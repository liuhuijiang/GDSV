{"project": "qemu", "commit_id": "90e496386fe7fd32c189561f846b7913f95b8cf4", "target": 0, "func": "static TCGv_i64 read_fp_dreg(DisasContext *s, int reg)\n\n{\n\n    TCGv_i64 v = tcg_temp_new_i64();\n\n\n\n    tcg_gen_ld_i64(v, cpu_env, fp_reg_offset(reg, MO_64));\n\n    return v;\n\n}\n", "idx": 21720}
{"project": "qemu", "commit_id": "2e4109de8e589beecd69996ee14f24021b991c0d", "target": 0, "func": "static int vfio_connect_container(VFIOGroup *group, AddressSpace *as)\n\n{\n\n    VFIOContainer *container;\n\n    int ret, fd;\n\n    VFIOAddressSpace *space;\n\n\n\n    space = vfio_get_address_space(as);\n\n\n\n    QLIST_FOREACH(container, &space->containers, next) {\n\n        if (!ioctl(group->fd, VFIO_GROUP_SET_CONTAINER, &container->fd)) {\n\n            group->container = container;\n\n            QLIST_INSERT_HEAD(&container->group_list, group, container_next);\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    fd = qemu_open(\"/dev/vfio/vfio\", O_RDWR);\n\n    if (fd < 0) {\n\n        error_report(\"vfio: failed to open /dev/vfio/vfio: %m\");\n\n        ret = -errno;\n\n        goto put_space_exit;\n\n    }\n\n\n\n    ret = ioctl(fd, VFIO_GET_API_VERSION);\n\n    if (ret != VFIO_API_VERSION) {\n\n        error_report(\"vfio: supported vfio version: %d, \"\n\n                     \"reported version: %d\", VFIO_API_VERSION, ret);\n\n        ret = -EINVAL;\n\n        goto close_fd_exit;\n\n    }\n\n\n\n    container = g_malloc0(sizeof(*container));\n\n    container->space = space;\n\n    container->fd = fd;\n\n    if (ioctl(fd, VFIO_CHECK_EXTENSION, VFIO_TYPE1_IOMMU) ||\n\n        ioctl(fd, VFIO_CHECK_EXTENSION, VFIO_TYPE1v2_IOMMU)) {\n\n        bool v2 = !!ioctl(fd, VFIO_CHECK_EXTENSION, VFIO_TYPE1v2_IOMMU);\n\n        struct vfio_iommu_type1_info info;\n\n\n\n        ret = ioctl(group->fd, VFIO_GROUP_SET_CONTAINER, &fd);\n\n        if (ret) {\n\n            error_report(\"vfio: failed to set group container: %m\");\n\n            ret = -errno;\n\n            goto free_container_exit;\n\n        }\n\n\n\n        container->iommu_type = v2 ? VFIO_TYPE1v2_IOMMU : VFIO_TYPE1_IOMMU;\n\n        ret = ioctl(fd, VFIO_SET_IOMMU, container->iommu_type);\n\n        if (ret) {\n\n            error_report(\"vfio: failed to set iommu for container: %m\");\n\n            ret = -errno;\n\n            goto free_container_exit;\n\n        }\n\n\n\n        /*\n\n         * FIXME: This assumes that a Type1 IOMMU can map any 64-bit\n\n         * IOVA whatsoever.  That's not actually true, but the current\n\n         * kernel interface doesn't tell us what it can map, and the\n\n         * existing Type1 IOMMUs generally support any IOVA we're\n\n         * going to actually try in practice.\n\n         */\n\n        info.argsz = sizeof(info);\n\n        ret = ioctl(fd, VFIO_IOMMU_GET_INFO, &info);\n\n        /* Ignore errors */\n\n        if (ret || !(info.flags & VFIO_IOMMU_INFO_PGSIZES)) {\n\n            /* Assume 4k IOVA page size */\n\n            info.iova_pgsizes = 4096;\n\n        }\n\n        vfio_host_win_add(container, 0, (hwaddr)-1, info.iova_pgsizes);\n\n    } else if (ioctl(fd, VFIO_CHECK_EXTENSION, VFIO_SPAPR_TCE_IOMMU) ||\n\n               ioctl(fd, VFIO_CHECK_EXTENSION, VFIO_SPAPR_TCE_v2_IOMMU)) {\n\n        struct vfio_iommu_spapr_tce_info info;\n\n        bool v2 = !!ioctl(fd, VFIO_CHECK_EXTENSION, VFIO_SPAPR_TCE_v2_IOMMU);\n\n\n\n        ret = ioctl(group->fd, VFIO_GROUP_SET_CONTAINER, &fd);\n\n        if (ret) {\n\n            error_report(\"vfio: failed to set group container: %m\");\n\n            ret = -errno;\n\n            goto free_container_exit;\n\n        }\n\n        container->iommu_type =\n\n            v2 ? VFIO_SPAPR_TCE_v2_IOMMU : VFIO_SPAPR_TCE_IOMMU;\n\n        ret = ioctl(fd, VFIO_SET_IOMMU, container->iommu_type);\n\n        if (ret) {\n\n            error_report(\"vfio: failed to set iommu for container: %m\");\n\n            ret = -errno;\n\n            goto free_container_exit;\n\n        }\n\n\n\n        /*\n\n         * The host kernel code implementing VFIO_IOMMU_DISABLE is called\n\n         * when container fd is closed so we do not call it explicitly\n\n         * in this file.\n\n         */\n\n        if (!v2) {\n\n            ret = ioctl(fd, VFIO_IOMMU_ENABLE);\n\n            if (ret) {\n\n                error_report(\"vfio: failed to enable container: %m\");\n\n                ret = -errno;\n\n                goto free_container_exit;\n\n            }\n\n        } else {\n\n            container->prereg_listener = vfio_prereg_listener;\n\n\n\n            memory_listener_register(&container->prereg_listener,\n\n                                     &address_space_memory);\n\n            if (container->error) {\n\n                memory_listener_unregister(&container->prereg_listener);\n\n                error_report(\"vfio: RAM memory listener initialization failed for container\");\n\n                goto free_container_exit;\n\n            }\n\n        }\n\n\n\n        /*\n\n         * This only considers the host IOMMU's 32-bit window.  At\n\n         * some point we need to add support for the optional 64-bit\n\n         * window and dynamic windows\n\n         */\n\n        info.argsz = sizeof(info);\n\n        ret = ioctl(fd, VFIO_IOMMU_SPAPR_TCE_GET_INFO, &info);\n\n        if (ret) {\n\n            error_report(\"vfio: VFIO_IOMMU_SPAPR_TCE_GET_INFO failed: %m\");\n\n            ret = -errno;\n\n            if (v2) {\n\n                memory_listener_unregister(&container->prereg_listener);\n\n            }\n\n            goto free_container_exit;\n\n        }\n\n\n\n        /* The default table uses 4K pages */\n\n        vfio_host_win_add(container, info.dma32_window_start,\n\n                          info.dma32_window_start +\n\n                          info.dma32_window_size - 1,\n\n                          0x1000);\n\n    } else {\n\n        error_report(\"vfio: No available IOMMU models\");\n\n        ret = -EINVAL;\n\n        goto free_container_exit;\n\n    }\n\n\n\n    container->listener = vfio_memory_listener;\n\n\n\n    memory_listener_register(&container->listener, container->space->as);\n\n\n\n    if (container->error) {\n\n        ret = container->error;\n\n        error_report(\"vfio: memory listener initialization failed for container\");\n\n        goto listener_release_exit;\n\n    }\n\n\n\n    container->initialized = true;\n\n\n\n    QLIST_INIT(&container->group_list);\n\n    QLIST_INSERT_HEAD(&space->containers, container, next);\n\n\n\n    group->container = container;\n\n    QLIST_INSERT_HEAD(&container->group_list, group, container_next);\n\n\n\n    return 0;\n\nlistener_release_exit:\n\n    vfio_listener_release(container);\n\n\n\nfree_container_exit:\n\n    g_free(container);\n\n\n\nclose_fd_exit:\n\n    close(fd);\n\n\n\nput_space_exit:\n\n    vfio_put_address_space(space);\n\n\n\n    return ret;\n\n}\n", "idx": 21721}
{"project": "qemu", "commit_id": "ee951a37d8873bff7aa58e23222dfd984111b6cb", "target": 0, "func": "static void pci_piix_init_ports(PCIIDEState *d) {\n\n    int i;\n\n    struct {\n\n        int iobase;\n\n        int iobase2;\n\n        int isairq;\n\n    } port_info[] = {\n\n        {0x1f0, 0x3f6, 14},\n\n        {0x170, 0x376, 15},\n\n    };\n\n\n\n    for (i = 0; i < 2; i++) {\n\n        ide_bus_new(&d->bus[i], &d->dev.qdev, i);\n\n        ide_init_ioport(&d->bus[i], port_info[i].iobase, port_info[i].iobase2);\n\n        ide_init2(&d->bus[i], isa_reserve_irq(port_info[i].isairq));\n\n\n\n        bmdma_init(&d->bus[i], &d->bmdma[i]);\n\n        d->bmdma[i].bus = &d->bus[i];\n\n        qemu_add_vm_change_state_handler(d->bus[i].dma->ops->restart_cb,\n\n                                         &d->bmdma[i].dma);\n\n    }\n\n}\n", "idx": 21722}
{"project": "qemu", "commit_id": "de13d2161473d02ae97ec0f8e4503147554892dd", "target": 0, "func": "static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)\n\n{\n\n    VirtIOS390Bus *bus;\n\n    int dev_len;\n\n\n\n    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);\n\n    dev->vdev = vdev;\n\n    dev->dev_offs = bus->dev_offs;\n\n    dev->feat_len = sizeof(uint32_t); /* always keep 32 bits features */\n\n\n\n    dev_len = VIRTIO_DEV_OFFS_CONFIG;\n\n    dev_len += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;\n\n    dev_len += dev->feat_len * 2;\n\n    dev_len += virtio_bus_get_vdev_config_len(&dev->bus);\n\n\n\n    bus->dev_offs += dev_len;\n\n\n\n    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,\n\n                                                      dev->host_features);\n\n    s390_virtio_device_sync(dev);\n\n    s390_virtio_reset_idx(dev);\n\n    if (dev->qdev.hotplugged) {\n\n        S390CPU *cpu = s390_cpu_addr2state(0);\n\n        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 21723}
{"project": "qemu", "commit_id": "3acace1333d6b75628fe6e6786ad3cd2db766f0e", "target": 0, "func": "void load_seg(int seg_reg, int selector)\n\n{\n\n    SegmentCache *sc;\n\n    SegmentDescriptorTable *dt;\n\n    int index;\n\n    uint32_t e1, e2;\n\n    uint8_t *ptr;\n\n\n\n    env->segs[seg_reg] = selector;\n\n    sc = &env->seg_cache[seg_reg];\n\n    if (env->eflags & VM_MASK) {\n\n        sc->base = (void *)(selector << 4);\n\n        sc->limit = 0xffff;\n\n        sc->seg_32bit = 0;\n\n    } else {\n\n        if (selector & 0x4)\n\n            dt = &env->ldt;\n\n        else\n\n            dt = &env->gdt;\n\n        index = selector & ~7;\n\n        if ((index + 7) > dt->limit)\n\n            raise_exception_err(EXCP0D_GPF, selector);\n\n        ptr = dt->base + index;\n\n        e1 = ldl(ptr);\n\n        e2 = ldl(ptr + 4);\n\n        sc->base = (void *)((e1 >> 16) | ((e2 & 0xff) << 16) | (e2 & 0xff000000));\n\n        sc->limit = (e1 & 0xffff) | (e2 & 0x000f0000);\n\n        if (e2 & (1 << 23))\n\n            sc->limit = (sc->limit << 12) | 0xfff;\n\n        sc->seg_32bit = (e2 >> 22) & 1;\n\n#if 0\n\n        fprintf(logfile, \"load_seg: sel=0x%04x base=0x%08lx limit=0x%08lx seg_32bit=%d\\n\", \n\n                selector, (unsigned long)sc->base, sc->limit, sc->seg_32bit);\n\n#endif\n\n    }\n\n}\n", "idx": 21724}
{"project": "qemu", "commit_id": "40119effc5c36dbd0ca19ca85a5897d5b3d37d6d", "target": 0, "func": "static BlockBackend *blockdev_init(const char *file, QDict *bs_opts,\n\n                                   Error **errp)\n\n{\n\n    const char *buf;\n\n    int bdrv_flags = 0;\n\n    int on_read_error, on_write_error;\n\n    bool account_invalid, account_failed;\n\n    const char *stats_intervals;\n\n    BlockBackend *blk;\n\n    BlockDriverState *bs;\n\n    ThrottleConfig cfg;\n\n    int snapshot = 0;\n\n    Error *error = NULL;\n\n    QemuOpts *opts;\n\n    const char *id;\n\n    bool has_driver_specific_opts;\n\n    BlockdevDetectZeroesOptions detect_zeroes =\n\n        BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF;\n\n    const char *throttling_group = NULL;\n\n\n\n    /* Check common options by copying from bs_opts to opts, all other options\n\n     * stay in bs_opts for processing by bdrv_open(). */\n\n    id = qdict_get_try_str(bs_opts, \"id\");\n\n    opts = qemu_opts_create(&qemu_common_drive_opts, id, 1, &error);\n\n    if (error) {\n\n        error_propagate(errp, error);\n\n        goto err_no_opts;\n\n    }\n\n\n\n    qemu_opts_absorb_qdict(opts, bs_opts, &error);\n\n    if (error) {\n\n        error_propagate(errp, error);\n\n        goto early_err;\n\n    }\n\n\n\n    if (id) {\n\n        qdict_del(bs_opts, \"id\");\n\n    }\n\n\n\n    has_driver_specific_opts = !!qdict_size(bs_opts);\n\n\n\n    /* extract parameters */\n\n    snapshot = qemu_opt_get_bool(opts, \"snapshot\", 0);\n\n\n\n    account_invalid = qemu_opt_get_bool(opts, \"stats-account-invalid\", true);\n\n    account_failed = qemu_opt_get_bool(opts, \"stats-account-failed\", true);\n\n\n\n    stats_intervals = qemu_opt_get(opts, \"stats-intervals\");\n\n\n\n    extract_common_blockdev_options(opts, &bdrv_flags, &throttling_group, &cfg,\n\n                                    &detect_zeroes, &error);\n\n    if (error) {\n\n        error_propagate(errp, error);\n\n        goto early_err;\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"format\")) != NULL) {\n\n        if (is_help_option(buf)) {\n\n            error_printf(\"Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            error_printf(\"\\n\");\n\n            goto early_err;\n\n        }\n\n\n\n        if (qdict_haskey(bs_opts, \"driver\")) {\n\n            error_setg(errp, \"Cannot specify both 'driver' and 'format'\");\n\n            goto early_err;\n\n        }\n\n        qdict_put(bs_opts, \"driver\", qstring_from_str(buf));\n\n    }\n\n\n\n    on_write_error = BLOCKDEV_ON_ERROR_ENOSPC;\n\n    if ((buf = qemu_opt_get(opts, \"werror\")) != NULL) {\n\n        on_write_error = parse_block_error_action(buf, 0, &error);\n\n        if (error) {\n\n            error_propagate(errp, error);\n\n            goto early_err;\n\n        }\n\n    }\n\n\n\n    on_read_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    if ((buf = qemu_opt_get(opts, \"rerror\")) != NULL) {\n\n        on_read_error = parse_block_error_action(buf, 1, &error);\n\n        if (error) {\n\n            error_propagate(errp, error);\n\n            goto early_err;\n\n        }\n\n    }\n\n\n\n    if (snapshot) {\n\n        /* always use cache=unsafe with snapshot */\n\n        bdrv_flags &= ~BDRV_O_CACHE_MASK;\n\n        bdrv_flags |= (BDRV_O_SNAPSHOT|BDRV_O_CACHE_WB|BDRV_O_NO_FLUSH);\n\n    }\n\n\n\n    /* init */\n\n    if ((!file || !*file) && !has_driver_specific_opts) {\n\n        BlockBackendRootState *blk_rs;\n\n\n\n        blk = blk_new(qemu_opts_id(opts), errp);\n\n        if (!blk) {\n\n            goto early_err;\n\n        }\n\n\n\n        blk_rs = blk_get_root_state(blk);\n\n        blk_rs->open_flags    = bdrv_flags;\n\n        blk_rs->read_only     = !(bdrv_flags & BDRV_O_RDWR);\n\n        blk_rs->detect_zeroes = detect_zeroes;\n\n\n\n        if (throttle_enabled(&cfg)) {\n\n            if (!throttling_group) {\n\n                throttling_group = blk_name(blk);\n\n            }\n\n            blk_rs->throttle_group = g_strdup(throttling_group);\n\n            blk_rs->throttle_state = throttle_group_incref(throttling_group);\n\n            blk_rs->throttle_state->cfg = cfg;\n\n        }\n\n\n\n        QDECREF(bs_opts);\n\n    } else {\n\n        if (file && !*file) {\n\n            file = NULL;\n\n        }\n\n\n\n        blk = blk_new_open(qemu_opts_id(opts), file, NULL, bs_opts, bdrv_flags,\n\n                           errp);\n\n        if (!blk) {\n\n            goto err_no_bs_opts;\n\n        }\n\n        bs = blk_bs(blk);\n\n\n\n        bs->detect_zeroes = detect_zeroes;\n\n\n\n        /* disk I/O throttling */\n\n        if (throttle_enabled(&cfg)) {\n\n            if (!throttling_group) {\n\n                throttling_group = blk_name(blk);\n\n            }\n\n            bdrv_io_limits_enable(bs, throttling_group);\n\n            bdrv_set_io_limits(bs, &cfg);\n\n        }\n\n\n\n        if (bdrv_key_required(bs)) {\n\n            autostart = 0;\n\n        }\n\n\n\n        block_acct_init(blk_get_stats(blk), account_invalid, account_failed);\n\n\n\n        if (stats_intervals) {\n\n            char **intervals = g_strsplit(stats_intervals, \":\", 0);\n\n            unsigned i;\n\n\n\n            if (*stats_intervals == '\\0') {\n\n                error_setg(&error, \"stats-intervals can't have an empty value\");\n\n            }\n\n\n\n            for (i = 0; !error && intervals[i] != NULL; i++) {\n\n                unsigned long long val;\n\n                if (parse_uint_full(intervals[i], &val, 10) == 0 &&\n\n                    val > 0 && val <= UINT_MAX) {\n\n                    block_acct_add_interval(blk_get_stats(blk), val);\n\n                } else {\n\n                    error_setg(&error, \"Invalid interval length: '%s'\",\n\n                               intervals[i]);\n\n                }\n\n            }\n\n\n\n            g_strfreev(intervals);\n\n\n\n            if (error) {\n\n                error_propagate(errp, error);\n\n                blk_unref(blk);\n\n                blk = NULL;\n\n                goto err_no_bs_opts;\n\n            }\n\n        }\n\n    }\n\n\n\n    blk_set_on_error(blk, on_read_error, on_write_error);\n\n\n\nerr_no_bs_opts:\n\n    qemu_opts_del(opts);\n\n    return blk;\n\n\n\nearly_err:\n\n    qemu_opts_del(opts);\n\nerr_no_opts:\n\n    QDECREF(bs_opts);\n\n    return NULL;\n\n}\n", "idx": 21725}
{"project": "qemu", "commit_id": "c89e91a76b361feaa09a48c20e6d18ae92ad0b4a", "target": 0, "func": "static int add_calxeda_midway_xgmac_fdt_node(SysBusDevice *sbdev, void *opaque)\n\n{\n\n    PlatformBusFDTData *data = opaque;\n\n    PlatformBusDevice *pbus = data->pbus;\n\n    void *fdt = data->fdt;\n\n    const char *parent_node = data->pbus_node_name;\n\n    int compat_str_len, i, ret = -1;\n\n    char *nodename;\n\n    uint32_t *irq_attr, *reg_attr;\n\n    uint64_t mmio_base, irq_number;\n\n    VFIOPlatformDevice *vdev = VFIO_PLATFORM_DEVICE(sbdev);\n\n    VFIODevice *vbasedev = &vdev->vbasedev;\n\n\n\n    mmio_base = platform_bus_get_mmio_addr(pbus, sbdev, 0);\n\n    nodename = g_strdup_printf(\"%s/%s@%\" PRIx64, parent_node,\n\n                               vbasedev->name, mmio_base);\n\n    qemu_fdt_add_subnode(fdt, nodename);\n\n\n\n    compat_str_len = strlen(vdev->compat) + 1;\n\n    qemu_fdt_setprop(fdt, nodename, \"compatible\",\n\n                          vdev->compat, compat_str_len);\n\n\n\n    qemu_fdt_setprop(fdt, nodename, \"dma-coherent\", \"\", 0);\n\n\n\n    reg_attr = g_new(uint32_t, vbasedev->num_regions * 2);\n\n    for (i = 0; i < vbasedev->num_regions; i++) {\n\n        mmio_base = platform_bus_get_mmio_addr(pbus, sbdev, i);\n\n        reg_attr[2 * i] = cpu_to_be32(mmio_base);\n\n        reg_attr[2 * i + 1] = cpu_to_be32(\n\n                                memory_region_size(&vdev->regions[i]->mem));\n\n    }\n\n    ret = qemu_fdt_setprop(fdt, nodename, \"reg\", reg_attr,\n\n                           vbasedev->num_regions * 2 * sizeof(uint32_t));\n\n    if (ret) {\n\n        error_report(\"could not set reg property of node %s\", nodename);\n\n        goto fail_reg;\n\n    }\n\n\n\n    irq_attr = g_new(uint32_t, vbasedev->num_irqs * 3);\n\n    for (i = 0; i < vbasedev->num_irqs; i++) {\n\n        irq_number = platform_bus_get_irqn(pbus, sbdev , i)\n\n                         + data->irq_start;\n\n        irq_attr[3 * i] = cpu_to_be32(GIC_FDT_IRQ_TYPE_SPI);\n\n        irq_attr[3 * i + 1] = cpu_to_be32(irq_number);\n\n        irq_attr[3 * i + 2] = cpu_to_be32(GIC_FDT_IRQ_FLAGS_LEVEL_HI);\n\n    }\n\n    ret = qemu_fdt_setprop(fdt, nodename, \"interrupts\",\n\n                     irq_attr, vbasedev->num_irqs * 3 * sizeof(uint32_t));\n\n    if (ret) {\n\n        error_report(\"could not set interrupts property of node %s\",\n\n                     nodename);\n\n    }\n\n    g_free(irq_attr);\n\nfail_reg:\n\n    g_free(reg_attr);\n\n    g_free(nodename);\n\n    return ret;\n\n}\n", "idx": 21726}
{"project": "qemu", "commit_id": "09e68369a88d7de0f988972bf28eec1b80cc47f9", "target": 0, "func": "static QObject *qmp_input_get_object(QmpInputVisitor *qiv,\n\n                                     const char *name,\n\n                                     bool consume, Error **errp)\n\n{\n\n    StackObject *tos;\n\n    QObject *qobj;\n\n    QObject *ret;\n\n\n\n    if (QSLIST_EMPTY(&qiv->stack)) {\n\n        /* Starting at root, name is ignored. */\n\n        assert(qiv->root);\n\n        return qiv->root;\n\n    }\n\n\n\n    /* We are in a container; find the next element. */\n\n    tos = QSLIST_FIRST(&qiv->stack);\n\n    qobj = tos->obj;\n\n    assert(qobj);\n\n\n\n    if (qobject_type(qobj) == QTYPE_QDICT) {\n\n        assert(name);\n\n        ret = qdict_get(qobject_to_qdict(qobj), name);\n\n        if (tos->h && consume && ret) {\n\n            bool removed = g_hash_table_remove(tos->h, name);\n\n            assert(removed);\n\n        }\n\n        if (!ret) {\n\n            error_setg(errp, QERR_MISSING_PARAMETER, name);\n\n        }\n\n    } else {\n\n        assert(qobject_type(qobj) == QTYPE_QLIST);\n\n        assert(!name);\n\n        ret = qlist_entry_obj(tos->entry);\n\n        assert(ret);\n\n        if (consume) {\n\n            tos->entry = qlist_next(tos->entry);\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 21728}
{"project": "qemu", "commit_id": "46c5874e9cd752ed8ded31af03472edd8fc3efc1", "target": 0, "func": "static void rtas_ibm_set_slot_reset(PowerPCCPU *cpu,\n\n                                    sPAPREnvironment *spapr,\n\n                                    uint32_t token, uint32_t nargs,\n\n                                    target_ulong args, uint32_t nret,\n\n                                    target_ulong rets)\n\n{\n\n    sPAPRPHBState *sphb;\n\n    sPAPRPHBClass *spc;\n\n    uint32_t option;\n\n    uint64_t buid;\n\n    int ret;\n\n\n\n    if ((nargs != 4) || (nret != 1)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    buid = ((uint64_t)rtas_ld(args, 1) << 32) | rtas_ld(args, 2);\n\n    option = rtas_ld(args, 3);\n\n    sphb = find_phb(spapr, buid);\n\n    if (!sphb) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb);\n\n    if (!spc->eeh_reset) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    ret = spc->eeh_reset(sphb, option);\n\n    rtas_st(rets, 0, ret);\n\n    return;\n\n\n\nparam_error_exit:\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n", "idx": 21729}
{"project": "qemu", "commit_id": "496272a7018ba01aa2b87a1a5ed866ff85133401", "target": 0, "func": "int pp_check(int key, int pp, int nx)\n\n{\n\n    int access;\n\n\n\n    /* Compute access rights */\n\n    /* When pp is 3/7, the result is undefined. Set it to noaccess */\n\n    access = 0;\n\n    if (key == 0) {\n\n        switch (pp) {\n\n        case 0x0:\n\n        case 0x1:\n\n        case 0x2:\n\n            access |= PAGE_WRITE;\n\n            /* No break here */\n\n        case 0x3:\n\n        case 0x6:\n\n            access |= PAGE_READ;\n\n            break;\n\n        }\n\n    } else {\n\n        switch (pp) {\n\n        case 0x0:\n\n        case 0x6:\n\n            access = 0;\n\n            break;\n\n        case 0x1:\n\n        case 0x3:\n\n            access = PAGE_READ;\n\n            break;\n\n        case 0x2:\n\n            access = PAGE_READ | PAGE_WRITE;\n\n            break;\n\n        }\n\n    }\n\n    if (nx == 0) {\n\n        access |= PAGE_EXEC;\n\n    }\n\n\n\n    return access;\n\n}\n", "idx": 21730}
{"project": "qemu", "commit_id": "0a75601853c00f3729fa62c49ec0d4bb1e3d9bc1", "target": 0, "func": "RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,\n\n                                  void (*resized)(const char*,\n\n                                                  uint64_t length,\n\n                                                  void *host),\n\n                                  void *host, bool resizeable,\n\n                                  MemoryRegion *mr, Error **errp)\n\n{\n\n    RAMBlock *new_block;\n\n    Error *local_err = NULL;\n\n\n\n    size = HOST_PAGE_ALIGN(size);\n\n    max_size = HOST_PAGE_ALIGN(max_size);\n\n    new_block = g_malloc0(sizeof(*new_block));\n\n    new_block->mr = mr;\n\n    new_block->resized = resized;\n\n    new_block->used_length = size;\n\n    new_block->max_length = max_size;\n\n    assert(max_size >= size);\n\n    new_block->fd = -1;\n\n    new_block->host = host;\n\n    if (host) {\n\n        new_block->flags |= RAM_PREALLOC;\n\n    }\n\n    if (resizeable) {\n\n        new_block->flags |= RAM_RESIZEABLE;\n\n    }\n\n    ram_block_add(new_block, &local_err);\n\n    if (local_err) {\n\n        g_free(new_block);\n\n        error_propagate(errp, local_err);\n\n        return NULL;\n\n    }\n\n    mr->ram_block = new_block;\n\n    return new_block;\n\n}\n", "idx": 21731}
{"project": "qemu", "commit_id": "59f39a47411ab6007a592555dc639aa9753f8d23", "target": 0, "func": "static bool check_section_footer(QEMUFile *f, SaveStateEntry *se)\n\n{\n\n    uint8_t read_mark;\n\n    uint32_t read_section_id;\n\n\n\n    if (skip_section_footers) {\n\n        /* No footer to check */\n\n        return true;\n\n    }\n\n\n\n    read_mark = qemu_get_byte(f);\n\n\n\n    if (read_mark != QEMU_VM_SECTION_FOOTER) {\n\n        error_report(\"Missing section footer for %s\", se->idstr);\n\n        return false;\n\n    }\n\n\n\n    read_section_id = qemu_get_be32(f);\n\n    if (read_section_id != se->section_id) {\n\n        error_report(\"Mismatched section id in footer for %s -\"\n\n                     \" read 0x%x expected 0x%x\",\n\n                     se->idstr, read_section_id, se->section_id);\n\n        return false;\n\n    }\n\n\n\n    /* All good */\n\n    return true;\n\n}\n", "idx": 21732}
{"project": "qemu", "commit_id": "9dbbc748d671c70599101836cd1c2719d92f3017", "target": 0, "func": "static int disas_neon_data_insn(DisasContext *s, uint32_t insn)\n\n{\n\n    int op;\n\n    int q;\n\n    int rd, rn, rm;\n\n    int size;\n\n    int shift;\n\n    int pass;\n\n    int count;\n\n    int pairwise;\n\n    int u;\n\n    uint32_t imm, mask;\n\n    TCGv_i32 tmp, tmp2, tmp3, tmp4, tmp5;\n\n    TCGv_i64 tmp64;\n\n\n\n    /* FIXME: this access check should not take precedence over UNDEF\n\n     * for invalid encodings; we will generate incorrect syndrome information\n\n     * for attempts to execute invalid vfp/neon encodings with FP disabled.\n\n     */\n\n    if (!s->cpacr_fpen) {\n\n        gen_exception_insn(s, 4, EXCP_UDEF,\n\n                           syn_fp_access_trap(1, 0xe, s->thumb),\n\n                           default_exception_el(s));\n\n        return 0;\n\n    }\n\n\n\n    if (!s->vfp_enabled)\n\n      return 1;\n\n    q = (insn & (1 << 6)) != 0;\n\n    u = (insn >> 24) & 1;\n\n    VFP_DREG_D(rd, insn);\n\n    VFP_DREG_N(rn, insn);\n\n    VFP_DREG_M(rm, insn);\n\n    size = (insn >> 20) & 3;\n\n    if ((insn & (1 << 23)) == 0) {\n\n        /* Three register same length.  */\n\n        op = ((insn >> 7) & 0x1e) | ((insn >> 4) & 1);\n\n        /* Catch invalid op and bad size combinations: UNDEF */\n\n        if ((neon_3r_sizes[op] & (1 << size)) == 0) {\n\n            return 1;\n\n        }\n\n        /* All insns of this form UNDEF for either this condition or the\n\n         * superset of cases \"Q==1\"; we catch the latter later.\n\n         */\n\n        if (q && ((rd | rn | rm) & 1)) {\n\n            return 1;\n\n        }\n\n        /*\n\n         * The SHA-1/SHA-256 3-register instructions require special treatment\n\n         * here, as their size field is overloaded as an op type selector, and\n\n         * they all consume their input in a single pass.\n\n         */\n\n        if (op == NEON_3R_SHA) {\n\n            if (!q) {\n\n                return 1;\n\n            }\n\n            if (!u) { /* SHA-1 */\n\n                if (!arm_dc_feature(s, ARM_FEATURE_V8_SHA1)) {\n\n                    return 1;\n\n                }\n\n                tmp = tcg_const_i32(rd);\n\n                tmp2 = tcg_const_i32(rn);\n\n                tmp3 = tcg_const_i32(rm);\n\n                tmp4 = tcg_const_i32(size);\n\n                gen_helper_crypto_sha1_3reg(cpu_env, tmp, tmp2, tmp3, tmp4);\n\n                tcg_temp_free_i32(tmp4);\n\n            } else { /* SHA-256 */\n\n                if (!arm_dc_feature(s, ARM_FEATURE_V8_SHA256) || size == 3) {\n\n                    return 1;\n\n                }\n\n                tmp = tcg_const_i32(rd);\n\n                tmp2 = tcg_const_i32(rn);\n\n                tmp3 = tcg_const_i32(rm);\n\n                switch (size) {\n\n                case 0:\n\n                    gen_helper_crypto_sha256h(cpu_env, tmp, tmp2, tmp3);\n\n                    break;\n\n                case 1:\n\n                    gen_helper_crypto_sha256h2(cpu_env, tmp, tmp2, tmp3);\n\n                    break;\n\n                case 2:\n\n                    gen_helper_crypto_sha256su1(cpu_env, tmp, tmp2, tmp3);\n\n                    break;\n\n                }\n\n            }\n\n            tcg_temp_free_i32(tmp);\n\n            tcg_temp_free_i32(tmp2);\n\n            tcg_temp_free_i32(tmp3);\n\n            return 0;\n\n        }\n\n        if (size == 3 && op != NEON_3R_LOGIC) {\n\n            /* 64-bit element instructions. */\n\n            for (pass = 0; pass < (q ? 2 : 1); pass++) {\n\n                neon_load_reg64(cpu_V0, rn + pass);\n\n                neon_load_reg64(cpu_V1, rm + pass);\n\n                switch (op) {\n\n                case NEON_3R_VQADD:\n\n                    if (u) {\n\n                        gen_helper_neon_qadd_u64(cpu_V0, cpu_env,\n\n                                                 cpu_V0, cpu_V1);\n\n                    } else {\n\n                        gen_helper_neon_qadd_s64(cpu_V0, cpu_env,\n\n                                                 cpu_V0, cpu_V1);\n\n                    }\n\n                    break;\n\n                case NEON_3R_VQSUB:\n\n                    if (u) {\n\n                        gen_helper_neon_qsub_u64(cpu_V0, cpu_env,\n\n                                                 cpu_V0, cpu_V1);\n\n                    } else {\n\n                        gen_helper_neon_qsub_s64(cpu_V0, cpu_env,\n\n                                                 cpu_V0, cpu_V1);\n\n                    }\n\n                    break;\n\n                case NEON_3R_VSHL:\n\n                    if (u) {\n\n                        gen_helper_neon_shl_u64(cpu_V0, cpu_V1, cpu_V0);\n\n                    } else {\n\n                        gen_helper_neon_shl_s64(cpu_V0, cpu_V1, cpu_V0);\n\n                    }\n\n                    break;\n\n                case NEON_3R_VQSHL:\n\n                    if (u) {\n\n                        gen_helper_neon_qshl_u64(cpu_V0, cpu_env,\n\n                                                 cpu_V1, cpu_V0);\n\n                    } else {\n\n                        gen_helper_neon_qshl_s64(cpu_V0, cpu_env,\n\n                                                 cpu_V1, cpu_V0);\n\n                    }\n\n                    break;\n\n                case NEON_3R_VRSHL:\n\n                    if (u) {\n\n                        gen_helper_neon_rshl_u64(cpu_V0, cpu_V1, cpu_V0);\n\n                    } else {\n\n                        gen_helper_neon_rshl_s64(cpu_V0, cpu_V1, cpu_V0);\n\n                    }\n\n                    break;\n\n                case NEON_3R_VQRSHL:\n\n                    if (u) {\n\n                        gen_helper_neon_qrshl_u64(cpu_V0, cpu_env,\n\n                                                  cpu_V1, cpu_V0);\n\n                    } else {\n\n                        gen_helper_neon_qrshl_s64(cpu_V0, cpu_env,\n\n                                                  cpu_V1, cpu_V0);\n\n                    }\n\n                    break;\n\n                case NEON_3R_VADD_VSUB:\n\n                    if (u) {\n\n                        tcg_gen_sub_i64(CPU_V001);\n\n                    } else {\n\n                        tcg_gen_add_i64(CPU_V001);\n\n                    }\n\n                    break;\n\n                default:\n\n                    abort();\n\n                }\n\n                neon_store_reg64(cpu_V0, rd + pass);\n\n            }\n\n            return 0;\n\n        }\n\n        pairwise = 0;\n\n        switch (op) {\n\n        case NEON_3R_VSHL:\n\n        case NEON_3R_VQSHL:\n\n        case NEON_3R_VRSHL:\n\n        case NEON_3R_VQRSHL:\n\n            {\n\n                int rtmp;\n\n                /* Shift instruction operands are reversed.  */\n\n                rtmp = rn;\n\n                rn = rm;\n\n                rm = rtmp;\n\n            }\n\n            break;\n\n        case NEON_3R_VPADD:\n\n            if (u) {\n\n                return 1;\n\n            }\n\n            /* Fall through */\n\n        case NEON_3R_VPMAX:\n\n        case NEON_3R_VPMIN:\n\n            pairwise = 1;\n\n            break;\n\n        case NEON_3R_FLOAT_ARITH:\n\n            pairwise = (u && size < 2); /* if VPADD (float) */\n\n            break;\n\n        case NEON_3R_FLOAT_MINMAX:\n\n            pairwise = u; /* if VPMIN/VPMAX (float) */\n\n            break;\n\n        case NEON_3R_FLOAT_CMP:\n\n            if (!u && size) {\n\n                /* no encoding for U=0 C=1x */\n\n                return 1;\n\n            }\n\n            break;\n\n        case NEON_3R_FLOAT_ACMP:\n\n            if (!u) {\n\n                return 1;\n\n            }\n\n            break;\n\n        case NEON_3R_FLOAT_MISC:\n\n            /* VMAXNM/VMINNM in ARMv8 */\n\n            if (u && !arm_dc_feature(s, ARM_FEATURE_V8)) {\n\n                return 1;\n\n            }\n\n            break;\n\n        case NEON_3R_VMUL:\n\n            if (u && (size != 0)) {\n\n                /* UNDEF on invalid size for polynomial subcase */\n\n                return 1;\n\n            }\n\n            break;\n\n        case NEON_3R_VFM:\n\n            if (!arm_dc_feature(s, ARM_FEATURE_VFP4) || u) {\n\n                return 1;\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n\n\n        if (pairwise && q) {\n\n            /* All the pairwise insns UNDEF if Q is set */\n\n            return 1;\n\n        }\n\n\n\n        for (pass = 0; pass < (q ? 4 : 2); pass++) {\n\n\n\n        if (pairwise) {\n\n            /* Pairwise.  */\n\n            if (pass < 1) {\n\n                tmp = neon_load_reg(rn, 0);\n\n                tmp2 = neon_load_reg(rn, 1);\n\n            } else {\n\n                tmp = neon_load_reg(rm, 0);\n\n                tmp2 = neon_load_reg(rm, 1);\n\n            }\n\n        } else {\n\n            /* Elementwise.  */\n\n            tmp = neon_load_reg(rn, pass);\n\n            tmp2 = neon_load_reg(rm, pass);\n\n        }\n\n        switch (op) {\n\n        case NEON_3R_VHADD:\n\n            GEN_NEON_INTEGER_OP(hadd);\n\n            break;\n\n        case NEON_3R_VQADD:\n\n            GEN_NEON_INTEGER_OP_ENV(qadd);\n\n            break;\n\n        case NEON_3R_VRHADD:\n\n            GEN_NEON_INTEGER_OP(rhadd);\n\n            break;\n\n        case NEON_3R_LOGIC: /* Logic ops.  */\n\n            switch ((u << 2) | size) {\n\n            case 0: /* VAND */\n\n                tcg_gen_and_i32(tmp, tmp, tmp2);\n\n                break;\n\n            case 1: /* BIC */\n\n                tcg_gen_andc_i32(tmp, tmp, tmp2);\n\n                break;\n\n            case 2: /* VORR */\n\n                tcg_gen_or_i32(tmp, tmp, tmp2);\n\n                break;\n\n            case 3: /* VORN */\n\n                tcg_gen_orc_i32(tmp, tmp, tmp2);\n\n                break;\n\n            case 4: /* VEOR */\n\n                tcg_gen_xor_i32(tmp, tmp, tmp2);\n\n                break;\n\n            case 5: /* VBSL */\n\n                tmp3 = neon_load_reg(rd, pass);\n\n                gen_neon_bsl(tmp, tmp, tmp2, tmp3);\n\n                tcg_temp_free_i32(tmp3);\n\n                break;\n\n            case 6: /* VBIT */\n\n                tmp3 = neon_load_reg(rd, pass);\n\n                gen_neon_bsl(tmp, tmp, tmp3, tmp2);\n\n                tcg_temp_free_i32(tmp3);\n\n                break;\n\n            case 7: /* VBIF */\n\n                tmp3 = neon_load_reg(rd, pass);\n\n                gen_neon_bsl(tmp, tmp3, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp3);\n\n                break;\n\n            }\n\n            break;\n\n        case NEON_3R_VHSUB:\n\n            GEN_NEON_INTEGER_OP(hsub);\n\n            break;\n\n        case NEON_3R_VQSUB:\n\n            GEN_NEON_INTEGER_OP_ENV(qsub);\n\n            break;\n\n        case NEON_3R_VCGT:\n\n            GEN_NEON_INTEGER_OP(cgt);\n\n            break;\n\n        case NEON_3R_VCGE:\n\n            GEN_NEON_INTEGER_OP(cge);\n\n            break;\n\n        case NEON_3R_VSHL:\n\n            GEN_NEON_INTEGER_OP(shl);\n\n            break;\n\n        case NEON_3R_VQSHL:\n\n            GEN_NEON_INTEGER_OP_ENV(qshl);\n\n            break;\n\n        case NEON_3R_VRSHL:\n\n            GEN_NEON_INTEGER_OP(rshl);\n\n            break;\n\n        case NEON_3R_VQRSHL:\n\n            GEN_NEON_INTEGER_OP_ENV(qrshl);\n\n            break;\n\n        case NEON_3R_VMAX:\n\n            GEN_NEON_INTEGER_OP(max);\n\n            break;\n\n        case NEON_3R_VMIN:\n\n            GEN_NEON_INTEGER_OP(min);\n\n            break;\n\n        case NEON_3R_VABD:\n\n            GEN_NEON_INTEGER_OP(abd);\n\n            break;\n\n        case NEON_3R_VABA:\n\n            GEN_NEON_INTEGER_OP(abd);\n\n            tcg_temp_free_i32(tmp2);\n\n            tmp2 = neon_load_reg(rd, pass);\n\n            gen_neon_add(size, tmp, tmp2);\n\n            break;\n\n        case NEON_3R_VADD_VSUB:\n\n            if (!u) { /* VADD */\n\n                gen_neon_add(size, tmp, tmp2);\n\n            } else { /* VSUB */\n\n                switch (size) {\n\n                case 0: gen_helper_neon_sub_u8(tmp, tmp, tmp2); break;\n\n                case 1: gen_helper_neon_sub_u16(tmp, tmp, tmp2); break;\n\n                case 2: tcg_gen_sub_i32(tmp, tmp, tmp2); break;\n\n                default: abort();\n\n                }\n\n            }\n\n            break;\n\n        case NEON_3R_VTST_VCEQ:\n\n            if (!u) { /* VTST */\n\n                switch (size) {\n\n                case 0: gen_helper_neon_tst_u8(tmp, tmp, tmp2); break;\n\n                case 1: gen_helper_neon_tst_u16(tmp, tmp, tmp2); break;\n\n                case 2: gen_helper_neon_tst_u32(tmp, tmp, tmp2); break;\n\n                default: abort();\n\n                }\n\n            } else { /* VCEQ */\n\n                switch (size) {\n\n                case 0: gen_helper_neon_ceq_u8(tmp, tmp, tmp2); break;\n\n                case 1: gen_helper_neon_ceq_u16(tmp, tmp, tmp2); break;\n\n                case 2: gen_helper_neon_ceq_u32(tmp, tmp, tmp2); break;\n\n                default: abort();\n\n                }\n\n            }\n\n            break;\n\n        case NEON_3R_VML: /* VMLA, VMLAL, VMLS,VMLSL */\n\n            switch (size) {\n\n            case 0: gen_helper_neon_mul_u8(tmp, tmp, tmp2); break;\n\n            case 1: gen_helper_neon_mul_u16(tmp, tmp, tmp2); break;\n\n            case 2: tcg_gen_mul_i32(tmp, tmp, tmp2); break;\n\n            default: abort();\n\n            }\n\n            tcg_temp_free_i32(tmp2);\n\n            tmp2 = neon_load_reg(rd, pass);\n\n            if (u) { /* VMLS */\n\n                gen_neon_rsb(size, tmp, tmp2);\n\n            } else { /* VMLA */\n\n                gen_neon_add(size, tmp, tmp2);\n\n            }\n\n            break;\n\n        case NEON_3R_VMUL:\n\n            if (u) { /* polynomial */\n\n                gen_helper_neon_mul_p8(tmp, tmp, tmp2);\n\n            } else { /* Integer */\n\n                switch (size) {\n\n                case 0: gen_helper_neon_mul_u8(tmp, tmp, tmp2); break;\n\n                case 1: gen_helper_neon_mul_u16(tmp, tmp, tmp2); break;\n\n                case 2: tcg_gen_mul_i32(tmp, tmp, tmp2); break;\n\n                default: abort();\n\n                }\n\n            }\n\n            break;\n\n        case NEON_3R_VPMAX:\n\n            GEN_NEON_INTEGER_OP(pmax);\n\n            break;\n\n        case NEON_3R_VPMIN:\n\n            GEN_NEON_INTEGER_OP(pmin);\n\n            break;\n\n        case NEON_3R_VQDMULH_VQRDMULH: /* Multiply high.  */\n\n            if (!u) { /* VQDMULH */\n\n                switch (size) {\n\n                case 1:\n\n                    gen_helper_neon_qdmulh_s16(tmp, cpu_env, tmp, tmp2);\n\n                    break;\n\n                case 2:\n\n                    gen_helper_neon_qdmulh_s32(tmp, cpu_env, tmp, tmp2);\n\n                    break;\n\n                default: abort();\n\n                }\n\n            } else { /* VQRDMULH */\n\n                switch (size) {\n\n                case 1:\n\n                    gen_helper_neon_qrdmulh_s16(tmp, cpu_env, tmp, tmp2);\n\n                    break;\n\n                case 2:\n\n                    gen_helper_neon_qrdmulh_s32(tmp, cpu_env, tmp, tmp2);\n\n                    break;\n\n                default: abort();\n\n                }\n\n            }\n\n            break;\n\n        case NEON_3R_VPADD:\n\n            switch (size) {\n\n            case 0: gen_helper_neon_padd_u8(tmp, tmp, tmp2); break;\n\n            case 1: gen_helper_neon_padd_u16(tmp, tmp, tmp2); break;\n\n            case 2: tcg_gen_add_i32(tmp, tmp, tmp2); break;\n\n            default: abort();\n\n            }\n\n            break;\n\n        case NEON_3R_FLOAT_ARITH: /* Floating point arithmetic. */\n\n        {\n\n            TCGv_ptr fpstatus = get_fpstatus_ptr(1);\n\n            switch ((u << 2) | size) {\n\n            case 0: /* VADD */\n\n            case 4: /* VPADD */\n\n                gen_helper_vfp_adds(tmp, tmp, tmp2, fpstatus);\n\n                break;\n\n            case 2: /* VSUB */\n\n                gen_helper_vfp_subs(tmp, tmp, tmp2, fpstatus);\n\n                break;\n\n            case 6: /* VABD */\n\n                gen_helper_neon_abd_f32(tmp, tmp, tmp2, fpstatus);\n\n                break;\n\n            default:\n\n                abort();\n\n            }\n\n            tcg_temp_free_ptr(fpstatus);\n\n            break;\n\n        }\n\n        case NEON_3R_FLOAT_MULTIPLY:\n\n        {\n\n            TCGv_ptr fpstatus = get_fpstatus_ptr(1);\n\n            gen_helper_vfp_muls(tmp, tmp, tmp2, fpstatus);\n\n            if (!u) {\n\n                tcg_temp_free_i32(tmp2);\n\n                tmp2 = neon_load_reg(rd, pass);\n\n                if (size == 0) {\n\n                    gen_helper_vfp_adds(tmp, tmp, tmp2, fpstatus);\n\n                } else {\n\n                    gen_helper_vfp_subs(tmp, tmp2, tmp, fpstatus);\n\n                }\n\n            }\n\n            tcg_temp_free_ptr(fpstatus);\n\n            break;\n\n        }\n\n        case NEON_3R_FLOAT_CMP:\n\n        {\n\n            TCGv_ptr fpstatus = get_fpstatus_ptr(1);\n\n            if (!u) {\n\n                gen_helper_neon_ceq_f32(tmp, tmp, tmp2, fpstatus);\n\n            } else {\n\n                if (size == 0) {\n\n                    gen_helper_neon_cge_f32(tmp, tmp, tmp2, fpstatus);\n\n                } else {\n\n                    gen_helper_neon_cgt_f32(tmp, tmp, tmp2, fpstatus);\n\n                }\n\n            }\n\n            tcg_temp_free_ptr(fpstatus);\n\n            break;\n\n        }\n\n        case NEON_3R_FLOAT_ACMP:\n\n        {\n\n            TCGv_ptr fpstatus = get_fpstatus_ptr(1);\n\n            if (size == 0) {\n\n                gen_helper_neon_acge_f32(tmp, tmp, tmp2, fpstatus);\n\n            } else {\n\n                gen_helper_neon_acgt_f32(tmp, tmp, tmp2, fpstatus);\n\n            }\n\n            tcg_temp_free_ptr(fpstatus);\n\n            break;\n\n        }\n\n        case NEON_3R_FLOAT_MINMAX:\n\n        {\n\n            TCGv_ptr fpstatus = get_fpstatus_ptr(1);\n\n            if (size == 0) {\n\n                gen_helper_vfp_maxs(tmp, tmp, tmp2, fpstatus);\n\n            } else {\n\n                gen_helper_vfp_mins(tmp, tmp, tmp2, fpstatus);\n\n            }\n\n            tcg_temp_free_ptr(fpstatus);\n\n            break;\n\n        }\n\n        case NEON_3R_FLOAT_MISC:\n\n            if (u) {\n\n                /* VMAXNM/VMINNM */\n\n                TCGv_ptr fpstatus = get_fpstatus_ptr(1);\n\n                if (size == 0) {\n\n                    gen_helper_vfp_maxnums(tmp, tmp, tmp2, fpstatus);\n\n                } else {\n\n                    gen_helper_vfp_minnums(tmp, tmp, tmp2, fpstatus);\n\n                }\n\n                tcg_temp_free_ptr(fpstatus);\n\n            } else {\n\n                if (size == 0) {\n\n                    gen_helper_recps_f32(tmp, tmp, tmp2, cpu_env);\n\n                } else {\n\n                    gen_helper_rsqrts_f32(tmp, tmp, tmp2, cpu_env);\n\n              }\n\n            }\n\n            break;\n\n        case NEON_3R_VFM:\n\n        {\n\n            /* VFMA, VFMS: fused multiply-add */\n\n            TCGv_ptr fpstatus = get_fpstatus_ptr(1);\n\n            TCGv_i32 tmp3 = neon_load_reg(rd, pass);\n\n            if (size) {\n\n                /* VFMS */\n\n                gen_helper_vfp_negs(tmp, tmp);\n\n            }\n\n            gen_helper_vfp_muladds(tmp, tmp, tmp2, tmp3, fpstatus);\n\n            tcg_temp_free_i32(tmp3);\n\n            tcg_temp_free_ptr(fpstatus);\n\n            break;\n\n        }\n\n        default:\n\n            abort();\n\n        }\n\n        tcg_temp_free_i32(tmp2);\n\n\n\n        /* Save the result.  For elementwise operations we can put it\n\n           straight into the destination register.  For pairwise operations\n\n           we have to be careful to avoid clobbering the source operands.  */\n\n        if (pairwise && rd == rm) {\n\n            neon_store_scratch(pass, tmp);\n\n        } else {\n\n            neon_store_reg(rd, pass, tmp);\n\n        }\n\n\n\n        } /* for pass */\n\n        if (pairwise && rd == rm) {\n\n            for (pass = 0; pass < (q ? 4 : 2); pass++) {\n\n                tmp = neon_load_scratch(pass);\n\n                neon_store_reg(rd, pass, tmp);\n\n            }\n\n        }\n\n        /* End of 3 register same size operations.  */\n\n    } else if (insn & (1 << 4)) {\n\n        if ((insn & 0x00380080) != 0) {\n\n            /* Two registers and shift.  */\n\n            op = (insn >> 8) & 0xf;\n\n            if (insn & (1 << 7)) {\n\n                /* 64-bit shift. */\n\n                if (op > 7) {\n\n                    return 1;\n\n                }\n\n                size = 3;\n\n            } else {\n\n                size = 2;\n\n                while ((insn & (1 << (size + 19))) == 0)\n\n                    size--;\n\n            }\n\n            shift = (insn >> 16) & ((1 << (3 + size)) - 1);\n\n            /* To avoid excessive duplication of ops we implement shift\n\n               by immediate using the variable shift operations.  */\n\n            if (op < 8) {\n\n                /* Shift by immediate:\n\n                   VSHR, VSRA, VRSHR, VRSRA, VSRI, VSHL, VQSHL, VQSHLU.  */\n\n                if (q && ((rd | rm) & 1)) {\n\n                    return 1;\n\n                }\n\n                if (!u && (op == 4 || op == 6)) {\n\n                    return 1;\n\n                }\n\n                /* Right shifts are encoded as N - shift, where N is the\n\n                   element size in bits.  */\n\n                if (op <= 4)\n\n                    shift = shift - (1 << (size + 3));\n\n                if (size == 3) {\n\n                    count = q + 1;\n\n                } else {\n\n                    count = q ? 4: 2;\n\n                }\n\n                switch (size) {\n\n                case 0:\n\n                    imm = (uint8_t) shift;\n\n                    imm |= imm << 8;\n\n                    imm |= imm << 16;\n\n                    break;\n\n                case 1:\n\n                    imm = (uint16_t) shift;\n\n                    imm |= imm << 16;\n\n                    break;\n\n                case 2:\n\n                case 3:\n\n                    imm = shift;\n\n                    break;\n\n                default:\n\n                    abort();\n\n                }\n\n\n\n                for (pass = 0; pass < count; pass++) {\n\n                    if (size == 3) {\n\n                        neon_load_reg64(cpu_V0, rm + pass);\n\n                        tcg_gen_movi_i64(cpu_V1, imm);\n\n                        switch (op) {\n\n                        case 0:  /* VSHR */\n\n                        case 1:  /* VSRA */\n\n                            if (u)\n\n                                gen_helper_neon_shl_u64(cpu_V0, cpu_V0, cpu_V1);\n\n                            else\n\n                                gen_helper_neon_shl_s64(cpu_V0, cpu_V0, cpu_V1);\n\n                            break;\n\n                        case 2: /* VRSHR */\n\n                        case 3: /* VRSRA */\n\n                            if (u)\n\n                                gen_helper_neon_rshl_u64(cpu_V0, cpu_V0, cpu_V1);\n\n                            else\n\n                                gen_helper_neon_rshl_s64(cpu_V0, cpu_V0, cpu_V1);\n\n                            break;\n\n                        case 4: /* VSRI */\n\n                        case 5: /* VSHL, VSLI */\n\n                            gen_helper_neon_shl_u64(cpu_V0, cpu_V0, cpu_V1);\n\n                            break;\n\n                        case 6: /* VQSHLU */\n\n                            gen_helper_neon_qshlu_s64(cpu_V0, cpu_env,\n\n                                                      cpu_V0, cpu_V1);\n\n                            break;\n\n                        case 7: /* VQSHL */\n\n                            if (u) {\n\n                                gen_helper_neon_qshl_u64(cpu_V0, cpu_env,\n\n                                                         cpu_V0, cpu_V1);\n\n                            } else {\n\n                                gen_helper_neon_qshl_s64(cpu_V0, cpu_env,\n\n                                                         cpu_V0, cpu_V1);\n\n                            }\n\n                            break;\n\n                        }\n\n                        if (op == 1 || op == 3) {\n\n                            /* Accumulate.  */\n\n                            neon_load_reg64(cpu_V1, rd + pass);\n\n                            tcg_gen_add_i64(cpu_V0, cpu_V0, cpu_V1);\n\n                        } else if (op == 4 || (op == 5 && u)) {\n\n                            /* Insert */\n\n                            neon_load_reg64(cpu_V1, rd + pass);\n\n                            uint64_t mask;\n\n                            if (shift < -63 || shift > 63) {\n\n                                mask = 0;\n\n                            } else {\n\n                                if (op == 4) {\n\n                                    mask = 0xffffffffffffffffull >> -shift;\n\n                                } else {\n\n                                    mask = 0xffffffffffffffffull << shift;\n\n                                }\n\n                            }\n\n                            tcg_gen_andi_i64(cpu_V1, cpu_V1, ~mask);\n\n                            tcg_gen_or_i64(cpu_V0, cpu_V0, cpu_V1);\n\n                        }\n\n                        neon_store_reg64(cpu_V0, rd + pass);\n\n                    } else { /* size < 3 */\n\n                        /* Operands in T0 and T1.  */\n\n                        tmp = neon_load_reg(rm, pass);\n\n                        tmp2 = tcg_temp_new_i32();\n\n                        tcg_gen_movi_i32(tmp2, imm);\n\n                        switch (op) {\n\n                        case 0:  /* VSHR */\n\n                        case 1:  /* VSRA */\n\n                            GEN_NEON_INTEGER_OP(shl);\n\n                            break;\n\n                        case 2: /* VRSHR */\n\n                        case 3: /* VRSRA */\n\n                            GEN_NEON_INTEGER_OP(rshl);\n\n                            break;\n\n                        case 4: /* VSRI */\n\n                        case 5: /* VSHL, VSLI */\n\n                            switch (size) {\n\n                            case 0: gen_helper_neon_shl_u8(tmp, tmp, tmp2); break;\n\n                            case 1: gen_helper_neon_shl_u16(tmp, tmp, tmp2); break;\n\n                            case 2: gen_helper_neon_shl_u32(tmp, tmp, tmp2); break;\n\n                            default: abort();\n\n                            }\n\n                            break;\n\n                        case 6: /* VQSHLU */\n\n                            switch (size) {\n\n                            case 0:\n\n                                gen_helper_neon_qshlu_s8(tmp, cpu_env,\n\n                                                         tmp, tmp2);\n\n                                break;\n\n                            case 1:\n\n                                gen_helper_neon_qshlu_s16(tmp, cpu_env,\n\n                                                          tmp, tmp2);\n\n                                break;\n\n                            case 2:\n\n                                gen_helper_neon_qshlu_s32(tmp, cpu_env,\n\n                                                          tmp, tmp2);\n\n                                break;\n\n                            default:\n\n                                abort();\n\n                            }\n\n                            break;\n\n                        case 7: /* VQSHL */\n\n                            GEN_NEON_INTEGER_OP_ENV(qshl);\n\n                            break;\n\n                        }\n\n                        tcg_temp_free_i32(tmp2);\n\n\n\n                        if (op == 1 || op == 3) {\n\n                            /* Accumulate.  */\n\n                            tmp2 = neon_load_reg(rd, pass);\n\n                            gen_neon_add(size, tmp, tmp2);\n\n                            tcg_temp_free_i32(tmp2);\n\n                        } else if (op == 4 || (op == 5 && u)) {\n\n                            /* Insert */\n\n                            switch (size) {\n\n                            case 0:\n\n                                if (op == 4)\n\n                                    mask = 0xff >> -shift;\n\n                                else\n\n                                    mask = (uint8_t)(0xff << shift);\n\n                                mask |= mask << 8;\n\n                                mask |= mask << 16;\n\n                                break;\n\n                            case 1:\n\n                                if (op == 4)\n\n                                    mask = 0xffff >> -shift;\n\n                                else\n\n                                    mask = (uint16_t)(0xffff << shift);\n\n                                mask |= mask << 16;\n\n                                break;\n\n                            case 2:\n\n                                if (shift < -31 || shift > 31) {\n\n                                    mask = 0;\n\n                                } else {\n\n                                    if (op == 4)\n\n                                        mask = 0xffffffffu >> -shift;\n\n                                    else\n\n                                        mask = 0xffffffffu << shift;\n\n                                }\n\n                                break;\n\n                            default:\n\n                                abort();\n\n                            }\n\n                            tmp2 = neon_load_reg(rd, pass);\n\n                            tcg_gen_andi_i32(tmp, tmp, mask);\n\n                            tcg_gen_andi_i32(tmp2, tmp2, ~mask);\n\n                            tcg_gen_or_i32(tmp, tmp, tmp2);\n\n                            tcg_temp_free_i32(tmp2);\n\n                        }\n\n                        neon_store_reg(rd, pass, tmp);\n\n                    }\n\n                } /* for pass */\n\n            } else if (op < 10) {\n\n                /* Shift by immediate and narrow:\n\n                   VSHRN, VRSHRN, VQSHRN, VQRSHRN.  */\n\n                int input_unsigned = (op == 8) ? !u : u;\n\n                if (rm & 1) {\n\n                    return 1;\n\n                }\n\n                shift = shift - (1 << (size + 3));\n\n                size++;\n\n                if (size == 3) {\n\n                    tmp64 = tcg_const_i64(shift);\n\n                    neon_load_reg64(cpu_V0, rm);\n\n                    neon_load_reg64(cpu_V1, rm + 1);\n\n                    for (pass = 0; pass < 2; pass++) {\n\n                        TCGv_i64 in;\n\n                        if (pass == 0) {\n\n                            in = cpu_V0;\n\n                        } else {\n\n                            in = cpu_V1;\n\n                        }\n\n                        if (q) {\n\n                            if (input_unsigned) {\n\n                                gen_helper_neon_rshl_u64(cpu_V0, in, tmp64);\n\n                            } else {\n\n                                gen_helper_neon_rshl_s64(cpu_V0, in, tmp64);\n\n                            }\n\n                        } else {\n\n                            if (input_unsigned) {\n\n                                gen_helper_neon_shl_u64(cpu_V0, in, tmp64);\n\n                            } else {\n\n                                gen_helper_neon_shl_s64(cpu_V0, in, tmp64);\n\n                            }\n\n                        }\n\n                        tmp = tcg_temp_new_i32();\n\n                        gen_neon_narrow_op(op == 8, u, size - 1, tmp, cpu_V0);\n\n                        neon_store_reg(rd, pass, tmp);\n\n                    } /* for pass */\n\n                    tcg_temp_free_i64(tmp64);\n\n                } else {\n\n                    if (size == 1) {\n\n                        imm = (uint16_t)shift;\n\n                        imm |= imm << 16;\n\n                    } else {\n\n                        /* size == 2 */\n\n                        imm = (uint32_t)shift;\n\n                    }\n\n                    tmp2 = tcg_const_i32(imm);\n\n                    tmp4 = neon_load_reg(rm + 1, 0);\n\n                    tmp5 = neon_load_reg(rm + 1, 1);\n\n                    for (pass = 0; pass < 2; pass++) {\n\n                        if (pass == 0) {\n\n                            tmp = neon_load_reg(rm, 0);\n\n                        } else {\n\n                            tmp = tmp4;\n\n                        }\n\n                        gen_neon_shift_narrow(size, tmp, tmp2, q,\n\n                                              input_unsigned);\n\n                        if (pass == 0) {\n\n                            tmp3 = neon_load_reg(rm, 1);\n\n                        } else {\n\n                            tmp3 = tmp5;\n\n                        }\n\n                        gen_neon_shift_narrow(size, tmp3, tmp2, q,\n\n                                              input_unsigned);\n\n                        tcg_gen_concat_i32_i64(cpu_V0, tmp, tmp3);\n\n                        tcg_temp_free_i32(tmp);\n\n                        tcg_temp_free_i32(tmp3);\n\n                        tmp = tcg_temp_new_i32();\n\n                        gen_neon_narrow_op(op == 8, u, size - 1, tmp, cpu_V0);\n\n                        neon_store_reg(rd, pass, tmp);\n\n                    } /* for pass */\n\n                    tcg_temp_free_i32(tmp2);\n\n                }\n\n            } else if (op == 10) {\n\n                /* VSHLL, VMOVL */\n\n                if (q || (rd & 1)) {\n\n                    return 1;\n\n                }\n\n                tmp = neon_load_reg(rm, 0);\n\n                tmp2 = neon_load_reg(rm, 1);\n\n                for (pass = 0; pass < 2; pass++) {\n\n                    if (pass == 1)\n\n                        tmp = tmp2;\n\n\n\n                    gen_neon_widen(cpu_V0, tmp, size, u);\n\n\n\n                    if (shift != 0) {\n\n                        /* The shift is less than the width of the source\n\n                           type, so we can just shift the whole register.  */\n\n                        tcg_gen_shli_i64(cpu_V0, cpu_V0, shift);\n\n                        /* Widen the result of shift: we need to clear\n\n                         * the potential overflow bits resulting from\n\n                         * left bits of the narrow input appearing as\n\n                         * right bits of left the neighbour narrow\n\n                         * input.  */\n\n                        if (size < 2 || !u) {\n\n                            uint64_t imm64;\n\n                            if (size == 0) {\n\n                                imm = (0xffu >> (8 - shift));\n\n                                imm |= imm << 16;\n\n                            } else if (size == 1) {\n\n                                imm = 0xffff >> (16 - shift);\n\n                            } else {\n\n                                /* size == 2 */\n\n                                imm = 0xffffffff >> (32 - shift);\n\n                            }\n\n                            if (size < 2) {\n\n                                imm64 = imm | (((uint64_t)imm) << 32);\n\n                            } else {\n\n                                imm64 = imm;\n\n                            }\n\n                            tcg_gen_andi_i64(cpu_V0, cpu_V0, ~imm64);\n\n                        }\n\n                    }\n\n                    neon_store_reg64(cpu_V0, rd + pass);\n\n                }\n\n            } else if (op >= 14) {\n\n                /* VCVT fixed-point.  */\n\n                if (!(insn & (1 << 21)) || (q && ((rd | rm) & 1))) {\n\n                    return 1;\n\n                }\n\n                /* We have already masked out the must-be-1 top bit of imm6,\n\n                 * hence this 32-shift where the ARM ARM has 64-imm6.\n\n                 */\n\n                shift = 32 - shift;\n\n                for (pass = 0; pass < (q ? 4 : 2); pass++) {\n\n                    tcg_gen_ld_f32(cpu_F0s, cpu_env, neon_reg_offset(rm, pass));\n\n                    if (!(op & 1)) {\n\n                        if (u)\n\n                            gen_vfp_ulto(0, shift, 1);\n\n                        else\n\n                            gen_vfp_slto(0, shift, 1);\n\n                    } else {\n\n                        if (u)\n\n                            gen_vfp_toul(0, shift, 1);\n\n                        else\n\n                            gen_vfp_tosl(0, shift, 1);\n\n                    }\n\n                    tcg_gen_st_f32(cpu_F0s, cpu_env, neon_reg_offset(rd, pass));\n\n                }\n\n            } else {\n\n                return 1;\n\n            }\n\n        } else { /* (insn & 0x00380080) == 0 */\n\n            int invert;\n\n            if (q && (rd & 1)) {\n\n                return 1;\n\n            }\n\n\n\n            op = (insn >> 8) & 0xf;\n\n            /* One register and immediate.  */\n\n            imm = (u << 7) | ((insn >> 12) & 0x70) | (insn & 0xf);\n\n            invert = (insn & (1 << 5)) != 0;\n\n            /* Note that op = 2,3,4,5,6,7,10,11,12,13 imm=0 is UNPREDICTABLE.\n\n             * We choose to not special-case this and will behave as if a\n\n             * valid constant encoding of 0 had been given.\n\n             */\n\n            switch (op) {\n\n            case 0: case 1:\n\n                /* no-op */\n\n                break;\n\n            case 2: case 3:\n\n                imm <<= 8;\n\n                break;\n\n            case 4: case 5:\n\n                imm <<= 16;\n\n                break;\n\n            case 6: case 7:\n\n                imm <<= 24;\n\n                break;\n\n            case 8: case 9:\n\n                imm |= imm << 16;\n\n                break;\n\n            case 10: case 11:\n\n                imm = (imm << 8) | (imm << 24);\n\n                break;\n\n            case 12:\n\n                imm = (imm << 8) | 0xff;\n\n                break;\n\n            case 13:\n\n                imm = (imm << 16) | 0xffff;\n\n                break;\n\n            case 14:\n\n                imm |= (imm << 8) | (imm << 16) | (imm << 24);\n\n                if (invert)\n\n                    imm = ~imm;\n\n                break;\n\n            case 15:\n\n                if (invert) {\n\n                    return 1;\n\n                }\n\n                imm = ((imm & 0x80) << 24) | ((imm & 0x3f) << 19)\n\n                      | ((imm & 0x40) ? (0x1f << 25) : (1 << 30));\n\n                break;\n\n            }\n\n            if (invert)\n\n                imm = ~imm;\n\n\n\n            for (pass = 0; pass < (q ? 4 : 2); pass++) {\n\n                if (op & 1 && op < 12) {\n\n                    tmp = neon_load_reg(rd, pass);\n\n                    if (invert) {\n\n                        /* The immediate value has already been inverted, so\n\n                           BIC becomes AND.  */\n\n                        tcg_gen_andi_i32(tmp, tmp, imm);\n\n                    } else {\n\n                        tcg_gen_ori_i32(tmp, tmp, imm);\n\n                    }\n\n                } else {\n\n                    /* VMOV, VMVN.  */\n\n                    tmp = tcg_temp_new_i32();\n\n                    if (op == 14 && invert) {\n\n                        int n;\n\n                        uint32_t val;\n\n                        val = 0;\n\n                        for (n = 0; n < 4; n++) {\n\n                            if (imm & (1 << (n + (pass & 1) * 4)))\n\n                                val |= 0xff << (n * 8);\n\n                        }\n\n                        tcg_gen_movi_i32(tmp, val);\n\n                    } else {\n\n                        tcg_gen_movi_i32(tmp, imm);\n\n                    }\n\n                }\n\n                neon_store_reg(rd, pass, tmp);\n\n            }\n\n        }\n\n    } else { /* (insn & 0x00800010 == 0x00800000) */\n\n        if (size != 3) {\n\n            op = (insn >> 8) & 0xf;\n\n            if ((insn & (1 << 6)) == 0) {\n\n                /* Three registers of different lengths.  */\n\n                int src1_wide;\n\n                int src2_wide;\n\n                int prewiden;\n\n                /* undefreq: bit 0 : UNDEF if size == 0\n\n                 *           bit 1 : UNDEF if size == 1\n\n                 *           bit 2 : UNDEF if size == 2\n\n                 *           bit 3 : UNDEF if U == 1\n\n                 * Note that [2:0] set implies 'always UNDEF'\n\n                 */\n\n                int undefreq;\n\n                /* prewiden, src1_wide, src2_wide, undefreq */\n\n                static const int neon_3reg_wide[16][4] = {\n\n                    {1, 0, 0, 0}, /* VADDL */\n\n                    {1, 1, 0, 0}, /* VADDW */\n\n                    {1, 0, 0, 0}, /* VSUBL */\n\n                    {1, 1, 0, 0}, /* VSUBW */\n\n                    {0, 1, 1, 0}, /* VADDHN */\n\n                    {0, 0, 0, 0}, /* VABAL */\n\n                    {0, 1, 1, 0}, /* VSUBHN */\n\n                    {0, 0, 0, 0}, /* VABDL */\n\n                    {0, 0, 0, 0}, /* VMLAL */\n\n                    {0, 0, 0, 9}, /* VQDMLAL */\n\n                    {0, 0, 0, 0}, /* VMLSL */\n\n                    {0, 0, 0, 9}, /* VQDMLSL */\n\n                    {0, 0, 0, 0}, /* Integer VMULL */\n\n                    {0, 0, 0, 1}, /* VQDMULL */\n\n                    {0, 0, 0, 0xa}, /* Polynomial VMULL */\n\n                    {0, 0, 0, 7}, /* Reserved: always UNDEF */\n\n                };\n\n\n\n                prewiden = neon_3reg_wide[op][0];\n\n                src1_wide = neon_3reg_wide[op][1];\n\n                src2_wide = neon_3reg_wide[op][2];\n\n                undefreq = neon_3reg_wide[op][3];\n\n\n\n                if ((undefreq & (1 << size)) ||\n\n                    ((undefreq & 8) && u)) {\n\n                    return 1;\n\n                }\n\n                if ((src1_wide && (rn & 1)) ||\n\n                    (src2_wide && (rm & 1)) ||\n\n                    (!src2_wide && (rd & 1))) {\n\n                    return 1;\n\n                }\n\n\n\n                /* Handle VMULL.P64 (Polynomial 64x64 to 128 bit multiply)\n\n                 * outside the loop below as it only performs a single pass.\n\n                 */\n\n                if (op == 14 && size == 2) {\n\n                    TCGv_i64 tcg_rn, tcg_rm, tcg_rd;\n\n\n\n                    if (!arm_dc_feature(s, ARM_FEATURE_V8_PMULL)) {\n\n                        return 1;\n\n                    }\n\n                    tcg_rn = tcg_temp_new_i64();\n\n                    tcg_rm = tcg_temp_new_i64();\n\n                    tcg_rd = tcg_temp_new_i64();\n\n                    neon_load_reg64(tcg_rn, rn);\n\n                    neon_load_reg64(tcg_rm, rm);\n\n                    gen_helper_neon_pmull_64_lo(tcg_rd, tcg_rn, tcg_rm);\n\n                    neon_store_reg64(tcg_rd, rd);\n\n                    gen_helper_neon_pmull_64_hi(tcg_rd, tcg_rn, tcg_rm);\n\n                    neon_store_reg64(tcg_rd, rd + 1);\n\n                    tcg_temp_free_i64(tcg_rn);\n\n                    tcg_temp_free_i64(tcg_rm);\n\n                    tcg_temp_free_i64(tcg_rd);\n\n                    return 0;\n\n                }\n\n\n\n                /* Avoid overlapping operands.  Wide source operands are\n\n                   always aligned so will never overlap with wide\n\n                   destinations in problematic ways.  */\n\n                if (rd == rm && !src2_wide) {\n\n                    tmp = neon_load_reg(rm, 1);\n\n                    neon_store_scratch(2, tmp);\n\n                } else if (rd == rn && !src1_wide) {\n\n                    tmp = neon_load_reg(rn, 1);\n\n                    neon_store_scratch(2, tmp);\n\n                }\n\n                TCGV_UNUSED_I32(tmp3);\n\n                for (pass = 0; pass < 2; pass++) {\n\n                    if (src1_wide) {\n\n                        neon_load_reg64(cpu_V0, rn + pass);\n\n                        TCGV_UNUSED_I32(tmp);\n\n                    } else {\n\n                        if (pass == 1 && rd == rn) {\n\n                            tmp = neon_load_scratch(2);\n\n                        } else {\n\n                            tmp = neon_load_reg(rn, pass);\n\n                        }\n\n                        if (prewiden) {\n\n                            gen_neon_widen(cpu_V0, tmp, size, u);\n\n                        }\n\n                    }\n\n                    if (src2_wide) {\n\n                        neon_load_reg64(cpu_V1, rm + pass);\n\n                        TCGV_UNUSED_I32(tmp2);\n\n                    } else {\n\n                        if (pass == 1 && rd == rm) {\n\n                            tmp2 = neon_load_scratch(2);\n\n                        } else {\n\n                            tmp2 = neon_load_reg(rm, pass);\n\n                        }\n\n                        if (prewiden) {\n\n                            gen_neon_widen(cpu_V1, tmp2, size, u);\n\n                        }\n\n                    }\n\n                    switch (op) {\n\n                    case 0: case 1: case 4: /* VADDL, VADDW, VADDHN, VRADDHN */\n\n                        gen_neon_addl(size);\n\n                        break;\n\n                    case 2: case 3: case 6: /* VSUBL, VSUBW, VSUBHN, VRSUBHN */\n\n                        gen_neon_subl(size);\n\n                        break;\n\n                    case 5: case 7: /* VABAL, VABDL */\n\n                        switch ((size << 1) | u) {\n\n                        case 0:\n\n                            gen_helper_neon_abdl_s16(cpu_V0, tmp, tmp2);\n\n                            break;\n\n                        case 1:\n\n                            gen_helper_neon_abdl_u16(cpu_V0, tmp, tmp2);\n\n                            break;\n\n                        case 2:\n\n                            gen_helper_neon_abdl_s32(cpu_V0, tmp, tmp2);\n\n                            break;\n\n                        case 3:\n\n                            gen_helper_neon_abdl_u32(cpu_V0, tmp, tmp2);\n\n                            break;\n\n                        case 4:\n\n                            gen_helper_neon_abdl_s64(cpu_V0, tmp, tmp2);\n\n                            break;\n\n                        case 5:\n\n                            gen_helper_neon_abdl_u64(cpu_V0, tmp, tmp2);\n\n                            break;\n\n                        default: abort();\n\n                        }\n\n                        tcg_temp_free_i32(tmp2);\n\n                        tcg_temp_free_i32(tmp);\n\n                        break;\n\n                    case 8: case 9: case 10: case 11: case 12: case 13:\n\n                        /* VMLAL, VQDMLAL, VMLSL, VQDMLSL, VMULL, VQDMULL */\n\n                        gen_neon_mull(cpu_V0, tmp, tmp2, size, u);\n\n                        break;\n\n                    case 14: /* Polynomial VMULL */\n\n                        gen_helper_neon_mull_p8(cpu_V0, tmp, tmp2);\n\n                        tcg_temp_free_i32(tmp2);\n\n                        tcg_temp_free_i32(tmp);\n\n                        break;\n\n                    default: /* 15 is RESERVED: caught earlier  */\n\n                        abort();\n\n                    }\n\n                    if (op == 13) {\n\n                        /* VQDMULL */\n\n                        gen_neon_addl_saturate(cpu_V0, cpu_V0, size);\n\n                        neon_store_reg64(cpu_V0, rd + pass);\n\n                    } else if (op == 5 || (op >= 8 && op <= 11)) {\n\n                        /* Accumulate.  */\n\n                        neon_load_reg64(cpu_V1, rd + pass);\n\n                        switch (op) {\n\n                        case 10: /* VMLSL */\n\n                            gen_neon_negl(cpu_V0, size);\n\n                            /* Fall through */\n\n                        case 5: case 8: /* VABAL, VMLAL */\n\n                            gen_neon_addl(size);\n\n                            break;\n\n                        case 9: case 11: /* VQDMLAL, VQDMLSL */\n\n                            gen_neon_addl_saturate(cpu_V0, cpu_V0, size);\n\n                            if (op == 11) {\n\n                                gen_neon_negl(cpu_V0, size);\n\n                            }\n\n                            gen_neon_addl_saturate(cpu_V0, cpu_V1, size);\n\n                            break;\n\n                        default:\n\n                            abort();\n\n                        }\n\n                        neon_store_reg64(cpu_V0, rd + pass);\n\n                    } else if (op == 4 || op == 6) {\n\n                        /* Narrowing operation.  */\n\n                        tmp = tcg_temp_new_i32();\n\n                        if (!u) {\n\n                            switch (size) {\n\n                            case 0:\n\n                                gen_helper_neon_narrow_high_u8(tmp, cpu_V0);\n\n                                break;\n\n                            case 1:\n\n                                gen_helper_neon_narrow_high_u16(tmp, cpu_V0);\n\n                                break;\n\n                            case 2:\n\n                                tcg_gen_shri_i64(cpu_V0, cpu_V0, 32);\n\n                                tcg_gen_trunc_i64_i32(tmp, cpu_V0);\n\n                                break;\n\n                            default: abort();\n\n                            }\n\n                        } else {\n\n                            switch (size) {\n\n                            case 0:\n\n                                gen_helper_neon_narrow_round_high_u8(tmp, cpu_V0);\n\n                                break;\n\n                            case 1:\n\n                                gen_helper_neon_narrow_round_high_u16(tmp, cpu_V0);\n\n                                break;\n\n                            case 2:\n\n                                tcg_gen_addi_i64(cpu_V0, cpu_V0, 1u << 31);\n\n                                tcg_gen_shri_i64(cpu_V0, cpu_V0, 32);\n\n                                tcg_gen_trunc_i64_i32(tmp, cpu_V0);\n\n                                break;\n\n                            default: abort();\n\n                            }\n\n                        }\n\n                        if (pass == 0) {\n\n                            tmp3 = tmp;\n\n                        } else {\n\n                            neon_store_reg(rd, 0, tmp3);\n\n                            neon_store_reg(rd, 1, tmp);\n\n                        }\n\n                    } else {\n\n                        /* Write back the result.  */\n\n                        neon_store_reg64(cpu_V0, rd + pass);\n\n                    }\n\n                }\n\n            } else {\n\n                /* Two registers and a scalar. NB that for ops of this form\n\n                 * the ARM ARM labels bit 24 as Q, but it is in our variable\n\n                 * 'u', not 'q'.\n\n                 */\n\n                if (size == 0) {\n\n                    return 1;\n\n                }\n\n                switch (op) {\n\n                case 1: /* Float VMLA scalar */\n\n                case 5: /* Floating point VMLS scalar */\n\n                case 9: /* Floating point VMUL scalar */\n\n                    if (size == 1) {\n\n                        return 1;\n\n                    }\n\n                    /* fall through */\n\n                case 0: /* Integer VMLA scalar */\n\n                case 4: /* Integer VMLS scalar */\n\n                case 8: /* Integer VMUL scalar */\n\n                case 12: /* VQDMULH scalar */\n\n                case 13: /* VQRDMULH scalar */\n\n                    if (u && ((rd | rn) & 1)) {\n\n                        return 1;\n\n                    }\n\n                    tmp = neon_get_scalar(size, rm);\n\n                    neon_store_scratch(0, tmp);\n\n                    for (pass = 0; pass < (u ? 4 : 2); pass++) {\n\n                        tmp = neon_load_scratch(0);\n\n                        tmp2 = neon_load_reg(rn, pass);\n\n                        if (op == 12) {\n\n                            if (size == 1) {\n\n                                gen_helper_neon_qdmulh_s16(tmp, cpu_env, tmp, tmp2);\n\n                            } else {\n\n                                gen_helper_neon_qdmulh_s32(tmp, cpu_env, tmp, tmp2);\n\n                            }\n\n                        } else if (op == 13) {\n\n                            if (size == 1) {\n\n                                gen_helper_neon_qrdmulh_s16(tmp, cpu_env, tmp, tmp2);\n\n                            } else {\n\n                                gen_helper_neon_qrdmulh_s32(tmp, cpu_env, tmp, tmp2);\n\n                            }\n\n                        } else if (op & 1) {\n\n                            TCGv_ptr fpstatus = get_fpstatus_ptr(1);\n\n                            gen_helper_vfp_muls(tmp, tmp, tmp2, fpstatus);\n\n                            tcg_temp_free_ptr(fpstatus);\n\n                        } else {\n\n                            switch (size) {\n\n                            case 0: gen_helper_neon_mul_u8(tmp, tmp, tmp2); break;\n\n                            case 1: gen_helper_neon_mul_u16(tmp, tmp, tmp2); break;\n\n                            case 2: tcg_gen_mul_i32(tmp, tmp, tmp2); break;\n\n                            default: abort();\n\n                            }\n\n                        }\n\n                        tcg_temp_free_i32(tmp2);\n\n                        if (op < 8) {\n\n                            /* Accumulate.  */\n\n                            tmp2 = neon_load_reg(rd, pass);\n\n                            switch (op) {\n\n                            case 0:\n\n                                gen_neon_add(size, tmp, tmp2);\n\n                                break;\n\n                            case 1:\n\n                            {\n\n                                TCGv_ptr fpstatus = get_fpstatus_ptr(1);\n\n                                gen_helper_vfp_adds(tmp, tmp, tmp2, fpstatus);\n\n                                tcg_temp_free_ptr(fpstatus);\n\n                                break;\n\n                            }\n\n                            case 4:\n\n                                gen_neon_rsb(size, tmp, tmp2);\n\n                                break;\n\n                            case 5:\n\n                            {\n\n                                TCGv_ptr fpstatus = get_fpstatus_ptr(1);\n\n                                gen_helper_vfp_subs(tmp, tmp2, tmp, fpstatus);\n\n                                tcg_temp_free_ptr(fpstatus);\n\n                                break;\n\n                            }\n\n                            default:\n\n                                abort();\n\n                            }\n\n                            tcg_temp_free_i32(tmp2);\n\n                        }\n\n                        neon_store_reg(rd, pass, tmp);\n\n                    }\n\n                    break;\n\n                case 3: /* VQDMLAL scalar */\n\n                case 7: /* VQDMLSL scalar */\n\n                case 11: /* VQDMULL scalar */\n\n                    if (u == 1) {\n\n                        return 1;\n\n                    }\n\n                    /* fall through */\n\n                case 2: /* VMLAL sclar */\n\n                case 6: /* VMLSL scalar */\n\n                case 10: /* VMULL scalar */\n\n                    if (rd & 1) {\n\n                        return 1;\n\n                    }\n\n                    tmp2 = neon_get_scalar(size, rm);\n\n                    /* We need a copy of tmp2 because gen_neon_mull\n\n                     * deletes it during pass 0.  */\n\n                    tmp4 = tcg_temp_new_i32();\n\n                    tcg_gen_mov_i32(tmp4, tmp2);\n\n                    tmp3 = neon_load_reg(rn, 1);\n\n\n\n                    for (pass = 0; pass < 2; pass++) {\n\n                        if (pass == 0) {\n\n                            tmp = neon_load_reg(rn, 0);\n\n                        } else {\n\n                            tmp = tmp3;\n\n                            tmp2 = tmp4;\n\n                        }\n\n                        gen_neon_mull(cpu_V0, tmp, tmp2, size, u);\n\n                        if (op != 11) {\n\n                            neon_load_reg64(cpu_V1, rd + pass);\n\n                        }\n\n                        switch (op) {\n\n                        case 6:\n\n                            gen_neon_negl(cpu_V0, size);\n\n                            /* Fall through */\n\n                        case 2:\n\n                            gen_neon_addl(size);\n\n                            break;\n\n                        case 3: case 7:\n\n                            gen_neon_addl_saturate(cpu_V0, cpu_V0, size);\n\n                            if (op == 7) {\n\n                                gen_neon_negl(cpu_V0, size);\n\n                            }\n\n                            gen_neon_addl_saturate(cpu_V0, cpu_V1, size);\n\n                            break;\n\n                        case 10:\n\n                            /* no-op */\n\n                            break;\n\n                        case 11:\n\n                            gen_neon_addl_saturate(cpu_V0, cpu_V0, size);\n\n                            break;\n\n                        default:\n\n                            abort();\n\n                        }\n\n                        neon_store_reg64(cpu_V0, rd + pass);\n\n                    }\n\n\n\n\n\n                    break;\n\n                default: /* 14 and 15 are RESERVED */\n\n                    return 1;\n\n                }\n\n            }\n\n        } else { /* size == 3 */\n\n            if (!u) {\n\n                /* Extract.  */\n\n                imm = (insn >> 8) & 0xf;\n\n\n\n                if (imm > 7 && !q)\n\n                    return 1;\n\n\n\n                if (q && ((rd | rn | rm) & 1)) {\n\n                    return 1;\n\n                }\n\n\n\n                if (imm == 0) {\n\n                    neon_load_reg64(cpu_V0, rn);\n\n                    if (q) {\n\n                        neon_load_reg64(cpu_V1, rn + 1);\n\n                    }\n\n                } else if (imm == 8) {\n\n                    neon_load_reg64(cpu_V0, rn + 1);\n\n                    if (q) {\n\n                        neon_load_reg64(cpu_V1, rm);\n\n                    }\n\n                } else if (q) {\n\n                    tmp64 = tcg_temp_new_i64();\n\n                    if (imm < 8) {\n\n                        neon_load_reg64(cpu_V0, rn);\n\n                        neon_load_reg64(tmp64, rn + 1);\n\n                    } else {\n\n                        neon_load_reg64(cpu_V0, rn + 1);\n\n                        neon_load_reg64(tmp64, rm);\n\n                    }\n\n                    tcg_gen_shri_i64(cpu_V0, cpu_V0, (imm & 7) * 8);\n\n                    tcg_gen_shli_i64(cpu_V1, tmp64, 64 - ((imm & 7) * 8));\n\n                    tcg_gen_or_i64(cpu_V0, cpu_V0, cpu_V1);\n\n                    if (imm < 8) {\n\n                        neon_load_reg64(cpu_V1, rm);\n\n                    } else {\n\n                        neon_load_reg64(cpu_V1, rm + 1);\n\n                        imm -= 8;\n\n                    }\n\n                    tcg_gen_shli_i64(cpu_V1, cpu_V1, 64 - (imm * 8));\n\n                    tcg_gen_shri_i64(tmp64, tmp64, imm * 8);\n\n                    tcg_gen_or_i64(cpu_V1, cpu_V1, tmp64);\n\n                    tcg_temp_free_i64(tmp64);\n\n                } else {\n\n                    /* BUGFIX */\n\n                    neon_load_reg64(cpu_V0, rn);\n\n                    tcg_gen_shri_i64(cpu_V0, cpu_V0, imm * 8);\n\n                    neon_load_reg64(cpu_V1, rm);\n\n                    tcg_gen_shli_i64(cpu_V1, cpu_V1, 64 - (imm * 8));\n\n                    tcg_gen_or_i64(cpu_V0, cpu_V0, cpu_V1);\n\n                }\n\n                neon_store_reg64(cpu_V0, rd);\n\n                if (q) {\n\n                    neon_store_reg64(cpu_V1, rd + 1);\n\n                }\n\n            } else if ((insn & (1 << 11)) == 0) {\n\n                /* Two register misc.  */\n\n                op = ((insn >> 12) & 0x30) | ((insn >> 7) & 0xf);\n\n                size = (insn >> 18) & 3;\n\n                /* UNDEF for unknown op values and bad op-size combinations */\n\n                if ((neon_2rm_sizes[op] & (1 << size)) == 0) {\n\n                    return 1;\n\n                }\n\n                if ((op != NEON_2RM_VMOVN && op != NEON_2RM_VQMOVN) &&\n\n                    q && ((rm | rd) & 1)) {\n\n                    return 1;\n\n                }\n\n                switch (op) {\n\n                case NEON_2RM_VREV64:\n\n                    for (pass = 0; pass < (q ? 2 : 1); pass++) {\n\n                        tmp = neon_load_reg(rm, pass * 2);\n\n                        tmp2 = neon_load_reg(rm, pass * 2 + 1);\n\n                        switch (size) {\n\n                        case 0: tcg_gen_bswap32_i32(tmp, tmp); break;\n\n                        case 1: gen_swap_half(tmp); break;\n\n                        case 2: /* no-op */ break;\n\n                        default: abort();\n\n                        }\n\n                        neon_store_reg(rd, pass * 2 + 1, tmp);\n\n                        if (size == 2) {\n\n                            neon_store_reg(rd, pass * 2, tmp2);\n\n                        } else {\n\n                            switch (size) {\n\n                            case 0: tcg_gen_bswap32_i32(tmp2, tmp2); break;\n\n                            case 1: gen_swap_half(tmp2); break;\n\n                            default: abort();\n\n                            }\n\n                            neon_store_reg(rd, pass * 2, tmp2);\n\n                        }\n\n                    }\n\n                    break;\n\n                case NEON_2RM_VPADDL: case NEON_2RM_VPADDL_U:\n\n                case NEON_2RM_VPADAL: case NEON_2RM_VPADAL_U:\n\n                    for (pass = 0; pass < q + 1; pass++) {\n\n                        tmp = neon_load_reg(rm, pass * 2);\n\n                        gen_neon_widen(cpu_V0, tmp, size, op & 1);\n\n                        tmp = neon_load_reg(rm, pass * 2 + 1);\n\n                        gen_neon_widen(cpu_V1, tmp, size, op & 1);\n\n                        switch (size) {\n\n                        case 0: gen_helper_neon_paddl_u16(CPU_V001); break;\n\n                        case 1: gen_helper_neon_paddl_u32(CPU_V001); break;\n\n                        case 2: tcg_gen_add_i64(CPU_V001); break;\n\n                        default: abort();\n\n                        }\n\n                        if (op >= NEON_2RM_VPADAL) {\n\n                            /* Accumulate.  */\n\n                            neon_load_reg64(cpu_V1, rd + pass);\n\n                            gen_neon_addl(size);\n\n                        }\n\n                        neon_store_reg64(cpu_V0, rd + pass);\n\n                    }\n\n                    break;\n\n                case NEON_2RM_VTRN:\n\n                    if (size == 2) {\n\n                        int n;\n\n                        for (n = 0; n < (q ? 4 : 2); n += 2) {\n\n                            tmp = neon_load_reg(rm, n);\n\n                            tmp2 = neon_load_reg(rd, n + 1);\n\n                            neon_store_reg(rm, n, tmp2);\n\n                            neon_store_reg(rd, n + 1, tmp);\n\n                        }\n\n                    } else {\n\n                        goto elementwise;\n\n                    }\n\n                    break;\n\n                case NEON_2RM_VUZP:\n\n                    if (gen_neon_unzip(rd, rm, size, q)) {\n\n                        return 1;\n\n                    }\n\n                    break;\n\n                case NEON_2RM_VZIP:\n\n                    if (gen_neon_zip(rd, rm, size, q)) {\n\n                        return 1;\n\n                    }\n\n                    break;\n\n                case NEON_2RM_VMOVN: case NEON_2RM_VQMOVN:\n\n                    /* also VQMOVUN; op field and mnemonics don't line up */\n\n                    if (rm & 1) {\n\n                        return 1;\n\n                    }\n\n                    TCGV_UNUSED_I32(tmp2);\n\n                    for (pass = 0; pass < 2; pass++) {\n\n                        neon_load_reg64(cpu_V0, rm + pass);\n\n                        tmp = tcg_temp_new_i32();\n\n                        gen_neon_narrow_op(op == NEON_2RM_VMOVN, q, size,\n\n                                           tmp, cpu_V0);\n\n                        if (pass == 0) {\n\n                            tmp2 = tmp;\n\n                        } else {\n\n                            neon_store_reg(rd, 0, tmp2);\n\n                            neon_store_reg(rd, 1, tmp);\n\n                        }\n\n                    }\n\n                    break;\n\n                case NEON_2RM_VSHLL:\n\n                    if (q || (rd & 1)) {\n\n                        return 1;\n\n                    }\n\n                    tmp = neon_load_reg(rm, 0);\n\n                    tmp2 = neon_load_reg(rm, 1);\n\n                    for (pass = 0; pass < 2; pass++) {\n\n                        if (pass == 1)\n\n                            tmp = tmp2;\n\n                        gen_neon_widen(cpu_V0, tmp, size, 1);\n\n                        tcg_gen_shli_i64(cpu_V0, cpu_V0, 8 << size);\n\n                        neon_store_reg64(cpu_V0, rd + pass);\n\n                    }\n\n                    break;\n\n                case NEON_2RM_VCVT_F16_F32:\n\n                    if (!arm_dc_feature(s, ARM_FEATURE_VFP_FP16) ||\n\n                        q || (rm & 1)) {\n\n                        return 1;\n\n                    }\n\n                    tmp = tcg_temp_new_i32();\n\n                    tmp2 = tcg_temp_new_i32();\n\n                    tcg_gen_ld_f32(cpu_F0s, cpu_env, neon_reg_offset(rm, 0));\n\n                    gen_helper_neon_fcvt_f32_to_f16(tmp, cpu_F0s, cpu_env);\n\n                    tcg_gen_ld_f32(cpu_F0s, cpu_env, neon_reg_offset(rm, 1));\n\n                    gen_helper_neon_fcvt_f32_to_f16(tmp2, cpu_F0s, cpu_env);\n\n                    tcg_gen_shli_i32(tmp2, tmp2, 16);\n\n                    tcg_gen_or_i32(tmp2, tmp2, tmp);\n\n                    tcg_gen_ld_f32(cpu_F0s, cpu_env, neon_reg_offset(rm, 2));\n\n                    gen_helper_neon_fcvt_f32_to_f16(tmp, cpu_F0s, cpu_env);\n\n                    tcg_gen_ld_f32(cpu_F0s, cpu_env, neon_reg_offset(rm, 3));\n\n                    neon_store_reg(rd, 0, tmp2);\n\n                    tmp2 = tcg_temp_new_i32();\n\n                    gen_helper_neon_fcvt_f32_to_f16(tmp2, cpu_F0s, cpu_env);\n\n                    tcg_gen_shli_i32(tmp2, tmp2, 16);\n\n                    tcg_gen_or_i32(tmp2, tmp2, tmp);\n\n                    neon_store_reg(rd, 1, tmp2);\n\n                    tcg_temp_free_i32(tmp);\n\n                    break;\n\n                case NEON_2RM_VCVT_F32_F16:\n\n                    if (!arm_dc_feature(s, ARM_FEATURE_VFP_FP16) ||\n\n                        q || (rd & 1)) {\n\n                        return 1;\n\n                    }\n\n                    tmp3 = tcg_temp_new_i32();\n\n                    tmp = neon_load_reg(rm, 0);\n\n                    tmp2 = neon_load_reg(rm, 1);\n\n                    tcg_gen_ext16u_i32(tmp3, tmp);\n\n                    gen_helper_neon_fcvt_f16_to_f32(cpu_F0s, tmp3, cpu_env);\n\n                    tcg_gen_st_f32(cpu_F0s, cpu_env, neon_reg_offset(rd, 0));\n\n                    tcg_gen_shri_i32(tmp3, tmp, 16);\n\n                    gen_helper_neon_fcvt_f16_to_f32(cpu_F0s, tmp3, cpu_env);\n\n                    tcg_gen_st_f32(cpu_F0s, cpu_env, neon_reg_offset(rd, 1));\n\n                    tcg_temp_free_i32(tmp);\n\n                    tcg_gen_ext16u_i32(tmp3, tmp2);\n\n                    gen_helper_neon_fcvt_f16_to_f32(cpu_F0s, tmp3, cpu_env);\n\n                    tcg_gen_st_f32(cpu_F0s, cpu_env, neon_reg_offset(rd, 2));\n\n                    tcg_gen_shri_i32(tmp3, tmp2, 16);\n\n                    gen_helper_neon_fcvt_f16_to_f32(cpu_F0s, tmp3, cpu_env);\n\n                    tcg_gen_st_f32(cpu_F0s, cpu_env, neon_reg_offset(rd, 3));\n\n                    tcg_temp_free_i32(tmp2);\n\n                    tcg_temp_free_i32(tmp3);\n\n                    break;\n\n                case NEON_2RM_AESE: case NEON_2RM_AESMC:\n\n                    if (!arm_dc_feature(s, ARM_FEATURE_V8_AES)\n\n                        || ((rm | rd) & 1)) {\n\n                        return 1;\n\n                    }\n\n                    tmp = tcg_const_i32(rd);\n\n                    tmp2 = tcg_const_i32(rm);\n\n\n\n                     /* Bit 6 is the lowest opcode bit; it distinguishes between\n\n                      * encryption (AESE/AESMC) and decryption (AESD/AESIMC)\n\n                      */\n\n                    tmp3 = tcg_const_i32(extract32(insn, 6, 1));\n\n\n\n                    if (op == NEON_2RM_AESE) {\n\n                        gen_helper_crypto_aese(cpu_env, tmp, tmp2, tmp3);\n\n                    } else {\n\n                        gen_helper_crypto_aesmc(cpu_env, tmp, tmp2, tmp3);\n\n                    }\n\n                    tcg_temp_free_i32(tmp);\n\n                    tcg_temp_free_i32(tmp2);\n\n                    tcg_temp_free_i32(tmp3);\n\n                    break;\n\n                case NEON_2RM_SHA1H:\n\n                    if (!arm_dc_feature(s, ARM_FEATURE_V8_SHA1)\n\n                        || ((rm | rd) & 1)) {\n\n                        return 1;\n\n                    }\n\n                    tmp = tcg_const_i32(rd);\n\n                    tmp2 = tcg_const_i32(rm);\n\n\n\n                    gen_helper_crypto_sha1h(cpu_env, tmp, tmp2);\n\n\n\n                    tcg_temp_free_i32(tmp);\n\n                    tcg_temp_free_i32(tmp2);\n\n                    break;\n\n                case NEON_2RM_SHA1SU1:\n\n                    if ((rm | rd) & 1) {\n\n                            return 1;\n\n                    }\n\n                    /* bit 6 (q): set -> SHA256SU0, cleared -> SHA1SU1 */\n\n                    if (q) {\n\n                        if (!arm_dc_feature(s, ARM_FEATURE_V8_SHA256)) {\n\n                            return 1;\n\n                        }\n\n                    } else if (!arm_dc_feature(s, ARM_FEATURE_V8_SHA1)) {\n\n                        return 1;\n\n                    }\n\n                    tmp = tcg_const_i32(rd);\n\n                    tmp2 = tcg_const_i32(rm);\n\n                    if (q) {\n\n                        gen_helper_crypto_sha256su0(cpu_env, tmp, tmp2);\n\n                    } else {\n\n                        gen_helper_crypto_sha1su1(cpu_env, tmp, tmp2);\n\n                    }\n\n                    tcg_temp_free_i32(tmp);\n\n                    tcg_temp_free_i32(tmp2);\n\n                    break;\n\n                default:\n\n                elementwise:\n\n                    for (pass = 0; pass < (q ? 4 : 2); pass++) {\n\n                        if (neon_2rm_is_float_op(op)) {\n\n                            tcg_gen_ld_f32(cpu_F0s, cpu_env,\n\n                                           neon_reg_offset(rm, pass));\n\n                            TCGV_UNUSED_I32(tmp);\n\n                        } else {\n\n                            tmp = neon_load_reg(rm, pass);\n\n                        }\n\n                        switch (op) {\n\n                        case NEON_2RM_VREV32:\n\n                            switch (size) {\n\n                            case 0: tcg_gen_bswap32_i32(tmp, tmp); break;\n\n                            case 1: gen_swap_half(tmp); break;\n\n                            default: abort();\n\n                            }\n\n                            break;\n\n                        case NEON_2RM_VREV16:\n\n                            gen_rev16(tmp);\n\n                            break;\n\n                        case NEON_2RM_VCLS:\n\n                            switch (size) {\n\n                            case 0: gen_helper_neon_cls_s8(tmp, tmp); break;\n\n                            case 1: gen_helper_neon_cls_s16(tmp, tmp); break;\n\n                            case 2: gen_helper_neon_cls_s32(tmp, tmp); break;\n\n                            default: abort();\n\n                            }\n\n                            break;\n\n                        case NEON_2RM_VCLZ:\n\n                            switch (size) {\n\n                            case 0: gen_helper_neon_clz_u8(tmp, tmp); break;\n\n                            case 1: gen_helper_neon_clz_u16(tmp, tmp); break;\n\n                            case 2: gen_helper_clz(tmp, tmp); break;\n\n                            default: abort();\n\n                            }\n\n                            break;\n\n                        case NEON_2RM_VCNT:\n\n                            gen_helper_neon_cnt_u8(tmp, tmp);\n\n                            break;\n\n                        case NEON_2RM_VMVN:\n\n                            tcg_gen_not_i32(tmp, tmp);\n\n                            break;\n\n                        case NEON_2RM_VQABS:\n\n                            switch (size) {\n\n                            case 0:\n\n                                gen_helper_neon_qabs_s8(tmp, cpu_env, tmp);\n\n                                break;\n\n                            case 1:\n\n                                gen_helper_neon_qabs_s16(tmp, cpu_env, tmp);\n\n                                break;\n\n                            case 2:\n\n                                gen_helper_neon_qabs_s32(tmp, cpu_env, tmp);\n\n                                break;\n\n                            default: abort();\n\n                            }\n\n                            break;\n\n                        case NEON_2RM_VQNEG:\n\n                            switch (size) {\n\n                            case 0:\n\n                                gen_helper_neon_qneg_s8(tmp, cpu_env, tmp);\n\n                                break;\n\n                            case 1:\n\n                                gen_helper_neon_qneg_s16(tmp, cpu_env, tmp);\n\n                                break;\n\n                            case 2:\n\n                                gen_helper_neon_qneg_s32(tmp, cpu_env, tmp);\n\n                                break;\n\n                            default: abort();\n\n                            }\n\n                            break;\n\n                        case NEON_2RM_VCGT0: case NEON_2RM_VCLE0:\n\n                            tmp2 = tcg_const_i32(0);\n\n                            switch(size) {\n\n                            case 0: gen_helper_neon_cgt_s8(tmp, tmp, tmp2); break;\n\n                            case 1: gen_helper_neon_cgt_s16(tmp, tmp, tmp2); break;\n\n                            case 2: gen_helper_neon_cgt_s32(tmp, tmp, tmp2); break;\n\n                            default: abort();\n\n                            }\n\n                            tcg_temp_free_i32(tmp2);\n\n                            if (op == NEON_2RM_VCLE0) {\n\n                                tcg_gen_not_i32(tmp, tmp);\n\n                            }\n\n                            break;\n\n                        case NEON_2RM_VCGE0: case NEON_2RM_VCLT0:\n\n                            tmp2 = tcg_const_i32(0);\n\n                            switch(size) {\n\n                            case 0: gen_helper_neon_cge_s8(tmp, tmp, tmp2); break;\n\n                            case 1: gen_helper_neon_cge_s16(tmp, tmp, tmp2); break;\n\n                            case 2: gen_helper_neon_cge_s32(tmp, tmp, tmp2); break;\n\n                            default: abort();\n\n                            }\n\n                            tcg_temp_free_i32(tmp2);\n\n                            if (op == NEON_2RM_VCLT0) {\n\n                                tcg_gen_not_i32(tmp, tmp);\n\n                            }\n\n                            break;\n\n                        case NEON_2RM_VCEQ0:\n\n                            tmp2 = tcg_const_i32(0);\n\n                            switch(size) {\n\n                            case 0: gen_helper_neon_ceq_u8(tmp, tmp, tmp2); break;\n\n                            case 1: gen_helper_neon_ceq_u16(tmp, tmp, tmp2); break;\n\n                            case 2: gen_helper_neon_ceq_u32(tmp, tmp, tmp2); break;\n\n                            default: abort();\n\n                            }\n\n                            tcg_temp_free_i32(tmp2);\n\n                            break;\n\n                        case NEON_2RM_VABS:\n\n                            switch(size) {\n\n                            case 0: gen_helper_neon_abs_s8(tmp, tmp); break;\n\n                            case 1: gen_helper_neon_abs_s16(tmp, tmp); break;\n\n                            case 2: tcg_gen_abs_i32(tmp, tmp); break;\n\n                            default: abort();\n\n                            }\n\n                            break;\n\n                        case NEON_2RM_VNEG:\n\n                            tmp2 = tcg_const_i32(0);\n\n                            gen_neon_rsb(size, tmp, tmp2);\n\n                            tcg_temp_free_i32(tmp2);\n\n                            break;\n\n                        case NEON_2RM_VCGT0_F:\n\n                        {\n\n                            TCGv_ptr fpstatus = get_fpstatus_ptr(1);\n\n                            tmp2 = tcg_const_i32(0);\n\n                            gen_helper_neon_cgt_f32(tmp, tmp, tmp2, fpstatus);\n\n                            tcg_temp_free_i32(tmp2);\n\n                            tcg_temp_free_ptr(fpstatus);\n\n                            break;\n\n                        }\n\n                        case NEON_2RM_VCGE0_F:\n\n                        {\n\n                            TCGv_ptr fpstatus = get_fpstatus_ptr(1);\n\n                            tmp2 = tcg_const_i32(0);\n\n                            gen_helper_neon_cge_f32(tmp, tmp, tmp2, fpstatus);\n\n                            tcg_temp_free_i32(tmp2);\n\n                            tcg_temp_free_ptr(fpstatus);\n\n                            break;\n\n                        }\n\n                        case NEON_2RM_VCEQ0_F:\n\n                        {\n\n                            TCGv_ptr fpstatus = get_fpstatus_ptr(1);\n\n                            tmp2 = tcg_const_i32(0);\n\n                            gen_helper_neon_ceq_f32(tmp, tmp, tmp2, fpstatus);\n\n                            tcg_temp_free_i32(tmp2);\n\n                            tcg_temp_free_ptr(fpstatus);\n\n                            break;\n\n                        }\n\n                        case NEON_2RM_VCLE0_F:\n\n                        {\n\n                            TCGv_ptr fpstatus = get_fpstatus_ptr(1);\n\n                            tmp2 = tcg_const_i32(0);\n\n                            gen_helper_neon_cge_f32(tmp, tmp2, tmp, fpstatus);\n\n                            tcg_temp_free_i32(tmp2);\n\n                            tcg_temp_free_ptr(fpstatus);\n\n                            break;\n\n                        }\n\n                        case NEON_2RM_VCLT0_F:\n\n                        {\n\n                            TCGv_ptr fpstatus = get_fpstatus_ptr(1);\n\n                            tmp2 = tcg_const_i32(0);\n\n                            gen_helper_neon_cgt_f32(tmp, tmp2, tmp, fpstatus);\n\n                            tcg_temp_free_i32(tmp2);\n\n                            tcg_temp_free_ptr(fpstatus);\n\n                            break;\n\n                        }\n\n                        case NEON_2RM_VABS_F:\n\n                            gen_vfp_abs(0);\n\n                            break;\n\n                        case NEON_2RM_VNEG_F:\n\n                            gen_vfp_neg(0);\n\n                            break;\n\n                        case NEON_2RM_VSWP:\n\n                            tmp2 = neon_load_reg(rd, pass);\n\n                            neon_store_reg(rm, pass, tmp2);\n\n                            break;\n\n                        case NEON_2RM_VTRN:\n\n                            tmp2 = neon_load_reg(rd, pass);\n\n                            switch (size) {\n\n                            case 0: gen_neon_trn_u8(tmp, tmp2); break;\n\n                            case 1: gen_neon_trn_u16(tmp, tmp2); break;\n\n                            default: abort();\n\n                            }\n\n                            neon_store_reg(rm, pass, tmp2);\n\n                            break;\n\n                        case NEON_2RM_VRINTN:\n\n                        case NEON_2RM_VRINTA:\n\n                        case NEON_2RM_VRINTM:\n\n                        case NEON_2RM_VRINTP:\n\n                        case NEON_2RM_VRINTZ:\n\n                        {\n\n                            TCGv_i32 tcg_rmode;\n\n                            TCGv_ptr fpstatus = get_fpstatus_ptr(1);\n\n                            int rmode;\n\n\n\n                            if (op == NEON_2RM_VRINTZ) {\n\n                                rmode = FPROUNDING_ZERO;\n\n                            } else {\n\n                                rmode = fp_decode_rm[((op & 0x6) >> 1) ^ 1];\n\n                            }\n\n\n\n                            tcg_rmode = tcg_const_i32(arm_rmode_to_sf(rmode));\n\n                            gen_helper_set_neon_rmode(tcg_rmode, tcg_rmode,\n\n                                                      cpu_env);\n\n                            gen_helper_rints(cpu_F0s, cpu_F0s, fpstatus);\n\n                            gen_helper_set_neon_rmode(tcg_rmode, tcg_rmode,\n\n                                                      cpu_env);\n\n                            tcg_temp_free_ptr(fpstatus);\n\n                            tcg_temp_free_i32(tcg_rmode);\n\n                            break;\n\n                        }\n\n                        case NEON_2RM_VRINTX:\n\n                        {\n\n                            TCGv_ptr fpstatus = get_fpstatus_ptr(1);\n\n                            gen_helper_rints_exact(cpu_F0s, cpu_F0s, fpstatus);\n\n                            tcg_temp_free_ptr(fpstatus);\n\n                            break;\n\n                        }\n\n                        case NEON_2RM_VCVTAU:\n\n                        case NEON_2RM_VCVTAS:\n\n                        case NEON_2RM_VCVTNU:\n\n                        case NEON_2RM_VCVTNS:\n\n                        case NEON_2RM_VCVTPU:\n\n                        case NEON_2RM_VCVTPS:\n\n                        case NEON_2RM_VCVTMU:\n\n                        case NEON_2RM_VCVTMS:\n\n                        {\n\n                            bool is_signed = !extract32(insn, 7, 1);\n\n                            TCGv_ptr fpst = get_fpstatus_ptr(1);\n\n                            TCGv_i32 tcg_rmode, tcg_shift;\n\n                            int rmode = fp_decode_rm[extract32(insn, 8, 2)];\n\n\n\n                            tcg_shift = tcg_const_i32(0);\n\n                            tcg_rmode = tcg_const_i32(arm_rmode_to_sf(rmode));\n\n                            gen_helper_set_neon_rmode(tcg_rmode, tcg_rmode,\n\n                                                      cpu_env);\n\n\n\n                            if (is_signed) {\n\n                                gen_helper_vfp_tosls(cpu_F0s, cpu_F0s,\n\n                                                     tcg_shift, fpst);\n\n                            } else {\n\n                                gen_helper_vfp_touls(cpu_F0s, cpu_F0s,\n\n                                                     tcg_shift, fpst);\n\n                            }\n\n\n\n                            gen_helper_set_neon_rmode(tcg_rmode, tcg_rmode,\n\n                                                      cpu_env);\n\n                            tcg_temp_free_i32(tcg_rmode);\n\n                            tcg_temp_free_i32(tcg_shift);\n\n                            tcg_temp_free_ptr(fpst);\n\n                            break;\n\n                        }\n\n                        case NEON_2RM_VRECPE:\n\n                        {\n\n                            TCGv_ptr fpstatus = get_fpstatus_ptr(1);\n\n                            gen_helper_recpe_u32(tmp, tmp, fpstatus);\n\n                            tcg_temp_free_ptr(fpstatus);\n\n                            break;\n\n                        }\n\n                        case NEON_2RM_VRSQRTE:\n\n                        {\n\n                            TCGv_ptr fpstatus = get_fpstatus_ptr(1);\n\n                            gen_helper_rsqrte_u32(tmp, tmp, fpstatus);\n\n                            tcg_temp_free_ptr(fpstatus);\n\n                            break;\n\n                        }\n\n                        case NEON_2RM_VRECPE_F:\n\n                        {\n\n                            TCGv_ptr fpstatus = get_fpstatus_ptr(1);\n\n                            gen_helper_recpe_f32(cpu_F0s, cpu_F0s, fpstatus);\n\n                            tcg_temp_free_ptr(fpstatus);\n\n                            break;\n\n                        }\n\n                        case NEON_2RM_VRSQRTE_F:\n\n                        {\n\n                            TCGv_ptr fpstatus = get_fpstatus_ptr(1);\n\n                            gen_helper_rsqrte_f32(cpu_F0s, cpu_F0s, fpstatus);\n\n                            tcg_temp_free_ptr(fpstatus);\n\n                            break;\n\n                        }\n\n                        case NEON_2RM_VCVT_FS: /* VCVT.F32.S32 */\n\n                            gen_vfp_sito(0, 1);\n\n                            break;\n\n                        case NEON_2RM_VCVT_FU: /* VCVT.F32.U32 */\n\n                            gen_vfp_uito(0, 1);\n\n                            break;\n\n                        case NEON_2RM_VCVT_SF: /* VCVT.S32.F32 */\n\n                            gen_vfp_tosiz(0, 1);\n\n                            break;\n\n                        case NEON_2RM_VCVT_UF: /* VCVT.U32.F32 */\n\n                            gen_vfp_touiz(0, 1);\n\n                            break;\n\n                        default:\n\n                            /* Reserved op values were caught by the\n\n                             * neon_2rm_sizes[] check earlier.\n\n                             */\n\n                            abort();\n\n                        }\n\n                        if (neon_2rm_is_float_op(op)) {\n\n                            tcg_gen_st_f32(cpu_F0s, cpu_env,\n\n                                           neon_reg_offset(rd, pass));\n\n                        } else {\n\n                            neon_store_reg(rd, pass, tmp);\n\n                        }\n\n                    }\n\n                    break;\n\n                }\n\n            } else if ((insn & (1 << 10)) == 0) {\n\n                /* VTBL, VTBX.  */\n\n                int n = ((insn >> 8) & 3) + 1;\n\n                if ((rn + n) > 32) {\n\n                    /* This is UNPREDICTABLE; we choose to UNDEF to avoid the\n\n                     * helper function running off the end of the register file.\n\n                     */\n\n                    return 1;\n\n                }\n\n                n <<= 3;\n\n                if (insn & (1 << 6)) {\n\n                    tmp = neon_load_reg(rd, 0);\n\n                } else {\n\n                    tmp = tcg_temp_new_i32();\n\n                    tcg_gen_movi_i32(tmp, 0);\n\n                }\n\n                tmp2 = neon_load_reg(rm, 0);\n\n                tmp4 = tcg_const_i32(rn);\n\n                tmp5 = tcg_const_i32(n);\n\n                gen_helper_neon_tbl(tmp2, cpu_env, tmp2, tmp, tmp4, tmp5);\n\n                tcg_temp_free_i32(tmp);\n\n                if (insn & (1 << 6)) {\n\n                    tmp = neon_load_reg(rd, 1);\n\n                } else {\n\n                    tmp = tcg_temp_new_i32();\n\n                    tcg_gen_movi_i32(tmp, 0);\n\n                }\n\n                tmp3 = neon_load_reg(rm, 1);\n\n                gen_helper_neon_tbl(tmp3, cpu_env, tmp3, tmp, tmp4, tmp5);\n\n                tcg_temp_free_i32(tmp5);\n\n                tcg_temp_free_i32(tmp4);\n\n                neon_store_reg(rd, 0, tmp2);\n\n                neon_store_reg(rd, 1, tmp3);\n\n                tcg_temp_free_i32(tmp);\n\n            } else if ((insn & 0x380) == 0) {\n\n                /* VDUP */\n\n                if ((insn & (7 << 16)) == 0 || (q && (rd & 1))) {\n\n                    return 1;\n\n                }\n\n                if (insn & (1 << 19)) {\n\n                    tmp = neon_load_reg(rm, 1);\n\n                } else {\n\n                    tmp = neon_load_reg(rm, 0);\n\n                }\n\n                if (insn & (1 << 16)) {\n\n                    gen_neon_dup_u8(tmp, ((insn >> 17) & 3) * 8);\n\n                } else if (insn & (1 << 17)) {\n\n                    if ((insn >> 18) & 1)\n\n                        gen_neon_dup_high16(tmp);\n\n                    else\n\n                        gen_neon_dup_low16(tmp);\n\n                }\n\n                for (pass = 0; pass < (q ? 4 : 2); pass++) {\n\n                    tmp2 = tcg_temp_new_i32();\n\n                    tcg_gen_mov_i32(tmp2, tmp);\n\n                    neon_store_reg(rd, pass, tmp2);\n\n                }\n\n                tcg_temp_free_i32(tmp);\n\n            } else {\n\n                return 1;\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 21733}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "static void rtas_int_on(sPAPREnvironment *spapr, uint32_t token,\n\n                        uint32_t nargs, target_ulong args,\n\n                        uint32_t nret, target_ulong rets)\n\n{\n\n    struct ics_state *ics = spapr->icp->ics;\n\n    uint32_t nr;\n\n\n\n    if ((nargs != 1) || (nret != 1)) {\n\n        rtas_st(rets, 0, -3);\n\n        return;\n\n    }\n\n\n\n    nr = rtas_ld(args, 0);\n\n\n\n    if (!ics_valid_irq(ics, nr)) {\n\n        rtas_st(rets, 0, -3);\n\n        return;\n\n    }\n\n\n\n    ics_write_xive(ics, nr, ics->irqs[nr - ics->offset].server,\n\n                   ics->irqs[nr - ics->offset].saved_priority,\n\n                   ics->irqs[nr - ics->offset].saved_priority);\n\n\n\n    rtas_st(rets, 0, 0); /* Success */\n\n}\n", "idx": 21734}
{"project": "qemu", "commit_id": "25b422eb4051b9b7473feea1ae848f1e3b4f799f", "target": 0, "func": "static void do_info(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    const mon_cmd_t *cmd;\n\n    const char *item = qdict_get_try_str(qdict, \"item\");\n\n\n\n    if (!item)\n\n        goto help;\n\n\n\n    for (cmd = info_cmds; cmd->name != NULL; cmd++) {\n\n        if (compare_cmd(item, cmd->name))\n\n            break;\n\n    }\n\n\n\n    if (cmd->name == NULL)\n\n        goto help;\n\n\n\n    if (monitor_handler_ported(cmd)) {\n\n        cmd->mhandler.info_new(mon, ret_data);\n\n        if (*ret_data)\n\n            cmd->user_print(mon, *ret_data);\n\n    } else {\n\n        cmd->mhandler.info(mon);\n\n    }\n\n\n\n    return;\n\n\n\nhelp:\n\n    help_cmd(mon, \"info\");\n\n}\n", "idx": 21735}
{"project": "qemu", "commit_id": "68d553587c0aa271c3eb2902921b503740d775b6", "target": 0, "func": "static int ehci_state_fetchsitd(EHCIState *ehci, int async)\n\n{\n\n    uint32_t entry;\n\n    EHCIsitd sitd;\n\n\n\n    assert(!async);\n\n    entry = ehci_get_fetch_addr(ehci, async);\n\n\n\n    get_dwords(NLPTR_GET(entry), (uint32_t *)&sitd,\n\n               sizeof(EHCIsitd) >> 2);\n\n    ehci_trace_sitd(ehci, entry, &sitd);\n\n\n\n    if (!(sitd.results & SITD_RESULTS_ACTIVE)) {\n\n        /* siTD is not active, nothing to do */;\n\n    } else {\n\n        /* TODO: split transfers are not implemented */\n\n        fprintf(stderr, \"WARNING: Skipping active siTD\\n\");\n\n    }\n\n\n\n    ehci_set_fetch_addr(ehci, async, sitd.next);\n\n    ehci_set_state(ehci, async, EST_FETCHENTRY);\n\n    return 1;\n\n}\n", "idx": 21736}
{"project": "qemu", "commit_id": "543f8f13e256a081dd820375e9575439b659ccd8", "target": 0, "func": "static void test_cdrom_dma(void)\n\n{\n\n    static const size_t len = ATAPI_BLOCK_SIZE;\n\n    char *pattern = g_malloc(ATAPI_BLOCK_SIZE * 16);\n\n    char *rx = g_malloc0(len);\n\n    uintptr_t guest_buf;\n\n    PrdtEntry prdt[1];\n\n    FILE *fh;\n\n\n\n    ide_test_start(\"-drive if=none,file=%s,media=cdrom,format=raw,id=sr0,index=0 \"\n\n                   \"-device ide-cd,drive=sr0,bus=ide.0\", tmp_path);\n\n    qtest_irq_intercept_in(global_qtest, \"ioapic\");\n\n\n\n    guest_buf = guest_alloc(guest_malloc, len);\n\n    prdt[0].addr = cpu_to_le32(guest_buf);\n\n    prdt[0].size = cpu_to_le32(len | PRDT_EOT);\n\n\n\n    generate_pattern(pattern, ATAPI_BLOCK_SIZE * 16, ATAPI_BLOCK_SIZE);\n\n    fh = fopen(tmp_path, \"w+\");\n\n    fwrite(pattern, ATAPI_BLOCK_SIZE, 16, fh);\n\n    fclose(fh);\n\n\n\n    send_dma_request(CMD_PACKET, 0, 1, prdt, 1, send_scsi_cdb_read10);\n\n\n\n    /* Read back data from guest memory into local qtest memory */\n\n    memread(guest_buf, rx, len);\n\n    g_assert_cmpint(memcmp(pattern, rx, len), ==, 0);\n\n\n\n    g_free(pattern);\n\n    g_free(rx);\n\n    test_bmdma_teardown();\n\n}\n", "idx": 21737}
{"project": "qemu", "commit_id": "f02ca5cbeaf86038834c1953247a1579d7921927", "target": 0, "func": "static inline void tcg_out_movi(TCGContext *s, TCGType type,\n\n                                int ret, tcg_target_long arg)\n\n{\n\n#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)\n\n    if (arg != (arg & 0xffffffff))\n\n        fprintf(stderr, \"unimplemented %s with constant %ld\\n\", __func__, arg);\n\n#endif\n\n    if (arg == (arg & 0xfff))\n\n        tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(TCG_REG_G0) |\n\n                  INSN_IMM13(arg));\n\n    else {\n\n        tcg_out32(s, SETHI | INSN_RD(ret) | ((arg & 0xfffffc00) >> 10));\n\n        if (arg & 0x3ff)\n\n            tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(ret) |\n\n                      INSN_IMM13(arg & 0x3ff));\n\n    }\n\n}\n", "idx": 21739}
{"project": "qemu", "commit_id": "375092332eeaa6e47561ce47fd36144cdaf964d0", "target": 0, "func": "qcrypto_block_luks_create(QCryptoBlock *block,\n\n                          QCryptoBlockCreateOptions *options,\n\n                          QCryptoBlockInitFunc initfunc,\n\n                          QCryptoBlockWriteFunc writefunc,\n\n                          void *opaque,\n\n                          Error **errp)\n\n{\n\n    QCryptoBlockLUKS *luks;\n\n    QCryptoBlockCreateOptionsLUKS luks_opts;\n\n    Error *local_err = NULL;\n\n    uint8_t *masterkey = NULL;\n\n    uint8_t *slotkey = NULL;\n\n    uint8_t *splitkey = NULL;\n\n    size_t splitkeylen = 0;\n\n    size_t i;\n\n    QCryptoCipher *cipher = NULL;\n\n    QCryptoIVGen *ivgen = NULL;\n\n    char *password;\n\n    const char *cipher_alg;\n\n    const char *cipher_mode;\n\n    const char *ivgen_alg;\n\n    const char *ivgen_hash_alg = NULL;\n\n    const char *hash_alg;\n\n    char *cipher_mode_spec = NULL;\n\n    QCryptoCipherAlgorithm ivcipheralg = 0;\n\n    uint64_t iters;\n\n\n\n    memcpy(&luks_opts, &options->u.luks, sizeof(luks_opts));\n\n    if (!luks_opts.has_iter_time) {\n\n        luks_opts.iter_time = 2000;\n\n    }\n\n    if (!luks_opts.has_cipher_alg) {\n\n        luks_opts.cipher_alg = QCRYPTO_CIPHER_ALG_AES_256;\n\n    }\n\n    if (!luks_opts.has_cipher_mode) {\n\n        luks_opts.cipher_mode = QCRYPTO_CIPHER_MODE_XTS;\n\n    }\n\n    if (!luks_opts.has_ivgen_alg) {\n\n        luks_opts.ivgen_alg = QCRYPTO_IVGEN_ALG_PLAIN64;\n\n    }\n\n    if (!luks_opts.has_hash_alg) {\n\n        luks_opts.hash_alg = QCRYPTO_HASH_ALG_SHA256;\n\n    }\n\n    if (luks_opts.ivgen_alg == QCRYPTO_IVGEN_ALG_ESSIV) {\n\n        if (!luks_opts.has_ivgen_hash_alg) {\n\n            luks_opts.ivgen_hash_alg = QCRYPTO_HASH_ALG_SHA256;\n\n            luks_opts.has_ivgen_hash_alg = true;\n\n        }\n\n    }\n\n    /* Note we're allowing ivgen_hash_alg to be set even for\n\n     * non-essiv iv generators that don't need a hash. It will\n\n     * be silently ignored, for compatibility with dm-crypt */\n\n\n\n    if (!options->u.luks.key_secret) {\n\n        error_setg(errp, \"Parameter 'key-secret' is required for cipher\");\n\n        return -1;\n\n    }\n\n    password = qcrypto_secret_lookup_as_utf8(luks_opts.key_secret, errp);\n\n    if (!password) {\n\n        return -1;\n\n    }\n\n\n\n    luks = g_new0(QCryptoBlockLUKS, 1);\n\n    block->opaque = luks;\n\n\n\n    memcpy(luks->header.magic, qcrypto_block_luks_magic,\n\n           QCRYPTO_BLOCK_LUKS_MAGIC_LEN);\n\n\n\n    /* We populate the header in native endianness initially and\n\n     * then convert everything to big endian just before writing\n\n     * it out to disk\n\n     */\n\n    luks->header.version = QCRYPTO_BLOCK_LUKS_VERSION;\n\n    qcrypto_block_luks_uuid_gen(luks->header.uuid);\n\n\n\n    cipher_alg = qcrypto_block_luks_cipher_alg_lookup(luks_opts.cipher_alg,\n\n                                                      errp);\n\n    if (!cipher_alg) {\n\n        goto error;\n\n    }\n\n\n\n    cipher_mode = QCryptoCipherMode_lookup[luks_opts.cipher_mode];\n\n    ivgen_alg = QCryptoIVGenAlgorithm_lookup[luks_opts.ivgen_alg];\n\n    if (luks_opts.has_ivgen_hash_alg) {\n\n        ivgen_hash_alg = QCryptoHashAlgorithm_lookup[luks_opts.ivgen_hash_alg];\n\n        cipher_mode_spec = g_strdup_printf(\"%s-%s:%s\", cipher_mode, ivgen_alg,\n\n                                           ivgen_hash_alg);\n\n    } else {\n\n        cipher_mode_spec = g_strdup_printf(\"%s-%s\", cipher_mode, ivgen_alg);\n\n    }\n\n    hash_alg = QCryptoHashAlgorithm_lookup[luks_opts.hash_alg];\n\n\n\n\n\n    if (strlen(cipher_alg) >= QCRYPTO_BLOCK_LUKS_CIPHER_NAME_LEN) {\n\n        error_setg(errp, \"Cipher name '%s' is too long for LUKS header\",\n\n                   cipher_alg);\n\n        goto error;\n\n    }\n\n    if (strlen(cipher_mode_spec) >= QCRYPTO_BLOCK_LUKS_CIPHER_MODE_LEN) {\n\n        error_setg(errp, \"Cipher mode '%s' is too long for LUKS header\",\n\n                   cipher_mode_spec);\n\n        goto error;\n\n    }\n\n    if (strlen(hash_alg) >= QCRYPTO_BLOCK_LUKS_HASH_SPEC_LEN) {\n\n        error_setg(errp, \"Hash name '%s' is too long for LUKS header\",\n\n                   hash_alg);\n\n        goto error;\n\n    }\n\n\n\n    if (luks_opts.ivgen_alg == QCRYPTO_IVGEN_ALG_ESSIV) {\n\n        ivcipheralg = qcrypto_block_luks_essiv_cipher(luks_opts.cipher_alg,\n\n                                                      luks_opts.ivgen_hash_alg,\n\n                                                      &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            goto error;\n\n        }\n\n    } else {\n\n        ivcipheralg = luks_opts.cipher_alg;\n\n    }\n\n\n\n    strcpy(luks->header.cipher_name, cipher_alg);\n\n    strcpy(luks->header.cipher_mode, cipher_mode_spec);\n\n    strcpy(luks->header.hash_spec, hash_alg);\n\n\n\n    luks->header.key_bytes = qcrypto_cipher_get_key_len(luks_opts.cipher_alg);\n\n    if (luks_opts.cipher_mode == QCRYPTO_CIPHER_MODE_XTS) {\n\n        luks->header.key_bytes *= 2;\n\n    }\n\n\n\n    /* Generate the salt used for hashing the master key\n\n     * with PBKDF later\n\n     */\n\n    if (qcrypto_random_bytes(luks->header.master_key_salt,\n\n                             QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                             errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n    /* Generate random master key */\n\n    masterkey = g_new0(uint8_t, luks->header.key_bytes);\n\n    if (qcrypto_random_bytes(masterkey,\n\n                             luks->header.key_bytes, errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Setup the block device payload encryption objects */\n\n    block->cipher = qcrypto_cipher_new(luks_opts.cipher_alg,\n\n                                       luks_opts.cipher_mode,\n\n                                       masterkey, luks->header.key_bytes,\n\n                                       errp);\n\n    if (!block->cipher) {\n\n        goto error;\n\n    }\n\n\n\n    block->kdfhash = luks_opts.hash_alg;\n\n    block->niv = qcrypto_cipher_get_iv_len(luks_opts.cipher_alg,\n\n                                           luks_opts.cipher_mode);\n\n    block->ivgen = qcrypto_ivgen_new(luks_opts.ivgen_alg,\n\n                                     ivcipheralg,\n\n                                     luks_opts.ivgen_hash_alg,\n\n                                     masterkey, luks->header.key_bytes,\n\n                                     errp);\n\n\n\n    if (!block->ivgen) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Determine how many iterations we need to hash the master\n\n     * key, in order to have 1 second of compute time used\n\n     */\n\n    iters = qcrypto_pbkdf2_count_iters(luks_opts.hash_alg,\n\n                                       masterkey, luks->header.key_bytes,\n\n                                       luks->header.master_key_salt,\n\n                                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                                       QCRYPTO_BLOCK_LUKS_DIGEST_LEN,\n\n                                       &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    if (iters > (ULLONG_MAX / luks_opts.iter_time)) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu too large to scale\",\n\n                         (unsigned long long)iters);\n\n        goto error;\n\n    }\n\n\n\n    /* iter_time was in millis, but count_iters reported for secs */\n\n    iters = iters * luks_opts.iter_time / 1000;\n\n\n\n    /* Why /= 8 ?  That matches cryptsetup, but there's no\n\n     * explanation why they chose /= 8... Probably so that\n\n     * if all 8 keyslots are active we only spend 1 second\n\n     * in total time to check all keys */\n\n    iters /= 8;\n\n    if (iters > UINT32_MAX) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu larger than %u\",\n\n                         (unsigned long long)iters, UINT32_MAX);\n\n        goto error;\n\n    }\n\n    iters = MAX(iters, QCRYPTO_BLOCK_LUKS_MIN_MASTER_KEY_ITERS);\n\n    luks->header.master_key_iterations = iters;\n\n\n\n    /* Hash the master key, saving the result in the LUKS\n\n     * header. This hash is used when opening the encrypted\n\n     * device to verify that the user password unlocked a\n\n     * valid master key\n\n     */\n\n    if (qcrypto_pbkdf2(luks_opts.hash_alg,\n\n                       masterkey, luks->header.key_bytes,\n\n                       luks->header.master_key_salt,\n\n                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                       luks->header.master_key_iterations,\n\n                       luks->header.master_key_digest,\n\n                       QCRYPTO_BLOCK_LUKS_DIGEST_LEN,\n\n                       errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Although LUKS has multiple key slots, we're just going\n\n     * to use the first key slot */\n\n    splitkeylen = luks->header.key_bytes * QCRYPTO_BLOCK_LUKS_STRIPES;\n\n    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {\n\n        luks->header.key_slots[i].active = i == 0 ?\n\n            QCRYPTO_BLOCK_LUKS_KEY_SLOT_ENABLED :\n\n            QCRYPTO_BLOCK_LUKS_KEY_SLOT_DISABLED;\n\n        luks->header.key_slots[i].stripes = QCRYPTO_BLOCK_LUKS_STRIPES;\n\n\n\n        /* This calculation doesn't match that shown in the spec,\n\n         * but instead follows the cryptsetup implementation.\n\n         */\n\n        luks->header.key_slots[i].key_offset =\n\n            (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n             QCRYPTO_BLOCK_LUKS_SECTOR_SIZE) +\n\n            (ROUND_UP(DIV_ROUND_UP(splitkeylen, QCRYPTO_BLOCK_LUKS_SECTOR_SIZE),\n\n                      (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n                       QCRYPTO_BLOCK_LUKS_SECTOR_SIZE)) * i);\n\n    }\n\n\n\n    if (qcrypto_random_bytes(luks->header.key_slots[0].salt,\n\n                             QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                             errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n    /* Again we determine how many iterations are required to\n\n     * hash the user password while consuming 1 second of compute\n\n     * time */\n\n    iters = qcrypto_pbkdf2_count_iters(luks_opts.hash_alg,\n\n                                       (uint8_t *)password, strlen(password),\n\n                                       luks->header.key_slots[0].salt,\n\n                                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                                       luks->header.key_bytes,\n\n                                       &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    if (iters > (ULLONG_MAX / luks_opts.iter_time)) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu too large to scale\",\n\n                         (unsigned long long)iters);\n\n        goto error;\n\n    }\n\n\n\n    /* iter_time was in millis, but count_iters reported for secs */\n\n    iters = iters * luks_opts.iter_time / 1000;\n\n\n\n    if (iters > UINT32_MAX) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu larger than %u\",\n\n                         (unsigned long long)iters, UINT32_MAX);\n\n        goto error;\n\n    }\n\n\n\n    luks->header.key_slots[0].iterations =\n\n        MAX(iters, QCRYPTO_BLOCK_LUKS_MIN_SLOT_KEY_ITERS);\n\n\n\n\n\n    /* Generate a key that we'll use to encrypt the master\n\n     * key, from the user's password\n\n     */\n\n    slotkey = g_new0(uint8_t, luks->header.key_bytes);\n\n    if (qcrypto_pbkdf2(luks_opts.hash_alg,\n\n                       (uint8_t *)password, strlen(password),\n\n                       luks->header.key_slots[0].salt,\n\n                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                       luks->header.key_slots[0].iterations,\n\n                       slotkey, luks->header.key_bytes,\n\n                       errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Setup the encryption objects needed to encrypt the\n\n     * master key material\n\n     */\n\n    cipher = qcrypto_cipher_new(luks_opts.cipher_alg,\n\n                                luks_opts.cipher_mode,\n\n                                slotkey, luks->header.key_bytes,\n\n                                errp);\n\n    if (!cipher) {\n\n        goto error;\n\n    }\n\n\n\n    ivgen = qcrypto_ivgen_new(luks_opts.ivgen_alg,\n\n                              ivcipheralg,\n\n                              luks_opts.ivgen_hash_alg,\n\n                              slotkey, luks->header.key_bytes,\n\n                              errp);\n\n    if (!ivgen) {\n\n        goto error;\n\n    }\n\n\n\n    /* Before storing the master key, we need to vastly\n\n     * increase its size, as protection against forensic\n\n     * disk data recovery */\n\n    splitkey = g_new0(uint8_t, splitkeylen);\n\n\n\n    if (qcrypto_afsplit_encode(luks_opts.hash_alg,\n\n                               luks->header.key_bytes,\n\n                               luks->header.key_slots[0].stripes,\n\n                               masterkey,\n\n                               splitkey,\n\n                               errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n    /* Now we encrypt the split master key with the key generated\n\n     * from the user's password, before storing it */\n\n    if (qcrypto_block_encrypt_helper(cipher, block->niv, ivgen,\n\n                                     QCRYPTO_BLOCK_LUKS_SECTOR_SIZE,\n\n                                     0,\n\n                                     splitkey,\n\n                                     splitkeylen,\n\n                                     errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* The total size of the LUKS headers is the partition header + key\n\n     * slot headers, rounded up to the nearest sector, combined with\n\n     * the size of each master key material region, also rounded up\n\n     * to the nearest sector */\n\n    luks->header.payload_offset =\n\n        (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n         QCRYPTO_BLOCK_LUKS_SECTOR_SIZE) +\n\n        (ROUND_UP(DIV_ROUND_UP(splitkeylen, QCRYPTO_BLOCK_LUKS_SECTOR_SIZE),\n\n                  (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n                   QCRYPTO_BLOCK_LUKS_SECTOR_SIZE)) *\n\n         QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS);\n\n\n\n    block->payload_offset = luks->header.payload_offset *\n\n        QCRYPTO_BLOCK_LUKS_SECTOR_SIZE;\n\n\n\n    /* Reserve header space to match payload offset */\n\n    initfunc(block, block->payload_offset, &local_err, opaque);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    /* Everything on disk uses Big Endian, so flip header fields\n\n     * before writing them */\n\n    cpu_to_be16s(&luks->header.version);\n\n    cpu_to_be32s(&luks->header.payload_offset);\n\n    cpu_to_be32s(&luks->header.key_bytes);\n\n    cpu_to_be32s(&luks->header.master_key_iterations);\n\n\n\n    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {\n\n        cpu_to_be32s(&luks->header.key_slots[i].active);\n\n        cpu_to_be32s(&luks->header.key_slots[i].iterations);\n\n        cpu_to_be32s(&luks->header.key_slots[i].key_offset);\n\n        cpu_to_be32s(&luks->header.key_slots[i].stripes);\n\n    }\n\n\n\n\n\n    /* Write out the partition header and key slot headers */\n\n    writefunc(block, 0,\n\n              (const uint8_t *)&luks->header,\n\n              sizeof(luks->header),\n\n              &local_err,\n\n              opaque);\n\n\n\n    /* Delay checking local_err until we've byte-swapped */\n\n\n\n    /* Byte swap the header back to native, in case we need\n\n     * to read it again later */\n\n    be16_to_cpus(&luks->header.version);\n\n    be32_to_cpus(&luks->header.payload_offset);\n\n    be32_to_cpus(&luks->header.key_bytes);\n\n    be32_to_cpus(&luks->header.master_key_iterations);\n\n\n\n    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {\n\n        be32_to_cpus(&luks->header.key_slots[i].active);\n\n        be32_to_cpus(&luks->header.key_slots[i].iterations);\n\n        be32_to_cpus(&luks->header.key_slots[i].key_offset);\n\n        be32_to_cpus(&luks->header.key_slots[i].stripes);\n\n    }\n\n\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    /* Write out the master key material, starting at the\n\n     * sector immediately following the partition header. */\n\n    if (writefunc(block,\n\n                  luks->header.key_slots[0].key_offset *\n\n                  QCRYPTO_BLOCK_LUKS_SECTOR_SIZE,\n\n                  splitkey, splitkeylen,\n\n                  errp,\n\n                  opaque) != splitkeylen) {\n\n        goto error;\n\n    }\n\n\n\n    luks->cipher_alg = luks_opts.cipher_alg;\n\n    luks->cipher_mode = luks_opts.cipher_mode;\n\n    luks->ivgen_alg = luks_opts.ivgen_alg;\n\n    luks->ivgen_hash_alg = luks_opts.ivgen_hash_alg;\n\n    luks->hash_alg = luks_opts.hash_alg;\n\n\n\n    memset(masterkey, 0, luks->header.key_bytes);\n\n    g_free(masterkey);\n\n    memset(slotkey, 0, luks->header.key_bytes);\n\n    g_free(slotkey);\n\n    g_free(splitkey);\n\n    g_free(password);\n\n    g_free(cipher_mode_spec);\n\n\n\n    qcrypto_ivgen_free(ivgen);\n\n    qcrypto_cipher_free(cipher);\n\n\n\n    return 0;\n\n\n\n error:\n\n    if (masterkey) {\n\n        memset(masterkey, 0, luks->header.key_bytes);\n\n    }\n\n    g_free(masterkey);\n\n    if (slotkey) {\n\n        memset(slotkey, 0, luks->header.key_bytes);\n\n    }\n\n    g_free(slotkey);\n\n    g_free(splitkey);\n\n    g_free(password);\n\n    g_free(cipher_mode_spec);\n\n\n\n    qcrypto_ivgen_free(ivgen);\n\n    qcrypto_cipher_free(cipher);\n\n\n\n    g_free(luks);\n\n    return -1;\n\n}\n", "idx": 21740}
{"project": "qemu", "commit_id": "dbb2a604a94f3899fa34bd1ede462f213e822e03", "target": 0, "func": "static void test_abstract_interfaces(void)\n\n{\n\n    QList *all_types;\n\n    QList *obj_types;\n\n    QListEntry *ae;\n\n\n\n    qtest_start(common_args);\n\n    /* qom-list-types implements=interface would return any type\n\n     * that implements _any_ interface (not just interface types),\n\n     * so use a trick to find the interface type names:\n\n     * - list all object types\n\n     * - list all types, and look for items that are not\n\n     *   on the first list\n\n     */\n\n    all_types = qom_list_types(NULL, false);\n\n    obj_types = qom_list_types(\"object\", false);\n\n\n\n    QLIST_FOREACH_ENTRY(all_types, ae) {\n\n        QDict *at = qobject_to_qdict(qlist_entry_obj(ae));\n\n        const char *aname = qdict_get_str(at, \"name\");\n\n        QListEntry *oe;\n\n        const char *found = NULL;\n\n\n\n        QLIST_FOREACH_ENTRY(obj_types, oe) {\n\n            QDict *ot = qobject_to_qdict(qlist_entry_obj(oe));\n\n            const char *oname = qdict_get_str(ot, \"name\");\n\n            if (!strcmp(aname, oname)) {\n\n                found = oname;\n\n                break;\n\n            }\n\n        }\n\n\n\n        /* Using g_assert_cmpstr() will give more useful failure\n\n         * messages than g_assert(found) */\n\n        g_assert_cmpstr(aname, ==, found);\n\n    }\n\n\n\n    QDECREF(all_types);\n\n    QDECREF(obj_types);\n\n    qtest_end();\n\n}\n", "idx": 21741}
{"project": "qemu", "commit_id": "64d7e9a421fea0ac50b44541f5521de455e7cd5d", "target": 0, "func": "static void mips_fulong2e_init(ram_addr_t ram_size, const char *boot_device,\n\n                        const char *kernel_filename, const char *kernel_cmdline,\n\n                        const char *initrd_filename, const char *cpu_model)\n\n{\n\n    char *filename;\n\n    unsigned long ram_offset, bios_offset;\n\n    long bios_size;\n\n    int64_t kernel_entry;\n\n    qemu_irq *i8259;\n\n    qemu_irq *cpu_exit_irq;\n\n    int via_devfn;\n\n    PCIBus *pci_bus;\n\n    uint8_t *eeprom_buf;\n\n    i2c_bus *smbus;\n\n    int i;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    DeviceState *eeprom;\n\n    CPUState *env;\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"Loongson-2E\";\n\n    }\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    register_savevm(NULL, \"cpu\", 0, 3, cpu_save, cpu_load, env);\n\n    qemu_register_reset(main_cpu_reset, env);\n\n\n\n    /* fulong 2e has 256M ram. */\n\n    ram_size = 256 * 1024 * 1024;\n\n\n\n    /* fulong 2e has a 1M flash.Winbond W39L040AP70Z */\n\n    bios_size = 1024 * 1024;\n\n\n\n    /* allocate RAM */\n\n    ram_offset = qemu_ram_alloc(NULL, \"fulong2e.ram\", ram_size);\n\n    bios_offset = qemu_ram_alloc(NULL, \"fulong2e.bios\", bios_size);\n\n\n\n    cpu_register_physical_memory(0, ram_size, ram_offset);\n\n    cpu_register_physical_memory(0x1fc00000LL,\n\n\t\t\t\t\t   bios_size, bios_offset | IO_MEM_ROM);\n\n\n\n    /* We do not support flash operation, just loading pmon.bin as raw BIOS.\n\n     * Please use -L to set the BIOS path and -bios to set bios name. */\n\n\n\n    if (kernel_filename) {\n\n        loaderparams.ram_size = ram_size;\n\n        loaderparams.kernel_filename = kernel_filename;\n\n        loaderparams.kernel_cmdline = kernel_cmdline;\n\n        loaderparams.initrd_filename = initrd_filename;\n\n        kernel_entry = load_kernel (env);\n\n        write_bootloader(env, qemu_get_ram_ptr(bios_offset), kernel_entry);\n\n    } else {\n\n        if (bios_name == NULL) {\n\n                bios_name = FULONG_BIOSNAME;\n\n        }\n\n        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n        if (filename) {\n\n            bios_size = load_image_targphys(filename, 0x1fc00000LL,\n\n                                            BIOS_SIZE);\n\n            qemu_free(filename);\n\n        } else {\n\n            bios_size = -1;\n\n        }\n\n\n\n        if ((bios_size < 0 || bios_size > BIOS_SIZE) && !kernel_filename) {\n\n            fprintf(stderr, \"qemu: Could not load MIPS bios '%s'\\n\", bios_name);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Init internal devices */\n\n    cpu_mips_irq_init_cpu(env);\n\n    cpu_mips_clock_init(env);\n\n\n\n    /* Interrupt controller */\n\n    /* The 8259 -> IP5  */\n\n    i8259 = i8259_init(env->irq[5]);\n\n\n\n    /* North bridge, Bonito --> IP2 */\n\n    pci_bus = bonito_init((qemu_irq *)&(env->irq[2]));\n\n\n\n    /* South bridge */\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        hd[i] = drive_get(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);\n\n    }\n\n\n\n    via_devfn = vt82c686b_init(pci_bus, PCI_DEVFN(FULONG2E_VIA_SLOT, 0));\n\n    if (via_devfn < 0) {\n\n        fprintf(stderr, \"vt82c686b_init error \\n\");\n\n        exit(1);\n\n    }\n\n\n\n    isa_bus_irqs(i8259);\n\n    vt82c686b_ide_init(pci_bus, hd, PCI_DEVFN(FULONG2E_VIA_SLOT, 1));\n\n    usb_uhci_vt82c686b_init(pci_bus, PCI_DEVFN(FULONG2E_VIA_SLOT, 2));\n\n    usb_uhci_vt82c686b_init(pci_bus, PCI_DEVFN(FULONG2E_VIA_SLOT, 3));\n\n\n\n    smbus = vt82c686b_pm_init(pci_bus, PCI_DEVFN(FULONG2E_VIA_SLOT, 4),\n\n                              0xeee1, NULL);\n\n    eeprom_buf = qemu_mallocz(8 * 256); /* XXX: make this persistent */\n\n    memcpy(eeprom_buf, eeprom_spd, sizeof(eeprom_spd));\n\n    /* TODO: Populate SPD eeprom data.  */\n\n    eeprom = qdev_create((BusState *)smbus, \"smbus-eeprom\");\n\n    qdev_prop_set_uint8(eeprom, \"address\", 0x50);\n\n    qdev_prop_set_ptr(eeprom, \"data\", eeprom_buf);\n\n    qdev_init_nofail(eeprom);\n\n\n\n    /* init other devices */\n\n    pit = pit_init(0x40, isa_reserve_irq(0));\n\n    cpu_exit_irq = qemu_allocate_irqs(cpu_request_exit, NULL, 1);\n\n    DMA_init(0, cpu_exit_irq);\n\n\n\n    /* Super I/O */\n\n    isa_create_simple(\"i8042\");\n\n\n\n    rtc_init(2000, NULL);\n\n\n\n    for(i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            serial_isa_init(i, serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    if (parallel_hds[0]) {\n\n        parallel_init(0, parallel_hds[0]);\n\n    }\n\n\n\n    /* Sound card */\n\n    audio_init(pci_bus);\n\n    /* Network card */\n\n    network_init();\n\n}\n", "idx": 21742}
{"project": "qemu", "commit_id": "1069985fb132cd4324fc02d371f1e61492a1823f", "target": 0, "func": "static ssize_t nic_receive(NetClientState *nc, const uint8_t * buf, size_t size)\n\n{\n\n    /* TODO:\n\n     * - Magic packets should set bit 30 in power management driver register.\n\n     * - Interesting packets should set bit 29 in power management driver register.\n\n     */\n\n    EEPRO100State *s = DO_UPCAST(NICState, nc, nc)->opaque;\n\n    uint16_t rfd_status = 0xa000;\n\n#if defined(CONFIG_PAD_RECEIVED_FRAMES)\n\n    uint8_t min_buf[60];\n\n#endif\n\n    static const uint8_t broadcast_macaddr[6] =\n\n        { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\n\n\n#if defined(CONFIG_PAD_RECEIVED_FRAMES)\n\n    /* Pad to minimum Ethernet frame length */\n\n    if (size < sizeof(min_buf)) {\n\n        memcpy(min_buf, buf, size);\n\n        memset(&min_buf[size], 0, sizeof(min_buf) - size);\n\n        buf = min_buf;\n\n        size = sizeof(min_buf);\n\n    }\n\n#endif\n\n\n\n    if (s->configuration[8] & 0x80) {\n\n        /* CSMA is disabled. */\n\n        logout(\"%p received while CSMA is disabled\\n\", s);\n\n        return -1;\n\n#if !defined(CONFIG_PAD_RECEIVED_FRAMES)\n\n    } else if (size < 64 && (s->configuration[7] & BIT(0))) {\n\n        /* Short frame and configuration byte 7/0 (discard short receive) set:\n\n         * Short frame is discarded */\n\n        logout(\"%p received short frame (%zu byte)\\n\", s, size);\n\n        s->statistics.rx_short_frame_errors++;\n\n        return -1;\n\n#endif\n\n    } else if ((size > MAX_ETH_FRAME_SIZE + 4) && !(s->configuration[18] & BIT(3))) {\n\n        /* Long frame and configuration byte 18/3 (long receive ok) not set:\n\n         * Long frames are discarded. */\n\n        logout(\"%p received long frame (%zu byte), ignored\\n\", s, size);\n\n        return -1;\n\n    } else if (memcmp(buf, s->conf.macaddr.a, 6) == 0) {       /* !!! */\n\n        /* Frame matches individual address. */\n\n        /* TODO: check configuration byte 15/4 (ignore U/L). */\n\n        TRACE(RXTX, logout(\"%p received frame for me, len=%zu\\n\", s, size));\n\n    } else if (memcmp(buf, broadcast_macaddr, 6) == 0) {\n\n        /* Broadcast frame. */\n\n        TRACE(RXTX, logout(\"%p received broadcast, len=%zu\\n\", s, size));\n\n        rfd_status |= 0x0002;\n\n    } else if (buf[0] & 0x01) {\n\n        /* Multicast frame. */\n\n        TRACE(RXTX, logout(\"%p received multicast, len=%zu,%s\\n\", s, size, nic_dump(buf, size)));\n\n        if (s->configuration[21] & BIT(3)) {\n\n          /* Multicast all bit is set, receive all multicast frames. */\n\n        } else {\n\n          unsigned mcast_idx = e100_compute_mcast_idx(buf);\n\n          assert(mcast_idx < 64);\n\n          if (s->mult[mcast_idx >> 3] & (1 << (mcast_idx & 7))) {\n\n            /* Multicast frame is allowed in hash table. */\n\n          } else if (s->configuration[15] & BIT(0)) {\n\n              /* Promiscuous: receive all. */\n\n              rfd_status |= 0x0004;\n\n          } else {\n\n              TRACE(RXTX, logout(\"%p multicast ignored\\n\", s));\n\n              return -1;\n\n          }\n\n        }\n\n        /* TODO: Next not for promiscuous mode? */\n\n        rfd_status |= 0x0002;\n\n    } else if (s->configuration[15] & BIT(0)) {\n\n        /* Promiscuous: receive all. */\n\n        TRACE(RXTX, logout(\"%p received frame in promiscuous mode, len=%zu\\n\", s, size));\n\n        rfd_status |= 0x0004;\n\n    } else if (s->configuration[20] & BIT(6)) {\n\n        /* Multiple IA bit set. */\n\n        unsigned mcast_idx = compute_mcast_idx(buf);\n\n        assert(mcast_idx < 64);\n\n        if (s->mult[mcast_idx >> 3] & (1 << (mcast_idx & 7))) {\n\n            TRACE(RXTX, logout(\"%p accepted, multiple IA bit set\\n\", s));\n\n        } else {\n\n            TRACE(RXTX, logout(\"%p frame ignored, multiple IA bit set\\n\", s));\n\n            return -1;\n\n        }\n\n    } else {\n\n        TRACE(RXTX, logout(\"%p received frame, ignored, len=%zu,%s\\n\", s, size,\n\n              nic_dump(buf, size)));\n\n        return size;\n\n    }\n\n\n\n    if (get_ru_state(s) != ru_ready) {\n\n        /* No resources available. */\n\n        logout(\"no resources, state=%u\\n\", get_ru_state(s));\n\n        /* TODO: RNR interrupt only at first failed frame? */\n\n        eepro100_rnr_interrupt(s);\n\n        s->statistics.rx_resource_errors++;\n\n#if 0\n\n        assert(!\"no resources\");\n\n#endif\n\n        return -1;\n\n    }\n\n    /* !!! */\n\n    eepro100_rx_t rx;\n\n    pci_dma_read(&s->dev, s->ru_base + s->ru_offset,\n\n                 &rx, sizeof(eepro100_rx_t));\n\n    uint16_t rfd_command = le16_to_cpu(rx.command);\n\n    uint16_t rfd_size = le16_to_cpu(rx.size);\n\n\n\n    if (size > rfd_size) {\n\n        logout(\"Receive buffer (%\" PRId16 \" bytes) too small for data \"\n\n            \"(%zu bytes); data truncated\\n\", rfd_size, size);\n\n        size = rfd_size;\n\n    }\n\n#if !defined(CONFIG_PAD_RECEIVED_FRAMES)\n\n    if (size < 64) {\n\n        rfd_status |= 0x0080;\n\n    }\n\n#endif\n\n    TRACE(OTHER, logout(\"command 0x%04x, link 0x%08x, addr 0x%08x, size %u\\n\",\n\n          rfd_command, rx.link, rx.rx_buf_addr, rfd_size));\n\n    stw_le_pci_dma(&s->dev, s->ru_base + s->ru_offset +\n\n                offsetof(eepro100_rx_t, status), rfd_status);\n\n    stw_le_pci_dma(&s->dev, s->ru_base + s->ru_offset +\n\n                offsetof(eepro100_rx_t, count), size);\n\n    /* Early receive interrupt not supported. */\n\n#if 0\n\n    eepro100_er_interrupt(s);\n\n#endif\n\n    /* Receive CRC Transfer not supported. */\n\n    if (s->configuration[18] & BIT(2)) {\n\n        missing(\"Receive CRC Transfer\");\n\n        return -1;\n\n    }\n\n    /* TODO: check stripping enable bit. */\n\n#if 0\n\n    assert(!(s->configuration[17] & BIT(0)));\n\n#endif\n\n    pci_dma_write(&s->dev, s->ru_base + s->ru_offset +\n\n                  sizeof(eepro100_rx_t), buf, size);\n\n    s->statistics.rx_good_frames++;\n\n    eepro100_fr_interrupt(s);\n\n    s->ru_offset = le32_to_cpu(rx.link);\n\n    if (rfd_command & COMMAND_EL) {\n\n        /* EL bit is set, so this was the last frame. */\n\n        logout(\"receive: Running out of frames\\n\");\n\n        set_ru_state(s, ru_suspended);\n\n    }\n\n    if (rfd_command & COMMAND_S) {\n\n        /* S bit is set. */\n\n        set_ru_state(s, ru_suspended);\n\n    }\n\n    return size;\n\n}\n", "idx": 21743}
{"project": "qemu", "commit_id": "a0efbf16604770b9d805bcf210ec29942321134f", "target": 0, "func": "void pci_bus_get_w64_range(PCIBus *bus, Range *range)\n\n{\n\n    range->begin = range->end = 0;\n\n    pci_for_each_device_under_bus(bus, pci_dev_get_w64, range);\n\n}\n", "idx": 21744}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void m5208_timer_write(void *opaque, target_phys_addr_t offset,\n\n                              uint64_t value, unsigned size)\n\n{\n\n    m5208_timer_state *s = (m5208_timer_state *)opaque;\n\n    int prescale;\n\n    int limit;\n\n    switch (offset) {\n\n    case 0:\n\n        /* The PIF bit is set-to-clear.  */\n\n        if (value & PCSR_PIF) {\n\n            s->pcsr &= ~PCSR_PIF;\n\n            value &= ~PCSR_PIF;\n\n        }\n\n        /* Avoid frobbing the timer if we're just twiddling IRQ bits. */\n\n        if (((s->pcsr ^ value) & ~PCSR_PIE) == 0) {\n\n            s->pcsr = value;\n\n            m5208_timer_update(s);\n\n            return;\n\n        }\n\n\n\n        if (s->pcsr & PCSR_EN)\n\n            ptimer_stop(s->timer);\n\n\n\n        s->pcsr = value;\n\n\n\n        prescale = 1 << ((s->pcsr & PCSR_PRE_MASK) >> PCSR_PRE_SHIFT);\n\n        ptimer_set_freq(s->timer, (SYS_FREQ / 2) / prescale);\n\n        if (s->pcsr & PCSR_RLD)\n\n            limit = s->pmr;\n\n        else\n\n            limit = 0xffff;\n\n        ptimer_set_limit(s->timer, limit, 0);\n\n\n\n        if (s->pcsr & PCSR_EN)\n\n            ptimer_run(s->timer, 0);\n\n        break;\n\n    case 2:\n\n        s->pmr = value;\n\n        s->pcsr &= ~PCSR_PIF;\n\n        if ((s->pcsr & PCSR_RLD) == 0) {\n\n            if (s->pcsr & PCSR_OVW)\n\n                ptimer_set_count(s->timer, value);\n\n        } else {\n\n            ptimer_set_limit(s->timer, value, s->pcsr & PCSR_OVW);\n\n        }\n\n        break;\n\n    case 4:\n\n        break;\n\n    default:\n\n        hw_error(\"m5208_timer_write: Bad offset 0x%x\\n\", (int)offset);\n\n        break;\n\n    }\n\n    m5208_timer_update(s);\n\n}\n", "idx": 21745}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static struct omap_pwt_s *omap_pwt_init(MemoryRegion *system_memory,\n\n                                        target_phys_addr_t base,\n\n                                        omap_clk clk)\n\n{\n\n    struct omap_pwt_s *s = g_malloc0(sizeof(*s));\n\n    s->clk = clk;\n\n    omap_pwt_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_pwt_ops, s,\n\n                          \"omap-pwt\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n    return s;\n\n}\n", "idx": 21746}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "CBus *cbus_init(qemu_irq dat)\n\n{\n\n    CBusPriv *s = (CBusPriv *) g_malloc0(sizeof(*s));\n\n\n\n    s->dat_out = dat;\n\n    s->cbus.clk = qemu_allocate_irqs(cbus_clk, s, 1)[0];\n\n    s->cbus.dat = qemu_allocate_irqs(cbus_dat, s, 1)[0];\n\n    s->cbus.sel = qemu_allocate_irqs(cbus_sel, s, 1)[0];\n\n\n\n    s->sel = 1;\n\n    s->clk = 0;\n\n    s->dat = 0;\n\n\n\n    return &s->cbus;\n\n}\n", "idx": 21748}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static int cp15_tls_load_store(CPUState *env, DisasContext *s, uint32_t insn, uint32_t rd)\n\n{\n\n    TCGv tmp;\n\n    int cpn = (insn >> 16) & 0xf;\n\n    int cpm = insn & 0xf;\n\n    int op = ((insn >> 5) & 7) | ((insn >> 18) & 0x38);\n\n\n\n    if (!arm_feature(env, ARM_FEATURE_V6K))\n\n        return 0;\n\n\n\n    if (!(cpn == 13 && cpm == 0))\n\n        return 0;\n\n\n\n    if (insn & ARM_CP_RW_BIT) {\n\n        switch (op) {\n\n        case 2:\n\n            tmp = load_cpu_field(cp15.c13_tls1);\n\n            break;\n\n        case 3:\n\n            tmp = load_cpu_field(cp15.c13_tls2);\n\n            break;\n\n        case 4:\n\n            tmp = load_cpu_field(cp15.c13_tls3);\n\n            break;\n\n        default:\n\n            return 0;\n\n        }\n\n        store_reg(s, rd, tmp);\n\n\n\n    } else {\n\n        tmp = load_reg(s, rd);\n\n        switch (op) {\n\n        case 2:\n\n            store_cpu_field(tmp, cp15.c13_tls1);\n\n            break;\n\n        case 3:\n\n            store_cpu_field(tmp, cp15.c13_tls2);\n\n            break;\n\n        case 4:\n\n            store_cpu_field(tmp, cp15.c13_tls3);\n\n            break;\n\n        default:\n\n            dead_tmp(tmp);\n\n            return 0;\n\n        }\n\n    }\n\n    return 1;\n\n}\n", "idx": 21749}
{"project": "qemu", "commit_id": "f51074cdc6e750daa3b6df727d83449a7e42b391", "target": 1, "func": "void hmp_pci_add(Monitor *mon, const QDict *qdict)\n\n{\n\n    PCIDevice *dev = NULL;\n\n    const char *pci_addr = qdict_get_str(qdict, \"pci_addr\");\n\n    const char *type = qdict_get_str(qdict, \"type\");\n\n    const char *opts = qdict_get_try_str(qdict, \"opts\");\n\n\n\n    /* strip legacy tag */\n\n    if (!strncmp(pci_addr, \"pci_addr=\", 9)) {\n\n        pci_addr += 9;\n\n    }\n\n\n\n    if (!opts) {\n\n        opts = \"\";\n\n    }\n\n\n\n    if (!strcmp(pci_addr, \"auto\"))\n\n        pci_addr = NULL;\n\n\n\n    if (strcmp(type, \"nic\") == 0) {\n\n        dev = qemu_pci_hot_add_nic(mon, pci_addr, opts);\n\n    } else if (strcmp(type, \"storage\") == 0) {\n\n        dev = qemu_pci_hot_add_storage(mon, pci_addr, opts);\n\n    } else {\n\n        monitor_printf(mon, \"invalid type: %s\\n\", type);\n\n    }\n\n\n\n    if (dev) {\n\n        monitor_printf(mon, \"OK root bus %s, bus %d, slot %d, function %d\\n\",\n\n                       pci_root_bus_path(dev),\n\n                       pci_bus_num(dev->bus), PCI_SLOT(dev->devfn),\n\n                       PCI_FUNC(dev->devfn));\n\n    } else\n\n        monitor_printf(mon, \"failed to add %s\\n\", opts);\n\n}\n", "idx": 21751}
{"project": "qemu", "commit_id": "40a1f64b468ee247fca3b237f0b89f066e59626c", "target": 1, "func": "static inline void gen_mtcr(CPUTriCoreState *env, DisasContext *ctx, TCGv r1,\n\n                            int32_t offset)\n\n{\n\n    if (ctx->hflags & TRICORE_HFLAG_SM) {\n\n        /* since we're caching PSW make this a special case */\n\n        if (offset == 0xfe04) {\n\n            gen_helper_psw_write(cpu_env, r1);\n\n        } else {\n\n            switch (offset) {\n\n#include \"csfr.def\"\n\n            }\n\n        }\n\n    } else {\n\n        /* generate privilege trap */\n\n    }\n\n}\n", "idx": 21763}
{"project": "qemu", "commit_id": "e0cf6d15e374c8db39acda551845ecc62f5205a3", "target": 1, "func": "m_free(struct mbuf *m)\n\n{\n\n\n\n  DEBUG_CALL(\"m_free\");\n\n  DEBUG_ARG(\"m = %lx\", (long )m);\n\n\n\n  if(m) {\n\n\t/* Remove from m_usedlist */\n\n\tif (m->m_flags & M_USEDLIST)\n\n\t   remque(m);\n\n\n\n\t/* If it's M_EXT, free() it */\n\n\tif (m->m_flags & M_EXT)\n\n\t   free(m->m_ext);\n\n\n\n\t/*\n\n\t * Either free() it or put it on the free list\n\n\t */\n\n\tif (m->m_flags & M_DOFREE) {\n\n\t\tfree(m);\n\n\t\tm->slirp->mbuf_alloced--;\n\n\t} else if ((m->m_flags & M_FREELIST) == 0) {\n\n\t\tinsque(m,&m->slirp->m_freelist);\n\n\t\tm->m_flags = M_FREELIST; /* Clobber other flags */\n\n\t}\n\n  } /* if(m) */\n\n}\n", "idx": 21764}
{"project": "qemu", "commit_id": "b5eff355460643d09e533024360fe0522f368c07", "target": 1, "func": "static int qcow_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int len, i, shift, ret;\n\n    QCowHeader header;\n\n\n\n    ret = bdrv_file_open(&s->hd, filename, flags | BDRV_O_AUTOGROW);\n\n    if (ret < 0)\n\n        return ret;\n\n    if (bdrv_pread(s->hd, 0, &header, sizeof(header)) != sizeof(header))\n\n        goto fail;\n\n    be32_to_cpus(&header.magic);\n\n    be32_to_cpus(&header.version);\n\n    be64_to_cpus(&header.backing_file_offset);\n\n    be32_to_cpus(&header.backing_file_size);\n\n    be64_to_cpus(&header.size);\n\n    be32_to_cpus(&header.cluster_bits);\n\n    be32_to_cpus(&header.crypt_method);\n\n    be64_to_cpus(&header.l1_table_offset);\n\n    be32_to_cpus(&header.l1_size);\n\n    be64_to_cpus(&header.refcount_table_offset);\n\n    be32_to_cpus(&header.refcount_table_clusters);\n\n    be64_to_cpus(&header.snapshots_offset);\n\n    be32_to_cpus(&header.nb_snapshots);\n\n\n\n    if (header.magic != QCOW_MAGIC || header.version != QCOW_VERSION)\n\n        goto fail;\n\n    if (header.size <= 1 ||\n\n        header.cluster_bits < 9 ||\n\n        header.cluster_bits > 16)\n\n        goto fail;\n\n    if (header.crypt_method > QCOW_CRYPT_AES)\n\n        goto fail;\n\n    s->crypt_method_header = header.crypt_method;\n\n    if (s->crypt_method_header)\n\n        bs->encrypted = 1;\n\n    s->cluster_bits = header.cluster_bits;\n\n    s->cluster_size = 1 << s->cluster_bits;\n\n    s->cluster_sectors = 1 << (s->cluster_bits - 9);\n\n    s->l2_bits = s->cluster_bits - 3; /* L2 is always one cluster */\n\n    s->l2_size = 1 << s->l2_bits;\n\n    bs->total_sectors = header.size / 512;\n\n    s->csize_shift = (62 - (s->cluster_bits - 8));\n\n    s->csize_mask = (1 << (s->cluster_bits - 8)) - 1;\n\n    s->cluster_offset_mask = (1LL << s->csize_shift) - 1;\n\n    s->refcount_table_offset = header.refcount_table_offset;\n\n    s->refcount_table_size =\n\n        header.refcount_table_clusters << (s->cluster_bits - 3);\n\n\n\n    s->snapshots_offset = header.snapshots_offset;\n\n    s->nb_snapshots = header.nb_snapshots;\n\n\n\n    /* read the level 1 table */\n\n    s->l1_size = header.l1_size;\n\n    shift = s->cluster_bits + s->l2_bits;\n\n    s->l1_vm_state_index = (header.size + (1LL << shift) - 1) >> shift;\n\n    /* the L1 table must contain at least enough entries to put\n\n       header.size bytes */\n\n    if (s->l1_size < s->l1_vm_state_index)\n\n        goto fail;\n\n    s->l1_table_offset = header.l1_table_offset;\n\n    s->l1_table = qemu_malloc(s->l1_size * sizeof(uint64_t));\n\n    if (!s->l1_table)\n\n        goto fail;\n\n    if (bdrv_pread(s->hd, s->l1_table_offset, s->l1_table, s->l1_size * sizeof(uint64_t)) !=\n\n        s->l1_size * sizeof(uint64_t))\n\n        goto fail;\n\n    for(i = 0;i < s->l1_size; i++) {\n\n        be64_to_cpus(&s->l1_table[i]);\n\n    }\n\n    /* alloc L2 cache */\n\n    s->l2_cache = qemu_malloc(s->l2_size * L2_CACHE_SIZE * sizeof(uint64_t));\n\n    if (!s->l2_cache)\n\n        goto fail;\n\n    s->cluster_cache = qemu_malloc(s->cluster_size);\n\n    if (!s->cluster_cache)\n\n        goto fail;\n\n    /* one more sector for decompressed data alignment */\n\n    s->cluster_data = qemu_malloc(s->cluster_size + 512);\n\n    if (!s->cluster_data)\n\n        goto fail;\n\n    s->cluster_cache_offset = -1;\n\n\n\n    if (refcount_init(bs) < 0)\n\n        goto fail;\n\n\n\n    /* read the backing file name */\n\n    if (header.backing_file_offset != 0) {\n\n        len = header.backing_file_size;\n\n        if (len > 1023)\n\n            len = 1023;\n\n        if (bdrv_pread(s->hd, header.backing_file_offset, bs->backing_file, len) != len)\n\n            goto fail;\n\n        bs->backing_file[len] = '\\0';\n\n    }\n\n    if (qcow_read_snapshots(bs) < 0)\n\n        goto fail;\n\n\n\n#ifdef DEBUG_ALLOC\n\n    check_refcounts(bs);\n\n#endif\n\n    return 0;\n\n\n\n fail:\n\n    qcow_free_snapshots(bs);\n\n    refcount_close(bs);\n\n    qemu_free(s->l1_table);\n\n    qemu_free(s->l2_cache);\n\n    qemu_free(s->cluster_cache);\n\n    qemu_free(s->cluster_data);\n\n    bdrv_delete(s->hd);\n\n    return -1;\n\n}\n", "idx": 21768}
{"project": "qemu", "commit_id": "3e48dd4a2d48aabafe22ce3611d65544d0234a69", "target": 1, "func": "static uint32_t rtl8139_io_readl(void *opaque, uint8_t addr)\n\n{\n\n    RTL8139State *s = opaque;\n\n    uint32_t ret;\n\n\n\n    switch (addr)\n\n    {\n\n        case RxMissed:\n\n            ret = s->RxMissed;\n\n\n\n            DPRINTF(\"RxMissed read val=0x%08x\\n\", ret);\n\n            break;\n\n\n\n        case TxConfig:\n\n            ret = rtl8139_TxConfig_read(s);\n\n            break;\n\n\n\n        case RxConfig:\n\n            ret = rtl8139_RxConfig_read(s);\n\n            break;\n\n\n\n        case TxStatus0 ... TxStatus0+4*4-1:\n\n            ret = rtl8139_TxStatus_read(s, addr, 4);\n\n            break;\n\n\n\n        case TxAddr0 ... TxAddr0+4*4-1:\n\n            ret = rtl8139_TxAddr_read(s, addr-TxAddr0);\n\n            break;\n\n\n\n        case RxBuf:\n\n            ret = rtl8139_RxBuf_read(s);\n\n            break;\n\n\n\n        case RxRingAddrLO:\n\n            ret = s->RxRingAddrLO;\n\n            DPRINTF(\"C+ RxRing low bits read val=0x%08x\\n\", ret);\n\n            break;\n\n\n\n        case RxRingAddrHI:\n\n            ret = s->RxRingAddrHI;\n\n            DPRINTF(\"C+ RxRing high bits read val=0x%08x\\n\", ret);\n\n            break;\n\n\n\n        case Timer:\n\n            ret = muldiv64(qemu_get_clock_ns(vm_clock) - s->TCTR_base,\n\n                           PCI_FREQUENCY, get_ticks_per_sec());\n\n            DPRINTF(\"TCTR Timer read val=0x%08x\\n\", ret);\n\n            break;\n\n\n\n        case FlashReg:\n\n            ret = s->TimerInt;\n\n            DPRINTF(\"FlashReg TimerInt read val=0x%08x\\n\", ret);\n\n            break;\n\n\n\n        default:\n\n            DPRINTF(\"ioport read(l) addr=0x%x via read(b)\\n\", addr);\n\n\n\n            ret  = rtl8139_io_readb(opaque, addr);\n\n            ret |= rtl8139_io_readb(opaque, addr + 1) << 8;\n\n            ret |= rtl8139_io_readb(opaque, addr + 2) << 16;\n\n            ret |= rtl8139_io_readb(opaque, addr + 3) << 24;\n\n\n\n            DPRINTF(\"read(l) addr=0x%x val=%08x\\n\", addr, ret);\n\n            break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 21769}
{"project": "qemu", "commit_id": "9ed5726c043958359b0f1fa44ab3e4f25f9d9a47", "target": 1, "func": "target_ulong helper_dvpe(target_ulong arg1)\n\n{\n\n    // TODO\n\n    arg1 = 0;\n\n    // rt = arg1\n\n\n\n    return arg1;\n\n}\n", "idx": 21773}
{"project": "qemu", "commit_id": "dfd917a9c2bed578c31043126c9f558190bf21e4", "target": 1, "func": "static void colo_compare_finalize(Object *obj)\n\n{\n\n    CompareState *s = COLO_COMPARE(obj);\n\n\n\n    qemu_chr_fe_deinit(&s->chr_pri_in);\n\n    qemu_chr_fe_deinit(&s->chr_sec_in);\n\n    qemu_chr_fe_deinit(&s->chr_out);\n\n\n\n    g_queue_free(&s->conn_list);\n\n\n\n    if (qemu_thread_is_self(&s->thread)) {\n\n        /* compare connection */\n\n        g_queue_foreach(&s->conn_list, colo_compare_connection, s);\n\n        qemu_thread_join(&s->thread);\n\n    }\n\n\n\n    g_free(s->pri_indev);\n\n    g_free(s->sec_indev);\n\n    g_free(s->outdev);\n\n}\n", "idx": 21774}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void cpu_dump_state(CPUState *env, FILE *f, \n\n                    int (*cpu_fprintf)(FILE *f, const char *fmt, ...),\n\n                    int flags)\n\n{\n\n#if defined(TARGET_PPC64) || 1\n\n#define FILL \"\"\n\n#define RGPL  4\n\n#define RFPL  4\n\n#else\n\n#define FILL \"        \"\n\n#define RGPL  8\n\n#define RFPL  4\n\n#endif\n\n\n\n    int i;\n\n\n\n    cpu_fprintf(f, \"NIP \" REGX \" LR \" REGX \" CTR \" REGX \"\\n\",\n\n                env->nip, env->lr, env->ctr);\n\n    cpu_fprintf(f, \"MSR \" REGX FILL \" XER %08x      TB %08x %08x \"\n\n#if !defined(CONFIG_USER_ONLY)\n\n                \"DECR %08x\"\n\n#endif\n\n                \"\\n\",\n\n                do_load_msr(env), load_xer(env), cpu_ppc_load_tbu(env),\n\n                cpu_ppc_load_tbl(env)\n\n#if !defined(CONFIG_USER_ONLY)\n\n                , cpu_ppc_load_decr(env)\n\n#endif\n\n                );\n\n    for (i = 0; i < 32; i++) {\n\n        if ((i & (RGPL - 1)) == 0)\n\n            cpu_fprintf(f, \"GPR%02d\", i);\n\n        cpu_fprintf(f, \" \" REGX, env->gpr[i]);\n\n        if ((i & (RGPL - 1)) == (RGPL - 1))\n\n            cpu_fprintf(f, \"\\n\");\n\n    }\n\n    cpu_fprintf(f, \"CR \");\n\n    for (i = 0; i < 8; i++)\n\n        cpu_fprintf(f, \"%01x\", env->crf[i]);\n\n    cpu_fprintf(f, \"  [\");\n\n    for (i = 0; i < 8; i++) {\n\n        char a = '-';\n\n        if (env->crf[i] & 0x08)\n\n            a = 'L';\n\n        else if (env->crf[i] & 0x04)\n\n            a = 'G';\n\n        else if (env->crf[i] & 0x02)\n\n            a = 'E';\n\n        cpu_fprintf(f, \" %c%c\", a, env->crf[i] & 0x01 ? 'O' : ' ');\n\n    }\n\n    cpu_fprintf(f, \" ]             \" FILL \"RES \" REGX \"\\n\", env->reserve);\n\n    for (i = 0; i < 32; i++) {\n\n        if ((i & (RFPL - 1)) == 0)\n\n            cpu_fprintf(f, \"FPR%02d\", i);\n\n        cpu_fprintf(f, \" %016\" PRIx64, *((uint64_t *)&env->fpr[i]));\n\n        if ((i & (RFPL - 1)) == (RFPL - 1))\n\n            cpu_fprintf(f, \"\\n\");\n\n    }\n\n    cpu_fprintf(f, \"SRR0 \" REGX \" SRR1 \" REGX \"         \" FILL FILL FILL\n\n                \"SDR1 \" REGX \"\\n\",\n\n                env->spr[SPR_SRR0], env->spr[SPR_SRR1], env->sdr1);\n\n\n\n#undef REGX\n\n#undef RGPL\n\n#undef RFPL\n\n#undef FILL\n\n}\n", "idx": 21775}
{"project": "qemu", "commit_id": "3c01ae0ea29915d165c384d0bd1cbafcf4364a4d", "target": 1, "func": "static void tci_out_label(TCGContext *s, TCGArg arg)\n\n{\n\n    TCGLabel *label = &s->labels[arg];\n\n    if (label->has_value) {\n\n        tcg_out_i(s, label->u.value);\n\n        assert(label->u.value);\n\n    } else {\n\n        tcg_out_reloc(s, s->code_ptr, sizeof(tcg_target_ulong), arg, 0);\n\n        tcg_out_i(s, 0);\n\n    }\n\n}\n", "idx": 21777}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static inline uint64_t ram_chunk_index(const uint8_t *start,\n\n                                       const uint8_t *host)\n\n{\n\n    return ((uintptr_t) host - (uintptr_t) start) >> RDMA_REG_CHUNK_SHIFT;\n\n}\n", "idx": 21789}
{"project": "qemu", "commit_id": "15fa08f8451babc88d733bd411d4c94976f9d0f8", "target": 1, "func": "static void arm_tr_insn_start(DisasContextBase *dcbase, CPUState *cpu)\n\n{\n\n    DisasContext *dc = container_of(dcbase, DisasContext, base);\n\n\n\n    dc->insn_start_idx = tcg_op_buf_count();\n\n    tcg_gen_insn_start(dc->pc,\n\n                       (dc->condexec_cond << 4) | (dc->condexec_mask >> 1),\n\n                       0);\n\n}\n", "idx": 21792}
{"project": "qemu", "commit_id": "ab3ad07f89c7f9e03c17c98e1d1a02dbf61c605c", "target": 1, "func": "static void kvm_hwpoison_page_add(ram_addr_t ram_addr)\n\n{\n\n    HWPoisonPage *page;\n\n\n\n    QLIST_FOREACH(page, &hwpoison_page_list, list) {\n\n        if (page->ram_addr == ram_addr) {\n\n            return;\n\n        }\n\n    }\n\n    page = g_malloc(sizeof(HWPoisonPage));\n\n    page->ram_addr = ram_addr;\n\n    QLIST_INSERT_HEAD(&hwpoison_page_list, page, list);\n\n}\n", "idx": 21794}
{"project": "qemu", "commit_id": "c9262e8a84a29f22fbb5edde5d17f4f6166d5ae1", "target": 1, "func": "void zipl_load(void)\n\n{\n\n    ScsiMbr *mbr = (void *)sec;\n\n    LDL_VTOC *vlbl = (void *)sec;\n\n\n\n    /* Grab the MBR */\n\n    memset(sec, FREE_SPACE_FILLER, sizeof(sec));\n\n    read_block(0, mbr, \"Cannot read block 0\");\n\n\n\n    dputs(\"checking magic\\n\");\n\n\n\n    if (magic_match(mbr->magic, ZIPL_MAGIC)) {\n\n        ipl_scsi(); /* no return */\n\n    }\n\n\n\n    /* Check if we can boot as ISO media */\n\n    if (virtio_guessed_disk_nature()) {\n\n        virtio_assume_iso9660();\n\n    }\n\n    ipl_iso_el_torito();\n\n\n\n    /* We have failed to follow the SCSI scheme, so */\n\n    if (virtio_guessed_disk_nature()) {\n\n        sclp_print(\"Using guessed DASD geometry.\\n\");\n\n        virtio_assume_eckd();\n\n    }\n\n    print_eckd_msg();\n\n    if (magic_match(mbr->magic, IPL1_MAGIC)) {\n\n        ipl_eckd_cdl(); /* no return */\n\n    }\n\n\n\n    /* LDL/CMS? */\n\n    memset(sec, FREE_SPACE_FILLER, sizeof(sec));\n\n    read_block(2, vlbl, \"Cannot read block 2\");\n\n\n\n    if (magic_match(vlbl->magic, CMS1_MAGIC)) {\n\n        ipl_eckd_ldl(ECKD_CMS); /* no return */\n\n    }\n\n    if (magic_match(vlbl->magic, LNX1_MAGIC)) {\n\n        ipl_eckd_ldl(ECKD_LDL); /* no return */\n\n    }\n\n\n\n    ipl_eckd_ldl(ECKD_LDL_UNLABELED); /* it still may return */\n\n    /*\n\n     * Ok, it is not a LDL by any means.\n\n     * It still might be a CDL with zero record keys for IPL1 and IPL2\n\n     */\n\n    ipl_eckd_cdl();\n\n\n\n    virtio_panic(\"\\n* this can never happen *\\n\");\n\n}\n", "idx": 21798}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "func": "void ppc_set_irq(PowerPCCPU *cpu, int n_IRQ, int level)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUPPCState *env = &cpu->env;\n\n    unsigned int old_pending = env->pending_interrupts;\n\n\n\n    if (level) {\n\n        env->pending_interrupts |= 1 << n_IRQ;\n\n        cpu_interrupt(cs, CPU_INTERRUPT_HARD);\n\n    } else {\n\n        env->pending_interrupts &= ~(1 << n_IRQ);\n\n        if (env->pending_interrupts == 0) {\n\n            cpu_reset_interrupt(cs, CPU_INTERRUPT_HARD);\n\n        }\n\n    }\n\n\n\n    if (old_pending != env->pending_interrupts) {\n\n#ifdef CONFIG_KVM\n\n        kvmppc_set_interrupt(cpu, n_IRQ, level);\n\n#endif\n\n    }\n\n\n\n    LOG_IRQ(\"%s: %p n_IRQ %d level %d => pending %08\" PRIx32\n\n                \"req %08x\\n\", __func__, env, n_IRQ, level,\n\n                env->pending_interrupts, CPU(cpu)->interrupt_request);\n\n}\n", "idx": 21799}
{"project": "qemu", "commit_id": "bdd81addf4033ce26e6cd180b060f63095f3ded9", "target": 1, "func": "static void vfio_vga_probe_ati_3c3_quirk(VFIOPCIDevice *vdev)\n\n{\n\n    VFIOQuirk *quirk;\n\n\n\n    /*\n\n     * As long as the BAR is >= 256 bytes it will be aligned such that the\n\n     * lower byte is always zero.  Filter out anything else, if it exists.\n\n     */\n\n    if (!vfio_pci_is(vdev, PCI_VENDOR_ID_ATI, PCI_ANY_ID) ||\n\n        !vdev->bars[4].ioport || vdev->bars[4].region.size < 256) {\n\n        return;\n\n    }\n\n\n\n    quirk = g_malloc0(sizeof(*quirk));\n\n    quirk->mem = g_malloc0(sizeof(MemoryRegion));\n\n    quirk->nr_mem = 1;\n\n\n\n    memory_region_init_io(quirk->mem, OBJECT(vdev), &vfio_ati_3c3_quirk, vdev,\n\n                          \"vfio-ati-3c3-quirk\", 1);\n\n    memory_region_add_subregion(&vdev->vga.region[QEMU_PCI_VGA_IO_HI].mem,\n\n                                3 /* offset 3 bytes from 0x3c0 */, quirk->mem);\n\n\n\n    QLIST_INSERT_HEAD(&vdev->vga.region[QEMU_PCI_VGA_IO_HI].quirks,\n\n                      quirk, next);\n\n\n\n    trace_vfio_quirk_ati_3c3_probe(vdev->vbasedev.name);\n\n}\n", "idx": 21800}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static void mem_info(Monitor *mon)\n\n{\n\n    CPUState *env;\n\n    int l1, l2, prot, last_prot;\n\n    uint32_t pgd, pde, pte, start, end;\n\n\n\n    env = mon_get_cpu();\n\n    if (!env)\n\n        return;\n\n\n\n    if (!(env->cr[0] & CR0_PG_MASK)) {\n\n        monitor_printf(mon, \"PG disabled\\n\");\n\n        return;\n\n    }\n\n    pgd = env->cr[3] & ~0xfff;\n\n    last_prot = 0;\n\n    start = -1;\n\n    for(l1 = 0; l1 < 1024; l1++) {\n\n        cpu_physical_memory_read(pgd + l1 * 4, (uint8_t *)&pde, 4);\n\n        pde = le32_to_cpu(pde);\n\n        end = l1 << 22;\n\n        if (pde & PG_PRESENT_MASK) {\n\n            if ((pde & PG_PSE_MASK) && (env->cr[4] & CR4_PSE_MASK)) {\n\n                prot = pde & (PG_USER_MASK | PG_RW_MASK | PG_PRESENT_MASK);\n\n                mem_print(mon, &start, &last_prot, end, prot);\n\n            } else {\n\n                for(l2 = 0; l2 < 1024; l2++) {\n\n                    cpu_physical_memory_read((pde & ~0xfff) + l2 * 4,\n\n                                             (uint8_t *)&pte, 4);\n\n                    pte = le32_to_cpu(pte);\n\n                    end = (l1 << 22) + (l2 << 12);\n\n                    if (pte & PG_PRESENT_MASK) {\n\n                        prot = pte & (PG_USER_MASK | PG_RW_MASK | PG_PRESENT_MASK);\n\n                    } else {\n\n                        prot = 0;\n\n                    }\n\n                    mem_print(mon, &start, &last_prot, end, prot);\n\n                }\n\n            }\n\n        } else {\n\n            prot = 0;\n\n            mem_print(mon, &start, &last_prot, end, prot);\n\n        }\n\n    }\n\n}\n", "idx": 21801}
{"project": "qemu", "commit_id": "2d528d45ecf5ee3c1a566a9f3d664464925ef830", "target": 1, "func": "CharDriverState *chr_testdev_init(void)\n\n{\n\n    TestdevCharState *testdev;\n\n    CharDriverState *chr;\n\n\n\n    testdev = g_malloc0(sizeof(TestdevCharState));\n\n    testdev->chr = chr = g_malloc0(sizeof(CharDriverState));\n\n\n\n    chr->opaque = testdev;\n\n    chr->chr_write = testdev_write;\n\n    chr->chr_close = testdev_close;\n\n\n\n    return chr;\n\n}\n", "idx": 21802}
{"project": "qemu", "commit_id": "f4658285f99473367dbbc34ce6970ec4637c2388", "target": 1, "func": "static int coroutine_fn bdrv_co_do_writev(BlockDriverState *bs,\n    int64_t sector_num, int nb_sectors, QEMUIOVector *qiov)\n{\n    BlockDriver *drv = bs->drv;\n    BdrvTrackedRequest req;\n    int ret;\n    if (!bs->drv) {\n        return -ENOMEDIUM;\n    if (bs->read_only) {\n        return -EACCES;\n    if (bdrv_check_request(bs, sector_num, nb_sectors)) {\n        return -EIO;\n    /* throttling disk write I/O */\n    if (bs->io_limits_enabled) {\n        bdrv_io_limits_intercept(bs, true, nb_sectors);\n    tracked_request_begin(&req, bs, sector_num, nb_sectors, true);\n    ret = drv->bdrv_co_writev(bs, sector_num, nb_sectors, qiov);\n    if (bs->dirty_bitmap) {\n        set_dirty_bitmap(bs, sector_num, nb_sectors, 1);\n    if (bs->wr_highest_sector < sector_num + nb_sectors - 1) {\n        bs->wr_highest_sector = sector_num + nb_sectors - 1;\n    tracked_request_end(&req);\n    return ret;", "idx": 21803}
{"project": "qemu", "commit_id": "ae50b2747f77944faa79eb914272b54eb30b63b3", "target": 1, "func": "void *etraxfs_eth_init(NICInfo *nd, target_phys_addr_t base, int phyaddr)\n\n{\n\n\tstruct etraxfs_dma_client *dma = NULL;\t\n\n\tstruct fs_eth *eth = NULL;\n\n\n\n\tqemu_check_nic_model(nd, \"fseth\");\n\n\n\n\tdma = qemu_mallocz(sizeof *dma * 2);\n\n\teth = qemu_mallocz(sizeof *eth);\n\n\n\n\tdma[0].client.push = eth_tx_push;\n\n\tdma[0].client.opaque = eth;\n\n\tdma[1].client.opaque = eth;\n\n\tdma[1].client.pull = NULL;\n\n\n\n\teth->dma_out = dma;\n\n\teth->dma_in = dma + 1;\n\n\n\n\t/* Connect the phy.  */\n\n\teth->phyaddr = phyaddr & 0x1f;\n\n\ttdk_init(&eth->phy);\n\n\tmdio_attach(&eth->mdio_bus, &eth->phy, eth->phyaddr);\n\n\n\n\teth->ethregs = cpu_register_io_memory(eth_read, eth_write, eth);\n\n\tcpu_register_physical_memory (base, 0x5c, eth->ethregs);\n\n\n\n\teth->vc = qemu_new_vlan_client(nd->vlan, nd->model, nd->name,\n\n\t\t\t\t       eth_can_receive, eth_receive, NULL,\n\n\t\t\t\t       eth_cleanup, eth);\n\n\teth->vc->opaque = eth;\n\n\teth->vc->link_status_changed = eth_set_link;\n\n\n\n\treturn dma;\n\n}\n", "idx": 21804}
{"project": "qemu", "commit_id": "80e1eea37a25a7696137e680285e36d0bfdc9f34", "target": 1, "func": "static QVirtioPCIDevice *virtio_blk_pci_init(QPCIBus *bus, int slot)\n\n{\n\n    QVirtioPCIDevice *dev;\n\n\n\n    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_BLOCK);\n\n    g_assert(dev != NULL);\n\n    g_assert_cmphex(dev->vdev.device_type, ==, VIRTIO_ID_BLOCK);\n\n    g_assert_cmphex(dev->pdev->devfn, ==, ((slot << 3) | PCI_FN));\n\n\n\n    qvirtio_pci_device_enable(dev);\n\n    qvirtio_reset(&dev->vdev);\n\n    qvirtio_set_acknowledge(&dev->vdev);\n\n    qvirtio_set_driver(&dev->vdev);\n\n\n\n    return dev;\n\n}\n", "idx": 21807}
{"project": "qemu", "commit_id": "81c219ac6ce0d6182e35f3976f2caa4cefcaf9f0", "target": 1, "func": "static int64_t coroutine_fn bdrv_co_get_block_status(BlockDriverState *bs,\n\n                                                     int64_t sector_num,\n\n                                                     int nb_sectors, int *pnum,\n\n                                                     BlockDriverState **file)\n\n{\n\n    int64_t total_sectors;\n\n    int64_t n;\n\n    int64_t ret, ret2;\n\n\n\n    total_sectors = bdrv_nb_sectors(bs);\n\n    if (total_sectors < 0) {\n\n        return total_sectors;\n\n    }\n\n\n\n    if (sector_num >= total_sectors) {\n\n        *pnum = 0;\n\n        return BDRV_BLOCK_EOF;\n\n    }\n\n\n\n    n = total_sectors - sector_num;\n\n    if (n < nb_sectors) {\n\n        nb_sectors = n;\n\n    }\n\n\n\n    if (!bs->drv->bdrv_co_get_block_status) {\n\n        *pnum = nb_sectors;\n\n        ret = BDRV_BLOCK_DATA | BDRV_BLOCK_ALLOCATED;\n\n        if (sector_num + nb_sectors == total_sectors) {\n\n            ret |= BDRV_BLOCK_EOF;\n\n        }\n\n        if (bs->drv->protocol_name) {\n\n            ret |= BDRV_BLOCK_OFFSET_VALID | (sector_num * BDRV_SECTOR_SIZE);\n\n        }\n\n        return ret;\n\n    }\n\n\n\n    *file = NULL;\n\n    bdrv_inc_in_flight(bs);\n\n    ret = bs->drv->bdrv_co_get_block_status(bs, sector_num, nb_sectors, pnum,\n\n                                            file);\n\n    if (ret < 0) {\n\n        *pnum = 0;\n\n        goto out;\n\n    }\n\n\n\n    if (ret & BDRV_BLOCK_RAW) {\n\n        assert(ret & BDRV_BLOCK_OFFSET_VALID);\n\n        ret = bdrv_co_get_block_status(*file, ret >> BDRV_SECTOR_BITS,\n\n                                       *pnum, pnum, file);\n\n        goto out;\n\n    }\n\n\n\n    if (ret & (BDRV_BLOCK_DATA | BDRV_BLOCK_ZERO)) {\n\n        ret |= BDRV_BLOCK_ALLOCATED;\n\n    } else {\n\n        if (bdrv_unallocated_blocks_are_zero(bs)) {\n\n            ret |= BDRV_BLOCK_ZERO;\n\n        } else if (bs->backing) {\n\n            BlockDriverState *bs2 = bs->backing->bs;\n\n            int64_t nb_sectors2 = bdrv_nb_sectors(bs2);\n\n            if (nb_sectors2 >= 0 && sector_num >= nb_sectors2) {\n\n                ret |= BDRV_BLOCK_ZERO;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (*file && *file != bs &&\n\n        (ret & BDRV_BLOCK_DATA) && !(ret & BDRV_BLOCK_ZERO) &&\n\n        (ret & BDRV_BLOCK_OFFSET_VALID)) {\n\n        BlockDriverState *file2;\n\n        int file_pnum;\n\n\n\n        ret2 = bdrv_co_get_block_status(*file, ret >> BDRV_SECTOR_BITS,\n\n                                        *pnum, &file_pnum, &file2);\n\n        if (ret2 >= 0) {\n\n            /* Ignore errors.  This is just providing extra information, it\n\n             * is useful but not necessary.\n\n             */\n\n            if (ret2 & BDRV_BLOCK_EOF &&\n\n                (!file_pnum || ret2 & BDRV_BLOCK_ZERO)) {\n\n                /*\n\n                 * It is valid for the format block driver to read\n\n                 * beyond the end of the underlying file's current\n\n                 * size; such areas read as zero.\n\n                 */\n\n                ret |= BDRV_BLOCK_ZERO;\n\n            } else {\n\n                /* Limit request to the range reported by the protocol driver */\n\n                *pnum = file_pnum;\n\n                ret |= (ret2 & BDRV_BLOCK_ZERO);\n\n            }\n\n        }\n\n    }\n\n\n\nout:\n\n    bdrv_dec_in_flight(bs);\n\n    if (ret >= 0 && sector_num + *pnum == total_sectors) {\n\n        ret |= BDRV_BLOCK_EOF;\n\n    }\n\n    return ret;\n\n}\n", "idx": 21808}
{"project": "qemu", "commit_id": "4652b8f3e1ec91bb9d6f00e40df7f96d1f1aafee", "target": 1, "func": "static int qcow2_do_open(BlockDriverState *bs, QDict *options, int flags,\n\n                         Error **errp)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    unsigned int len, i;\n\n    int ret = 0;\n\n    QCowHeader header;\n\n    Error *local_err = NULL;\n\n    uint64_t ext_end;\n\n    uint64_t l1_vm_state_index;\n\n\n\n    ret = bdrv_pread(bs->file, 0, &header, sizeof(header));\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"Could not read qcow2 header\");\n\n        goto fail;\n\n    }\n\n    be32_to_cpus(&header.magic);\n\n    be32_to_cpus(&header.version);\n\n    be64_to_cpus(&header.backing_file_offset);\n\n    be32_to_cpus(&header.backing_file_size);\n\n    be64_to_cpus(&header.size);\n\n    be32_to_cpus(&header.cluster_bits);\n\n    be32_to_cpus(&header.crypt_method);\n\n    be64_to_cpus(&header.l1_table_offset);\n\n    be32_to_cpus(&header.l1_size);\n\n    be64_to_cpus(&header.refcount_table_offset);\n\n    be32_to_cpus(&header.refcount_table_clusters);\n\n    be64_to_cpus(&header.snapshots_offset);\n\n    be32_to_cpus(&header.nb_snapshots);\n\n\n\n    if (header.magic != QCOW_MAGIC) {\n\n        error_setg(errp, \"Image is not in qcow2 format\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    if (header.version < 2 || header.version > 3) {\n\n        error_setg(errp, \"Unsupported qcow2 version %\" PRIu32, header.version);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    }\n\n\n\n    s->qcow_version = header.version;\n\n\n\n    /* Initialise cluster size */\n\n    if (header.cluster_bits < MIN_CLUSTER_BITS ||\n\n        header.cluster_bits > MAX_CLUSTER_BITS) {\n\n        error_setg(errp, \"Unsupported cluster size: 2^%\" PRIu32,\n\n                   header.cluster_bits);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    s->cluster_bits = header.cluster_bits;\n\n    s->cluster_size = 1 << s->cluster_bits;\n\n    s->cluster_sectors = 1 << (s->cluster_bits - 9);\n\n\n\n    /* Initialise version 3 header fields */\n\n    if (header.version == 2) {\n\n        header.incompatible_features    = 0;\n\n        header.compatible_features      = 0;\n\n        header.autoclear_features       = 0;\n\n        header.refcount_order           = 4;\n\n        header.header_length            = 72;\n\n    } else {\n\n        be64_to_cpus(&header.incompatible_features);\n\n        be64_to_cpus(&header.compatible_features);\n\n        be64_to_cpus(&header.autoclear_features);\n\n        be32_to_cpus(&header.refcount_order);\n\n        be32_to_cpus(&header.header_length);\n\n\n\n        if (header.header_length < 104) {\n\n            error_setg(errp, \"qcow2 header too short\");\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    if (header.header_length > s->cluster_size) {\n\n        error_setg(errp, \"qcow2 header exceeds cluster size\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    if (header.header_length > sizeof(header)) {\n\n        s->unknown_header_fields_size = header.header_length - sizeof(header);\n\n        s->unknown_header_fields = g_malloc(s->unknown_header_fields_size);\n\n        ret = bdrv_pread(bs->file, sizeof(header), s->unknown_header_fields,\n\n                         s->unknown_header_fields_size);\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret, \"Could not read unknown qcow2 header \"\n\n                             \"fields\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    if (header.backing_file_offset > s->cluster_size) {\n\n        error_setg(errp, \"Invalid backing file offset\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    if (header.backing_file_offset) {\n\n        ext_end = header.backing_file_offset;\n\n    } else {\n\n        ext_end = 1 << header.cluster_bits;\n\n    }\n\n\n\n    /* Handle feature bits */\n\n    s->incompatible_features    = header.incompatible_features;\n\n    s->compatible_features      = header.compatible_features;\n\n    s->autoclear_features       = header.autoclear_features;\n\n\n\n    if (s->incompatible_features & ~QCOW2_INCOMPAT_MASK) {\n\n        void *feature_table = NULL;\n\n        qcow2_read_extensions(bs, header.header_length, ext_end,\n\n                              &feature_table, NULL);\n\n        report_unsupported_feature(errp, feature_table,\n\n                                   s->incompatible_features &\n\n                                   ~QCOW2_INCOMPAT_MASK);\n\n        ret = -ENOTSUP;\n\n        g_free(feature_table);\n\n        goto fail;\n\n    }\n\n\n\n    if (s->incompatible_features & QCOW2_INCOMPAT_CORRUPT) {\n\n        /* Corrupt images may not be written to unless they are being repaired\n\n         */\n\n        if ((flags & BDRV_O_RDWR) && !(flags & BDRV_O_CHECK)) {\n\n            error_setg(errp, \"qcow2: Image is corrupt; cannot be opened \"\n\n                       \"read/write\");\n\n            ret = -EACCES;\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    /* Check support for various header values */\n\n    if (header.refcount_order > 6) {\n\n        error_setg(errp, \"Reference count entry width too large; may not \"\n\n                   \"exceed 64 bits\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    s->refcount_order = header.refcount_order;\n\n    s->refcount_bits = 1 << s->refcount_order;\n\n    s->refcount_max = UINT64_C(1) << (s->refcount_bits - 1);\n\n    s->refcount_max += s->refcount_max - 1;\n\n\n\n    if (header.crypt_method > QCOW_CRYPT_AES) {\n\n        error_setg(errp, \"Unsupported encryption method: %\" PRIu32,\n\n                   header.crypt_method);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    s->crypt_method_header = header.crypt_method;\n\n    if (s->crypt_method_header) {\n\n        if (bdrv_uses_whitelist() &&\n\n            s->crypt_method_header == QCOW_CRYPT_AES) {\n\n            error_setg(errp,\n\n                       \"Use of AES-CBC encrypted qcow2 images is no longer \"\n\n                       \"supported in system emulators\");\n\n            error_append_hint(errp,\n\n                              \"You can use 'qemu-img convert' to convert your \"\n\n                              \"image to an alternative supported format, such \"\n\n                              \"as unencrypted qcow2, or raw with the LUKS \"\n\n                              \"format instead.\\n\");\n\n            ret = -ENOSYS;\n\n            goto fail;\n\n        }\n\n\n\n        bs->encrypted = true;\n\n        bs->valid_key = true;\n\n    }\n\n\n\n    s->l2_bits = s->cluster_bits - 3; /* L2 is always one cluster */\n\n    s->l2_size = 1 << s->l2_bits;\n\n    /* 2^(s->refcount_order - 3) is the refcount width in bytes */\n\n    s->refcount_block_bits = s->cluster_bits - (s->refcount_order - 3);\n\n    s->refcount_block_size = 1 << s->refcount_block_bits;\n\n    bs->total_sectors = header.size / 512;\n\n    s->csize_shift = (62 - (s->cluster_bits - 8));\n\n    s->csize_mask = (1 << (s->cluster_bits - 8)) - 1;\n\n    s->cluster_offset_mask = (1LL << s->csize_shift) - 1;\n\n\n\n    s->refcount_table_offset = header.refcount_table_offset;\n\n    s->refcount_table_size =\n\n        header.refcount_table_clusters << (s->cluster_bits - 3);\n\n\n\n    if (header.refcount_table_clusters > qcow2_max_refcount_clusters(s)) {\n\n        error_setg(errp, \"Reference count table too large\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    ret = validate_table_offset(bs, s->refcount_table_offset,\n\n                                s->refcount_table_size, sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Invalid reference count table offset\");\n\n        goto fail;\n\n    }\n\n\n\n    /* Snapshot table offset/length */\n\n    if (header.nb_snapshots > QCOW_MAX_SNAPSHOTS) {\n\n        error_setg(errp, \"Too many snapshots\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    ret = validate_table_offset(bs, header.snapshots_offset,\n\n                                header.nb_snapshots,\n\n                                sizeof(QCowSnapshotHeader));\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Invalid snapshot table offset\");\n\n        goto fail;\n\n    }\n\n\n\n    /* read the level 1 table */\n\n    if (header.l1_size > QCOW_MAX_L1_SIZE / sizeof(uint64_t)) {\n\n        error_setg(errp, \"Active L1 table too large\");\n\n        ret = -EFBIG;\n\n        goto fail;\n\n    }\n\n    s->l1_size = header.l1_size;\n\n\n\n    l1_vm_state_index = size_to_l1(s, header.size);\n\n    if (l1_vm_state_index > INT_MAX) {\n\n        error_setg(errp, \"Image is too big\");\n\n        ret = -EFBIG;\n\n        goto fail;\n\n    }\n\n    s->l1_vm_state_index = l1_vm_state_index;\n\n\n\n    /* the L1 table must contain at least enough entries to put\n\n       header.size bytes */\n\n    if (s->l1_size < s->l1_vm_state_index) {\n\n        error_setg(errp, \"L1 table is too small\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    ret = validate_table_offset(bs, header.l1_table_offset,\n\n                                header.l1_size, sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Invalid L1 table offset\");\n\n        goto fail;\n\n    }\n\n    s->l1_table_offset = header.l1_table_offset;\n\n\n\n\n\n    if (s->l1_size > 0) {\n\n        s->l1_table = qemu_try_blockalign(bs->file->bs,\n\n            align_offset(s->l1_size * sizeof(uint64_t), 512));\n\n        if (s->l1_table == NULL) {\n\n            error_setg(errp, \"Could not allocate L1 table\");\n\n            ret = -ENOMEM;\n\n            goto fail;\n\n        }\n\n        ret = bdrv_pread(bs->file, s->l1_table_offset, s->l1_table,\n\n                         s->l1_size * sizeof(uint64_t));\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret, \"Could not read L1 table\");\n\n            goto fail;\n\n        }\n\n        for(i = 0;i < s->l1_size; i++) {\n\n            be64_to_cpus(&s->l1_table[i]);\n\n        }\n\n    }\n\n\n\n    /* Parse driver-specific options */\n\n    ret = qcow2_update_options(bs, options, flags, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    s->cluster_cache = g_malloc(s->cluster_size);\n\n    /* one more sector for decompressed data alignment */\n\n    s->cluster_data = qemu_try_blockalign(bs->file->bs, QCOW_MAX_CRYPT_CLUSTERS\n\n                                                    * s->cluster_size + 512);\n\n    if (s->cluster_data == NULL) {\n\n        error_setg(errp, \"Could not allocate temporary cluster buffer\");\n\n        ret = -ENOMEM;\n\n        goto fail;\n\n    }\n\n\n\n    s->cluster_cache_offset = -1;\n\n    s->flags = flags;\n\n\n\n    ret = qcow2_refcount_init(bs);\n\n    if (ret != 0) {\n\n        error_setg_errno(errp, -ret, \"Could not initialize refcount handling\");\n\n        goto fail;\n\n    }\n\n\n\n    QLIST_INIT(&s->cluster_allocs);\n\n    QTAILQ_INIT(&s->discards);\n\n\n\n    /* read qcow2 extensions */\n\n    if (qcow2_read_extensions(bs, header.header_length, ext_end, NULL,\n\n        &local_err)) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    if (s->crypt_method_header == QCOW_CRYPT_AES) {\n\n        unsigned int cflags = 0;\n\n        if (flags & BDRV_O_NO_IO) {\n\n            cflags |= QCRYPTO_BLOCK_OPEN_NO_IO;\n\n        }\n\n        s->crypto = qcrypto_block_open(s->crypto_opts, NULL, NULL,\n\n                                       cflags, errp);\n\n        if (!s->crypto) {\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    /* read the backing file name */\n\n    if (header.backing_file_offset != 0) {\n\n        len = header.backing_file_size;\n\n        if (len > MIN(1023, s->cluster_size - header.backing_file_offset) ||\n\n            len >= sizeof(bs->backing_file)) {\n\n            error_setg(errp, \"Backing file name too long\");\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n        ret = bdrv_pread(bs->file, header.backing_file_offset,\n\n                         bs->backing_file, len);\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret, \"Could not read backing file name\");\n\n            goto fail;\n\n        }\n\n        bs->backing_file[len] = '\\0';\n\n        s->image_backing_file = g_strdup(bs->backing_file);\n\n    }\n\n\n\n    /* Internal snapshots */\n\n    s->snapshots_offset = header.snapshots_offset;\n\n    s->nb_snapshots = header.nb_snapshots;\n\n\n\n    ret = qcow2_read_snapshots(bs);\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"Could not read snapshots\");\n\n        goto fail;\n\n    }\n\n\n\n    /* Clear unknown autoclear feature bits */\n\n    if (!bs->read_only && !(flags & BDRV_O_INACTIVE) && s->autoclear_features) {\n\n        s->autoclear_features = 0;\n\n        ret = qcow2_update_header(bs);\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret, \"Could not update qcow2 header\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    /* Initialise locks */\n\n    qemu_co_mutex_init(&s->lock);\n\n    bs->supported_zero_flags = BDRV_REQ_MAY_UNMAP;\n\n\n\n    /* Repair image if dirty */\n\n    if (!(flags & (BDRV_O_CHECK | BDRV_O_INACTIVE)) && !bs->read_only &&\n\n        (s->incompatible_features & QCOW2_INCOMPAT_DIRTY)) {\n\n        BdrvCheckResult result = {0};\n\n\n\n        ret = qcow2_check(bs, &result, BDRV_FIX_ERRORS | BDRV_FIX_LEAKS);\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret, \"Could not repair dirty image\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n#ifdef DEBUG_ALLOC\n\n    {\n\n        BdrvCheckResult result = {0};\n\n        qcow2_check_refcounts(bs, &result, 0);\n\n    }\n\n#endif\n\n    return ret;\n\n\n\n fail:\n\n    g_free(s->unknown_header_fields);\n\n    cleanup_unknown_header_ext(bs);\n\n    qcow2_free_snapshots(bs);\n\n    qcow2_refcount_close(bs);\n\n    qemu_vfree(s->l1_table);\n\n    /* else pre-write overlap checks in cache_destroy may crash */\n\n    s->l1_table = NULL;\n\n    cache_clean_timer_del(bs);\n\n    if (s->l2_table_cache) {\n\n        qcow2_cache_destroy(bs, s->l2_table_cache);\n\n    }\n\n    if (s->refcount_block_cache) {\n\n        qcow2_cache_destroy(bs, s->refcount_block_cache);\n\n    }\n\n    g_free(s->cluster_cache);\n\n    qemu_vfree(s->cluster_data);\n\n    qcrypto_block_free(s->crypto);\n\n    qapi_free_QCryptoBlockOpenOptions(s->crypto_opts);\n\n    return ret;\n\n}\n", "idx": 21809}
{"project": "qemu", "commit_id": "372579427a5040a26dfee78464b50e2bdf27ef26", "target": 1, "func": "static void *qemu_tcg_cpu_thread_fn(void *arg)\n\n{\n\n    CPUState *cpu = arg;\n\n\n\n    rcu_register_thread();\n\n\n\n    qemu_mutex_lock_iothread();\n\n    qemu_thread_get_self(cpu->thread);\n\n\n\n    CPU_FOREACH(cpu) {\n\n        cpu->thread_id = qemu_get_thread_id();\n\n        cpu->created = true;\n\n        cpu->can_do_io = 1;\n\n    }\n\n    qemu_cond_signal(&qemu_cpu_cond);\n\n\n\n    /* wait for initial kick-off after machine start */\n\n    while (first_cpu->stopped) {\n\n        qemu_cond_wait(first_cpu->halt_cond, &qemu_global_mutex);\n\n\n\n        /* process any pending work */\n\n        CPU_FOREACH(cpu) {\n\n            qemu_wait_io_event_common(cpu);\n\n        }\n\n    }\n\n\n\n    start_tcg_kick_timer();\n\n\n\n    cpu = first_cpu;\n\n\n\n    /* process any pending work */\n\n    cpu->exit_request = 1;\n\n\n\n    while (1) {\n\n        /* Account partial waits to QEMU_CLOCK_VIRTUAL.  */\n\n        qemu_account_warp_timer();\n\n\n\n        if (!cpu) {\n\n            cpu = first_cpu;\n\n        }\n\n\n\n        while (cpu && !cpu->queued_work_first && !cpu->exit_request) {\n\n\n\n            atomic_mb_set(&tcg_current_rr_cpu, cpu);\n\n\n\n            qemu_clock_enable(QEMU_CLOCK_VIRTUAL,\n\n                              (cpu->singlestep_enabled & SSTEP_NOTIMER) == 0);\n\n\n\n            if (cpu_can_run(cpu)) {\n\n                int r;\n\n                r = tcg_cpu_exec(cpu);\n\n                if (r == EXCP_DEBUG) {\n\n                    cpu_handle_guest_debug(cpu);\n\n                    break;\n\n                }\n\n            } else if (cpu->stop || cpu->stopped) {\n\n                if (cpu->unplug) {\n\n                    cpu = CPU_NEXT(cpu);\n\n                }\n\n                break;\n\n            }\n\n\n\n            cpu = CPU_NEXT(cpu);\n\n        } /* while (cpu && !cpu->exit_request).. */\n\n\n\n        /* Does not need atomic_mb_set because a spurious wakeup is okay.  */\n\n        atomic_set(&tcg_current_rr_cpu, NULL);\n\n\n\n        if (cpu && cpu->exit_request) {\n\n            atomic_mb_set(&cpu->exit_request, 0);\n\n        }\n\n\n\n        handle_icount_deadline();\n\n\n\n        qemu_tcg_wait_io_event(QTAILQ_FIRST(&cpus));\n\n        deal_with_unplugged_cpus();\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 21810}
{"project": "qemu", "commit_id": "772034b63e9c0caf6c92e31413f2d8df2ee69c88", "target": 1, "func": "static int elf_core_dump(int signr, const CPUArchState *env)\n\n{\n\n    const CPUState *cpu = ENV_GET_CPU((CPUArchState *)env);\n\n    const TaskState *ts = (const TaskState *)cpu->opaque;\n\n    struct vm_area_struct *vma = NULL;\n\n    char corefile[PATH_MAX];\n\n    struct elf_note_info info;\n\n    struct elfhdr elf;\n\n    struct elf_phdr phdr;\n\n    struct rlimit dumpsize;\n\n    struct mm_struct *mm = NULL;\n\n    off_t offset = 0, data_offset = 0;\n\n    int segs = 0;\n\n    int fd = -1;\n\n\n\n    init_note_info(&info);\n\n\n\n    errno = 0;\n\n    getrlimit(RLIMIT_CORE, &dumpsize);\n\n    if (dumpsize.rlim_cur == 0)\n\n        return 0;\n\n\n\n    if (core_dump_filename(ts, corefile, sizeof (corefile)) < 0)\n\n        return (-errno);\n\n\n\n    if ((fd = open(corefile, O_WRONLY | O_CREAT,\n\n                   S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) < 0)\n\n        return (-errno);\n\n\n\n    /*\n\n     * Walk through target process memory mappings and\n\n     * set up structure containing this information.  After\n\n     * this point vma_xxx functions can be used.\n\n     */\n\n    if ((mm = vma_init()) == NULL)\n\n        goto out;\n\n\n\n    walk_memory_regions(mm, vma_walker);\n\n    segs = vma_get_mapping_count(mm);\n\n\n\n    /*\n\n     * Construct valid coredump ELF header.  We also\n\n     * add one more segment for notes.\n\n     */\n\n    fill_elf_header(&elf, segs + 1, ELF_MACHINE, 0);\n\n    if (dump_write(fd, &elf, sizeof (elf)) != 0)\n\n        goto out;\n\n\n\n    /* fill in the in-memory version of notes */\n\n    if (fill_note_info(&info, signr, env) < 0)\n\n        goto out;\n\n\n\n    offset += sizeof (elf);                             /* elf header */\n\n    offset += (segs + 1) * sizeof (struct elf_phdr);    /* program headers */\n\n\n\n    /* write out notes program header */\n\n    fill_elf_note_phdr(&phdr, info.notes_size, offset);\n\n\n\n    offset += info.notes_size;\n\n    if (dump_write(fd, &phdr, sizeof (phdr)) != 0)\n\n        goto out;\n\n\n\n    /*\n\n     * ELF specification wants data to start at page boundary so\n\n     * we align it here.\n\n     */\n\n    data_offset = offset = roundup(offset, ELF_EXEC_PAGESIZE);\n\n\n\n    /*\n\n     * Write program headers for memory regions mapped in\n\n     * the target process.\n\n     */\n\n    for (vma = vma_first(mm); vma != NULL; vma = vma_next(vma)) {\n\n        (void) memset(&phdr, 0, sizeof (phdr));\n\n\n\n        phdr.p_type = PT_LOAD;\n\n        phdr.p_offset = offset;\n\n        phdr.p_vaddr = vma->vma_start;\n\n        phdr.p_paddr = 0;\n\n        phdr.p_filesz = vma_dump_size(vma);\n\n        offset += phdr.p_filesz;\n\n        phdr.p_memsz = vma->vma_end - vma->vma_start;\n\n        phdr.p_flags = vma->vma_flags & PROT_READ ? PF_R : 0;\n\n        if (vma->vma_flags & PROT_WRITE)\n\n            phdr.p_flags |= PF_W;\n\n        if (vma->vma_flags & PROT_EXEC)\n\n            phdr.p_flags |= PF_X;\n\n        phdr.p_align = ELF_EXEC_PAGESIZE;\n\n\n\n        bswap_phdr(&phdr, 1);\n\n        dump_write(fd, &phdr, sizeof (phdr));\n\n    }\n\n\n\n    /*\n\n     * Next we write notes just after program headers.  No\n\n     * alignment needed here.\n\n     */\n\n    if (write_note_info(&info, fd) < 0)\n\n        goto out;\n\n\n\n    /* align data to page boundary */\n\n    if (lseek(fd, data_offset, SEEK_SET) != data_offset)\n\n        goto out;\n\n\n\n    /*\n\n     * Finally we can dump process memory into corefile as well.\n\n     */\n\n    for (vma = vma_first(mm); vma != NULL; vma = vma_next(vma)) {\n\n        abi_ulong addr;\n\n        abi_ulong end;\n\n\n\n        end = vma->vma_start + vma_dump_size(vma);\n\n\n\n        for (addr = vma->vma_start; addr < end;\n\n             addr += TARGET_PAGE_SIZE) {\n\n            char page[TARGET_PAGE_SIZE];\n\n            int error;\n\n\n\n            /*\n\n             *  Read in page from target process memory and\n\n             *  write it to coredump file.\n\n             */\n\n            error = copy_from_user(page, addr, sizeof (page));\n\n            if (error != 0) {\n\n                (void) fprintf(stderr, \"unable to dump \" TARGET_ABI_FMT_lx \"\\n\",\n\n                               addr);\n\n                errno = -error;\n\n                goto out;\n\n            }\n\n            if (dump_write(fd, page, TARGET_PAGE_SIZE) < 0)\n\n                goto out;\n\n        }\n\n    }\n\n\n\n out:\n\n    free_note_info(&info);\n\n    if (mm != NULL)\n\n        vma_delete(mm);\n\n    (void) close(fd);\n\n\n\n    if (errno != 0)\n\n        return (-errno);\n\n    return (0);\n\n}\n", "idx": 21813}
{"project": "qemu", "commit_id": "0ce6a434176e274a7e86bcaa268542c5cc402696", "target": 1, "func": "void qemu_acl_reset(qemu_acl *acl)\n\n{\n\n    qemu_acl_entry *entry;\n\n\n\n    /* Put back to deny by default, so there is no window\n\n     * of \"open access\" while the user re-initializes the\n\n     * access control list */\n\n    acl->defaultDeny = 1;\n\n    QTAILQ_FOREACH(entry, &acl->entries, next) {\n\n        QTAILQ_REMOVE(&acl->entries, entry, next);\n\n        free(entry->match);\n\n        free(entry);\n\n    }\n\n    acl->nentries = 0;\n\n}\n", "idx": 21814}
{"project": "qemu", "commit_id": "9366f4186025e1d8fc3bebd41fb714521c170b6f", "target": 1, "func": "static int qemu_loadvm_state(QEMUFile *f)\n\n{\n\n    SaveStateEntry *se;\n\n    int len, ret, instance_id, record_len, version_id;\n\n    int64_t total_len, end_pos, cur_pos;\n\n    unsigned int v;\n\n    char idstr[256];\n\n\n\n    v = qemu_get_be32(f);\n\n    if (v != QEMU_VM_FILE_MAGIC)\n\n        goto fail;\n\n    v = qemu_get_be32(f);\n\n    if (v != QEMU_VM_FILE_VERSION) {\n\n    fail:\n\n        ret = -1;\n\n        goto the_end;\n\n    }\n\n    total_len = qemu_get_be64(f);\n\n    end_pos = total_len + qemu_ftell(f);\n\n    for(;;) {\n\n        if (qemu_ftell(f) >= end_pos)\n\n            break;\n\n        len = qemu_get_byte(f);\n\n        qemu_get_buffer(f, (uint8_t *)idstr, len);\n\n        idstr[len] = '\\0';\n\n        instance_id = qemu_get_be32(f);\n\n        version_id = qemu_get_be32(f);\n\n        record_len = qemu_get_be32(f);\n\n#if 0\n\n        printf(\"idstr=%s instance=0x%x version=%d len=%d\\n\",\n\n               idstr, instance_id, version_id, record_len);\n\n#endif\n\n        cur_pos = qemu_ftell(f);\n\n        se = find_se(idstr, instance_id);\n\n        if (!se) {\n\n            fprintf(stderr, \"qemu: warning: instance 0x%x of device '%s' not present in current VM\\n\",\n\n                    instance_id, idstr);\n\n        } else {\n\n            ret = se->load_state(f, se->opaque, version_id);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"qemu: warning: error while loading state for instance 0x%x of device '%s'\\n\",\n\n                        instance_id, idstr);\n\n            }\n\n        }\n\n        /* always seek to exact end of record */\n\n        qemu_fseek(f, cur_pos + record_len, SEEK_SET);\n\n    }\n\n    ret = 0;\n\n the_end:\n\n    return ret;\n\n}\n", "idx": 21817}
{"project": "qemu", "commit_id": "79482e5ab38a05ca8869040b0d8b8f451f16ff62", "target": 1, "func": "static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv arg1,\n\n                                    TCGv arg2, bool add_ca, bool compute_ca,\n\n                                    bool compute_ov, bool compute_rc0)\n\n{\n\n    TCGv t0 = ret;\n\n\n\n    if (((compute_ca && add_ca) || compute_ov)\n\n        && (TCGV_EQUAL(ret, arg1) || TCGV_EQUAL(ret, arg2)))  {\n\n        t0 = tcg_temp_new();\n\n    }\n\n\n\n    if (compute_ca) {\n\n        TCGv zero = tcg_const_tl(0);\n\n        if (add_ca) {\n\n            tcg_gen_add2_tl(t0, cpu_ca, arg1, zero, cpu_ca, zero);\n\n            tcg_gen_add2_tl(t0, cpu_ca, t0, cpu_ca, arg2, zero);\n\n        } else {\n\n            tcg_gen_add2_tl(t0, cpu_ca, arg1, zero, arg2, zero);\n\n        }\n\n        tcg_temp_free(zero);\n\n    } else {\n\n        tcg_gen_add_tl(t0, arg1, arg2);\n\n        if (add_ca) {\n\n            tcg_gen_add_tl(t0, t0, cpu_ca);\n\n        }\n\n    }\n\n\n\n    if (compute_ov) {\n\n        gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 0);\n\n    }\n\n    if (unlikely(compute_rc0)) {\n\n        gen_set_Rc0(ctx, t0);\n\n    }\n\n\n\n    if (!TCGV_EQUAL(t0, ret)) {\n\n        tcg_gen_mov_tl(ret, t0);\n\n        tcg_temp_free(t0);\n\n    }\n\n}\n", "idx": 21819}
{"project": "qemu", "commit_id": "43e86c8f5b6d9f6279e20dede4e1f7829bdc43b7", "target": 1, "func": "static void pcie_mmcfg_data_write(PCIBus *s,\n\n                                  uint32_t mmcfg_addr, uint32_t val, int len)\n\n{\n\n    PCIDevice *pci_dev = pcie_dev_find_by_mmcfg_addr(s, mmcfg_addr);\n\n\n\n    if (!pci_dev) {\n\n        return;\n\n    }\n\n    pci_host_config_write_common(pci_dev, PCIE_MMCFG_CONFOFFSET(mmcfg_addr),\n\n                                 pci_config_size(pci_dev), val, len);\n\n}\n", "idx": 21820}
{"project": "qemu", "commit_id": "be48e9951214a78ebef025cefecfc77be3d1c13c", "target": 1, "func": "static void qxl_check_state(PCIQXLDevice *d)\n\n{\n\n    QXLRam *ram = d->ram;\n\n\n\n    assert(SPICE_RING_IS_EMPTY(&ram->cmd_ring));\n\n    assert(SPICE_RING_IS_EMPTY(&ram->cursor_ring));\n\n}\n", "idx": 21821}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static target_long monitor_get_tbl (const struct MonitorDef *md, int val)\n\n{\n\n    CPUState *env = mon_get_cpu();\n\n    if (!env)\n\n        return 0;\n\n    return cpu_ppc_load_tbl(env);\n\n}\n", "idx": 21823}
{"project": "qemu", "commit_id": "c24a8a0b6dad5a33d84f5fb846edb28c43312c71", "target": 1, "func": "static inline uint64_t inline_cvttq(CPUAlphaState *env, uint64_t a,\n\n                                    int roundmode, int VI)\n\n{\n\n    uint64_t frac, ret = 0;\n\n    uint32_t exp, sign, exc = 0;\n\n    int shift;\n\n\n\n    sign = (a >> 63);\n\n    exp = (uint32_t)(a >> 52) & 0x7ff;\n\n    frac = a & 0xfffffffffffffull;\n\n\n\n    if (exp == 0) {\n\n        if (unlikely(frac != 0)) {\n\n            goto do_underflow;\n\n        }\n\n    } else if (exp == 0x7ff) {\n\n        exc = (frac ? FPCR_INV : VI ? FPCR_OVF : 0);\n\n    } else {\n\n        /* Restore implicit bit.  */\n\n        frac |= 0x10000000000000ull;\n\n\n\n        shift = exp - 1023 - 52;\n\n        if (shift >= 0) {\n\n            /* In this case the number is so large that we must shift\n\n               the fraction left.  There is no rounding to do.  */\n\n            if (shift < 63) {\n\n                ret = frac << shift;\n\n                if (VI && (ret >> shift) != frac) {\n\n                    exc = FPCR_OVF;\n\n                }\n\n            }\n\n        } else {\n\n            uint64_t round;\n\n\n\n            /* In this case the number is smaller than the fraction as\n\n               represented by the 52 bit number.  Here we must think\n\n               about rounding the result.  Handle this by shifting the\n\n               fractional part of the number into the high bits of ROUND.\n\n               This will let us efficiently handle round-to-nearest.  */\n\n            shift = -shift;\n\n            if (shift < 63) {\n\n                ret = frac >> shift;\n\n                round = frac << (64 - shift);\n\n            } else {\n\n                /* The exponent is so small we shift out everything.\n\n                   Leave a sticky bit for proper rounding below.  */\n\n            do_underflow:\n\n                round = 1;\n\n            }\n\n\n\n            if (round) {\n\n                exc = (VI ? FPCR_INE : 0);\n\n                switch (roundmode) {\n\n                case float_round_nearest_even:\n\n                    if (round == (1ull << 63)) {\n\n                        /* Fraction is exactly 0.5; round to even.  */\n\n                        ret += (ret & 1);\n\n                    } else if (round > (1ull << 63)) {\n\n                        ret += 1;\n\n                    }\n\n                    break;\n\n                case float_round_to_zero:\n\n                    break;\n\n                case float_round_up:\n\n                    ret += 1 - sign;\n\n                    break;\n\n                case float_round_down:\n\n                    ret += sign;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (sign) {\n\n            ret = -ret;\n\n        }\n\n    }\n\n    env->error_code = exc;\n\n\n\n    return ret;\n\n}\n", "idx": 21824}
{"project": "qemu", "commit_id": "0920a17199d23b3def3a60fa1fbbdeadcdda452d", "target": 1, "func": "static Visitor *visitor_input_test_init_raw(TestInputVisitorData *data,\n\n                                            const char *json_string)\n\n{\n\n    Visitor *v;\n\n\n\n    data->obj = qobject_from_json(json_string);\n\n\n\n    g_assert(data->obj != NULL);\n\n\n\n    data->qiv = qmp_input_visitor_new(data->obj);\n\n    g_assert(data->qiv != NULL);\n\n\n\n    v = qmp_input_get_visitor(data->qiv);\n\n    g_assert(v != NULL);\n\n\n\n    return v;\n\n}\n", "idx": 21829}
{"project": "qemu", "commit_id": "8af00205445eb901f17ca5b632d976065187538e", "target": 1, "func": "ssize_t v9fs_get_xattr(FsContext *ctx, const char *path,\n\n                       const char *name, void *value, size_t size)\n\n{\n\n    XattrOperations *xops = get_xattr_operations(ctx->xops, name);\n\n    if (xops) {\n\n        return xops->getxattr(ctx, path, name, value, size);\n\n    }\n\n    errno = -EOPNOTSUPP;\n\n    return -1;\n\n}\n", "idx": 21830}
{"project": "qemu", "commit_id": "e907746266721f305d67bc0718795fedee2e824c", "target": 1, "func": "static void fdctrl_write_data(FDCtrl *fdctrl, uint32_t value)\n\n{\n\n    FDrive *cur_drv;\n\n    int pos;\n\n\n\n    /* Reset mode */\n\n    if (!(fdctrl->dor & FD_DOR_nRESET)) {\n\n        FLOPPY_DPRINTF(\"Floppy controller in RESET state !\\n\");\n\n        return;\n\n    }\n\n    if (!(fdctrl->msr & FD_MSR_RQM) || (fdctrl->msr & FD_MSR_DIO)) {\n\n        FLOPPY_DPRINTF(\"error: controller not ready for writing\\n\");\n\n        return;\n\n    }\n\n    fdctrl->dsr &= ~FD_DSR_PWRDOWN;\n\n    /* Is it write command time ? */\n\n    if (fdctrl->msr & FD_MSR_NONDMA) {\n\n        /* FIFO data write */\n\n        pos = fdctrl->data_pos++;\n\n        pos %= FD_SECTOR_LEN;\n\n        fdctrl->fifo[pos] = value;\n\n        if (pos == FD_SECTOR_LEN - 1 ||\n\n            fdctrl->data_pos == fdctrl->data_len) {\n\n            cur_drv = get_cur_drv(fdctrl);\n\n            if (blk_write(cur_drv->blk, fd_sector(cur_drv), fdctrl->fifo, 1)\n\n                < 0) {\n\n                FLOPPY_DPRINTF(\"error writing sector %d\\n\",\n\n                               fd_sector(cur_drv));\n\n                return;\n\n            }\n\n            if (!fdctrl_seek_to_next_sect(fdctrl, cur_drv)) {\n\n                FLOPPY_DPRINTF(\"error seeking to next sector %d\\n\",\n\n                               fd_sector(cur_drv));\n\n                return;\n\n            }\n\n        }\n\n        /* Switch from transfer mode to status mode\n\n         * then from status mode to command mode\n\n         */\n\n        if (fdctrl->data_pos == fdctrl->data_len)\n\n            fdctrl_stop_transfer(fdctrl, 0x00, 0x00, 0x00);\n\n        return;\n\n    }\n\n    if (fdctrl->data_pos == 0) {\n\n        /* Command */\n\n        pos = command_to_handler[value & 0xff];\n\n        FLOPPY_DPRINTF(\"%s command\\n\", handlers[pos].name);\n\n        fdctrl->data_len = handlers[pos].parameters + 1;\n\n        fdctrl->msr |= FD_MSR_CMDBUSY;\n\n    }\n\n\n\n    FLOPPY_DPRINTF(\"%s: %02x\\n\", __func__, value);\n\n    fdctrl->fifo[fdctrl->data_pos++] = value;\n\n    if (fdctrl->data_pos == fdctrl->data_len) {\n\n        /* We now have all parameters\n\n         * and will be able to treat the command\n\n         */\n\n        if (fdctrl->data_state & FD_STATE_FORMAT) {\n\n            fdctrl_format_sector(fdctrl);\n\n            return;\n\n        }\n\n\n\n        pos = command_to_handler[fdctrl->fifo[0] & 0xff];\n\n        FLOPPY_DPRINTF(\"treat %s command\\n\", handlers[pos].name);\n\n        (*handlers[pos].handler)(fdctrl, handlers[pos].direction);\n\n    }\n\n}\n", "idx": 21831}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static uint8_t *scsi_get_buf(SCSIDevice *d, uint32_t tag)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n\n    SCSIDiskReq *r;\n\n\n\n    r = scsi_find_request(s, tag);\n\n    if (!r) {\n\n        BADF(\"Bad buffer tag 0x%x\\n\", tag);\n\n        return NULL;\n\n    }\n\n    return (uint8_t *)r->iov.iov_base;\n\n}\n", "idx": 21832}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void qdev_print_devinfos(bool show_no_user)\n\n{\n\n    static const char *cat_name[DEVICE_CATEGORY_MAX + 1] = {\n\n        [DEVICE_CATEGORY_BRIDGE]  = \"Controller/Bridge/Hub\",\n\n        [DEVICE_CATEGORY_USB]     = \"USB\",\n\n        [DEVICE_CATEGORY_STORAGE] = \"Storage\",\n\n        [DEVICE_CATEGORY_NETWORK] = \"Network\",\n\n        [DEVICE_CATEGORY_INPUT]   = \"Input\",\n\n        [DEVICE_CATEGORY_DISPLAY] = \"Display\",\n\n        [DEVICE_CATEGORY_SOUND]   = \"Sound\",\n\n        [DEVICE_CATEGORY_MISC]    = \"Misc\",\n\n        [DEVICE_CATEGORY_MAX]     = \"Uncategorized\",\n\n    };\n\n    GSList *list, *elt;\n\n    int i;\n\n    bool cat_printed;\n\n\n\n    list = g_slist_sort(object_class_get_list(TYPE_DEVICE, false),\n\n                        devinfo_cmp);\n\n\n\n    for (i = 0; i <= DEVICE_CATEGORY_MAX; i++) {\n\n        cat_printed = false;\n\n        for (elt = list; elt; elt = elt->next) {\n\n            DeviceClass *dc = OBJECT_CLASS_CHECK(DeviceClass, elt->data,\n\n                                                 TYPE_DEVICE);\n\n            if ((i < DEVICE_CATEGORY_MAX\n\n                 ? !test_bit(i, dc->categories)\n\n                 : !bitmap_empty(dc->categories, DEVICE_CATEGORY_MAX))\n\n                || (!show_no_user && dc->no_user)) {\n\n                continue;\n\n            }\n\n            if (!cat_printed) {\n\n                error_printf(\"%s%s devices:\\n\", i ? \"\\n\" : \"\",\n\n                             cat_name[i]);\n\n                cat_printed = true;\n\n            }\n\n            qdev_print_devinfo(dc);\n\n        }\n\n    }\n\n\n\n    g_slist_free(list);\n\n}\n", "idx": 21834}
{"project": "qemu", "commit_id": "f8f48b6957bf182339495e6be429f7bdc7ef1981", "target": 1, "func": "static void uhci_ioport_writew(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    UHCIState *s = opaque;\n\n\n\n    addr &= 0x1f;\n\n    trace_usb_uhci_mmio_writew(addr, val);\n\n\n\n    switch(addr) {\n\n    case 0x00:\n\n        if ((val & UHCI_CMD_RS) && !(s->cmd & UHCI_CMD_RS)) {\n\n            /* start frame processing */\n\n            trace_usb_uhci_schedule_start();\n\n            s->expire_time = qemu_get_clock_ns(vm_clock) +\n\n                (get_ticks_per_sec() / FRAME_TIMER_FREQ);\n\n            qemu_mod_timer(s->frame_timer, qemu_get_clock_ns(vm_clock));\n\n            s->status &= ~UHCI_STS_HCHALTED;\n\n        } else if (!(val & UHCI_CMD_RS)) {\n\n            s->status |= UHCI_STS_HCHALTED;\n\n        }\n\n        if (val & UHCI_CMD_GRESET) {\n\n            UHCIPort *port;\n\n            int i;\n\n\n\n            /* send reset on the USB bus */\n\n            for(i = 0; i < NB_PORTS; i++) {\n\n                port = &s->ports[i];\n\n                usb_device_reset(port->port.dev);\n\n            }\n\n            uhci_reset(s);\n\n            return;\n\n        }\n\n        if (val & UHCI_CMD_HCRESET) {\n\n            uhci_reset(s);\n\n            return;\n\n        }\n\n        s->cmd = val;\n\n        break;\n\n    case 0x02:\n\n        s->status &= ~val;\n\n        /* XXX: the chip spec is not coherent, so we add a hidden\n\n           register to distinguish between IOC and SPD */\n\n        if (val & UHCI_STS_USBINT)\n\n            s->status2 = 0;\n\n        uhci_update_irq(s);\n\n        break;\n\n    case 0x04:\n\n        s->intr = val;\n\n        uhci_update_irq(s);\n\n        break;\n\n    case 0x06:\n\n        if (s->status & UHCI_STS_HCHALTED)\n\n            s->frnum = val & 0x7ff;\n\n        break;\n\n    case 0x10 ... 0x1f:\n\n        {\n\n            UHCIPort *port;\n\n            USBDevice *dev;\n\n            int n;\n\n\n\n            n = (addr >> 1) & 7;\n\n            if (n >= NB_PORTS)\n\n                return;\n\n            port = &s->ports[n];\n\n            dev = port->port.dev;\n\n            if (dev && dev->attached) {\n\n                /* port reset */\n\n                if ( (val & UHCI_PORT_RESET) &&\n\n                     !(port->ctrl & UHCI_PORT_RESET) ) {\n\n                    usb_device_reset(dev);\n\n                }\n\n            }\n\n            port->ctrl &= UHCI_PORT_READ_ONLY;\n\n            /* enabled may only be set if a device is connected */\n\n            if (!(port->ctrl & UHCI_PORT_CCS)) {\n\n                val &= ~UHCI_PORT_EN;\n\n            }\n\n            port->ctrl |= (val & ~UHCI_PORT_READ_ONLY);\n\n            /* some bits are reset when a '1' is written to them */\n\n            port->ctrl &= ~(val & UHCI_PORT_WRITE_CLEAR);\n\n        }\n\n        break;\n\n    }\n\n}\n", "idx": 21835}
{"project": "qemu", "commit_id": "147dfab747dd1720cb6350b6b746ca84e15f9a24", "target": 1, "func": "void aio_context_setup(AioContext *ctx, Error **errp)\n\n{\n\n#ifdef CONFIG_EPOLL\n\n    assert(!ctx->epollfd);\n\n    ctx->epollfd = epoll_create1(EPOLL_CLOEXEC);\n\n    if (ctx->epollfd == -1) {\n\n        ctx->epoll_available = false;\n\n    } else {\n\n        ctx->epoll_available = true;\n\n    }\n\n#endif\n\n}\n", "idx": 21836}
{"project": "qemu", "commit_id": "bdd81addf4033ce26e6cd180b060f63095f3ded9", "target": 1, "func": "static void vfio_probe_rtl8168_bar2_quirk(VFIOPCIDevice *vdev, int nr)\n\n{\n\n    VFIOQuirk *quirk;\n\n    VFIOrtl8168Quirk *rtl;\n\n\n\n    if (!vfio_pci_is(vdev, PCI_VENDOR_ID_REALTEK, 0x8168) || nr != 2) {\n\n        return;\n\n    }\n\n\n\n    quirk = g_malloc0(sizeof(*quirk));\n\n    quirk->mem = g_malloc0(sizeof(MemoryRegion) * 2);\n\n    quirk->nr_mem = 2;\n\n    quirk->data = rtl = g_malloc0(sizeof(*rtl));\n\n    rtl->vdev = vdev;\n\n\n\n    memory_region_init_io(&quirk->mem[0], OBJECT(vdev),\n\n                          &vfio_rtl_address_quirk, rtl,\n\n                          \"vfio-rtl8168-window-address-quirk\", 4);\n\n    memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,\n\n                                        0x74, &quirk->mem[0], 1);\n\n\n\n    memory_region_init_io(&quirk->mem[1], OBJECT(vdev),\n\n                          &vfio_rtl_data_quirk, rtl,\n\n                          \"vfio-rtl8168-window-data-quirk\", 4);\n\n    memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,\n\n                                        0x70, &quirk->mem[1], 1);\n\n\n\n    QLIST_INSERT_HEAD(&vdev->bars[nr].quirks, quirk, next);\n\n\n\n    trace_vfio_quirk_rtl8168_probe(vdev->vbasedev.name);\n\n}\n", "idx": 21846}
{"project": "qemu", "commit_id": "d26e445c80fddcc7483b83f3115e5067fef28fe6", "target": 1, "func": "int tap_open(char *ifname, int ifname_size, int *vnet_hdr,\n\n             int vnet_hdr_required, int mq_required)\n\n{\n\n    struct ifreq ifr;\n\n    int fd, ret;\n\n    int len = sizeof(struct virtio_net_hdr);\n\n\n\n    TFR(fd = open(PATH_NET_TUN, O_RDWR));\n\n    if (fd < 0) {\n\n        error_report(\"could not open %s: %m\", PATH_NET_TUN);\n\n        return -1;\n\n    }\n\n    memset(&ifr, 0, sizeof(ifr));\n\n    ifr.ifr_flags = IFF_TAP | IFF_NO_PI;\n\n\n\n    if (*vnet_hdr) {\n\n        unsigned int features;\n\n\n\n        if (ioctl(fd, TUNGETFEATURES, &features) == 0 &&\n\n            features & IFF_VNET_HDR) {\n\n            *vnet_hdr = 1;\n\n            ifr.ifr_flags |= IFF_VNET_HDR;\n\n        } else {\n\n            *vnet_hdr = 0;\n\n        }\n\n\n\n        if (vnet_hdr_required && !*vnet_hdr) {\n\n            error_report(\"vnet_hdr=1 requested, but no kernel \"\n\n                         \"support for IFF_VNET_HDR available\");\n\n            close(fd);\n\n            return -1;\n\n        }\n\n        /*\n\n         * Make sure vnet header size has the default value: for a persistent\n\n         * tap it might have been modified e.g. by another instance of qemu.\n\n         * Ignore errors since old kernels do not support this ioctl: in this\n\n         * case the header size implicitly has the correct value.\n\n         */\n\n        ioctl(fd, TUNSETVNETHDRSZ, &len);\n\n    }\n\n\n\n    if (mq_required) {\n\n        unsigned int features;\n\n\n\n        if ((ioctl(fd, TUNGETFEATURES, &features) != 0) ||\n\n            !(features & IFF_MULTI_QUEUE)) {\n\n            error_report(\"multiqueue required, but no kernel \"\n\n                         \"support for IFF_MULTI_QUEUE available\");\n\n            close(fd);\n\n            return -1;\n\n        } else {\n\n            ifr.ifr_flags |= IFF_MULTI_QUEUE;\n\n        }\n\n    }\n\n\n\n    if (ifname[0] != '\\0')\n\n        pstrcpy(ifr.ifr_name, IFNAMSIZ, ifname);\n\n    else\n\n        pstrcpy(ifr.ifr_name, IFNAMSIZ, \"tap%d\");\n\n    ret = ioctl(fd, TUNSETIFF, (void *) &ifr);\n\n    if (ret != 0) {\n\n        if (ifname[0] != '\\0') {\n\n            error_report(\"could not configure %s (%s): %m\", PATH_NET_TUN, ifr.ifr_name);\n\n        } else {\n\n            error_report(\"could not configure %s: %m\", PATH_NET_TUN);\n\n        }\n\n        close(fd);\n\n        return -1;\n\n    }\n\n    pstrcpy(ifname, ifname_size, ifr.ifr_name);\n\n    fcntl(fd, F_SETFL, O_NONBLOCK);\n\n    return fd;\n\n}\n", "idx": 21848}
{"project": "qemu", "commit_id": "55b4e80b047300e1512df02887b7448ba3786b62", "target": 0, "func": "static void phys_section_destroy(MemoryRegion *mr)\n\n{\n\n    memory_region_unref(mr);\n\n\n\n    if (mr->subpage) {\n\n        subpage_t *subpage = container_of(mr, subpage_t, iomem);\n\n        object_unref(OBJECT(&subpage->iomem));\n\n        g_free(subpage);\n\n    }\n\n}\n", "idx": 21853}
{"project": "qemu", "commit_id": "c169998802505c244b8bcad562633f29de7d74a4", "target": 0, "func": "static void usb_ohci_init(OHCIState *ohci, DeviceState *dev,\n\n                          int num_ports, int devfn,\n\n                          qemu_irq irq, enum ohci_type type,\n\n                          const char *name, uint32_t localmem_base)\n\n{\n\n    int i;\n\n\n\n    if (usb_frame_time == 0) {\n\n#ifdef OHCI_TIME_WARP\n\n        usb_frame_time = get_ticks_per_sec();\n\n        usb_bit_time = muldiv64(1, get_ticks_per_sec(), USB_HZ/1000);\n\n#else\n\n        usb_frame_time = muldiv64(1, get_ticks_per_sec(), 1000);\n\n        if (get_ticks_per_sec() >= USB_HZ) {\n\n            usb_bit_time = muldiv64(1, get_ticks_per_sec(), USB_HZ);\n\n        } else {\n\n            usb_bit_time = 1;\n\n        }\n\n#endif\n\n        dprintf(\"usb-ohci: usb_bit_time=%\" PRId64 \" usb_frame_time=%\" PRId64 \"\\n\",\n\n                usb_frame_time, usb_bit_time);\n\n    }\n\n\n\n    ohci->mem = cpu_register_io_memory(ohci_readfn, ohci_writefn, ohci);\n\n    ohci->localmem_base = localmem_base;\n\n    ohci->name = name;\n\n\n\n    ohci->irq = irq;\n\n    ohci->type = type;\n\n\n\n    usb_bus_new(&ohci->bus, dev);\n\n    ohci->num_ports = num_ports;\n\n    for (i = 0; i < num_ports; i++) {\n\n        usb_register_port(&ohci->bus, &ohci->rhport[i].port, ohci, i, ohci_attach);\n\n    }\n\n\n\n    ohci->async_td = 0;\n\n    qemu_register_reset(ohci_reset, ohci);\n\n    ohci_reset(ohci);\n\n}\n", "idx": 21854}
{"project": "qemu", "commit_id": "e33e94f92298c96e0928cefab00ea5bae0a1cd19", "target": 0, "func": "void helper_float_check_status (void)\n\n{\n\n#ifdef CONFIG_SOFTFLOAT\n\n    if (env->exception_index == POWERPC_EXCP_PROGRAM &&\n\n        (env->error_code & POWERPC_EXCP_FP)) {\n\n        /* Differred floating-point exception after target FPR update */\n\n        if (msr_fe0 != 0 || msr_fe1 != 0)\n\n            helper_raise_exception_err(env->exception_index, env->error_code);\n\n    } else {\n\n        int status = get_float_exception_flags(&env->fp_status);\n\n        if (status & float_flag_overflow) {\n\n            float_overflow_excp();\n\n        } else if (status & float_flag_underflow) {\n\n            float_underflow_excp();\n\n        } else if (status & float_flag_inexact) {\n\n            float_inexact_excp();\n\n        }\n\n    }\n\n#else\n\n    if (env->exception_index == POWERPC_EXCP_PROGRAM &&\n\n        (env->error_code & POWERPC_EXCP_FP)) {\n\n        /* Differred floating-point exception after target FPR update */\n\n        if (msr_fe0 != 0 || msr_fe1 != 0)\n\n            helper_raise_exception_err(env->exception_index, env->error_code);\n\n    }\n\n#endif\n\n}\n", "idx": 21855}
{"project": "qemu", "commit_id": "4f441474c61f317de7927edfdb1d042b0b6f3882", "target": 0, "func": "static void spapr_dt_rtas(sPAPRMachineState *spapr, void *fdt)\n\n{\n\n    int rtas;\n\n    GString *hypertas = g_string_sized_new(256);\n\n    GString *qemu_hypertas = g_string_sized_new(256);\n\n    uint32_t refpoints[] = { cpu_to_be32(0x4), cpu_to_be32(0x4) };\n\n    uint64_t max_hotplug_addr = spapr->hotplug_memory.base +\n\n        memory_region_size(&spapr->hotplug_memory.mr);\n\n    uint32_t lrdr_capacity[] = {\n\n        cpu_to_be32(max_hotplug_addr >> 32),\n\n        cpu_to_be32(max_hotplug_addr & 0xffffffff),\n\n        0, cpu_to_be32(SPAPR_MEMORY_BLOCK_SIZE),\n\n        cpu_to_be32(max_cpus / smp_threads),\n\n    };\n\n\n\n    _FDT(rtas = fdt_add_subnode(fdt, 0, \"rtas\"));\n\n\n\n    /* hypertas */\n\n    add_str(hypertas, \"hcall-pft\");\n\n    add_str(hypertas, \"hcall-term\");\n\n    add_str(hypertas, \"hcall-dabr\");\n\n    add_str(hypertas, \"hcall-interrupt\");\n\n    add_str(hypertas, \"hcall-tce\");\n\n    add_str(hypertas, \"hcall-vio\");\n\n    add_str(hypertas, \"hcall-splpar\");\n\n    add_str(hypertas, \"hcall-bulk\");\n\n    add_str(hypertas, \"hcall-set-mode\");\n\n    add_str(hypertas, \"hcall-sprg0\");\n\n    add_str(hypertas, \"hcall-copy\");\n\n    add_str(hypertas, \"hcall-debug\");\n\n    add_str(qemu_hypertas, \"hcall-memop1\");\n\n\n\n    if (!kvm_enabled() || kvmppc_spapr_use_multitce()) {\n\n        add_str(hypertas, \"hcall-multi-tce\");\n\n    }\n\n\n\n    if (spapr->resize_hpt != SPAPR_RESIZE_HPT_DISABLED) {\n\n        add_str(hypertas, \"hcall-hpt-resize\");\n\n    }\n\n\n\n    _FDT(fdt_setprop(fdt, rtas, \"ibm,hypertas-functions\",\n\n                     hypertas->str, hypertas->len));\n\n    g_string_free(hypertas, TRUE);\n\n    _FDT(fdt_setprop(fdt, rtas, \"qemu,hypertas-functions\",\n\n                     qemu_hypertas->str, qemu_hypertas->len));\n\n    g_string_free(qemu_hypertas, TRUE);\n\n\n\n    _FDT(fdt_setprop(fdt, rtas, \"ibm,associativity-reference-points\",\n\n                     refpoints, sizeof(refpoints)));\n\n\n\n    _FDT(fdt_setprop_cell(fdt, rtas, \"rtas-error-log-max\",\n\n                          RTAS_ERROR_LOG_MAX));\n\n    _FDT(fdt_setprop_cell(fdt, rtas, \"rtas-event-scan-rate\",\n\n                          RTAS_EVENT_SCAN_RATE));\n\n\n\n    if (msi_nonbroken) {\n\n        _FDT(fdt_setprop(fdt, rtas, \"ibm,change-msix-capable\", NULL, 0));\n\n    }\n\n\n\n    /*\n\n     * According to PAPR, rtas ibm,os-term does not guarantee a return\n\n     * back to the guest cpu.\n\n     *\n\n     * While an additional ibm,extended-os-term property indicates\n\n     * that rtas call return will always occur. Set this property.\n\n     */\n\n    _FDT(fdt_setprop(fdt, rtas, \"ibm,extended-os-term\", NULL, 0));\n\n\n\n    _FDT(fdt_setprop(fdt, rtas, \"ibm,lrdr-capacity\",\n\n                     lrdr_capacity, sizeof(lrdr_capacity)));\n\n\n\n    spapr_dt_rtas_tokens(fdt, rtas);\n\n}\n", "idx": 21856}
{"project": "qemu", "commit_id": "b626b51a6721e53817155af720243f59072e424f", "target": 0, "func": "static ssize_t nbd_co_receive_request(NBDRequest *req,\n\n                                      struct nbd_request *request)\n\n{\n\n    NBDClient *client = req->client;\n\n    uint32_t command;\n\n    ssize_t rc;\n\n\n\n    g_assert(qemu_in_coroutine());\n\n    client->recv_coroutine = qemu_coroutine_self();\n\n    nbd_update_can_read(client);\n\n\n\n    rc = nbd_receive_request(client->ioc, request);\n\n    if (rc < 0) {\n\n        if (rc != -EAGAIN) {\n\n            rc = -EIO;\n\n        }\n\n        goto out;\n\n    }\n\n\n\n    TRACE(\"Decoding type\");\n\n\n\n    command = request->type & NBD_CMD_MASK_COMMAND;\n\n    if (command != NBD_CMD_WRITE) {\n\n        /* No payload, we are ready to read the next request.  */\n\n        req->complete = true;\n\n    }\n\n\n\n    if (command == NBD_CMD_DISC) {\n\n        /* Special case: we're going to disconnect without a reply,\n\n         * whether or not flags, from, or len are bogus */\n\n        TRACE(\"Request type is DISCONNECT\");\n\n        rc = -EIO;\n\n        goto out;\n\n    }\n\n\n\n    /* Check for sanity in the parameters, part 1.  Defer as many\n\n     * checks as possible until after reading any NBD_CMD_WRITE\n\n     * payload, so we can try and keep the connection alive.  */\n\n    if ((request->from + request->len) < request->from) {\n\n        LOG(\"integer overflow detected, you're probably being attacked\");\n\n        rc = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    if (command == NBD_CMD_READ || command == NBD_CMD_WRITE) {\n\n        if (request->len > NBD_MAX_BUFFER_SIZE) {\n\n            LOG(\"len (%\" PRIu32\" ) is larger than max len (%u)\",\n\n                request->len, NBD_MAX_BUFFER_SIZE);\n\n            rc = -EINVAL;\n\n            goto out;\n\n        }\n\n\n\n        req->data = blk_try_blockalign(client->exp->blk, request->len);\n\n        if (req->data == NULL) {\n\n            rc = -ENOMEM;\n\n            goto out;\n\n        }\n\n    }\n\n    if (command == NBD_CMD_WRITE) {\n\n        TRACE(\"Reading %\" PRIu32 \" byte(s)\", request->len);\n\n\n\n        if (read_sync(client->ioc, req->data, request->len) != request->len) {\n\n            LOG(\"reading from socket failed\");\n\n            rc = -EIO;\n\n            goto out;\n\n        }\n\n        req->complete = true;\n\n    }\n\n\n\n    /* Sanity checks, part 2. */\n\n    if (request->from + request->len > client->exp->size) {\n\n        LOG(\"operation past EOF; From: %\" PRIu64 \", Len: %\" PRIu32\n\n            \", Size: %\" PRIu64, request->from, request->len,\n\n            (uint64_t)client->exp->size);\n\n        rc = command == NBD_CMD_WRITE ? -ENOSPC : -EINVAL;\n\n        goto out;\n\n    }\n\n    if (request->type & ~NBD_CMD_MASK_COMMAND & ~NBD_CMD_FLAG_FUA) {\n\n        LOG(\"unsupported flags (got 0x%x)\",\n\n            request->type & ~NBD_CMD_MASK_COMMAND);\n\n        rc = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    rc = 0;\n\n\n\nout:\n\n    client->recv_coroutine = NULL;\n\n    nbd_update_can_read(client);\n\n\n\n    return rc;\n\n}\n", "idx": 21857}
{"project": "qemu", "commit_id": "08a2d4c4ffde60e48819449f461274c43ad6e2d3", "target": 0, "func": "static void sdl_grab_start(void)\n\n{\n\n    if (guest_cursor) {\n\n        SDL_SetCursor(guest_sprite);\n\n        SDL_WarpMouse(guest_x, guest_y);\n\n    } else\n\n        sdl_hide_cursor();\n\n\n\n    if (SDL_WM_GrabInput(SDL_GRAB_ON) == SDL_GRAB_ON) {\n\n        gui_grab = 1;\n\n        sdl_update_caption();\n\n    } else\n\n        sdl_show_cursor();\n\n}\n", "idx": 21858}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static void qio_channel_socket_listen_worker(QIOTask *task,\n\n                                             gpointer opaque)\n\n{\n\n    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(qio_task_get_source(task));\n\n    SocketAddressLegacy *addr = opaque;\n\n    Error *err = NULL;\n\n\n\n    qio_channel_socket_listen_sync(ioc, addr, &err);\n\n\n\n    qio_task_set_error(task, err);\n\n}\n", "idx": 21859}
{"project": "qemu", "commit_id": "872dd82c83745a603d2e07a03d34313eb6467ae4", "target": 0, "func": "VirtQueue *virtio_add_queue(VirtIODevice *vdev, int queue_size,\n\n                            VirtIOHandleOutput handle_output)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < VIRTIO_QUEUE_MAX; i++) {\n\n        if (vdev->vq[i].vring.num == 0)\n\n            break;\n\n    }\n\n\n\n    if (i == VIRTIO_QUEUE_MAX || queue_size > VIRTQUEUE_MAX_SIZE)\n\n        abort();\n\n\n\n    vdev->vq[i].vring.num = queue_size;\n\n    vdev->vq[i].vring.num_default = queue_size;\n\n    vdev->vq[i].vring.align = VIRTIO_PCI_VRING_ALIGN;\n\n    vdev->vq[i].handle_output = handle_output;\n\n    vdev->vq[i].handle_aio_output = NULL;\n\n\n\n    return &vdev->vq[i];\n\n}\n", "idx": 21860}
{"project": "qemu", "commit_id": "0544edd88a6acea81aefe22fd0cd9a85d1eef093", "target": 0, "func": "static void smp_parse(QemuOpts *opts)\n\n{\n\n    if (opts) {\n\n\n\n        unsigned cpus    = qemu_opt_get_number(opts, \"cpus\", 0);\n\n        unsigned sockets = qemu_opt_get_number(opts, \"sockets\", 0);\n\n        unsigned cores   = qemu_opt_get_number(opts, \"cores\", 0);\n\n        unsigned threads = qemu_opt_get_number(opts, \"threads\", 0);\n\n\n\n        /* compute missing values, prefer sockets over cores over threads */\n\n        if (cpus == 0 || sockets == 0) {\n\n            sockets = sockets > 0 ? sockets : 1;\n\n            cores = cores > 0 ? cores : 1;\n\n            threads = threads > 0 ? threads : 1;\n\n            if (cpus == 0) {\n\n                cpus = cores * threads * sockets;\n\n            }\n\n        } else if (cores == 0) {\n\n            threads = threads > 0 ? threads : 1;\n\n            cores = cpus / (sockets * threads);\n\n        } else if (threads == 0) {\n\n            threads = cpus / (cores * sockets);\n\n        } else if (sockets * cores * threads < cpus) {\n\n            error_report(\"cpu topology: \"\n\n                         \"sockets (%u) * cores (%u) * threads (%u) < \"\n\n                         \"smp_cpus (%u)\",\n\n                         sockets, cores, threads, cpus);\n\n            exit(1);\n\n        }\n\n\n\n        max_cpus = qemu_opt_get_number(opts, \"maxcpus\", cpus);\n\n        if (sockets * cores * threads > max_cpus) {\n\n            error_report(\"cpu topology: \"\n\n                         \"sockets (%u) * cores (%u) * threads (%u) > \"\n\n                         \"maxcpus (%u)\",\n\n                         sockets, cores, threads, max_cpus);\n\n            exit(1);\n\n        }\n\n\n\n        smp_cpus = cpus;\n\n        smp_cores = cores > 0 ? cores : 1;\n\n        smp_threads = threads > 0 ? threads : 1;\n\n\n\n    }\n\n\n\n    if (max_cpus == 0) {\n\n        max_cpus = smp_cpus;\n\n    }\n\n\n\n    if (max_cpus > MAX_CPUMASK_BITS) {\n\n        error_report(\"unsupported number of maxcpus\");\n\n        exit(1);\n\n    }\n\n    if (max_cpus < smp_cpus) {\n\n        error_report(\"maxcpus must be equal to or greater than smp\");\n\n        exit(1);\n\n    }\n\n\n\n    if (smp_cpus > 1 || smp_cores > 1 || smp_threads > 1) {\n\n        Error *blocker = NULL;\n\n        error_setg(&blocker, QERR_REPLAY_NOT_SUPPORTED, \"smp\");\n\n        replay_add_blocker(blocker);\n\n    }\n\n}\n", "idx": 21861}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "static void kvm_set_phys_mem(target_phys_addr_t start_addr,\n\n\t\t\t     ram_addr_t size,\n\n\t\t\t     ram_addr_t phys_offset)\n\n{\n\n    KVMState *s = kvm_state;\n\n    ram_addr_t flags = phys_offset & ~TARGET_PAGE_MASK;\n\n    KVMSlot *mem, old;\n\n    int err;\n\n\n\n    /* kvm works in page size chunks, but the function may be called\n\n       with sub-page size and unaligned start address. */\n\n    size = TARGET_PAGE_ALIGN(size);\n\n    start_addr = TARGET_PAGE_ALIGN(start_addr);\n\n\n\n    /* KVM does not support read-only slots */\n\n    phys_offset &= ~IO_MEM_ROM;\n\n\n\n    while (1) {\n\n        mem = kvm_lookup_overlapping_slot(s, start_addr, start_addr + size);\n\n        if (!mem) {\n\n            break;\n\n        }\n\n\n\n        if (flags < IO_MEM_UNASSIGNED && start_addr >= mem->start_addr &&\n\n            (start_addr + size <= mem->start_addr + mem->memory_size) &&\n\n            (phys_offset - start_addr == mem->phys_offset - mem->start_addr)) {\n\n            /* The new slot fits into the existing one and comes with\n\n             * identical parameters - nothing to be done. */\n\n            return;\n\n        }\n\n\n\n        old = *mem;\n\n\n\n        /* unregister the overlapping slot */\n\n        mem->memory_size = 0;\n\n        err = kvm_set_user_memory_region(s, mem);\n\n        if (err) {\n\n            fprintf(stderr, \"%s: error unregistering overlapping slot: %s\\n\",\n\n                    __func__, strerror(-err));\n\n            abort();\n\n        }\n\n\n\n        /* Workaround for older KVM versions: we can't join slots, even not by\n\n         * unregistering the previous ones and then registering the larger\n\n         * slot. We have to maintain the existing fragmentation. Sigh.\n\n         *\n\n         * This workaround assumes that the new slot starts at the same\n\n         * address as the first existing one. If not or if some overlapping\n\n         * slot comes around later, we will fail (not seen in practice so far)\n\n         * - and actually require a recent KVM version. */\n\n        if (s->broken_set_mem_region &&\n\n            old.start_addr == start_addr && old.memory_size < size &&\n\n            flags < IO_MEM_UNASSIGNED) {\n\n            mem = kvm_alloc_slot(s);\n\n            mem->memory_size = old.memory_size;\n\n            mem->start_addr = old.start_addr;\n\n            mem->phys_offset = old.phys_offset;\n\n            mem->flags = 0;\n\n\n\n            err = kvm_set_user_memory_region(s, mem);\n\n            if (err) {\n\n                fprintf(stderr, \"%s: error updating slot: %s\\n\", __func__,\n\n                        strerror(-err));\n\n                abort();\n\n            }\n\n\n\n            start_addr += old.memory_size;\n\n            phys_offset += old.memory_size;\n\n            size -= old.memory_size;\n\n            continue;\n\n        }\n\n\n\n        /* register prefix slot */\n\n        if (old.start_addr < start_addr) {\n\n            mem = kvm_alloc_slot(s);\n\n            mem->memory_size = start_addr - old.start_addr;\n\n            mem->start_addr = old.start_addr;\n\n            mem->phys_offset = old.phys_offset;\n\n            mem->flags = 0;\n\n\n\n            err = kvm_set_user_memory_region(s, mem);\n\n            if (err) {\n\n                fprintf(stderr, \"%s: error registering prefix slot: %s\\n\",\n\n                        __func__, strerror(-err));\n\n                abort();\n\n            }\n\n        }\n\n\n\n        /* register suffix slot */\n\n        if (old.start_addr + old.memory_size > start_addr + size) {\n\n            ram_addr_t size_delta;\n\n\n\n            mem = kvm_alloc_slot(s);\n\n            mem->start_addr = start_addr + size;\n\n            size_delta = mem->start_addr - old.start_addr;\n\n            mem->memory_size = old.memory_size - size_delta;\n\n            mem->phys_offset = old.phys_offset + size_delta;\n\n            mem->flags = 0;\n\n\n\n            err = kvm_set_user_memory_region(s, mem);\n\n            if (err) {\n\n                fprintf(stderr, \"%s: error registering suffix slot: %s\\n\",\n\n                        __func__, strerror(-err));\n\n                abort();\n\n            }\n\n        }\n\n    }\n\n\n\n    /* in case the KVM bug workaround already \"consumed\" the new slot */\n\n    if (!size)\n\n        return;\n\n\n\n    /* KVM does not need to know about this memory */\n\n    if (flags >= IO_MEM_UNASSIGNED)\n\n        return;\n\n\n\n    mem = kvm_alloc_slot(s);\n\n    mem->memory_size = size;\n\n    mem->start_addr = start_addr;\n\n    mem->phys_offset = phys_offset;\n\n    mem->flags = 0;\n\n\n\n    err = kvm_set_user_memory_region(s, mem);\n\n    if (err) {\n\n        fprintf(stderr, \"%s: error registering slot: %s\\n\", __func__,\n\n                strerror(-err));\n\n        abort();\n\n    }\n\n}\n", "idx": 21863}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static void discard_vq_data(VirtQueue *vq, VirtIODevice *vdev)\n\n{\n\n    VirtQueueElement elem;\n\n\n\n    if (!virtio_queue_ready(vq)) {\n\n        return;\n\n    }\n\n    while (virtqueue_pop(vq, &elem)) {\n\n        virtqueue_push(vq, &elem, 0);\n\n    }\n\n    virtio_notify(vdev, vq);\n\n}\n", "idx": 21864}
{"project": "qemu", "commit_id": "90d131fb6504ed12a37dc8433375cc683c30e9da", "target": 0, "func": "static void rtl8139_io_writeb(void *opaque, uint8_t addr, uint32_t val)\n\n{\n\n    RTL8139State *s = opaque;\n\n\n\n    switch (addr)\n\n    {\n\n        case MAC0 ... MAC0+5:\n\n            s->phys[addr - MAC0] = val;\n\n            qemu_format_nic_info_str(qemu_get_queue(s->nic), s->phys);\n\n            break;\n\n        case MAC0+6 ... MAC0+7:\n\n            /* reserved */\n\n            break;\n\n        case MAR0 ... MAR0+7:\n\n            s->mult[addr - MAR0] = val;\n\n            break;\n\n        case ChipCmd:\n\n            rtl8139_ChipCmd_write(s, val);\n\n            break;\n\n        case Cfg9346:\n\n            rtl8139_Cfg9346_write(s, val);\n\n            break;\n\n        case TxConfig: /* windows driver sometimes writes using byte-lenth call */\n\n            rtl8139_TxConfig_writeb(s, val);\n\n            break;\n\n        case Config0:\n\n            rtl8139_Config0_write(s, val);\n\n            break;\n\n        case Config1:\n\n            rtl8139_Config1_write(s, val);\n\n            break;\n\n        case Config3:\n\n            rtl8139_Config3_write(s, val);\n\n            break;\n\n        case Config4:\n\n            rtl8139_Config4_write(s, val);\n\n            break;\n\n        case Config5:\n\n            rtl8139_Config5_write(s, val);\n\n            break;\n\n        case MediaStatus:\n\n            /* ignore */\n\n            DPRINTF(\"not implemented write(b) to MediaStatus val=0x%02x\\n\",\n\n                val);\n\n            break;\n\n\n\n        case HltClk:\n\n            DPRINTF(\"HltClk write val=0x%08x\\n\", val);\n\n            if (val == 'R')\n\n            {\n\n                s->clock_enabled = 1;\n\n            }\n\n            else if (val == 'H')\n\n            {\n\n                s->clock_enabled = 0;\n\n            }\n\n            break;\n\n\n\n        case TxThresh:\n\n            DPRINTF(\"C+ TxThresh write(b) val=0x%02x\\n\", val);\n\n            s->TxThresh = val;\n\n            break;\n\n\n\n        case TxPoll:\n\n            DPRINTF(\"C+ TxPoll write(b) val=0x%02x\\n\", val);\n\n            if (val & (1 << 7))\n\n            {\n\n                DPRINTF(\"C+ TxPoll high priority transmission (not \"\n\n                    \"implemented)\\n\");\n\n                //rtl8139_cplus_transmit(s);\n\n            }\n\n            if (val & (1 << 6))\n\n            {\n\n                DPRINTF(\"C+ TxPoll normal priority transmission\\n\");\n\n                rtl8139_cplus_transmit(s);\n\n            }\n\n\n\n            break;\n\n\n\n        default:\n\n            DPRINTF(\"not implemented write(b) addr=0x%x val=0x%02x\\n\", addr,\n\n                val);\n\n            break;\n\n    }\n\n}\n", "idx": 21865}
{"project": "qemu", "commit_id": "805017b7791200f1b72deef17dc98fd272b941eb", "target": 0, "func": "static void test_validate_fail_union(TestInputVisitorData *data,\n\n                                      const void *unused)\n\n{\n\n    UserDefUnion *tmp = NULL;\n\n    Error *err = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data, \"{ 'type': 'b', 'data' : { 'integer': 42 } }\");\n\n\n\n    visit_type_UserDefUnion(v, &tmp, NULL, &err);\n\n    g_assert(err);\n\n    qapi_free_UserDefUnion(tmp);\n\n}\n", "idx": 21866}
{"project": "qemu", "commit_id": "10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b", "target": 0, "func": "static void nabm_writew (void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    PCIAC97LinkState *d = opaque;\n\n    AC97LinkState *s = &d->ac97;\n\n    AC97BusMasterRegs *r = NULL;\n\n    uint32_t index = addr - s->base[1];\n\n    switch (index) {\n\n    case PI_SR:\n\n    case PO_SR:\n\n    case MC_SR:\n\n        r = &s->bm_regs[GET_BM (index)];\n\n        r->sr |= val & ~(SR_RO_MASK | SR_WCLEAR_MASK);\n\n        update_sr (s, r, r->sr & ~(val & SR_WCLEAR_MASK));\n\n        dolog (\"SR[%d] <- %#x (sr %#x)\\n\", GET_BM (index), val, r->sr);\n\n        break;\n\n    default:\n\n        dolog (\"U nabm writew %#x <- %#x\\n\", addr, val);\n\n        break;\n\n    }\n\n}\n", "idx": 21867}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void musicpal_misc_write(void *opaque, target_phys_addr_t offset,\n\n                                uint64_t value, unsigned size)\n\n{\n\n}\n", "idx": 21868}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "void HELPER(ucf64_cmpd)(float64 a, float64 b, uint32_t c, CPUUniCore32State *env)\n\n{\n\n    int flag;\n\n    flag = float64_compare_quiet(a, b, &env->ucf64.fp_status);\n\n    env->CF = 0;\n\n    switch (c & 0x7) {\n\n    case 0: /* F */\n\n        break;\n\n    case 1: /* UN */\n\n        if (flag == 2) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 2: /* EQ */\n\n        if (flag == 0) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 3: /* UEQ */\n\n        if ((flag == 0) || (flag == 2)) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 4: /* OLT */\n\n        if (flag == -1) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 5: /* ULT */\n\n        if ((flag == -1) || (flag == 2)) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 6: /* OLE */\n\n        if ((flag == -1) || (flag == 0)) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 7: /* ULE */\n\n        if (flag != 1) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    }\n\n    env->ucf64.xregs[UC32_UCF64_FPSCR] = (env->CF << 29)\n\n                    | (env->ucf64.xregs[UC32_UCF64_FPSCR] & 0x0fffffff);\n\n}\n", "idx": 21869}
{"project": "qemu", "commit_id": "134d42d614768b2803e551621f6654dab1fdc2d2", "target": 0, "func": "static void acpi_align_size(GArray *blob, unsigned align)\n\n{\n\n    /* Align size to multiple of given size. This reduces the chance\n\n     * we need to change size in the future (breaking cross version migration).\n\n     */\n\n    g_array_set_size(blob, (ROUND_UP(acpi_data_len(blob), align) +\n\n                            g_array_get_element_size(blob) - 1) /\n\n                             g_array_get_element_size(blob));\n\n}\n", "idx": 21870}
{"project": "qemu", "commit_id": "35efba2cc6812dc980c336d7b9bf81dbfb5daf00", "target": 0, "func": "static void usbredir_chardev_open(USBRedirDevice *dev)\n\n{\n\n    uint32_t caps[USB_REDIR_CAPS_SIZE] = { 0, };\n\n    char version[32];\n\n    int flags = 0;\n\n\n\n    /* Make sure any pending closes are handled (no-op if none pending) */\n\n    usbredir_chardev_close_bh(dev);\n\n    qemu_bh_cancel(dev->chardev_close_bh);\n\n\n\n    DPRINTF(\"creating usbredirparser\\n\");\n\n\n\n    strcpy(version, \"qemu usb-redir guest \");\n\n    pstrcat(version, sizeof(version), qemu_get_version());\n\n\n\n    dev->parser = qemu_oom_check(usbredirparser_create());\n\n    dev->parser->priv = dev;\n\n    dev->parser->log_func = usbredir_log;\n\n    dev->parser->read_func = usbredir_read;\n\n    dev->parser->write_func = usbredir_write;\n\n    dev->parser->hello_func = usbredir_hello;\n\n    dev->parser->device_connect_func = usbredir_device_connect;\n\n    dev->parser->device_disconnect_func = usbredir_device_disconnect;\n\n    dev->parser->interface_info_func = usbredir_interface_info;\n\n    dev->parser->ep_info_func = usbredir_ep_info;\n\n    dev->parser->configuration_status_func = usbredir_configuration_status;\n\n    dev->parser->alt_setting_status_func = usbredir_alt_setting_status;\n\n    dev->parser->iso_stream_status_func = usbredir_iso_stream_status;\n\n    dev->parser->interrupt_receiving_status_func =\n\n        usbredir_interrupt_receiving_status;\n\n    dev->parser->bulk_streams_status_func = usbredir_bulk_streams_status;\n\n    dev->parser->control_packet_func = usbredir_control_packet;\n\n    dev->parser->bulk_packet_func = usbredir_bulk_packet;\n\n    dev->parser->iso_packet_func = usbredir_iso_packet;\n\n    dev->parser->interrupt_packet_func = usbredir_interrupt_packet;\n\n    dev->read_buf = NULL;\n\n    dev->read_buf_size = 0;\n\n\n\n    usbredirparser_caps_set_cap(caps, usb_redir_cap_connect_device_version);\n\n    usbredirparser_caps_set_cap(caps, usb_redir_cap_filter);\n\n    usbredirparser_caps_set_cap(caps, usb_redir_cap_ep_info_max_packet_size);\n\n    usbredirparser_caps_set_cap(caps, usb_redir_cap_64bits_ids);\n\n\n\n    if (runstate_check(RUN_STATE_INMIGRATE)) {\n\n        flags |= usbredirparser_fl_no_hello;\n\n    }\n\n    usbredirparser_init(dev->parser, version, caps, USB_REDIR_CAPS_SIZE,\n\n                        flags);\n\n    usbredirparser_do_write(dev->parser);\n\n}\n", "idx": 21871}
{"project": "qemu", "commit_id": "e1c37d0e94048502f9874e6356ce7136d4b05bdb", "target": 0, "func": "int fd_start_outgoing_migration(MigrationState *s, const char *fdname)\n\n{\n\n    s->fd = monitor_get_fd(s->mon, fdname);\n\n    if (s->fd == -1) {\n\n        DPRINTF(\"fd_migration: invalid file descriptor identifier\\n\");\n\n        goto err_after_get_fd;\n\n    }\n\n\n\n    if (fcntl(s->fd, F_SETFL, O_NONBLOCK) == -1) {\n\n        DPRINTF(\"Unable to set nonblocking mode on file descriptor\\n\");\n\n        goto err_after_open;\n\n    }\n\n\n\n    s->get_error = fd_errno;\n\n    s->write = fd_write;\n\n    s->close = fd_close;\n\n\n\n    migrate_fd_connect(s);\n\n    return 0;\n\n\n\nerr_after_open:\n\n    close(s->fd);\n\nerr_after_get_fd:\n\n    return -1;\n\n}\n", "idx": 21872}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static void usbnet_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n    USBNetState *s = opaque;\n\n    struct rndis_packet_msg_type *msg;\n\n\n\n    if (s->rndis) {\n\n        msg = (struct rndis_packet_msg_type *) s->in_buf;\n\n        if (!s->rndis_state == RNDIS_DATA_INITIALIZED)\n\n            return;\n\n        if (size + sizeof(struct rndis_packet_msg_type) > sizeof(s->in_buf))\n\n            return;\n\n\n\n        memset(msg, 0, sizeof(struct rndis_packet_msg_type));\n\n        msg->MessageType = cpu_to_le32(RNDIS_PACKET_MSG);\n\n        msg->MessageLength = cpu_to_le32(size + sizeof(struct rndis_packet_msg_type));\n\n        msg->DataOffset = cpu_to_le32(sizeof(struct rndis_packet_msg_type) - 8);\n\n        msg->DataLength = cpu_to_le32(size);\n\n        /* msg->OOBDataOffset;\n\n         * msg->OOBDataLength;\n\n         * msg->NumOOBDataElements;\n\n         * msg->PerPacketInfoOffset;\n\n         * msg->PerPacketInfoLength;\n\n         * msg->VcHandle;\n\n         * msg->Reserved;\n\n         */\n\n        memcpy(msg + 1, buf, size);\n\n        s->in_len = size + sizeof(struct rndis_packet_msg_type);\n\n    } else {\n\n        if (size > sizeof(s->in_buf))\n\n            return;\n\n        memcpy(s->in_buf, buf, size);\n\n        s->in_len = size;\n\n    }\n\n    s->in_ptr = 0;\n\n}\n", "idx": 21874}
{"project": "qemu", "commit_id": "90e56fb46d0a7add88ed463efa4e723a6238f692", "target": 0, "func": "void migrate_compress_threads_create(void)\n\n{\n\n    int i, thread_count;\n\n\n\n    if (!migrate_use_compression()) {\n\n        return;\n\n    }\n\n    quit_comp_thread = false;\n\n    compression_switch = true;\n\n    thread_count = migrate_compress_threads();\n\n    compress_threads = g_new0(QemuThread, thread_count);\n\n    comp_param = g_new0(CompressParam, thread_count);\n\n    comp_done_cond = g_new0(QemuCond, 1);\n\n    comp_done_lock = g_new0(QemuMutex, 1);\n\n    qemu_cond_init(comp_done_cond);\n\n    qemu_mutex_init(comp_done_lock);\n\n    for (i = 0; i < thread_count; i++) {\n\n        /* com_param[i].file is just used as a dummy buffer to save data, set\n\n         * it's ops to empty.\n\n         */\n\n        comp_param[i].file = qemu_fopen_ops(NULL, &empty_ops);\n\n        comp_param[i].done = true;\n\n        qemu_mutex_init(&comp_param[i].mutex);\n\n        qemu_cond_init(&comp_param[i].cond);\n\n        qemu_thread_create(compress_threads + i, \"compress\",\n\n                           do_data_compress, comp_param + i,\n\n                           QEMU_THREAD_JOINABLE);\n\n    }\n\n}\n", "idx": 21875}
{"project": "qemu", "commit_id": "703008e81a6ace40f227aae16d630014e5016af1", "target": 0, "func": "void validate_bootdevices(const char *devices)\n\n{\n\n    /* We just do some generic consistency checks */\n\n    const char *p;\n\n    int bitmap = 0;\n\n\n\n    for (p = devices; *p != '\\0'; p++) {\n\n        /* Allowed boot devices are:\n\n         * a-b: floppy disk drives\n\n         * c-f: IDE disk drives\n\n         * g-m: machine implementation dependent drives\n\n         * n-p: network devices\n\n         * It's up to each machine implementation to check if the given boot\n\n         * devices match the actual hardware implementation and firmware\n\n         * features.\n\n         */\n\n        if (*p < 'a' || *p > 'p') {\n\n            fprintf(stderr, \"Invalid boot device '%c'\\n\", *p);\n\n            exit(1);\n\n        }\n\n        if (bitmap & (1 << (*p - 'a'))) {\n\n            fprintf(stderr, \"Boot device '%c' was given twice\\n\", *p);\n\n            exit(1);\n\n        }\n\n        bitmap |= 1 << (*p - 'a');\n\n    }\n\n}\n", "idx": 21876}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "static int v9fs_walk_marshal(V9fsPDU *pdu, uint16_t nwnames, V9fsQID *qids)\n\n{\n\n    int i;\n\n    size_t offset = 7;\n\n    offset += pdu_marshal(pdu, offset, \"w\", nwnames);\n\n    for (i = 0; i < nwnames; i++) {\n\n        offset += pdu_marshal(pdu, offset, \"Q\", &qids[i]);\n\n    }\n\n    return offset;\n\n}\n", "idx": 21877}
{"project": "qemu", "commit_id": "88266f5aa70fa71fd5cc20aa4dbeb7a7bd8d2e92", "target": 0, "func": "static void close_unused_images(BlockDriverState *top, BlockDriverState *base,\n\n                                const char *base_id)\n\n{\n\n    BlockDriverState *intermediate;\n\n    intermediate = top->backing_hd;\n\n\n\n    while (intermediate) {\n\n        BlockDriverState *unused;\n\n\n\n        /* reached base */\n\n        if (intermediate == base) {\n\n            break;\n\n        }\n\n\n\n        unused = intermediate;\n\n        intermediate = intermediate->backing_hd;\n\n        unused->backing_hd = NULL;\n\n        bdrv_delete(unused);\n\n    }\n\n    top->backing_hd = base;\n\n}\n", "idx": 21878}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void qemu_paio_submit(struct qemu_paiocb *aiocb)\n\n{\n\n    aiocb->ret = -EINPROGRESS;\n\n    aiocb->active = 0;\n\n    mutex_lock(&lock);\n\n    if (idle_threads == 0 && cur_threads < max_threads)\n\n        spawn_thread();\n\n    TAILQ_INSERT_TAIL(&request_list, aiocb, node);\n\n    mutex_unlock(&lock);\n\n    cond_signal(&cond);\n\n}\n", "idx": 21879}
{"project": "qemu", "commit_id": "cfb2d02be9413d45b30ed6d8e38800250b6b4b48", "target": 0, "func": "static inline void cpu_loop_exec_tb(CPUState *cpu, TranslationBlock *tb,\n\n                                    TranslationBlock **last_tb, int *tb_exit,\n\n                                    SyncClocks *sc)\n\n{\n\n    uintptr_t ret;\n\n    int32_t insns_left;\n\n\n\n    if (unlikely(atomic_read(&cpu->exit_request))) {\n\n        return;\n\n    }\n\n\n\n    trace_exec_tb(tb, tb->pc);\n\n    ret = cpu_tb_exec(cpu, tb);\n\n    tb = (TranslationBlock *)(ret & ~TB_EXIT_MASK);\n\n    *tb_exit = ret & TB_EXIT_MASK;\n\n    if (*tb_exit != TB_EXIT_REQUESTED) {\n\n        *last_tb = tb;\n\n        return;\n\n    }\n\n\n\n    *last_tb = NULL;\n\n    insns_left = atomic_read(&cpu->icount_decr.u32);\n\n    atomic_set(&cpu->icount_decr.u16.high, 0);\n\n    if (insns_left < 0) {\n\n        /* Something asked us to stop executing\n\n         * chained TBs; just continue round the main\n\n         * loop. Whatever requested the exit will also\n\n         * have set something else (eg exit_request or\n\n         * interrupt_request) which we will handle\n\n         * next time around the loop.  But we need to\n\n         * ensure the zeroing of tcg_exit_req (see cpu_tb_exec)\n\n         * comes before the next read of cpu->exit_request\n\n         * or cpu->interrupt_request.\n\n         */\n\n        smp_mb();\n\n        return;\n\n    }\n\n\n\n    /* Instruction counter expired.  */\n\n    assert(use_icount);\n\n#ifndef CONFIG_USER_ONLY\n\n    if (cpu->icount_extra) {\n\n        /* Refill decrementer and continue execution.  */\n\n        cpu->icount_extra += insns_left;\n\n        insns_left = MIN(0xffff, cpu->icount_extra);\n\n        cpu->icount_extra -= insns_left;\n\n        cpu->icount_decr.u16.low = insns_left;\n\n    } else {\n\n        /* Execute any remaining instructions, then let the main loop\n\n         * handle the next event.\n\n         */\n\n        if (insns_left > 0) {\n\n            cpu_exec_nocache(cpu, insns_left, tb, false);\n\n            align_clocks(sc, cpu);\n\n        }\n\n        cpu->exception_index = EXCP_INTERRUPT;\n\n        cpu_loop_exit(cpu);\n\n    }\n\n#endif\n\n}\n", "idx": 21880}
{"project": "qemu", "commit_id": "2e6fc7eb1a4af1b127df5f07b8bb28af891946fa", "target": 0, "func": "static int raw_media_changed(BlockDriverState *bs)\n\n{\n\n    return bdrv_media_changed(bs->file->bs);\n\n}\n", "idx": 21881}
{"project": "qemu", "commit_id": "52ae646d4a3ebdcdcc973492c6a56f2c49b6578f", "target": 0, "func": "bool is_tcg_gen_code(uintptr_t tc_ptr)\n\n{\n\n    /* This can be called during code generation, code_gen_buffer_max_size\n\n       is used instead of code_gen_ptr for upper boundary checking */\n\n    return (tc_ptr >= (uintptr_t)tcg_ctx.code_gen_buffer &&\n\n            tc_ptr < (uintptr_t)(tcg_ctx.code_gen_buffer +\n\n                    tcg_ctx.code_gen_buffer_max_size));\n\n}\n", "idx": 21882}
{"project": "qemu", "commit_id": "e3cffe6fad29e07d401eabb913a6d88501d5c143", "target": 1, "func": "static void gen_tlbsync(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    GEN_PRIV;\n\n#else\n\n    CHK_HV;\n\n\n\n    /* tlbsync is a nop for server, ptesync handles delayed tlb flush,\n\n     * embedded however needs to deal with tlbsync. We don't try to be\n\n     * fancy and swallow the overhead of checking for both.\n\n     */\n\n    gen_check_tlb_flush(ctx);\n\n#endif /* defined(CONFIG_USER_ONLY) */\n\n}\n", "idx": 21888}
{"project": "qemu", "commit_id": "0fbf50b6ec126600dca115adb1563c657cc27695", "target": 1, "func": "static void master_abort_mem_write(void *opaque, hwaddr addr, uint64_t val,\n\n                                   unsigned size)\n\n{\n\n}\n", "idx": 21889}
{"project": "qemu", "commit_id": "0dacea92d26c31d453c58de2e99c178fee554166", "target": 1, "func": "static void net_tx_pkt_do_sw_csum(struct NetTxPkt *pkt)\n\n{\n\n    struct iovec *iov = &pkt->vec[NET_TX_PKT_L2HDR_FRAG];\n\n    uint32_t csum_cntr;\n\n    uint16_t csum = 0;\n\n    uint32_t cso;\n\n    /* num of iovec without vhdr */\n\n    uint32_t iov_len = pkt->payload_frags + NET_TX_PKT_PL_START_FRAG - 1;\n\n    uint16_t csl;\n\n    struct ip_header *iphdr;\n\n    size_t csum_offset = pkt->virt_hdr.csum_start + pkt->virt_hdr.csum_offset;\n\n\n\n    /* Put zero to checksum field */\n\n    iov_from_buf(iov, iov_len, csum_offset, &csum, sizeof csum);\n\n\n\n    /* Calculate L4 TCP/UDP checksum */\n\n    csl = pkt->payload_len;\n\n\n\n    /* add pseudo header to csum */\n\n    iphdr = pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base;\n\n    csum_cntr = eth_calc_ip4_pseudo_hdr_csum(iphdr, csl, &cso);\n\n\n\n    /* data checksum */\n\n    csum_cntr +=\n\n        net_checksum_add_iov(iov, iov_len, pkt->virt_hdr.csum_start, csl, cso);\n\n\n\n    /* Put the checksum obtained into the packet */\n\n    csum = cpu_to_be16(net_checksum_finish(csum_cntr));\n\n    iov_from_buf(iov, iov_len, csum_offset, &csum, sizeof csum);\n\n}\n", "idx": 21891}
{"project": "qemu", "commit_id": "35ecde26018207fe723bec6efbd340db6e9c2d53", "target": 1, "func": "static void test_submit_co(void)\n\n{\n\n    WorkerTestData data;\n\n    Coroutine *co = qemu_coroutine_create(co_test_cb);\n\n\n\n    qemu_coroutine_enter(co, &data);\n\n\n\n    /* Back here once the worker has started.  */\n\n\n\n    g_assert_cmpint(active, ==, 1);\n\n    g_assert_cmpint(data.ret, ==, -EINPROGRESS);\n\n\n\n    /* qemu_aio_wait_all will execute the rest of the coroutine.  */\n\n\n\n    qemu_aio_wait_all();\n\n\n\n    /* Back here after the coroutine has finished.  */\n\n\n\n    g_assert_cmpint(active, ==, 0);\n\n    g_assert_cmpint(data.ret, ==, 0);\n\n}\n", "idx": 21893}
{"project": "qemu", "commit_id": "837f21aacf5a714c23ddaadbbc5212f9b661e3f7", "target": 1, "func": "static void pcnet_transmit(PCNetState *s)\n\n{\n\n    hwaddr xmit_cxda = 0;\n\n    int count = CSR_XMTRL(s)-1;\n\n    int add_crc = 0;\n\n    int bcnt;\n\n    s->xmit_pos = -1;\n\n\n\n    if (!CSR_TXON(s)) {\n\n        s->csr[0] &= ~0x0008;\n\n        return;\n\n    }\n\n\n\n    s->tx_busy = 1;\n\n\n\n    txagain:\n\n    if (pcnet_tdte_poll(s)) {\n\n        struct pcnet_TMD tmd;\n\n\n\n        TMDLOAD(&tmd, PHYSADDR(s,CSR_CXDA(s)));\n\n\n\n#ifdef PCNET_DEBUG_TMD\n\n        printf(\"  TMDLOAD 0x%08x\\n\", PHYSADDR(s,CSR_CXDA(s)));\n\n        PRINT_TMD(&tmd);\n\n#endif\n\n        if (GET_FIELD(tmd.status, TMDS, STP)) {\n\n            s->xmit_pos = 0;\n\n            xmit_cxda = PHYSADDR(s,CSR_CXDA(s));\n\n            if (BCR_SWSTYLE(s) != 1)\n\n                add_crc = GET_FIELD(tmd.status, TMDS, ADDFCS);\n\n        }\n\n        if (s->lnkst == 0 &&\n\n            (!CSR_LOOP(s) || (!CSR_INTL(s) && !BCR_TMAULOOP(s)))) {\n\n            SET_FIELD(&tmd.misc, TMDM, LCAR, 1);\n\n            SET_FIELD(&tmd.status, TMDS, ERR, 1);\n\n            SET_FIELD(&tmd.status, TMDS, OWN, 0);\n\n            s->csr[0] |= 0xa000; /* ERR | CERR */\n\n            s->xmit_pos = -1;\n\n            goto txdone;\n\n        }\n\n\n\n        if (s->xmit_pos < 0) {\n\n            goto txdone;\n\n        }\n\n\n\n        bcnt = 4096 - GET_FIELD(tmd.length, TMDL, BCNT);\n\n\n\n        /* if multi-tmd packet outsizes s->buffer then skip it silently.\n\n           Note: this is not what real hw does */\n\n        if (s->xmit_pos + bcnt > sizeof(s->buffer)) {\n\n            s->xmit_pos = -1;\n\n            goto txdone;\n\n        }\n\n\n\n        s->phys_mem_read(s->dma_opaque, PHYSADDR(s, tmd.tbadr),\n\n                         s->buffer + s->xmit_pos, bcnt, CSR_BSWP(s));\n\n        s->xmit_pos += bcnt;\n\n        \n\n        if (!GET_FIELD(tmd.status, TMDS, ENP)) {\n\n            goto txdone;\n\n        }\n\n\n\n#ifdef PCNET_DEBUG\n\n        printf(\"pcnet_transmit size=%d\\n\", s->xmit_pos);\n\n#endif\n\n        if (CSR_LOOP(s)) {\n\n            if (BCR_SWSTYLE(s) == 1)\n\n                add_crc = !GET_FIELD(tmd.status, TMDS, NOFCS);\n\n            s->looptest = add_crc ? PCNET_LOOPTEST_CRC : PCNET_LOOPTEST_NOCRC;\n\n            pcnet_receive(qemu_get_queue(s->nic), s->buffer, s->xmit_pos);\n\n            s->looptest = 0;\n\n        } else {\n\n            if (s->nic) {\n\n                qemu_send_packet(qemu_get_queue(s->nic), s->buffer,\n\n                                 s->xmit_pos);\n\n            }\n\n        }\n\n\n\n        s->csr[0] &= ~0x0008;   /* clear TDMD */\n\n        s->csr[4] |= 0x0004;    /* set TXSTRT */\n\n        s->xmit_pos = -1;\n\n\n\n    txdone:\n\n        SET_FIELD(&tmd.status, TMDS, OWN, 0);\n\n        TMDSTORE(&tmd, PHYSADDR(s,CSR_CXDA(s)));\n\n        if (!CSR_TOKINTD(s) || (CSR_LTINTEN(s) && GET_FIELD(tmd.status, TMDS, LTINT)))\n\n            s->csr[0] |= 0x0200;    /* set TINT */\n\n\n\n        if (CSR_XMTRC(s)<=1)\n\n            CSR_XMTRC(s) = CSR_XMTRL(s);\n\n        else\n\n            CSR_XMTRC(s)--;\n\n        if (count--)\n\n            goto txagain;\n\n\n\n    } else\n\n    if (s->xmit_pos >= 0) {\n\n        struct pcnet_TMD tmd;\n\n        TMDLOAD(&tmd, xmit_cxda);\n\n        SET_FIELD(&tmd.misc, TMDM, BUFF, 1);\n\n        SET_FIELD(&tmd.misc, TMDM, UFLO, 1);\n\n        SET_FIELD(&tmd.status, TMDS, ERR, 1);\n\n        SET_FIELD(&tmd.status, TMDS, OWN, 0);\n\n        TMDSTORE(&tmd, xmit_cxda);\n\n        s->csr[0] |= 0x0200;    /* set TINT */\n\n        if (!CSR_DXSUFLO(s)) {\n\n            s->csr[0] &= ~0x0010;\n\n        } else\n\n        if (count--)\n\n          goto txagain;\n\n    }\n\n\n\n    s->tx_busy = 0;\n\n}\n", "idx": 21894}
{"project": "qemu", "commit_id": "4134ecfeb903c362558cb1cb594ff532fd83fb84", "target": 1, "func": "long do_sigreturn(CPUMBState *env)\n\n{\n\n    struct target_signal_frame *frame;\n\n    abi_ulong frame_addr;\n\n    target_sigset_t target_set;\n\n    sigset_t set;\n\n    int i;\n\n\n\n    frame_addr = env->regs[R_SP];\n\n    trace_user_do_sigreturn(env, frame_addr);\n\n    /* Make sure the guest isn't playing games.  */\n\n    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))\n\n        goto badframe;\n\n\n\n    /* Restore blocked signals */\n\n    __get_user(target_set.sig[0], &frame->uc.tuc_mcontext.oldmask);\n\n    for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n        __get_user(target_set.sig[i], &frame->extramask[i - 1]);\n\n    }\n\n    target_to_host_sigset_internal(&set, &target_set);\n\n    do_sigprocmask(SIG_SETMASK, &set, NULL);\n\n\n\n    restore_sigcontext(&frame->uc.tuc_mcontext, env);\n\n    /* We got here through a sigreturn syscall, our path back is via an\n\n       rtb insn so setup r14 for that.  */\n\n    env->regs[14] = env->sregs[SR_PC];\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return env->regs[10];\n\nbadframe:\n\n    force_sig(TARGET_SIGSEGV);\n\n}\n", "idx": 21895}
{"project": "qemu", "commit_id": "4322e8ced5aaac7191958f09622d199fe61e2d87", "target": 1, "func": "static hwaddr ppc_hash64_pteg_search(PowerPCCPU *cpu, hwaddr hash,\n\n                                     bool secondary, target_ulong ptem,\n\n                                     ppc_hash_pte64_t *pte)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    int i;\n\n    uint64_t token;\n\n    target_ulong pte0, pte1;\n\n    target_ulong pte_index;\n\n\n\n    pte_index = (hash & env->htab_mask) * HPTES_PER_GROUP;\n\n    token = ppc_hash64_start_access(cpu, pte_index);\n\n    if (!token) {\n\n        return -1;\n\n    }\n\n    for (i = 0; i < HPTES_PER_GROUP; i++) {\n\n        pte0 = ppc_hash64_load_hpte0(cpu, token, i);\n\n        pte1 = ppc_hash64_load_hpte1(cpu, token, i);\n\n\n\n        if ((pte0 & HPTE64_V_VALID)\n\n            && (secondary == !!(pte0 & HPTE64_V_SECONDARY))\n\n            && HPTE64_V_COMPARE(pte0, ptem)) {\n\n            pte->pte0 = pte0;\n\n            pte->pte1 = pte1;\n\n            ppc_hash64_stop_access(cpu, token);\n\n            return (pte_index + i) * HASH_PTE_SIZE_64;\n\n        }\n\n    }\n\n    ppc_hash64_stop_access(cpu, token);\n\n    /*\n\n     * We didn't find a valid entry.\n\n     */\n\n    return -1;\n\n}\n", "idx": 21896}
{"project": "qemu", "commit_id": "c0532a76b407af4b276dc5a62d8178db59857ea6", "target": 1, "func": "static void qemu_kvm_eat_signal(CPUState *env, int timeout)\n\n{\n\n    struct timespec ts;\n\n    int r, e;\n\n    siginfo_t siginfo;\n\n    sigset_t waitset;\n\n\n\n    ts.tv_sec = timeout / 1000;\n\n    ts.tv_nsec = (timeout % 1000) * 1000000;\n\n\n\n    sigemptyset(&waitset);\n\n    sigaddset(&waitset, SIG_IPI);\n\n\n\n    qemu_mutex_unlock(&qemu_global_mutex);\n\n    r = sigtimedwait(&waitset, &siginfo, &ts);\n\n    e = errno;\n\n    qemu_mutex_lock(&qemu_global_mutex);\n\n\n\n    if (r == -1 && !(e == EAGAIN || e == EINTR)) {\n\n        fprintf(stderr, \"sigtimedwait: %s\\n\", strerror(e));\n\n        exit(1);\n\n    }\n\n}\n", "idx": 21897}
{"project": "qemu", "commit_id": "32532f215c49f005aaef942adfae34cbcc5fa678", "target": 1, "func": "static void pc_dimm_realize(DeviceState *dev, Error **errp)\n\n{\n\n    PCDIMMDevice *dimm = PC_DIMM(dev);\n\n\n\n    if (!dimm->hostmem) {\n\n        error_setg(errp, \"'\" PC_DIMM_MEMDEV_PROP \"' property is not set\");\n\n        return;\n\n    }\n\n    if ((nb_numa_nodes > 0) && (dimm->node >= nb_numa_nodes)) {\n\n        error_setg(errp, \"'DIMM property \" PC_DIMM_NODE_PROP \" has value %\"\n\n                   PRIu32 \"' which exceeds the number of numa nodes: %d\",\n\n                   dimm->node, nb_numa_nodes);\n\n        return;\n\n    }\n\n}\n", "idx": 21901}
{"project": "qemu", "commit_id": "65072c157e466db2785748a929e775703b20eefe", "target": 1, "func": "static int iothread_stop(Object *object, void *opaque)\n\n{\n\n    IOThread *iothread;\n\n\n\n    iothread = (IOThread *)object_dynamic_cast(object, TYPE_IOTHREAD);\n\n    if (!iothread || !iothread->ctx) {\n\n        return 0;\n\n    }\n\n    iothread->stopping = true;\n\n    aio_notify(iothread->ctx);\n\n    if (atomic_read(&iothread->main_loop)) {\n\n        g_main_loop_quit(iothread->main_loop);\n\n    }\n\n    qemu_thread_join(&iothread->thread);\n\n    return 0;\n\n}\n", "idx": 21902}
{"project": "qemu", "commit_id": "274fb0e1ed962e9ae43ab05e7939499cebb39d26", "target": 1, "func": "SCSIDevice *scsi_disk_init(BlockDriverState *bdrv, int tcq,\n\n                           scsi_completionfn completion, void *opaque)\n\n{\n\n    SCSIDevice *d;\n\n    SCSIDeviceState *s;\n\n\n\n\n    s = (SCSIDeviceState *)qemu_mallocz(sizeof(SCSIDeviceState));\n\n    s->bdrv = bdrv;\n\n    s->tcq = tcq;\n\n    s->completion = completion;\n\n    s->opaque = opaque;\n\n    if (bdrv_get_type_hint(s->bdrv) == BDRV_TYPE_CDROM) {\n\n        s->cluster_size = 4;\n\n    } else {\n\n        s->cluster_size = 1;\n\n    }\n\n    bdrv_get_geometry(s->bdrv, &nb_sectors);\n\n    nb_sectors /= s->cluster_size;\n\n    if (nb_sectors)\n\n        nb_sectors--;\n\n    s->max_lba = nb_sectors;\n\n    strncpy(s->drive_serial_str, drive_get_serial(s->bdrv),\n\n            sizeof(s->drive_serial_str));\n\n    if (strlen(s->drive_serial_str) == 0)\n\n        pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), \"0\");\n\n    qemu_add_vm_change_state_handler(scsi_dma_restart_cb, s);\n\n    d = (SCSIDevice *)qemu_mallocz(sizeof(SCSIDevice));\n\n    d->state = s;\n\n    d->destroy = scsi_destroy;\n\n    d->send_command = scsi_send_command;\n\n    d->read_data = scsi_read_data;\n\n    d->write_data = scsi_write_data;\n\n    d->cancel_io = scsi_cancel_io;\n\n    d->get_buf = scsi_get_buf;\n\n\n\n    return d;\n\n}", "idx": 21903}
{"project": "qemu", "commit_id": "a14ff8a650b5943ee6221b952494661f7cb3b5e2", "target": 1, "func": "static void usbredir_handle_destroy(USBDevice *udev)\n\n{\n\n    USBRedirDevice *dev = DO_UPCAST(USBRedirDevice, dev, udev);\n\n\n\n    qemu_chr_delete(dev->cs);\n\n\n    /* Note must be done after qemu_chr_close, as that causes a close event */\n\n    qemu_bh_delete(dev->chardev_close_bh);\n\n\n\n    qemu_del_timer(dev->attach_timer);\n\n    qemu_free_timer(dev->attach_timer);\n\n\n\n    usbredir_cleanup_device_queues(dev);\n\n\n\n    if (dev->parser) {\n\n        usbredirparser_destroy(dev->parser);\n\n    }\n\n    if (dev->watch) {\n\n        g_source_remove(dev->watch);\n\n    }\n\n\n\n    free(dev->filter_rules);\n\n}", "idx": 21904}
{"project": "qemu", "commit_id": "6cec5487990bf3f1f22b3fcb871978255e92ae0d", "target": 1, "func": "static void set_pixel_format(VncState *vs,\n\n\t\t\t     int bits_per_pixel, int depth,\n\n\t\t\t     int big_endian_flag, int true_color_flag,\n\n\t\t\t     int red_max, int green_max, int blue_max,\n\n\t\t\t     int red_shift, int green_shift, int blue_shift)\n\n{\n\n    int host_big_endian_flag;\n\n\n\n#ifdef WORDS_BIGENDIAN\n\n    host_big_endian_flag = 1;\n\n#else\n\n    host_big_endian_flag = 0;\n\n#endif\n\n    if (!true_color_flag) {\n\n    fail:\n\n\tvnc_client_error(vs);\n\n        return;\n\n    }\n\n    if (bits_per_pixel == 32 &&\n\n        bits_per_pixel == vs->depth * 8 &&\n\n        host_big_endian_flag == big_endian_flag &&\n\n        red_max == 0xff && green_max == 0xff && blue_max == 0xff &&\n\n        red_shift == 16 && green_shift == 8 && blue_shift == 0) {\n\n        vs->depth = 4;\n\n        vs->write_pixels = vnc_write_pixels_copy;\n\n        vs->send_hextile_tile = send_hextile_tile_32;\n\n    } else\n\n    if (bits_per_pixel == 16 &&\n\n        bits_per_pixel == vs->depth * 8 && \n\n        host_big_endian_flag == big_endian_flag &&\n\n        red_max == 31 && green_max == 63 && blue_max == 31 &&\n\n        red_shift == 11 && green_shift == 5 && blue_shift == 0) {\n\n        vs->depth = 2;\n\n        vs->write_pixels = vnc_write_pixels_copy;\n\n        vs->send_hextile_tile = send_hextile_tile_16;\n\n    } else\n\n    if (bits_per_pixel == 8 &&\n\n        bits_per_pixel == vs->depth * 8 &&\n\n        red_max == 7 && green_max == 7 && blue_max == 3 &&\n\n        red_shift == 5 && green_shift == 2 && blue_shift == 0) {\n\n        vs->depth = 1;\n\n        vs->write_pixels = vnc_write_pixels_copy;\n\n        vs->send_hextile_tile = send_hextile_tile_8;\n\n    } else\n\n    {\n\n        /* generic and slower case */\n\n        if (bits_per_pixel != 8 &&\n\n            bits_per_pixel != 16 &&\n\n            bits_per_pixel != 32)\n\n            goto fail;\n\n        if (vs->depth == 4) {\n\n            vs->send_hextile_tile = send_hextile_tile_generic_32;\n\n        } else if (vs->depth == 2) {\n\n           vs->send_hextile_tile = send_hextile_tile_generic_16;\n\n        } else {\n\n            vs->send_hextile_tile = send_hextile_tile_generic_8;\n\n        }\n\n\n\n        vs->pix_big_endian = big_endian_flag;\n\n        vs->write_pixels = vnc_write_pixels_generic;\n\n    }\n\n\n\n    vs->client_red_shift = red_shift;\n\n    vs->client_red_max = red_max;\n\n    vs->client_green_shift = green_shift;\n\n    vs->client_green_max = green_max;\n\n    vs->client_blue_shift = blue_shift;\n\n    vs->client_blue_max = blue_max;\n\n    vs->pix_bpp = bits_per_pixel / 8;\n\n\n\n    vga_hw_invalidate();\n\n    vga_hw_update();\n\n}\n", "idx": 21906}
{"project": "qemu", "commit_id": "1dd3a44753f10970ded50950d28353c00bfcaf91", "target": 1, "func": "static int bdrv_check_byte_request(BlockDriverState *bs, int64_t offset,\n                                   size_t size)\n{\n    int64_t len;\n    if (!bdrv_is_inserted(bs))\n        return -ENOMEDIUM;\n    if (bs->growable)\n        return 0;\n    len = bdrv_getlength(bs);\n    if (offset < 0)\n    if ((offset > len) || (len - offset < size))\n    return 0;", "idx": 21907}
{"project": "qemu", "commit_id": "e5d1fca0f20babbe355957b9ba536fe6187691cc", "target": 1, "func": "static void net_socket_accept(void *opaque)\n\n{\n\n    NetSocketListenState *s = opaque;\n\n    NetSocketState *s1;\n\n    struct sockaddr_in saddr;\n\n    socklen_t len;\n\n    int fd;\n\n\n\n    for(;;) {\n\n        len = sizeof(saddr);\n\n        fd = qemu_accept(s->fd, (struct sockaddr *)&saddr, &len);\n\n        if (fd < 0 && errno != EINTR) {\n\n            return;\n\n        } else if (fd >= 0) {\n\n            break;\n\n        }\n\n    }\n\n    s1 = net_socket_fd_init(s->vlan, s->model, s->name, fd, 1);\n\n    if (!s1) {\n\n        closesocket(fd);\n\n    } else {\n\n        snprintf(s1->nc.info_str, sizeof(s1->nc.info_str),\n\n                 \"socket: connection from %s:%d\",\n\n                 inet_ntoa(saddr.sin_addr), ntohs(saddr.sin_port));\n\n    }\n\n}\n", "idx": 21908}
{"project": "qemu", "commit_id": "0426d53c6530606bf7641b83f2b755fe61c280ee", "target": 1, "func": "static void test_visitor_in_alternate_number(TestInputVisitorData *data,\n\n                                             const void *unused)\n\n{\n\n    Visitor *v;\n\n    Error *err = NULL;\n\n    AltStrBool *asb;\n\n    AltStrNum *asn;\n\n    AltNumStr *ans;\n\n    AltStrInt *asi;\n\n    AltIntNum *ain;\n\n    AltNumInt *ani;\n\n\n\n    /* Parsing an int */\n\n\n\n    v = visitor_input_test_init(data, \"42\");\n\n    visit_type_AltStrBool(v, &asb, NULL, &err);\n\n    error_free_or_abort(&err);\n\n    qapi_free_AltStrBool(asb);\n\n\n\n    /* FIXME: Order of alternate should not affect semantics; asn should\n\n     * parse the same as ans */\n\n    v = visitor_input_test_init(data, \"42\");\n\n    visit_type_AltStrNum(v, &asn, NULL, &err);\n\n    /* FIXME g_assert_cmpint(asn->type, == ALT_STR_NUM_KIND_N); */\n\n    /* FIXME g_assert_cmpfloat(asn->u.n, ==, 42); */\n\n    error_free_or_abort(&err);\n\n    qapi_free_AltStrNum(asn);\n\n\n\n    v = visitor_input_test_init(data, \"42\");\n\n    visit_type_AltNumStr(v, &ans, NULL, &error_abort);\n\n    g_assert_cmpint(ans->type, ==, ALT_NUM_STR_KIND_N);\n\n    g_assert_cmpfloat(ans->u.n, ==, 42);\n\n    qapi_free_AltNumStr(ans);\n\n\n\n    v = visitor_input_test_init(data, \"42\");\n\n    visit_type_AltStrInt(v, &asi, NULL, &error_abort);\n\n    g_assert_cmpint(asi->type, ==, ALT_STR_INT_KIND_I);\n\n    g_assert_cmpint(asi->u.i, ==, 42);\n\n    qapi_free_AltStrInt(asi);\n\n\n\n    v = visitor_input_test_init(data, \"42\");\n\n    visit_type_AltIntNum(v, &ain, NULL, &error_abort);\n\n    g_assert_cmpint(ain->type, ==, ALT_INT_NUM_KIND_I);\n\n    g_assert_cmpint(ain->u.i, ==, 42);\n\n    qapi_free_AltIntNum(ain);\n\n\n\n    v = visitor_input_test_init(data, \"42\");\n\n    visit_type_AltNumInt(v, &ani, NULL, &error_abort);\n\n    g_assert_cmpint(ani->type, ==, ALT_NUM_INT_KIND_I);\n\n    g_assert_cmpint(ani->u.i, ==, 42);\n\n    qapi_free_AltNumInt(ani);\n\n\n\n    /* Parsing a double */\n\n\n\n    v = visitor_input_test_init(data, \"42.5\");\n\n    visit_type_AltStrBool(v, &asb, NULL, &err);\n\n    error_free_or_abort(&err);\n\n    qapi_free_AltStrBool(asb);\n\n\n\n    v = visitor_input_test_init(data, \"42.5\");\n\n    visit_type_AltStrNum(v, &asn, NULL, &error_abort);\n\n    g_assert_cmpint(asn->type, ==, ALT_STR_NUM_KIND_N);\n\n    g_assert_cmpfloat(asn->u.n, ==, 42.5);\n\n    qapi_free_AltStrNum(asn);\n\n\n\n    v = visitor_input_test_init(data, \"42.5\");\n\n    visit_type_AltNumStr(v, &ans, NULL, &error_abort);\n\n    g_assert_cmpint(ans->type, ==, ALT_NUM_STR_KIND_N);\n\n    g_assert_cmpfloat(ans->u.n, ==, 42.5);\n\n    qapi_free_AltNumStr(ans);\n\n\n\n    v = visitor_input_test_init(data, \"42.5\");\n\n    visit_type_AltStrInt(v, &asi, NULL, &err);\n\n    error_free_or_abort(&err);\n\n    qapi_free_AltStrInt(asi);\n\n\n\n    v = visitor_input_test_init(data, \"42.5\");\n\n    visit_type_AltIntNum(v, &ain, NULL, &error_abort);\n\n    g_assert_cmpint(ain->type, ==, ALT_INT_NUM_KIND_N);\n\n    g_assert_cmpfloat(ain->u.n, ==, 42.5);\n\n    qapi_free_AltIntNum(ain);\n\n\n\n    v = visitor_input_test_init(data, \"42.5\");\n\n    visit_type_AltNumInt(v, &ani, NULL, &error_abort);\n\n    g_assert_cmpint(ani->type, ==, ALT_NUM_INT_KIND_N);\n\n    g_assert_cmpfloat(ani->u.n, ==, 42.5);\n\n    qapi_free_AltNumInt(ani);\n\n}\n", "idx": 21912}
{"project": "qemu", "commit_id": "e49ab19fcaa617ad6cdfe1ac401327326b6a2552", "target": 1, "func": "static int coroutine_fn iscsi_co_writev(BlockDriverState *bs,\n\n                                        int64_t sector_num, int nb_sectors,\n\n                                        QEMUIOVector *iov)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    struct IscsiTask iTask;\n\n    uint64_t lba;\n\n    uint32_t num_sectors;\n\n    uint8_t *data = NULL;\n\n    uint8_t *buf = NULL;\n\n\n\n    if (!is_request_lun_aligned(sector_num, nb_sectors, iscsilun)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    lba = sector_qemu2lun(sector_num, iscsilun);\n\n    num_sectors = sector_qemu2lun(nb_sectors, iscsilun);\n\n#if !defined(LIBISCSI_FEATURE_IOVECTOR)\n\n    /* if the iovec only contains one buffer we can pass it directly */\n\n    if (iov->niov == 1) {\n\n        data = iov->iov[0].iov_base;\n\n    } else {\n\n        size_t size = MIN(nb_sectors * BDRV_SECTOR_SIZE, iov->size);\n\n        buf = g_malloc(size);\n\n        qemu_iovec_to_buf(iov, 0, buf, size);\n\n        data = buf;\n\n    }\n\n#endif\n\n    iscsi_co_init_iscsitask(iscsilun, &iTask);\n\nretry:\n\n    if (iscsilun->use_16_for_rw) {\n\n        iTask.task = iscsi_write16_task(iscsilun->iscsi, iscsilun->lun, lba,\n\n                                        data, num_sectors * iscsilun->block_size,\n\n                                        iscsilun->block_size, 0, 0, 0, 0, 0,\n\n                                        iscsi_co_generic_cb, &iTask);\n\n    } else {\n\n        iTask.task = iscsi_write10_task(iscsilun->iscsi, iscsilun->lun, lba,\n\n                                        data, num_sectors * iscsilun->block_size,\n\n                                        iscsilun->block_size, 0, 0, 0, 0, 0,\n\n                                        iscsi_co_generic_cb, &iTask);\n\n    }\n\n    if (iTask.task == NULL) {\n\n        g_free(buf);\n\n        return -ENOMEM;\n\n    }\n\n#if defined(LIBISCSI_FEATURE_IOVECTOR)\n\n    scsi_task_set_iov_out(iTask.task, (struct scsi_iovec *) iov->iov,\n\n                          iov->niov);\n\n#endif\n\n    while (!iTask.complete) {\n\n        iscsi_set_events(iscsilun);\n\n        qemu_coroutine_yield();\n\n    }\n\n\n\n    if (iTask.task != NULL) {\n\n        scsi_free_scsi_task(iTask.task);\n\n        iTask.task = NULL;\n\n    }\n\n\n\n    if (iTask.do_retry) {\n\n        iTask.complete = 0;\n\n        goto retry;\n\n    }\n\n\n\n    g_free(buf);\n\n\n\n    if (iTask.status != SCSI_STATUS_GOOD) {\n\n        return -EIO;\n\n    }\n\n\n\n    iscsi_allocationmap_set(iscsilun, sector_num, nb_sectors);\n\n\n\n    return 0;\n\n}\n", "idx": 21913}
{"project": "qemu", "commit_id": "4f298a4b2957b7833bc607c951ca27c458d98d88", "target": 1, "func": "static void add_sel_entry(IPMIBmcSim *ibs,\n\n                          uint8_t *cmd, unsigned int cmd_len,\n\n                          uint8_t *rsp, unsigned int *rsp_len,\n\n                          unsigned int max_rsp_len)\n\n{\n\n    IPMI_CHECK_CMD_LEN(18);\n\n    if (sel_add_event(ibs, cmd + 2)) {\n\n        rsp[2] = IPMI_CC_OUT_OF_SPACE;\n\n        return;\n\n    }\n\n    /* sel_add_event fills in the record number. */\n\n    IPMI_ADD_RSP_DATA(cmd[2]);\n\n    IPMI_ADD_RSP_DATA(cmd[3]);\n\n}\n", "idx": 21915}
{"project": "qemu", "commit_id": "5839e53bbc0fec56021d758aab7610df421ed8c8", "target": 1, "func": "static void vmdk_free_last_extent(BlockDriverState *bs)\n\n{\n\n    BDRVVmdkState *s = bs->opaque;\n\n\n\n    if (s->num_extents == 0) {\n\n        return;\n\n    }\n\n    s->num_extents--;\n\n    s->extents = g_realloc(s->extents, s->num_extents * sizeof(VmdkExtent));\n\n}\n", "idx": 21916}
{"project": "qemu", "commit_id": "dd09c36159858c66ab6e47c688e4177dd3912bf0", "target": 1, "func": "void cpu_write_xer(CPUPPCState *env, target_ulong xer)\n\n{\n\n    env->so = (xer >> XER_SO) & 1;\n\n    env->ov = (xer >> XER_OV) & 1;\n\n    env->ca = (xer >> XER_CA) & 1;\n\n    env->xer = xer & ~((1u << XER_SO) | (1u << XER_OV) | (1u << XER_CA));\n\n}\n", "idx": 21918}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static int qcow2_write(BlockDriverState *bs, int64_t sector_num,\n\n                       const uint8_t *buf, int nb_sectors)\n\n{\n\n    Coroutine *co;\n\n    AioContext *aio_context = bdrv_get_aio_context(bs);\n\n    Qcow2WriteCo data = {\n\n        .bs         = bs,\n\n        .sector_num = sector_num,\n\n        .buf        = buf,\n\n        .nb_sectors = nb_sectors,\n\n        .ret        = -EINPROGRESS,\n\n    };\n\n    co = qemu_coroutine_create(qcow2_write_co_entry);\n\n    qemu_coroutine_enter(co, &data);\n\n    while (data.ret == -EINPROGRESS) {\n\n        aio_poll(aio_context, true);\n\n    }\n\n    return data.ret;\n\n}\n", "idx": 21920}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "void helper_divq_EAX_T0(void)\n\n{\n\n    uint64_t r0, r1;\n\n    if (T0 == 0) {\n\n        raise_exception(EXCP00_DIVZ);\n\n    }\n\n    r0 = EAX;\n\n    r1 = EDX;\n\n    div64(&r0, &r1, T0);\n\n    EAX = r0;\n\n    EDX = r1;\n\n}\n", "idx": 21921}
{"project": "qemu", "commit_id": "43c696a298f6bef81818b1d8e64d41a160782101", "target": 1, "func": "static void virtio_scsi_hotplug(HotplugHandler *hotplug_dev, DeviceState *dev,\n\n                                Error **errp)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(hotplug_dev);\n\n    VirtIOSCSI *s = VIRTIO_SCSI(vdev);\n\n    SCSIDevice *sd = SCSI_DEVICE(dev);\n\n\n\n    if (s->ctx && !s->dataplane_disabled) {\n\n        VirtIOSCSIBlkChangeNotifier *insert_notifier, *remove_notifier;\n\n\n\n        if (blk_op_is_blocked(sd->conf.blk, BLOCK_OP_TYPE_DATAPLANE, errp)) {\n\n            return;\n\n        }\n\n        blk_op_block_all(sd->conf.blk, s->blocker);\n\n        aio_context_acquire(s->ctx);\n\n        blk_set_aio_context(sd->conf.blk, s->ctx);\n\n        aio_context_release(s->ctx);\n\n\n\n        insert_notifier = g_new0(VirtIOSCSIBlkChangeNotifier, 1);\n\n        insert_notifier->n.notify = virtio_scsi_blk_insert_notifier;\n\n        insert_notifier->s = s;\n\n        insert_notifier->sd = sd;\n\n        blk_add_insert_bs_notifier(sd->conf.blk, &insert_notifier->n);\n\n        QTAILQ_INSERT_TAIL(&s->insert_notifiers, insert_notifier, next);\n\n\n\n        remove_notifier = g_new0(VirtIOSCSIBlkChangeNotifier, 1);\n\n        remove_notifier->n.notify = virtio_scsi_blk_remove_notifier;\n\n        remove_notifier->s = s;\n\n        remove_notifier->sd = sd;\n\n        blk_add_remove_bs_notifier(sd->conf.blk, &remove_notifier->n);\n\n        QTAILQ_INSERT_TAIL(&s->remove_notifiers, remove_notifier, next);\n\n    }\n\n\n\n    if (virtio_vdev_has_feature(vdev, VIRTIO_SCSI_F_HOTPLUG)) {\n\n        virtio_scsi_push_event(s, sd,\n\n                               VIRTIO_SCSI_T_TRANSPORT_RESET,\n\n                               VIRTIO_SCSI_EVT_RESET_RESCAN);\n\n    }\n\n}\n", "idx": 21922}
{"project": "qemu", "commit_id": "2d528d45ecf5ee3c1a566a9f3d664464925ef830", "target": 1, "func": "static CharDriverState *qemu_chr_open_pty(const char *id,\n\n                                          ChardevReturn *ret)\n\n{\n\n    CharDriverState *chr;\n\n    PtyCharDriver *s;\n\n    int master_fd, slave_fd;\n\n    char pty_name[PATH_MAX];\n\n\n\n    master_fd = qemu_openpty_raw(&slave_fd, pty_name);\n\n    if (master_fd < 0) {\n\n        return NULL;\n\n    }\n\n\n\n    close(slave_fd);\n\n    qemu_set_nonblock(master_fd);\n\n\n\n    chr = qemu_chr_alloc();\n\n\n\n    chr->filename = g_strdup_printf(\"pty:%s\", pty_name);\n\n    ret->pty = g_strdup(pty_name);\n\n    ret->has_pty = true;\n\n\n\n    fprintf(stderr, \"char device redirected to %s (label %s)\\n\",\n\n            pty_name, id);\n\n\n\n    s = g_malloc0(sizeof(PtyCharDriver));\n\n    chr->opaque = s;\n\n    chr->chr_write = pty_chr_write;\n\n    chr->chr_update_read_handler = pty_chr_update_read_handler;\n\n    chr->chr_close = pty_chr_close;\n\n    chr->chr_add_watch = pty_chr_add_watch;\n\n    chr->explicit_be_open = true;\n\n\n\n    s->fd = io_channel_from_fd(master_fd);\n\n    s->timer_tag = 0;\n\n\n\n    return chr;\n\n}\n", "idx": 21923}
{"project": "qemu", "commit_id": "1108b2f8a939fb5778d384149e2f1b99062a72da", "target": 1, "func": "int msi_init(struct PCIDevice *dev, uint8_t offset,\n\n             unsigned int nr_vectors, bool msi64bit, bool msi_per_vector_mask)\n\n{\n\n    unsigned int vectors_order;\n\n    uint16_t flags;\n\n    uint8_t cap_size;\n\n    int config_offset;\n\n\n\n    if (!msi_nonbroken) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    MSI_DEV_PRINTF(dev,\n\n                   \"init offset: 0x%\"PRIx8\" vector: %\"PRId8\n\n                   \" 64bit %d mask %d\\n\",\n\n                   offset, nr_vectors, msi64bit, msi_per_vector_mask);\n\n\n\n    assert(!(nr_vectors & (nr_vectors - 1)));   /* power of 2 */\n\n    assert(nr_vectors > 0);\n\n    assert(nr_vectors <= PCI_MSI_VECTORS_MAX);\n\n    /* the nr of MSI vectors is up to 32 */\n\n    vectors_order = ctz32(nr_vectors);\n\n\n\n    flags = vectors_order << ctz32(PCI_MSI_FLAGS_QMASK);\n\n    if (msi64bit) {\n\n        flags |= PCI_MSI_FLAGS_64BIT;\n\n    }\n\n    if (msi_per_vector_mask) {\n\n        flags |= PCI_MSI_FLAGS_MASKBIT;\n\n    }\n\n\n\n    cap_size = msi_cap_sizeof(flags);\n\n    config_offset = pci_add_capability(dev, PCI_CAP_ID_MSI, offset, cap_size);\n\n    if (config_offset < 0) {\n\n        return config_offset;\n\n    }\n\n\n\n    dev->msi_cap = config_offset;\n\n    dev->cap_present |= QEMU_PCI_CAP_MSI;\n\n\n\n    pci_set_word(dev->config + msi_flags_off(dev), flags);\n\n    pci_set_word(dev->wmask + msi_flags_off(dev),\n\n                 PCI_MSI_FLAGS_QSIZE | PCI_MSI_FLAGS_ENABLE);\n\n    pci_set_long(dev->wmask + msi_address_lo_off(dev),\n\n                 PCI_MSI_ADDRESS_LO_MASK);\n\n    if (msi64bit) {\n\n        pci_set_long(dev->wmask + msi_address_hi_off(dev), 0xffffffff);\n\n    }\n\n    pci_set_word(dev->wmask + msi_data_off(dev, msi64bit), 0xffff);\n\n\n\n    if (msi_per_vector_mask) {\n\n        /* Make mask bits 0 to nr_vectors - 1 writable. */\n\n        pci_set_long(dev->wmask + msi_mask_off(dev, msi64bit),\n\n                     0xffffffff >> (PCI_MSI_VECTORS_MAX - nr_vectors));\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 21928}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static int gen_set_psr(DisasContext *s, uint32_t mask, int spsr, TCGv t0)\n\n{\n\n    TCGv tmp;\n\n    if (spsr) {\n\n        /* ??? This is also undefined in system mode.  */\n\n        if (IS_USER(s))\n\n            return 1;\n\n\n\n        tmp = load_cpu_field(spsr);\n\n        tcg_gen_andi_i32(tmp, tmp, ~mask);\n\n        tcg_gen_andi_i32(t0, t0, mask);\n\n        tcg_gen_or_i32(tmp, tmp, t0);\n\n        store_cpu_field(tmp, spsr);\n\n    } else {\n\n        gen_set_cpsr(t0, mask);\n\n    }\n\n    dead_tmp(t0);\n\n    gen_lookup_tb(s);\n\n    return 0;\n\n}\n", "idx": 21930}
{"project": "qemu", "commit_id": "fdad35ef6c5839d50dfc14073364ac893afebc30", "target": 1, "func": "static int nbd_negotiate_options(NBDClient *client, uint16_t myflags,\n                                 Error **errp)\n{\n    uint32_t flags;\n    bool fixedNewstyle = false;\n    bool no_zeroes = false;\n    /* Client sends:\n        [ 0 ..   3]   client flags\n       Then we loop until NBD_OPT_EXPORT_NAME or NBD_OPT_GO:\n        [ 0 ..   7]   NBD_OPTS_MAGIC\n        [ 8 ..  11]   NBD option\n        [12 ..  15]   Data length\n        ...           Rest of request\n        [ 0 ..   7]   NBD_OPTS_MAGIC\n        [ 8 ..  11]   Second NBD option\n        [12 ..  15]   Data length\n        ...           Rest of request\n    */\n    if (nbd_read(client->ioc, &flags, sizeof(flags), errp) < 0) {\n        error_prepend(errp, \"read failed: \");\n        return -EIO;\n    be32_to_cpus(&flags);\n    trace_nbd_negotiate_options_flags(flags);\n    if (flags & NBD_FLAG_C_FIXED_NEWSTYLE) {\n        fixedNewstyle = true;\n        flags &= ~NBD_FLAG_C_FIXED_NEWSTYLE;\n    if (flags & NBD_FLAG_C_NO_ZEROES) {\n        no_zeroes = true;\n        flags &= ~NBD_FLAG_C_NO_ZEROES;\n    if (flags != 0) {\n        error_setg(errp, \"Unknown client flags 0x%\" PRIx32 \" received\", flags);\n    while (1) {\n        int ret;\n        uint32_t option, length;\n        uint64_t magic;\n        if (nbd_read(client->ioc, &magic, sizeof(magic), errp) < 0) {\n            error_prepend(errp, \"read failed: \");\n        magic = be64_to_cpu(magic);\n        trace_nbd_negotiate_options_check_magic(magic);\n        if (magic != NBD_OPTS_MAGIC) {\n            error_setg(errp, \"Bad magic received\");\n        if (nbd_read(client->ioc, &option,\n                     sizeof(option), errp) < 0) {\n            error_prepend(errp, \"read failed: \");\n        option = be32_to_cpu(option);\n        if (nbd_read(client->ioc, &length, sizeof(length), errp) < 0) {\n            error_prepend(errp, \"read failed: \");\n        length = be32_to_cpu(length);\n        trace_nbd_negotiate_options_check_option(option,\n                                                 nbd_opt_lookup(option));\n        if (client->tlscreds &&\n            client->ioc == (QIOChannel *)client->sioc) {\n            QIOChannel *tioc;\n            if (!fixedNewstyle) {\n                error_setg(errp, \"Unsupported option 0x%\" PRIx32, option);\n            switch (option) {\n            case NBD_OPT_STARTTLS:\n                if (length) {\n                    /* Unconditionally drop the connection if the client\n                     * can't start a TLS negotiation correctly */\n                    return nbd_reject_length(client, length, option, true,\n                                             errp);\n                tioc = nbd_negotiate_handle_starttls(client, errp);\n                if (!tioc) {\n                    return -EIO;\n                ret = 0;\n                object_unref(OBJECT(client->ioc));\n                client->ioc = QIO_CHANNEL(tioc);\n                break;\n            case NBD_OPT_EXPORT_NAME:\n                /* No way to return an error to client, so drop connection */\n                error_setg(errp, \"Option 0x%x not permitted before TLS\",\n                           option);\n            default:\n                if (nbd_drop(client->ioc, length, errp) < 0) {\n                    return -EIO;\n                ret = nbd_negotiate_send_rep_err(client->ioc,\n                                                 NBD_REP_ERR_TLS_REQD,\n                                                 option, errp,\n                                                 \"Option 0x%\" PRIx32\n                                                 \"not permitted before TLS\",\n                                                 option);\n                /* Let the client keep trying, unless they asked to\n                 * quit. In this mode, we've already sent an error, so\n                 * we can't ack the abort.  */\n                if (option == NBD_OPT_ABORT) {\n                    return 1;\n                break;\n        } else if (fixedNewstyle) {\n            switch (option) {\n            case NBD_OPT_LIST:\n                if (length) {\n                    ret = nbd_reject_length(client, length, option, false,\n                                            errp);\n                } else {\n                    ret = nbd_negotiate_handle_list(client, errp);\n                break;\n            case NBD_OPT_ABORT:\n                /* NBD spec says we must try to reply before\n                 * disconnecting, but that we must also tolerate\n                 * guests that don't wait for our reply. */\n                nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, option, NULL);\n                return 1;\n            case NBD_OPT_EXPORT_NAME:\n                return nbd_negotiate_handle_export_name(client, length,\n                                                        myflags, no_zeroes,\n                                                        errp);\n            case NBD_OPT_INFO:\n            case NBD_OPT_GO:\n                ret = nbd_negotiate_handle_info(client, length, option,\n                                                myflags, errp);\n                if (ret == 1) {\n                    assert(option == NBD_OPT_GO);\n                    return 0;\n                break;\n            case NBD_OPT_STARTTLS:\n                if (length) {\n                    ret = nbd_reject_length(client, length, option, false,\n                                            errp);\n                } else if (client->tlscreds) {\n                    ret = nbd_negotiate_send_rep_err(client->ioc,\n                                                     NBD_REP_ERR_INVALID,\n                                                     option, errp,\n                                                     \"TLS already enabled\");\n                } else {\n                    ret = nbd_negotiate_send_rep_err(client->ioc,\n                                                     NBD_REP_ERR_POLICY,\n                                                     option, errp,\n                                                     \"TLS not configured\");\n                break;\n            case NBD_OPT_STRUCTURED_REPLY:\n                if (length) {\n                    ret = nbd_reject_length(client, length, option, false,\n                                            errp);\n                } else if (client->structured_reply) {\n                    ret = nbd_negotiate_send_rep_err(\n                        client->ioc, NBD_REP_ERR_INVALID, option, errp,\n                        \"structured reply already negotiated\");\n                } else {\n                    ret = nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK,\n                                                 option, errp);\n                    client->structured_reply = true;\n                    myflags |= NBD_FLAG_SEND_DF;\n                break;\n            default:\n                if (nbd_drop(client->ioc, length, errp) < 0) {\n                    return -EIO;\n                ret = nbd_negotiate_send_rep_err(client->ioc,\n                                                 NBD_REP_ERR_UNSUP,\n                                                 option, errp,\n                                                 \"Unsupported option 0x%\"\n                                                 PRIx32 \" (%s)\", option,\n                                                 nbd_opt_lookup(option));\n                break;\n        } else {\n            /*\n             * If broken new-style we should drop the connection\n             * for anything except NBD_OPT_EXPORT_NAME\n             */\n            switch (option) {\n            case NBD_OPT_EXPORT_NAME:\n                return nbd_negotiate_handle_export_name(client, length,\n                                                        myflags, no_zeroes,\n                                                        errp);\n            default:\n                error_setg(errp, \"Unsupported option 0x%\" PRIx32 \" (%s)\",\n                           option, nbd_opt_lookup(option));\n        if (ret < 0) {\n            return ret;", "idx": 21932}
{"project": "qemu", "commit_id": "caffdac363801cd2cf2bf01ad013a8c1e1e43800", "target": 1, "func": "static int virtio_ccw_blk_init(VirtioCcwDevice *ccw_dev)\n\n{\n\n    VirtIOBlkCcw *dev = VIRTIO_BLK_CCW(ccw_dev);\n\n    DeviceState *vdev = DEVICE(&dev->vdev);\n\n    virtio_blk_set_conf(vdev, &(dev->blk));\n\n    qdev_set_parent_bus(vdev, BUS(&ccw_dev->bus));\n\n    if (qdev_init(vdev) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    return virtio_ccw_device_init(ccw_dev, VIRTIO_DEVICE(vdev));\n\n}\n", "idx": 21933}
{"project": "qemu", "commit_id": "27a83f8e7ed63ced7e36c47a42f46ab44ee02bd8", "target": 1, "func": "CPUState *mon_get_cpu(void)\n\n{\n\n    if (!cur_mon->mon_cpu) {\n\n        monitor_set_cpu(0);\n\n    }\n\n    cpu_synchronize_state(cur_mon->mon_cpu);\n\n    return cur_mon->mon_cpu;\n\n}\n", "idx": 21939}
{"project": "qemu", "commit_id": "737d2b3c41d59eb8f94ab7eb419b957938f24943", "target": 1, "func": "ssize_t ne2000_receive(NetClientState *nc, const uint8_t *buf, size_t size_)\n\n{\n\n    NE2000State *s = qemu_get_nic_opaque(nc);\n\n    int size = size_;\n\n    uint8_t *p;\n\n    unsigned int total_len, next, avail, len, index, mcast_idx;\n\n    uint8_t buf1[60];\n\n    static const uint8_t broadcast_macaddr[6] =\n\n        { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\n\n\n#if defined(DEBUG_NE2000)\n\n    printf(\"NE2000: received len=%d\\n\", size);\n\n#endif\n\n\n\n    if (s->cmd & E8390_STOP || ne2000_buffer_full(s))\n\n        return -1;\n\n\n\n    /* XXX: check this */\n\n    if (s->rxcr & 0x10) {\n\n        /* promiscuous: receive all */\n\n    } else {\n\n        if (!memcmp(buf,  broadcast_macaddr, 6)) {\n\n            /* broadcast address */\n\n            if (!(s->rxcr & 0x04))\n\n                return size;\n\n        } else if (buf[0] & 0x01) {\n\n            /* multicast */\n\n            if (!(s->rxcr & 0x08))\n\n                return size;\n\n            mcast_idx = compute_mcast_idx(buf);\n\n            if (!(s->mult[mcast_idx >> 3] & (1 << (mcast_idx & 7))))\n\n                return size;\n\n        } else if (s->mem[0] == buf[0] &&\n\n                   s->mem[2] == buf[1] &&\n\n                   s->mem[4] == buf[2] &&\n\n                   s->mem[6] == buf[3] &&\n\n                   s->mem[8] == buf[4] &&\n\n                   s->mem[10] == buf[5]) {\n\n            /* match */\n\n        } else {\n\n            return size;\n\n        }\n\n    }\n\n\n\n\n\n    /* if too small buffer, then expand it */\n\n    if (size < MIN_BUF_SIZE) {\n\n        memcpy(buf1, buf, size);\n\n        memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n\n        buf = buf1;\n\n        size = MIN_BUF_SIZE;\n\n    }\n\n\n\n    index = s->curpag << 8;\n\n    if (index >= NE2000_PMEM_END) {\n\n        index = s->start;\n\n    }\n\n    /* 4 bytes for header */\n\n    total_len = size + 4;\n\n    /* address for next packet (4 bytes for CRC) */\n\n    next = index + ((total_len + 4 + 255) & ~0xff);\n\n    if (next >= s->stop)\n\n        next -= (s->stop - s->start);\n\n    /* prepare packet header */\n\n    p = s->mem + index;\n\n    s->rsr = ENRSR_RXOK; /* receive status */\n\n    /* XXX: check this */\n\n    if (buf[0] & 0x01)\n\n        s->rsr |= ENRSR_PHY;\n\n    p[0] = s->rsr;\n\n    p[1] = next >> 8;\n\n    p[2] = total_len;\n\n    p[3] = total_len >> 8;\n\n    index += 4;\n\n\n\n    /* write packet data */\n\n    while (size > 0) {\n\n        if (index <= s->stop)\n\n            avail = s->stop - index;\n\n        else\n\n            avail = 0;\n\n        len = size;\n\n        if (len > avail)\n\n            len = avail;\n\n        memcpy(s->mem + index, buf, len);\n\n        buf += len;\n\n        index += len;\n\n        if (index == s->stop)\n\n            index = s->start;\n\n        size -= len;\n\n    }\n\n    s->curpag = next >> 8;\n\n\n\n    /* now we can signal we have received something */\n\n    s->isr |= ENISR_RX;\n\n    ne2000_update_irq(s);\n\n\n\n    return size_;\n\n}\n", "idx": 21941}
{"project": "qemu", "commit_id": "00b8702581f312aa46f797a8b3153d9b2892d967", "target": 1, "func": "static void get_pci_host_devaddr(Object *obj, Visitor *v, const char *name,\n\n                                 void *opaque, Error **errp)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop = opaque;\n\n    PCIHostDeviceAddress *addr = qdev_get_prop_ptr(dev, prop);\n\n    char buffer[] = \"xxxx:xx:xx.x\";\n\n    char *p = buffer;\n\n    int rc = 0;\n\n\n\n    rc = snprintf(buffer, sizeof(buffer), \"%04x:%02x:%02x.%d\",\n\n                  addr->domain, addr->bus, addr->slot, addr->function);\n\n    assert(rc == sizeof(buffer) - 1);\n\n\n\n    visit_type_str(v, name, &p, errp);\n\n}\n", "idx": 21943}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(set_T1)\n\n{\n\n    T1 = PARAM(1);\n\n    RETURN();\n\n}\n", "idx": 21949}
{"project": "qemu", "commit_id": "72b6ffc76653214b69a94a7b1643ff80df134486", "target": 1, "func": "static int nbd_co_send_request(BlockDriverState *bs,\n\n                               NBDRequest *request,\n\n                               QEMUIOVector *qiov)\n\n{\n\n    NBDClientSession *s = nbd_get_client_session(bs);\n\n    int rc, ret, i;\n\n\n\n    qemu_co_mutex_lock(&s->send_mutex);\n\n    while (s->in_flight == MAX_NBD_REQUESTS) {\n\n        qemu_co_queue_wait(&s->free_sema, &s->send_mutex);\n\n    }\n\n    s->in_flight++;\n\n\n\n    for (i = 0; i < MAX_NBD_REQUESTS; i++) {\n\n        if (s->recv_coroutine[i] == NULL) {\n\n            s->recv_coroutine[i] = qemu_coroutine_self();\n\n            break;\n\n        }\n\n    }\n\n\n\n    g_assert(qemu_in_coroutine());\n\n    assert(i < MAX_NBD_REQUESTS);\n\n    request->handle = INDEX_TO_HANDLE(s, i);\n\n\n\n    if (!s->ioc) {\n\n        qemu_co_mutex_unlock(&s->send_mutex);\n\n        return -EPIPE;\n\n    }\n\n\n\n    if (qiov) {\n\n        qio_channel_set_cork(s->ioc, true);\n\n        rc = nbd_send_request(s->ioc, request);\n\n        if (rc >= 0) {\n\n            ret = nbd_rwv(s->ioc, qiov->iov, qiov->niov, request->len, false,\n\n                          NULL);\n\n            if (ret != request->len) {\n\n                rc = -EIO;\n\n            }\n\n        }\n\n        qio_channel_set_cork(s->ioc, false);\n\n    } else {\n\n        rc = nbd_send_request(s->ioc, request);\n\n    }\n\n    qemu_co_mutex_unlock(&s->send_mutex);\n\n    return rc;\n\n}\n", "idx": 21950}
{"project": "qemu", "commit_id": "21b7cf9e07e5991c57b461181cfb5bbb6fe7a9d6", "target": 1, "func": "static void __attribute__((__constructor__)) rcu_init(void)\n\n{\n\n    QemuThread thread;\n\n\n\n    qemu_mutex_init(&rcu_gp_lock);\n\n    qemu_event_init(&rcu_gp_event, true);\n\n\n\n    qemu_event_init(&rcu_call_ready_event, false);\n\n    qemu_thread_create(&thread, \"call_rcu\", call_rcu_thread,\n\n                       NULL, QEMU_THREAD_DETACHED);\n\n\n\n    rcu_register_thread();\n\n}\n", "idx": 21952}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(divw)\n\n{\n\n    if ((Ts0 == INT32_MIN && Ts1 == -1) || Ts1 == 0) {\n\n        T0 = (int32_t)((-1) * (T0 >> 31));\n\n    } else {\n\n        T0 = (Ts0 / Ts1);\n\n    }\n\n    RETURN();\n\n}\n", "idx": 21957}
{"project": "qemu", "commit_id": "cdad4bd8940c6fb1616733550663d006c611b2f4", "target": 1, "func": "BlockInterfaceErrorAction drive_get_onerror(BlockDriverState *bdrv)\n\n{\n\n    int index;\n\n\n\n    for (index = 0; index < nb_drives; index++)\n\n        if (drives_table[index].bdrv == bdrv)\n\n            return drives_table[index].onerror;\n\n\n\n    return BLOCK_ERR_REPORT;\n\n}\n", "idx": 21958}
{"project": "qemu", "commit_id": "34bc07c5282a631c2663ae1ded0a186f46f64612", "target": 1, "func": "static void increase_dynamic_storage(IVShmemState *s, int new_min_size) {\n\n\n\n    int j, old_nb_alloc;\n\n\n\n    old_nb_alloc = s->nb_peers;\n\n\n\n    while (new_min_size >= s->nb_peers)\n\n        s->nb_peers = s->nb_peers * 2;\n\n\n\n    IVSHMEM_DPRINTF(\"bumping storage to %d guests\\n\", s->nb_peers);\n\n    s->peers = g_realloc(s->peers, s->nb_peers * sizeof(Peer));\n\n\n\n    /* zero out new pointers */\n\n    for (j = old_nb_alloc; j < s->nb_peers; j++) {\n\n        s->peers[j].eventfds = NULL;\n\n        s->peers[j].nb_eventfds = 0;\n\n    }\n\n}\n", "idx": 21961}
{"project": "qemu", "commit_id": "671f66f87fbf6cc6a3879f3055f16347b1db91e9", "target": 1, "func": "static void netfilter_finalize(Object *obj)\n\n{\n\n    NetFilterState *nf = NETFILTER(obj);\n\n    NetFilterClass *nfc = NETFILTER_GET_CLASS(obj);\n\n\n\n    if (nfc->cleanup) {\n\n        nfc->cleanup(nf);\n\n    }\n\n\n\n    if (nf->netdev && !QTAILQ_EMPTY(&nf->netdev->filters)) {\n\n        QTAILQ_REMOVE(&nf->netdev->filters, nf, next);\n\n    }\n\n\n}", "idx": 21962}
{"project": "qemu", "commit_id": "3ce21445387c64032a21ae73c995195307a28a36", "target": 1, "func": "static void usb_host_auto_check(void *unused)\n\n{\n\n    struct USBHostDevice *s;\n\n    struct USBAutoFilter *f;\n\n    libusb_device **devs;\n\n    struct libusb_device_descriptor ddesc;\n\n    int unconnected = 0;\n\n    int i, n;\n\n\n\n    if (usb_host_init() != 0) {\n\n        return;\n\n    }\n\n\n\n    if (runstate_is_running()) {\n\n        n = libusb_get_device_list(ctx, &devs);\n\n        for (i = 0; i < n; i++) {\n\n            if (libusb_get_device_descriptor(devs[i], &ddesc) != 0) {\n\n                continue;\n\n            }\n\n            if (ddesc.bDeviceClass == LIBUSB_CLASS_HUB) {\n\n                continue;\n\n            }\n\n            QTAILQ_FOREACH(s, &hostdevs, next) {\n\n                f = &s->match;\n\n                if (f->bus_num > 0 &&\n\n                    f->bus_num != libusb_get_bus_number(devs[i])) {\n\n                    continue;\n\n                }\n\n                if (f->addr > 0 &&\n\n                    f->addr != libusb_get_device_address(devs[i])) {\n\n                    continue;\n\n                }\n\n                if (f->port != NULL) {\n\n                    char port[16] = \"-\";\n\n                    usb_host_get_port(devs[i], port, sizeof(port));\n\n                    if (strcmp(f->port, port) != 0) {\n\n                        continue;\n\n                    }\n\n                }\n\n                if (f->vendor_id > 0 &&\n\n                    f->vendor_id != ddesc.idVendor) {\n\n                    continue;\n\n                }\n\n                if (f->product_id > 0 &&\n\n                    f->product_id != ddesc.idProduct) {\n\n                    continue;\n\n                }\n\n\n\n                /* We got a match */\n\n                s->seen++;\n\n                if (s->errcount >= 3) {\n\n                    continue;\n\n                }\n\n                if (s->dh != NULL) {\n\n                    continue;\n\n                }\n\n                if (usb_host_open(s, devs[i]) < 0) {\n\n                    s->errcount++;\n\n                    continue;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n        libusb_free_device_list(devs, 1);\n\n\n\n        QTAILQ_FOREACH(s, &hostdevs, next) {\n\n            if (s->dh == NULL) {\n\n                unconnected++;\n\n            }\n\n            if (s->seen == 0) {\n\n                if (s->dh) {\n\n                    usb_host_close(s);\n\n                }\n\n                s->errcount = 0;\n\n            }\n\n            s->seen = 0;\n\n        }\n\n\n\n#if 0\n\n        if (unconnected == 0) {\n\n            /* nothing to watch */\n\n            if (usb_auto_timer) {\n\n                timer_del(usb_auto_timer);\n\n                trace_usb_host_auto_scan_disabled();\n\n            }\n\n            return;\n\n        }\n\n#endif\n\n    }\n\n\n\n    if (!usb_vmstate) {\n\n        usb_vmstate = qemu_add_vm_change_state_handler(usb_host_vm_state, NULL);\n\n    }\n\n    if (!usb_auto_timer) {\n\n        usb_auto_timer = timer_new_ms(QEMU_CLOCK_REALTIME, usb_host_auto_check, NULL);\n\n        if (!usb_auto_timer) {\n\n            return;\n\n        }\n\n        trace_usb_host_auto_scan_enabled();\n\n    }\n\n    timer_mod(usb_auto_timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 2000);\n\n}\n", "idx": 21963}
{"project": "qemu", "commit_id": "15fa08f8451babc88d733bd411d4c94976f9d0f8", "target": 1, "func": "int tcg_gen_code(TCGContext *s, TranslationBlock *tb)\n\n{\n\n#ifdef CONFIG_PROFILER\n\n    TCGProfile *prof = &s->prof;\n\n#endif\n\n    int i, oi, oi_next, num_insns;\n\n\n\n#ifdef CONFIG_PROFILER\n\n    {\n\n        int n;\n\n\n\n        n = s->gen_op_buf[0].prev + 1;\n\n        atomic_set(&prof->op_count, prof->op_count + n);\n\n        if (n > prof->op_count_max) {\n\n            atomic_set(&prof->op_count_max, n);\n\n        }\n\n\n\n        n = s->nb_temps;\n\n        atomic_set(&prof->temp_count, prof->temp_count + n);\n\n        if (n > prof->temp_count_max) {\n\n            atomic_set(&prof->temp_count_max, n);\n\n        }\n\n    }\n\n#endif\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP)\n\n                 && qemu_log_in_addr_range(tb->pc))) {\n\n        qemu_log_lock();\n\n        qemu_log(\"OP:\\n\");\n\n        tcg_dump_ops(s);\n\n        qemu_log(\"\\n\");\n\n        qemu_log_unlock();\n\n    }\n\n#endif\n\n\n\n#ifdef CONFIG_PROFILER\n\n    atomic_set(&prof->opt_time, prof->opt_time - profile_getclock());\n\n#endif\n\n\n\n#ifdef USE_TCG_OPTIMIZATIONS\n\n    tcg_optimize(s);\n\n#endif\n\n\n\n#ifdef CONFIG_PROFILER\n\n    atomic_set(&prof->opt_time, prof->opt_time + profile_getclock());\n\n    atomic_set(&prof->la_time, prof->la_time - profile_getclock());\n\n#endif\n\n\n\n    liveness_pass_1(s);\n\n\n\n    if (s->nb_indirects > 0) {\n\n#ifdef DEBUG_DISAS\n\n        if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP_IND)\n\n                     && qemu_log_in_addr_range(tb->pc))) {\n\n            qemu_log_lock();\n\n            qemu_log(\"OP before indirect lowering:\\n\");\n\n            tcg_dump_ops(s);\n\n            qemu_log(\"\\n\");\n\n            qemu_log_unlock();\n\n        }\n\n#endif\n\n        /* Replace indirect temps with direct temps.  */\n\n        if (liveness_pass_2(s)) {\n\n            /* If changes were made, re-run liveness.  */\n\n            liveness_pass_1(s);\n\n        }\n\n    }\n\n\n\n#ifdef CONFIG_PROFILER\n\n    atomic_set(&prof->la_time, prof->la_time + profile_getclock());\n\n#endif\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP_OPT)\n\n                 && qemu_log_in_addr_range(tb->pc))) {\n\n        qemu_log_lock();\n\n        qemu_log(\"OP after optimization and liveness analysis:\\n\");\n\n        tcg_dump_ops(s);\n\n        qemu_log(\"\\n\");\n\n        qemu_log_unlock();\n\n    }\n\n#endif\n\n\n\n    tcg_reg_alloc_start(s);\n\n\n\n    s->code_buf = tb->tc.ptr;\n\n    s->code_ptr = tb->tc.ptr;\n\n\n\n#ifdef TCG_TARGET_NEED_LDST_LABELS\n\n    s->ldst_labels = NULL;\n\n#endif\n\n#ifdef TCG_TARGET_NEED_POOL_LABELS\n\n    s->pool_labels = NULL;\n\n#endif\n\n\n\n    num_insns = -1;\n\n    for (oi = s->gen_op_buf[0].next; oi != 0; oi = oi_next) {\n\n        TCGOp * const op = &s->gen_op_buf[oi];\n\n        TCGOpcode opc = op->opc;\n\n\n\n        oi_next = op->next;\n\n#ifdef CONFIG_PROFILER\n\n        atomic_set(&prof->table_op_count[opc], prof->table_op_count[opc] + 1);\n\n#endif\n\n\n\n        switch (opc) {\n\n        case INDEX_op_mov_i32:\n\n        case INDEX_op_mov_i64:\n\n            tcg_reg_alloc_mov(s, op);\n\n            break;\n\n        case INDEX_op_movi_i32:\n\n        case INDEX_op_movi_i64:\n\n            tcg_reg_alloc_movi(s, op);\n\n            break;\n\n        case INDEX_op_insn_start:\n\n            if (num_insns >= 0) {\n\n                s->gen_insn_end_off[num_insns] = tcg_current_code_size(s);\n\n            }\n\n            num_insns++;\n\n            for (i = 0; i < TARGET_INSN_START_WORDS; ++i) {\n\n                target_ulong a;\n\n#if TARGET_LONG_BITS > TCG_TARGET_REG_BITS\n\n                a = deposit64(op->args[i * 2], 32, 32, op->args[i * 2 + 1]);\n\n#else\n\n                a = op->args[i];\n\n#endif\n\n                s->gen_insn_data[num_insns][i] = a;\n\n            }\n\n            break;\n\n        case INDEX_op_discard:\n\n            temp_dead(s, arg_temp(op->args[0]));\n\n            break;\n\n        case INDEX_op_set_label:\n\n            tcg_reg_alloc_bb_end(s, s->reserved_regs);\n\n            tcg_out_label(s, arg_label(op->args[0]), s->code_ptr);\n\n            break;\n\n        case INDEX_op_call:\n\n            tcg_reg_alloc_call(s, op);\n\n            break;\n\n        default:\n\n            /* Sanity check that we've not introduced any unhandled opcodes. */\n\n            tcg_debug_assert(tcg_op_supported(opc));\n\n            /* Note: in order to speed up the code, it would be much\n\n               faster to have specialized register allocator functions for\n\n               some common argument patterns */\n\n            tcg_reg_alloc_op(s, op);\n\n            break;\n\n        }\n\n#ifdef CONFIG_DEBUG_TCG\n\n        check_regs(s);\n\n#endif\n\n        /* Test for (pending) buffer overflow.  The assumption is that any\n\n           one operation beginning below the high water mark cannot overrun\n\n           the buffer completely.  Thus we can test for overflow after\n\n           generating code without having to check during generation.  */\n\n        if (unlikely((void *)s->code_ptr > s->code_gen_highwater)) {\n\n            return -1;\n\n        }\n\n    }\n\n    tcg_debug_assert(num_insns >= 0);\n\n    s->gen_insn_end_off[num_insns] = tcg_current_code_size(s);\n\n\n\n    /* Generate TB finalization at the end of block */\n\n#ifdef TCG_TARGET_NEED_LDST_LABELS\n\n    if (!tcg_out_ldst_finalize(s)) {\n\n        return -1;\n\n    }\n\n#endif\n\n#ifdef TCG_TARGET_NEED_POOL_LABELS\n\n    if (!tcg_out_pool_finalize(s)) {\n\n        return -1;\n\n    }\n\n#endif\n\n\n\n    /* flush instruction cache */\n\n    flush_icache_range((uintptr_t)s->code_buf, (uintptr_t)s->code_ptr);\n\n\n\n    return tcg_current_code_size(s);\n\n}\n", "idx": 21964}
{"project": "qemu", "commit_id": "d6e58090fed20e30e6966007bc4df0c04324d9e7", "target": 1, "func": "void palette_destroy(VncPalette *palette)\n\n{\n\n    if (palette == NULL) {\n\n        qemu_free(palette);\n\n    }\n\n}\n", "idx": 21965}
{"project": "qemu", "commit_id": "ee640c625e190a0c0e6b8966adc0e4720fb75200", "target": 1, "func": "static int ivshmem_setup_interrupts(IVShmemState *s)\n\n{\n\n    /* allocate QEMU callback data for receiving interrupts */\n\n    s->msi_vectors = g_malloc0(s->vectors * sizeof(MSIVector));\n\n\n\n    if (ivshmem_has_feature(s, IVSHMEM_MSI)) {\n\n        if (msix_init_exclusive_bar(PCI_DEVICE(s), s->vectors, 1)) {\n\n            return -1;\n\n        }\n\n\n\n        IVSHMEM_DPRINTF(\"msix initialized (%d vectors)\\n\", s->vectors);\n\n        ivshmem_msix_vector_use(s);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 21966}
{"project": "qemu", "commit_id": "7839ff593be03a7de3c6760e0b50c565ea751d36", "target": 1, "func": "static void pc_compat_1_4(QEMUMachineInitArgs *args)\n\n{\n\n    pc_compat_1_5(args);\n\n    has_pvpanic = false;\n\n    x86_cpu_compat_set_features(\"n270\", FEAT_1_ECX, 0, CPUID_EXT_MOVBE);\n\n    x86_cpu_compat_set_features(\"Westmere\", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);\n\n}\n", "idx": 21967}
{"project": "qemu", "commit_id": "ef0e8fc768a561dd13a86420b3268f6f3d5d0621", "target": 1, "func": "static void amdvi_realize(DeviceState *dev, Error **err)\n\n{\n\n    int ret = 0;\n\n    AMDVIState *s = AMD_IOMMU_DEVICE(dev);\n\n    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(dev);\n\n    PCIBus *bus = PC_MACHINE(qdev_get_machine())->bus;\n\n    s->iotlb = g_hash_table_new_full(amdvi_uint64_hash,\n\n                                     amdvi_uint64_equal, g_free, g_free);\n\n\n\n    /* This device should take care of IOMMU PCI properties */\n\n    x86_iommu->type = TYPE_AMD;\n\n    qdev_set_parent_bus(DEVICE(&s->pci), &bus->qbus);\n\n    object_property_set_bool(OBJECT(&s->pci), true, \"realized\", err);\n\n    s->capab_offset = pci_add_capability(&s->pci.dev, AMDVI_CAPAB_ID_SEC, 0,\n\n                                         AMDVI_CAPAB_SIZE);\n\n    assert(s->capab_offset > 0);\n\n    ret = pci_add_capability(&s->pci.dev, PCI_CAP_ID_MSI, 0, AMDVI_CAPAB_REG_SIZE);\n\n    assert(ret > 0);\n\n    ret = pci_add_capability(&s->pci.dev, PCI_CAP_ID_HT, 0, AMDVI_CAPAB_REG_SIZE);\n\n    assert(ret > 0);\n\n\n\n    /* set up MMIO */\n\n    memory_region_init_io(&s->mmio, OBJECT(s), &mmio_mem_ops, s, \"amdvi-mmio\",\n\n                          AMDVI_MMIO_SIZE);\n\n\n\n    sysbus_init_mmio(SYS_BUS_DEVICE(s), &s->mmio);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(s), 0, AMDVI_BASE_ADDR);\n\n    pci_setup_iommu(bus, amdvi_host_dma_iommu, s);\n\n    s->devid = object_property_get_int(OBJECT(&s->pci), \"addr\", err);\n\n    msi_init(&s->pci.dev, 0, 1, true, false, err);\n\n    amdvi_init(s);\n\n}\n", "idx": 21969}
{"project": "qemu", "commit_id": "8f5d58ef2c92d7b82d9a6eeefd7c8854a183ba4a", "target": 1, "func": "virtio_crypto_check_cryptodev_is_used(Object *obj, const char *name,\n\n                                      Object *val, Error **errp)\n\n{\n\n    if (cryptodev_backend_is_used(CRYPTODEV_BACKEND(val))) {\n\n        char *path = object_get_canonical_path_component(val);\n\n        error_setg(errp,\n\n            \"can't use already used cryptodev backend: %s\", path);\n\n        g_free(path);\n\n    } else {\n\n        qdev_prop_allow_set_link_before_realize(obj, name, val, errp);\n\n    }\n\n}\n", "idx": 21970}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void unterminated_dict(void)\n\n{\n\n    QObject *obj = qobject_from_json(\"{'abc':32\", NULL);\n\n    g_assert(obj == NULL);\n\n}\n", "idx": 21973}
{"project": "qemu", "commit_id": "c572f23a3e7180dbeab5e86583e43ea2afed6271", "target": 1, "func": "static void v9fs_read(void *opaque)\n\n{\n\n    int32_t fid;\n\n    int64_t off;\n\n    ssize_t err = 0;\n\n    int32_t count = 0;\n\n    size_t offset = 7;\n\n    int32_t max_count;\n\n    V9fsFidState *fidp;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    pdu_unmarshal(pdu, offset, \"dqd\", &fid, &off, &max_count);\n\n\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        err = -EINVAL;\n\n        goto out_nofid;\n\n    }\n\n    if (fidp->fid_type == P9_FID_DIR) {\n\n\n\n        if (off == 0) {\n\n            v9fs_co_rewinddir(pdu, fidp);\n\n        }\n\n        count = v9fs_do_readdir_with_stat(pdu, fidp, max_count);\n\n        if (count < 0) {\n\n            err = count;\n\n            goto out;\n\n        }\n\n        err = offset;\n\n        err += pdu_marshal(pdu, offset, \"d\", count);\n\n        err += count;\n\n    } else if (fidp->fid_type == P9_FID_FILE) {\n\n        int32_t cnt;\n\n        int32_t len;\n\n        struct iovec *sg;\n\n        struct iovec iov[128]; /* FIXME: bad, bad, bad */\n\n\n\n        sg = iov;\n\n        pdu_marshal(pdu, offset + 4, \"v\", sg, &cnt);\n\n        sg = cap_sg(sg, max_count, &cnt);\n\n        do {\n\n            if (0) {\n\n                print_sg(sg, cnt);\n\n            }\n\n            /* Loop in case of EINTR */\n\n            do {\n\n                len = v9fs_co_preadv(pdu, fidp, sg, cnt, off);\n\n                if (len >= 0) {\n\n                    off   += len;\n\n                    count += len;\n\n                }\n\n            } while (len == -EINTR && !pdu->cancelled);\n\n            if (len < 0) {\n\n                /* IO error return the error */\n\n                err = len;\n\n                goto out;\n\n            }\n\n            sg = adjust_sg(sg, len, &cnt);\n\n        } while (count < max_count && len > 0);\n\n        err = offset;\n\n        err += pdu_marshal(pdu, offset, \"d\", count);\n\n        err += count;\n\n    } else if (fidp->fid_type == P9_FID_XATTR) {\n\n        err = v9fs_xattr_read(s, pdu, fidp, off, max_count);\n\n    } else {\n\n        err = -EINVAL;\n\n    }\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    trace_v9fs_read_return(pdu->tag, pdu->id, count, err);\n\n    complete_pdu(s, pdu, err);\n\n}", "idx": 21978}
{"project": "qemu", "commit_id": "e8ffaa311080a570a7c86d03c139c160cd11a831", "target": 1, "func": "int qio_channel_readv_all(QIOChannel *ioc,\n\n                          const struct iovec *iov,\n\n                          size_t niov,\n\n                          Error **errp)\n\n{\n\n    int ret = -1;\n\n    struct iovec *local_iov = g_new(struct iovec, niov);\n\n    struct iovec *local_iov_head = local_iov;\n\n    unsigned int nlocal_iov = niov;\n\n\n\n    nlocal_iov = iov_copy(local_iov, nlocal_iov,\n\n                          iov, niov,\n\n                          0, iov_size(iov, niov));\n\n\n\n    while (nlocal_iov > 0) {\n\n        ssize_t len;\n\n        len = qio_channel_readv(ioc, local_iov, nlocal_iov, errp);\n\n        if (len == QIO_CHANNEL_ERR_BLOCK) {\n\n            if (qemu_in_coroutine()) {\n\n                qio_channel_yield(ioc, G_IO_IN);\n\n            } else {\n\n                qio_channel_wait(ioc, G_IO_IN);\n\n            }\n\n            continue;\n\n        } else if (len < 0) {\n\n            goto cleanup;\n\n        } else if (len == 0) {\n\n            error_setg(errp,\n\n                       \"Unexpected end-of-file before all bytes were read\");\n\n            goto cleanup;\n\n        }\n\n\n\n        iov_discard_front(&local_iov, &nlocal_iov, len);\n\n    }\n\n\n\n    ret = 0;\n\n\n\n cleanup:\n\n    g_free(local_iov_head);\n\n    return ret;\n\n}\n", "idx": 21979}
{"project": "qemu", "commit_id": "640601c7cb1b6b41d3e1a435b986266c2b71e9bc", "target": 1, "func": "vu_queue_flush(VuDev *dev, VuVirtq *vq, unsigned int count)\n\n{\n\n    uint16_t old, new;\n\n\n\n    if (unlikely(dev->broken)) {\n\n        return;\n\n    }\n\n\n\n    /* Make sure buffer is written before we update index. */\n\n    smp_wmb();\n\n\n\n    old = vq->used_idx;\n\n    new = old + count;\n\n    vring_used_idx_set(dev, vq, new);\n\n    vq->inuse -= count;\n\n    if (unlikely((int16_t)(new - vq->signalled_used) < (uint16_t)(new - old))) {\n\n        vq->signalled_used_valid = false;\n\n    }\n\n}\n", "idx": 21980}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void qvirtio_pci_device_disable(QVirtioPCIDevice *d)\n\n{\n\n    qpci_iounmap(d->pdev, d->addr);\n\n    d->addr = NULL;\n\n}\n", "idx": 21981}
{"project": "qemu", "commit_id": "7c4228b4771acddcb8815079bc116007cec8a1ff", "target": 1, "func": "static void vfio_vga_quirk_teardown(VFIODevice *vdev)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < ARRAY_SIZE(vdev->vga.region); i++) {\n\n        while (!QLIST_EMPTY(&vdev->vga.region[i].quirks)) {\n\n            VFIOQuirk *quirk = QLIST_FIRST(&vdev->vga.region[i].quirks);\n\n            memory_region_del_subregion(&vdev->vga.region[i].mem, &quirk->mem);\n\n\n            QLIST_REMOVE(quirk, next);\n\n            g_free(quirk);\n\n        }\n\n    }\n\n}", "idx": 21982}
{"project": "qemu", "commit_id": "eeae2e7b52255dae0976a027b6e11274990c708d", "target": 1, "func": "static uint32_t pci_reg_read4(void *opaque, target_phys_addr_t addr)\n\n{\n\n    PPCE500PCIState *pci = opaque;\n\n    unsigned long win;\n\n    uint32_t value = 0;\n\n\n\n    win = addr & 0xfe0;\n\n\n\n    switch (win) {\n\n    case PPCE500_PCI_OW1:\n\n    case PPCE500_PCI_OW2:\n\n    case PPCE500_PCI_OW3:\n\n    case PPCE500_PCI_OW4:\n\n        switch (addr & 0xC) {\n\n        case PCI_POTAR:\n\n            value = pci->pob[(addr >> 5) & 0x7].potar;\n\n            break;\n\n        case PCI_POTEAR:\n\n            value = pci->pob[(addr >> 5) & 0x7].potear;\n\n            break;\n\n        case PCI_POWBAR:\n\n            value = pci->pob[(addr >> 5) & 0x7].powbar;\n\n            break;\n\n        case PCI_POWAR:\n\n            value = pci->pob[(addr >> 5) & 0x7].powar;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case PPCE500_PCI_IW3:\n\n    case PPCE500_PCI_IW2:\n\n    case PPCE500_PCI_IW1:\n\n        switch (addr & 0xC) {\n\n        case PCI_PITAR:\n\n            value = pci->pib[(addr >> 5) & 0x3].pitar;\n\n            break;\n\n        case PCI_PIWBAR:\n\n            value = pci->pib[(addr >> 5) & 0x3].piwbar;\n\n            break;\n\n        case PCI_PIWBEAR:\n\n            value = pci->pib[(addr >> 5) & 0x3].piwbear;\n\n            break;\n\n        case PCI_PIWAR:\n\n            value = pci->pib[(addr >> 5) & 0x3].piwar;\n\n            break;\n\n        default:\n\n            break;\n\n        };\n\n        break;\n\n\n\n    case PPCE500_PCI_GASKET_TIMR:\n\n        value = pci->gasket_time;\n\n        break;\n\n\n\n    default:\n\n        break;\n\n    }\n\n\n\n    pci_debug(\"%s: win:%lx(addr:\" TARGET_FMT_plx \") -> value:%x\\n\", __func__,\n\n              win, addr, value);\n\n    return value;\n\n}\n", "idx": 21990}
{"project": "qemu", "commit_id": "5bfb723f07fde2caafa90cb40c102a4e36dfea9e", "target": 1, "func": "static void win32_rearm_timer(struct qemu_alarm_timer *t,\n\n                              int64_t nearest_delta_ns)\n\n{\n\n    HANDLE hTimer = t->timer;\n\n    int nearest_delta_ms;\n\n    BOOLEAN success;\n\n\n\n    nearest_delta_ms = (nearest_delta_ns + 999999) / 1000000;\n\n    if (nearest_delta_ms < 1) {\n\n        nearest_delta_ms = 1;\n\n    }\n\n    success = ChangeTimerQueueTimer(NULL,\n\n                                    hTimer,\n\n                                    nearest_delta_ms,\n\n                                    3600000);\n\n\n\n    if (!success) {\n\n        fprintf(stderr, \"Failed to rearm win32 alarm timer: %ld\\n\",\n\n                GetLastError());\n\n        exit(-1);\n\n    }\n\n\n\n}\n", "idx": 21991}
{"project": "qemu", "commit_id": "240ce26a0533a6e5ee472789fbfbd9f7f939197e", "target": 1, "func": "static int decode_extended_mips16_opc (CPUMIPSState *env, DisasContext *ctx,\n\n                                       int *is_branch)\n\n{\n\n    int extend = cpu_lduw_code(env, ctx->pc + 2);\n\n    int op, rx, ry, funct, sa;\n\n    int16_t imm, offset;\n\n\n\n    ctx->opcode = (ctx->opcode << 16) | extend;\n\n    op = (ctx->opcode >> 11) & 0x1f;\n\n    sa = (ctx->opcode >> 22) & 0x1f;\n\n    funct = (ctx->opcode >> 8) & 0x7;\n\n    rx = xlat((ctx->opcode >> 8) & 0x7);\n\n    ry = xlat((ctx->opcode >> 5) & 0x7);\n\n    offset = imm = (int16_t) (((ctx->opcode >> 16) & 0x1f) << 11\n\n                              | ((ctx->opcode >> 21) & 0x3f) << 5\n\n                              | (ctx->opcode & 0x1f));\n\n\n\n    /* The extended opcodes cleverly reuse the opcodes from their 16-bit\n\n       counterparts.  */\n\n    switch (op) {\n\n    case M16_OPC_ADDIUSP:\n\n        gen_arith_imm(ctx, OPC_ADDIU, rx, 29, imm);\n\n        break;\n\n    case M16_OPC_ADDIUPC:\n\n        gen_addiupc(ctx, rx, imm, 0, 1);\n\n        break;\n\n    case M16_OPC_B:\n\n        gen_compute_branch(ctx, OPC_BEQ, 4, 0, 0, offset << 1);\n\n        /* No delay slot, so just process as a normal instruction */\n\n        break;\n\n    case M16_OPC_BEQZ:\n\n        gen_compute_branch(ctx, OPC_BEQ, 4, rx, 0, offset << 1);\n\n        /* No delay slot, so just process as a normal instruction */\n\n        break;\n\n    case M16_OPC_BNEQZ:\n\n        gen_compute_branch(ctx, OPC_BNE, 4, rx, 0, offset << 1);\n\n        /* No delay slot, so just process as a normal instruction */\n\n        break;\n\n    case M16_OPC_SHIFT:\n\n        switch (ctx->opcode & 0x3) {\n\n        case 0x0:\n\n            gen_shift_imm(ctx, OPC_SLL, rx, ry, sa);\n\n            break;\n\n        case 0x1:\n\n#if defined(TARGET_MIPS64)\n\n            check_mips_64(ctx);\n\n            gen_shift_imm(ctx, OPC_DSLL, rx, ry, sa);\n\n#else\n\n            generate_exception(ctx, EXCP_RI);\n\n#endif\n\n            break;\n\n        case 0x2:\n\n            gen_shift_imm(ctx, OPC_SRL, rx, ry, sa);\n\n            break;\n\n        case 0x3:\n\n            gen_shift_imm(ctx, OPC_SRA, rx, ry, sa);\n\n            break;\n\n        }\n\n        break;\n\n#if defined(TARGET_MIPS64)\n\n    case M16_OPC_LD:\n\n            check_mips_64(ctx);\n\n        gen_ld(ctx, OPC_LD, ry, rx, offset);\n\n        break;\n\n#endif\n\n    case M16_OPC_RRIA:\n\n        imm = ctx->opcode & 0xf;\n\n        imm = imm | ((ctx->opcode >> 20) & 0x7f) << 4;\n\n        imm = imm | ((ctx->opcode >> 16) & 0xf) << 11;\n\n        imm = (int16_t) (imm << 1) >> 1;\n\n        if ((ctx->opcode >> 4) & 0x1) {\n\n#if defined(TARGET_MIPS64)\n\n            check_mips_64(ctx);\n\n            gen_arith_imm(ctx, OPC_DADDIU, ry, rx, imm);\n\n#else\n\n            generate_exception(ctx, EXCP_RI);\n\n#endif\n\n        } else {\n\n            gen_arith_imm(ctx, OPC_ADDIU, ry, rx, imm);\n\n        }\n\n        break;\n\n    case M16_OPC_ADDIU8:\n\n        gen_arith_imm(ctx, OPC_ADDIU, rx, rx, imm);\n\n        break;\n\n    case M16_OPC_SLTI:\n\n        gen_slt_imm(ctx, OPC_SLTI, 24, rx, imm);\n\n        break;\n\n    case M16_OPC_SLTIU:\n\n        gen_slt_imm(ctx, OPC_SLTIU, 24, rx, imm);\n\n        break;\n\n    case M16_OPC_I8:\n\n        switch (funct) {\n\n        case I8_BTEQZ:\n\n            gen_compute_branch(ctx, OPC_BEQ, 4, 24, 0, offset << 1);\n\n            break;\n\n        case I8_BTNEZ:\n\n            gen_compute_branch(ctx, OPC_BNE, 4, 24, 0, offset << 1);\n\n            break;\n\n        case I8_SWRASP:\n\n            gen_st(ctx, OPC_SW, 31, 29, imm);\n\n            break;\n\n        case I8_ADJSP:\n\n            gen_arith_imm(ctx, OPC_ADDIU, 29, 29, imm);\n\n            break;\n\n        case I8_SVRS:\n\n            {\n\n                int xsregs = (ctx->opcode >> 24) & 0x7;\n\n                int aregs = (ctx->opcode >> 16) & 0xf;\n\n                int do_ra = (ctx->opcode >> 6) & 0x1;\n\n                int do_s0 = (ctx->opcode >> 5) & 0x1;\n\n                int do_s1 = (ctx->opcode >> 4) & 0x1;\n\n                int framesize = (((ctx->opcode >> 20) & 0xf) << 4\n\n                                 | (ctx->opcode & 0xf)) << 3;\n\n\n\n                if (ctx->opcode & (1 << 7)) {\n\n                    gen_mips16_save(ctx, xsregs, aregs,\n\n                                    do_ra, do_s0, do_s1,\n\n                                    framesize);\n\n                } else {\n\n                    gen_mips16_restore(ctx, xsregs, aregs,\n\n                                       do_ra, do_s0, do_s1,\n\n                                       framesize);\n\n                }\n\n            }\n\n            break;\n\n        default:\n\n            generate_exception(ctx, EXCP_RI);\n\n            break;\n\n        }\n\n        break;\n\n    case M16_OPC_LI:\n\n        tcg_gen_movi_tl(cpu_gpr[rx], (uint16_t) imm);\n\n        break;\n\n    case M16_OPC_CMPI:\n\n        tcg_gen_xori_tl(cpu_gpr[24], cpu_gpr[rx], (uint16_t) imm);\n\n        break;\n\n#if defined(TARGET_MIPS64)\n\n    case M16_OPC_SD:\n\n        gen_st(ctx, OPC_SD, ry, rx, offset);\n\n        break;\n\n#endif\n\n    case M16_OPC_LB:\n\n        gen_ld(ctx, OPC_LB, ry, rx, offset);\n\n        break;\n\n    case M16_OPC_LH:\n\n        gen_ld(ctx, OPC_LH, ry, rx, offset);\n\n        break;\n\n    case M16_OPC_LWSP:\n\n        gen_ld(ctx, OPC_LW, rx, 29, offset);\n\n        break;\n\n    case M16_OPC_LW:\n\n        gen_ld(ctx, OPC_LW, ry, rx, offset);\n\n        break;\n\n    case M16_OPC_LBU:\n\n        gen_ld(ctx, OPC_LBU, ry, rx, offset);\n\n        break;\n\n    case M16_OPC_LHU:\n\n        gen_ld(ctx, OPC_LHU, ry, rx, offset);\n\n        break;\n\n    case M16_OPC_LWPC:\n\n        gen_ld(ctx, OPC_LWPC, rx, 0, offset);\n\n        break;\n\n#if defined(TARGET_MIPS64)\n\n    case M16_OPC_LWU:\n\n        gen_ld(ctx, OPC_LWU, ry, rx, offset);\n\n        break;\n\n#endif\n\n    case M16_OPC_SB:\n\n        gen_st(ctx, OPC_SB, ry, rx, offset);\n\n        break;\n\n    case M16_OPC_SH:\n\n        gen_st(ctx, OPC_SH, ry, rx, offset);\n\n        break;\n\n    case M16_OPC_SWSP:\n\n        gen_st(ctx, OPC_SW, rx, 29, offset);\n\n        break;\n\n    case M16_OPC_SW:\n\n        gen_st(ctx, OPC_SW, ry, rx, offset);\n\n        break;\n\n#if defined(TARGET_MIPS64)\n\n    case M16_OPC_I64:\n\n        decode_i64_mips16(ctx, ry, funct, offset, 1);\n\n        break;\n\n#endif\n\n    default:\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    }\n\n\n\n    return 4;\n\n}\n", "idx": 21993}
{"project": "qemu", "commit_id": "6baebed7698a37a0ac5168faf26023426b0ac940", "target": 1, "func": "static void set_pixel_format(VncState *vs,\n\n                             int bits_per_pixel, int depth,\n\n                             int big_endian_flag, int true_color_flag,\n\n                             int red_max, int green_max, int blue_max,\n\n                             int red_shift, int green_shift, int blue_shift)\n\n{\n\n    if (!true_color_flag) {\n\n        vnc_client_error(vs);\n\n        return;\n\n    }\n\n\n\n    vs->clientds = vs->serverds;\n\n    vs->clientds.pf.rmax = red_max;\n\n    count_bits(vs->clientds.pf.rbits, red_max);\n\n    vs->clientds.pf.rshift = red_shift;\n\n    vs->clientds.pf.rmask = red_max << red_shift;\n\n    vs->clientds.pf.gmax = green_max;\n\n    count_bits(vs->clientds.pf.gbits, green_max);\n\n    vs->clientds.pf.gshift = green_shift;\n\n    vs->clientds.pf.gmask = green_max << green_shift;\n\n    vs->clientds.pf.bmax = blue_max;\n\n    count_bits(vs->clientds.pf.bbits, blue_max);\n\n    vs->clientds.pf.bshift = blue_shift;\n\n    vs->clientds.pf.bmask = blue_max << blue_shift;\n\n    vs->clientds.pf.bits_per_pixel = bits_per_pixel;\n\n    vs->clientds.pf.bytes_per_pixel = bits_per_pixel / 8;\n\n    vs->clientds.pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;\n\n    vs->clientds.flags = big_endian_flag ? QEMU_BIG_ENDIAN_FLAG : 0x00;\n\n\n\n    set_pixel_conversion(vs);\n\n\n\n    vga_hw_invalidate();\n\n    vga_hw_update();\n\n}\n", "idx": 21994}
{"project": "qemu", "commit_id": "7d91ddd25e3a4e5008a2ac16127d51a34fd56bf1", "target": 1, "func": "static void qemu_net_queue_append(NetQueue *queue,\n\n                                  NetClientState *sender,\n\n                                  unsigned flags,\n\n                                  const uint8_t *buf,\n\n                                  size_t size,\n\n                                  NetPacketSent *sent_cb)\n\n{\n\n    NetPacket *packet;\n\n\n\n    if (queue->nq_count >= queue->nq_maxlen && !sent_cb) {\n\n        return; /* drop if queue full and no callback */\n\n    }\n\n    packet = g_malloc(sizeof(NetPacket) + size);\n\n    packet->sender = sender;\n\n    packet->flags = flags;\n\n    packet->size = size;\n\n    packet->sent_cb = sent_cb;\n\n    memcpy(packet->data, buf, size);\n\n\n\n\n    QTAILQ_INSERT_TAIL(&queue->packets, packet, entry);\n\n}", "idx": 21995}
{"project": "qemu", "commit_id": "258dc7c96bb4b7ca71d5bee811e73933310e168c", "target": 1, "func": "int virtio_load(VirtIODevice *vdev, QEMUFile *f)\n\n{\n\n    int num, i, ret;\n\n    uint32_t features;\n\n    uint32_t supported_features =\n\n        vdev->binding->get_features(vdev->binding_opaque);\n\n\n\n\n    if (vdev->binding->load_config) {\n\n        ret = vdev->binding->load_config(vdev->binding_opaque, f);\n\n        if (ret)\n\n            return ret;\n\n    }\n\n\n\n    qemu_get_8s(f, &vdev->status);\n\n    qemu_get_8s(f, &vdev->isr);\n\n    qemu_get_be16s(f, &vdev->queue_sel);\n\n    qemu_get_be32s(f, &features);\n\n    if (features & ~supported_features) {\n\n        fprintf(stderr, \"Features 0x%x unsupported. Allowed features: 0x%x\\n\",\n\n                features, supported_features);\n\n        return -1;\n\n    }\n\n    if (vdev->set_features)\n\n        vdev->set_features(vdev, features);\n\n    vdev->guest_features = features;\n\n    vdev->config_len = qemu_get_be32(f);\n\n    qemu_get_buffer(f, vdev->config, vdev->config_len);\n\n\n\n    num = qemu_get_be32(f);\n\n\n\n    for (i = 0; i < num; i++) {\n\n        vdev->vq[i].vring.num = qemu_get_be32(f);\n\n        vdev->vq[i].pa = qemu_get_be64(f);\n\n        qemu_get_be16s(f, &vdev->vq[i].last_avail_idx);\n\n\n\n        if (vdev->vq[i].pa) {\n\n            virtqueue_init(&vdev->vq[i]);\n\n        }\n\n\tnum_heads = vring_avail_idx(&vdev->vq[i]) - vdev->vq[i].last_avail_idx;\n\n\t/* Check it isn't doing very strange things with descriptor numbers. */\n\n\tif (num_heads > vdev->vq[i].vring.num) {\n\n\t\tfprintf(stderr, \"VQ %d size 0x%x Guest index 0x%x \"\n\n                        \"inconsistent with Host index 0x%x: delta 0x%x\\n\",\n\n\t\t\ti, vdev->vq[i].vring.num,\n\n                        vring_avail_idx(&vdev->vq[i]),\n\n                        vdev->vq[i].last_avail_idx, num_heads);\n\n\t\treturn -1;\n\n\t}\n\n        if (vdev->binding->load_queue) {\n\n            ret = vdev->binding->load_queue(vdev->binding_opaque, i, f);\n\n            if (ret)\n\n                return ret;\n\n        }\n\n    }\n\n\n\n    virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);\n\n    return 0;\n\n}", "idx": 21996}
{"project": "qemu", "commit_id": "b57482d7a0fe669aeb6f0c3c3503d143b9db89dd", "target": 1, "func": "qcrypto_tls_session_check_credentials(QCryptoTLSSession *session,\n\n                                      Error **errp)\n\n{\n\n    if (object_dynamic_cast(OBJECT(session->creds),\n\n                            TYPE_QCRYPTO_TLS_CREDS_ANON)) {\n\n        return 0;\n\n    } else if (object_dynamic_cast(OBJECT(session->creds),\n\n                            TYPE_QCRYPTO_TLS_CREDS_X509)) {\n\n        if (session->creds->verifyPeer) {\n\n            return qcrypto_tls_session_check_certificate(session,\n\n                                                         errp);\n\n        } else {\n\n            return 0;\n\n        }\n\n    } else {\n\n        error_setg(errp, \"Unexpected credential type %s\",\n\n                   object_get_typename(OBJECT(session->creds)));\n\n        return -1;\n\n    }\n\n}\n", "idx": 21998}
{"project": "qemu", "commit_id": "6c2f9a15dfc8c18ba94defb0f819109902a817cb", "target": 1, "func": "static QObject *qmp_output_first(QmpOutputVisitor *qov)\n\n{\n\n    QStackEntry *e = QTAILQ_LAST(&qov->stack, QStack);\n\n\n\n    /* FIXME - find a better way to deal with NULL values */\n\n    if (!e) {\n\n        return NULL;\n\n    }\n\n\n\n    return e->value;\n\n}\n", "idx": 21999}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "PCIDevice *pci_create_simple(PCIBus *bus, int devfn, const char *name)\n\n{\n\n    PCIDevice *dev = pci_create(bus, devfn, name);\n\n    qdev_init(&dev->qdev);\n\n    return dev;\n\n}\n", "idx": 22001}
{"project": "qemu", "commit_id": "1108b2f8a939fb5778d384149e2f1b99062a72da", "target": 1, "func": "static int ioh3420_initfn(PCIDevice *d)\n\n{\n\n    PCIEPort *p = PCIE_PORT(d);\n\n    PCIESlot *s = PCIE_SLOT(d);\n\n    int rc;\n\n\n\n    pci_bridge_initfn(d, TYPE_PCIE_BUS);\n\n    pcie_port_init_reg(d);\n\n\n\n    rc = pci_bridge_ssvid_init(d, IOH_EP_SSVID_OFFSET,\n\n                               IOH_EP_SSVID_SVID, IOH_EP_SSVID_SSID);\n\n    if (rc < 0) {\n\n        goto err_bridge;\n\n    }\n\n\n\n    rc = msi_init(d, IOH_EP_MSI_OFFSET, IOH_EP_MSI_NR_VECTOR,\n\n                  IOH_EP_MSI_SUPPORTED_FLAGS & PCI_MSI_FLAGS_64BIT,\n\n                  IOH_EP_MSI_SUPPORTED_FLAGS & PCI_MSI_FLAGS_MASKBIT);\n\n    if (rc < 0) {\n\n        goto err_bridge;\n\n    }\n\n\n\n    rc = pcie_cap_init(d, IOH_EP_EXP_OFFSET, PCI_EXP_TYPE_ROOT_PORT, p->port);\n\n    if (rc < 0) {\n\n        goto err_msi;\n\n    }\n\n\n\n    pcie_cap_arifwd_init(d);\n\n    pcie_cap_deverr_init(d);\n\n    pcie_cap_slot_init(d, s->slot);\n\n    pcie_cap_root_init(d);\n\n\n\n    pcie_chassis_create(s->chassis);\n\n    rc = pcie_chassis_add_slot(s);\n\n    if (rc < 0) {\n\n        goto err_pcie_cap;\n\n    }\n\n\n\n    rc = pcie_aer_init(d, IOH_EP_AER_OFFSET, PCI_ERR_SIZEOF);\n\n    if (rc < 0) {\n\n        goto err;\n\n    }\n\n    pcie_aer_root_init(d);\n\n    ioh3420_aer_vector_update(d);\n\n\n\n    return 0;\n\n\n\nerr:\n\n    pcie_chassis_del_slot(s);\n\nerr_pcie_cap:\n\n    pcie_cap_exit(d);\n\nerr_msi:\n\n    msi_uninit(d);\n\nerr_bridge:\n\n    pci_bridge_exitfn(d);\n\n    return rc;\n\n}\n", "idx": 22002}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(test_ctr)\n\n{\n\n    T0 = regs->ctr;\n\n    RETURN();\n\n}\n", "idx": 22004}
{"project": "qemu", "commit_id": "07caea315a85ebfe90851f9c2e4ef3fdd24117b5", "target": 1, "func": "static void ppc_heathrow_init (ram_addr_t ram_size,\n\n                               const char *boot_device,\n\n                               const char *kernel_filename,\n\n                               const char *kernel_cmdline,\n\n                               const char *initrd_filename,\n\n                               const char *cpu_model)\n\n{\n\n    CPUState *env = NULL, *envs[MAX_CPUS];\n\n    char *filename;\n\n    qemu_irq *pic, **heathrow_irqs;\n\n    int linux_boot, i;\n\n    ram_addr_t ram_offset, bios_offset, vga_bios_offset;\n\n    uint32_t kernel_base, initrd_base;\n\n    int32_t kernel_size, initrd_size;\n\n    PCIBus *pci_bus;\n\n    MacIONVRAMState *nvr;\n\n    int vga_bios_size, bios_size;\n\n    int pic_mem_index, nvram_mem_index, dbdma_mem_index, cuda_mem_index;\n\n    int escc_mem_index, ide_mem_index[2];\n\n    uint16_t ppc_boot_device;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    void *fw_cfg;\n\n    void *dbdma;\n\n    uint8_t *vga_bios_ptr;\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL)\n\n        cpu_model = \"G3\";\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        /* Set time-base frequency to 16.6 Mhz */\n\n        cpu_ppc_tb_init(env,  16600000UL);\n\n        env->osi_call = vga_osi_call;\n\n        qemu_register_reset(&cpu_ppc_reset, env);\n\n        envs[i] = env;\n\n    }\n\n\n\n    /* allocate RAM */\n\n    if (ram_size > (2047 << 20)) {\n\n        fprintf(stderr,\n\n                \"qemu: Too much memory for this machine: %d MB, maximum 2047 MB\\n\",\n\n                ((unsigned int)ram_size / (1 << 20)));\n\n        exit(1);\n\n    }\n\n\n\n    ram_offset = qemu_ram_alloc(ram_size);\n\n    cpu_register_physical_memory(0, ram_size, ram_offset);\n\n\n\n    /* allocate and load BIOS */\n\n    bios_offset = qemu_ram_alloc(BIOS_SIZE);\n\n    if (bios_name == NULL)\n\n        bios_name = PROM_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    cpu_register_physical_memory(PROM_ADDR, BIOS_SIZE, bios_offset | IO_MEM_ROM);\n\n\n\n    /* Load OpenBIOS (ELF) */\n\n    if (filename) {\n\n        bios_size = load_elf(filename, 0, NULL, NULL, NULL,\n\n                               1, ELF_MACHINE, 0);\n\n        qemu_free(filename);\n\n    } else {\n\n        bios_size = -1;\n\n    }\n\n    if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n        hw_error(\"qemu: could not load PowerPC bios '%s'\\n\", bios_name);\n\n        exit(1);\n\n    }\n\n\n\n    /* allocate and load VGA BIOS */\n\n    vga_bios_offset = qemu_ram_alloc(VGA_BIOS_SIZE);\n\n    vga_bios_ptr = qemu_get_ram_ptr(vga_bios_offset);\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, VGABIOS_FILENAME);\n\n    if (filename) {\n\n        vga_bios_size = load_image(filename, vga_bios_ptr + 8);\n\n        qemu_free(filename);\n\n    } else {\n\n        vga_bios_size = -1;\n\n    }\n\n    if (vga_bios_size < 0) {\n\n        /* if no bios is present, we can still work */\n\n        fprintf(stderr, \"qemu: warning: could not load VGA bios '%s'\\n\",\n\n                VGABIOS_FILENAME);\n\n        vga_bios_size = 0;\n\n    } else {\n\n        /* set a specific header (XXX: find real Apple format for NDRV\n\n           drivers) */\n\n        vga_bios_ptr[0] = 'N';\n\n        vga_bios_ptr[1] = 'D';\n\n        vga_bios_ptr[2] = 'R';\n\n        vga_bios_ptr[3] = 'V';\n\n        cpu_to_be32w((uint32_t *)(vga_bios_ptr + 4), vga_bios_size);\n\n        vga_bios_size += 8;\n\n\n\n        /* Round to page boundary */\n\n        vga_bios_size = (vga_bios_size + TARGET_PAGE_SIZE - 1) &\n\n            TARGET_PAGE_MASK;\n\n    }\n\n\n\n    if (linux_boot) {\n\n        uint64_t lowaddr = 0;\n\n        int bswap_needed;\n\n\n\n#ifdef BSWAP_NEEDED\n\n        bswap_needed = 1;\n\n#else\n\n        bswap_needed = 0;\n\n#endif\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n        /* Now we can load the kernel. The first step tries to load the kernel\n\n           supposing PhysAddr = 0x00000000. If that was wrong the kernel is\n\n           loaded again, the new PhysAddr being computed from lowaddr. */\n\n        kernel_size = load_elf(kernel_filename, kernel_base, NULL, &lowaddr, NULL,\n\n                               1, ELF_MACHINE, 0);\n\n        if (kernel_size > 0 && lowaddr != KERNEL_LOAD_ADDR) {\n\n            kernel_size = load_elf(kernel_filename, (2 * kernel_base) - lowaddr,\n\n                                   NULL, NULL, NULL, 1, ELF_MACHINE, 0);\n\n        }\n\n        if (kernel_size < 0)\n\n            kernel_size = load_aout(kernel_filename, kernel_base,\n\n                                    ram_size - kernel_base, bswap_needed,\n\n                                    TARGET_PAGE_SIZE);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              kernel_base,\n\n                                              ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            hw_error(\"qemu: could not load kernel '%s'\\n\",\n\n                      kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                hw_error(\"qemu: could not load initial ram disk '%s'\\n\",\n\n                         initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n        ppc_boot_device = 'm';\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n        ppc_boot_device = '\\0';\n\n        for (i = 0; boot_device[i] != '\\0'; i++) {\n\n            /* TOFIX: for now, the second IDE channel is not properly\n\n             *        used by OHW. The Mac floppy disk are not emulated.\n\n             *        For now, OHW cannot boot from the network.\n\n             */\n\n#if 0\n\n            if (boot_device[i] >= 'a' && boot_device[i] <= 'f') {\n\n                ppc_boot_device = boot_device[i];\n\n                break;\n\n            }\n\n#else\n\n            if (boot_device[i] >= 'c' && boot_device[i] <= 'd') {\n\n                ppc_boot_device = boot_device[i];\n\n                break;\n\n            }\n\n#endif\n\n        }\n\n        if (ppc_boot_device == '\\0') {\n\n            fprintf(stderr, \"No valid boot device for G3 Beige machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    isa_mem_base = 0x80000000;\n\n\n\n    /* Register 2 MB of ISA IO space */\n\n    isa_mmio_init(0xfe000000, 0x00200000);\n\n\n\n    /* XXX: we register only 1 output pin for heathrow PIC */\n\n    heathrow_irqs = qemu_mallocz(smp_cpus * sizeof(qemu_irq *));\n\n    heathrow_irqs[0] =\n\n        qemu_mallocz(smp_cpus * sizeof(qemu_irq) * 1);\n\n    /* Connect the heathrow PIC outputs to the 6xx bus */\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        switch (PPC_INPUT(env)) {\n\n        case PPC_FLAGS_INPUT_6xx:\n\n            heathrow_irqs[i] = heathrow_irqs[0] + (i * 1);\n\n            heathrow_irqs[i][0] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];\n\n            break;\n\n        default:\n\n            hw_error(\"Bus model not supported on OldWorld Mac machine\\n\");\n\n        }\n\n    }\n\n\n\n    /* init basic PC hardware */\n\n    if (PPC_INPUT(env) != PPC_FLAGS_INPUT_6xx) {\n\n        hw_error(\"Only 6xx bus is supported on heathrow machine\\n\");\n\n    }\n\n    pic = heathrow_pic_init(&pic_mem_index, 1, heathrow_irqs);\n\n    pci_bus = pci_grackle_init(0xfec00000, pic);\n\n    pci_vga_init(pci_bus, vga_bios_offset, vga_bios_size);\n\n\n\n    escc_mem_index = escc_init(0x80013000, pic[0x0f], pic[0x10], serial_hds[0],\n\n                               serial_hds[1], ESCC_CLOCK, 4);\n\n\n\n    for(i = 0; i < nb_nics; i++)\n\n        pci_nic_init(&nd_table[i], \"ne2k_pci\", NULL);\n\n\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* First IDE channel is a MAC IDE on the MacIO bus */\n\n    hd[0] = drive_get(IF_IDE, 0, 0);\n\n    hd[1] = drive_get(IF_IDE, 0, 1);\n\n    dbdma = DBDMA_init(&dbdma_mem_index);\n\n    ide_mem_index[0] = -1;\n\n    ide_mem_index[1] = pmac_ide_init(hd, pic[0x0D], dbdma, 0x16, pic[0x02]);\n\n\n\n    /* Second IDE channel is a CMD646 on the PCI bus */\n\n    hd[0] = drive_get(IF_IDE, 1, 0);\n\n    hd[1] = drive_get(IF_IDE, 1, 1);\n\n    hd[3] = hd[2] = NULL;\n\n    pci_cmd646_ide_init(pci_bus, hd, 0);\n\n\n\n    /* cuda also initialize ADB */\n\n    cuda_init(&cuda_mem_index, pic[0x12]);\n\n\n\n    adb_kbd_init(&adb_bus);\n\n    adb_mouse_init(&adb_bus);\n\n\n\n    nvr = macio_nvram_init(&nvram_mem_index, 0x2000, 4);\n\n    pmac_format_nvram_partition(nvr, 0x2000);\n\n\n\n    macio_init(pci_bus, PCI_DEVICE_ID_APPLE_343S1201, 1, pic_mem_index,\n\n               dbdma_mem_index, cuda_mem_index, nvr, 2, ide_mem_index,\n\n               escc_mem_index);\n\n\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, -1);\n\n    }\n\n\n\n    if (graphic_depth != 15 && graphic_depth != 32 && graphic_depth != 8)\n\n        graphic_depth = 15;\n\n\n\n    /* No PCI init: the BIOS will do it */\n\n\n\n    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, ARCH_HEATHROW);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, kernel_base);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\n\n    if (kernel_cmdline) {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);\n\n        pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);\n\n    }\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, initrd_base);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, ppc_boot_device);\n\n\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_WIDTH, graphic_width);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_HEIGHT, graphic_height);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_DEPTH, graphic_depth);\n\n\n\n    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);\n\n}\n", "idx": 22005}
{"project": "qemu", "commit_id": "33bef0b9948b85000221d32c758d9d4a9276aaaf", "target": 1, "func": "bool timerlist_expired(QEMUTimerList *timer_list)\n\n{\n\n    int64_t expire_time;\n\n\n\n    if (!atomic_read(&timer_list->active_timers)) {\n\n        return false;\n\n    }\n\n\n\n    qemu_mutex_lock(&timer_list->active_timers_lock);\n\n    if (!timer_list->active_timers) {\n\n        qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n        return false;\n\n    }\n\n    expire_time = timer_list->active_timers->expire_time;\n\n    qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n\n\n    return expire_time < qemu_clock_get_ns(timer_list->clock->type);\n\n}\n", "idx": 22006}
{"project": "qemu", "commit_id": "58ac321135af890b503ebe56d0d00e184779918f", "target": 1, "func": "void ide_sector_read(IDEState *s)\n{\n    int64_t sector_num;\n    int n;\n    s->status = READY_STAT | SEEK_STAT;\n    s->error = 0; /* not needed by IDE spec, but needed by Windows */\n    sector_num = ide_get_sector(s);\n    n = s->nsector;\n    if (n == 0) {\n        ide_transfer_stop(s);\n    s->status |= BUSY_STAT;\n    if (n > s->req_nb_sectors) {\n        n = s->req_nb_sectors;\n#if defined(DEBUG_IDE)\n    printf(\"sector=%\" PRId64 \"\\n\", sector_num);\n#endif\n    s->iov.iov_base = s->io_buffer;\n    s->iov.iov_len  = n * BDRV_SECTOR_SIZE;\n    qemu_iovec_init_external(&s->qiov, &s->iov, 1);\n    bdrv_acct_start(s->bs, &s->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_READ);\n    s->pio_aiocb = bdrv_aio_readv(s->bs, sector_num, &s->qiov, n,\n                                  ide_sector_read_cb, s);", "idx": 22010}
{"project": "qemu", "commit_id": "7839ff593be03a7de3c6760e0b50c565ea751d36", "target": 1, "func": "static void pc_compat_1_5(QEMUMachineInitArgs *args)\n\n{\n\n    pc_compat_1_6(args);\n\n    has_pvpanic = true;\n\n}\n", "idx": 22011}
{"project": "qemu", "commit_id": "9fbf0fa81fca8f527669dd4fa72662d66e7d6329", "target": 1, "func": "static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist,\n\n                                AHCICmdHdr *cmd, int64_t limit, int32_t offset)\n\n{\n\n    uint16_t opts = le16_to_cpu(cmd->opts);\n\n    uint16_t prdtl = le16_to_cpu(cmd->prdtl);\n\n    uint64_t cfis_addr = le64_to_cpu(cmd->tbl_addr);\n\n    uint64_t prdt_addr = cfis_addr + 0x80;\n\n    dma_addr_t prdt_len = (prdtl * sizeof(AHCI_SG));\n\n    dma_addr_t real_prdt_len = prdt_len;\n\n    uint8_t *prdt;\n\n    int i;\n\n    int r = 0;\n\n    uint64_t sum = 0;\n\n    int off_idx = -1;\n\n    int64_t off_pos = -1;\n\n    int tbl_entry_size;\n\n    IDEBus *bus = &ad->port;\n\n    BusState *qbus = BUS(bus);\n\n\n\n    /*\n\n     * Note: AHCI PRDT can describe up to 256GiB. SATA/ATA only support\n\n     * transactions of up to 32MiB as of ATA8-ACS3 rev 1b, assuming a\n\n     * 512 byte sector size. We limit the PRDT in this implementation to\n\n     * a reasonably large 2GiB, which can accommodate the maximum transfer\n\n     * request for sector sizes up to 32K.\n\n     */\n\n\n\n    if (!prdtl) {\n\n        DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);\n\n        return -1;\n\n    }\n\n\n\n    /* map PRDT */\n\n    if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,\n\n                                DMA_DIRECTION_TO_DEVICE))){\n\n        DPRINTF(ad->port_no, \"map failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (prdt_len < real_prdt_len) {\n\n        DPRINTF(ad->port_no, \"mapped less than expected\\n\");\n\n        r = -1;\n\n        goto out;\n\n    }\n\n\n\n    /* Get entries in the PRDT, init a qemu sglist accordingly */\n\n    if (prdtl > 0) {\n\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n\n        sum = 0;\n\n        for (i = 0; i < prdtl; i++) {\n\n            tbl_entry_size = prdt_tbl_entry_size(&tbl[i]);\n\n            if (offset < (sum + tbl_entry_size)) {\n\n                off_idx = i;\n\n                off_pos = offset - sum;\n\n                break;\n\n            }\n\n            sum += tbl_entry_size;\n\n        }\n\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n\n                            \"off_idx: %d, off_pos: %\"PRId64\"\\n\",\n\n                            __func__, off_idx, off_pos);\n\n            r = -1;\n\n            goto out;\n\n        }\n\n\n\n        qemu_sglist_init(sglist, qbus->parent, (prdtl - off_idx),\n\n                         ad->hba->as);\n\n        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr) + off_pos,\n\n                        MIN(prdt_tbl_entry_size(&tbl[off_idx]) - off_pos,\n\n                            limit));\n\n\n\n        for (i = off_idx + 1; i < prdtl && sglist->size < limit; i++) {\n\n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n\n                            MIN(prdt_tbl_entry_size(&tbl[i]),\n\n                                limit - sglist->size));\n\n            if (sglist->size > INT32_MAX) {\n\n                error_report(\"AHCI Physical Region Descriptor Table describes \"\n\n                             \"more than 2 GiB.\");\n\n                qemu_sglist_destroy(sglist);\n\n                r = -1;\n\n                goto out;\n\n            }\n\n        }\n\n    }\n\n\n\nout:\n\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n\n    return r;\n\n}\n", "idx": 22016}
{"project": "qemu", "commit_id": "2061c14c9bea67f8f1fc6bc7acb33c903a0586c1", "target": 1, "func": "static int handle_secondary_tcp_pkt(NetFilterState *nf,\n\n                                    Connection *conn,\n\n                                    Packet *pkt)\n\n{\n\n    struct tcphdr *tcp_pkt;\n\n\n\n    tcp_pkt = (struct tcphdr *)pkt->transport_header;\n\n\n\n    if (trace_event_get_state(TRACE_COLO_FILTER_REWRITER_DEBUG)) {\n\n        char *sdebug, *ddebug;\n\n        sdebug = strdup(inet_ntoa(pkt->ip->ip_src));\n\n        ddebug = strdup(inet_ntoa(pkt->ip->ip_dst));\n\n        trace_colo_filter_rewriter_pkt_info(__func__, sdebug, ddebug,\n\n                    ntohl(tcp_pkt->th_seq), ntohl(tcp_pkt->th_ack),\n\n                    tcp_pkt->th_flags);\n\n        trace_colo_filter_rewriter_conn_offset(conn->offset);\n\n        g_free(sdebug);\n\n        g_free(ddebug);\n\n    }\n\n\n\n    if (((tcp_pkt->th_flags & (TH_ACK | TH_SYN)) == (TH_ACK | TH_SYN))) {\n\n        /*\n\n         * save offset = secondary_seq and then\n\n         * in handle_primary_tcp_pkt make offset\n\n         * = secondary_seq - primary_seq\n\n         */\n\n        conn->offset = ntohl(tcp_pkt->th_seq);\n\n    }\n\n\n\n    if ((tcp_pkt->th_flags & (TH_ACK | TH_SYN)) == TH_ACK) {\n\n        /* handle packets to the primary from the secondary*/\n\n        tcp_pkt->th_seq = htonl(ntohl(tcp_pkt->th_seq) - conn->offset);\n\n\n\n        net_checksum_calculate((uint8_t *)pkt->data, pkt->size);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 22017}
{"project": "qemu", "commit_id": "372579427a5040a26dfee78464b50e2bdf27ef26", "target": 1, "func": "static inline bool cpu_handle_halt(CPUState *cpu)\n\n{\n\n    if (cpu->halted) {\n\n#if defined(TARGET_I386) && !defined(CONFIG_USER_ONLY)\n\n        if ((cpu->interrupt_request & CPU_INTERRUPT_POLL)\n\n            && replay_interrupt()) {\n\n            X86CPU *x86_cpu = X86_CPU(cpu);\n\n            qemu_mutex_lock_iothread();\n\n            apic_poll_irq(x86_cpu->apic_state);\n\n            cpu_reset_interrupt(cpu, CPU_INTERRUPT_POLL);\n\n            qemu_mutex_unlock_iothread();\n\n        }\n\n#endif\n\n        if (!cpu_has_work(cpu)) {\n\n            current_cpu = NULL;\n\n            return true;\n\n        }\n\n\n\n        cpu->halted = 0;\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 22018}
{"project": "qemu", "commit_id": "544a3731591f5d53e15f22de00ce5ac758d490b3", "target": 1, "func": "static void test_visitor_out_union_flat(TestOutputVisitorData *data,\n\n                                        const void *unused)\n\n{\n\n    QObject *arg;\n\n    QDict *qdict;\n\n\n\n    UserDefFlatUnion *tmp = g_malloc0(sizeof(UserDefFlatUnion));\n\n    tmp->enum1 = ENUM_ONE_VALUE1;\n\n    tmp->string = g_strdup(\"str\");\n\n    tmp->u.value1 = g_malloc0(sizeof(UserDefA));\n\n    tmp->integer = 41;\n\n    tmp->u.value1->boolean = true;\n\n\n\n    visit_type_UserDefFlatUnion(data->ov, NULL, &tmp, &error_abort);\n\n    arg = qmp_output_get_qobject(data->qov);\n\n\n\n    g_assert(qobject_type(arg) == QTYPE_QDICT);\n\n    qdict = qobject_to_qdict(arg);\n\n\n\n    g_assert_cmpstr(qdict_get_str(qdict, \"enum1\"), ==, \"value1\");\n\n    g_assert_cmpstr(qdict_get_str(qdict, \"string\"), ==, \"str\");\n\n    g_assert_cmpint(qdict_get_int(qdict, \"integer\"), ==, 41);\n\n    g_assert_cmpint(qdict_get_bool(qdict, \"boolean\"), ==, true);\n\n\n\n    qapi_free_UserDefFlatUnion(tmp);\n\n    QDECREF(qdict);\n\n}\n", "idx": 22021}
{"project": "qemu", "commit_id": "58ae2d1f037fae1d90eed4522053a85d79edfbec", "target": 1, "func": "static int bad_mode_switch(CPUARMState *env, int mode)\n\n{\n\n    /* Return true if it is not valid for us to switch to\n\n     * this CPU mode (ie all the UNPREDICTABLE cases in\n\n     * the ARM ARM CPSRWriteByInstr pseudocode).\n\n     */\n\n    switch (mode) {\n\n    case ARM_CPU_MODE_USR:\n\n    case ARM_CPU_MODE_SYS:\n\n    case ARM_CPU_MODE_SVC:\n\n    case ARM_CPU_MODE_ABT:\n\n    case ARM_CPU_MODE_UND:\n\n    case ARM_CPU_MODE_IRQ:\n\n    case ARM_CPU_MODE_FIQ:\n\n        /* Note that we don't implement the IMPDEF NSACR.RFR which in v7\n\n         * allows FIQ mode to be Secure-only. (In v8 this doesn't exist.)\n\n         */\n\n        return 0;\n\n    case ARM_CPU_MODE_HYP:\n\n        return !arm_feature(env, ARM_FEATURE_EL2)\n\n            || arm_current_el(env) < 2 || arm_is_secure(env);\n\n    case ARM_CPU_MODE_MON:\n\n        return !arm_is_secure(env);\n\n    default:\n\n        return 1;\n\n    }\n\n}\n", "idx": 22024}
{"project": "qemu", "commit_id": "7e8c49c56154ab5c45d4f07edf0c22728735da35", "target": 1, "func": "static void scsi_write_complete(void * opaque, int ret)\n\n{\n\n    SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint32_t n;\n\n\n\n    if (r->req.aiocb != NULL) {\n\n        r->req.aiocb = NULL;\n\n        bdrv_acct_done(s->qdev.conf.bs, &r->acct);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        if (scsi_handle_rw_error(r, -ret)) {\n\n            goto done;\n\n        }\n\n    }\n\n\n\n    n = r->qiov.size / 512;\n\n    r->sector += n;\n\n    r->sector_count -= n;\n\n    if (r->sector_count == 0) {\n\n        scsi_req_complete(&r->req, GOOD);\n\n    } else {\n\n        scsi_init_iovec(r, SCSI_DMA_BUF_SIZE);\n\n        DPRINTF(\"Write complete tag=0x%x more=%d\\n\", r->req.tag, r->qiov.size);\n\n        scsi_req_data(&r->req, r->qiov.size);\n\n    }\n\n\n\ndone:\n\n    if (!r->req.io_canceled) {\n\n        scsi_req_unref(&r->req);\n\n    }\n\n}\n", "idx": 22025}
{"project": "qemu", "commit_id": "7e09797c299712cafa7bc05dd57c1b13afcc6039", "target": 1, "func": "static void pmsav5_insn_ap_write(CPUARMState *env, const ARMCPRegInfo *ri,\n\n                                 uint64_t value)\n\n{\n\n    env->cp15.c5_insn = extended_mpu_ap_bits(value);\n\n}\n", "idx": 22027}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static void do_busid_cmd(ESPState *s, uint8_t *buf, uint8_t busid)\n\n{\n\n    int32_t datalen;\n\n    int lun;\n\n\n\n    DPRINTF(\"do_busid_cmd: busid 0x%x\\n\", busid);\n\n    lun = busid & 7;\n\n    datalen = s->current_dev->info->send_command(s->current_dev, 0, buf, lun);\n\n    s->ti_size = datalen;\n\n    if (datalen != 0) {\n\n        s->rregs[ESP_RSTAT] = STAT_TC;\n\n        s->dma_left = 0;\n\n        s->dma_counter = 0;\n\n        if (datalen > 0) {\n\n            s->rregs[ESP_RSTAT] |= STAT_DI;\n\n            s->current_dev->info->read_data(s->current_dev, 0);\n\n        } else {\n\n            s->rregs[ESP_RSTAT] |= STAT_DO;\n\n            s->current_dev->info->write_data(s->current_dev, 0);\n\n        }\n\n    }\n\n    s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;\n\n    s->rregs[ESP_RSEQ] = SEQ_CD;\n\n    esp_raise_irq(s);\n\n}\n", "idx": 22029}
{"project": "qemu", "commit_id": "a890643958f03aaa344290700093b280cb606c28", "target": 1, "func": "qht_entry_move(struct qht_bucket *to, int i, struct qht_bucket *from, int j)\n\n{\n\n    qht_debug_assert(!(to == from && i == j));\n\n    qht_debug_assert(to->pointers[i]);\n\n    qht_debug_assert(from->pointers[j]);\n\n\n\n    to->hashes[i] = from->hashes[j];\n\n    atomic_set(&to->pointers[i], from->pointers[j]);\n\n\n\n    from->hashes[j] = 0;\n\n    atomic_set(&from->pointers[j], NULL);\n\n}\n", "idx": 22030}
{"project": "qemu", "commit_id": "a70dadc7f1a3e96a7179c6c3a6ccd1a0ea65760a", "target": 1, "func": "static void tswap_siginfo(target_siginfo_t *tinfo,\n\n                          const target_siginfo_t *info)\n\n{\n\n    int sig = info->si_signo;\n\n    tinfo->si_signo = tswap32(sig);\n\n    tinfo->si_errno = tswap32(info->si_errno);\n\n    tinfo->si_code = tswap32(info->si_code);\n\n\n\n    if (sig == TARGET_SIGILL || sig == TARGET_SIGFPE || sig == TARGET_SIGSEGV\n\n        || sig == TARGET_SIGBUS || sig == TARGET_SIGTRAP) {\n\n        tinfo->_sifields._sigfault._addr\n\n            = tswapal(info->_sifields._sigfault._addr);\n\n    } else if (sig == TARGET_SIGIO) {\n\n        tinfo->_sifields._sigpoll._band\n\n            = tswap32(info->_sifields._sigpoll._band);\n\n        tinfo->_sifields._sigpoll._fd = tswap32(info->_sifields._sigpoll._fd);\n\n    } else if (sig == TARGET_SIGCHLD) {\n\n        tinfo->_sifields._sigchld._pid\n\n            = tswap32(info->_sifields._sigchld._pid);\n\n        tinfo->_sifields._sigchld._uid\n\n            = tswap32(info->_sifields._sigchld._uid);\n\n        tinfo->_sifields._sigchld._status\n\n            = tswap32(info->_sifields._sigchld._status);\n\n        tinfo->_sifields._sigchld._utime\n\n            = tswapal(info->_sifields._sigchld._utime);\n\n        tinfo->_sifields._sigchld._stime\n\n            = tswapal(info->_sifields._sigchld._stime);\n\n    } else if (sig >= TARGET_SIGRTMIN) {\n\n        tinfo->_sifields._rt._pid = tswap32(info->_sifields._rt._pid);\n\n        tinfo->_sifields._rt._uid = tswap32(info->_sifields._rt._uid);\n\n        tinfo->_sifields._rt._sigval.sival_ptr\n\n            = tswapal(info->_sifields._rt._sigval.sival_ptr);\n\n    }\n\n}\n", "idx": 22036}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "void axisdev88_init (ram_addr_t ram_size,\n\n                     const char *boot_device,\n\n                     const char *kernel_filename, const char *kernel_cmdline,\n\n                     const char *initrd_filename, const char *cpu_model)\n\n{\n\n    CPUState *env;\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    qemu_irq irq[30], nmi[2], *cpu_irq;\n\n    void *etraxfs_dmac;\n\n    struct etraxfs_dma_client *eth[2] = {NULL, NULL};\n\n    int kernel_size;\n\n    int i;\n\n    int nand_regs;\n\n    int gpio_regs;\n\n    ram_addr_t phys_ram;\n\n    ram_addr_t phys_intmem;\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"crisv32\";\n\n    }\n\n    env = cpu_init(cpu_model);\n\n    qemu_register_reset(main_cpu_reset, env);\n\n\n\n    /* allocate RAM */\n\n    phys_ram = qemu_ram_alloc(ram_size);\n\n    cpu_register_physical_memory(0x40000000, ram_size, phys_ram | IO_MEM_RAM);\n\n\n\n    /* The ETRAX-FS has 128Kb on chip ram, the docs refer to it as the \n\n       internal memory.  */\n\n    phys_intmem = qemu_ram_alloc(INTMEM_SIZE);\n\n    cpu_register_physical_memory(0x38000000, INTMEM_SIZE,\n\n                                 phys_intmem | IO_MEM_RAM);\n\n\n\n\n\n      /* Attach a NAND flash to CS1.  */\n\n    nand_state.nand = nand_init(NAND_MFR_STMICRO, 0x39);\n\n    nand_regs = cpu_register_io_memory(nand_read, nand_write, &nand_state);\n\n    cpu_register_physical_memory(0x10000000, 0x05000000, nand_regs);\n\n\n\n    gpio_state.nand = &nand_state;\n\n    gpio_regs = cpu_register_io_memory(gpio_read, gpio_write, &gpio_state);\n\n    cpu_register_physical_memory(0x3001a000, 0x5c, gpio_regs);\n\n\n\n\n\n    cpu_irq = cris_pic_init_cpu(env);\n\n    dev = qdev_create(NULL, \"etraxfs,pic\");\n\n    /* FIXME: Is there a proper way to signal vectors to the CPU core?  */\n\n    qdev_prop_set_ptr(dev, \"interrupt_vector\", &env->interrupt_vector);\n\n    qdev_init(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_mmio_map(s, 0, 0x3001c000);\n\n    sysbus_connect_irq(s, 0, cpu_irq[0]);\n\n    sysbus_connect_irq(s, 1, cpu_irq[1]);\n\n    for (i = 0; i < 30; i++) {\n\n        irq[i] = qdev_get_gpio_in(dev, i);\n\n    }\n\n    nmi[0] = qdev_get_gpio_in(dev, 30);\n\n    nmi[1] = qdev_get_gpio_in(dev, 31);\n\n\n\n    etraxfs_dmac = etraxfs_dmac_init(0x30000000, 10);\n\n    for (i = 0; i < 10; i++) {\n\n        /* On ETRAX, odd numbered channels are inputs.  */\n\n        etraxfs_dmac_connect(etraxfs_dmac, i, irq + 7 + i, i & 1);\n\n    }\n\n\n\n    /* Add the two ethernet blocks.  */\n\n    eth[0] = etraxfs_eth_init(&nd_table[0], 0x30034000, 1);\n\n    if (nb_nics > 1)\n\n        eth[1] = etraxfs_eth_init(&nd_table[1], 0x30036000, 2);\n\n\n\n    /* The DMA Connector block is missing, hardwire things for now.  */\n\n    etraxfs_dmac_connect_client(etraxfs_dmac, 0, eth[0]);\n\n    etraxfs_dmac_connect_client(etraxfs_dmac, 1, eth[0] + 1);\n\n    if (eth[1]) {\n\n        etraxfs_dmac_connect_client(etraxfs_dmac, 6, eth[1]);\n\n        etraxfs_dmac_connect_client(etraxfs_dmac, 7, eth[1] + 1);\n\n    }\n\n\n\n    /* 2 timers.  */\n\n    sysbus_create_varargs(\"etraxfs,timer\", 0x3001e000, irq[0x1b], nmi[1], NULL);\n\n    sysbus_create_varargs(\"etraxfs,timer\", 0x3005e000, irq[0x1b], nmi[1], NULL);\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        sysbus_create_simple(\"etraxfs,serial\", 0x30026000 + i * 0x2000,\n\n                             irq[0x14 + i]);\n\n    }\n\n\n\n    if (kernel_filename) {\n\n        uint64_t entry, high;\n\n        int kcmdline_len;\n\n\n\n        /* Boots a kernel elf binary, os/linux-2.6/vmlinux from the axis \n\n           devboard SDK.  */\n\n        kernel_size = load_elf(kernel_filename, -0x80000000LL,\n\n                               &entry, NULL, &high, 0, ELF_MACHINE, 0);\n\n        bootstrap_pc = entry;\n\n        if (kernel_size < 0) {\n\n            /* Takes a kimage from the axis devboard SDK.  */\n\n            kernel_size = load_image_targphys(kernel_filename, 0x40004000,\n\n                                              ram_size);\n\n            bootstrap_pc = 0x40004000;\n\n            env->regs[9] = 0x40004000 + kernel_size;\n\n        }\n\n        env->regs[8] = 0x56902387; /* RAM init magic.  */\n\n\n\n        if (kernel_cmdline && (kcmdline_len = strlen(kernel_cmdline))) {\n\n            if (kcmdline_len > 256) {\n\n                fprintf(stderr, \"Too long CRIS kernel cmdline (max 256)\\n\");\n\n                exit(1);\n\n            }\n\n            /* Let the kernel know we are modifying the cmdline.  */\n\n            env->regs[10] = 0x87109563;\n\n            env->regs[11] = 0x40000000;\n\n            pstrcpy_targphys(env->regs[11], 256, kernel_cmdline);\n\n        }\n\n    }\n\n    env->pc = bootstrap_pc;\n\n\n\n    printf (\"pc =%x\\n\", env->pc);\n\n    printf (\"ram size =%ld\\n\", ram_size);\n\n}\n", "idx": 22038}
{"project": "qemu", "commit_id": "aea2a33c73f28ecd8f10b242ecadddcc79c1c28b", "target": 1, "func": "void bdrv_eject(BlockDriverState *bs, int eject_flag)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    int ret;\n\n\n\n    if (!drv || !drv->bdrv_eject) {\n\n        ret = -ENOTSUP;\n\n    } else {\n\n        ret = drv->bdrv_eject(bs, eject_flag);\n\n    }\n\n    if (ret == -ENOTSUP) {\n\n        if (eject_flag)\n\n            bdrv_close(bs);\n\n    }\n\n}\n", "idx": 22042}
{"project": "qemu", "commit_id": "f2d089425d43735b5369f70f3a36b712440578e5", "target": 1, "func": "static MemTxResult memory_region_write_with_attrs_accessor(MemoryRegion *mr,\n\n                                                           hwaddr addr,\n\n                                                           uint64_t *value,\n\n                                                           unsigned size,\n\n                                                           unsigned shift,\n\n                                                           uint64_t mask,\n\n                                                           MemTxAttrs attrs)\n\n{\n\n    uint64_t tmp;\n\n\n\n    tmp = (*value >> shift) & mask;\n\n    if (mr->subpage) {\n\n        trace_memory_region_subpage_write(get_cpu_index(), mr, addr, tmp, size);\n\n\n\n\n\n\n    } else if (TRACE_MEMORY_REGION_OPS_WRITE_ENABLED) {\n\n        hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);\n\n        trace_memory_region_ops_write(get_cpu_index(), mr, abs_addr, tmp, size);\n\n    }\n\n    return mr->ops->write_with_attrs(mr->opaque, addr, tmp, size, attrs);\n\n}", "idx": 22044}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static TCGv neon_load_scratch(int scratch)\n\n{\n\n    TCGv tmp = new_tmp();\n\n    tcg_gen_ld_i32(tmp, cpu_env, offsetof(CPUARMState, vfp.scratch[scratch]));\n\n    return tmp;\n\n}\n", "idx": 22045}
{"project": "qemu", "commit_id": "07b026fd82d6cf11baf7d7c603c4f5f6070b35bf", "target": 1, "func": "static void usbredir_realize(USBDevice *udev, Error **errp)\n\n{\n\n    USBRedirDevice *dev = USB_REDIRECT(udev);\n\n    int i;\n\n\n\n    if (!qemu_chr_fe_get_driver(&dev->cs)) {\n\n        error_setg(errp, QERR_MISSING_PARAMETER, \"chardev\");\n\n        return;\n\n    }\n\n\n\n    if (dev->filter_str) {\n\n        i = usbredirfilter_string_to_rules(dev->filter_str, \":\", \"|\",\n\n                                           &dev->filter_rules,\n\n                                           &dev->filter_rules_count);\n\n        if (i) {\n\n            error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"filter\",\n\n                       \"a usb device filter string\");\n\n            return;\n\n        }\n\n    }\n\n\n\n    dev->chardev_close_bh = qemu_bh_new(usbredir_chardev_close_bh, dev);\n\n    dev->device_reject_bh = qemu_bh_new(usbredir_device_reject_bh, dev);\n\n    dev->attach_timer = timer_new_ms(QEMU_CLOCK_VIRTUAL, usbredir_do_attach, dev);\n\n\n\n    packet_id_queue_init(&dev->cancelled, dev, \"cancelled\");\n\n    packet_id_queue_init(&dev->already_in_flight, dev, \"already-in-flight\");\n\n    usbredir_init_endpoints(dev);\n\n\n\n    /* We'll do the attach once we receive the speed from the usb-host */\n\n    udev->auto_attach = 0;\n\n\n\n    /* Will be cleared during setup when we find conflicts */\n\n    dev->compatible_speedmask = USB_SPEED_MASK_FULL | USB_SPEED_MASK_HIGH;\n\n\n\n    /* Let the backend know we are ready */\n\n    qemu_chr_fe_set_handlers(&dev->cs, usbredir_chardev_can_read,\n\n                             usbredir_chardev_read, usbredir_chardev_event,\n\n                             dev, NULL, true);\n\n\n\n    qemu_add_vm_change_state_handler(usbredir_vm_state_change, dev);\n\n}\n", "idx": 22046}
{"project": "qemu", "commit_id": "1e9b65bb1bad51735cab6c861c29b592dccabf0e", "target": 1, "func": "void error_propagate(Error **dst_errp, Error *local_err)\n\n{\n\n    if (local_err && dst_errp == &error_abort) {\n\n        error_report_err(local_err);\n\n        abort();\n\n    } else if (dst_errp && !*dst_errp) {\n\n        *dst_errp = local_err;\n\n    } else if (local_err) {\n\n        error_free(local_err);\n\n    }\n\n}\n", "idx": 22047}
{"project": "qemu", "commit_id": "d63fb193e71644a073b77ff5ac6f1216f2f6cf6e", "target": 1, "func": "static void coroutine_fn v9fs_lcreate(void *opaque)\n\n{\n\n    int32_t dfid, flags, mode;\n\n    gid_t gid;\n\n    ssize_t err = 0;\n\n    ssize_t offset = 7;\n\n    V9fsString name;\n\n    V9fsFidState *fidp;\n\n    struct stat stbuf;\n\n    V9fsQID qid;\n\n    int32_t iounit;\n\n    V9fsPDU *pdu = opaque;\n\n\n\n    v9fs_string_init(&name);\n\n    err = pdu_unmarshal(pdu, offset, \"dsddd\", &dfid,\n\n                        &name, &flags, &mode, &gid);\n\n    if (err < 0) {\n\n        goto out_nofid;\n\n\n    trace_v9fs_lcreate(pdu->tag, pdu->id, dfid, flags, mode, gid);\n\n\n\n    if (name_is_illegal(name.data)) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n\n\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n\n        err = -EEXIST;\n\n        goto out_nofid;\n\n\n\n\n    fidp = get_fid(pdu, dfid);\n\n    if (fidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n\n\n\n\n\n\n\n    flags = get_dotl_openflags(pdu->s, flags);\n\n    err = v9fs_co_open2(pdu, fidp, &name, gid,\n\n                        flags | O_CREAT, mode, &stbuf);\n\n    if (err < 0) {\n\n\n\n    fidp->fid_type = P9_FID_FILE;\n\n    fidp->open_flags = flags;\n\n    if (flags & O_EXCL) {\n\n        /*\n\n         * We let the host file system do O_EXCL check\n\n         * We should not reclaim such fd\n\n         */\n\n        fidp->flags |= FID_NON_RECLAIMABLE;\n\n\n    iounit =  get_iounit(pdu, &fidp->path);\n\n    stat_to_qid(&stbuf, &qid);\n\n    err = pdu_marshal(pdu, offset, \"Qd\", &qid, iounit);\n\n    if (err < 0) {\n\n\n\n    err += offset;\n\n    trace_v9fs_lcreate_return(pdu->tag, pdu->id,\n\n                              qid.type, qid.version, qid.path, iounit);\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    pdu_complete(pdu, err);\n\n    v9fs_string_free(&name);\n", "idx": 22048}
{"project": "qemu", "commit_id": "f80256b7eebfbe20683b3a2b2720ad9991313761", "target": 1, "func": "static inline int array_ensure_allocated(array_t* array, int index)\n\n{\n\n    if((index + 1) * array->item_size > array->size) {\n\n        int new_size = (index + 32) * array->item_size;\n\n        array->pointer = g_realloc(array->pointer, new_size);\n\n        if (!array->pointer)\n\n            return -1;\n\n\n        array->size = new_size;\n\n        array->next = index + 1;\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 22050}
{"project": "qemu", "commit_id": "b5fc09ae52e3d19e01126715c998eb6587795b56", "target": 1, "func": "static inline TranslationBlock *tb_find_fast(void)\n\n{\n\n    TranslationBlock *tb;\n\n    target_ulong cs_base, pc;\n\n    uint64_t flags;\n\n\n\n    /* we record a subset of the CPU state. It will\n\n       always be the same before a given translated block\n\n       is executed. */\n\n#if defined(TARGET_I386)\n\n    flags = env->hflags;\n\n    flags |= (env->eflags & (IOPL_MASK | TF_MASK | VM_MASK));\n\n    flags |= env->intercept;\n\n    cs_base = env->segs[R_CS].base;\n\n    pc = cs_base + env->eip;\n\n#elif defined(TARGET_ARM)\n\n    flags = env->thumb | (env->vfp.vec_len << 1)\n\n            | (env->vfp.vec_stride << 4);\n\n    if ((env->uncached_cpsr & CPSR_M) != ARM_CPU_MODE_USR)\n\n        flags |= (1 << 6);\n\n    if (env->vfp.xregs[ARM_VFP_FPEXC] & (1 << 30))\n\n        flags |= (1 << 7);\n\n    flags |= (env->condexec_bits << 8);\n\n    cs_base = 0;\n\n    pc = env->regs[15];\n\n#elif defined(TARGET_SPARC)\n\n#ifdef TARGET_SPARC64\n\n    // Combined FPU enable bits . PRIV . DMMU enabled . IMMU enabled\n\n    flags = (((env->pstate & PS_PEF) >> 1) | ((env->fprs & FPRS_FEF) << 2))\n\n        | (env->pstate & PS_PRIV) | ((env->lsu & (DMMU_E | IMMU_E)) >> 2);\n\n#else\n\n    // FPU enable . Supervisor\n\n    flags = (env->psref << 4) | env->psrs;\n\n#endif\n\n    cs_base = env->npc;\n\n    pc = env->pc;\n\n#elif defined(TARGET_PPC)\n\n    flags = env->hflags;\n\n    cs_base = 0;\n\n    pc = env->nip;\n\n#elif defined(TARGET_MIPS)\n\n    flags = env->hflags & (MIPS_HFLAG_TMASK | MIPS_HFLAG_BMASK);\n\n    cs_base = 0;\n\n    pc = env->PC[env->current_tc];\n\n#elif defined(TARGET_M68K)\n\n    flags = (env->fpcr & M68K_FPCR_PREC)  /* Bit  6 */\n\n            | (env->sr & SR_S)            /* Bit  13 */\n\n            | ((env->macsr >> 4) & 0xf);  /* Bits 0-3 */\n\n    cs_base = 0;\n\n    pc = env->pc;\n\n#elif defined(TARGET_SH4)\n\n    flags = env->flags;\n\n    cs_base = 0;\n\n    pc = env->pc;\n\n#elif defined(TARGET_ALPHA)\n\n    flags = env->ps;\n\n    cs_base = 0;\n\n    pc = env->pc;\n\n#elif defined(TARGET_CRIS)\n\n    flags = env->pregs[PR_CCS] & (U_FLAG | X_FLAG);\n\n    cs_base = 0;\n\n    pc = env->pc;\n\n#else\n\n#error unsupported CPU\n\n#endif\n\n    tb = env->tb_jmp_cache[tb_jmp_cache_hash_func(pc)];\n\n    if (__builtin_expect(!tb || tb->pc != pc || tb->cs_base != cs_base ||\n\n                         tb->flags != flags, 0)) {\n\n        tb = tb_find_slow(pc, cs_base, flags);\n\n        /* Note: we do it here to avoid a gcc bug on Mac OS X when\n\n           doing it in tb_find_slow */\n\n        if (tb_invalidated_flag) {\n\n            /* as some TB could have been invalidated because\n\n               of memory exceptions while generating the code, we\n\n               must recompute the hash index here */\n\n            T0 = 0;\n\n        }\n\n    }\n\n    return tb;\n\n}\n", "idx": 22051}
{"project": "qemu", "commit_id": "062ba099e01ff1474be98c0a4f3da351efab5d9d", "target": 1, "func": "static void arm_cpu_reset(CPUState *s)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(s);\n\n    ARMCPUClass *acc = ARM_CPU_GET_CLASS(cpu);\n\n    CPUARMState *env = &cpu->env;\n\n\n\n    acc->parent_reset(s);\n\n\n\n    memset(env, 0, offsetof(CPUARMState, end_reset_fields));\n\n\n\n    g_hash_table_foreach(cpu->cp_regs, cp_reg_reset, cpu);\n\n    g_hash_table_foreach(cpu->cp_regs, cp_reg_check_reset, cpu);\n\n\n\n    env->vfp.xregs[ARM_VFP_FPSID] = cpu->reset_fpsid;\n\n    env->vfp.xregs[ARM_VFP_MVFR0] = cpu->mvfr0;\n\n    env->vfp.xregs[ARM_VFP_MVFR1] = cpu->mvfr1;\n\n    env->vfp.xregs[ARM_VFP_MVFR2] = cpu->mvfr2;\n\n\n\n    cpu->powered_off = cpu->start_powered_off;\n\n    s->halted = cpu->start_powered_off;\n\n\n\n    if (arm_feature(env, ARM_FEATURE_IWMMXT)) {\n\n        env->iwmmxt.cregs[ARM_IWMMXT_wCID] = 0x69051000 | 'Q';\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_AARCH64)) {\n\n        /* 64 bit CPUs always start in 64 bit mode */\n\n        env->aarch64 = 1;\n\n#if defined(CONFIG_USER_ONLY)\n\n        env->pstate = PSTATE_MODE_EL0t;\n\n        /* Userspace expects access to DC ZVA, CTL_EL0 and the cache ops */\n\n        env->cp15.sctlr_el[1] |= SCTLR_UCT | SCTLR_UCI | SCTLR_DZE;\n\n        /* and to the FP/Neon instructions */\n\n        env->cp15.cpacr_el1 = deposit64(env->cp15.cpacr_el1, 20, 2, 3);\n\n#else\n\n        /* Reset into the highest available EL */\n\n        if (arm_feature(env, ARM_FEATURE_EL3)) {\n\n            env->pstate = PSTATE_MODE_EL3h;\n\n        } else if (arm_feature(env, ARM_FEATURE_EL2)) {\n\n            env->pstate = PSTATE_MODE_EL2h;\n\n        } else {\n\n            env->pstate = PSTATE_MODE_EL1h;\n\n        }\n\n        env->pc = cpu->rvbar;\n\n#endif\n\n    } else {\n\n#if defined(CONFIG_USER_ONLY)\n\n        /* Userspace expects access to cp10 and cp11 for FP/Neon */\n\n        env->cp15.cpacr_el1 = deposit64(env->cp15.cpacr_el1, 20, 4, 0xf);\n\n#endif\n\n    }\n\n\n\n#if defined(CONFIG_USER_ONLY)\n\n    env->uncached_cpsr = ARM_CPU_MODE_USR;\n\n    /* For user mode we must enable access to coprocessors */\n\n    env->vfp.xregs[ARM_VFP_FPEXC] = 1 << 30;\n\n    if (arm_feature(env, ARM_FEATURE_IWMMXT)) {\n\n        env->cp15.c15_cpar = 3;\n\n    } else if (arm_feature(env, ARM_FEATURE_XSCALE)) {\n\n        env->cp15.c15_cpar = 1;\n\n    }\n\n#else\n\n    /* SVC mode with interrupts disabled.  */\n\n    env->uncached_cpsr = ARM_CPU_MODE_SVC;\n\n    env->daif = PSTATE_D | PSTATE_A | PSTATE_I | PSTATE_F;\n\n\n\n    if (arm_feature(env, ARM_FEATURE_M)) {\n\n        uint32_t initial_msp; /* Loaded from 0x0 */\n\n        uint32_t initial_pc; /* Loaded from 0x4 */\n\n        uint8_t *rom;\n\n\n\n        /* For M profile we store FAULTMASK and PRIMASK in the\n\n         * PSTATE F and I bits; these are both clear at reset.\n\n         */\n\n        env->daif &= ~(PSTATE_I | PSTATE_F);\n\n\n\n        /* The reset value of this bit is IMPDEF, but ARM recommends\n\n         * that it resets to 1, so QEMU always does that rather than making\n\n         * it dependent on CPU model.\n\n         */\n\n        env->v7m.ccr = R_V7M_CCR_STKALIGN_MASK;\n\n\n\n        /* Unlike A/R profile, M profile defines the reset LR value */\n\n        env->regs[14] = 0xffffffff;\n\n\n\n        /* Load the initial SP and PC from the vector table at address 0 */\n\n        rom = rom_ptr(0);\n\n        if (rom) {\n\n            /* Address zero is covered by ROM which hasn't yet been\n\n             * copied into physical memory.\n\n             */\n\n            initial_msp = ldl_p(rom);\n\n            initial_pc = ldl_p(rom + 4);\n\n        } else {\n\n            /* Address zero not covered by a ROM blob, or the ROM blob\n\n             * is in non-modifiable memory and this is a second reset after\n\n             * it got copied into memory. In the latter case, rom_ptr\n\n             * will return a NULL pointer and we should use ldl_phys instead.\n\n             */\n\n            initial_msp = ldl_phys(s->as, 0);\n\n            initial_pc = ldl_phys(s->as, 4);\n\n        }\n\n\n\n        env->regs[13] = initial_msp & 0xFFFFFFFC;\n\n        env->regs[15] = initial_pc & ~1;\n\n        env->thumb = initial_pc & 1;\n\n    }\n\n\n\n    /* AArch32 has a hard highvec setting of 0xFFFF0000.  If we are currently\n\n     * executing as AArch32 then check if highvecs are enabled and\n\n     * adjust the PC accordingly.\n\n     */\n\n    if (A32_BANKED_CURRENT_REG_GET(env, sctlr) & SCTLR_V) {\n\n        env->regs[15] = 0xFFFF0000;\n\n    }\n\n\n\n    env->vfp.xregs[ARM_VFP_FPEXC] = 0;\n\n#endif\n\n    set_flush_to_zero(1, &env->vfp.standard_fp_status);\n\n    set_flush_inputs_to_zero(1, &env->vfp.standard_fp_status);\n\n    set_default_nan_mode(1, &env->vfp.standard_fp_status);\n\n    set_float_detect_tininess(float_tininess_before_rounding,\n\n                              &env->vfp.fp_status);\n\n    set_float_detect_tininess(float_tininess_before_rounding,\n\n                              &env->vfp.standard_fp_status);\n\n#ifndef CONFIG_USER_ONLY\n\n    if (kvm_enabled()) {\n\n        kvm_arm_reset_vcpu(cpu);\n\n    }\n\n#endif\n\n\n\n    hw_breakpoint_update_all(cpu);\n\n    hw_watchpoint_update_all(cpu);\n\n}\n", "idx": 22052}
{"project": "qemu", "commit_id": "c3b08d0e05f381b0a02647038d454eecf51ae014", "target": 1, "func": "void tcg_add_target_add_op_defs(const TCGTargetOpDef *tdefs)\n\n{\n\n    TCGOpcode op;\n\n    TCGOpDef *def;\n\n    const char *ct_str;\n\n    int i, nb_args;\n\n\n\n    for(;;) {\n\n        if (tdefs->op == (TCGOpcode)-1)\n\n            break;\n\n        op = tdefs->op;\n\n        assert(op >= 0 && op < NB_OPS);\n\n        def = &tcg_op_defs[op];\n\n#if defined(CONFIG_DEBUG_TCG)\n\n        /* Duplicate entry in op definitions? */\n\n        assert(!def->used);\n\n        def->used = 1;\n\n#endif\n\n        nb_args = def->nb_iargs + def->nb_oargs;\n\n        for(i = 0; i < nb_args; i++) {\n\n            ct_str = tdefs->args_ct_str[i];\n\n            /* Incomplete TCGTargetOpDef entry? */\n\n            assert(ct_str != NULL);\n\n            tcg_regset_clear(def->args_ct[i].u.regs);\n\n            def->args_ct[i].ct = 0;\n\n            if (ct_str[0] >= '0' && ct_str[0] <= '9') {\n\n                int oarg;\n\n                oarg = ct_str[0] - '0';\n\n                assert(oarg < def->nb_oargs);\n\n                assert(def->args_ct[oarg].ct & TCG_CT_REG);\n\n                /* TCG_CT_ALIAS is for the output arguments. The input\n\n                   argument is tagged with TCG_CT_IALIAS. */\n\n                def->args_ct[i] = def->args_ct[oarg];\n\n                def->args_ct[oarg].ct = TCG_CT_ALIAS;\n\n                def->args_ct[oarg].alias_index = i;\n\n                def->args_ct[i].ct |= TCG_CT_IALIAS;\n\n                def->args_ct[i].alias_index = oarg;\n\n            } else {\n\n                for(;;) {\n\n                    if (*ct_str == '\\0')\n\n                        break;\n\n                    switch(*ct_str) {\n\n                    case 'i':\n\n                        def->args_ct[i].ct |= TCG_CT_CONST;\n\n                        ct_str++;\n\n                        break;\n\n                    default:\n\n                        if (target_parse_constraint(&def->args_ct[i], &ct_str) < 0) {\n\n                            fprintf(stderr, \"Invalid constraint '%s' for arg %d of operation '%s'\\n\",\n\n                                    ct_str, i, def->name);\n\n                            exit(1);\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        /* TCGTargetOpDef entry with too much information? */\n\n        assert(i == TCG_MAX_OP_ARGS || tdefs->args_ct_str[i] == NULL);\n\n\n\n        /* sort the constraints (XXX: this is just an heuristic) */\n\n        sort_constraints(def, 0, def->nb_oargs);\n\n        sort_constraints(def, def->nb_oargs, def->nb_iargs);\n\n\n\n#if 0\n\n        {\n\n            int i;\n\n\n\n            printf(\"%s: sorted=\", def->name);\n\n            for(i = 0; i < def->nb_oargs + def->nb_iargs; i++)\n\n                printf(\" %d\", def->sorted_args[i]);\n\n            printf(\"\\n\");\n\n        }\n\n#endif\n\n        tdefs++;\n\n    }\n\n\n\n#if defined(CONFIG_DEBUG_TCG)\n\n    i = 0;\n\n    for (op = 0; op < ARRAY_SIZE(tcg_op_defs); op++) {\n\n        if (op < INDEX_op_call || op == INDEX_op_debug_insn_start) {\n\n            /* Wrong entry in op definitions? */\n\n            if (tcg_op_defs[op].used) {\n\n                fprintf(stderr, \"Invalid op definition for %s\\n\",\n\n                        tcg_op_defs[op].name);\n\n                i = 1;\n\n            }\n\n        } else {\n\n            /* Missing entry in op definitions? */\n\n            if (!tcg_op_defs[op].used) {\n\n                fprintf(stderr, \"Missing op definition for %s\\n\",\n\n                        tcg_op_defs[op].name);\n\n                i = 1;\n\n            }\n\n        }\n\n    }\n\n    if (i == 1) {\n\n        tcg_abort();\n\n    }\n\n#endif\n\n}\n", "idx": 22053}
{"project": "qemu", "commit_id": "12de9a396acbc95e25c5d60ed097cc55777eaaed", "target": 1, "func": "static inline int _find_pte (mmu_ctx_t *ctx, int is_64b, int h, int rw)\n\n{\n\n    target_ulong base, pte0, pte1;\n\n    int i, good = -1;\n\n    int ret, r;\n\n\n\n    ret = -1; /* No entry found */\n\n    base = ctx->pg_addr[h];\n\n    for (i = 0; i < 8; i++) {\n\n#if defined(TARGET_PPC64)\n\n        if (is_64b) {\n\n            pte0 = ldq_phys(base + (i * 16));\n\n            pte1 =  ldq_phys(base + (i * 16) + 8);\n\n            r = pte64_check(ctx, pte0, pte1, h, rw);\n\n        } else\n\n#endif\n\n        {\n\n            pte0 = ldl_phys(base + (i * 8));\n\n            pte1 =  ldl_phys(base + (i * 8) + 4);\n\n            r = pte32_check(ctx, pte0, pte1, h, rw);\n\n        }\n\n#if defined (DEBUG_MMU)\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"Load pte from 0x\" ADDRX \" => 0x\" ADDRX\n\n                    \" 0x\" ADDRX \" %d %d %d 0x\" ADDRX \"\\n\",\n\n                    base + (i * 8), pte0, pte1,\n\n                    (int)(pte0 >> 31), h, (int)((pte0 >> 6) & 1), ctx->ptem);\n\n        }\n\n#endif\n\n        switch (r) {\n\n        case -3:\n\n            /* PTE inconsistency */\n\n            return -1;\n\n        case -2:\n\n            /* Access violation */\n\n            ret = -2;\n\n            good = i;\n\n            break;\n\n        case -1:\n\n        default:\n\n            /* No PTE match */\n\n            break;\n\n        case 0:\n\n            /* access granted */\n\n            /* XXX: we should go on looping to check all PTEs consistency\n\n             *      but if we can speed-up the whole thing as the\n\n             *      result would be undefined if PTEs are not consistent.\n\n             */\n\n            ret = 0;\n\n            good = i;\n\n            goto done;\n\n        }\n\n    }\n\n    if (good != -1) {\n\n    done:\n\n#if defined (DEBUG_MMU)\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"found PTE at addr 0x\" PADDRX \" prot=0x%01x \"\n\n                    \"ret=%d\\n\",\n\n                    ctx->raddr, ctx->prot, ret);\n\n        }\n\n#endif\n\n        /* Update page flags */\n\n        pte1 = ctx->raddr;\n\n        if (pte_update_flags(ctx, &pte1, ret, rw) == 1) {\n\n#if defined(TARGET_PPC64)\n\n            if (is_64b) {\n\n                stq_phys_notdirty(base + (good * 16) + 8, pte1);\n\n            } else\n\n#endif\n\n            {\n\n                stl_phys_notdirty(base + (good * 8) + 4, pte1);\n\n            }\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 22055}
{"project": "qemu", "commit_id": "94e7340b5db8bce7866e44e700ffa8fd26585c7e", "target": 1, "func": "static int nbd_send_reply(int csock, struct nbd_reply *reply)\n\n{\n\n    uint8_t buf[4 + 4 + 8];\n\n\n\n    /* Reply\n\n       [ 0 ..  3]    magic   (NBD_REPLY_MAGIC)\n\n       [ 4 ..  7]    error   (0 == no error)\n\n       [ 7 .. 15]    handle\n\n     */\n\n    cpu_to_be32w((uint32_t*)buf, NBD_REPLY_MAGIC);\n\n    cpu_to_be32w((uint32_t*)(buf + 4), reply->error);\n\n    cpu_to_be64w((uint64_t*)(buf + 8), reply->handle);\n\n\n\n    TRACE(\"Sending response to client\");\n\n\n\n    if (write_sync(csock, buf, sizeof(buf)) != sizeof(buf)) {\n\n        LOG(\"writing to socket failed\");\n\n        errno = EINVAL;\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 22056}
{"project": "qemu", "commit_id": "9bbd4843c052a0a467c7a3363046b0c95c0e5fc0", "target": 1, "func": "gen_msub32_q(TCGv ret, TCGv arg1, TCGv arg2, TCGv arg3, uint32_t n,\n\n             uint32_t up_shift, CPUTriCoreState *env)\n\n{\n\n    TCGv temp = tcg_temp_new();\n\n    TCGv temp2 = tcg_temp_new();\n\n    TCGv temp3 = tcg_temp_new();\n\n    TCGv_i64 t1 = tcg_temp_new_i64();\n\n    TCGv_i64 t2 = tcg_temp_new_i64();\n\n    TCGv_i64 t3 = tcg_temp_new_i64();\n\n    TCGv_i64 t4 = tcg_temp_new_i64();\n\n\n\n    tcg_gen_ext_i32_i64(t2, arg2);\n\n    tcg_gen_ext_i32_i64(t3, arg3);\n\n\n\n    tcg_gen_mul_i64(t2, t2, t3);\n\n\n\n    tcg_gen_ext_i32_i64(t1, arg1);\n\n    /* if we shift part of the fraction out, we need to round up */\n\n    tcg_gen_andi_i64(t4, t2, (1ll << (up_shift - n)) - 1);\n\n    tcg_gen_setcondi_i64(TCG_COND_NE, t4, t4, 0);\n\n    tcg_gen_sari_i64(t2, t2, up_shift - n);\n\n    tcg_gen_add_i64(t2, t2, t4);\n\n\n\n    tcg_gen_sub_i64(t3, t1, t2);\n\n    tcg_gen_trunc_i64_i32(temp3, t3);\n\n    /* calc v bit */\n\n    tcg_gen_setcondi_i64(TCG_COND_GT, t1, t3, 0x7fffffffLL);\n\n    tcg_gen_setcondi_i64(TCG_COND_LT, t2, t3, -0x80000000LL);\n\n    tcg_gen_or_i64(t1, t1, t2);\n\n    tcg_gen_trunc_i64_i32(cpu_PSW_V, t1);\n\n    tcg_gen_shli_tl(cpu_PSW_V, cpu_PSW_V, 31);\n\n    /* We produce an overflow on the host if the mul before was\n\n       (0x80000000 * 0x80000000) << 1). If this is the\n\n       case, we negate the ovf. */\n\n    if (n == 1) {\n\n        tcg_gen_setcondi_tl(TCG_COND_EQ, temp, arg2, 0x80000000);\n\n        tcg_gen_setcond_tl(TCG_COND_EQ, temp2, arg2, arg3);\n\n        tcg_gen_and_tl(temp, temp, temp2);\n\n        tcg_gen_shli_tl(temp, temp, 31);\n\n        /* negate v bit, if special condition */\n\n        tcg_gen_xor_tl(cpu_PSW_V, cpu_PSW_V, temp);\n\n    }\n\n    /* Calc SV bit */\n\n    tcg_gen_or_tl(cpu_PSW_SV, cpu_PSW_SV, cpu_PSW_V);\n\n    /* Calc AV/SAV bits */\n\n    tcg_gen_add_tl(cpu_PSW_AV, temp3, temp3);\n\n    tcg_gen_xor_tl(cpu_PSW_AV, temp3, cpu_PSW_AV);\n\n    /* calc SAV */\n\n    tcg_gen_or_tl(cpu_PSW_SAV, cpu_PSW_SAV, cpu_PSW_AV);\n\n    /* write back result */\n\n    tcg_gen_mov_tl(ret, temp3);\n\n\n\n    tcg_temp_free(temp);\n\n    tcg_temp_free(temp2);\n\n    tcg_temp_free(temp3);\n\n    tcg_temp_free_i64(t1);\n\n    tcg_temp_free_i64(t2);\n\n    tcg_temp_free_i64(t3);\n\n    tcg_temp_free_i64(t4);\n\n}\n", "idx": 22058}
{"project": "qemu", "commit_id": "69c07db04625cb243db6e8a0ac0a8e3973dd961a", "target": 1, "func": "static int tpm_passthrough_open_sysfs_cancel(TPMPassthruState *tpm_pt)\n\n{\n\n    int fd = -1;\n\n    char *dev;\n\n    char path[PATH_MAX];\n\n\n\n    if (tpm_pt->options->cancel_path) {\n\n        fd = qemu_open(tpm_pt->options->cancel_path, O_WRONLY);\n\n        if (fd < 0) {\n\n            error_report(\"Could not open TPM cancel path : %s\",\n\n                         strerror(errno));\n\n        }\n\n        return fd;\n\n    }\n\n\n\n    dev = strrchr(tpm_pt->tpm_dev, '/');\n\n    if (dev) {\n\n        dev++;\n\n        if (snprintf(path, sizeof(path), \"/sys/class/misc/%s/device/cancel\",\n\n                     dev) < sizeof(path)) {\n\n            fd = qemu_open(path, O_WRONLY);\n\n            if (fd >= 0) {\n\n                tpm_pt->options->cancel_path = g_strdup(path);\n\n            } else {\n\n                error_report(\"tpm_passthrough: Could not open TPM cancel \"\n\n                             \"path %s : %s\", path, strerror(errno));\n\n            }\n\n        }\n\n    } else {\n\n       error_report(\"tpm_passthrough: Bad TPM device path %s\",\n\n                    tpm_pt->tpm_dev);\n\n    }\n\n\n\n    return fd;\n\n}\n", "idx": 22059}
{"project": "qemu", "commit_id": "0b368a10c71af96f6cf93b0ba5c2ee3bdbd50e96", "target": 1, "func": "static int kvm_put_msrs(X86CPU *cpu, int level)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    int i;\n\n    int ret;\n\n\n\n    kvm_msr_buf_reset(cpu);\n\n\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_CS, env->sysenter_cs);\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_ESP, env->sysenter_esp);\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_EIP, env->sysenter_eip);\n\n    kvm_msr_entry_add(cpu, MSR_PAT, env->pat);\n\n    if (has_msr_star) {\n\n        kvm_msr_entry_add(cpu, MSR_STAR, env->star);\n\n    }\n\n    if (has_msr_hsave_pa) {\n\n        kvm_msr_entry_add(cpu, MSR_VM_HSAVE_PA, env->vm_hsave);\n\n    }\n\n    if (has_msr_tsc_aux) {\n\n        kvm_msr_entry_add(cpu, MSR_TSC_AUX, env->tsc_aux);\n\n    }\n\n    if (has_msr_tsc_adjust) {\n\n        kvm_msr_entry_add(cpu, MSR_TSC_ADJUST, env->tsc_adjust);\n\n    }\n\n    if (has_msr_misc_enable) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_MISC_ENABLE,\n\n                          env->msr_ia32_misc_enable);\n\n    }\n\n    if (has_msr_smbase) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_SMBASE, env->smbase);\n\n    }\n\n    if (has_msr_bndcfgs) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_BNDCFGS, env->msr_bndcfgs);\n\n    }\n\n    if (has_msr_xss) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_XSS, env->xss);\n\n    }\n\n#ifdef TARGET_X86_64\n\n    if (lm_capable_kernel) {\n\n        kvm_msr_entry_add(cpu, MSR_CSTAR, env->cstar);\n\n        kvm_msr_entry_add(cpu, MSR_KERNELGSBASE, env->kernelgsbase);\n\n        kvm_msr_entry_add(cpu, MSR_FMASK, env->fmask);\n\n        kvm_msr_entry_add(cpu, MSR_LSTAR, env->lstar);\n\n    }\n\n#endif\n\n    /*\n\n     * The following MSRs have side effects on the guest or are too heavy\n\n     * for normal writeback. Limit them to reset or full state updates.\n\n     */\n\n    if (level >= KVM_PUT_RESET_STATE) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_TSC, env->tsc);\n\n        kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, env->system_time_msr);\n\n        kvm_msr_entry_add(cpu, MSR_KVM_WALL_CLOCK, env->wall_clock_msr);\n\n        if (env->features[FEAT_KVM] & (1 << KVM_FEATURE_ASYNC_PF)) {\n\n            kvm_msr_entry_add(cpu, MSR_KVM_ASYNC_PF_EN, env->async_pf_en_msr);\n\n        }\n\n        if (env->features[FEAT_KVM] & (1 << KVM_FEATURE_PV_EOI)) {\n\n            kvm_msr_entry_add(cpu, MSR_KVM_PV_EOI_EN, env->pv_eoi_en_msr);\n\n        }\n\n        if (env->features[FEAT_KVM] & (1 << KVM_FEATURE_STEAL_TIME)) {\n\n            kvm_msr_entry_add(cpu, MSR_KVM_STEAL_TIME, env->steal_time_msr);\n\n        }\n\n        if (has_msr_architectural_pmu) {\n\n            /* Stop the counter.  */\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);\n\n\n\n            /* Set the counter values.  */\n\n            for (i = 0; i < MAX_FIXED_COUNTERS; i++) {\n\n                kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i,\n\n                                  env->msr_fixed_counters[i]);\n\n            }\n\n            for (i = 0; i < num_architectural_pmu_counters; i++) {\n\n                kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i,\n\n                                  env->msr_gp_counters[i]);\n\n                kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i,\n\n                                  env->msr_gp_evtsel[i]);\n\n            }\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS,\n\n                              env->msr_global_status);\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL,\n\n                              env->msr_global_ovf_ctrl);\n\n\n\n            /* Now start the PMU.  */\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL,\n\n                              env->msr_fixed_ctr_ctrl);\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL,\n\n                              env->msr_global_ctrl);\n\n        }\n\n        /*\n\n         * Hyper-V partition-wide MSRs: to avoid clearing them on cpu hot-add,\n\n         * only sync them to KVM on the first cpu\n\n         */\n\n        if (current_cpu == first_cpu) {\n\n            if (has_msr_hv_hypercall) {\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_GUEST_OS_ID,\n\n                                  env->msr_hv_guest_os_id);\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_HYPERCALL,\n\n                                  env->msr_hv_hypercall);\n\n            }\n\n            if (cpu->hyperv_time) {\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_REFERENCE_TSC,\n\n                                  env->msr_hv_tsc);\n\n            }\n\n        }\n\n        if (cpu->hyperv_vapic) {\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_APIC_ASSIST_PAGE,\n\n                              env->msr_hv_vapic);\n\n        }\n\n        if (has_msr_hv_crash) {\n\n            int j;\n\n\n\n            for (j = 0; j < HV_CRASH_PARAMS; j++)\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_P0 + j,\n\n                                  env->msr_hv_crash_params[j]);\n\n\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_CTL, HV_CRASH_CTL_NOTIFY);\n\n        }\n\n        if (has_msr_hv_runtime) {\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_VP_RUNTIME, env->msr_hv_runtime);\n\n        }\n\n        if (cpu->hyperv_synic) {\n\n            int j;\n\n\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_SVERSION, HV_SYNIC_VERSION);\n\n\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_SCONTROL,\n\n                              env->msr_hv_synic_control);\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_SIEFP,\n\n                              env->msr_hv_synic_evt_page);\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_SIMP,\n\n                              env->msr_hv_synic_msg_page);\n\n\n\n            for (j = 0; j < ARRAY_SIZE(env->msr_hv_synic_sint); j++) {\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_SINT0 + j,\n\n                                  env->msr_hv_synic_sint[j]);\n\n            }\n\n        }\n\n        if (has_msr_hv_stimer) {\n\n            int j;\n\n\n\n            for (j = 0; j < ARRAY_SIZE(env->msr_hv_stimer_config); j++) {\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_STIMER0_CONFIG + j * 2,\n\n                                env->msr_hv_stimer_config[j]);\n\n            }\n\n\n\n            for (j = 0; j < ARRAY_SIZE(env->msr_hv_stimer_count); j++) {\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_STIMER0_COUNT + j * 2,\n\n                                env->msr_hv_stimer_count[j]);\n\n            }\n\n        }\n\n        if (env->features[FEAT_1_EDX] & CPUID_MTRR) {\n\n            uint64_t phys_mask = MAKE_64BIT_MASK(0, cpu->phys_bits);\n\n\n\n            kvm_msr_entry_add(cpu, MSR_MTRRdefType, env->mtrr_deftype);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix64K_00000, env->mtrr_fixed[0]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix16K_80000, env->mtrr_fixed[1]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix16K_A0000, env->mtrr_fixed[2]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C0000, env->mtrr_fixed[3]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C8000, env->mtrr_fixed[4]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D0000, env->mtrr_fixed[5]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D8000, env->mtrr_fixed[6]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E0000, env->mtrr_fixed[7]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E8000, env->mtrr_fixed[8]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F0000, env->mtrr_fixed[9]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F8000, env->mtrr_fixed[10]);\n\n            for (i = 0; i < MSR_MTRRcap_VCNT; i++) {\n\n                /* The CPU GPs if we write to a bit above the physical limit of\n\n                 * the host CPU (and KVM emulates that)\n\n                 */\n\n                uint64_t mask = env->mtrr_var[i].mask;\n\n                mask &= phys_mask;\n\n\n\n                kvm_msr_entry_add(cpu, MSR_MTRRphysBase(i),\n\n                                  env->mtrr_var[i].base);\n\n                kvm_msr_entry_add(cpu, MSR_MTRRphysMask(i), mask);\n\n            }\n\n        }\n\n\n\n        /* Note: MSR_IA32_FEATURE_CONTROL is written separately, see\n\n         *       kvm_put_msr_feature_control. */\n\n    }\n\n    if (env->mcg_cap) {\n\n        int i;\n\n\n\n        kvm_msr_entry_add(cpu, MSR_MCG_STATUS, env->mcg_status);\n\n        kvm_msr_entry_add(cpu, MSR_MCG_CTL, env->mcg_ctl);\n\n        if (has_msr_mcg_ext_ctl) {\n\n            kvm_msr_entry_add(cpu, MSR_MCG_EXT_CTL, env->mcg_ext_ctl);\n\n        }\n\n        for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_MC0_CTL + i, env->mce_banks[i]);\n\n        }\n\n    }\n\n\n\n    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    if (ret < cpu->kvm_msr_buf->nmsrs) {\n\n        struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];\n\n        error_report(\"error: failed to set MSR 0x%\" PRIx32 \" to 0x%\" PRIx64,\n\n                     (uint32_t)e->index, (uint64_t)e->data);\n\n    }\n\n\n\n    assert(ret == cpu->kvm_msr_buf->nmsrs);\n\n    return 0;\n\n}\n", "idx": 22060}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void lm32_cpu_initfn(Object *obj)\n\n{\n\n    CPUState *cs = CPU(obj);\n\n    LM32CPU *cpu = LM32_CPU(obj);\n\n    CPULM32State *env = &cpu->env;\n\n    static bool tcg_initialized;\n\n\n\n    cs->env_ptr = env;\n\n    cpu_exec_init(cs, &error_abort);\n\n\n\n    env->flags = 0;\n\n\n\n    if (tcg_enabled() && !tcg_initialized) {\n\n        tcg_initialized = true;\n\n        lm32_translate_init();\n\n    }\n\n}\n", "idx": 22063}
{"project": "qemu", "commit_id": "0a73336d96397c80881219d080518fac6f1ecacb", "target": 1, "func": "static int find_and_check_chardev(CharDriverState **chr,\n\n                                  char *chr_name,\n\n                                  Error **errp)\n\n{\n\n    CompareChardevProps props;\n\n\n\n    *chr = qemu_chr_find(chr_name);\n\n    if (*chr == NULL) {\n\n        error_setg(errp, \"Device '%s' not found\",\n\n                   chr_name);\n\n        return 1;\n\n    }\n\n\n\n    memset(&props, 0, sizeof(props));\n\n    if (qemu_opt_foreach((*chr)->opts, compare_chardev_opts, &props, errp)) {\n\n        return 1;\n\n    }\n\n\n\n    if (!props.is_socket) {\n\n        error_setg(errp, \"chardev \\\"%s\\\" is not a tcp socket\",\n\n                   chr_name);\n\n        return 1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 22064}
{"project": "qemu", "commit_id": "b3a6a2e0417c78ec5491347eb85a7d125a5fefdc", "target": 1, "func": "int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )\n\n{\n\n    flag aSign;\n\n    int16 aExp, shiftCount;\n\n    uint64_t aSig, savedASig;\n\n    int32 z;\n\n    a = float64_squash_input_denormal(a STATUS_VAR);\n\n\n\n    aSig = extractFloat64Frac( a );\n\n    aExp = extractFloat64Exp( a );\n\n    aSign = extractFloat64Sign( a );\n\n    if ( 0x41E < aExp ) {\n\n        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;\n\n        goto invalid;\n\n    }\n\n    else if ( aExp < 0x3FF ) {\n\n        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n        return 0;\n\n    }\n\n    aSig |= LIT64( 0x0010000000000000 );\n\n    shiftCount = 0x433 - aExp;\n\n    savedASig = aSig;\n\n    aSig >>= shiftCount;\n\n    z = aSig;\n\n    if ( aSign ) z = - z;\n\n    if ( ( z < 0 ) ^ aSign ) {\n\n invalid:\n\n        float_raise( float_flag_invalid STATUS_VAR);\n\n        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;\n\n    }\n\n    if ( ( aSig<<shiftCount ) != savedASig ) {\n\n        STATUS(float_exception_flags) |= float_flag_inexact;\n\n    }\n\n    return z;\n\n\n\n}\n", "idx": 22065}
{"project": "qemu", "commit_id": "949fc82314cc84162e64a5323764527a542421ce", "target": 0, "func": "static void set_bit(Object *obj, Visitor *v, void *opaque,\n\n                    const char *name, Error **errp)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop = opaque;\n\n    Error *local_err = NULL;\n\n    bool value;\n\n\n\n    if (dev->realized) {\n\n        qdev_prop_set_after_realize(dev, name, errp);\n\n        return;\n\n    }\n\n\n\n    visit_type_bool(v, &value, name, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n    bit_prop_set(dev, prop, value);\n\n}\n", "idx": 22066}
{"project": "qemu", "commit_id": "fe62089563ffc6a42f16ff28a6b6be34d2697766", "target": 0, "func": "static inline void gen_goto_tb(DisasContext *s, int tb_num, target_ulong eip)\n\n{\n\n    target_ulong pc = s->cs_base + eip;\n\n\n\n    if (use_goto_tb(s, pc))  {\n\n        /* jump to same page: we can use a direct jump */\n\n        tcg_gen_goto_tb(tb_num);\n\n        gen_jmp_im(eip);\n\n        tcg_gen_exit_tb((uintptr_t)s->tb + tb_num);\n\n    } else {\n\n        /* jump to another page: currently not optimized */\n\n        gen_jmp_im(eip);\n\n        gen_eob(s);\n\n    }\n\n}\n", "idx": 22067}
{"project": "qemu", "commit_id": "e42349cbd6afd1f6838e719184e3d07190c02de7", "target": 0, "func": "static const char *target_parse_constraint(TCGArgConstraint *ct,\n\n                                           const char *ct_str, TCGType type)\n\n{\n\n    switch (*ct_str++) {\n\n    case 'r':                  /* all registers */\n\n        ct->ct |= TCG_CT_REG;\n\n        tcg_regset_set32(ct->u.regs, 0, 0xffff);\n\n        break;\n\n    case 'L':                  /* qemu_ld/st constraint */\n\n        ct->ct |= TCG_CT_REG;\n\n        tcg_regset_set32(ct->u.regs, 0, 0xffff);\n\n        tcg_regset_reset_reg (ct->u.regs, TCG_REG_R2);\n\n        tcg_regset_reset_reg (ct->u.regs, TCG_REG_R3);\n\n        tcg_regset_reset_reg (ct->u.regs, TCG_REG_R4);\n\n        break;\n\n    case 'a':                  /* force R2 for division */\n\n        ct->ct |= TCG_CT_REG;\n\n        tcg_regset_clear(ct->u.regs);\n\n        tcg_regset_set_reg(ct->u.regs, TCG_REG_R2);\n\n        break;\n\n    case 'b':                  /* force R3 for division */\n\n        ct->ct |= TCG_CT_REG;\n\n        tcg_regset_clear(ct->u.regs);\n\n        tcg_regset_set_reg(ct->u.regs, TCG_REG_R3);\n\n        break;\n\n    case 'A':\n\n        ct->ct |= TCG_CT_CONST_S33;\n\n        break;\n\n    case 'I':\n\n        ct->ct |= TCG_CT_CONST_S16;\n\n        break;\n\n    case 'J':\n\n        ct->ct |= TCG_CT_CONST_S32;\n\n        break;\n\n    case 'O':\n\n        ct->ct |= TCG_CT_CONST_ORI;\n\n        break;\n\n    case 'X':\n\n        ct->ct |= TCG_CT_CONST_XORI;\n\n        break;\n\n    case 'C':\n\n        /* ??? We have no insight here into whether the comparison is\n\n           signed or unsigned.  The COMPARE IMMEDIATE insn uses a 32-bit\n\n           signed immediate, and the COMPARE LOGICAL IMMEDIATE insn uses\n\n           a 32-bit unsigned immediate.  If we were to use the (semi)\n\n           obvious \"val == (int32_t)val\" we would be enabling unsigned\n\n           comparisons vs very large numbers.  The only solution is to\n\n           take the intersection of the ranges.  */\n\n        /* ??? Another possible solution is to simply lie and allow all\n\n           constants here and force the out-of-range values into a temp\n\n           register in tgen_cmp when we have knowledge of the actual\n\n           comparison code in use.  */\n\n        ct->ct |= TCG_CT_CONST_U31;\n\n        break;\n\n    case 'Z':\n\n        ct->ct |= TCG_CT_CONST_ZERO;\n\n        break;\n\n    default:\n\n        return NULL;\n\n    }\n\n    return ct_str;\n\n}\n", "idx": 22068}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t megasas_port_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    return megasas_mmio_read(opaque, addr & 0xff, size);\n\n}\n", "idx": 22069}
{"project": "qemu", "commit_id": "3826121d9298cde1d29ead05910e1f40125ee9b0", "target": 0, "func": "void arm_debug_excp_handler(CPUState *cs)\n\n{\n\n    /* Called by core code when a watchpoint or breakpoint fires;\n\n     * need to check which one and raise the appropriate exception.\n\n     */\n\n    ARMCPU *cpu = ARM_CPU(cs);\n\n    CPUARMState *env = &cpu->env;\n\n    CPUWatchpoint *wp_hit = cs->watchpoint_hit;\n\n\n\n    if (wp_hit) {\n\n        if (wp_hit->flags & BP_CPU) {\n\n            cs->watchpoint_hit = NULL;\n\n            if (check_watchpoints(cpu)) {\n\n                bool wnr = (wp_hit->flags & BP_WATCHPOINT_HIT_WRITE) != 0;\n\n                bool same_el = arm_debug_target_el(env) == arm_current_el(env);\n\n\n\n                if (extended_addresses_enabled(env)) {\n\n                    env->exception.fsr = (1 << 9) | 0x22;\n\n                } else {\n\n                    env->exception.fsr = 0x2;\n\n                }\n\n                env->exception.vaddress = wp_hit->hitaddr;\n\n                raise_exception(env, EXCP_DATA_ABORT,\n\n                                syn_watchpoint(same_el, 0, wnr),\n\n                                arm_debug_target_el(env));\n\n            } else {\n\n                cpu_resume_from_signal(cs, NULL);\n\n            }\n\n        }\n\n    } else {\n\n        uint64_t pc = is_a64(env) ? env->pc : env->regs[15];\n\n        bool same_el = (arm_debug_target_el(env) == arm_current_el(env));\n\n\n\n        /* (1) GDB breakpoints should be handled first.\n\n         * (2) Do not raise a CPU exception if no CPU breakpoint has fired,\n\n         * since singlestep is also done by generating a debug internal\n\n         * exception.\n\n         */\n\n        if (cpu_breakpoint_test(cs, pc, BP_GDB)\n\n            || !cpu_breakpoint_test(cs, pc, BP_CPU)) {\n\n            return;\n\n        }\n\n\n\n        if (extended_addresses_enabled(env)) {\n\n            env->exception.fsr = (1 << 9) | 0x22;\n\n        } else {\n\n            env->exception.fsr = 0x2;\n\n        }\n\n        /* FAR is UNKNOWN, so doesn't need setting */\n\n        raise_exception(env, EXCP_PREFETCH_ABORT,\n\n                        syn_breakpoint(same_el),\n\n                        arm_debug_target_el(env));\n\n    }\n\n}\n", "idx": 22070}
{"project": "qemu", "commit_id": "34f1b23f8a61841bac06010e898221c6192a9035", "target": 0, "func": "int load_elf_as(const char *filename,\n\n                uint64_t (*translate_fn)(void *, uint64_t),\n\n                void *translate_opaque, uint64_t *pentry, uint64_t *lowaddr,\n\n                uint64_t *highaddr, int big_endian, int elf_machine,\n\n                int clear_lsb, int data_swab, AddressSpace *as)\n\n{\n\n    int fd, data_order, target_data_order, must_swab, ret = ELF_LOAD_FAILED;\n\n    uint8_t e_ident[EI_NIDENT];\n\n\n\n    fd = open(filename, O_RDONLY | O_BINARY);\n\n    if (fd < 0) {\n\n        perror(filename);\n\n        return -1;\n\n    }\n\n    if (read(fd, e_ident, sizeof(e_ident)) != sizeof(e_ident))\n\n        goto fail;\n\n    if (e_ident[0] != ELFMAG0 ||\n\n        e_ident[1] != ELFMAG1 ||\n\n        e_ident[2] != ELFMAG2 ||\n\n        e_ident[3] != ELFMAG3) {\n\n        ret = ELF_LOAD_NOT_ELF;\n\n        goto fail;\n\n    }\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n    data_order = ELFDATA2MSB;\n\n#else\n\n    data_order = ELFDATA2LSB;\n\n#endif\n\n    must_swab = data_order != e_ident[EI_DATA];\n\n    if (big_endian) {\n\n        target_data_order = ELFDATA2MSB;\n\n    } else {\n\n        target_data_order = ELFDATA2LSB;\n\n    }\n\n\n\n    if (target_data_order != e_ident[EI_DATA]) {\n\n        ret = ELF_LOAD_WRONG_ENDIAN;\n\n        goto fail;\n\n    }\n\n\n\n    lseek(fd, 0, SEEK_SET);\n\n    if (e_ident[EI_CLASS] == ELFCLASS64) {\n\n        ret = load_elf64(filename, fd, translate_fn, translate_opaque, must_swab,\n\n                         pentry, lowaddr, highaddr, elf_machine, clear_lsb,\n\n                         data_swab, as);\n\n    } else {\n\n        ret = load_elf32(filename, fd, translate_fn, translate_opaque, must_swab,\n\n                         pentry, lowaddr, highaddr, elf_machine, clear_lsb,\n\n                         data_swab, as);\n\n    }\n\n\n\n fail:\n\n    close(fd);\n\n    return ret;\n\n}\n", "idx": 22071}
{"project": "qemu", "commit_id": "2d2507ef23d2a28eaeea5507ff4ec68657f1792f", "target": 0, "func": "static int vhost_net_start_one(struct vhost_net *net,\n\n                               VirtIODevice *dev,\n\n                               int vq_index)\n\n{\n\n    struct vhost_vring_file file = { };\n\n    int r;\n\n\n\n    if (net->dev.started) {\n\n        return 0;\n\n    }\n\n\n\n    net->dev.nvqs = 2;\n\n    net->dev.vqs = net->vqs;\n\n    net->dev.vq_index = vq_index;\n\n\n\n    r = vhost_dev_enable_notifiers(&net->dev, dev);\n\n    if (r < 0) {\n\n        goto fail_notifiers;\n\n    }\n\n\n\n    r = vhost_dev_start(&net->dev, dev);\n\n    if (r < 0) {\n\n        goto fail_start;\n\n    }\n\n\n\n    if (net->nc->info->poll) {\n\n        net->nc->info->poll(net->nc, false);\n\n    }\n\n\n\n    if (net->nc->info->type == NET_CLIENT_OPTIONS_KIND_TAP) {\n\n        qemu_set_fd_handler(net->backend, NULL, NULL, NULL);\n\n        file.fd = net->backend;\n\n        for (file.index = 0; file.index < net->dev.nvqs; ++file.index) {\n\n            const VhostOps *vhost_ops = net->dev.vhost_ops;\n\n            r = vhost_ops->vhost_call(&net->dev, VHOST_NET_SET_BACKEND,\n\n                                      &file);\n\n            if (r < 0) {\n\n                r = -errno;\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\nfail:\n\n    file.fd = -1;\n\n    if (net->nc->info->type == NET_CLIENT_OPTIONS_KIND_TAP) {\n\n        while (file.index-- > 0) {\n\n            const VhostOps *vhost_ops = net->dev.vhost_ops;\n\n            int r = vhost_ops->vhost_call(&net->dev, VHOST_NET_SET_BACKEND,\n\n                                          &file);\n\n            assert(r >= 0);\n\n        }\n\n    }\n\n    if (net->nc->info->poll) {\n\n        net->nc->info->poll(net->nc, true);\n\n    }\n\n    vhost_dev_stop(&net->dev, dev);\n\nfail_start:\n\n    vhost_dev_disable_notifiers(&net->dev, dev);\n\nfail_notifiers:\n\n    return r;\n\n}\n", "idx": 22072}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "mst_fpga_readb(void *opaque, target_phys_addr_t addr, unsigned size)\n\n{\n\n\tmst_irq_state *s = (mst_irq_state *) opaque;\n\n\n\n\tswitch (addr) {\n\n\tcase MST_LEDDAT1:\n\n\t\treturn s->leddat1;\n\n\tcase MST_LEDDAT2:\n\n\t\treturn s->leddat2;\n\n\tcase MST_LEDCTRL:\n\n\t\treturn s->ledctrl;\n\n\tcase MST_GPSWR:\n\n\t\treturn s->gpswr;\n\n\tcase MST_MSCWR1:\n\n\t\treturn s->mscwr1;\n\n\tcase MST_MSCWR2:\n\n\t\treturn s->mscwr2;\n\n\tcase MST_MSCWR3:\n\n\t\treturn s->mscwr3;\n\n\tcase MST_MSCRD:\n\n\t\treturn s->mscrd;\n\n\tcase MST_INTMSKENA:\n\n\t\treturn s->intmskena;\n\n\tcase MST_INTSETCLR:\n\n\t\treturn s->intsetclr;\n\n\tcase MST_PCMCIA0:\n\n\t\treturn s->pcmcia0;\n\n\tcase MST_PCMCIA1:\n\n\t\treturn s->pcmcia1;\n\n\tdefault:\n\n\t\tprintf(\"Mainstone - mst_fpga_readb: Bad register offset \"\n\n\t\t\t\"0x\" TARGET_FMT_plx \"\\n\", addr);\n\n\t}\n\n\treturn 0;\n\n}\n", "idx": 22073}
{"project": "qemu", "commit_id": "ffba87862b37f1d7762370c8d31b09f6e359ff09", "target": 0, "func": "int ppcmas_tlb_check(CPUState *env, ppcmas_tlb_t *tlb,\n\n                     target_phys_addr_t *raddrp,\n\n                     target_ulong address, uint32_t pid)\n\n{\n\n    target_ulong mask;\n\n    uint32_t tlb_pid;\n\n\n\n    /* Check valid flag */\n\n    if (!(tlb->mas1 & MAS1_VALID)) {\n\n        return -1;\n\n    }\n\n\n\n    mask = ~(booke206_tlb_to_page_size(env, tlb) - 1);\n\n    LOG_SWTLB(\"%s: TLB ADDR=0x\" TARGET_FMT_lx \" PID=0x%x MAS1=0x%x MAS2=0x%\"\n\n              PRIx64 \" mask=0x\" TARGET_FMT_lx \" MAS7_3=0x%\" PRIx64 \" MAS8=%x\\n\",\n\n              __func__, address, pid, tlb->mas1, tlb->mas2, mask, tlb->mas7_3,\n\n              tlb->mas8);\n\n\n\n    /* Check PID */\n\n    tlb_pid = (tlb->mas1 & MAS1_TID_MASK) >> MAS1_TID_SHIFT;\n\n    if (tlb_pid != 0 && tlb_pid != pid) {\n\n        return -1;\n\n    }\n\n\n\n    /* Check effective address */\n\n    if ((address & mask) != (tlb->mas2 & MAS2_EPN_MASK)) {\n\n        return -1;\n\n    }\n\n    *raddrp = (tlb->mas7_3 & mask) | (address & ~mask);\n\n\n\n    return 0;\n\n}\n", "idx": 22074}
{"project": "qemu", "commit_id": "b47d8efa9f430c332bf96ce6eede169eb48422ad", "target": 0, "func": "static VFIOGroup *vfio_get_group(int groupid, AddressSpace *as)\n\n{\n\n    VFIOGroup *group;\n\n    char path[32];\n\n    struct vfio_group_status status = { .argsz = sizeof(status) };\n\n\n\n    QLIST_FOREACH(group, &group_list, next) {\n\n        if (group->groupid == groupid) {\n\n            /* Found it.  Now is it already in the right context? */\n\n            if (group->container->space->as == as) {\n\n                return group;\n\n            } else {\n\n                error_report(\"vfio: group %d used in multiple address spaces\",\n\n                             group->groupid);\n\n                return NULL;\n\n            }\n\n        }\n\n    }\n\n\n\n    group = g_malloc0(sizeof(*group));\n\n\n\n    snprintf(path, sizeof(path), \"/dev/vfio/%d\", groupid);\n\n    group->fd = qemu_open(path, O_RDWR);\n\n    if (group->fd < 0) {\n\n        error_report(\"vfio: error opening %s: %m\", path);\n\n        goto free_group_exit;\n\n    }\n\n\n\n    if (ioctl(group->fd, VFIO_GROUP_GET_STATUS, &status)) {\n\n        error_report(\"vfio: error getting group status: %m\");\n\n        goto close_fd_exit;\n\n    }\n\n\n\n    if (!(status.flags & VFIO_GROUP_FLAGS_VIABLE)) {\n\n        error_report(\"vfio: error, group %d is not viable, please ensure \"\n\n                     \"all devices within the iommu_group are bound to their \"\n\n                     \"vfio bus driver.\", groupid);\n\n        goto close_fd_exit;\n\n    }\n\n\n\n    group->groupid = groupid;\n\n    QLIST_INIT(&group->device_list);\n\n\n\n    if (vfio_connect_container(group, as)) {\n\n        error_report(\"vfio: failed to setup container for group %d\", groupid);\n\n        goto close_fd_exit;\n\n    }\n\n\n\n    if (QLIST_EMPTY(&group_list)) {\n\n        qemu_register_reset(vfio_pci_reset_handler, NULL);\n\n    }\n\n\n\n    QLIST_INSERT_HEAD(&group_list, group, next);\n\n\n\n    vfio_kvm_device_add_group(group);\n\n\n\n    return group;\n\n\n\nclose_fd_exit:\n\n    close(group->fd);\n\n\n\nfree_group_exit:\n\n    g_free(group);\n\n\n\n    return NULL;\n\n}\n", "idx": 22076}
{"project": "qemu", "commit_id": "172061a0a0d98c974ea8d5ed715195237bc44225", "target": 0, "func": "int main_loop_init(void)\n\n{\n\n    int ret;\n\n\n\n    qemu_mutex_lock_iothread();\n\n    ret = qemu_signal_init();\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    /* Note eventfd must be drained before signalfd handlers run */\n\n    ret = qemu_event_init();\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 22077}
{"project": "qemu", "commit_id": "a153bf52b37e148f052b0869600877130671a03d", "target": 0, "func": "bool aio_poll(AioContext *ctx, bool blocking)\n\n{\n\n    AioHandler *node;\n\n    int i;\n\n    int ret = 0;\n\n    bool progress;\n\n    int64_t timeout;\n\n    int64_t start = 0;\n\n\n\n    /* aio_notify can avoid the expensive event_notifier_set if\n\n     * everything (file descriptors, bottom halves, timers) will\n\n     * be re-evaluated before the next blocking poll().  This is\n\n     * already true when aio_poll is called with blocking == false;\n\n     * if blocking == true, it is only true after poll() returns,\n\n     * so disable the optimization now.\n\n     */\n\n    if (blocking) {\n\n        atomic_add(&ctx->notify_me, 2);\n\n    }\n\n\n\n    qemu_lockcnt_inc(&ctx->list_lock);\n\n\n\n    if (ctx->poll_max_ns) {\n\n        start = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n\n    }\n\n\n\n    progress = try_poll_mode(ctx, blocking);\n\n    if (!progress) {\n\n        assert(npfd == 0);\n\n\n\n        /* fill pollfds */\n\n\n\n        if (!aio_epoll_enabled(ctx)) {\n\n            QLIST_FOREACH_RCU(node, &ctx->aio_handlers, node) {\n\n                if (!node->deleted && node->pfd.events\n\n                    && aio_node_check(ctx, node->is_external)) {\n\n                    add_pollfd(node);\n\n                }\n\n            }\n\n        }\n\n\n\n        timeout = blocking ? aio_compute_timeout(ctx) : 0;\n\n\n\n        /* wait until next event */\n\n        if (aio_epoll_check_poll(ctx, pollfds, npfd, timeout)) {\n\n            AioHandler epoll_handler;\n\n\n\n            epoll_handler.pfd.fd = ctx->epollfd;\n\n            epoll_handler.pfd.events = G_IO_IN | G_IO_OUT | G_IO_HUP | G_IO_ERR;\n\n            npfd = 0;\n\n            add_pollfd(&epoll_handler);\n\n            ret = aio_epoll(ctx, pollfds, npfd, timeout);\n\n        } else  {\n\n            ret = qemu_poll_ns(pollfds, npfd, timeout);\n\n        }\n\n    }\n\n\n\n    if (blocking) {\n\n        atomic_sub(&ctx->notify_me, 2);\n\n    }\n\n\n\n    /* Adjust polling time */\n\n    if (ctx->poll_max_ns) {\n\n        int64_t block_ns = qemu_clock_get_ns(QEMU_CLOCK_REALTIME) - start;\n\n\n\n        if (block_ns <= ctx->poll_ns) {\n\n            /* This is the sweet spot, no adjustment needed */\n\n        } else if (block_ns > ctx->poll_max_ns) {\n\n            /* We'd have to poll for too long, poll less */\n\n            int64_t old = ctx->poll_ns;\n\n\n\n            if (ctx->poll_shrink) {\n\n                ctx->poll_ns /= ctx->poll_shrink;\n\n            } else {\n\n                ctx->poll_ns = 0;\n\n            }\n\n\n\n            trace_poll_shrink(ctx, old, ctx->poll_ns);\n\n        } else if (ctx->poll_ns < ctx->poll_max_ns &&\n\n                   block_ns < ctx->poll_max_ns) {\n\n            /* There is room to grow, poll longer */\n\n            int64_t old = ctx->poll_ns;\n\n            int64_t grow = ctx->poll_grow;\n\n\n\n            if (grow == 0) {\n\n                grow = 2;\n\n            }\n\n\n\n            if (ctx->poll_ns) {\n\n                ctx->poll_ns *= grow;\n\n            } else {\n\n                ctx->poll_ns = 4000; /* start polling at 4 microseconds */\n\n            }\n\n\n\n            if (ctx->poll_ns > ctx->poll_max_ns) {\n\n                ctx->poll_ns = ctx->poll_max_ns;\n\n            }\n\n\n\n            trace_poll_grow(ctx, old, ctx->poll_ns);\n\n        }\n\n    }\n\n\n\n    aio_notify_accept(ctx);\n\n\n\n    /* if we have any readable fds, dispatch event */\n\n    if (ret > 0) {\n\n        for (i = 0; i < npfd; i++) {\n\n            nodes[i]->pfd.revents = pollfds[i].revents;\n\n        }\n\n    }\n\n\n\n    npfd = 0;\n\n    qemu_lockcnt_dec(&ctx->list_lock);\n\n\n\n    /* Run dispatch even if there were no readable fds to run timers */\n\n    if (aio_dispatch(ctx, ret > 0)) {\n\n        progress = true;\n\n    }\n\n\n\n    return progress;\n\n}\n", "idx": 22078}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "void qio_channel_socket_listen_async(QIOChannelSocket *ioc,\n\n                                     SocketAddress *addr,\n\n                                     QIOTaskFunc callback,\n\n                                     gpointer opaque,\n\n                                     GDestroyNotify destroy)\n\n{\n\n    QIOTask *task = qio_task_new(\n\n        OBJECT(ioc), callback, opaque, destroy);\n\n    SocketAddress *addrCopy;\n\n\n\n    addrCopy = QAPI_CLONE(SocketAddress, addr);\n\n\n\n    /* socket_listen() blocks in DNS lookups, so we must use a thread */\n\n    trace_qio_channel_socket_listen_async(ioc, addr);\n\n    qio_task_run_in_thread(task,\n\n                           qio_channel_socket_listen_worker,\n\n                           addrCopy,\n\n                           (GDestroyNotify)qapi_free_SocketAddress);\n\n}\n", "idx": 22079}
{"project": "qemu", "commit_id": "234ac1a9025bcfcc532449f72a97b3d4754d466c", "target": 0, "func": "void bdrv_append(BlockDriverState *bs_new, BlockDriverState *bs_top,\n\n                 Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n\n\n    assert(!atomic_read(&bs_top->in_flight));\n\n    assert(!atomic_read(&bs_new->in_flight));\n\n\n\n    bdrv_set_backing_hd(bs_new, bs_top, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto out;\n\n    }\n\n\n\n    change_parent_backing_link(bs_top, bs_new);\n\n\n\n    /* bs_new is now referenced by its new parents, we don't need the\n\n     * additional reference any more. */\n\nout:\n\n    bdrv_unref(bs_new);\n\n}\n", "idx": 22080}
{"project": "qemu", "commit_id": "be09ac4194bd0a61c0d9412c32431fbe2273cba1", "target": 0, "func": "static abi_long do_sendto(int fd, abi_ulong msg, size_t len, int flags,\n\n                          abi_ulong target_addr, socklen_t addrlen)\n\n{\n\n    void *addr;\n\n    void *host_msg;\n\n    abi_long ret;\n\n\n\n    if (addrlen < 0 || addrlen > MAX_SOCK_ADDR)\n\n        return -TARGET_EINVAL;\n\n\n\n    host_msg = lock_user(VERIFY_READ, msg, len, 1);\n\n    if (!host_msg)\n\n        return -TARGET_EFAULT;\n\n    if (target_addr) {\n\n        addr = alloca(addrlen);\n\n        target_to_host_sockaddr(addr, target_addr, addrlen);\n\n        ret = get_errno(sendto(fd, host_msg, len, flags, addr, addrlen));\n\n    } else {\n\n        ret = get_errno(send(fd, host_msg, len, flags));\n\n    }\n\n    unlock_user(host_msg, msg, 0);\n\n    return ret;\n\n}\n", "idx": 22081}
{"project": "qemu", "commit_id": "67251a311371c4d22e803f151f47fe817175b6c3", "target": 0, "func": "BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,\n\n                                    BlockDriverState *bs, int flags)\n\n{\n\n    assert(bs != NULL);\n\n\n\n    BlockReopenQueueEntry *bs_entry;\n\n    if (bs_queue == NULL) {\n\n        bs_queue = g_new0(BlockReopenQueue, 1);\n\n        QSIMPLEQ_INIT(bs_queue);\n\n    }\n\n\n\n    /* bdrv_open() masks this flag out */\n\n    flags &= ~BDRV_O_PROTOCOL;\n\n\n\n    if (bs->file) {\n\n        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));\n\n    }\n\n\n\n    bs_entry = g_new0(BlockReopenQueueEntry, 1);\n\n    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);\n\n\n\n    bs_entry->state.bs = bs;\n\n    bs_entry->state.flags = flags;\n\n\n\n    return bs_queue;\n\n}\n", "idx": 22082}
{"project": "qemu", "commit_id": "0e2487bd6f56445b43307536a465ee2ba810aed9", "target": 0, "func": "void qxl_render_resize(PCIQXLDevice *qxl)\n\n{\n\n    QXLSurfaceCreate *sc = &qxl->guest_primary.surface;\n\n\n\n    qxl->guest_primary.stride = sc->stride;\n\n    qxl->guest_primary.resized++;\n\n    switch (sc->format) {\n\n    case SPICE_SURFACE_FMT_16_555:\n\n        qxl->guest_primary.bytes_pp = 2;\n\n        qxl->guest_primary.bits_pp = 15;\n\n        break;\n\n    case SPICE_SURFACE_FMT_16_565:\n\n        qxl->guest_primary.bytes_pp = 2;\n\n        qxl->guest_primary.bits_pp = 16;\n\n        break;\n\n    case SPICE_SURFACE_FMT_32_xRGB:\n\n    case SPICE_SURFACE_FMT_32_ARGB:\n\n        qxl->guest_primary.bytes_pp = 4;\n\n        qxl->guest_primary.bits_pp = 32;\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"%s: unhandled format: %x\\n\", __FUNCTION__,\n\n                qxl->guest_primary.surface.format);\n\n        qxl->guest_primary.bytes_pp = 4;\n\n        qxl->guest_primary.bits_pp = 32;\n\n        break;\n\n    }\n\n}\n", "idx": 22083}
{"project": "qemu", "commit_id": "3ae43202754711808ea5186e327bfd0533dd88fc", "target": 0, "func": "long do_syscall(void *cpu_env, int num, long arg1, long arg2, long arg3,\n\n                long arg4, long arg5, long arg6)\n\n{\n\n    long ret;\n\n    struct stat st;\n\n    struct statfs stfs;\n\n    void *p;\n\n   \n\n#ifdef DEBUG\n\n    gemu_log(\"syscall %d\", num);\n\n#endif\n\n    switch(num) {\n\n    case TARGET_NR_exit:\n\n#ifdef HAVE_GPROF\n\n        _mcleanup();\n\n#endif\n\n        gdb_exit(cpu_env, arg1);\n\n        /* XXX: should free thread stack and CPU env */\n\n        _exit(arg1);\n\n        ret = 0; /* avoid warning */\n\n        break;\n\n    case TARGET_NR_read:\n\n        page_unprotect_range(arg2, arg3);\n\n        p = lock_user(arg2, arg3, 0);\n\n        ret = get_errno(read(arg1, p, arg3));\n\n        unlock_user(p, arg2, ret);\n\n        break;\n\n    case TARGET_NR_write:\n\n        p = lock_user(arg2, arg3, 1);\n\n        ret = get_errno(write(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n    case TARGET_NR_open:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(open(path(p),\n\n                             target_to_host_bitmask(arg2, fcntl_flags_tbl),\n\n                             arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_close:\n\n        ret = get_errno(close(arg1));\n\n        break;\n\n    case TARGET_NR_brk:\n\n        ret = do_brk(arg1);\n\n        break;\n\n    case TARGET_NR_fork:\n\n        ret = get_errno(do_fork(cpu_env, SIGCHLD, 0));\n\n        break;\n\n#ifdef TARGET_NR_waitpid\n\n    case TARGET_NR_waitpid:\n\n        {\n\n            int status;\n\n            ret = get_errno(waitpid(arg1, &status, arg3));\n\n            if (!is_error(ret) && arg2)\n\n                tput32(arg2, status);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_creat /* not on alpha */\n\n    case TARGET_NR_creat:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(creat(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_link:\n\n        {\n\n            void * p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg2);\n\n            ret = get_errno(link(p, p2));\n\n            unlock_user(p2, arg2, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n    case TARGET_NR_unlink:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(unlink(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_execve:\n\n        {\n\n            char **argp, **envp;\n\n            int argc, envc;\n\n            target_ulong gp;\n\n            target_ulong guest_argp;\n\n            target_ulong guest_envp;\n\n            target_ulong addr;\n\n            char **q;\n\n\n\n            argc = 0;\n\n            guest_argp = arg2;\n\n            for (gp = guest_argp; tgetl(gp); gp++)\n\n                argc++;\n\n            envc = 0;\n\n            guest_envp = arg3;\n\n            for (gp = guest_envp; tgetl(gp); gp++)\n\n                envc++;\n\n\n\n            argp = alloca((argc + 1) * sizeof(void *));\n\n            envp = alloca((envc + 1) * sizeof(void *));\n\n\n\n            for (gp = guest_argp, q = argp; ;\n\n                  gp += sizeof(target_ulong), q++) {\n\n                addr = tgetl(gp);\n\n                if (!addr)\n\n                    break;\n\n                *q = lock_user_string(addr);\n\n            }\n\n            *q = NULL;\n\n\n\n            for (gp = guest_envp, q = envp; ;\n\n                  gp += sizeof(target_ulong), q++) {\n\n                addr = tgetl(gp);\n\n                if (!addr)\n\n                    break;\n\n                *q = lock_user_string(addr);\n\n            }\n\n            *q = NULL;\n\n\n\n            p = lock_user_string(arg1);\n\n            ret = get_errno(execve(p, argp, envp));\n\n            unlock_user(p, arg1, 0);\n\n\n\n            for (gp = guest_argp, q = argp; *q;\n\n                  gp += sizeof(target_ulong), q++) {\n\n                addr = tgetl(gp);\n\n                unlock_user(*q, addr, 0);\n\n            }\n\n            for (gp = guest_envp, q = envp; *q;\n\n                  gp += sizeof(target_ulong), q++) {\n\n                addr = tgetl(gp);\n\n                unlock_user(*q, addr, 0);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_chdir:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(chdir(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_time\n\n    case TARGET_NR_time:\n\n        {\n\n            time_t host_time;\n\n            ret = get_errno(time(&host_time));\n\n            if (!is_error(ret) && arg1)\n\n                tputl(arg1, host_time);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_mknod:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(mknod(p, arg2, arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_chmod:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(chmod(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_break\n\n    case TARGET_NR_break:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_oldstat\n\n    case TARGET_NR_oldstat:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_lseek:\n\n        ret = get_errno(lseek(arg1, arg2, arg3));\n\n        break;\n\n#ifdef TARGET_NR_getxpid\n\n    case TARGET_NR_getxpid:\n\n#else\n\n    case TARGET_NR_getpid:\n\n#endif\n\n        ret = get_errno(getpid());\n\n        break;\n\n    case TARGET_NR_mount:\n\n\t\t{\n\n\t\t\t/* need to look at the data field */\n\n\t\t\tvoid *p2, *p3;\n\n\t\t\tp = lock_user_string(arg1);\n\n\t\t\tp2 = lock_user_string(arg2);\n\n\t\t\tp3 = lock_user_string(arg3);\n\n\t\t\tret = get_errno(mount(p, p2, p3, (unsigned long)arg4, (const void *)arg5));\n\n\t\t\tunlock_user(p, arg1, 0);\n\n\t\t\tunlock_user(p2, arg2, 0);\n\n\t\t\tunlock_user(p3, arg3, 0);\n\n\t\t\tbreak;\n\n\t\t}\n\n#ifdef TARGET_NR_umount\n\n    case TARGET_NR_umount:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(umount(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_stime /* not on alpha */\n\n    case TARGET_NR_stime:\n\n        {\n\n            time_t host_time;\n\n            host_time = tgetl(arg1);\n\n            ret = get_errno(stime(&host_time));\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_ptrace:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_alarm /* not on alpha */\n\n    case TARGET_NR_alarm:\n\n        ret = alarm(arg1);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_oldfstat\n\n    case TARGET_NR_oldfstat:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_pause /* not on alpha */\n\n    case TARGET_NR_pause:\n\n        ret = get_errno(pause());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_utime\n\n    case TARGET_NR_utime:\n\n        {\n\n            struct utimbuf tbuf, *host_tbuf;\n\n            struct target_utimbuf *target_tbuf;\n\n            if (arg2) {\n\n                lock_user_struct(target_tbuf, arg2, 1);\n\n                tbuf.actime = tswapl(target_tbuf->actime);\n\n                tbuf.modtime = tswapl(target_tbuf->modtime);\n\n                unlock_user_struct(target_tbuf, arg2, 0);\n\n                host_tbuf = &tbuf;\n\n            } else {\n\n                host_tbuf = NULL;\n\n            }\n\n            p = lock_user_string(arg1);\n\n            ret = get_errno(utime(p, host_tbuf));\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_utimes:\n\n        {\n\n            struct timeval *tvp, tv[2];\n\n            if (arg2) {\n\n                target_to_host_timeval(&tv[0], arg2);\n\n                target_to_host_timeval(&tv[1],\n\n                    arg2 + sizeof (struct target_timeval));\n\n                tvp = tv;\n\n            } else {\n\n                tvp = NULL;\n\n            }\n\n            p = lock_user_string(arg1);\n\n            ret = get_errno(utimes(p, tvp));\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_stty\n\n    case TARGET_NR_stty:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_gtty\n\n    case TARGET_NR_gtty:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_access:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(access(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_nice /* not on alpha */\n\n    case TARGET_NR_nice:\n\n        ret = get_errno(nice(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_ftime\n\n    case TARGET_NR_ftime:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_sync:\n\n        sync();\n\n        ret = 0;\n\n        break;\n\n    case TARGET_NR_kill:\n\n        ret = get_errno(kill(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_rename:\n\n        {\n\n            void *p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg2);\n\n            ret = get_errno(rename(p, p2));\n\n            unlock_user(p2, arg2, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n    case TARGET_NR_mkdir:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(mkdir(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_rmdir:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(rmdir(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_dup:\n\n        ret = get_errno(dup(arg1));\n\n        break;\n\n    case TARGET_NR_pipe:\n\n        {\n\n            int host_pipe[2];\n\n            ret = get_errno(pipe(host_pipe));\n\n            if (!is_error(ret)) {\n\n#if defined(TARGET_MIPS)\n\n                CPUMIPSState *env = (CPUMIPSState*)cpu_env;\n\n\t\tenv->gpr[3][env->current_tc] = host_pipe[1];\n\n\t\tret = host_pipe[0];\n\n#else\n\n                tput32(arg1, host_pipe[0]);\n\n                tput32(arg1 + 4, host_pipe[1]);\n\n#endif\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_times:\n\n        {\n\n            struct target_tms *tmsp;\n\n            struct tms tms;\n\n            ret = get_errno(times(&tms));\n\n            if (arg1) {\n\n                tmsp = lock_user(arg1, sizeof(struct target_tms), 0);\n\n                tmsp->tms_utime = tswapl(host_to_target_clock_t(tms.tms_utime));\n\n                tmsp->tms_stime = tswapl(host_to_target_clock_t(tms.tms_stime));\n\n                tmsp->tms_cutime = tswapl(host_to_target_clock_t(tms.tms_cutime));\n\n                tmsp->tms_cstime = tswapl(host_to_target_clock_t(tms.tms_cstime));\n\n            }\n\n            if (!is_error(ret))\n\n                ret = host_to_target_clock_t(ret);\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_prof\n\n    case TARGET_NR_prof:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_signal\n\n    case TARGET_NR_signal:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_acct:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(acct(path(p)));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_umount2 /* not on alpha */\n\n    case TARGET_NR_umount2:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(umount2(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_lock\n\n    case TARGET_NR_lock:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_ioctl:\n\n        ret = do_ioctl(arg1, arg2, arg3);\n\n        break;\n\n    case TARGET_NR_fcntl:\n\n        ret = get_errno(do_fcntl(arg1, arg2, arg3));\n\n        break;\n\n#ifdef TARGET_NR_mpx\n\n    case TARGET_NR_mpx:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_setpgid:\n\n        ret = get_errno(setpgid(arg1, arg2));\n\n        break;\n\n#ifdef TARGET_NR_ulimit\n\n    case TARGET_NR_ulimit:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_oldolduname\n\n    case TARGET_NR_oldolduname:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_umask:\n\n        ret = get_errno(umask(arg1));\n\n        break;\n\n    case TARGET_NR_chroot:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(chroot(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_ustat:\n\n        goto unimplemented;\n\n    case TARGET_NR_dup2:\n\n        ret = get_errno(dup2(arg1, arg2));\n\n        break;\n\n#ifdef TARGET_NR_getppid /* not on alpha */\n\n    case TARGET_NR_getppid:\n\n        ret = get_errno(getppid());\n\n        break;\n\n#endif\n\n    case TARGET_NR_getpgrp:\n\n        ret = get_errno(getpgrp());\n\n        break;\n\n    case TARGET_NR_setsid:\n\n        ret = get_errno(setsid());\n\n        break;\n\n#ifdef TARGET_NR_sigaction\n\n    case TARGET_NR_sigaction:\n\n        {\n\n#if !defined(TARGET_MIPS)\n\n            struct target_old_sigaction *old_act;\n\n            struct target_sigaction act, oact, *pact;\n\n            if (arg2) {\n\n                lock_user_struct(old_act, arg2, 1);\n\n                act._sa_handler = old_act->_sa_handler;\n\n                target_siginitset(&act.sa_mask, old_act->sa_mask);\n\n                act.sa_flags = old_act->sa_flags;\n\n                act.sa_restorer = old_act->sa_restorer;\n\n                unlock_user_struct(old_act, arg2, 0);\n\n                pact = &act;\n\n            } else {\n\n                pact = NULL;\n\n            }\n\n            ret = get_errno(do_sigaction(arg1, pact, &oact));\n\n            if (!is_error(ret) && arg3) {\n\n                lock_user_struct(old_act, arg3, 0);\n\n                old_act->_sa_handler = oact._sa_handler;\n\n                old_act->sa_mask = oact.sa_mask.sig[0];\n\n                old_act->sa_flags = oact.sa_flags;\n\n                old_act->sa_restorer = oact.sa_restorer;\n\n                unlock_user_struct(old_act, arg3, 1);\n\n            }\n\n#else\n\n\t    struct target_sigaction act, oact, *pact, *old_act;\n\n\n\n\t    if (arg2) {\n\n\t\tlock_user_struct(old_act, arg2, 1);\n\n\t\tact._sa_handler = old_act->_sa_handler;\n\n\t\ttarget_siginitset(&act.sa_mask, old_act->sa_mask.sig[0]);\n\n\t\tact.sa_flags = old_act->sa_flags;\n\n\t\tunlock_user_struct(old_act, arg2, 0);\n\n\t\tpact = &act;\n\n\t    } else {\n\n\t\tpact = NULL;\n\n\t    }\n\n\n\n\t    ret = get_errno(do_sigaction(arg1, pact, &oact));\n\n\n\n\t    if (!is_error(ret) && arg3) {\n\n\t\tlock_user_struct(old_act, arg3, 0);\n\n\t\told_act->_sa_handler = oact._sa_handler;\n\n\t\told_act->sa_flags = oact.sa_flags;\n\n\t\told_act->sa_mask.sig[0] = oact.sa_mask.sig[0];\n\n\t\told_act->sa_mask.sig[1] = 0;\n\n\t\told_act->sa_mask.sig[2] = 0;\n\n\t\told_act->sa_mask.sig[3] = 0;\n\n\t\tunlock_user_struct(old_act, arg3, 1);\n\n\t    }\n\n#endif\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigaction:\n\n        {\n\n            struct target_sigaction *act;\n\n            struct target_sigaction *oact;\n\n\n\n            if (arg2)\n\n                lock_user_struct(act, arg2, 1);\n\n            else\n\n                act = NULL;\n\n            if (arg3)\n\n                lock_user_struct(oact, arg3, 0);\n\n            else\n\n                oact = NULL;\n\n            ret = get_errno(do_sigaction(arg1, act, oact));\n\n            if (arg2)\n\n                unlock_user_struct(act, arg2, 0);\n\n            if (arg3)\n\n                unlock_user_struct(oact, arg3, 1);\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sgetmask /* not on alpha */\n\n    case TARGET_NR_sgetmask:\n\n        {\n\n            sigset_t cur_set;\n\n            target_ulong target_set;\n\n            sigprocmask(0, NULL, &cur_set);\n\n            host_to_target_old_sigset(&target_set, &cur_set);\n\n            ret = target_set;\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_ssetmask /* not on alpha */\n\n    case TARGET_NR_ssetmask:\n\n        {\n\n            sigset_t set, oset, cur_set;\n\n            target_ulong target_set = arg1;\n\n            sigprocmask(0, NULL, &cur_set);\n\n            target_to_host_old_sigset(&set, &target_set);\n\n            sigorset(&set, &set, &cur_set);\n\n            sigprocmask(SIG_SETMASK, &set, &oset);\n\n            host_to_target_old_sigset(&target_set, &oset);\n\n            ret = target_set;\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sigprocmask\n\n    case TARGET_NR_sigprocmask:\n\n        {\n\n            int how = arg1;\n\n            sigset_t set, oldset, *set_ptr;\n\n           \n\n            if (arg2) {\n\n                switch(how) {\n\n                case TARGET_SIG_BLOCK:\n\n                    how = SIG_BLOCK;\n\n                    break;\n\n                case TARGET_SIG_UNBLOCK:\n\n                    how = SIG_UNBLOCK;\n\n                    break;\n\n                case TARGET_SIG_SETMASK:\n\n                    how = SIG_SETMASK;\n\n                    break;\n\n                default:\n\n                    ret = -EINVAL;\n\n                    goto fail;\n\n                }\n\n                p = lock_user(arg2, sizeof(target_sigset_t), 1);\n\n                target_to_host_old_sigset(&set, p);\n\n                unlock_user(p, arg2, 0);\n\n                set_ptr = &set;\n\n            } else {\n\n                how = 0;\n\n                set_ptr = NULL;\n\n            }\n\n            ret = get_errno(sigprocmask(arg1, set_ptr, &oldset));\n\n            if (!is_error(ret) && arg3) {\n\n                p = lock_user(arg3, sizeof(target_sigset_t), 0);\n\n                host_to_target_old_sigset(p, &oldset);\n\n                unlock_user(p, arg3, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigprocmask:\n\n        {\n\n            int how = arg1;\n\n            sigset_t set, oldset, *set_ptr;\n\n           \n\n            if (arg2) {\n\n                switch(how) {\n\n                case TARGET_SIG_BLOCK:\n\n                    how = SIG_BLOCK;\n\n                    break;\n\n                case TARGET_SIG_UNBLOCK:\n\n                    how = SIG_UNBLOCK;\n\n                    break;\n\n                case TARGET_SIG_SETMASK:\n\n                    how = SIG_SETMASK;\n\n                    break;\n\n                default:\n\n                    ret = -EINVAL;\n\n                    goto fail;\n\n                }\n\n                p = lock_user(arg2, sizeof(target_sigset_t), 1);\n\n                target_to_host_sigset(&set, p);\n\n                unlock_user(p, arg2, 0);\n\n                set_ptr = &set;\n\n            } else {\n\n                how = 0;\n\n                set_ptr = NULL;\n\n            }\n\n            ret = get_errno(sigprocmask(how, set_ptr, &oldset));\n\n            if (!is_error(ret) && arg3) {\n\n                p = lock_user(arg3, sizeof(target_sigset_t), 0);\n\n                host_to_target_sigset(p, &oldset);\n\n                unlock_user(p, arg3, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sigpending\n\n    case TARGET_NR_sigpending:\n\n        {\n\n            sigset_t set;\n\n            ret = get_errno(sigpending(&set));\n\n            if (!is_error(ret)) {\n\n                p = lock_user(arg1, sizeof(target_sigset_t), 0);\n\n                host_to_target_old_sigset(p, &set);\n\n                unlock_user(p, arg1, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigpending:\n\n        {\n\n            sigset_t set;\n\n            ret = get_errno(sigpending(&set));\n\n            if (!is_error(ret)) {\n\n                p = lock_user(arg1, sizeof(target_sigset_t), 0);\n\n                host_to_target_sigset(p, &set);\n\n                unlock_user(p, arg1, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sigsuspend\n\n    case TARGET_NR_sigsuspend:\n\n        {\n\n            sigset_t set;\n\n            p = lock_user(arg1, sizeof(target_sigset_t), 1);\n\n            target_to_host_old_sigset(&set, p);\n\n            unlock_user(p, arg1, 0);\n\n            ret = get_errno(sigsuspend(&set));\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigsuspend:\n\n        {\n\n            sigset_t set;\n\n            p = lock_user(arg1, sizeof(target_sigset_t), 1);\n\n            target_to_host_sigset(&set, p);\n\n            unlock_user(p, arg1, 0);\n\n            ret = get_errno(sigsuspend(&set));\n\n        }\n\n        break;\n\n    case TARGET_NR_rt_sigtimedwait:\n\n        {\n\n            sigset_t set;\n\n            struct timespec uts, *puts;\n\n            siginfo_t uinfo;\n\n           \n\n            p = lock_user(arg1, sizeof(target_sigset_t), 1);\n\n            target_to_host_sigset(&set, p);\n\n            unlock_user(p, arg1, 0);\n\n            if (arg3) {\n\n                puts = &uts;\n\n                target_to_host_timespec(puts, arg3);\n\n            } else {\n\n                puts = NULL;\n\n            }\n\n            ret = get_errno(sigtimedwait(&set, &uinfo, puts));\n\n            if (!is_error(ret) && arg2) {\n\n                p = lock_user(arg2, sizeof(target_sigset_t), 0);\n\n                host_to_target_siginfo(p, &uinfo);\n\n                unlock_user(p, arg2, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_rt_sigqueueinfo:\n\n        {\n\n            siginfo_t uinfo;\n\n            p = lock_user(arg3, sizeof(target_sigset_t), 1);\n\n            target_to_host_siginfo(&uinfo, p);\n\n            unlock_user(p, arg1, 0);\n\n            ret = get_errno(sys_rt_sigqueueinfo(arg1, arg2, &uinfo));\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sigreturn\n\n    case TARGET_NR_sigreturn:\n\n        /* NOTE: ret is eax, so not transcoding must be done */\n\n        ret = do_sigreturn(cpu_env);\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigreturn:\n\n        /* NOTE: ret is eax, so not transcoding must be done */\n\n        ret = do_rt_sigreturn(cpu_env);\n\n        break;\n\n    case TARGET_NR_sethostname:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(sethostname(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_setrlimit:\n\n        {\n\n            /* XXX: convert resource ? */\n\n            int resource = arg1;\n\n            struct target_rlimit *target_rlim;\n\n            struct rlimit rlim;\n\n            lock_user_struct(target_rlim, arg2, 1);\n\n            rlim.rlim_cur = tswapl(target_rlim->rlim_cur);\n\n            rlim.rlim_max = tswapl(target_rlim->rlim_max);\n\n            unlock_user_struct(target_rlim, arg2, 0);\n\n            ret = get_errno(setrlimit(resource, &rlim));\n\n        }\n\n        break;\n\n    case TARGET_NR_getrlimit:\n\n        {\n\n            /* XXX: convert resource ? */\n\n            int resource = arg1;\n\n            struct target_rlimit *target_rlim;\n\n            struct rlimit rlim;\n\n           \n\n            ret = get_errno(getrlimit(resource, &rlim));\n\n            if (!is_error(ret)) {\n\n                lock_user_struct(target_rlim, arg2, 0);\n\n                rlim.rlim_cur = tswapl(target_rlim->rlim_cur);\n\n                rlim.rlim_max = tswapl(target_rlim->rlim_max);\n\n                unlock_user_struct(target_rlim, arg2, 1);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_getrusage:\n\n        {\n\n            struct rusage rusage;\n\n            ret = get_errno(getrusage(arg1, &rusage));\n\n            if (!is_error(ret)) {\n\n                host_to_target_rusage(arg2, &rusage);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_gettimeofday:\n\n        {\n\n            struct timeval tv;\n\n            ret = get_errno(gettimeofday(&tv, NULL));\n\n            if (!is_error(ret)) {\n\n                host_to_target_timeval(arg1, &tv);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_settimeofday:\n\n        {\n\n            struct timeval tv;\n\n            target_to_host_timeval(&tv, arg1);\n\n            ret = get_errno(settimeofday(&tv, NULL));\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_select\n\n    case TARGET_NR_select:\n\n        {\n\n            struct target_sel_arg_struct *sel;\n\n            target_ulong inp, outp, exp, tvp;\n\n            long nsel;\n\n\n\n            lock_user_struct(sel, arg1, 1);\n\n            nsel = tswapl(sel->n);\n\n            inp = tswapl(sel->inp);\n\n            outp = tswapl(sel->outp);\n\n            exp = tswapl(sel->exp);\n\n            tvp = tswapl(sel->tvp);\n\n            unlock_user_struct(sel, arg1, 0);\n\n            ret = do_select(nsel, inp, outp, exp, tvp);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_symlink:\n\n        {\n\n            void *p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg2);\n\n            ret = get_errno(symlink(p, p2));\n\n            unlock_user(p2, arg2, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_oldlstat\n\n    case TARGET_NR_oldlstat:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_readlink:\n\n        {\n\n            void *p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user(arg2, arg3, 0);\n\n            ret = get_errno(readlink(path(p), p2, arg3));\n\n            unlock_user(p2, arg2, ret);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_uselib\n\n    case TARGET_NR_uselib:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_swapon\n\n    case TARGET_NR_swapon:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(swapon(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_reboot:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_readdir\n\n    case TARGET_NR_readdir:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_mmap\n\n    case TARGET_NR_mmap:\n\n#if defined(TARGET_I386) || defined(TARGET_ARM) || defined(TARGET_M68K)\n\n        {\n\n            target_ulong *v;\n\n            target_ulong v1, v2, v3, v4, v5, v6;\n\n            v = lock_user(arg1, 6 * sizeof(target_ulong), 1);\n\n            v1 = tswapl(v[0]);\n\n            v2 = tswapl(v[1]);\n\n            v3 = tswapl(v[2]);\n\n            v4 = tswapl(v[3]);\n\n            v5 = tswapl(v[4]);\n\n            v6 = tswapl(v[5]);\n\n            unlock_user(v, arg1, 0);\n\n            ret = get_errno(target_mmap(v1, v2, v3,\n\n                                        target_to_host_bitmask(v4, mmap_flags_tbl),\n\n                                        v5, v6));\n\n        }\n\n#else\n\n        ret = get_errno(target_mmap(arg1, arg2, arg3,\n\n                                    target_to_host_bitmask(arg4, mmap_flags_tbl),\n\n                                    arg5,\n\n                                    arg6));\n\n#endif\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_mmap2\n\n    case TARGET_NR_mmap2:\n\n#if defined(TARGET_SPARC) || defined(TARGET_MIPS)\n\n#define MMAP_SHIFT 12\n\n#else\n\n#define MMAP_SHIFT TARGET_PAGE_BITS\n\n#endif\n\n        ret = get_errno(target_mmap(arg1, arg2, arg3,\n\n                                    target_to_host_bitmask(arg4, mmap_flags_tbl),\n\n                                    arg5,\n\n                                    arg6 << MMAP_SHIFT));\n\n        break;\n\n#endif\n\n    case TARGET_NR_munmap:\n\n        ret = get_errno(target_munmap(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_mprotect:\n\n        ret = get_errno(target_mprotect(arg1, arg2, arg3));\n\n        break;\n\n#ifdef TARGET_NR_mremap\n\n    case TARGET_NR_mremap:\n\n        ret = get_errno(target_mremap(arg1, arg2, arg3, arg4, arg5));\n\n        break;\n\n#endif\n\n        /* ??? msync/mlock/munlock are broken for softmmu.  */\n\n#ifdef TARGET_NR_msync\n\n    case TARGET_NR_msync:\n\n        ret = get_errno(msync(g2h(arg1), arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_mlock\n\n    case TARGET_NR_mlock:\n\n        ret = get_errno(mlock(g2h(arg1), arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_munlock\n\n    case TARGET_NR_munlock:\n\n        ret = get_errno(munlock(g2h(arg1), arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_mlockall\n\n    case TARGET_NR_mlockall:\n\n        ret = get_errno(mlockall(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_munlockall\n\n    case TARGET_NR_munlockall:\n\n        ret = get_errno(munlockall());\n\n        break;\n\n#endif\n\n    case TARGET_NR_truncate:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(truncate(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_ftruncate:\n\n        ret = get_errno(ftruncate(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_fchmod:\n\n        ret = get_errno(fchmod(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_getpriority:\n\n        ret = get_errno(getpriority(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_setpriority:\n\n        ret = get_errno(setpriority(arg1, arg2, arg3));\n\n        break;\n\n#ifdef TARGET_NR_profil\n\n    case TARGET_NR_profil:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_statfs:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(statfs(path(p), &stfs));\n\n        unlock_user(p, arg1, 0);\n\n    convert_statfs:\n\n        if (!is_error(ret)) {\n\n            struct target_statfs *target_stfs;\n\n           \n\n            lock_user_struct(target_stfs, arg2, 0);\n\n            /* ??? put_user is probably wrong.  */\n\n            put_user(stfs.f_type, &target_stfs->f_type);\n\n            put_user(stfs.f_bsize, &target_stfs->f_bsize);\n\n            put_user(stfs.f_blocks, &target_stfs->f_blocks);\n\n            put_user(stfs.f_bfree, &target_stfs->f_bfree);\n\n            put_user(stfs.f_bavail, &target_stfs->f_bavail);\n\n            put_user(stfs.f_files, &target_stfs->f_files);\n\n            put_user(stfs.f_ffree, &target_stfs->f_ffree);\n\n            put_user(stfs.f_fsid.__val[0], &target_stfs->f_fsid.val[0]);\n\n            put_user(stfs.f_fsid.__val[1], &target_stfs->f_fsid.val[1]);\n\n            put_user(stfs.f_namelen, &target_stfs->f_namelen);\n\n            unlock_user_struct(target_stfs, arg2, 1);\n\n        }\n\n        break;\n\n    case TARGET_NR_fstatfs:\n\n        ret = get_errno(fstatfs(arg1, &stfs));\n\n        goto convert_statfs;\n\n#ifdef TARGET_NR_statfs64\n\n    case TARGET_NR_statfs64:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(statfs(path(p), &stfs));\n\n        unlock_user(p, arg1, 0);\n\n    convert_statfs64:\n\n        if (!is_error(ret)) {\n\n            struct target_statfs64 *target_stfs;\n\n           \n\n            lock_user_struct(target_stfs, arg3, 0);\n\n            /* ??? put_user is probably wrong.  */\n\n            put_user(stfs.f_type, &target_stfs->f_type);\n\n            put_user(stfs.f_bsize, &target_stfs->f_bsize);\n\n            put_user(stfs.f_blocks, &target_stfs->f_blocks);\n\n            put_user(stfs.f_bfree, &target_stfs->f_bfree);\n\n            put_user(stfs.f_bavail, &target_stfs->f_bavail);\n\n            put_user(stfs.f_files, &target_stfs->f_files);\n\n            put_user(stfs.f_ffree, &target_stfs->f_ffree);\n\n            put_user(stfs.f_fsid.__val[0], &target_stfs->f_fsid.val[0]);\n\n            put_user(stfs.f_fsid.__val[1], &target_stfs->f_fsid.val[1]);\n\n            put_user(stfs.f_namelen, &target_stfs->f_namelen);\n\n            unlock_user_struct(target_stfs, arg3, 0);\n\n        }\n\n        break;\n\n    case TARGET_NR_fstatfs64:\n\n        ret = get_errno(fstatfs(arg1, &stfs));\n\n        goto convert_statfs64;\n\n#endif\n\n#ifdef TARGET_NR_ioperm\n\n    case TARGET_NR_ioperm:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_socketcall\n\n    case TARGET_NR_socketcall:\n\n        ret = do_socketcall(arg1, arg2);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_accept\n\n    case TARGET_NR_accept:\n\n        ret = do_accept(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_bind\n\n    case TARGET_NR_bind:\n\n        ret = do_bind(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_connect\n\n    case TARGET_NR_connect:\n\n        ret = do_connect(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getpeername\n\n    case TARGET_NR_getpeername:\n\n        ret = do_getpeername(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getsockname\n\n    case TARGET_NR_getsockname:\n\n        ret = do_getsockname(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getsockopt\n\n    case TARGET_NR_getsockopt:\n\n        ret = do_getsockopt(arg1, arg2, arg3, arg4, arg5);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_listen\n\n    case TARGET_NR_listen:\n\n        ret = get_errno(listen(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_recv\n\n    case TARGET_NR_recv:\n\n        ret = do_recvfrom(arg1, arg2, arg3, arg4, 0, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_recvfrom\n\n    case TARGET_NR_recvfrom:\n\n        ret = do_recvfrom(arg1, arg2, arg3, arg4, arg5, arg6);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_recvmsg\n\n    case TARGET_NR_recvmsg:\n\n        ret = do_sendrecvmsg(arg1, arg2, arg3, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_send\n\n    case TARGET_NR_send:\n\n        ret = do_sendto(arg1, arg2, arg3, arg4, 0, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sendmsg\n\n    case TARGET_NR_sendmsg:\n\n        ret = do_sendrecvmsg(arg1, arg2, arg3, 1);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sendto\n\n    case TARGET_NR_sendto:\n\n        ret = do_sendto(arg1, arg2, arg3, arg4, arg5, arg6);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shutdown\n\n    case TARGET_NR_shutdown:\n\n        ret = get_errno(shutdown(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_socket\n\n    case TARGET_NR_socket:\n\n        ret = do_socket(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_socketpair\n\n    case TARGET_NR_socketpair:\n\n        ret = do_socketpair(arg1, arg2, arg3, arg4);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setsockopt\n\n    case TARGET_NR_setsockopt:\n\n        ret = do_setsockopt(arg1, arg2, arg3, arg4, (socklen_t) arg5);\n\n        break;\n\n#endif\n\n\n\n    case TARGET_NR_syslog:\n\n        p = lock_user_string(arg2);\n\n        ret = get_errno(sys_syslog((int)arg1, p, (int)arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n\n\n    case TARGET_NR_setitimer:\n\n        {\n\n            struct itimerval value, ovalue, *pvalue;\n\n\n\n            if (arg2) {\n\n                pvalue = &value;\n\n                target_to_host_timeval(&pvalue->it_interval,\n\n                                       arg2);\n\n                target_to_host_timeval(&pvalue->it_value,\n\n                                       arg2 + sizeof(struct target_timeval));\n\n            } else {\n\n                pvalue = NULL;\n\n            }\n\n            ret = get_errno(setitimer(arg1, pvalue, &ovalue));\n\n            if (!is_error(ret) && arg3) {\n\n                host_to_target_timeval(arg3,\n\n                                       &ovalue.it_interval);\n\n                host_to_target_timeval(arg3 + sizeof(struct target_timeval),\n\n                                       &ovalue.it_value);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_getitimer:\n\n        {\n\n            struct itimerval value;\n\n           \n\n            ret = get_errno(getitimer(arg1, &value));\n\n            if (!is_error(ret) && arg2) {\n\n                host_to_target_timeval(arg2,\n\n                                       &value.it_interval);\n\n                host_to_target_timeval(arg2 + sizeof(struct target_timeval),\n\n                                       &value.it_value);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_stat:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(stat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        goto do_stat;\n\n    case TARGET_NR_lstat:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(lstat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        goto do_stat;\n\n    case TARGET_NR_fstat:\n\n        {\n\n            ret = get_errno(fstat(arg1, &st));\n\n        do_stat:\n\n            if (!is_error(ret)) {\n\n                struct target_stat *target_st;\n\n\n\n                lock_user_struct(target_st, arg2, 0);\n\n#if defined(TARGET_MIPS) || defined(TARGET_SPARC64)\n\n                target_st->st_dev = tswap32(st.st_dev);\n\n#else\n\n                target_st->st_dev = tswap16(st.st_dev);\n\n#endif\n\n                target_st->st_ino = tswapl(st.st_ino);\n\n#if defined(TARGET_PPC) || defined(TARGET_MIPS)\n\n                target_st->st_mode = tswapl(st.st_mode); /* XXX: check this */\n\n                target_st->st_uid = tswap32(st.st_uid);\n\n                target_st->st_gid = tswap32(st.st_gid);\n\n#elif defined(TARGET_SPARC64)\n\n                target_st->st_mode = tswap32(st.st_mode);\n\n                target_st->st_uid = tswap32(st.st_uid);\n\n                target_st->st_gid = tswap32(st.st_gid);\n\n#else\n\n                target_st->st_mode = tswap16(st.st_mode);\n\n                target_st->st_uid = tswap16(st.st_uid);\n\n                target_st->st_gid = tswap16(st.st_gid);\n\n#endif\n\n#if defined(TARGET_MIPS)\n\n\t\t/* If this is the same on PPC, then just merge w/ the above ifdef */\n\n                target_st->st_nlink = tswapl(st.st_nlink);\n\n                target_st->st_rdev = tswapl(st.st_rdev);\n\n#elif defined(TARGET_SPARC64)\n\n                target_st->st_nlink = tswap32(st.st_nlink);\n\n                target_st->st_rdev = tswap32(st.st_rdev);\n\n#else\n\n                target_st->st_nlink = tswap16(st.st_nlink);\n\n                target_st->st_rdev = tswap16(st.st_rdev);\n\n#endif\n\n                target_st->st_size = tswapl(st.st_size);\n\n                target_st->st_blksize = tswapl(st.st_blksize);\n\n                target_st->st_blocks = tswapl(st.st_blocks);\n\n                target_st->target_st_atime = tswapl(st.st_atime);\n\n                target_st->target_st_mtime = tswapl(st.st_mtime);\n\n                target_st->target_st_ctime = tswapl(st.st_ctime);\n\n                unlock_user_struct(target_st, arg2, 1);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_olduname\n\n    case TARGET_NR_olduname:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_iopl\n\n    case TARGET_NR_iopl:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_vhangup:\n\n        ret = get_errno(vhangup());\n\n        break;\n\n#ifdef TARGET_NR_idle\n\n    case TARGET_NR_idle:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_syscall\n\n    case TARGET_NR_syscall:\n\n    \tret = do_syscall(cpu_env,arg1 & 0xffff,arg2,arg3,arg4,arg5,arg6,0);\n\n    \tbreak;\n\n#endif\n\n    case TARGET_NR_wait4:\n\n        {\n\n            int status;\n\n            target_long status_ptr = arg2;\n\n            struct rusage rusage, *rusage_ptr;\n\n            target_ulong target_rusage = arg4;\n\n            if (target_rusage)\n\n                rusage_ptr = &rusage;\n\n            else\n\n                rusage_ptr = NULL;\n\n            ret = get_errno(wait4(arg1, &status, arg3, rusage_ptr));\n\n            if (!is_error(ret)) {\n\n                if (status_ptr)\n\n                    tputl(status_ptr, status);\n\n                if (target_rusage) {\n\n                    host_to_target_rusage(target_rusage, &rusage);\n\n                }\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_swapoff\n\n    case TARGET_NR_swapoff:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(swapoff(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_sysinfo:\n\n        {\n\n            struct target_sysinfo *target_value;\n\n            struct sysinfo value;\n\n            ret = get_errno(sysinfo(&value));\n\n            if (!is_error(ret) && arg1)\n\n            {\n\n                /* ??? __put_user is probably wrong.  */\n\n                lock_user_struct(target_value, arg1, 0);\n\n                __put_user(value.uptime, &target_value->uptime);\n\n                __put_user(value.loads[0], &target_value->loads[0]);\n\n                __put_user(value.loads[1], &target_value->loads[1]);\n\n                __put_user(value.loads[2], &target_value->loads[2]);\n\n                __put_user(value.totalram, &target_value->totalram);\n\n                __put_user(value.freeram, &target_value->freeram);\n\n                __put_user(value.sharedram, &target_value->sharedram);\n\n                __put_user(value.bufferram, &target_value->bufferram);\n\n                __put_user(value.totalswap, &target_value->totalswap);\n\n                __put_user(value.freeswap, &target_value->freeswap);\n\n                __put_user(value.procs, &target_value->procs);\n\n                __put_user(value.totalhigh, &target_value->totalhigh);\n\n                __put_user(value.freehigh, &target_value->freehigh);\n\n                __put_user(value.mem_unit, &target_value->mem_unit);\n\n                unlock_user_struct(target_value, arg1, 1);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_ipc\n\n    case TARGET_NR_ipc:\n\n\tret = do_ipc(arg1, arg2, arg3, arg4, arg5, arg6);\n\n\tbreak;\n\n#endif\n\n    case TARGET_NR_fsync:\n\n        ret = get_errno(fsync(arg1));\n\n        break;\n\n    case TARGET_NR_clone:\n\n        ret = get_errno(do_fork(cpu_env, arg1, arg2));\n\n        break;\n\n#ifdef __NR_exit_group\n\n        /* new thread calls */\n\n    case TARGET_NR_exit_group:\n\n        gdb_exit(cpu_env, arg1);\n\n        ret = get_errno(exit_group(arg1));\n\n        break;\n\n#endif\n\n    case TARGET_NR_setdomainname:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(setdomainname(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_uname:\n\n        /* no need to transcode because we use the linux syscall */\n\n        {\n\n            struct new_utsname * buf;\n\n   \n\n            lock_user_struct(buf, arg1, 0);\n\n            ret = get_errno(sys_uname(buf));\n\n            if (!is_error(ret)) {\n\n                /* Overrite the native machine name with whatever is being\n\n                   emulated. */\n\n                strcpy (buf->machine, UNAME_MACHINE);\n\n                /* Allow the user to override the reported release.  */\n\n                if (qemu_uname_release && *qemu_uname_release)\n\n                  strcpy (buf->release, qemu_uname_release);\n\n            }\n\n            unlock_user_struct(buf, arg1, 1);\n\n        }\n\n        break;\n\n#ifdef TARGET_I386\n\n    case TARGET_NR_modify_ldt:\n\n        ret = get_errno(do_modify_ldt(cpu_env, arg1, arg2, arg3));\n\n        break;\n\n#if !defined(TARGET_X86_64)\n\n    case TARGET_NR_vm86old:\n\n        goto unimplemented;\n\n    case TARGET_NR_vm86:\n\n        ret = do_vm86(cpu_env, arg1, arg2);\n\n        break;\n\n#endif\n\n#endif\n\n    case TARGET_NR_adjtimex:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_create_module\n\n    case TARGET_NR_create_module:\n\n#endif\n\n    case TARGET_NR_init_module:\n\n    case TARGET_NR_delete_module:\n\n#ifdef TARGET_NR_get_kernel_syms\n\n    case TARGET_NR_get_kernel_syms:\n\n#endif\n\n        goto unimplemented;\n\n    case TARGET_NR_quotactl:\n\n        goto unimplemented;\n\n    case TARGET_NR_getpgid:\n\n        ret = get_errno(getpgid(arg1));\n\n        break;\n\n    case TARGET_NR_fchdir:\n\n        ret = get_errno(fchdir(arg1));\n\n        break;\n\n#ifdef TARGET_NR_bdflush /* not on x86_64 */\n\n    case TARGET_NR_bdflush:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_sysfs\n\n    case TARGET_NR_sysfs:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_personality:\n\n        ret = get_errno(personality(arg1));\n\n        break;\n\n#ifdef TARGET_NR_afs_syscall\n\n    case TARGET_NR_afs_syscall:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR__llseek /* Not on alpha */\n\n    case TARGET_NR__llseek:\n\n        {\n\n#if defined (__x86_64__)\n\n            ret = get_errno(lseek(arg1, ((uint64_t )arg2 << 32) | arg3, arg5));\n\n            tput64(arg4, ret);\n\n#else\n\n            int64_t res;\n\n            ret = get_errno(_llseek(arg1, arg2, arg3, &res, arg5));\n\n            tput64(arg4, res);\n\n#endif\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_getdents:\n\n#if TARGET_LONG_SIZE != 4\n\n        goto unimplemented;\n\n#warning not supported\n\n#elif TARGET_LONG_SIZE == 4 && HOST_LONG_SIZE == 8\n\n        {\n\n            struct target_dirent *target_dirp;\n\n            struct dirent *dirp;\n\n            long count = arg3;\n\n\n\n\t    dirp = malloc(count);\n\n\t    if (!dirp)\n\n                return -ENOMEM;\n\n           \n\n            ret = get_errno(sys_getdents(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct dirent *de;\n\n\t\tstruct target_dirent *tde;\n\n                int len = ret;\n\n                int reclen, treclen;\n\n\t\tint count1, tnamelen;\n\n\n\n\t\tcount1 = 0;\n\n                de = dirp;\n\n                target_dirp = lock_user(arg2, count, 0);\n\n\t\ttde = target_dirp;\n\n                while (len > 0) {\n\n                    reclen = de->d_reclen;\n\n\t\t    treclen = reclen - (2 * (sizeof(long) - sizeof(target_long)));\n\n                    tde->d_reclen = tswap16(treclen);\n\n                    tde->d_ino = tswapl(de->d_ino);\n\n                    tde->d_off = tswapl(de->d_off);\n\n\t\t    tnamelen = treclen - (2 * sizeof(target_long) + 2);\n\n\t\t    if (tnamelen > 256)\n\n                        tnamelen = 256;\n\n                    /* XXX: may not be correct */\n\n\t\t    strncpy(tde->d_name, de->d_name, tnamelen);\n\n                    de = (struct dirent *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                    tde = (struct target_dirent *)((char *)tde + treclen);\n\n\t\t    count1 += treclen;\n\n                }\n\n\t\tret = count1;\n\n            }\n\n            unlock_user(target_dirp, arg2, ret);\n\n\t    free(dirp);\n\n        }\n\n#else\n\n        {\n\n            struct dirent *dirp;\n\n            long count = arg3;\n\n\n\n            dirp = lock_user(arg2, count, 0);\n\n            ret = get_errno(sys_getdents(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct dirent *de;\n\n                int len = ret;\n\n                int reclen;\n\n                de = dirp;\n\n                while (len > 0) {\n\n                    reclen = de->d_reclen;\n\n                    if (reclen > len)\n\n                        break;\n\n                    de->d_reclen = tswap16(reclen);\n\n                    tswapls(&de->d_ino);\n\n                    tswapls(&de->d_off);\n\n                    de = (struct dirent *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                }\n\n            }\n\n            unlock_user(dirp, arg2, ret);\n\n        }\n\n#endif\n\n        break;\n\n#ifdef TARGET_NR_getdents64\n\n    case TARGET_NR_getdents64:\n\n        {\n\n            struct dirent64 *dirp;\n\n            long count = arg3;\n\n            dirp = lock_user(arg2, count, 0);\n\n            ret = get_errno(sys_getdents64(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct dirent64 *de;\n\n                int len = ret;\n\n                int reclen;\n\n                de = dirp;\n\n                while (len > 0) {\n\n                    reclen = de->d_reclen;\n\n                    if (reclen > len)\n\n                        break;\n\n                    de->d_reclen = tswap16(reclen);\n\n                    tswap64s(&de->d_ino);\n\n                    tswap64s(&de->d_off);\n\n                    de = (struct dirent64 *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                }\n\n            }\n\n            unlock_user(dirp, arg2, ret);\n\n        }\n\n        break;\n\n#endif /* TARGET_NR_getdents64 */\n\n#ifdef TARGET_NR__newselect\n\n    case TARGET_NR__newselect:\n\n        ret = do_select(arg1, arg2, arg3, arg4, arg5);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_poll\n\n    case TARGET_NR_poll:\n\n        {\n\n            struct target_pollfd *target_pfd;\n\n            unsigned int nfds = arg2;\n\n            int timeout = arg3;\n\n            struct pollfd *pfd;\n\n            unsigned int i;\n\n\n\n            target_pfd = lock_user(arg1, sizeof(struct target_pollfd) * nfds, 1);\n\n            pfd = alloca(sizeof(struct pollfd) * nfds);\n\n            for(i = 0; i < nfds; i++) {\n\n                pfd[i].fd = tswap32(target_pfd[i].fd);\n\n                pfd[i].events = tswap16(target_pfd[i].events);\n\n            }\n\n            ret = get_errno(poll(pfd, nfds, timeout));\n\n            if (!is_error(ret)) {\n\n                for(i = 0; i < nfds; i++) {\n\n                    target_pfd[i].revents = tswap16(pfd[i].revents);\n\n                }\n\n                ret += nfds * (sizeof(struct target_pollfd)\n\n                               - sizeof(struct pollfd));\n\n            }\n\n            unlock_user(target_pfd, arg1, ret);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_flock:\n\n        /* NOTE: the flock constant seems to be the same for every\n\n           Linux platform */\n\n        ret = get_errno(flock(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_readv:\n\n        {\n\n            int count = arg3;\n\n            struct iovec *vec;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            lock_iovec(vec, arg2, count, 0);\n\n            ret = get_errno(readv(arg1, vec, count));\n\n            unlock_iovec(vec, arg2, count, 1);\n\n        }\n\n        break;\n\n    case TARGET_NR_writev:\n\n        {\n\n            int count = arg3;\n\n            struct iovec *vec;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            lock_iovec(vec, arg2, count, 1);\n\n            ret = get_errno(writev(arg1, vec, count));\n\n            unlock_iovec(vec, arg2, count, 0);\n\n        }\n\n        break;\n\n    case TARGET_NR_getsid:\n\n        ret = get_errno(getsid(arg1));\n\n        break;\n\n#if defined(TARGET_NR_fdatasync) /* Not on alpha (osf_datasync ?) */\n\n    case TARGET_NR_fdatasync:\n\n        ret = get_errno(fdatasync(arg1));\n\n        break;\n\n#endif\n\n    case TARGET_NR__sysctl:\n\n        /* We don't implement this, but ENODIR is always a safe\n\n           return value. */\n\n        return -ENOTDIR;\n\n    case TARGET_NR_sched_setparam:\n\n        {\n\n            struct sched_param *target_schp;\n\n            struct sched_param schp;\n\n\n\n            lock_user_struct(target_schp, arg2, 1);\n\n            schp.sched_priority = tswap32(target_schp->sched_priority);\n\n            unlock_user_struct(target_schp, arg2, 0);\n\n            ret = get_errno(sched_setparam(arg1, &schp));\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_getparam:\n\n        {\n\n            struct sched_param *target_schp;\n\n            struct sched_param schp;\n\n            ret = get_errno(sched_getparam(arg1, &schp));\n\n            if (!is_error(ret)) {\n\n                lock_user_struct(target_schp, arg2, 0);\n\n                target_schp->sched_priority = tswap32(schp.sched_priority);\n\n                unlock_user_struct(target_schp, arg2, 1);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_setscheduler:\n\n        {\n\n            struct sched_param *target_schp;\n\n            struct sched_param schp;\n\n            lock_user_struct(target_schp, arg3, 1);\n\n            schp.sched_priority = tswap32(target_schp->sched_priority);\n\n            unlock_user_struct(target_schp, arg3, 0);\n\n            ret = get_errno(sched_setscheduler(arg1, arg2, &schp));\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_getscheduler:\n\n        ret = get_errno(sched_getscheduler(arg1));\n\n        break;\n\n    case TARGET_NR_sched_yield:\n\n        ret = get_errno(sched_yield());\n\n        break;\n\n    case TARGET_NR_sched_get_priority_max:\n\n        ret = get_errno(sched_get_priority_max(arg1));\n\n        break;\n\n    case TARGET_NR_sched_get_priority_min:\n\n        ret = get_errno(sched_get_priority_min(arg1));\n\n        break;\n\n    case TARGET_NR_sched_rr_get_interval:\n\n        {\n\n            struct timespec ts;\n\n            ret = get_errno(sched_rr_get_interval(arg1, &ts));\n\n            if (!is_error(ret)) {\n\n                host_to_target_timespec(arg2, &ts);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_nanosleep:\n\n        {\n\n            struct timespec req, rem;\n\n            target_to_host_timespec(&req, arg1);\n\n            ret = get_errno(nanosleep(&req, &rem));\n\n            if (is_error(ret) && arg2) {\n\n                host_to_target_timespec(arg2, &rem);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_query_module\n\n    case TARGET_NR_query_module:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_nfsservctl\n\n    case TARGET_NR_nfsservctl:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_prctl:\n\n        switch (arg1)\n\n            {\n\n            case PR_GET_PDEATHSIG:\n\n                {\n\n                    int deathsig;\n\n                    ret = get_errno(prctl(arg1, &deathsig, arg3, arg4, arg5));\n\n                    if (!is_error(ret) && arg2)\n\n                        tput32(arg2, deathsig);\n\n                }\n\n                break;\n\n            default:\n\n                ret = get_errno(prctl(arg1, arg2, arg3, arg4, arg5));\n\n                break;\n\n            }\n\n        break;\n\n#ifdef TARGET_NR_pread\n\n    case TARGET_NR_pread:\n\n        page_unprotect_range(arg2, arg3);\n\n        p = lock_user(arg2, arg3, 0);\n\n        ret = get_errno(pread(arg1, p, arg3, arg4));\n\n        unlock_user(p, arg2, ret);\n\n        break;\n\n    case TARGET_NR_pwrite:\n\n        p = lock_user(arg2, arg3, 1);\n\n        ret = get_errno(pwrite(arg1, p, arg3, arg4));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_getcwd:\n\n        p = lock_user(arg1, arg2, 0);\n\n        ret = get_errno(sys_getcwd1(p, arg2));\n\n        unlock_user(p, arg1, ret);\n\n        break;\n\n    case TARGET_NR_capget:\n\n        goto unimplemented;\n\n    case TARGET_NR_capset:\n\n        goto unimplemented;\n\n    case TARGET_NR_sigaltstack:\n\n        goto unimplemented;\n\n    case TARGET_NR_sendfile:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_getpmsg\n\n    case TARGET_NR_getpmsg:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_putpmsg\n\n    case TARGET_NR_putpmsg:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_vfork\n\n    case TARGET_NR_vfork:\n\n        ret = get_errno(do_fork(cpu_env, CLONE_VFORK | CLONE_VM | SIGCHLD, 0));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_ugetrlimit\n\n    case TARGET_NR_ugetrlimit:\n\n    {\n\n\tstruct rlimit rlim;\n\n\tret = get_errno(getrlimit(arg1, &rlim));\n\n\tif (!is_error(ret)) {\n\n\t    struct target_rlimit *target_rlim;\n\n            lock_user_struct(target_rlim, arg2, 0);\n\n\t    target_rlim->rlim_cur = tswapl(rlim.rlim_cur);\n\n\t    target_rlim->rlim_max = tswapl(rlim.rlim_max);\n\n            unlock_user_struct(target_rlim, arg2, 1);\n\n\t}\n\n\tbreak;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_truncate64\n\n    case TARGET_NR_truncate64:\n\n        p = lock_user_string(arg1);\n\n\tret = target_truncate64(cpu_env, p, arg2, arg3, arg4);\n\n        unlock_user(p, arg1, 0);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_ftruncate64\n\n    case TARGET_NR_ftruncate64:\n\n\tret = target_ftruncate64(cpu_env, arg1, arg2, arg3, arg4);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_stat64\n\n    case TARGET_NR_stat64:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(stat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        goto do_stat64;\n\n#endif\n\n#ifdef TARGET_NR_lstat64\n\n    case TARGET_NR_lstat64:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(lstat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        goto do_stat64;\n\n#endif\n\n#ifdef TARGET_NR_fstat64\n\n    case TARGET_NR_fstat64:\n\n        {\n\n            ret = get_errno(fstat(arg1, &st));\n\n        do_stat64:\n\n            if (!is_error(ret)) {\n\n#ifdef TARGET_ARM\n\n                if (((CPUARMState *)cpu_env)->eabi) {\n\n                    struct target_eabi_stat64 *target_st;\n\n                    lock_user_struct(target_st, arg2, 1);\n\n                    memset(target_st, 0, sizeof(struct target_eabi_stat64));\n\n                    /* put_user is probably wrong.  */\n\n                    put_user(st.st_dev, &target_st->st_dev);\n\n                    put_user(st.st_ino, &target_st->st_ino);\n\n#ifdef TARGET_STAT64_HAS_BROKEN_ST_INO\n\n                    put_user(st.st_ino, &target_st->__st_ino);\n\n#endif\n\n                    put_user(st.st_mode, &target_st->st_mode);\n\n                    put_user(st.st_nlink, &target_st->st_nlink);\n\n                    put_user(st.st_uid, &target_st->st_uid);\n\n                    put_user(st.st_gid, &target_st->st_gid);\n\n                    put_user(st.st_rdev, &target_st->st_rdev);\n\n                    /* XXX: better use of kernel struct */\n\n                    put_user(st.st_size, &target_st->st_size);\n\n                    put_user(st.st_blksize, &target_st->st_blksize);\n\n                    put_user(st.st_blocks, &target_st->st_blocks);\n\n                    put_user(st.st_atime, &target_st->target_st_atime);\n\n                    put_user(st.st_mtime, &target_st->target_st_mtime);\n\n                    put_user(st.st_ctime, &target_st->target_st_ctime);\n\n                    unlock_user_struct(target_st, arg2, 0);\n\n                } else\n\n#endif\n\n                {\n\n                    struct target_stat64 *target_st;\n\n                    lock_user_struct(target_st, arg2, 1);\n\n                    memset(target_st, 0, sizeof(struct target_stat64));\n\n                    /* ??? put_user is probably wrong.  */\n\n                    put_user(st.st_dev, &target_st->st_dev);\n\n                    put_user(st.st_ino, &target_st->st_ino);\n\n#ifdef TARGET_STAT64_HAS_BROKEN_ST_INO\n\n                    put_user(st.st_ino, &target_st->__st_ino);\n\n#endif\n\n                    put_user(st.st_mode, &target_st->st_mode);\n\n                    put_user(st.st_nlink, &target_st->st_nlink);\n\n                    put_user(st.st_uid, &target_st->st_uid);\n\n                    put_user(st.st_gid, &target_st->st_gid);\n\n                    put_user(st.st_rdev, &target_st->st_rdev);\n\n                    /* XXX: better use of kernel struct */\n\n                    put_user(st.st_size, &target_st->st_size);\n\n                    put_user(st.st_blksize, &target_st->st_blksize);\n\n                    put_user(st.st_blocks, &target_st->st_blocks);\n\n                    put_user(st.st_atime, &target_st->target_st_atime);\n\n                    put_user(st.st_mtime, &target_st->target_st_mtime);\n\n                    put_user(st.st_ctime, &target_st->target_st_ctime);\n\n                    unlock_user_struct(target_st, arg2, 0);\n\n                }\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef USE_UID16\n\n    case TARGET_NR_lchown:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(lchown(p, low2highuid(arg2), low2highgid(arg3)));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_getuid:\n\n        ret = get_errno(high2lowuid(getuid()));\n\n        break;\n\n    case TARGET_NR_getgid:\n\n        ret = get_errno(high2lowgid(getgid()));\n\n        break;\n\n    case TARGET_NR_geteuid:\n\n        ret = get_errno(high2lowuid(geteuid()));\n\n        break;\n\n    case TARGET_NR_getegid:\n\n        ret = get_errno(high2lowgid(getegid()));\n\n        break;\n\n    case TARGET_NR_setreuid:\n\n        ret = get_errno(setreuid(low2highuid(arg1), low2highuid(arg2)));\n\n        break;\n\n    case TARGET_NR_setregid:\n\n        ret = get_errno(setregid(low2highgid(arg1), low2highgid(arg2)));\n\n        break;\n\n    case TARGET_NR_getgroups:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint16_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            ret = get_errno(getgroups(gidsetsize, grouplist));\n\n            if (!is_error(ret)) {\n\n                target_grouplist = lock_user(arg2, gidsetsize * 2, 0);\n\n                for(i = 0;i < gidsetsize; i++)\n\n                    target_grouplist[i] = tswap16(grouplist[i]);\n\n                unlock_user(target_grouplist, arg2, gidsetsize * 2);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_setgroups:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint16_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            target_grouplist = lock_user(arg2, gidsetsize * 2, 1);\n\n            for(i = 0;i < gidsetsize; i++)\n\n                grouplist[i] = tswap16(target_grouplist[i]);\n\n            unlock_user(target_grouplist, arg2, 0);\n\n            ret = get_errno(setgroups(gidsetsize, grouplist));\n\n        }\n\n        break;\n\n    case TARGET_NR_fchown:\n\n        ret = get_errno(fchown(arg1, low2highuid(arg2), low2highgid(arg3)));\n\n        break;\n\n#ifdef TARGET_NR_setresuid\n\n    case TARGET_NR_setresuid:\n\n        ret = get_errno(setresuid(low2highuid(arg1),\n\n                                  low2highuid(arg2),\n\n                                  low2highuid(arg3)));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresuid\n\n    case TARGET_NR_getresuid:\n\n        {\n\n            uid_t ruid, euid, suid;\n\n            ret = get_errno(getresuid(&ruid, &euid, &suid));\n\n            if (!is_error(ret)) {\n\n                tput16(arg1, tswap16(high2lowuid(ruid)));\n\n                tput16(arg2, tswap16(high2lowuid(euid)));\n\n                tput16(arg3, tswap16(high2lowuid(suid)));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresgid\n\n    case TARGET_NR_setresgid:\n\n        ret = get_errno(setresgid(low2highgid(arg1),\n\n                                  low2highgid(arg2),\n\n                                  low2highgid(arg3)));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresgid\n\n    case TARGET_NR_getresgid:\n\n        {\n\n            gid_t rgid, egid, sgid;\n\n            ret = get_errno(getresgid(&rgid, &egid, &sgid));\n\n            if (!is_error(ret)) {\n\n                tput16(arg1, tswap16(high2lowgid(rgid)));\n\n                tput16(arg2, tswap16(high2lowgid(egid)));\n\n                tput16(arg3, tswap16(high2lowgid(sgid)));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_chown:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(chown(p, low2highuid(arg2), low2highgid(arg3)));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_setuid:\n\n        ret = get_errno(setuid(low2highuid(arg1)));\n\n        break;\n\n    case TARGET_NR_setgid:\n\n        ret = get_errno(setgid(low2highgid(arg1)));\n\n        break;\n\n    case TARGET_NR_setfsuid:\n\n        ret = get_errno(setfsuid(arg1));\n\n        break;\n\n    case TARGET_NR_setfsgid:\n\n        ret = get_errno(setfsgid(arg1));\n\n        break;\n\n#endif /* USE_UID16 */\n\n\n\n#ifdef TARGET_NR_lchown32\n\n    case TARGET_NR_lchown32:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(lchown(p, arg2, arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getuid32\n\n    case TARGET_NR_getuid32:\n\n        ret = get_errno(getuid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getgid32\n\n    case TARGET_NR_getgid32:\n\n        ret = get_errno(getgid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_geteuid32\n\n    case TARGET_NR_geteuid32:\n\n        ret = get_errno(geteuid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getegid32\n\n    case TARGET_NR_getegid32:\n\n        ret = get_errno(getegid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setreuid32\n\n    case TARGET_NR_setreuid32:\n\n        ret = get_errno(setreuid(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setregid32\n\n    case TARGET_NR_setregid32:\n\n        ret = get_errno(setregid(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getgroups32\n\n    case TARGET_NR_getgroups32:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint32_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            ret = get_errno(getgroups(gidsetsize, grouplist));\n\n            if (!is_error(ret)) {\n\n                target_grouplist = lock_user(arg2, gidsetsize * 4, 0);\n\n                for(i = 0;i < gidsetsize; i++)\n\n                    target_grouplist[i] = tswap32(grouplist[i]);\n\n                unlock_user(target_grouplist, arg2, gidsetsize * 4);\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setgroups32\n\n    case TARGET_NR_setgroups32:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint32_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n           \n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            target_grouplist = lock_user(arg2, gidsetsize * 4, 1);\n\n            for(i = 0;i < gidsetsize; i++)\n\n                grouplist[i] = tswap32(target_grouplist[i]);\n\n            unlock_user(target_grouplist, arg2, 0);\n\n            ret = get_errno(setgroups(gidsetsize, grouplist));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_fchown32\n\n    case TARGET_NR_fchown32:\n\n        ret = get_errno(fchown(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setresuid32\n\n    case TARGET_NR_setresuid32:\n\n        ret = get_errno(setresuid(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresuid32\n\n    case TARGET_NR_getresuid32:\n\n        {\n\n            uid_t ruid, euid, suid;\n\n            ret = get_errno(getresuid(&ruid, &euid, &suid));\n\n            if (!is_error(ret)) {\n\n                tput32(arg1, tswap32(ruid));\n\n                tput32(arg2, tswap32(euid));\n\n                tput32(arg3, tswap32(suid));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setresgid32\n\n    case TARGET_NR_setresgid32:\n\n        ret = get_errno(setresgid(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresgid32\n\n    case TARGET_NR_getresgid32:\n\n        {\n\n            gid_t rgid, egid, sgid;\n\n            ret = get_errno(getresgid(&rgid, &egid, &sgid));\n\n            if (!is_error(ret)) {\n\n                tput32(arg1, tswap32(rgid));\n\n                tput32(arg2, tswap32(egid));\n\n                tput32(arg3, tswap32(sgid));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_chown32\n\n    case TARGET_NR_chown32:\n\n        p = lock_user_string(arg1);\n\n        ret = get_errno(chown(p, arg2, arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setuid32\n\n    case TARGET_NR_setuid32:\n\n        ret = get_errno(setuid(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setgid32\n\n    case TARGET_NR_setgid32:\n\n        ret = get_errno(setgid(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setfsuid32\n\n    case TARGET_NR_setfsuid32:\n\n        ret = get_errno(setfsuid(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setfsgid32\n\n    case TARGET_NR_setfsgid32:\n\n        ret = get_errno(setfsgid(arg1));\n\n        break;\n\n#endif\n\n\n\n    case TARGET_NR_pivot_root:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_mincore\n\n    case TARGET_NR_mincore:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_madvise\n\n    case TARGET_NR_madvise:\n\n        /* A straight passthrough may not be safe because qemu sometimes\n\n           turns private flie-backed mappings into anonymous mappings.\n\n           This will break MADV_DONTNEED.\n\n           This is a hint, so ignoring and returning success is ok.  */\n\n        ret = get_errno(0);\n\n        break;\n\n#endif\n\n#if TARGET_LONG_BITS == 32\n\n    case TARGET_NR_fcntl64:\n\n    {\n\n\tint cmd;\n\n\tstruct flock64 fl;\n\n\tstruct target_flock64 *target_fl;\n\n#ifdef TARGET_ARM\n\n\tstruct target_eabi_flock64 *target_efl;\n\n#endif\n\n\n\n        switch(arg2){\n\n        case TARGET_F_GETLK64:\n\n            cmd = F_GETLK64;\n\n            break;\n\n        case TARGET_F_SETLK64:\n\n            cmd = F_SETLK64;\n\n            break;\n\n        case TARGET_F_SETLKW64:\n\n            cmd = F_SETLK64;\n\n            break;\n\n        default:\n\n            cmd = arg2;\n\n            break;\n\n        }\n\n\n\n        switch(arg2) {\n\n        case TARGET_F_GETLK64:\n\n#ifdef TARGET_ARM\n\n            if (((CPUARMState *)cpu_env)->eabi) {\n\n                lock_user_struct(target_efl, arg3, 1);\n\n                fl.l_type = tswap16(target_efl->l_type);\n\n                fl.l_whence = tswap16(target_efl->l_whence);\n\n                fl.l_start = tswap64(target_efl->l_start);\n\n                fl.l_len = tswap64(target_efl->l_len);\n\n                fl.l_pid = tswapl(target_efl->l_pid);\n\n                unlock_user_struct(target_efl, arg3, 0);\n\n            } else\n\n#endif\n\n            {\n\n                lock_user_struct(target_fl, arg3, 1);\n\n                fl.l_type = tswap16(target_fl->l_type);\n\n                fl.l_whence = tswap16(target_fl->l_whence);\n\n                fl.l_start = tswap64(target_fl->l_start);\n\n                fl.l_len = tswap64(target_fl->l_len);\n\n                fl.l_pid = tswapl(target_fl->l_pid);\n\n                unlock_user_struct(target_fl, arg3, 0);\n\n            }\n\n            ret = get_errno(fcntl(arg1, cmd, &fl));\n\n\t    if (ret == 0) {\n\n#ifdef TARGET_ARM\n\n                if (((CPUARMState *)cpu_env)->eabi) {\n\n                    lock_user_struct(target_efl, arg3, 0);\n\n                    target_efl->l_type = tswap16(fl.l_type);\n\n                    target_efl->l_whence = tswap16(fl.l_whence);\n\n                    target_efl->l_start = tswap64(fl.l_start);\n\n                    target_efl->l_len = tswap64(fl.l_len);\n\n                    target_efl->l_pid = tswapl(fl.l_pid);\n\n                    unlock_user_struct(target_efl, arg3, 1);\n\n                } else\n\n#endif\n\n                {\n\n                    lock_user_struct(target_fl, arg3, 0);\n\n                    target_fl->l_type = tswap16(fl.l_type);\n\n                    target_fl->l_whence = tswap16(fl.l_whence);\n\n                    target_fl->l_start = tswap64(fl.l_start);\n\n                    target_fl->l_len = tswap64(fl.l_len);\n\n                    target_fl->l_pid = tswapl(fl.l_pid);\n\n                    unlock_user_struct(target_fl, arg3, 1);\n\n                }\n\n\t    }\n\n\t    break;\n\n\n\n        case TARGET_F_SETLK64:\n\n        case TARGET_F_SETLKW64:\n\n#ifdef TARGET_ARM\n\n            if (((CPUARMState *)cpu_env)->eabi) {\n\n                lock_user_struct(target_efl, arg3, 1);\n\n                fl.l_type = tswap16(target_efl->l_type);\n\n                fl.l_whence = tswap16(target_efl->l_whence);\n\n                fl.l_start = tswap64(target_efl->l_start);\n\n                fl.l_len = tswap64(target_efl->l_len);\n\n                fl.l_pid = tswapl(target_efl->l_pid);\n\n                unlock_user_struct(target_efl, arg3, 0);\n\n            } else\n\n#endif\n\n            {\n\n                lock_user_struct(target_fl, arg3, 1);\n\n                fl.l_type = tswap16(target_fl->l_type);\n\n                fl.l_whence = tswap16(target_fl->l_whence);\n\n                fl.l_start = tswap64(target_fl->l_start);\n\n                fl.l_len = tswap64(target_fl->l_len);\n\n                fl.l_pid = tswapl(target_fl->l_pid);\n\n                unlock_user_struct(target_fl, arg3, 0);\n\n            }\n\n            ret = get_errno(fcntl(arg1, cmd, &fl));\n\n\t    break;\n\n        default:\n\n            ret = get_errno(do_fcntl(arg1, cmd, arg3));\n\n            break;\n\n        }\n\n\tbreak;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_cacheflush\n\n    case TARGET_NR_cacheflush:\n\n        /* self-modifying code is handled automatically, so nothing needed */\n\n        ret = 0;\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_security\n\n    case TARGET_NR_security:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_getpagesize\n\n    case TARGET_NR_getpagesize:\n\n        ret = TARGET_PAGE_SIZE;\n\n        break;\n\n#endif\n\n    case TARGET_NR_gettid:\n\n        ret = get_errno(gettid());\n\n        break;\n\n#ifdef TARGET_NR_readahead\n\n    case TARGET_NR_readahead:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_setxattr\n\n    case TARGET_NR_setxattr:\n\n    case TARGET_NR_lsetxattr:\n\n    case TARGET_NR_fsetxattr:\n\n    case TARGET_NR_getxattr:\n\n    case TARGET_NR_lgetxattr:\n\n    case TARGET_NR_fgetxattr:\n\n    case TARGET_NR_listxattr:\n\n    case TARGET_NR_llistxattr:\n\n    case TARGET_NR_flistxattr:\n\n    case TARGET_NR_removexattr:\n\n    case TARGET_NR_lremovexattr:\n\n    case TARGET_NR_fremovexattr:\n\n        goto unimplemented_nowarn;\n\n#endif\n\n#ifdef TARGET_NR_set_thread_area\n\n    case TARGET_NR_set_thread_area:\n\n#ifdef TARGET_MIPS\n\n      ((CPUMIPSState *) cpu_env)->tls_value = arg1;\n\n      ret = 0;\n\n      break;\n\n#else\n\n      goto unimplemented_nowarn;\n\n#endif\n\n#endif\n\n#ifdef TARGET_NR_get_thread_area\n\n    case TARGET_NR_get_thread_area:\n\n        goto unimplemented_nowarn;\n\n#endif\n\n#ifdef TARGET_NR_getdomainname\n\n    case TARGET_NR_getdomainname:\n\n        goto unimplemented_nowarn;\n\n#endif\n\n\n\n#ifdef TARGET_NR_clock_gettime\n\n    case TARGET_NR_clock_gettime:\n\n    {\n\n        struct timespec ts;\n\n        ret = get_errno(clock_gettime(arg1, &ts));\n\n        if (!is_error(ret)) {\n\n            host_to_target_timespec(arg2, &ts);\n\n        }\n\n        break;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_clock_getres\n\n    case TARGET_NR_clock_getres:\n\n    {\n\n        struct timespec ts;\n\n        ret = get_errno(clock_getres(arg1, &ts));\n\n        if (!is_error(ret)) {\n\n            host_to_target_timespec(arg2, &ts);\n\n        }\n\n        break;\n\n    }\n\n#endif\n\n\n\n#if defined(TARGET_NR_set_tid_address) && defined(__NR_set_tid_address)\n\n    case TARGET_NR_set_tid_address:\n\n      ret = get_errno(set_tid_address((int *) arg1));\n\n      break;\n\n#endif\n\n\n\n#ifdef TARGET_NR_tkill\n\n    case TARGET_NR_tkill:\n\n        ret = get_errno(sys_tkill((int)arg1, (int)arg2));\n\n        break;\n\n#endif\n\n\n\n#ifdef TARGET_NR_tgkill\n\n    case TARGET_NR_tgkill:\n\n\tret = get_errno(sys_tgkill((int)arg1, (int)arg2, (int)arg3));\n\n\tbreak;\n\n#endif\n\n\n\n#ifdef TARGET_NR_set_robust_list\n\n    case TARGET_NR_set_robust_list:\n\n\tgoto unimplemented_nowarn;\n\n#endif\n\n\n\n    default:\n\n    unimplemented:\n\n        gemu_log(\"qemu: Unsupported syscall: %d\\n\", num);\n\n#if defined(TARGET_NR_setxattr) || defined(TARGET_NR_get_thread_area) || defined(TARGET_NR_getdomainname) || defined(TARGET_NR_set_robust_list)\n\n    unimplemented_nowarn:\n\n#endif\n\n        ret = -ENOSYS;\n\n        break;\n\n    }\n\n fail:\n\n#ifdef DEBUG\n\n    gemu_log(\" = %ld\\n\", ret);\n\n#endif\n\n    return ret;\n\n}\n", "idx": 22084}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "void unix_start_outgoing_migration(MigrationState *s,\n\n                                   const char *path,\n\n                                   Error **errp)\n\n{\n\n    SocketAddressLegacy *saddr = unix_build_address(path);\n\n    socket_start_outgoing_migration(s, saddr, errp);\n\n}\n", "idx": 22085}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)\n\n{\n\n    struct kvm_signal_mask *sigmask;\n\n    int r;\n\n\n\n    if (!sigset)\n\n        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);\n\n\n\n    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));\n\n\n\n    sigmask->len = 8;\n\n    memcpy(sigmask->sigset, sigset, sizeof(*sigset));\n\n    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);\n\n    free(sigmask);\n\n\n\n    return r;\n\n}\n", "idx": 22094}
{"project": "qemu", "commit_id": "3eff1f46f08a360a4ae9f834ce9fef4c45bf6f0f", "target": 0, "func": "static VirtIOSCSIReq *virtio_scsi_init_req(VirtIOSCSI *s, VirtQueue *vq)\n\n{\n\n    VirtIOSCSIReq *req;\n\n    req = g_malloc(sizeof(*req));\n\n\n\n    req->vq = vq;\n\n    req->dev = s;\n\n    req->sreq = NULL;\n\n    qemu_sglist_init(&req->qsgl, DEVICE(s), 8, &address_space_memory);\n\n    return req;\n\n}\n", "idx": 22096}
{"project": "qemu", "commit_id": "5b8d7289e9e92a0d7bcecb93cd189e245fef10cd", "target": 0, "func": "static bool insn_crosses_page(CPUARMState *env, DisasContext *s)\n\n{\n\n    /* Return true if the insn at dc->pc might cross a page boundary.\n\n     * (False positives are OK, false negatives are not.)\n\n     */\n\n    uint16_t insn;\n\n\n\n    if ((s->pc & 3) == 0) {\n\n        /* At a 4-aligned address we can't be crossing a page */\n\n        return false;\n\n    }\n\n\n\n    /* This must be a Thumb insn */\n\n    insn = arm_lduw_code(env, s->pc, s->sctlr_b);\n\n\n\n    if ((insn >> 11) >= 0x1d) {\n\n        /* Top five bits 0b11101 / 0b11110 / 0b11111 : this is the\n\n         * First half of a 32-bit Thumb insn. Thumb-1 cores might\n\n         * end up actually treating this as two 16-bit insns (see the\n\n         * code at the start of disas_thumb2_insn()) but we don't bother\n\n         * to check for that as it is unlikely, and false positives here\n\n         * are harmless.\n\n         */\n\n        return true;\n\n    }\n\n    /* Definitely a 16-bit insn, can't be crossing a page. */\n\n    return false;\n\n}\n", "idx": 22097}
{"project": "qemu", "commit_id": "1eeb5c7deacbfb4d4cad17590a16a99f3d85eabb", "target": 0, "func": "static void bcm2835_peripherals_realize(DeviceState *dev, Error **errp)\n\n{\n\n    BCM2835PeripheralState *s = BCM2835_PERIPHERALS(dev);\n\n    Object *obj;\n\n    MemoryRegion *ram;\n\n    Error *err = NULL;\n\n    uint32_t ram_size, vcram_size;\n\n    int n;\n\n\n\n    obj = object_property_get_link(OBJECT(dev), \"ram\", &err);\n\n    if (obj == NULL) {\n\n        error_setg(errp, \"%s: required ram link not found: %s\",\n\n                   __func__, error_get_pretty(err));\n\n        return;\n\n    }\n\n\n\n    ram = MEMORY_REGION(obj);\n\n    ram_size = memory_region_size(ram);\n\n\n\n    /* Map peripherals and RAM into the GPU address space. */\n\n    memory_region_init_alias(&s->peri_mr_alias, OBJECT(s),\n\n                             \"bcm2835-peripherals\", &s->peri_mr, 0,\n\n                             memory_region_size(&s->peri_mr));\n\n\n\n    memory_region_add_subregion_overlap(&s->gpu_bus_mr, BCM2835_VC_PERI_BASE,\n\n                                        &s->peri_mr_alias, 1);\n\n\n\n    /* RAM is aliased four times (different cache configurations) on the GPU */\n\n    for (n = 0; n < 4; n++) {\n\n        memory_region_init_alias(&s->ram_alias[n], OBJECT(s),\n\n                                 \"bcm2835-gpu-ram-alias[*]\", ram, 0, ram_size);\n\n        memory_region_add_subregion_overlap(&s->gpu_bus_mr, (hwaddr)n << 30,\n\n                                            &s->ram_alias[n], 0);\n\n    }\n\n\n\n    /* Interrupt Controller */\n\n    object_property_set_bool(OBJECT(&s->ic), true, \"realized\", &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n\n\n    memory_region_add_subregion(&s->peri_mr, ARMCTRL_IC_OFFSET,\n\n                sysbus_mmio_get_region(SYS_BUS_DEVICE(&s->ic), 0));\n\n    sysbus_pass_irq(SYS_BUS_DEVICE(s), SYS_BUS_DEVICE(&s->ic));\n\n\n\n    /* UART0 */\n\n    qdev_prop_set_chr(DEVICE(s->uart0), \"chardev\", serial_hds[0]);\n\n    object_property_set_bool(OBJECT(s->uart0), true, \"realized\", &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n\n\n    memory_region_add_subregion(&s->peri_mr, UART0_OFFSET,\n\n                                sysbus_mmio_get_region(s->uart0, 0));\n\n    sysbus_connect_irq(s->uart0, 0,\n\n        qdev_get_gpio_in_named(DEVICE(&s->ic), BCM2835_IC_GPU_IRQ,\n\n                               INTERRUPT_UART));\n\n    /* AUX / UART1 */\n\n    qdev_prop_set_chr(DEVICE(&s->aux), \"chardev\", serial_hds[1]);\n\n\n\n    object_property_set_bool(OBJECT(&s->aux), true, \"realized\", &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n\n\n    memory_region_add_subregion(&s->peri_mr, UART1_OFFSET,\n\n                sysbus_mmio_get_region(SYS_BUS_DEVICE(&s->aux), 0));\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(&s->aux), 0,\n\n        qdev_get_gpio_in_named(DEVICE(&s->ic), BCM2835_IC_GPU_IRQ,\n\n                               INTERRUPT_AUX));\n\n\n\n    /* Mailboxes */\n\n    object_property_set_bool(OBJECT(&s->mboxes), true, \"realized\", &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n\n\n    memory_region_add_subregion(&s->peri_mr, ARMCTRL_0_SBM_OFFSET,\n\n                sysbus_mmio_get_region(SYS_BUS_DEVICE(&s->mboxes), 0));\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(&s->mboxes), 0,\n\n        qdev_get_gpio_in_named(DEVICE(&s->ic), BCM2835_IC_ARM_IRQ,\n\n                               INTERRUPT_ARM_MAILBOX));\n\n\n\n    /* Framebuffer */\n\n    vcram_size = (uint32_t)object_property_get_int(OBJECT(s), \"vcram-size\",\n\n                                                   &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n\n\n    object_property_set_int(OBJECT(&s->fb), ram_size - vcram_size,\n\n                            \"vcram-base\", &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n\n\n    object_property_set_bool(OBJECT(&s->fb), true, \"realized\", &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n\n\n    memory_region_add_subregion(&s->mbox_mr, MBOX_CHAN_FB << MBOX_AS_CHAN_SHIFT,\n\n                sysbus_mmio_get_region(SYS_BUS_DEVICE(&s->fb), 0));\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(&s->fb), 0,\n\n                       qdev_get_gpio_in(DEVICE(&s->mboxes), MBOX_CHAN_FB));\n\n\n\n    /* Property channel */\n\n    object_property_set_bool(OBJECT(&s->property), true, \"realized\", &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n\n\n    memory_region_add_subregion(&s->mbox_mr,\n\n                MBOX_CHAN_PROPERTY << MBOX_AS_CHAN_SHIFT,\n\n                sysbus_mmio_get_region(SYS_BUS_DEVICE(&s->property), 0));\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(&s->property), 0,\n\n                      qdev_get_gpio_in(DEVICE(&s->mboxes), MBOX_CHAN_PROPERTY));\n\n\n\n    /* Random Number Generator */\n\n    object_property_set_bool(OBJECT(&s->rng), true, \"realized\", &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n\n\n    memory_region_add_subregion(&s->peri_mr, RNG_OFFSET,\n\n                sysbus_mmio_get_region(SYS_BUS_DEVICE(&s->rng), 0));\n\n\n\n    /* Extended Mass Media Controller */\n\n    object_property_set_int(OBJECT(&s->sdhci), BCM2835_SDHC_CAPAREG, \"capareg\",\n\n                            &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n\n\n    object_property_set_bool(OBJECT(&s->sdhci), true, \"pending-insert-quirk\",\n\n                             &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n\n\n    object_property_set_bool(OBJECT(&s->sdhci), true, \"realized\", &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n\n\n    memory_region_add_subregion(&s->peri_mr, EMMC_OFFSET,\n\n                sysbus_mmio_get_region(SYS_BUS_DEVICE(&s->sdhci), 0));\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(&s->sdhci), 0,\n\n        qdev_get_gpio_in_named(DEVICE(&s->ic), BCM2835_IC_GPU_IRQ,\n\n                               INTERRUPT_ARASANSDIO));\n\n    object_property_add_alias(OBJECT(s), \"sd-bus\", OBJECT(&s->sdhci), \"sd-bus\",\n\n                              &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n\n\n    /* DMA Channels */\n\n    object_property_set_bool(OBJECT(&s->dma), true, \"realized\", &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n\n\n    memory_region_add_subregion(&s->peri_mr, DMA_OFFSET,\n\n                sysbus_mmio_get_region(SYS_BUS_DEVICE(&s->dma), 0));\n\n    memory_region_add_subregion(&s->peri_mr, DMA15_OFFSET,\n\n                sysbus_mmio_get_region(SYS_BUS_DEVICE(&s->dma), 1));\n\n\n\n    for (n = 0; n <= 12; n++) {\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(&s->dma), n,\n\n                           qdev_get_gpio_in_named(DEVICE(&s->ic),\n\n                                                  BCM2835_IC_GPU_IRQ,\n\n                                                  INTERRUPT_DMA0 + n));\n\n    }\n\n}\n", "idx": 22098}
{"project": "qemu", "commit_id": "0ce470cd4ca88e84e547a3b95159d23ce6be419e", "target": 0, "func": "static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)\n\n{\n\n    CPUState *cs = CPU(dev);\n\n    PowerPCCPU *cpu = POWERPC_CPU(dev);\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);\n\n    Error *local_err = NULL;\n\n#if !defined(CONFIG_USER_ONLY)\n\n    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;\n\n#endif\n\n\n\n#if !defined(CONFIG_USER_ONLY)\n\n    if (smp_threads > max_smt) {\n\n        error_setg(errp, \"Cannot support more than %d threads on PPC with %s\",\n\n                   max_smt, kvm_enabled() ? \"KVM\" : \"TCG\");\n\n        return;\n\n    }\n\n#endif\n\n\n\n    if (kvm_enabled()) {\n\n        if (kvmppc_fixup_cpu(cpu) != 0) {\n\n            error_setg(errp, \"Unable to virtualize selected CPU with KVM\");\n\n            return;\n\n        }\n\n    } else if (tcg_enabled()) {\n\n        if (ppc_fixup_cpu(cpu) != 0) {\n\n            error_setg(errp, \"Unable to emulate selected CPU with TCG\");\n\n            return;\n\n        }\n\n    }\n\n\n\n#if defined(TARGET_PPCEMB)\n\n    if (!ppc_cpu_is_valid(pcc)) {\n\n        error_setg(errp, \"CPU does not possess a BookE or 4xx MMU. \"\n\n                   \"Please use qemu-system-ppc or qemu-system-ppc64 instead \"\n\n                   \"or choose another CPU model.\");\n\n        return;\n\n    }\n\n#endif\n\n\n\n    create_ppc_opcodes(cpu, &local_err);\n\n    if (local_err != NULL) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n    init_ppc_proc(cpu);\n\n\n\n    if (pcc->insns_flags & PPC_FLOAT) {\n\n        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,\n\n                                 33, \"power-fpu.xml\", 0);\n\n    }\n\n    if (pcc->insns_flags & PPC_ALTIVEC) {\n\n        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,\n\n                                 34, \"power-altivec.xml\", 0);\n\n    }\n\n    if (pcc->insns_flags & PPC_SPE) {\n\n        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,\n\n                                 34, \"power-spe.xml\", 0);\n\n    }\n\n\n\n    qemu_init_vcpu(cs);\n\n\n\n    pcc->parent_realize(dev, errp);\n\n\n\n#if defined(PPC_DUMP_CPU)\n\n    {\n\n        CPUPPCState *env = &cpu->env;\n\n        const char *mmu_model, *excp_model, *bus_model;\n\n        switch (env->mmu_model) {\n\n        case POWERPC_MMU_32B:\n\n            mmu_model = \"PowerPC 32\";\n\n            break;\n\n        case POWERPC_MMU_SOFT_6xx:\n\n            mmu_model = \"PowerPC 6xx/7xx with software driven TLBs\";\n\n            break;\n\n        case POWERPC_MMU_SOFT_74xx:\n\n            mmu_model = \"PowerPC 74xx with software driven TLBs\";\n\n            break;\n\n        case POWERPC_MMU_SOFT_4xx:\n\n            mmu_model = \"PowerPC 4xx with software driven TLBs\";\n\n            break;\n\n        case POWERPC_MMU_SOFT_4xx_Z:\n\n            mmu_model = \"PowerPC 4xx with software driven TLBs \"\n\n                \"and zones protections\";\n\n            break;\n\n        case POWERPC_MMU_REAL:\n\n            mmu_model = \"PowerPC real mode only\";\n\n            break;\n\n        case POWERPC_MMU_MPC8xx:\n\n            mmu_model = \"PowerPC MPC8xx\";\n\n            break;\n\n        case POWERPC_MMU_BOOKE:\n\n            mmu_model = \"PowerPC BookE\";\n\n            break;\n\n        case POWERPC_MMU_BOOKE206:\n\n            mmu_model = \"PowerPC BookE 2.06\";\n\n            break;\n\n        case POWERPC_MMU_601:\n\n            mmu_model = \"PowerPC 601\";\n\n            break;\n\n#if defined (TARGET_PPC64)\n\n        case POWERPC_MMU_64B:\n\n            mmu_model = \"PowerPC 64\";\n\n            break;\n\n#endif\n\n        default:\n\n            mmu_model = \"Unknown or invalid\";\n\n            break;\n\n        }\n\n        switch (env->excp_model) {\n\n        case POWERPC_EXCP_STD:\n\n            excp_model = \"PowerPC\";\n\n            break;\n\n        case POWERPC_EXCP_40x:\n\n            excp_model = \"PowerPC 40x\";\n\n            break;\n\n        case POWERPC_EXCP_601:\n\n            excp_model = \"PowerPC 601\";\n\n            break;\n\n        case POWERPC_EXCP_602:\n\n            excp_model = \"PowerPC 602\";\n\n            break;\n\n        case POWERPC_EXCP_603:\n\n            excp_model = \"PowerPC 603\";\n\n            break;\n\n        case POWERPC_EXCP_603E:\n\n            excp_model = \"PowerPC 603e\";\n\n            break;\n\n        case POWERPC_EXCP_604:\n\n            excp_model = \"PowerPC 604\";\n\n            break;\n\n        case POWERPC_EXCP_7x0:\n\n            excp_model = \"PowerPC 740/750\";\n\n            break;\n\n        case POWERPC_EXCP_7x5:\n\n            excp_model = \"PowerPC 745/755\";\n\n            break;\n\n        case POWERPC_EXCP_74xx:\n\n            excp_model = \"PowerPC 74xx\";\n\n            break;\n\n        case POWERPC_EXCP_BOOKE:\n\n            excp_model = \"PowerPC BookE\";\n\n            break;\n\n#if defined (TARGET_PPC64)\n\n        case POWERPC_EXCP_970:\n\n            excp_model = \"PowerPC 970\";\n\n            break;\n\n#endif\n\n        default:\n\n            excp_model = \"Unknown or invalid\";\n\n            break;\n\n        }\n\n        switch (env->bus_model) {\n\n        case PPC_FLAGS_INPUT_6xx:\n\n            bus_model = \"PowerPC 6xx\";\n\n            break;\n\n        case PPC_FLAGS_INPUT_BookE:\n\n            bus_model = \"PowerPC BookE\";\n\n            break;\n\n        case PPC_FLAGS_INPUT_405:\n\n            bus_model = \"PowerPC 405\";\n\n            break;\n\n        case PPC_FLAGS_INPUT_401:\n\n            bus_model = \"PowerPC 401/403\";\n\n            break;\n\n        case PPC_FLAGS_INPUT_RCPU:\n\n            bus_model = \"RCPU / MPC8xx\";\n\n            break;\n\n#if defined (TARGET_PPC64)\n\n        case PPC_FLAGS_INPUT_970:\n\n            bus_model = \"PowerPC 970\";\n\n            break;\n\n#endif\n\n        default:\n\n            bus_model = \"Unknown or invalid\";\n\n            break;\n\n        }\n\n        printf(\"PowerPC %-12s : PVR %08x MSR %016\" PRIx64 \"\\n\"\n\n               \"    MMU model        : %s\\n\",\n\n               object_class_get_name(OBJECT_CLASS(pcc)),\n\n               pcc->pvr, pcc->msr_mask, mmu_model);\n\n#if !defined(CONFIG_USER_ONLY)\n\n        if (env->tlb.tlb6) {\n\n            printf(\"                       %d %s TLB in %d ways\\n\",\n\n                   env->nb_tlb, env->id_tlbs ? \"splitted\" : \"merged\",\n\n                   env->nb_ways);\n\n        }\n\n#endif\n\n        printf(\"    Exceptions model : %s\\n\"\n\n               \"    Bus model        : %s\\n\",\n\n               excp_model, bus_model);\n\n        printf(\"    MSR features     :\\n\");\n\n        if (env->flags & POWERPC_FLAG_SPE)\n\n            printf(\"                        signal processing engine enable\"\n\n                   \"\\n\");\n\n        else if (env->flags & POWERPC_FLAG_VRE)\n\n            printf(\"                        vector processor enable\\n\");\n\n        if (env->flags & POWERPC_FLAG_TGPR)\n\n            printf(\"                        temporary GPRs\\n\");\n\n        else if (env->flags & POWERPC_FLAG_CE)\n\n            printf(\"                        critical input enable\\n\");\n\n        if (env->flags & POWERPC_FLAG_SE)\n\n            printf(\"                        single-step trace mode\\n\");\n\n        else if (env->flags & POWERPC_FLAG_DWE)\n\n            printf(\"                        debug wait enable\\n\");\n\n        else if (env->flags & POWERPC_FLAG_UBLE)\n\n            printf(\"                        user BTB lock enable\\n\");\n\n        if (env->flags & POWERPC_FLAG_BE)\n\n            printf(\"                        branch-step trace mode\\n\");\n\n        else if (env->flags & POWERPC_FLAG_DE)\n\n            printf(\"                        debug interrupt enable\\n\");\n\n        if (env->flags & POWERPC_FLAG_PX)\n\n            printf(\"                        inclusive protection\\n\");\n\n        else if (env->flags & POWERPC_FLAG_PMM)\n\n            printf(\"                        performance monitor mark\\n\");\n\n        if (env->flags == POWERPC_FLAG_NONE)\n\n            printf(\"                        none\\n\");\n\n        printf(\"    Time-base/decrementer clock source: %s\\n\",\n\n               env->flags & POWERPC_FLAG_RTC_CLK ? \"RTC clock\" : \"bus clock\");\n\n        dump_ppc_insns(env);\n\n        dump_ppc_sprs(env);\n\n        fflush(stdout);\n\n    }\n\n#endif\n\n}\n", "idx": 22099}
{"project": "qemu", "commit_id": "99a3c89d5d538dc6c360e35dffb797cfe06e9cda", "target": 0, "func": "static int qemu_rbd_open(BlockDriverState *bs, QDict *options, int flags,\n\n                         Error **errp)\n\n{\n\n    BDRVRBDState *s = bs->opaque;\n\n    char pool[RBD_MAX_POOL_NAME_SIZE];\n\n    char snap_buf[RBD_MAX_SNAP_NAME_SIZE];\n\n    char conf[RBD_MAX_CONF_SIZE];\n\n    char clientname_buf[RBD_MAX_CONF_SIZE];\n\n    char *clientname;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n    const char *filename;\n\n    int r;\n\n\n\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        qemu_opts_del(opts);\n\n        return -EINVAL;\n\n    }\n\n\n\n    filename = qemu_opt_get(opts, \"filename\");\n\n\n\n    if (qemu_rbd_parsename(filename, pool, sizeof(pool),\n\n                           snap_buf, sizeof(snap_buf),\n\n                           s->name, sizeof(s->name),\n\n                           conf, sizeof(conf), errp) < 0) {\n\n        r = -EINVAL;\n\n        goto failed_opts;\n\n    }\n\n\n\n    clientname = qemu_rbd_parse_clientname(conf, clientname_buf);\n\n    r = rados_create(&s->cluster, clientname);\n\n    if (r < 0) {\n\n        error_setg(errp, \"error initializing\");\n\n        goto failed_opts;\n\n    }\n\n\n\n    s->snap = NULL;\n\n    if (snap_buf[0] != '\\0') {\n\n        s->snap = g_strdup(snap_buf);\n\n    }\n\n\n\n    /*\n\n     * Fallback to more conservative semantics if setting cache\n\n     * options fails. Ignore errors from setting rbd_cache because the\n\n     * only possible error is that the option does not exist, and\n\n     * librbd defaults to no caching. If write through caching cannot\n\n     * be set up, fall back to no caching.\n\n     */\n\n    if (flags & BDRV_O_NOCACHE) {\n\n        rados_conf_set(s->cluster, \"rbd_cache\", \"false\");\n\n    } else {\n\n        rados_conf_set(s->cluster, \"rbd_cache\", \"true\");\n\n    }\n\n\n\n    if (strstr(conf, \"conf=\") == NULL) {\n\n        /* try default location, but ignore failure */\n\n        rados_conf_read_file(s->cluster, NULL);\n\n    }\n\n\n\n    if (conf[0] != '\\0') {\n\n        r = qemu_rbd_set_conf(s->cluster, conf, errp);\n\n        if (r < 0) {\n\n            goto failed_shutdown;\n\n        }\n\n    }\n\n\n\n    r = rados_connect(s->cluster);\n\n    if (r < 0) {\n\n        error_setg(errp, \"error connecting\");\n\n        goto failed_shutdown;\n\n    }\n\n\n\n    r = rados_ioctx_create(s->cluster, pool, &s->io_ctx);\n\n    if (r < 0) {\n\n        error_setg(errp, \"error opening pool %s\", pool);\n\n        goto failed_shutdown;\n\n    }\n\n\n\n    r = rbd_open(s->io_ctx, s->name, &s->image, s->snap);\n\n    if (r < 0) {\n\n        error_setg(errp, \"error reading header from %s\", s->name);\n\n        goto failed_open;\n\n    }\n\n\n\n    bs->read_only = (s->snap != NULL);\n\n\n\n    qemu_opts_del(opts);\n\n    return 0;\n\n\n\nfailed_open:\n\n    rados_ioctx_destroy(s->io_ctx);\n\nfailed_shutdown:\n\n    rados_shutdown(s->cluster);\n\n    g_free(s->snap);\n\nfailed_opts:\n\n    qemu_opts_del(opts);\n\n    return r;\n\n}\n", "idx": 22100}
{"project": "qemu", "commit_id": "2eb74e1a1ef145034aa41255c4a6f469d560c96d", "target": 0, "func": "static void render_memory_region(FlatView *view,\n\n                                 MemoryRegion *mr,\n\n                                 Int128 base,\n\n                                 AddrRange clip,\n\n                                 bool readonly)\n\n{\n\n    MemoryRegion *subregion;\n\n    unsigned i;\n\n    hwaddr offset_in_region;\n\n    Int128 remain;\n\n    Int128 now;\n\n    FlatRange fr;\n\n    AddrRange tmp;\n\n\n\n    if (!mr->enabled) {\n\n        return;\n\n    }\n\n\n\n    int128_addto(&base, int128_make64(mr->addr));\n\n    readonly |= mr->readonly;\n\n\n\n    tmp = addrrange_make(base, mr->size);\n\n\n\n    if (!addrrange_intersects(tmp, clip)) {\n\n        return;\n\n    }\n\n\n\n    clip = addrrange_intersection(tmp, clip);\n\n\n\n    if (mr->alias) {\n\n        int128_subfrom(&base, int128_make64(mr->alias->addr));\n\n        int128_subfrom(&base, int128_make64(mr->alias_offset));\n\n        render_memory_region(view, mr->alias, base, clip, readonly);\n\n        return;\n\n    }\n\n\n\n    /* Render subregions in priority order. */\n\n    QTAILQ_FOREACH(subregion, &mr->subregions, subregions_link) {\n\n        render_memory_region(view, subregion, base, clip, readonly);\n\n    }\n\n\n\n    if (!mr->terminates) {\n\n        return;\n\n    }\n\n\n\n    offset_in_region = int128_get64(int128_sub(clip.start, base));\n\n    base = clip.start;\n\n    remain = clip.size;\n\n\n\n    /* Render the region itself into any gaps left by the current view. */\n\n    for (i = 0; i < view->nr && int128_nz(remain); ++i) {\n\n        if (int128_ge(base, addrrange_end(view->ranges[i].addr))) {\n\n            continue;\n\n        }\n\n        if (int128_lt(base, view->ranges[i].addr.start)) {\n\n            now = int128_min(remain,\n\n                             int128_sub(view->ranges[i].addr.start, base));\n\n            fr.mr = mr;\n\n            fr.offset_in_region = offset_in_region;\n\n            fr.addr = addrrange_make(base, now);\n\n            fr.dirty_log_mask = mr->dirty_log_mask;\n\n            fr.romd_mode = mr->romd_mode;\n\n            fr.readonly = readonly;\n\n            flatview_insert(view, i, &fr);\n\n            ++i;\n\n            int128_addto(&base, now);\n\n            offset_in_region += int128_get64(now);\n\n            int128_subfrom(&remain, now);\n\n        }\n\n        now = int128_sub(int128_min(int128_add(base, remain),\n\n                                    addrrange_end(view->ranges[i].addr)),\n\n                         base);\n\n        int128_addto(&base, now);\n\n        offset_in_region += int128_get64(now);\n\n        int128_subfrom(&remain, now);\n\n    }\n\n    if (int128_nz(remain)) {\n\n        fr.mr = mr;\n\n        fr.offset_in_region = offset_in_region;\n\n        fr.addr = addrrange_make(base, remain);\n\n        fr.dirty_log_mask = mr->dirty_log_mask;\n\n        fr.romd_mode = mr->romd_mode;\n\n        fr.readonly = readonly;\n\n        flatview_insert(view, i, &fr);\n\n    }\n\n}\n", "idx": 22101}
{"project": "qemu", "commit_id": "4534ff5426afeeae5238ba10a696cafa9a0168ee", "target": 0, "func": "static int vdi_check(BlockDriverState *bs, BdrvCheckResult *res)\n\n{\n\n    /* TODO: additional checks possible. */\n\n    BDRVVdiState *s = (BDRVVdiState *)bs->opaque;\n\n    uint32_t blocks_allocated = 0;\n\n    uint32_t block;\n\n    uint32_t *bmap;\n\n    logout(\"\\n\");\n\n\n\n    bmap = g_malloc(s->header.blocks_in_image * sizeof(uint32_t));\n\n    memset(bmap, 0xff, s->header.blocks_in_image * sizeof(uint32_t));\n\n\n\n    /* Check block map and value of blocks_allocated. */\n\n    for (block = 0; block < s->header.blocks_in_image; block++) {\n\n        uint32_t bmap_entry = le32_to_cpu(s->bmap[block]);\n\n        if (VDI_IS_ALLOCATED(bmap_entry)) {\n\n            if (bmap_entry < s->header.blocks_in_image) {\n\n                blocks_allocated++;\n\n                if (!VDI_IS_ALLOCATED(bmap[bmap_entry])) {\n\n                    bmap[bmap_entry] = bmap_entry;\n\n                } else {\n\n                    fprintf(stderr, \"ERROR: block index %\" PRIu32\n\n                            \" also used by %\" PRIu32 \"\\n\", bmap[bmap_entry], bmap_entry);\n\n                    res->corruptions++;\n\n                }\n\n            } else {\n\n                fprintf(stderr, \"ERROR: block index %\" PRIu32\n\n                        \" too large, is %\" PRIu32 \"\\n\", block, bmap_entry);\n\n                res->corruptions++;\n\n            }\n\n        }\n\n    }\n\n    if (blocks_allocated != s->header.blocks_allocated) {\n\n        fprintf(stderr, \"ERROR: allocated blocks mismatch, is %\" PRIu32\n\n               \", should be %\" PRIu32 \"\\n\",\n\n               blocks_allocated, s->header.blocks_allocated);\n\n        res->corruptions++;\n\n    }\n\n\n\n    g_free(bmap);\n\n\n\n    return 0;\n\n}\n", "idx": 22102}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static const char *exynos4210_uart_regname(target_phys_addr_t  offset)\n\n{\n\n\n\n    int regs_number = sizeof(exynos4210_uart_regs) / sizeof(Exynos4210UartReg);\n\n    int i;\n\n\n\n    for (i = 0; i < regs_number; i++) {\n\n        if (offset == exynos4210_uart_regs[i].offset) {\n\n            return exynos4210_uart_regs[i].name;\n\n        }\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 22103}
{"project": "qemu", "commit_id": "c338b6ad609699cf352c8dd6338360b7e3895ad0", "target": 0, "func": "static int vmdk_is_cid_valid(BlockDriverState *bs)\n\n{\n\n#ifdef CHECK_CID\n\n    BDRVVmdkState *s = bs->opaque;\n\n    BlockDriverState *p_bs = bs->backing_hd;\n\n    uint32_t cur_pcid;\n\n\n\n    if (p_bs) {\n\n        cur_pcid = vmdk_read_cid(p_bs, 0);\n\n        if (s->parent_cid != cur_pcid) {\n\n            /* CID not valid */\n\n            return 0;\n\n        }\n\n    }\n\n#endif\n\n    /* CID valid */\n\n    return 1;\n\n}\n", "idx": 22104}
{"project": "qemu", "commit_id": "a702b35388c307ce2364691e2edc14094701c81e", "target": 0, "func": "static uint32_t slavio_timer_mem_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    SLAVIO_TIMERState *s = opaque;\n\n    uint32_t saddr, ret;\n\n\n\n    saddr = (addr & TIMER_MAXADDR) >> 2;\n\n    switch (saddr) {\n\n    case 0:\n\n        // read limit (system counter mode) or read most signifying\n\n        // part of counter (user mode)\n\n        if (slavio_timer_is_user(s)) {\n\n            // read user timer MSW\n\n            slavio_timer_get_out(s);\n\n            ret = s->counthigh;\n\n        } else {\n\n            // read limit\n\n            // clear irq\n\n            qemu_irq_lower(s->irq);\n\n            s->reached = 0;\n\n            ret = s->limit & 0x7fffffff;\n\n        }\n\n        break;\n\n    case 1:\n\n        // read counter and reached bit (system mode) or read lsbits\n\n        // of counter (user mode)\n\n        slavio_timer_get_out(s);\n\n        if (slavio_timer_is_user(s)) // read user timer LSW\n\n            ret = s->count & 0xffffffe00;\n\n        else // read limit\n\n            ret = (s->count & 0x7ffffe00) | s->reached;\n\n        break;\n\n    case 3:\n\n        // only available in processor counter/timer\n\n        // read start/stop status\n\n        ret = s->running;\n\n        break;\n\n    case 4:\n\n        // only available in system counter\n\n        // read user/system mode\n\n        ret = s->slave_mode;\n\n        break;\n\n    default:\n\n        DPRINTF(\"invalid read address \" TARGET_FMT_plx \"\\n\", addr);\n\n        ret = 0;\n\n        break;\n\n    }\n\n    DPRINTF(\"read \" TARGET_FMT_plx \" = %08x\\n\", addr, ret);\n\n\n\n    return ret;\n\n}\n", "idx": 22105}
{"project": "qemu", "commit_id": "9dbbc748d671c70599101836cd1c2719d92f3017", "target": 0, "func": "static inline bool fp_access_check(DisasContext *s)\n\n{\n\n    assert(!s->fp_access_checked);\n\n    s->fp_access_checked = true;\n\n\n\n    if (s->cpacr_fpen) {\n\n        return true;\n\n    }\n\n\n\n    gen_exception_insn(s, 4, EXCP_UDEF, syn_fp_access_trap(1, 0xe, false),\n\n                       default_exception_el(s));\n\n    return false;\n\n}\n", "idx": 22107}
{"project": "qemu", "commit_id": "751ebd76e654bd1e65da08ecf694325282b4cfcc", "target": 0, "func": "void block_job_complete(BlockJob *job, Error **errp)\n\n{\n\n    if (job->paused || job->cancelled || !job->driver->complete) {\n\n        error_set(errp, QERR_BLOCK_JOB_NOT_READY,\n\n                  bdrv_get_device_name(job->bs));\n\n        return;\n\n    }\n\n\n\n    job->driver->complete(job, errp);\n\n}\n", "idx": 22108}
{"project": "qemu", "commit_id": "9abc62f6445795522d1bf5bf17f642e44eaf032d", "target": 0, "func": "void qemu_system_suspend_request(void)\n\n{\n\n    if (is_suspended) {\n\n        return;\n\n    }\n\n    suspend_requested = 1;\n\n    cpu_stop_current();\n\n    qemu_notify_event();\n\n}\n", "idx": 22109}
{"project": "qemu", "commit_id": "0b3652bc70891940f2c7142d39576d17c4d07196", "target": 0, "func": "static int oss_open (int in, struct oss_params *req,\n\n                     struct oss_params *obt, int *pfd)\n\n{\n\n    int fd;\n\n    int oflags;\n\n    int mmmmssss;\n\n    audio_buf_info abinfo;\n\n    int fmt, freq, nchannels;\n\n    const char *dspname = in ? conf.devpath_in : conf.devpath_out;\n\n    const char *typ = in ? \"ADC\" : \"DAC\";\n\n\n\n    /* Kludge needed to have working mmap on Linux */\n\n    oflags = conf.try_mmap ? O_RDWR : (in ? O_RDONLY : O_WRONLY);\n\n    fd = open (dspname, oflags | O_NONBLOCK);\n\n    if (-1 == fd) {\n\n        oss_logerr2 (errno, typ, \"Failed to open `%s'\\n\", dspname);\n\n        return -1;\n\n    }\n\n\n\n    freq = req->freq;\n\n    nchannels = req->nchannels;\n\n    fmt = req->fmt;\n\n\n\n    if (ioctl (fd, SNDCTL_DSP_SAMPLESIZE, &fmt)) {\n\n        oss_logerr2 (errno, typ, \"Failed to set sample size %d\\n\", req->fmt);\n\n        goto err;\n\n    }\n\n\n\n    if (ioctl (fd, SNDCTL_DSP_CHANNELS, &nchannels)) {\n\n        oss_logerr2 (errno, typ, \"Failed to set number of channels %d\\n\",\n\n                     req->nchannels);\n\n        goto err;\n\n    }\n\n\n\n    if (ioctl (fd, SNDCTL_DSP_SPEED, &freq)) {\n\n        oss_logerr2 (errno, typ, \"Failed to set frequency %d\\n\", req->freq);\n\n        goto err;\n\n    }\n\n\n\n    if (ioctl (fd, SNDCTL_DSP_NONBLOCK, NULL)) {\n\n        oss_logerr2 (errno, typ, \"Failed to set non-blocking mode\\n\");\n\n        goto err;\n\n    }\n\n\n\n    mmmmssss = (req->nfrags << 16) | ctz32 (req->fragsize);\n\n    if (ioctl (fd, SNDCTL_DSP_SETFRAGMENT, &mmmmssss)) {\n\n        oss_logerr2 (errno, typ, \"Failed to set buffer length (%d, %d)\\n\",\n\n                     req->nfrags, req->fragsize);\n\n        goto err;\n\n    }\n\n\n\n    if (ioctl (fd, in ? SNDCTL_DSP_GETISPACE : SNDCTL_DSP_GETOSPACE, &abinfo)) {\n\n        oss_logerr2 (errno, typ, \"Failed to get buffer length\\n\");\n\n        goto err;\n\n    }\n\n\n\n    if (!abinfo.fragstotal || !abinfo.fragsize) {\n\n        AUD_log (AUDIO_CAP, \"Returned bogus buffer information(%d, %d) for %s\\n\",\n\n                 abinfo.fragstotal, abinfo.fragsize, typ);\n\n        goto err;\n\n    }\n\n\n\n    obt->fmt = fmt;\n\n    obt->nchannels = nchannels;\n\n    obt->freq = freq;\n\n    obt->nfrags = abinfo.fragstotal;\n\n    obt->fragsize = abinfo.fragsize;\n\n    *pfd = fd;\n\n\n\n#ifdef DEBUG_MISMATCHES\n\n    if ((req->fmt != obt->fmt) ||\n\n        (req->nchannels != obt->nchannels) ||\n\n        (req->freq != obt->freq) ||\n\n        (req->fragsize != obt->fragsize) ||\n\n        (req->nfrags != obt->nfrags)) {\n\n        dolog (\"Audio parameters mismatch\\n\");\n\n        oss_dump_info (req, obt);\n\n    }\n\n#endif\n\n\n\n#ifdef DEBUG\n\n    oss_dump_info (req, obt);\n\n#endif\n\n    return 0;\n\n\n\n err:\n\n    oss_anal_close (&fd);\n\n    return -1;\n\n}\n", "idx": 22110}
{"project": "qemu", "commit_id": "e0a039e50d481dce6b4ee45a29002538a258cd89", "target": 0, "func": "static void netfilter_set_status(Object *obj, const char *str, Error **errp)\n\n{\n\n    NetFilterState *nf = NETFILTER(obj);\n\n    NetFilterClass *nfc = NETFILTER_GET_CLASS(obj);\n\n\n\n    if (strcmp(str, \"on\") && strcmp(str, \"off\")) {\n\n        error_setg(errp, \"Invalid value for netfilter status, \"\n\n                         \"should be 'on' or 'off'\");\n\n        return;\n\n    }\n\n    if (nf->on == !strcmp(str, \"on\")) {\n\n        return;\n\n    }\n\n    nf->on = !nf->on;\n\n    if (nfc->status_changed) {\n\n        nfc->status_changed(nf, errp);\n\n    }\n\n}\n", "idx": 22111}
{"project": "qemu", "commit_id": "02a2cbc872df99205eeafd399f01c210e0b797c4", "target": 0, "func": "static void vtd_interrupt_remap_table_setup(IntelIOMMUState *s)\n\n{\n\n    uint64_t value = 0;\n\n    value = vtd_get_quad_raw(s, DMAR_IRTA_REG);\n\n    s->intr_size = 1UL << ((value & VTD_IRTA_SIZE_MASK) + 1);\n\n    s->intr_root = value & VTD_IRTA_ADDR_MASK;\n\n\n\n    /* TODO: invalidate interrupt entry cache */\n\n\n\n    VTD_DPRINTF(CSR, \"int remap table addr 0x%\"PRIx64 \" size %\"PRIu32,\n\n                s->intr_root, s->intr_size);\n\n}\n", "idx": 22112}
{"project": "qemu", "commit_id": "7d553f27fce284805d7f94603932045ee3bbb979", "target": 0, "func": "static void usb_msd_password_cb(void *opaque, int err)\n\n{\n\n    MSDState *s = opaque;\n\n\n\n    if (!err)\n\n        err = usb_device_attach(&s->dev);\n\n\n\n    if (err)\n\n        qdev_unplug(&s->dev.qdev, NULL);\n\n}\n", "idx": 22113}
{"project": "qemu", "commit_id": "e6f9e6b496fbba419f0f447fbee56a8464a4cc41", "target": 0, "func": "static int cpu_x86_fill_model_id(char *str)\n\n{\n\n    uint32_t eax, ebx, ecx, edx;\n\n    int i;\n\n\n\n    for (i = 0; i < 3; i++) {\n\n        host_cpuid(0x80000002 + i, 0, &eax, &ebx, &ecx, &edx);\n\n        memcpy(str + i * 16 +  0, &eax, 4);\n\n        memcpy(str + i * 16 +  4, &ebx, 4);\n\n        memcpy(str + i * 16 +  8, &ecx, 4);\n\n        memcpy(str + i * 16 + 12, &edx, 4);\n\n    }\n\n    return 0;\n\n}\n", "idx": 22114}
{"project": "qemu", "commit_id": "9bf3eb2ca542dd9306cb2e72fc68e02ba3e56e2e", "target": 0, "func": "static void gen_movci (DisasContext *ctx, int rd, int rs, int cc, int tf)\n\n{\n\n    int l1 = gen_new_label();\n\n    uint32_t ccbit;\n\n    TCGCond cond;\n\n    TCGv t0 = tcg_temp_local_new(TCG_TYPE_TL);\n\n    TCGv t1 = tcg_temp_local_new(TCG_TYPE_TL);\n\n    TCGv r_tmp = tcg_temp_local_new(TCG_TYPE_I32);\n\n\n\n    if (cc)\n\n        ccbit = 1 << (24 + cc);\n\n    else\n\n        ccbit = 1 << 23;\n\n    if (tf)\n\n        cond = TCG_COND_EQ;\n\n    else\n\n        cond = TCG_COND_NE;\n\n\n\n    gen_load_gpr(t0, rd);\n\n    gen_load_gpr(t1, rs);\n\n    tcg_gen_andi_i32(r_tmp, fpu_fcr31, ccbit);\n\n    tcg_gen_brcondi_i32(cond, r_tmp, 0, l1);\n\n    tcg_temp_free(r_tmp);\n\n\n\n    tcg_gen_mov_tl(t0, t1);\n\n    tcg_temp_free(t1);\n\n\n\n    gen_set_label(l1);\n\n    gen_store_gpr(t0, rd);\n\n    tcg_temp_free(t0);\n\n}\n", "idx": 22115}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "DISAS_INSN(branch)\n\n{\n\n    int32_t offset;\n\n    uint32_t base;\n\n    int op;\n\n    int l1;\n\n\n\n    base = s->pc;\n\n    op = (insn >> 8) & 0xf;\n\n    offset = (int8_t)insn;\n\n    if (offset == 0) {\n\n        offset = cpu_ldsw_code(env, s->pc);\n\n        s->pc += 2;\n\n    } else if (offset == -1) {\n\n        offset = read_im32(env, s);\n\n    }\n\n    if (op == 1) {\n\n        /* bsr */\n\n        gen_push(s, tcg_const_i32(s->pc));\n\n    }\n\n    gen_flush_cc_op(s);\n\n    if (op > 1) {\n\n        /* Bcc */\n\n        l1 = gen_new_label();\n\n        gen_jmpcc(s, ((insn >> 8) & 0xf) ^ 1, l1);\n\n        gen_jmp_tb(s, 1, base + offset);\n\n        gen_set_label(l1);\n\n        gen_jmp_tb(s, 0, s->pc);\n\n    } else {\n\n        /* Unconditional branch.  */\n\n        gen_jmp_tb(s, 0, base + offset);\n\n    }\n\n}\n", "idx": 22116}
{"project": "qemu", "commit_id": "a6baa60807f88ba7d97b1787797fb58882ccbfb9", "target": 0, "func": "static BlockStats *bdrv_query_stats(BlockBackend *blk,\n\n                                    const BlockDriverState *bs,\n\n                                    bool query_backing)\n\n{\n\n    BlockStats *s;\n\n\n\n    s = bdrv_query_bds_stats(bs, query_backing);\n\n\n\n    if (blk) {\n\n        s->has_device = true;\n\n        s->device = g_strdup(blk_name(blk));\n\n        bdrv_query_blk_stats(s->stats, blk);\n\n    }\n\n\n\n    return s;\n\n}\n", "idx": 22118}
{"project": "qemu", "commit_id": "89dbe18089127cf90993359096b659ea6f819848", "target": 0, "func": "static void ssh_parse_filename(const char *filename, QDict *options,\n\n                               Error **errp)\n\n{\n\n    if (qdict_haskey(options, \"user\") ||\n\n        qdict_haskey(options, \"host\") ||\n\n        qdict_haskey(options, \"port\") ||\n\n        qdict_haskey(options, \"path\") ||\n\n        qdict_haskey(options, \"host_key_check\")) {\n\n        error_setg(errp, \"user, host, port, path, host_key_check cannot be used at the same time as a file option\");\n\n        return;\n\n    }\n\n\n\n    parse_uri(filename, options, errp);\n\n}\n", "idx": 22119}
{"project": "qemu", "commit_id": "285f7a62e464eac97e472ba6803ddede1e6c459e", "target": 0, "func": "ip_init(void)\n\n{\n\n\tipq.ip_link.next = ipq.ip_link.prev = &ipq.ip_link;\n\n\tip_id = tt.tv_sec & 0xffff;\n\n\tudp_init();\n\n\ttcp_init();\n\n}\n", "idx": 22120}
{"project": "qemu", "commit_id": "bf55b7afce53718ef96f4e6616da62c0ccac37dd", "target": 0, "func": "static IOMMUTLBEntry typhoon_translate_iommu(MemoryRegion *iommu, hwaddr addr,\n\n                                             bool is_write)\n\n{\n\n    TyphoonPchip *pchip = container_of(iommu, TyphoonPchip, iommu);\n\n    IOMMUTLBEntry ret;\n\n    int i;\n\n\n\n    if (addr <= 0xffffffffu) {\n\n        /* Single-address cycle.  */\n\n\n\n        /* Check for the Window Hole, inhibiting matching.  */\n\n        if ((pchip->ctl & 0x20)\n\n            && addr >= 0x80000\n\n            && addr <= 0xfffff) {\n\n            goto failure;\n\n        }\n\n\n\n        /* Check the first three windows.  */\n\n        for (i = 0; i < 3; ++i) {\n\n            if (window_translate(&pchip->win[i], addr, &ret)) {\n\n                goto success;\n\n            }\n\n        }\n\n\n\n        /* Check the fourth window for DAC disable.  */\n\n        if ((pchip->win[3].wba & 0x80000000000ull) == 0\n\n\t    && window_translate(&pchip->win[3], addr, &ret)) {\n\n            goto success;\n\n        }\n\n    } else {\n\n        /* Double-address cycle.  */\n\n\n\n        if (addr >= 0x10000000000ull && addr < 0x20000000000ull) {\n\n            /* Check for the DMA monster window.  */\n\n            if (pchip->ctl & 0x40) {\n\n                /* See 10.1.4.4; in particular <39:35> is ignored.  */\n\n                make_iommu_tlbe(0, 0x007ffffffffull, &ret);\n\n\t\tgoto success;\n\n            }\n\n        }\n\n\n\n        if (addr >= 0x80000000000ull && addr <= 0xfffffffffffull) {\n\n            /* Check the fourth window for DAC enable and window enable.  */\n\n            if ((pchip->win[3].wba & 0x80000000001ull) == 0x80000000001ull) {\n\n                uint64_t pte_addr;\n\n\n\n                pte_addr  = pchip->win[3].tba & 0x7ffc00000ull;\n\n                pte_addr |= (addr & 0xffffe000u) >> 10;\n\n                if (pte_translate(pte_addr, &ret)) {\n\n\t\t\tgoto success;\n\n\t\t}\n\n            }\n\n        }\n\n    }\n\n\n\n failure:\n\n    ret = (IOMMUTLBEntry) { .perm = IOMMU_NONE };\n\n success:\n\n    return ret;\n\n}\n", "idx": 22121}
{"project": "qemu", "commit_id": "17b74b98676aee5bc470b173b1e528d2fce2cf18", "target": 0, "func": "void json_prop_str(QJSON *json, const char *name, const char *str)\n\n{\n\n    json_emit_element(json, name);\n\n    qstring_append_chr(json->str, '\"');\n\n    qstring_append(json->str, str);\n\n    qstring_append_chr(json->str, '\"');\n\n}\n", "idx": 22122}
{"project": "qemu", "commit_id": "cc05c43ad942165ecc6ffd39e41991bee43af044", "target": 1, "func": "static void memory_region_write_accessor(MemoryRegion *mr,\n\n                                         hwaddr addr,\n\n                                         uint64_t *value,\n\n                                         unsigned size,\n\n                                         unsigned shift,\n\n                                         uint64_t mask)\n\n{\n\n    uint64_t tmp;\n\n\n\n    if (mr->flush_coalesced_mmio) {\n\n        qemu_flush_coalesced_mmio_buffer();\n\n    }\n\n    tmp = (*value >> shift) & mask;\n\n    trace_memory_region_ops_write(mr, addr, tmp, size);\n\n    mr->ops->write(mr->opaque, addr, tmp, size);\n\n}\n", "idx": 22126}
{"project": "qemu", "commit_id": "e4f4fb1eca795e36f363b4647724221e774523c1", "target": 1, "func": "static void kvm_ioapic_class_init(ObjectClass *klass, void *data)\n\n{\n\n    IOAPICCommonClass *k = IOAPIC_COMMON_CLASS(klass);\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    k->realize   = kvm_ioapic_realize;\n\n    k->pre_save  = kvm_ioapic_get;\n\n    k->post_load = kvm_ioapic_put;\n\n    dc->reset    = kvm_ioapic_reset;\n\n    dc->props    = kvm_ioapic_properties;\n\n\n\n\n\n\n}", "idx": 22127}
{"project": "qemu", "commit_id": "1b435b10324fe9937f254bb00718f78d5e50837a", "target": 1, "func": "void qemu_bh_cancel(QEMUBH *bh)\n\n{\n\n    QEMUBH **pbh;\n\n    if (bh->scheduled) {\n\n        pbh = &first_bh;\n\n        while (*pbh != bh)\n\n            pbh = &(*pbh)->next;\n\n        *pbh = bh->next;\n\n        bh->scheduled = 0;\n\n    }\n\n}\n", "idx": 22128}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int unix_close(void *opaque)\n\n{\n\n    QEMUFileSocket *s = opaque;\n\n    close(s->fd);\n\n    g_free(s);\n\n    return 0;\n\n}\n", "idx": 22132}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void tcg_out_movcond32(TCGContext *s, TCGCond cond, TCGArg dest,\n\n                              TCGArg c1, TCGArg c2, int const_c2,\n\n                              TCGArg v1)\n\n{\n\n    tcg_out_cmp(s, c1, c2, const_c2, 0);\n\n    if (have_cmov) {\n\n        tcg_out_modrm(s, OPC_CMOVCC | tcg_cond_to_jcc[cond], dest, v1);\n\n    } else {\n\n        int over = gen_new_label();\n\n        tcg_out_jxx(s, tcg_cond_to_jcc[tcg_invert_cond(cond)], over, 1);\n\n        tcg_out_mov(s, TCG_TYPE_I32, dest, v1);\n\n        tcg_out_label(s, over, s->code_ptr);\n\n    }\n\n}\n", "idx": 22139}
{"project": "qemu", "commit_id": "9bd7854e1e5d6f4cfe4558090bbd9493c12bf846", "target": 0, "func": "static void fd_chr_read(void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    FDCharDriver *s = chr->opaque;\n\n    int size, len;\n\n    uint8_t buf[1024];\n\n\n\n    len = sizeof(buf);\n\n    if (len > s->max_size)\n\n        len = s->max_size;\n\n    if (len == 0)\n\n        return;\n\n    size = read(s->fd_in, buf, len);\n\n    if (size == 0) {\n\n        /* FD has been closed. Remove it from the active list.  */\n\n        qemu_set_fd_handler2(s->fd_in, NULL, NULL, NULL, NULL);\n\n        qemu_chr_event(chr, CHR_EVENT_CLOSED);\n\n        return;\n\n    }\n\n    if (size > 0) {\n\n        qemu_chr_read(chr, buf, size);\n\n    }\n\n}\n", "idx": 22140}
{"project": "qemu", "commit_id": "850f49de9b57511dcaf2cd7e45059f8f38fadf3b", "target": 0, "func": "qcrypto_block_luks_open(QCryptoBlock *block,\n\n                        QCryptoBlockOpenOptions *options,\n\n                        const char *optprefix,\n\n                        QCryptoBlockReadFunc readfunc,\n\n                        void *opaque,\n\n                        unsigned int flags,\n\n                        Error **errp)\n\n{\n\n    QCryptoBlockLUKS *luks;\n\n    Error *local_err = NULL;\n\n    int ret = 0;\n\n    size_t i;\n\n    ssize_t rv;\n\n    uint8_t *masterkey = NULL;\n\n    size_t masterkeylen;\n\n    char *ivgen_name, *ivhash_name;\n\n    QCryptoCipherMode ciphermode;\n\n    QCryptoCipherAlgorithm cipheralg;\n\n    QCryptoIVGenAlgorithm ivalg;\n\n    QCryptoCipherAlgorithm ivcipheralg;\n\n    QCryptoHashAlgorithm hash;\n\n    QCryptoHashAlgorithm ivhash;\n\n    char *password = NULL;\n\n\n\n    if (!(flags & QCRYPTO_BLOCK_OPEN_NO_IO)) {\n\n        if (!options->u.luks.key_secret) {\n\n            error_setg(errp, \"Parameter '%skey-secret' is required for cipher\",\n\n                       optprefix ? optprefix : \"\");\n\n            return -1;\n\n        }\n\n        password = qcrypto_secret_lookup_as_utf8(\n\n            options->u.luks.key_secret, errp);\n\n        if (!password) {\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    luks = g_new0(QCryptoBlockLUKS, 1);\n\n    block->opaque = luks;\n\n\n\n    /* Read the entire LUKS header, minus the key material from\n\n     * the underlying device */\n\n    rv = readfunc(block, 0,\n\n                  (uint8_t *)&luks->header,\n\n                  sizeof(luks->header),\n\n                  opaque,\n\n                  errp);\n\n    if (rv < 0) {\n\n        ret = rv;\n\n        goto fail;\n\n    }\n\n\n\n    /* The header is always stored in big-endian format, so\n\n     * convert everything to native */\n\n    be16_to_cpus(&luks->header.version);\n\n    be32_to_cpus(&luks->header.payload_offset);\n\n    be32_to_cpus(&luks->header.key_bytes);\n\n    be32_to_cpus(&luks->header.master_key_iterations);\n\n\n\n    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {\n\n        be32_to_cpus(&luks->header.key_slots[i].active);\n\n        be32_to_cpus(&luks->header.key_slots[i].iterations);\n\n        be32_to_cpus(&luks->header.key_slots[i].key_offset);\n\n        be32_to_cpus(&luks->header.key_slots[i].stripes);\n\n    }\n\n\n\n    if (memcmp(luks->header.magic, qcrypto_block_luks_magic,\n\n               QCRYPTO_BLOCK_LUKS_MAGIC_LEN) != 0) {\n\n        error_setg(errp, \"Volume is not in LUKS format\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    if (luks->header.version != QCRYPTO_BLOCK_LUKS_VERSION) {\n\n        error_setg(errp, \"LUKS version %\" PRIu32 \" is not supported\",\n\n                   luks->header.version);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    }\n\n\n\n    /*\n\n     * The cipher_mode header contains a string that we have\n\n     * to further parse, of the format\n\n     *\n\n     *    <cipher-mode>-<iv-generator>[:<iv-hash>]\n\n     *\n\n     * eg  cbc-essiv:sha256, cbc-plain64\n\n     */\n\n    ivgen_name = strchr(luks->header.cipher_mode, '-');\n\n    if (!ivgen_name) {\n\n        ret = -EINVAL;\n\n        error_setg(errp, \"Unexpected cipher mode string format %s\",\n\n                   luks->header.cipher_mode);\n\n        goto fail;\n\n    }\n\n    *ivgen_name = '\\0';\n\n    ivgen_name++;\n\n\n\n    ivhash_name = strchr(ivgen_name, ':');\n\n    if (!ivhash_name) {\n\n        ivhash = 0;\n\n    } else {\n\n        *ivhash_name = '\\0';\n\n        ivhash_name++;\n\n\n\n        ivhash = qcrypto_block_luks_hash_name_lookup(ivhash_name,\n\n                                                     &local_err);\n\n        if (local_err) {\n\n            ret = -ENOTSUP;\n\n            error_propagate(errp, local_err);\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ciphermode = qcrypto_block_luks_cipher_mode_lookup(luks->header.cipher_mode,\n\n                                                       &local_err);\n\n    if (local_err) {\n\n        ret = -ENOTSUP;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n    }\n\n\n\n    cipheralg = qcrypto_block_luks_cipher_name_lookup(luks->header.cipher_name,\n\n                                                      ciphermode,\n\n                                                      luks->header.key_bytes,\n\n                                                      &local_err);\n\n    if (local_err) {\n\n        ret = -ENOTSUP;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n    }\n\n\n\n    hash = qcrypto_block_luks_hash_name_lookup(luks->header.hash_spec,\n\n                                               &local_err);\n\n    if (local_err) {\n\n        ret = -ENOTSUP;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n    }\n\n\n\n    ivalg = qcrypto_block_luks_ivgen_name_lookup(ivgen_name,\n\n                                                 &local_err);\n\n    if (local_err) {\n\n        ret = -ENOTSUP;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n    }\n\n\n\n    if (ivalg == QCRYPTO_IVGEN_ALG_ESSIV) {\n\n        if (!ivhash_name) {\n\n            ret = -EINVAL;\n\n            error_setg(errp, \"Missing IV generator hash specification\");\n\n            goto fail;\n\n        }\n\n        ivcipheralg = qcrypto_block_luks_essiv_cipher(cipheralg,\n\n                                                      ivhash,\n\n                                                      &local_err);\n\n        if (local_err) {\n\n            ret = -ENOTSUP;\n\n            error_propagate(errp, local_err);\n\n            goto fail;\n\n        }\n\n    } else {\n\n        /* Note we parsed the ivhash_name earlier in the cipher_mode\n\n         * spec string even with plain/plain64 ivgens, but we\n\n         * will ignore it, since it is irrelevant for these ivgens.\n\n         * This is for compat with dm-crypt which will silently\n\n         * ignore hash names with these ivgens rather than report\n\n         * an error about the invalid usage\n\n         */\n\n        ivcipheralg = cipheralg;\n\n    }\n\n\n\n    if (!(flags & QCRYPTO_BLOCK_OPEN_NO_IO)) {\n\n        /* Try to find which key slot our password is valid for\n\n         * and unlock the master key from that slot.\n\n         */\n\n        if (qcrypto_block_luks_find_key(block,\n\n                                        password,\n\n                                        cipheralg, ciphermode,\n\n                                        hash,\n\n                                        ivalg,\n\n                                        ivcipheralg,\n\n                                        ivhash,\n\n                                        &masterkey, &masterkeylen,\n\n                                        readfunc, opaque,\n\n                                        errp) < 0) {\n\n            ret = -EACCES;\n\n            goto fail;\n\n        }\n\n\n\n        /* We have a valid master key now, so can setup the\n\n         * block device payload decryption objects\n\n         */\n\n        block->kdfhash = hash;\n\n        block->niv = qcrypto_cipher_get_iv_len(cipheralg,\n\n                                               ciphermode);\n\n        block->ivgen = qcrypto_ivgen_new(ivalg,\n\n                                         ivcipheralg,\n\n                                         ivhash,\n\n                                         masterkey, masterkeylen,\n\n                                         errp);\n\n        if (!block->ivgen) {\n\n            ret = -ENOTSUP;\n\n            goto fail;\n\n        }\n\n\n\n        block->cipher = qcrypto_cipher_new(cipheralg,\n\n                                           ciphermode,\n\n                                           masterkey, masterkeylen,\n\n                                           errp);\n\n        if (!block->cipher) {\n\n            ret = -ENOTSUP;\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    block->payload_offset = luks->header.payload_offset *\n\n        QCRYPTO_BLOCK_LUKS_SECTOR_SIZE;\n\n\n\n    luks->cipher_alg = cipheralg;\n\n    luks->cipher_mode = ciphermode;\n\n    luks->ivgen_alg = ivalg;\n\n    luks->ivgen_hash_alg = ivhash;\n\n    luks->hash_alg = hash;\n\n\n\n    g_free(masterkey);\n\n    g_free(password);\n\n\n\n    return 0;\n\n\n\n fail:\n\n    g_free(masterkey);\n\n    qcrypto_cipher_free(block->cipher);\n\n    qcrypto_ivgen_free(block->ivgen);\n\n    g_free(luks);\n\n    g_free(password);\n\n    return ret;\n\n}\n", "idx": 22141}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void do_acl_show(Monitor *mon, const QDict *qdict)\n\n{\n\n    const char *aclname = qdict_get_str(qdict, \"aclname\");\n\n    qemu_acl *acl = find_acl(mon, aclname);\n\n    qemu_acl_entry *entry;\n\n    int i = 0;\n\n\n\n    if (acl) {\n\n        monitor_printf(mon, \"policy: %s\\n\",\n\n                       acl->defaultDeny ? \"deny\" : \"allow\");\n\n        TAILQ_FOREACH(entry, &acl->entries, next) {\n\n            i++;\n\n            monitor_printf(mon, \"%d: %s %s\\n\", i,\n\n                           entry->deny ? \"deny\" : \"allow\", entry->match);\n\n        }\n\n    }\n\n}\n", "idx": 22142}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "MemoryRegionSection *phys_page_find(AddressSpaceDispatch *d, target_phys_addr_t index)\n\n{\n\n    PhysPageEntry lp = d->phys_map;\n\n    PhysPageEntry *p;\n\n    int i;\n\n    uint16_t s_index = phys_section_unassigned;\n\n\n\n    for (i = P_L2_LEVELS - 1; i >= 0 && !lp.is_leaf; i--) {\n\n        if (lp.ptr == PHYS_MAP_NODE_NIL) {\n\n            goto not_found;\n\n        }\n\n        p = phys_map_nodes[lp.ptr];\n\n        lp = p[(index >> (i * L2_BITS)) & (L2_SIZE - 1)];\n\n    }\n\n\n\n    s_index = lp.ptr;\n\nnot_found:\n\n    return &phys_sections[s_index];\n\n}\n", "idx": 22143}
{"project": "qemu", "commit_id": "8cc580f6a0d8c0e2f590c1472cf5cd8e51761760", "target": 0, "func": "static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is64)\n\n{\n\n    TCGReg datalo, datahi, addrlo;\n\n    TCGReg addrhi __attribute__((unused));\n\n    TCGMemOpIdx oi;\n\n    TCGMemOp opc;\n\n#if defined(CONFIG_SOFTMMU)\n\n    int mem_index;\n\n    TCGMemOp s_bits;\n\n    tcg_insn_unit *label_ptr[2];\n\n#endif\n\n\n\n    datalo = *args++;\n\n    datahi = (TCG_TARGET_REG_BITS == 32 && is64 ? *args++ : 0);\n\n    addrlo = *args++;\n\n    addrhi = (TARGET_LONG_BITS > TCG_TARGET_REG_BITS ? *args++ : 0);\n\n    oi = *args++;\n\n    opc = get_memop(oi);\n\n\n\n#if defined(CONFIG_SOFTMMU)\n\n    mem_index = get_mmuidx(oi);\n\n    s_bits = opc & MO_SIZE;\n\n\n\n    tcg_out_tlb_load(s, addrlo, addrhi, mem_index, s_bits,\n\n                     label_ptr, offsetof(CPUTLBEntry, addr_read));\n\n\n\n    /* TLB Hit.  */\n\n    tcg_out_qemu_ld_direct(s, datalo, datahi, TCG_REG_L1, -1, 0, 0, opc);\n\n\n\n    /* Record the current context of a load into ldst label */\n\n    add_qemu_ldst_label(s, true, oi, datalo, datahi, addrlo, addrhi,\n\n                        s->code_ptr, label_ptr);\n\n#else\n\n    {\n\n        int32_t offset = GUEST_BASE;\n\n        TCGReg base = addrlo;\n\n        int index = -1;\n\n        int seg = 0;\n\n\n\n        /* For a 32-bit guest, the high 32 bits may contain garbage.\n\n           We can do this with the ADDR32 prefix if we're not using\n\n           a guest base, or when using segmentation.  Otherwise we\n\n           need to zero-extend manually.  */\n\n        if (GUEST_BASE == 0 || guest_base_flags) {\n\n            seg = guest_base_flags;\n\n            offset = 0;\n\n            if (TCG_TARGET_REG_BITS > TARGET_LONG_BITS) {\n\n                seg |= P_ADDR32;\n\n            }\n\n        } else if (TCG_TARGET_REG_BITS == 64) {\n\n            if (TARGET_LONG_BITS == 32) {\n\n                tcg_out_ext32u(s, TCG_REG_L0, base);\n\n                base = TCG_REG_L0;\n\n            }\n\n            if (offset != GUEST_BASE) {\n\n                tcg_out_movi(s, TCG_TYPE_I64, TCG_REG_L1, GUEST_BASE);\n\n                index = TCG_REG_L1;\n\n                offset = 0;\n\n            }\n\n        }\n\n\n\n        tcg_out_qemu_ld_direct(s, datalo, datahi,\n\n                               base, index, offset, seg, opc);\n\n    }\n\n#endif\n\n}\n", "idx": 22144}
{"project": "qemu", "commit_id": "26a83ad0e793465b74a8b06a65f2f6fdc5615413", "target": 0, "func": "void memory_region_init_io(MemoryRegion *mr,\n\n                           const MemoryRegionOps *ops,\n\n                           void *opaque,\n\n                           const char *name,\n\n                           uint64_t size)\n\n{\n\n    memory_region_init(mr, name, size);\n\n    mr->ops = ops;\n\n    mr->opaque = opaque;\n\n    mr->terminates = true;\n\n    mr->backend_registered = false;\n\n}\n", "idx": 22145}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "static uint32_t bonito_spciconf_readw(void *opaque, target_phys_addr_t addr)\n\n{\n\n    PCIBonitoState *s = opaque;\n\n    uint32_t pciaddr;\n\n    uint16_t status;\n\n\n\n    DPRINTF(\"bonito_spciconf_readw \"TARGET_FMT_plx\"  \\n\", addr);\n\n    assert((addr&0x1)==0);\n\n\n\n    pciaddr = bonito_sbridge_pciaddr(s, addr);\n\n\n\n    if (pciaddr == 0xffffffff) {\n\n        return 0xffff;\n\n    }\n\n\n\n    /* set the pci address in s->config_reg */\n\n    s->pcihost->config_reg = (pciaddr) | (1u << 31);\n\n\n\n    /* clear PCI_STATUS_REC_MASTER_ABORT and PCI_STATUS_REC_TARGET_ABORT */\n\n    status = pci_get_word(s->dev.config + PCI_STATUS);\n\n    status &= ~(PCI_STATUS_REC_MASTER_ABORT | PCI_STATUS_REC_TARGET_ABORT);\n\n    pci_set_word(s->dev.config + PCI_STATUS, status);\n\n\n\n    return pci_data_read(s->pcihost->bus, s->pcihost->config_reg, 2);\n\n}\n", "idx": 22146}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t uart_read(void *opaque, target_phys_addr_t offset,\n\n        unsigned size)\n\n{\n\n    UartState *s = (UartState *)opaque;\n\n    uint32_t c = 0;\n\n\n\n    offset >>= 2;\n\n    if (offset >= R_MAX) {\n\n        return 0;\n\n    } else if (offset == R_TX_RX) {\n\n        uart_read_rx_fifo(s, &c);\n\n        return c;\n\n    }\n\n    return s->r[offset];\n\n}\n", "idx": 22147}
{"project": "qemu", "commit_id": "f6b4fc8b23b1154577c72937b70e565716bb0a60", "target": 0, "func": "static int check_opts(QemuOptsList *opts_list, QDict *args)\n\n{\n\n    assert(!opts_list->desc->name);\n\n    return 0;\n\n}\n", "idx": 22149}
{"project": "qemu", "commit_id": "b3ce84fea466f3bca2ff85d158744f00c0f429bd", "target": 0, "func": "static int qdev_add_one_global(QemuOpts *opts, void *opaque)\n\n{\n\n    GlobalProperty *g;\n\n    ObjectClass *oc;\n\n\n\n    g = g_malloc0(sizeof(*g));\n\n    g->driver   = qemu_opt_get(opts, \"driver\");\n\n    g->property = qemu_opt_get(opts, \"property\");\n\n    g->value    = qemu_opt_get(opts, \"value\");\n\n    oc = object_class_dynamic_cast(object_class_by_name(g->driver),\n\n                                   TYPE_DEVICE);\n\n    if (oc) {\n\n        DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n        if (dc->hotpluggable) {\n\n            /* If hotpluggable then skip not_used checking. */\n\n            g->not_used = false;\n\n        } else {\n\n            /* Maybe a typo. */\n\n            g->not_used = true;\n\n        }\n\n    } else {\n\n        /* Maybe a typo. */\n\n        g->not_used = true;\n\n    }\n\n    qdev_prop_register_global(g);\n\n    return 0;\n\n}\n", "idx": 22150}
{"project": "qemu", "commit_id": "fc3b32958a80bca13309e2695de07b43dd788421", "target": 0, "func": "static void smbios_build_type_1_fields(QemuOpts *opts)\n\n{\n\n    const char *val;\n\n\n\n    val = qemu_opt_get(opts, \"manufacturer\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, manufacturer_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"product\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, product_name_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"version\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, version_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"serial\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, serial_number_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"uuid\");\n\n    if (val) {\n\n        if (qemu_uuid_parse(val, qemu_uuid) != 0) {\n\n            error_report(\"Invalid UUID\");\n\n            exit(1);\n\n        }\n\n    }\n\n    val = qemu_opt_get(opts, \"sku\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, sku_number_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"family\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, family_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n}\n", "idx": 22151}
{"project": "qemu", "commit_id": "65c0f1e9558c7c762cdb333406243fff1d687117", "target": 0, "func": "static QObject *parse_array(JSONParserContext *ctxt, QList **tokens, va_list *ap)\n\n{\n\n    QList *list = NULL;\n\n    QObject *token, *peek;\n\n    QList *working = qlist_copy(*tokens);\n\n\n\n    token = qlist_pop(working);\n\n    if (token == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    if (!token_is_operator(token, '[')) {\n\n        goto out;\n\n    }\n\n    qobject_decref(token);\n\n    token = NULL;\n\n\n\n    list = qlist_new();\n\n\n\n    peek = qlist_peek(working);\n\n    if (peek == NULL) {\n\n        parse_error(ctxt, NULL, \"premature EOI\");\n\n        goto out;\n\n    }\n\n\n\n    if (!token_is_operator(peek, ']')) {\n\n        QObject *obj;\n\n\n\n        obj = parse_value(ctxt, &working, ap);\n\n        if (obj == NULL) {\n\n            parse_error(ctxt, token, \"expecting value\");\n\n            goto out;\n\n        }\n\n\n\n        qlist_append_obj(list, obj);\n\n\n\n        token = qlist_pop(working);\n\n        if (token == NULL) {\n\n            parse_error(ctxt, NULL, \"premature EOI\");\n\n            goto out;\n\n        }\n\n\n\n        while (!token_is_operator(token, ']')) {\n\n            if (!token_is_operator(token, ',')) {\n\n                parse_error(ctxt, token, \"expected separator in list\");\n\n                goto out;\n\n            }\n\n\n\n            qobject_decref(token);\n\n            token = NULL;\n\n\n\n            obj = parse_value(ctxt, &working, ap);\n\n            if (obj == NULL) {\n\n                parse_error(ctxt, token, \"expecting value\");\n\n                goto out;\n\n            }\n\n\n\n            qlist_append_obj(list, obj);\n\n\n\n            token = qlist_pop(working);\n\n            if (token == NULL) {\n\n                parse_error(ctxt, NULL, \"premature EOI\");\n\n                goto out;\n\n            }\n\n        }\n\n\n\n        qobject_decref(token);\n\n        token = NULL;\n\n    } else {\n\n        token = qlist_pop(working);\n\n        qobject_decref(token);\n\n        token = NULL;\n\n    }\n\n\n\n    QDECREF(*tokens);\n\n    *tokens = working;\n\n\n\n    return QOBJECT(list);\n\n\n\nout:\n\n    qobject_decref(token);\n\n    QDECREF(working);\n\n    QDECREF(list);\n\n    return NULL;\n\n}\n", "idx": 22152}
{"project": "qemu", "commit_id": "b08d0ea0446aa91f373c9df4254ba3bc4ee84098", "target": 0, "func": "static int scsi_disk_emulate_command(SCSIDiskReq *r)\n\n{\n\n    SCSIRequest *req = &r->req;\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    uint64_t nb_sectors;\n\n    uint8_t *outbuf;\n\n    int buflen = 0;\n\n\n\n    if (!r->iov.iov_base) {\n\n        /*\n\n         * FIXME: we shouldn't return anything bigger than 4k, but the code\n\n         * requires the buffer to be as big as req->cmd.xfer in several\n\n         * places.  So, do not allow CDBs with a very large ALLOCATION\n\n         * LENGTH.  The real fix would be to modify scsi_read_data and\n\n         * dma_buf_read, so that they return data beyond the buflen\n\n         * as all zeros.\n\n         */\n\n        if (req->cmd.xfer > 65536) {\n\n            goto illegal_request;\n\n        }\n\n        r->buflen = MAX(4096, req->cmd.xfer);\n\n        r->iov.iov_base = qemu_blockalign(s->qdev.conf.bs, r->buflen);\n\n    }\n\n\n\n    outbuf = r->iov.iov_base;\n\n    switch (req->cmd.buf[0]) {\n\n    case TEST_UNIT_READY:\n\n        assert(!s->tray_open && bdrv_is_inserted(s->qdev.conf.bs));\n\n        break;\n\n    case INQUIRY:\n\n        buflen = scsi_disk_emulate_inquiry(req, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case MODE_SENSE:\n\n    case MODE_SENSE_10:\n\n        buflen = scsi_disk_emulate_mode_sense(r, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case READ_TOC:\n\n        buflen = scsi_disk_emulate_read_toc(req, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case RESERVE:\n\n        if (req->cmd.buf[1] & 1) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case RESERVE_10:\n\n        if (req->cmd.buf[1] & 3) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case RELEASE:\n\n        if (req->cmd.buf[1] & 1) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case RELEASE_10:\n\n        if (req->cmd.buf[1] & 3) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case START_STOP:\n\n        if (scsi_disk_emulate_start_stop(r) < 0) {\n\n            return -1;\n\n        }\n\n        break;\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n        s->tray_locked = req->cmd.buf[4] & 1;\n\n        bdrv_lock_medium(s->qdev.conf.bs, req->cmd.buf[4] & 1);\n\n        break;\n\n    case READ_CAPACITY_10:\n\n        /* The normal LEN field for this command is zero.  */\n\n        memset(outbuf, 0, 8);\n\n        bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n        if (!nb_sectors) {\n\n            scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n\n            return -1;\n\n        }\n\n        if ((req->cmd.buf[8] & 1) == 0 && req->cmd.lba) {\n\n            goto illegal_request;\n\n        }\n\n        nb_sectors /= s->qdev.blocksize / 512;\n\n        /* Returned value is the address of the last sector.  */\n\n        nb_sectors--;\n\n        /* Remember the new size for read/write sanity checking. */\n\n        s->qdev.max_lba = nb_sectors;\n\n        /* Clip to 2TB, instead of returning capacity modulo 2TB. */\n\n        if (nb_sectors > UINT32_MAX) {\n\n            nb_sectors = UINT32_MAX;\n\n        }\n\n        outbuf[0] = (nb_sectors >> 24) & 0xff;\n\n        outbuf[1] = (nb_sectors >> 16) & 0xff;\n\n        outbuf[2] = (nb_sectors >> 8) & 0xff;\n\n        outbuf[3] = nb_sectors & 0xff;\n\n        outbuf[4] = 0;\n\n        outbuf[5] = 0;\n\n        outbuf[6] = s->qdev.blocksize >> 8;\n\n        outbuf[7] = 0;\n\n        buflen = 8;\n\n        break;\n\n    case REQUEST_SENSE:\n\n        /* Just return \"NO SENSE\".  */\n\n        buflen = scsi_build_sense(NULL, 0, outbuf, r->buflen,\n\n                                  (req->cmd.buf[1] & 1) == 0);\n\n        break;\n\n    case MECHANISM_STATUS:\n\n        buflen = scsi_emulate_mechanism_status(s, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case GET_CONFIGURATION:\n\n        buflen = scsi_get_configuration(s, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case GET_EVENT_STATUS_NOTIFICATION:\n\n        buflen = scsi_get_event_status_notification(s, r, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case READ_DISC_INFORMATION:\n\n        buflen = scsi_read_disc_information(s, r, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case READ_DVD_STRUCTURE:\n\n        buflen = scsi_read_dvd_structure(s, r, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case SERVICE_ACTION_IN_16:\n\n        /* Service Action In subcommands. */\n\n        if ((req->cmd.buf[1] & 31) == SAI_READ_CAPACITY_16) {\n\n            DPRINTF(\"SAI READ CAPACITY(16)\\n\");\n\n            memset(outbuf, 0, req->cmd.xfer);\n\n            bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n            if (!nb_sectors) {\n\n                scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n\n                return -1;\n\n            }\n\n            if ((req->cmd.buf[14] & 1) == 0 && req->cmd.lba) {\n\n                goto illegal_request;\n\n            }\n\n            nb_sectors /= s->qdev.blocksize / 512;\n\n            /* Returned value is the address of the last sector.  */\n\n            nb_sectors--;\n\n            /* Remember the new size for read/write sanity checking. */\n\n            s->qdev.max_lba = nb_sectors;\n\n            outbuf[0] = (nb_sectors >> 56) & 0xff;\n\n            outbuf[1] = (nb_sectors >> 48) & 0xff;\n\n            outbuf[2] = (nb_sectors >> 40) & 0xff;\n\n            outbuf[3] = (nb_sectors >> 32) & 0xff;\n\n            outbuf[4] = (nb_sectors >> 24) & 0xff;\n\n            outbuf[5] = (nb_sectors >> 16) & 0xff;\n\n            outbuf[6] = (nb_sectors >> 8) & 0xff;\n\n            outbuf[7] = nb_sectors & 0xff;\n\n            outbuf[8] = 0;\n\n            outbuf[9] = 0;\n\n            outbuf[10] = s->qdev.blocksize >> 8;\n\n            outbuf[11] = 0;\n\n            outbuf[12] = 0;\n\n            outbuf[13] = get_physical_block_exp(&s->qdev.conf);\n\n\n\n            /* set TPE bit if the format supports discard */\n\n            if (s->qdev.conf.discard_granularity) {\n\n                outbuf[14] = 0x80;\n\n            }\n\n\n\n            /* Protection, exponent and lowest lba field left blank. */\n\n            buflen = req->cmd.xfer;\n\n            break;\n\n        }\n\n        DPRINTF(\"Unsupported Service Action In\\n\");\n\n        goto illegal_request;\n\n    case SYNCHRONIZE_CACHE:\n\n        /* The request is used as the AIO opaque value, so add a ref.  */\n\n        scsi_req_ref(&r->req);\n\n        bdrv_acct_start(s->qdev.conf.bs, &r->acct, 0, BDRV_ACCT_FLUSH);\n\n        r->req.aiocb = bdrv_aio_flush(s->qdev.conf.bs, scsi_aio_complete, r);\n\n        return 0;\n\n    case SEEK_10:\n\n        DPRINTF(\"Seek(10) (sector %\" PRId64 \")\\n\", r->req.cmd.lba);\n\n        if (r->req.cmd.lba > s->qdev.max_lba) {\n\n            goto illegal_lba;\n\n        }\n\n        break;\n\n#if 0\n\n    case MODE_SELECT:\n\n        DPRINTF(\"Mode Select(6) (len %lu)\\n\", (long)r->req.cmd.xfer);\n\n        /* We don't support mode parameter changes.\n\n           Allow the mode parameter header + block descriptors only. */\n\n        if (r->req.cmd.xfer > 12) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case MODE_SELECT_10:\n\n        DPRINTF(\"Mode Select(10) (len %lu)\\n\", (long)r->req.cmd.xfer);\n\n        /* We don't support mode parameter changes.\n\n           Allow the mode parameter header + block descriptors only. */\n\n        if (r->req.cmd.xfer > 16) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n#endif\n\n    case WRITE_SAME_10:\n\n        nb_sectors = lduw_be_p(&req->cmd.buf[7]);\n\n        goto write_same;\n\n    case WRITE_SAME_16:\n\n        nb_sectors = ldl_be_p(&req->cmd.buf[10]) & 0xffffffffULL;\n\n    write_same:\n\n        if (r->req.cmd.lba > s->qdev.max_lba) {\n\n            goto illegal_lba;\n\n        }\n\n\n\n        /*\n\n         * We only support WRITE SAME with the unmap bit set for now.\n\n         */\n\n        if (!(req->cmd.buf[1] & 0x8)) {\n\n            goto illegal_request;\n\n        }\n\n\n\n        /* The request is used as the AIO opaque value, so add a ref.  */\n\n        scsi_req_ref(&r->req);\n\n        r->req.aiocb = bdrv_aio_discard(s->qdev.conf.bs,\n\n                                        r->req.cmd.lba * (s->qdev.blocksize / 512),\n\n                                        nb_sectors * (s->qdev.blocksize / 512),\n\n                                        scsi_aio_complete, r);\n\n        return 0;\n\n    default:\n\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n\n        return -1;\n\n    }\n\n    assert(r->sector_count == 0);\n\n    buflen = MIN(buflen, req->cmd.xfer);\n\n    return buflen;\n\n\n\nillegal_request:\n\n    if (r->req.status == -1) {\n\n        scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n\n    }\n\n    return -1;\n\n\n\nillegal_lba:\n\n    scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE));\n\n    return 0;\n\n}\n", "idx": 22153}
{"project": "qemu", "commit_id": "80376c3fc2c38fdd45354e4b0eb45031f35587ed", "target": 0, "func": "void qbus_create_inplace(BusState *bus, BusInfo *info,\n\n                         DeviceState *parent, const char *name)\n\n{\n\n    char *buf;\n\n    int i,len;\n\n\n\n    bus->info = info;\n\n    bus->parent = parent;\n\n\n\n    if (name) {\n\n        /* use supplied name */\n\n        bus->name = qemu_strdup(name);\n\n    } else if (parent && parent->id) {\n\n        /* parent device has id -> use it for bus name */\n\n        len = strlen(parent->id) + 16;\n\n        buf = qemu_malloc(len);\n\n        snprintf(buf, len, \"%s.%d\", parent->id, parent->num_child_bus);\n\n        bus->name = buf;\n\n    } else {\n\n        /* no id -> use lowercase bus type for bus name */\n\n        len = strlen(info->name) + 16;\n\n        buf = qemu_malloc(len);\n\n        len = snprintf(buf, len, \"%s.%d\", info->name,\n\n                       parent ? parent->num_child_bus : 0);\n\n        for (i = 0; i < len; i++)\n\n            buf[i] = qemu_tolower(buf[i]);\n\n        bus->name = buf;\n\n    }\n\n\n\n    QLIST_INIT(&bus->children);\n\n    if (parent) {\n\n        QLIST_INSERT_HEAD(&parent->child_bus, bus, sibling);\n\n        parent->num_child_bus++;\n\n    }\n\n\n\n}\n", "idx": 22154}
{"project": "qemu", "commit_id": "5829b097204189c56dd1fb62c7f827360394bb39", "target": 0, "func": "static void vmsvga_fifo_run(struct vmsvga_state_s *s)\n\n{\n\n    uint32_t cmd, colour;\n\n    int args, len;\n\n    int x, y, dx, dy, width, height;\n\n    struct vmsvga_cursor_definition_s cursor;\n\n    uint32_t cmd_start;\n\n\n\n    len = vmsvga_fifo_length(s);\n\n    while (len > 0) {\n\n        /* May need to go back to the start of the command if incomplete */\n\n        cmd_start = s->cmd->stop;\n\n\n\n        switch (cmd = vmsvga_fifo_read(s)) {\n\n        case SVGA_CMD_UPDATE:\n\n        case SVGA_CMD_UPDATE_VERBOSE:\n\n            len -= 5;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            x = vmsvga_fifo_read(s);\n\n            y = vmsvga_fifo_read(s);\n\n            width = vmsvga_fifo_read(s);\n\n            height = vmsvga_fifo_read(s);\n\n            vmsvga_update_rect_delayed(s, x, y, width, height);\n\n            break;\n\n\n\n        case SVGA_CMD_RECT_FILL:\n\n            len -= 6;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            colour = vmsvga_fifo_read(s);\n\n            x = vmsvga_fifo_read(s);\n\n            y = vmsvga_fifo_read(s);\n\n            width = vmsvga_fifo_read(s);\n\n            height = vmsvga_fifo_read(s);\n\n#ifdef HW_FILL_ACCEL\n\n            if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {\n\n                break;\n\n            }\n\n#endif\n\n            args = 0;\n\n            goto badcmd;\n\n\n\n        case SVGA_CMD_RECT_COPY:\n\n            len -= 7;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            x = vmsvga_fifo_read(s);\n\n            y = vmsvga_fifo_read(s);\n\n            dx = vmsvga_fifo_read(s);\n\n            dy = vmsvga_fifo_read(s);\n\n            width = vmsvga_fifo_read(s);\n\n            height = vmsvga_fifo_read(s);\n\n#ifdef HW_RECT_ACCEL\n\n            if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {\n\n                break;\n\n            }\n\n#endif\n\n            args = 0;\n\n            goto badcmd;\n\n\n\n        case SVGA_CMD_DEFINE_CURSOR:\n\n            len -= 8;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            cursor.id = vmsvga_fifo_read(s);\n\n            cursor.hot_x = vmsvga_fifo_read(s);\n\n            cursor.hot_y = vmsvga_fifo_read(s);\n\n            cursor.width = x = vmsvga_fifo_read(s);\n\n            cursor.height = y = vmsvga_fifo_read(s);\n\n            vmsvga_fifo_read(s);\n\n            cursor.bpp = vmsvga_fifo_read(s);\n\n\n\n            args = SVGA_BITMAP_SIZE(x, y) + SVGA_PIXMAP_SIZE(x, y, cursor.bpp);\n\n            if (SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||\n\n                SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {\n\n                    goto badcmd;\n\n            }\n\n\n\n            len -= args;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            for (args = 0; args < SVGA_BITMAP_SIZE(x, y); args++) {\n\n                cursor.mask[args] = vmsvga_fifo_read_raw(s);\n\n            }\n\n            for (args = 0; args < SVGA_PIXMAP_SIZE(x, y, cursor.bpp); args++) {\n\n                cursor.image[args] = vmsvga_fifo_read_raw(s);\n\n            }\n\n#ifdef HW_MOUSE_ACCEL\n\n            vmsvga_cursor_define(s, &cursor);\n\n            break;\n\n#else\n\n            args = 0;\n\n            goto badcmd;\n\n#endif\n\n\n\n        /*\n\n         * Other commands that we at least know the number of arguments\n\n         * for so we can avoid FIFO desync if driver uses them illegally.\n\n         */\n\n        case SVGA_CMD_DEFINE_ALPHA_CURSOR:\n\n            len -= 6;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n            vmsvga_fifo_read(s);\n\n            vmsvga_fifo_read(s);\n\n            vmsvga_fifo_read(s);\n\n            x = vmsvga_fifo_read(s);\n\n            y = vmsvga_fifo_read(s);\n\n            args = x * y;\n\n            goto badcmd;\n\n        case SVGA_CMD_RECT_ROP_FILL:\n\n            args = 6;\n\n            goto badcmd;\n\n        case SVGA_CMD_RECT_ROP_COPY:\n\n            args = 7;\n\n            goto badcmd;\n\n        case SVGA_CMD_DRAW_GLYPH_CLIPPED:\n\n            len -= 4;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n            vmsvga_fifo_read(s);\n\n            vmsvga_fifo_read(s);\n\n            args = 7 + (vmsvga_fifo_read(s) >> 2);\n\n            goto badcmd;\n\n        case SVGA_CMD_SURFACE_ALPHA_BLEND:\n\n            args = 12;\n\n            goto badcmd;\n\n\n\n        /*\n\n         * Other commands that are not listed as depending on any\n\n         * CAPABILITIES bits, but are not described in the README either.\n\n         */\n\n        case SVGA_CMD_SURFACE_FILL:\n\n        case SVGA_CMD_SURFACE_COPY:\n\n        case SVGA_CMD_FRONT_ROP_FILL:\n\n        case SVGA_CMD_FENCE:\n\n        case SVGA_CMD_INVALID_CMD:\n\n            break; /* Nop */\n\n\n\n        default:\n\n            args = 0;\n\n        badcmd:\n\n            len -= args;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n            while (args--) {\n\n                vmsvga_fifo_read(s);\n\n            }\n\n            printf(\"%s: Unknown command 0x%02x in SVGA command FIFO\\n\",\n\n                   __func__, cmd);\n\n            break;\n\n\n\n        rewind:\n\n            s->cmd->stop = cmd_start;\n\n            break;\n\n        }\n\n    }\n\n\n\n    s->syncing = 0;\n\n}\n", "idx": 22155}
{"project": "qemu", "commit_id": "a3f1afb43a09e4577571c044c48f2ba9e6e4ad06", "target": 0, "func": "int qcow2_cache_put(BlockDriverState *bs, Qcow2Cache *c, void **table)\n\n{\n\n    int i = qcow2_cache_get_table_idx(bs, c, *table);\n\n\n\n    if (c->entries[i].offset == 0) {\n\n        return -ENOENT;\n\n    }\n\n\n\n    c->entries[i].ref--;\n\n    *table = NULL;\n\n\n\n    if (c->entries[i].ref == 0) {\n\n        c->entries[i].lru_counter = ++c->lru_counter;\n\n    }\n\n\n\n    assert(c->entries[i].ref >= 0);\n\n    return 0;\n\n}\n", "idx": 22156}
{"project": "qemu", "commit_id": "cd42d5b23691ad73edfd6dbcfc935a960a9c5a65", "target": 0, "func": "void gen_intermediate_code_internal(LM32CPU *cpu,\n\n                                    TranslationBlock *tb, bool search_pc)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPULM32State *env = &cpu->env;\n\n    struct DisasContext ctx, *dc = &ctx;\n\n    uint16_t *gen_opc_end;\n\n    uint32_t pc_start;\n\n    int j, lj;\n\n    uint32_t next_page_start;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    pc_start = tb->pc;\n\n    dc->features = cpu->features;\n\n    dc->num_breakpoints = cpu->num_breakpoints;\n\n    dc->num_watchpoints = cpu->num_watchpoints;\n\n    dc->tb = tb;\n\n\n\n    gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE;\n\n\n\n    dc->is_jmp = DISAS_NEXT;\n\n    dc->pc = pc_start;\n\n    dc->singlestep_enabled = cs->singlestep_enabled;\n\n\n\n    if (pc_start & 3) {\n\n        qemu_log_mask(LOG_GUEST_ERROR,\n\n                      \"unaligned PC=%x. Ignoring lowest bits.\\n\", pc_start);\n\n        pc_start &= ~3;\n\n    }\n\n\n\n    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n\n    lj = -1;\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0) {\n\n        max_insns = CF_COUNT_MASK;\n\n    }\n\n\n\n    gen_tb_start();\n\n    do {\n\n        check_breakpoint(env, dc);\n\n\n\n        if (search_pc) {\n\n            j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j) {\n\n                    tcg_ctx.gen_opc_instr_start[lj++] = 0;\n\n                }\n\n            }\n\n            tcg_ctx.gen_opc_pc[lj] = dc->pc;\n\n            tcg_ctx.gen_opc_instr_start[lj] = 1;\n\n            tcg_ctx.gen_opc_icount[lj] = num_insns;\n\n        }\n\n\n\n        /* Pretty disas.  */\n\n        LOG_DIS(\"%8.8x:\\t\", dc->pc);\n\n\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO)) {\n\n            gen_io_start();\n\n        }\n\n\n\n        decode(dc, cpu_ldl_code(env, dc->pc));\n\n        dc->pc += 4;\n\n        num_insns++;\n\n\n\n    } while (!dc->is_jmp\n\n         && tcg_ctx.gen_opc_ptr < gen_opc_end\n\n         && !cs->singlestep_enabled\n\n         && !singlestep\n\n         && (dc->pc < next_page_start)\n\n         && num_insns < max_insns);\n\n\n\n    if (tb->cflags & CF_LAST_IO) {\n\n        gen_io_end();\n\n    }\n\n\n\n    if (unlikely(cs->singlestep_enabled)) {\n\n        if (dc->is_jmp == DISAS_NEXT) {\n\n            tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n        }\n\n        t_gen_raise_exception(dc, EXCP_DEBUG);\n\n    } else {\n\n        switch (dc->is_jmp) {\n\n        case DISAS_NEXT:\n\n            gen_goto_tb(dc, 1, dc->pc);\n\n            break;\n\n        default:\n\n        case DISAS_JUMP:\n\n        case DISAS_UPDATE:\n\n            /* indicate that the hash table must be used\n\n               to find the next TB */\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        case DISAS_TB_JUMP:\n\n            /* nothing more to generate */\n\n            break;\n\n        }\n\n    }\n\n\n\n    gen_tb_end(tb, num_insns);\n\n    *tcg_ctx.gen_opc_ptr = INDEX_op_end;\n\n    if (search_pc) {\n\n        j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j) {\n\n            tcg_ctx.gen_opc_instr_start[lj++] = 0;\n\n        }\n\n    } else {\n\n        tb->size = dc->pc - pc_start;\n\n        tb->icount = num_insns;\n\n    }\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"\\n\");\n\n        log_target_disas(env, pc_start, dc->pc - pc_start, 0);\n\n        qemu_log(\"\\nisize=%d osize=%td\\n\",\n\n            dc->pc - pc_start, tcg_ctx.gen_opc_ptr -\n\n            tcg_ctx.gen_opc_buf);\n\n    }\n\n#endif\n\n}\n", "idx": 22157}
{"project": "qemu", "commit_id": "3ab493de4c524926bb75b04765b644f9189ccf01", "target": 0, "func": "void helper_lsl(void)\n\n{\n\n    unsigned int selector, limit;\n\n    uint32_t e1, e2;\n\n\n\n    CC_SRC = cc_table[CC_OP].compute_all() & ~CC_Z;\n\n    selector = T0 & 0xffff;\n\n    if (load_segment(&e1, &e2, selector) != 0)\n\n        return;\n\n    limit = (e1 & 0xffff) | (e2 & 0x000f0000);\n\n    if (e2 & (1 << 23))\n\n        limit = (limit << 12) | 0xfff;\n\n    T1 = limit;\n\n    CC_SRC |= CC_Z;\n\n}\n", "idx": 22158}
{"project": "qemu", "commit_id": "dd673288a8ff73ad77fcc1c255486d2466a772e1", "target": 0, "func": "static void apic_reset_common(DeviceState *d)\n\n{\n\n    APICCommonState *s = DO_UPCAST(APICCommonState, busdev.qdev, d);\n\n    APICCommonClass *info = APIC_COMMON_GET_CLASS(s);\n\n    bool bsp;\n\n\n\n    bsp = cpu_is_bsp(s->cpu_env);\n\n    s->apicbase = 0xfee00000 |\n\n        (bsp ? MSR_IA32_APICBASE_BSP : 0) | MSR_IA32_APICBASE_ENABLE;\n\n\n\n    s->vapic_paddr = 0;\n\n    info->vapic_base_update(s);\n\n\n\n    apic_init_reset(d);\n\n\n\n    if (bsp) {\n\n        /*\n\n         * LINT0 delivery mode on CPU #0 is set to ExtInt at initialization\n\n         * time typically by BIOS, so PIC interrupt can be delivered to the\n\n         * processor when local APIC is enabled.\n\n         */\n\n        s->lvt[APIC_LVT_LINT0] = 0x700;\n\n    }\n\n}\n", "idx": 22160}
{"project": "qemu", "commit_id": "4a9f9cb24de52e93aae7539a004dd20314ca1c0c", "target": 0, "func": "uint32_t HELPER(neon_max_f32)(uint32_t a, uint32_t b)\n\n{\n\n    float32 f0 = make_float32(a);\n\n    float32 f1 = make_float32(b);\n\n    return (float32_compare_quiet(f0, f1, NFS) == 1) ? a : b;\n\n}\n", "idx": 22161}
{"project": "qemu", "commit_id": "973e7170dddefb491a48df5cba33b2ae151013a0", "target": 1, "func": "static void virtqueue_map_desc(unsigned int *p_num_sg, hwaddr *addr, struct iovec *iov,\n                               unsigned int max_num_sg, bool is_write,\n                               hwaddr pa, size_t sz)\n{\n    unsigned num_sg = *p_num_sg;\n    assert(num_sg <= max_num_sg);\n    if (!sz) {\n        error_report(\"virtio: zero sized buffers are not allowed\");\n    while (sz) {\n        hwaddr len = sz;\n        if (num_sg == max_num_sg) {\n            error_report(\"virtio: too many write descriptors in indirect table\");\n        iov[num_sg].iov_base = cpu_physical_memory_map(pa, &len, is_write);\n        iov[num_sg].iov_len = len;\n        addr[num_sg] = pa;\n        sz -= len;\n        pa += len;\n        num_sg++;\n    *p_num_sg = num_sg;", "idx": 22162}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void tcp_start_outgoing_migration(MigrationState *s, const char *host_port, Error **errp)\n\n{\n\n    inet_nonblocking_connect(host_port, tcp_wait_for_connect, s, errp);\n\n}\n", "idx": 22163}
{"project": "qemu", "commit_id": "53593e90d13264dc88b3281ddf75ceaa641df05a", "target": 1, "func": "static void gen_check_sr(DisasContext *dc, uint32_t sr)\n\n{\n\n    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {\n\n        if (sregnames[sr].name) {\n\n            qemu_log(\"SR %s is not configured\\n\", sregnames[sr].name);\n\n        } else {\n\n            qemu_log(\"SR %d is not implemented\\n\", sr);\n\n        }\n\n        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n    }\n\n}\n", "idx": 22165}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int bt_hid_out(struct bt_hid_device_s *s)\n\n{\n\n    USBPacket p;\n\n\n\n    if (s->data_type == BT_DATA_OUTPUT) {\n\n        p.pid = USB_TOKEN_OUT;\n\n        p.devep = 1;\n\n        p.data = s->dataout.buffer;\n\n        p.len = s->dataout.len;\n\n        s->dataout.len = s->usbdev->info->handle_data(s->usbdev, &p);\n\n\n\n        return s->dataout.len;\n\n    }\n\n\n\n    if (s->data_type == BT_DATA_FEATURE) {\n\n        /* XXX:\n\n         * does this send a USB_REQ_CLEAR_FEATURE/USB_REQ_SET_FEATURE\n\n         * or a SET_REPORT? */\n\n        p.devep = 0;\n\n    }\n\n\n\n    return -1;\n\n}\n", "idx": 22166}
{"project": "qemu", "commit_id": "69583490856713f693291b32fc74b6d0f5992b72", "target": 1, "func": "static int hdev_get_max_segments(const struct stat *st)\n\n{\n\n#ifdef CONFIG_LINUX\n\n    char buf[32];\n\n    const char *end;\n\n    char *sysfspath;\n\n    int ret;\n\n    int fd = -1;\n\n    long max_segments;\n\n\n\n    sysfspath = g_strdup_printf(\"/sys/dev/block/%u:%u/queue/max_segments\",\n\n                                major(st->st_rdev), minor(st->st_rdev));\n\n    fd = open(sysfspath, O_RDONLY);\n\n    if (fd == -1) {\n\n        ret = -errno;\n\n        goto out;\n\n    }\n\n    do {\n\n        ret = read(fd, buf, sizeof(buf));\n\n    } while (ret == -1 && errno == EINTR);\n\n    if (ret < 0) {\n\n        ret = -errno;\n\n        goto out;\n\n    } else if (ret == 0) {\n\n        ret = -EIO;\n\n        goto out;\n\n    }\n\n    buf[ret] = 0;\n\n    /* The file is ended with '\\n', pass 'end' to accept that. */\n\n    ret = qemu_strtol(buf, &end, 10, &max_segments);\n\n    if (ret == 0 && end && *end == '\\n') {\n\n        ret = max_segments;\n\n    }\n\n\n\nout:\n\n    g_free(sysfspath);\n\n    return ret;\n\n#else\n\n    return -ENOTSUP;\n\n#endif\n\n}\n", "idx": 22167}
{"project": "qemu", "commit_id": "65a8e1f6413a0f6f79894da710b5d6d43361d27d", "target": 1, "func": "size_t mptsas_config_manufacturing_1(MPTSASState *s, uint8_t **data, int address)\n\n{\n\n    /* VPD - all zeros */\n\n    return MPTSAS_CONFIG_PACK(1, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,\n\n                              \"s256\");\n\n}\n", "idx": 22168}
{"project": "qemu", "commit_id": "082c6681b6c4af0035d9dad34a4a784be8c21dbe", "target": 0, "func": "static void init_proc_620 (CPUPPCState *env)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_spr_620(env);\n\n    /* Time base */\n\n    gen_tbl(env);\n\n    /* Hardware implementation registers */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Memory management */\n\n    gen_low_BATs(env);\n\n    gen_high_BATs(env);\n\n    init_excp_620(env);\n\n    env->dcache_line_size = 64;\n\n    env->icache_line_size = 64;\n\n    /* Allocate hardware IRQ controller */\n\n    ppc6xx_irq_init(env);\n\n}\n", "idx": 22169}
{"project": "qemu", "commit_id": "2d1a35bef0ed96b3f23535e459c552414ccdbafd", "target": 0, "func": "static void kvm_set_phys_mem(MemoryRegionSection *section, bool add)\n\n{\n\n    KVMState *s = kvm_state;\n\n    KVMSlot *mem, old;\n\n    int err;\n\n    MemoryRegion *mr = section->mr;\n\n    bool log_dirty = memory_region_is_logging(mr);\n\n    bool writeable = !mr->readonly && !mr->rom_device;\n\n    bool readonly_flag = mr->readonly || memory_region_is_romd(mr);\n\n    hwaddr start_addr = section->offset_within_address_space;\n\n    ram_addr_t size = int128_get64(section->size);\n\n    void *ram = NULL;\n\n    unsigned delta;\n\n\n\n    /* kvm works in page size chunks, but the function may be called\n\n       with sub-page size and unaligned start address. Pad the start\n\n       address to next and truncate size to previous page boundary. */\n\n    delta = (TARGET_PAGE_SIZE - (start_addr & ~TARGET_PAGE_MASK));\n\n    delta &= ~TARGET_PAGE_MASK;\n\n    if (delta > size) {\n\n        return;\n\n    }\n\n    start_addr += delta;\n\n    size -= delta;\n\n    size &= TARGET_PAGE_MASK;\n\n    if (!size || (start_addr & ~TARGET_PAGE_MASK)) {\n\n        return;\n\n    }\n\n\n\n    if (!memory_region_is_ram(mr)) {\n\n        if (writeable || !kvm_readonly_mem_allowed) {\n\n            return;\n\n        } else if (!mr->romd_mode) {\n\n            /* If the memory device is not in romd_mode, then we actually want\n\n             * to remove the kvm memory slot so all accesses will trap. */\n\n            add = false;\n\n        }\n\n    }\n\n\n\n    ram = memory_region_get_ram_ptr(mr) + section->offset_within_region + delta;\n\n\n\n    while (1) {\n\n        mem = kvm_lookup_overlapping_slot(s, start_addr, start_addr + size);\n\n        if (!mem) {\n\n            break;\n\n        }\n\n\n\n        if (add && start_addr >= mem->start_addr &&\n\n            (start_addr + size <= mem->start_addr + mem->memory_size) &&\n\n            (ram - start_addr == mem->ram - mem->start_addr)) {\n\n            /* The new slot fits into the existing one and comes with\n\n             * identical parameters - update flags and done. */\n\n            kvm_slot_dirty_pages_log_change(mem, log_dirty);\n\n            return;\n\n        }\n\n\n\n        old = *mem;\n\n\n\n        if ((mem->flags & KVM_MEM_LOG_DIRTY_PAGES) || s->migration_log) {\n\n            kvm_physical_sync_dirty_bitmap(section);\n\n        }\n\n\n\n        /* unregister the overlapping slot */\n\n        mem->memory_size = 0;\n\n        err = kvm_set_user_memory_region(s, mem);\n\n        if (err) {\n\n            fprintf(stderr, \"%s: error unregistering overlapping slot: %s\\n\",\n\n                    __func__, strerror(-err));\n\n            abort();\n\n        }\n\n\n\n        /* Workaround for older KVM versions: we can't join slots, even not by\n\n         * unregistering the previous ones and then registering the larger\n\n         * slot. We have to maintain the existing fragmentation. Sigh.\n\n         *\n\n         * This workaround assumes that the new slot starts at the same\n\n         * address as the first existing one. If not or if some overlapping\n\n         * slot comes around later, we will fail (not seen in practice so far)\n\n         * - and actually require a recent KVM version. */\n\n        if (s->broken_set_mem_region &&\n\n            old.start_addr == start_addr && old.memory_size < size && add) {\n\n            mem = kvm_alloc_slot(s);\n\n            mem->memory_size = old.memory_size;\n\n            mem->start_addr = old.start_addr;\n\n            mem->ram = old.ram;\n\n            mem->flags = kvm_mem_flags(s, log_dirty, readonly_flag);\n\n\n\n            err = kvm_set_user_memory_region(s, mem);\n\n            if (err) {\n\n                fprintf(stderr, \"%s: error updating slot: %s\\n\", __func__,\n\n                        strerror(-err));\n\n                abort();\n\n            }\n\n\n\n            start_addr += old.memory_size;\n\n            ram += old.memory_size;\n\n            size -= old.memory_size;\n\n            continue;\n\n        }\n\n\n\n        /* register prefix slot */\n\n        if (old.start_addr < start_addr) {\n\n            mem = kvm_alloc_slot(s);\n\n            mem->memory_size = start_addr - old.start_addr;\n\n            mem->start_addr = old.start_addr;\n\n            mem->ram = old.ram;\n\n            mem->flags =  kvm_mem_flags(s, log_dirty, readonly_flag);\n\n\n\n            err = kvm_set_user_memory_region(s, mem);\n\n            if (err) {\n\n                fprintf(stderr, \"%s: error registering prefix slot: %s\\n\",\n\n                        __func__, strerror(-err));\n\n#ifdef TARGET_PPC\n\n                fprintf(stderr, \"%s: This is probably because your kernel's \" \\\n\n                                \"PAGE_SIZE is too big. Please try to use 4k \" \\\n\n                                \"PAGE_SIZE!\\n\", __func__);\n\n#endif\n\n                abort();\n\n            }\n\n        }\n\n\n\n        /* register suffix slot */\n\n        if (old.start_addr + old.memory_size > start_addr + size) {\n\n            ram_addr_t size_delta;\n\n\n\n            mem = kvm_alloc_slot(s);\n\n            mem->start_addr = start_addr + size;\n\n            size_delta = mem->start_addr - old.start_addr;\n\n            mem->memory_size = old.memory_size - size_delta;\n\n            mem->ram = old.ram + size_delta;\n\n            mem->flags = kvm_mem_flags(s, log_dirty, readonly_flag);\n\n\n\n            err = kvm_set_user_memory_region(s, mem);\n\n            if (err) {\n\n                fprintf(stderr, \"%s: error registering suffix slot: %s\\n\",\n\n                        __func__, strerror(-err));\n\n                abort();\n\n            }\n\n        }\n\n    }\n\n\n\n    /* in case the KVM bug workaround already \"consumed\" the new slot */\n\n    if (!size) {\n\n        return;\n\n    }\n\n    if (!add) {\n\n        return;\n\n    }\n\n    mem = kvm_alloc_slot(s);\n\n    mem->memory_size = size;\n\n    mem->start_addr = start_addr;\n\n    mem->ram = ram;\n\n    mem->flags = kvm_mem_flags(s, log_dirty, readonly_flag);\n\n\n\n    err = kvm_set_user_memory_region(s, mem);\n\n    if (err) {\n\n        fprintf(stderr, \"%s: error registering slot: %s\\n\", __func__,\n\n                strerror(-err));\n\n        abort();\n\n    }\n\n}\n", "idx": 22170}
{"project": "qemu", "commit_id": "5e755519ac9d867f7da13f58a9d0c262db82e14c", "target": 0, "func": "static void gen_flt3_ldst (DisasContext *ctx, uint32_t opc, int fd,\n\n                           int fs, int base, int index)\n\n{\n\n    const char *opn = \"extended float load/store\";\n\n    int store = 0;\n\n\n\n    /* All of those work only on 64bit FPUs. */\n\n    gen_op_cp1_64bitmode();\n\n    if (base == 0) {\n\n        if (index == 0)\n\n            gen_op_reset_T0();\n\n        else\n\n            GEN_LOAD_REG_TN(T0, index);\n\n    } else if (index == 0) {\n\n        GEN_LOAD_REG_TN(T0, base);\n\n    } else {\n\n        GEN_LOAD_REG_TN(T0, base);\n\n        GEN_LOAD_REG_TN(T1, index);\n\n        gen_op_addr_add();\n\n    }\n\n    /* Don't do NOP if destination is zero: we must perform the actual\n\n     * memory access\n\n     */\n\n    switch (opc) {\n\n    case OPC_LWXC1:\n\n        op_ldst(lwc1);\n\n        GEN_STORE_FTN_FREG(fd, WT0);\n\n        opn = \"lwxc1\";\n\n        break;\n\n    case OPC_LDXC1:\n\n        op_ldst(ldc1);\n\n        GEN_STORE_FTN_FREG(fd, DT0);\n\n        opn = \"ldxc1\";\n\n        break;\n\n    case OPC_LUXC1:\n\n        op_ldst(luxc1);\n\n        GEN_STORE_FTN_FREG(fd, DT0);\n\n        opn = \"luxc1\";\n\n        break;\n\n    case OPC_SWXC1:\n\n        GEN_LOAD_FREG_FTN(WT0, fs);\n\n        op_ldst(swc1);\n\n        opn = \"swxc1\";\n\n        store = 1;\n\n        break;\n\n    case OPC_SDXC1:\n\n        GEN_LOAD_FREG_FTN(DT0, fs);\n\n        op_ldst(sdc1);\n\n        opn = \"sdxc1\";\n\n        store = 1;\n\n        break;\n\n    case OPC_SUXC1:\n\n        GEN_LOAD_FREG_FTN(DT0, fs);\n\n        op_ldst(suxc1);\n\n        opn = \"suxc1\";\n\n        store = 1;\n\n        break;\n\n    default:\n\n        MIPS_INVAL(opn);\n\n        generate_exception(ctx, EXCP_RI);\n\n        return;\n\n    }\n\n    MIPS_DEBUG(\"%s %s, %s(%s)\", opn, fregnames[store ? fs : fd],\n\n               regnames[index], regnames[base]);\n\n}\n", "idx": 22172}
{"project": "qemu", "commit_id": "680c1c6fd73c0cb3971938944936f18bbb7bad1b", "target": 0, "func": "static DeviceState *apic_init(void *env, uint8_t apic_id)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *d;\n\n    static int apic_mapped;\n\n\n\n    dev = qdev_create(NULL, \"apic\");\n\n    qdev_prop_set_uint8(dev, \"id\", apic_id);\n\n    qdev_prop_set_ptr(dev, \"cpu_env\", env);\n\n    qdev_init_nofail(dev);\n\n    d = sysbus_from_qdev(dev);\n\n\n\n    /* XXX: mapping more APICs at the same memory location */\n\n    if (apic_mapped == 0) {\n\n        /* NOTE: the APIC is directly connected to the CPU - it is not\n\n           on the global memory bus. */\n\n        /* XXX: what if the base changes? */\n\n        sysbus_mmio_map(d, 0, MSI_ADDR_BASE);\n\n        apic_mapped = 1;\n\n    }\n\n\n\n    msi_supported = true;\n\n\n\n    return dev;\n\n}\n", "idx": 22173}
{"project": "qemu", "commit_id": "f287b2c2d4d20d35880ab6dca44bda0476e67dce", "target": 0, "func": "abi_long do_syscall(void *cpu_env, int num, abi_long arg1,\n\n                    abi_long arg2, abi_long arg3, abi_long arg4,\n\n                    abi_long arg5, abi_long arg6, abi_long arg7,\n\n                    abi_long arg8)\n\n{\n\n    abi_long ret;\n\n    struct stat st;\n\n    struct statfs stfs;\n\n    void *p;\n\n\n\n#ifdef DEBUG\n\n    gemu_log(\"syscall %d\", num);\n\n#endif\n\n    if(do_strace)\n\n        print_syscall(num, arg1, arg2, arg3, arg4, arg5, arg6);\n\n\n\n    switch(num) {\n\n    case TARGET_NR_exit:\n\n#ifdef CONFIG_USE_NPTL\n\n      /* In old applications this may be used to implement _exit(2).\n\n         However in threaded applictions it is used for thread termination,\n\n         and _exit_group is used for application termination.\n\n         Do thread termination if we have more then one thread.  */\n\n      /* FIXME: This probably breaks if a signal arrives.  We should probably\n\n         be disabling signals.  */\n\n      if (first_cpu->next_cpu) {\n\n          TaskState *ts;\n\n          CPUArchState **lastp;\n\n          CPUArchState *p;\n\n\n\n          cpu_list_lock();\n\n          lastp = &first_cpu;\n\n          p = first_cpu;\n\n          while (p && p != (CPUArchState *)cpu_env) {\n\n              lastp = &p->next_cpu;\n\n              p = p->next_cpu;\n\n          }\n\n          /* If we didn't find the CPU for this thread then something is\n\n             horribly wrong.  */\n\n          if (!p)\n\n              abort();\n\n          /* Remove the CPU from the list.  */\n\n          *lastp = p->next_cpu;\n\n          cpu_list_unlock();\n\n          ts = ((CPUArchState *)cpu_env)->opaque;\n\n          if (ts->child_tidptr) {\n\n              put_user_u32(0, ts->child_tidptr);\n\n              sys_futex(g2h(ts->child_tidptr), FUTEX_WAKE, INT_MAX,\n\n                        NULL, NULL, 0);\n\n          }\n\n          thread_env = NULL;\n\n          object_delete(OBJECT(ENV_GET_CPU(cpu_env)));\n\n          g_free(ts);\n\n          pthread_exit(NULL);\n\n      }\n\n#endif\n\n#ifdef TARGET_GPROF\n\n        _mcleanup();\n\n#endif\n\n        gdb_exit(cpu_env, arg1);\n\n        _exit(arg1);\n\n        ret = 0; /* avoid warning */\n\n        break;\n\n    case TARGET_NR_read:\n\n        if (arg3 == 0)\n\n            ret = 0;\n\n        else {\n\n            if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))\n\n                goto efault;\n\n            ret = get_errno(read(arg1, p, arg3));\n\n            unlock_user(p, arg2, ret);\n\n        }\n\n        break;\n\n    case TARGET_NR_write:\n\n        if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))\n\n            goto efault;\n\n        ret = get_errno(write(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n    case TARGET_NR_open:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(do_open(cpu_env, p,\n\n                                target_to_host_bitmask(arg2, fcntl_flags_tbl),\n\n                                arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_openat) && defined(__NR_openat)\n\n    case TARGET_NR_openat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_openat(arg1,\n\n                                   path(p),\n\n                                   target_to_host_bitmask(arg3, fcntl_flags_tbl),\n\n                                   arg4));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_close:\n\n        ret = get_errno(close(arg1));\n\n        break;\n\n    case TARGET_NR_brk:\n\n        ret = do_brk(arg1);\n\n        break;\n\n    case TARGET_NR_fork:\n\n        ret = get_errno(do_fork(cpu_env, SIGCHLD, 0, 0, 0, 0));\n\n        break;\n\n#ifdef TARGET_NR_waitpid\n\n    case TARGET_NR_waitpid:\n\n        {\n\n            int status;\n\n            ret = get_errno(waitpid(arg1, &status, arg3));\n\n            if (!is_error(ret) && arg2 && ret\n\n                && put_user_s32(host_to_target_waitstatus(status), arg2))\n\n                goto efault;\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_waitid\n\n    case TARGET_NR_waitid:\n\n        {\n\n            siginfo_t info;\n\n            info.si_pid = 0;\n\n            ret = get_errno(waitid(arg1, arg2, &info, arg4));\n\n            if (!is_error(ret) && arg3 && info.si_pid != 0) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_siginfo_t), 0)))\n\n                    goto efault;\n\n                host_to_target_siginfo(p, &info);\n\n                unlock_user(p, arg3, sizeof(target_siginfo_t));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_creat /* not on alpha */\n\n    case TARGET_NR_creat:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(creat(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_link:\n\n        {\n\n            void * p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg2);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(link(p, p2));\n\n            unlock_user(p2, arg2, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_linkat) && defined(__NR_linkat)\n\n    case TARGET_NR_linkat:\n\n        {\n\n            void * p2 = NULL;\n\n            if (!arg2 || !arg4)\n\n                goto efault;\n\n            p  = lock_user_string(arg2);\n\n            p2 = lock_user_string(arg4);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_linkat(arg1, p, arg3, p2, arg5));\n\n            unlock_user(p, arg2, 0);\n\n            unlock_user(p2, arg4, 0);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_unlink:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(unlink(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_unlinkat) && defined(__NR_unlinkat)\n\n    case TARGET_NR_unlinkat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_unlinkat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_execve:\n\n        {\n\n            char **argp, **envp;\n\n            int argc, envc;\n\n            abi_ulong gp;\n\n            abi_ulong guest_argp;\n\n            abi_ulong guest_envp;\n\n            abi_ulong addr;\n\n            char **q;\n\n            int total_size = 0;\n\n\n\n            argc = 0;\n\n            guest_argp = arg2;\n\n            for (gp = guest_argp; gp; gp += sizeof(abi_ulong)) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto efault;\n\n                if (!addr)\n\n                    break;\n\n                argc++;\n\n            }\n\n            envc = 0;\n\n            guest_envp = arg3;\n\n            for (gp = guest_envp; gp; gp += sizeof(abi_ulong)) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto efault;\n\n                if (!addr)\n\n                    break;\n\n                envc++;\n\n            }\n\n\n\n            argp = alloca((argc + 1) * sizeof(void *));\n\n            envp = alloca((envc + 1) * sizeof(void *));\n\n\n\n            for (gp = guest_argp, q = argp; gp;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto execve_efault;\n\n                if (!addr)\n\n                    break;\n\n                if (!(*q = lock_user_string(addr)))\n\n                    goto execve_efault;\n\n                total_size += strlen(*q) + 1;\n\n            }\n\n            *q = NULL;\n\n\n\n            for (gp = guest_envp, q = envp; gp;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto execve_efault;\n\n                if (!addr)\n\n                    break;\n\n                if (!(*q = lock_user_string(addr)))\n\n                    goto execve_efault;\n\n                total_size += strlen(*q) + 1;\n\n            }\n\n            *q = NULL;\n\n\n\n            /* This case will not be caught by the host's execve() if its\n\n               page size is bigger than the target's. */\n\n            if (total_size > MAX_ARG_PAGES * TARGET_PAGE_SIZE) {\n\n                ret = -TARGET_E2BIG;\n\n                goto execve_end;\n\n            }\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto execve_efault;\n\n            ret = get_errno(execve(p, argp, envp));\n\n            unlock_user(p, arg1, 0);\n\n\n\n            goto execve_end;\n\n\n\n        execve_efault:\n\n            ret = -TARGET_EFAULT;\n\n\n\n        execve_end:\n\n            for (gp = guest_argp, q = argp; *q;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp)\n\n                    || !addr)\n\n                    break;\n\n                unlock_user(*q, addr, 0);\n\n            }\n\n            for (gp = guest_envp, q = envp; *q;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp)\n\n                    || !addr)\n\n                    break;\n\n                unlock_user(*q, addr, 0);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_chdir:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chdir(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_time\n\n    case TARGET_NR_time:\n\n        {\n\n            time_t host_time;\n\n            ret = get_errno(time(&host_time));\n\n            if (!is_error(ret)\n\n                && arg1\n\n                && put_user_sal(host_time, arg1))\n\n                goto efault;\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_mknod:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(mknod(p, arg2, arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_mknodat) && defined(__NR_mknodat)\n\n    case TARGET_NR_mknodat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_mknodat(arg1, p, arg3, arg4));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_chmod:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chmod(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_break\n\n    case TARGET_NR_break:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_oldstat\n\n    case TARGET_NR_oldstat:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_lseek:\n\n        ret = get_errno(lseek(arg1, arg2, arg3));\n\n        break;\n\n#if defined(TARGET_NR_getxpid) && defined(TARGET_ALPHA)\n\n    /* Alpha specific */\n\n    case TARGET_NR_getxpid:\n\n        ((CPUAlphaState *)cpu_env)->ir[IR_A4] = getppid();\n\n        ret = get_errno(getpid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getpid\n\n    case TARGET_NR_getpid:\n\n        ret = get_errno(getpid());\n\n        break;\n\n#endif\n\n    case TARGET_NR_mount:\n\n\t\t{\n\n\t\t\t/* need to look at the data field */\n\n\t\t\tvoid *p2, *p3;\n\n\t\t\tp = lock_user_string(arg1);\n\n\t\t\tp2 = lock_user_string(arg2);\n\n\t\t\tp3 = lock_user_string(arg3);\n\n                        if (!p || !p2 || !p3)\n\n                            ret = -TARGET_EFAULT;\n\n                        else {\n\n                            /* FIXME - arg5 should be locked, but it isn't clear how to\n\n                             * do that since it's not guaranteed to be a NULL-terminated\n\n                             * string.\n\n                             */\n\n                            if ( ! arg5 )\n\n                                ret = get_errno(mount(p, p2, p3, (unsigned long)arg4, NULL));\n\n                            else\n\n                                ret = get_errno(mount(p, p2, p3, (unsigned long)arg4, g2h(arg5)));\n\n                        }\n\n                        unlock_user(p, arg1, 0);\n\n                        unlock_user(p2, arg2, 0);\n\n                        unlock_user(p3, arg3, 0);\n\n\t\t\tbreak;\n\n\t\t}\n\n#ifdef TARGET_NR_umount\n\n    case TARGET_NR_umount:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(umount(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_stime /* not on alpha */\n\n    case TARGET_NR_stime:\n\n        {\n\n            time_t host_time;\n\n            if (get_user_sal(host_time, arg1))\n\n                goto efault;\n\n            ret = get_errno(stime(&host_time));\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_ptrace:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_alarm /* not on alpha */\n\n    case TARGET_NR_alarm:\n\n        ret = alarm(arg1);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_oldfstat\n\n    case TARGET_NR_oldfstat:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_pause /* not on alpha */\n\n    case TARGET_NR_pause:\n\n        ret = get_errno(pause());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_utime\n\n    case TARGET_NR_utime:\n\n        {\n\n            struct utimbuf tbuf, *host_tbuf;\n\n            struct target_utimbuf *target_tbuf;\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, target_tbuf, arg2, 1))\n\n                    goto efault;\n\n                tbuf.actime = tswapal(target_tbuf->actime);\n\n                tbuf.modtime = tswapal(target_tbuf->modtime);\n\n                unlock_user_struct(target_tbuf, arg2, 0);\n\n                host_tbuf = &tbuf;\n\n            } else {\n\n                host_tbuf = NULL;\n\n            }\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto efault;\n\n            ret = get_errno(utime(p, host_tbuf));\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_utimes:\n\n        {\n\n            struct timeval *tvp, tv[2];\n\n            if (arg2) {\n\n                if (copy_from_user_timeval(&tv[0], arg2)\n\n                    || copy_from_user_timeval(&tv[1],\n\n                                              arg2 + sizeof(struct target_timeval)))\n\n                    goto efault;\n\n                tvp = tv;\n\n            } else {\n\n                tvp = NULL;\n\n            }\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto efault;\n\n            ret = get_errno(utimes(p, tvp));\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_futimesat) && defined(__NR_futimesat)\n\n    case TARGET_NR_futimesat:\n\n        {\n\n            struct timeval *tvp, tv[2];\n\n            if (arg3) {\n\n                if (copy_from_user_timeval(&tv[0], arg3)\n\n                    || copy_from_user_timeval(&tv[1],\n\n                                              arg3 + sizeof(struct target_timeval)))\n\n                    goto efault;\n\n                tvp = tv;\n\n            } else {\n\n                tvp = NULL;\n\n            }\n\n            if (!(p = lock_user_string(arg2)))\n\n                goto efault;\n\n            ret = get_errno(sys_futimesat(arg1, path(p), tvp));\n\n            unlock_user(p, arg2, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_stty\n\n    case TARGET_NR_stty:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_gtty\n\n    case TARGET_NR_gtty:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_access:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(access(path(p), arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_faccessat) && defined(__NR_faccessat)\n\n    case TARGET_NR_faccessat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_faccessat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_nice /* not on alpha */\n\n    case TARGET_NR_nice:\n\n        ret = get_errno(nice(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_ftime\n\n    case TARGET_NR_ftime:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_sync:\n\n        sync();\n\n        ret = 0;\n\n        break;\n\n    case TARGET_NR_kill:\n\n        ret = get_errno(kill(arg1, target_to_host_signal(arg2)));\n\n        break;\n\n    case TARGET_NR_rename:\n\n        {\n\n            void *p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg2);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(rename(p, p2));\n\n            unlock_user(p2, arg2, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_renameat) && defined(__NR_renameat)\n\n    case TARGET_NR_renameat:\n\n        {\n\n            void *p2;\n\n            p  = lock_user_string(arg2);\n\n            p2 = lock_user_string(arg4);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_renameat(arg1, p, arg3, p2));\n\n            unlock_user(p2, arg4, 0);\n\n            unlock_user(p, arg2, 0);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_mkdir:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(mkdir(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_mkdirat) && defined(__NR_mkdirat)\n\n    case TARGET_NR_mkdirat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_mkdirat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_rmdir:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(rmdir(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_dup:\n\n        ret = get_errno(dup(arg1));\n\n        break;\n\n    case TARGET_NR_pipe:\n\n        ret = do_pipe(cpu_env, arg1, 0, 0);\n\n        break;\n\n#ifdef TARGET_NR_pipe2\n\n    case TARGET_NR_pipe2:\n\n        ret = do_pipe(cpu_env, arg1,\n\n                      target_to_host_bitmask(arg2, fcntl_flags_tbl), 1);\n\n        break;\n\n#endif\n\n    case TARGET_NR_times:\n\n        {\n\n            struct target_tms *tmsp;\n\n            struct tms tms;\n\n            ret = get_errno(times(&tms));\n\n            if (arg1) {\n\n                tmsp = lock_user(VERIFY_WRITE, arg1, sizeof(struct target_tms), 0);\n\n                if (!tmsp)\n\n                    goto efault;\n\n                tmsp->tms_utime = tswapal(host_to_target_clock_t(tms.tms_utime));\n\n                tmsp->tms_stime = tswapal(host_to_target_clock_t(tms.tms_stime));\n\n                tmsp->tms_cutime = tswapal(host_to_target_clock_t(tms.tms_cutime));\n\n                tmsp->tms_cstime = tswapal(host_to_target_clock_t(tms.tms_cstime));\n\n            }\n\n            if (!is_error(ret))\n\n                ret = host_to_target_clock_t(ret);\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_prof\n\n    case TARGET_NR_prof:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_signal\n\n    case TARGET_NR_signal:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_acct:\n\n        if (arg1 == 0) {\n\n            ret = get_errno(acct(NULL));\n\n        } else {\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto efault;\n\n            ret = get_errno(acct(path(p)));\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_umount2 /* not on alpha */\n\n    case TARGET_NR_umount2:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(umount2(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_lock\n\n    case TARGET_NR_lock:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_ioctl:\n\n        ret = do_ioctl(arg1, arg2, arg3);\n\n        break;\n\n    case TARGET_NR_fcntl:\n\n        ret = do_fcntl(arg1, arg2, arg3);\n\n        break;\n\n#ifdef TARGET_NR_mpx\n\n    case TARGET_NR_mpx:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_setpgid:\n\n        ret = get_errno(setpgid(arg1, arg2));\n\n        break;\n\n#ifdef TARGET_NR_ulimit\n\n    case TARGET_NR_ulimit:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_oldolduname\n\n    case TARGET_NR_oldolduname:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_umask:\n\n        ret = get_errno(umask(arg1));\n\n        break;\n\n    case TARGET_NR_chroot:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chroot(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_ustat:\n\n        goto unimplemented;\n\n    case TARGET_NR_dup2:\n\n        ret = get_errno(dup2(arg1, arg2));\n\n        break;\n\n#if defined(CONFIG_DUP3) && defined(TARGET_NR_dup3)\n\n    case TARGET_NR_dup3:\n\n        ret = get_errno(dup3(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getppid /* not on alpha */\n\n    case TARGET_NR_getppid:\n\n        ret = get_errno(getppid());\n\n        break;\n\n#endif\n\n    case TARGET_NR_getpgrp:\n\n        ret = get_errno(getpgrp());\n\n        break;\n\n    case TARGET_NR_setsid:\n\n        ret = get_errno(setsid());\n\n        break;\n\n#ifdef TARGET_NR_sigaction\n\n    case TARGET_NR_sigaction:\n\n        {\n\n#if defined(TARGET_ALPHA)\n\n            struct target_sigaction act, oact, *pact = 0;\n\n            struct target_old_sigaction *old_act;\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, old_act, arg2, 1))\n\n                    goto efault;\n\n                act._sa_handler = old_act->_sa_handler;\n\n                target_siginitset(&act.sa_mask, old_act->sa_mask);\n\n                act.sa_flags = old_act->sa_flags;\n\n                act.sa_restorer = 0;\n\n                unlock_user_struct(old_act, arg2, 0);\n\n                pact = &act;\n\n            }\n\n            ret = get_errno(do_sigaction(arg1, pact, &oact));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, old_act, arg3, 0))\n\n                    goto efault;\n\n                old_act->_sa_handler = oact._sa_handler;\n\n                old_act->sa_mask = oact.sa_mask.sig[0];\n\n                old_act->sa_flags = oact.sa_flags;\n\n                unlock_user_struct(old_act, arg3, 1);\n\n            }\n\n#elif defined(TARGET_MIPS)\n\n\t    struct target_sigaction act, oact, *pact, *old_act;\n\n\n\n\t    if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, old_act, arg2, 1))\n\n                    goto efault;\n\n\t\tact._sa_handler = old_act->_sa_handler;\n\n\t\ttarget_siginitset(&act.sa_mask, old_act->sa_mask.sig[0]);\n\n\t\tact.sa_flags = old_act->sa_flags;\n\n\t\tunlock_user_struct(old_act, arg2, 0);\n\n\t\tpact = &act;\n\n\t    } else {\n\n\t\tpact = NULL;\n\n\t    }\n\n\n\n\t    ret = get_errno(do_sigaction(arg1, pact, &oact));\n\n\n\n\t    if (!is_error(ret) && arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, old_act, arg3, 0))\n\n                    goto efault;\n\n\t\told_act->_sa_handler = oact._sa_handler;\n\n\t\told_act->sa_flags = oact.sa_flags;\n\n\t\told_act->sa_mask.sig[0] = oact.sa_mask.sig[0];\n\n\t\told_act->sa_mask.sig[1] = 0;\n\n\t\told_act->sa_mask.sig[2] = 0;\n\n\t\told_act->sa_mask.sig[3] = 0;\n\n\t\tunlock_user_struct(old_act, arg3, 1);\n\n\t    }\n\n#else\n\n            struct target_old_sigaction *old_act;\n\n            struct target_sigaction act, oact, *pact;\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, old_act, arg2, 1))\n\n                    goto efault;\n\n                act._sa_handler = old_act->_sa_handler;\n\n                target_siginitset(&act.sa_mask, old_act->sa_mask);\n\n                act.sa_flags = old_act->sa_flags;\n\n                act.sa_restorer = old_act->sa_restorer;\n\n                unlock_user_struct(old_act, arg2, 0);\n\n                pact = &act;\n\n            } else {\n\n                pact = NULL;\n\n            }\n\n            ret = get_errno(do_sigaction(arg1, pact, &oact));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, old_act, arg3, 0))\n\n                    goto efault;\n\n                old_act->_sa_handler = oact._sa_handler;\n\n                old_act->sa_mask = oact.sa_mask.sig[0];\n\n                old_act->sa_flags = oact.sa_flags;\n\n                old_act->sa_restorer = oact.sa_restorer;\n\n                unlock_user_struct(old_act, arg3, 1);\n\n            }\n\n#endif\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigaction:\n\n        {\n\n#if defined(TARGET_ALPHA)\n\n            struct target_sigaction act, oact, *pact = 0;\n\n            struct target_rt_sigaction *rt_act;\n\n            /* ??? arg4 == sizeof(sigset_t).  */\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, rt_act, arg2, 1))\n\n                    goto efault;\n\n                act._sa_handler = rt_act->_sa_handler;\n\n                act.sa_mask = rt_act->sa_mask;\n\n                act.sa_flags = rt_act->sa_flags;\n\n                act.sa_restorer = arg5;\n\n                unlock_user_struct(rt_act, arg2, 0);\n\n                pact = &act;\n\n            }\n\n            ret = get_errno(do_sigaction(arg1, pact, &oact));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, rt_act, arg3, 0))\n\n                    goto efault;\n\n                rt_act->_sa_handler = oact._sa_handler;\n\n                rt_act->sa_mask = oact.sa_mask;\n\n                rt_act->sa_flags = oact.sa_flags;\n\n                unlock_user_struct(rt_act, arg3, 1);\n\n            }\n\n#else\n\n            struct target_sigaction *act;\n\n            struct target_sigaction *oact;\n\n\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, act, arg2, 1))\n\n                    goto efault;\n\n            } else\n\n                act = NULL;\n\n            if (arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, oact, arg3, 0)) {\n\n                    ret = -TARGET_EFAULT;\n\n                    goto rt_sigaction_fail;\n\n                }\n\n            } else\n\n                oact = NULL;\n\n            ret = get_errno(do_sigaction(arg1, act, oact));\n\n\trt_sigaction_fail:\n\n            if (act)\n\n                unlock_user_struct(act, arg2, 0);\n\n            if (oact)\n\n                unlock_user_struct(oact, arg3, 1);\n\n#endif\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sgetmask /* not on alpha */\n\n    case TARGET_NR_sgetmask:\n\n        {\n\n            sigset_t cur_set;\n\n            abi_ulong target_set;\n\n            sigprocmask(0, NULL, &cur_set);\n\n            host_to_target_old_sigset(&target_set, &cur_set);\n\n            ret = target_set;\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_ssetmask /* not on alpha */\n\n    case TARGET_NR_ssetmask:\n\n        {\n\n            sigset_t set, oset, cur_set;\n\n            abi_ulong target_set = arg1;\n\n            sigprocmask(0, NULL, &cur_set);\n\n            target_to_host_old_sigset(&set, &target_set);\n\n            sigorset(&set, &set, &cur_set);\n\n            sigprocmask(SIG_SETMASK, &set, &oset);\n\n            host_to_target_old_sigset(&target_set, &oset);\n\n            ret = target_set;\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sigprocmask\n\n    case TARGET_NR_sigprocmask:\n\n        {\n\n#if defined(TARGET_ALPHA)\n\n            sigset_t set, oldset;\n\n            abi_ulong mask;\n\n            int how;\n\n\n\n            switch (arg1) {\n\n            case TARGET_SIG_BLOCK:\n\n                how = SIG_BLOCK;\n\n                break;\n\n            case TARGET_SIG_UNBLOCK:\n\n                how = SIG_UNBLOCK;\n\n                break;\n\n            case TARGET_SIG_SETMASK:\n\n                how = SIG_SETMASK;\n\n                break;\n\n            default:\n\n                ret = -TARGET_EINVAL;\n\n                goto fail;\n\n            }\n\n            mask = arg2;\n\n            target_to_host_old_sigset(&set, &mask);\n\n\n\n            ret = get_errno(sigprocmask(how, &set, &oldset));\n\n            if (!is_error(ret)) {\n\n                host_to_target_old_sigset(&mask, &oldset);\n\n                ret = mask;\n\n                ((CPUAlphaState *)cpu_env)->ir[IR_V0] = 0; /* force no error */\n\n            }\n\n#else\n\n            sigset_t set, oldset, *set_ptr;\n\n            int how;\n\n\n\n            if (arg2) {\n\n                switch (arg1) {\n\n                case TARGET_SIG_BLOCK:\n\n                    how = SIG_BLOCK;\n\n                    break;\n\n                case TARGET_SIG_UNBLOCK:\n\n                    how = SIG_UNBLOCK;\n\n                    break;\n\n                case TARGET_SIG_SETMASK:\n\n                    how = SIG_SETMASK;\n\n                    break;\n\n                default:\n\n                    ret = -TARGET_EINVAL;\n\n                    goto fail;\n\n                }\n\n                if (!(p = lock_user(VERIFY_READ, arg2, sizeof(target_sigset_t), 1)))\n\n                    goto efault;\n\n                target_to_host_old_sigset(&set, p);\n\n                unlock_user(p, arg2, 0);\n\n                set_ptr = &set;\n\n            } else {\n\n                how = 0;\n\n                set_ptr = NULL;\n\n            }\n\n            ret = get_errno(sigprocmask(how, set_ptr, &oldset));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_old_sigset(p, &oldset);\n\n                unlock_user(p, arg3, sizeof(target_sigset_t));\n\n            }\n\n#endif\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigprocmask:\n\n        {\n\n            int how = arg1;\n\n            sigset_t set, oldset, *set_ptr;\n\n\n\n            if (arg2) {\n\n                switch(how) {\n\n                case TARGET_SIG_BLOCK:\n\n                    how = SIG_BLOCK;\n\n                    break;\n\n                case TARGET_SIG_UNBLOCK:\n\n                    how = SIG_UNBLOCK;\n\n                    break;\n\n                case TARGET_SIG_SETMASK:\n\n                    how = SIG_SETMASK;\n\n                    break;\n\n                default:\n\n                    ret = -TARGET_EINVAL;\n\n                    goto fail;\n\n                }\n\n                if (!(p = lock_user(VERIFY_READ, arg2, sizeof(target_sigset_t), 1)))\n\n                    goto efault;\n\n                target_to_host_sigset(&set, p);\n\n                unlock_user(p, arg2, 0);\n\n                set_ptr = &set;\n\n            } else {\n\n                how = 0;\n\n                set_ptr = NULL;\n\n            }\n\n            ret = get_errno(sigprocmask(how, set_ptr, &oldset));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_sigset(p, &oldset);\n\n                unlock_user(p, arg3, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sigpending\n\n    case TARGET_NR_sigpending:\n\n        {\n\n            sigset_t set;\n\n            ret = get_errno(sigpending(&set));\n\n            if (!is_error(ret)) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg1, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_old_sigset(p, &set);\n\n                unlock_user(p, arg1, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigpending:\n\n        {\n\n            sigset_t set;\n\n            ret = get_errno(sigpending(&set));\n\n            if (!is_error(ret)) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg1, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_sigset(p, &set);\n\n                unlock_user(p, arg1, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sigsuspend\n\n    case TARGET_NR_sigsuspend:\n\n        {\n\n            sigset_t set;\n\n#if defined(TARGET_ALPHA)\n\n            abi_ulong mask = arg1;\n\n            target_to_host_old_sigset(&set, &mask);\n\n#else\n\n            if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_old_sigset(&set, p);\n\n            unlock_user(p, arg1, 0);\n\n#endif\n\n            ret = get_errno(sigsuspend(&set));\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigsuspend:\n\n        {\n\n            sigset_t set;\n\n            if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_sigset(&set, p);\n\n            unlock_user(p, arg1, 0);\n\n            ret = get_errno(sigsuspend(&set));\n\n        }\n\n        break;\n\n    case TARGET_NR_rt_sigtimedwait:\n\n        {\n\n            sigset_t set;\n\n            struct timespec uts, *puts;\n\n            siginfo_t uinfo;\n\n\n\n            if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_sigset(&set, p);\n\n            unlock_user(p, arg1, 0);\n\n            if (arg3) {\n\n                puts = &uts;\n\n                target_to_host_timespec(puts, arg3);\n\n            } else {\n\n                puts = NULL;\n\n            }\n\n            ret = get_errno(sigtimedwait(&set, &uinfo, puts));\n\n            if (!is_error(ret) && arg2) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg2, sizeof(target_siginfo_t), 0)))\n\n                    goto efault;\n\n                host_to_target_siginfo(p, &uinfo);\n\n                unlock_user(p, arg2, sizeof(target_siginfo_t));\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_rt_sigqueueinfo:\n\n        {\n\n            siginfo_t uinfo;\n\n            if (!(p = lock_user(VERIFY_READ, arg3, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_siginfo(&uinfo, p);\n\n            unlock_user(p, arg1, 0);\n\n            ret = get_errno(sys_rt_sigqueueinfo(arg1, arg2, &uinfo));\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sigreturn\n\n    case TARGET_NR_sigreturn:\n\n        /* NOTE: ret is eax, so not transcoding must be done */\n\n        ret = do_sigreturn(cpu_env);\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigreturn:\n\n        /* NOTE: ret is eax, so not transcoding must be done */\n\n        ret = do_rt_sigreturn(cpu_env);\n\n        break;\n\n    case TARGET_NR_sethostname:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(sethostname(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_setrlimit:\n\n        {\n\n            int resource = target_to_host_resource(arg1);\n\n            struct target_rlimit *target_rlim;\n\n            struct rlimit rlim;\n\n            if (!lock_user_struct(VERIFY_READ, target_rlim, arg2, 1))\n\n                goto efault;\n\n            rlim.rlim_cur = target_to_host_rlim(target_rlim->rlim_cur);\n\n            rlim.rlim_max = target_to_host_rlim(target_rlim->rlim_max);\n\n            unlock_user_struct(target_rlim, arg2, 0);\n\n            ret = get_errno(setrlimit(resource, &rlim));\n\n        }\n\n        break;\n\n    case TARGET_NR_getrlimit:\n\n        {\n\n            int resource = target_to_host_resource(arg1);\n\n            struct target_rlimit *target_rlim;\n\n            struct rlimit rlim;\n\n\n\n            ret = get_errno(getrlimit(resource, &rlim));\n\n            if (!is_error(ret)) {\n\n                if (!lock_user_struct(VERIFY_WRITE, target_rlim, arg2, 0))\n\n                    goto efault;\n\n                target_rlim->rlim_cur = host_to_target_rlim(rlim.rlim_cur);\n\n                target_rlim->rlim_max = host_to_target_rlim(rlim.rlim_max);\n\n                unlock_user_struct(target_rlim, arg2, 1);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_getrusage:\n\n        {\n\n            struct rusage rusage;\n\n            ret = get_errno(getrusage(arg1, &rusage));\n\n            if (!is_error(ret)) {\n\n                host_to_target_rusage(arg2, &rusage);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_gettimeofday:\n\n        {\n\n            struct timeval tv;\n\n            ret = get_errno(gettimeofday(&tv, NULL));\n\n            if (!is_error(ret)) {\n\n                if (copy_to_user_timeval(arg1, &tv))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_settimeofday:\n\n        {\n\n            struct timeval tv;\n\n            if (copy_from_user_timeval(&tv, arg1))\n\n                goto efault;\n\n            ret = get_errno(settimeofday(&tv, NULL));\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_select) && !defined(TARGET_S390X) && !defined(TARGET_S390)\n\n    case TARGET_NR_select:\n\n        {\n\n            struct target_sel_arg_struct *sel;\n\n            abi_ulong inp, outp, exp, tvp;\n\n            long nsel;\n\n\n\n            if (!lock_user_struct(VERIFY_READ, sel, arg1, 1))\n\n                goto efault;\n\n            nsel = tswapal(sel->n);\n\n            inp = tswapal(sel->inp);\n\n            outp = tswapal(sel->outp);\n\n            exp = tswapal(sel->exp);\n\n            tvp = tswapal(sel->tvp);\n\n            unlock_user_struct(sel, arg1, 0);\n\n            ret = do_select(nsel, inp, outp, exp, tvp);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_pselect6\n\n    case TARGET_NR_pselect6:\n\n        {\n\n            abi_long rfd_addr, wfd_addr, efd_addr, n, ts_addr;\n\n            fd_set rfds, wfds, efds;\n\n            fd_set *rfds_ptr, *wfds_ptr, *efds_ptr;\n\n            struct timespec ts, *ts_ptr;\n\n\n\n            /*\n\n             * The 6th arg is actually two args smashed together,\n\n             * so we cannot use the C library.\n\n             */\n\n            sigset_t set;\n\n            struct {\n\n                sigset_t *set;\n\n                size_t size;\n\n            } sig, *sig_ptr;\n\n\n\n            abi_ulong arg_sigset, arg_sigsize, *arg7;\n\n            target_sigset_t *target_sigset;\n\n\n\n            n = arg1;\n\n            rfd_addr = arg2;\n\n            wfd_addr = arg3;\n\n            efd_addr = arg4;\n\n            ts_addr = arg5;\n\n\n\n            ret = copy_from_user_fdset_ptr(&rfds, &rfds_ptr, rfd_addr, n);\n\n            if (ret) {\n\n                goto fail;\n\n            }\n\n            ret = copy_from_user_fdset_ptr(&wfds, &wfds_ptr, wfd_addr, n);\n\n            if (ret) {\n\n                goto fail;\n\n            }\n\n            ret = copy_from_user_fdset_ptr(&efds, &efds_ptr, efd_addr, n);\n\n            if (ret) {\n\n                goto fail;\n\n            }\n\n\n\n            /*\n\n             * This takes a timespec, and not a timeval, so we cannot\n\n             * use the do_select() helper ...\n\n             */\n\n            if (ts_addr) {\n\n                if (target_to_host_timespec(&ts, ts_addr)) {\n\n                    goto efault;\n\n                }\n\n                ts_ptr = &ts;\n\n            } else {\n\n                ts_ptr = NULL;\n\n            }\n\n\n\n            /* Extract the two packed args for the sigset */\n\n            if (arg6) {\n\n                sig_ptr = &sig;\n\n                sig.size = _NSIG / 8;\n\n\n\n                arg7 = lock_user(VERIFY_READ, arg6, sizeof(*arg7) * 2, 1);\n\n                if (!arg7) {\n\n                    goto efault;\n\n                }\n\n                arg_sigset = tswapal(arg7[0]);\n\n                arg_sigsize = tswapal(arg7[1]);\n\n                unlock_user(arg7, arg6, 0);\n\n\n\n                if (arg_sigset) {\n\n                    sig.set = &set;\n\n                    if (arg_sigsize != sizeof(*target_sigset)) {\n\n                        /* Like the kernel, we enforce correct size sigsets */\n\n                        ret = -TARGET_EINVAL;\n\n                        goto fail;\n\n                    }\n\n                    target_sigset = lock_user(VERIFY_READ, arg_sigset,\n\n                                              sizeof(*target_sigset), 1);\n\n                    if (!target_sigset) {\n\n                        goto efault;\n\n                    }\n\n                    target_to_host_sigset(&set, target_sigset);\n\n                    unlock_user(target_sigset, arg_sigset, 0);\n\n                } else {\n\n                    sig.set = NULL;\n\n                }\n\n            } else {\n\n                sig_ptr = NULL;\n\n            }\n\n\n\n            ret = get_errno(sys_pselect6(n, rfds_ptr, wfds_ptr, efds_ptr,\n\n                                         ts_ptr, sig_ptr));\n\n\n\n            if (!is_error(ret)) {\n\n                if (rfd_addr && copy_to_user_fdset(rfd_addr, &rfds, n))\n\n                    goto efault;\n\n                if (wfd_addr && copy_to_user_fdset(wfd_addr, &wfds, n))\n\n                    goto efault;\n\n                if (efd_addr && copy_to_user_fdset(efd_addr, &efds, n))\n\n                    goto efault;\n\n\n\n                if (ts_addr && host_to_target_timespec(ts_addr, &ts))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_symlink:\n\n        {\n\n            void *p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg2);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(symlink(p, p2));\n\n            unlock_user(p2, arg2, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_symlinkat) && defined(__NR_symlinkat)\n\n    case TARGET_NR_symlinkat:\n\n        {\n\n            void *p2;\n\n            p  = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg3);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_symlinkat(p, arg2, p2));\n\n            unlock_user(p2, arg3, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_oldlstat\n\n    case TARGET_NR_oldlstat:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_readlink:\n\n        {\n\n            void *p2, *temp;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user(VERIFY_WRITE, arg2, arg3, 0);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else {\n\n                if (strncmp((const char *)p, \"/proc/self/exe\", 14) == 0) {\n\n                    char real[PATH_MAX];\n\n                    temp = realpath(exec_path,real);\n\n                    ret = (temp==NULL) ? get_errno(-1) : strlen(real) ;\n\n                    snprintf((char *)p2, arg3, \"%s\", real);\n\n                    }\n\n                else\n\n                    ret = get_errno(readlink(path(p), p2, arg3));\n\n            }\n\n            unlock_user(p2, arg2, ret);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_readlinkat) && defined(__NR_readlinkat)\n\n    case TARGET_NR_readlinkat:\n\n        {\n\n            void *p2;\n\n            p  = lock_user_string(arg2);\n\n            p2 = lock_user(VERIFY_WRITE, arg3, arg4, 0);\n\n            if (!p || !p2)\n\n        \tret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_readlinkat(arg1, path(p), p2, arg4));\n\n            unlock_user(p2, arg3, ret);\n\n            unlock_user(p, arg2, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_uselib\n\n    case TARGET_NR_uselib:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_swapon\n\n    case TARGET_NR_swapon:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(swapon(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_reboot:\n\n        if (!(p = lock_user_string(arg4)))\n\n            goto efault;\n\n        ret = reboot(arg1, arg2, arg3, p);\n\n        unlock_user(p, arg4, 0);\n\n        break;\n\n#ifdef TARGET_NR_readdir\n\n    case TARGET_NR_readdir:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_mmap\n\n    case TARGET_NR_mmap:\n\n#if (defined(TARGET_I386) && defined(TARGET_ABI32)) || defined(TARGET_ARM) || \\\n\n    defined(TARGET_M68K) || defined(TARGET_CRIS) || defined(TARGET_MICROBLAZE) \\\n\n    || defined(TARGET_S390X)\n\n        {\n\n            abi_ulong *v;\n\n            abi_ulong v1, v2, v3, v4, v5, v6;\n\n            if (!(v = lock_user(VERIFY_READ, arg1, 6 * sizeof(abi_ulong), 1)))\n\n                goto efault;\n\n            v1 = tswapal(v[0]);\n\n            v2 = tswapal(v[1]);\n\n            v3 = tswapal(v[2]);\n\n            v4 = tswapal(v[3]);\n\n            v5 = tswapal(v[4]);\n\n            v6 = tswapal(v[5]);\n\n            unlock_user(v, arg1, 0);\n\n            ret = get_errno(target_mmap(v1, v2, v3,\n\n                                        target_to_host_bitmask(v4, mmap_flags_tbl),\n\n                                        v5, v6));\n\n        }\n\n#else\n\n        ret = get_errno(target_mmap(arg1, arg2, arg3,\n\n                                    target_to_host_bitmask(arg4, mmap_flags_tbl),\n\n                                    arg5,\n\n                                    arg6));\n\n#endif\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_mmap2\n\n    case TARGET_NR_mmap2:\n\n#ifndef MMAP_SHIFT\n\n#define MMAP_SHIFT 12\n\n#endif\n\n        ret = get_errno(target_mmap(arg1, arg2, arg3,\n\n                                    target_to_host_bitmask(arg4, mmap_flags_tbl),\n\n                                    arg5,\n\n                                    arg6 << MMAP_SHIFT));\n\n        break;\n\n#endif\n\n    case TARGET_NR_munmap:\n\n        ret = get_errno(target_munmap(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_mprotect:\n\n        {\n\n            TaskState *ts = ((CPUArchState *)cpu_env)->opaque;\n\n            /* Special hack to detect libc making the stack executable.  */\n\n            if ((arg3 & PROT_GROWSDOWN)\n\n                && arg1 >= ts->info->stack_limit\n\n                && arg1 <= ts->info->start_stack) {\n\n                arg3 &= ~PROT_GROWSDOWN;\n\n                arg2 = arg2 + arg1 - ts->info->stack_limit;\n\n                arg1 = ts->info->stack_limit;\n\n            }\n\n        }\n\n        ret = get_errno(target_mprotect(arg1, arg2, arg3));\n\n        break;\n\n#ifdef TARGET_NR_mremap\n\n    case TARGET_NR_mremap:\n\n        ret = get_errno(target_mremap(arg1, arg2, arg3, arg4, arg5));\n\n        break;\n\n#endif\n\n        /* ??? msync/mlock/munlock are broken for softmmu.  */\n\n#ifdef TARGET_NR_msync\n\n    case TARGET_NR_msync:\n\n        ret = get_errno(msync(g2h(arg1), arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_mlock\n\n    case TARGET_NR_mlock:\n\n        ret = get_errno(mlock(g2h(arg1), arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_munlock\n\n    case TARGET_NR_munlock:\n\n        ret = get_errno(munlock(g2h(arg1), arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_mlockall\n\n    case TARGET_NR_mlockall:\n\n        ret = get_errno(mlockall(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_munlockall\n\n    case TARGET_NR_munlockall:\n\n        ret = get_errno(munlockall());\n\n        break;\n\n#endif\n\n    case TARGET_NR_truncate:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(truncate(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_ftruncate:\n\n        ret = get_errno(ftruncate(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_fchmod:\n\n        ret = get_errno(fchmod(arg1, arg2));\n\n        break;\n\n#if defined(TARGET_NR_fchmodat) && defined(__NR_fchmodat)\n\n    case TARGET_NR_fchmodat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_fchmodat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_getpriority:\n\n        /* Note that negative values are valid for getpriority, so we must\n\n           differentiate based on errno settings.  */\n\n        errno = 0;\n\n        ret = getpriority(arg1, arg2);\n\n        if (ret == -1 && errno != 0) {\n\n            ret = -host_to_target_errno(errno);\n\n            break;\n\n        }\n\n#ifdef TARGET_ALPHA\n\n        /* Return value is the unbiased priority.  Signal no error.  */\n\n        ((CPUAlphaState *)cpu_env)->ir[IR_V0] = 0;\n\n#else\n\n        /* Return value is a biased priority to avoid negative numbers.  */\n\n        ret = 20 - ret;\n\n#endif\n\n        break;\n\n    case TARGET_NR_setpriority:\n\n        ret = get_errno(setpriority(arg1, arg2, arg3));\n\n        break;\n\n#ifdef TARGET_NR_profil\n\n    case TARGET_NR_profil:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_statfs:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(statfs(path(p), &stfs));\n\n        unlock_user(p, arg1, 0);\n\n    convert_statfs:\n\n        if (!is_error(ret)) {\n\n            struct target_statfs *target_stfs;\n\n\n\n            if (!lock_user_struct(VERIFY_WRITE, target_stfs, arg2, 0))\n\n                goto efault;\n\n            __put_user(stfs.f_type, &target_stfs->f_type);\n\n            __put_user(stfs.f_bsize, &target_stfs->f_bsize);\n\n            __put_user(stfs.f_blocks, &target_stfs->f_blocks);\n\n            __put_user(stfs.f_bfree, &target_stfs->f_bfree);\n\n            __put_user(stfs.f_bavail, &target_stfs->f_bavail);\n\n            __put_user(stfs.f_files, &target_stfs->f_files);\n\n            __put_user(stfs.f_ffree, &target_stfs->f_ffree);\n\n            __put_user(stfs.f_fsid.__val[0], &target_stfs->f_fsid.val[0]);\n\n            __put_user(stfs.f_fsid.__val[1], &target_stfs->f_fsid.val[1]);\n\n            __put_user(stfs.f_namelen, &target_stfs->f_namelen);\n\n            __put_user(stfs.f_frsize, &target_stfs->f_frsize);\n\n            memset(target_stfs->f_spare, 0, sizeof(target_stfs->f_spare));\n\n            unlock_user_struct(target_stfs, arg2, 1);\n\n        }\n\n        break;\n\n    case TARGET_NR_fstatfs:\n\n        ret = get_errno(fstatfs(arg1, &stfs));\n\n        goto convert_statfs;\n\n#ifdef TARGET_NR_statfs64\n\n    case TARGET_NR_statfs64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(statfs(path(p), &stfs));\n\n        unlock_user(p, arg1, 0);\n\n    convert_statfs64:\n\n        if (!is_error(ret)) {\n\n            struct target_statfs64 *target_stfs;\n\n\n\n            if (!lock_user_struct(VERIFY_WRITE, target_stfs, arg3, 0))\n\n                goto efault;\n\n            __put_user(stfs.f_type, &target_stfs->f_type);\n\n            __put_user(stfs.f_bsize, &target_stfs->f_bsize);\n\n            __put_user(stfs.f_blocks, &target_stfs->f_blocks);\n\n            __put_user(stfs.f_bfree, &target_stfs->f_bfree);\n\n            __put_user(stfs.f_bavail, &target_stfs->f_bavail);\n\n            __put_user(stfs.f_files, &target_stfs->f_files);\n\n            __put_user(stfs.f_ffree, &target_stfs->f_ffree);\n\n            __put_user(stfs.f_fsid.__val[0], &target_stfs->f_fsid.val[0]);\n\n            __put_user(stfs.f_fsid.__val[1], &target_stfs->f_fsid.val[1]);\n\n            __put_user(stfs.f_namelen, &target_stfs->f_namelen);\n\n            __put_user(stfs.f_frsize, &target_stfs->f_frsize);\n\n            memset(target_stfs->f_spare, 0, sizeof(target_stfs->f_spare));\n\n            unlock_user_struct(target_stfs, arg3, 1);\n\n        }\n\n        break;\n\n    case TARGET_NR_fstatfs64:\n\n        ret = get_errno(fstatfs(arg1, &stfs));\n\n        goto convert_statfs64;\n\n#endif\n\n#ifdef TARGET_NR_ioperm\n\n    case TARGET_NR_ioperm:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_socketcall\n\n    case TARGET_NR_socketcall:\n\n        ret = do_socketcall(arg1, arg2);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_accept\n\n    case TARGET_NR_accept:\n\n        ret = do_accept(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_bind\n\n    case TARGET_NR_bind:\n\n        ret = do_bind(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_connect\n\n    case TARGET_NR_connect:\n\n        ret = do_connect(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getpeername\n\n    case TARGET_NR_getpeername:\n\n        ret = do_getpeername(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getsockname\n\n    case TARGET_NR_getsockname:\n\n        ret = do_getsockname(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getsockopt\n\n    case TARGET_NR_getsockopt:\n\n        ret = do_getsockopt(arg1, arg2, arg3, arg4, arg5);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_listen\n\n    case TARGET_NR_listen:\n\n        ret = get_errno(listen(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_recv\n\n    case TARGET_NR_recv:\n\n        ret = do_recvfrom(arg1, arg2, arg3, arg4, 0, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_recvfrom\n\n    case TARGET_NR_recvfrom:\n\n        ret = do_recvfrom(arg1, arg2, arg3, arg4, arg5, arg6);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_recvmsg\n\n    case TARGET_NR_recvmsg:\n\n        ret = do_sendrecvmsg(arg1, arg2, arg3, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_send\n\n    case TARGET_NR_send:\n\n        ret = do_sendto(arg1, arg2, arg3, arg4, 0, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sendmsg\n\n    case TARGET_NR_sendmsg:\n\n        ret = do_sendrecvmsg(arg1, arg2, arg3, 1);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sendto\n\n    case TARGET_NR_sendto:\n\n        ret = do_sendto(arg1, arg2, arg3, arg4, arg5, arg6);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shutdown\n\n    case TARGET_NR_shutdown:\n\n        ret = get_errno(shutdown(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_socket\n\n    case TARGET_NR_socket:\n\n        ret = do_socket(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_socketpair\n\n    case TARGET_NR_socketpair:\n\n        ret = do_socketpair(arg1, arg2, arg3, arg4);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setsockopt\n\n    case TARGET_NR_setsockopt:\n\n        ret = do_setsockopt(arg1, arg2, arg3, arg4, (socklen_t) arg5);\n\n        break;\n\n#endif\n\n\n\n    case TARGET_NR_syslog:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_syslog((int)arg1, p, (int)arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n\n\n    case TARGET_NR_setitimer:\n\n        {\n\n            struct itimerval value, ovalue, *pvalue;\n\n\n\n            if (arg2) {\n\n                pvalue = &value;\n\n                if (copy_from_user_timeval(&pvalue->it_interval, arg2)\n\n                    || copy_from_user_timeval(&pvalue->it_value,\n\n                                              arg2 + sizeof(struct target_timeval)))\n\n                    goto efault;\n\n            } else {\n\n                pvalue = NULL;\n\n            }\n\n            ret = get_errno(setitimer(arg1, pvalue, &ovalue));\n\n            if (!is_error(ret) && arg3) {\n\n                if (copy_to_user_timeval(arg3,\n\n                                         &ovalue.it_interval)\n\n                    || copy_to_user_timeval(arg3 + sizeof(struct target_timeval),\n\n                                            &ovalue.it_value))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_getitimer:\n\n        {\n\n            struct itimerval value;\n\n\n\n            ret = get_errno(getitimer(arg1, &value));\n\n            if (!is_error(ret) && arg2) {\n\n                if (copy_to_user_timeval(arg2,\n\n                                         &value.it_interval)\n\n                    || copy_to_user_timeval(arg2 + sizeof(struct target_timeval),\n\n                                            &value.it_value))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_stat:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(stat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        goto do_stat;\n\n    case TARGET_NR_lstat:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lstat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        goto do_stat;\n\n    case TARGET_NR_fstat:\n\n        {\n\n            ret = get_errno(fstat(arg1, &st));\n\n        do_stat:\n\n            if (!is_error(ret)) {\n\n                struct target_stat *target_st;\n\n\n\n                if (!lock_user_struct(VERIFY_WRITE, target_st, arg2, 0))\n\n                    goto efault;\n\n                memset(target_st, 0, sizeof(*target_st));\n\n                __put_user(st.st_dev, &target_st->st_dev);\n\n                __put_user(st.st_ino, &target_st->st_ino);\n\n                __put_user(st.st_mode, &target_st->st_mode);\n\n                __put_user(st.st_uid, &target_st->st_uid);\n\n                __put_user(st.st_gid, &target_st->st_gid);\n\n                __put_user(st.st_nlink, &target_st->st_nlink);\n\n                __put_user(st.st_rdev, &target_st->st_rdev);\n\n                __put_user(st.st_size, &target_st->st_size);\n\n                __put_user(st.st_blksize, &target_st->st_blksize);\n\n                __put_user(st.st_blocks, &target_st->st_blocks);\n\n                __put_user(st.st_atime, &target_st->target_st_atime);\n\n                __put_user(st.st_mtime, &target_st->target_st_mtime);\n\n                __put_user(st.st_ctime, &target_st->target_st_ctime);\n\n                unlock_user_struct(target_st, arg2, 1);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_olduname\n\n    case TARGET_NR_olduname:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_iopl\n\n    case TARGET_NR_iopl:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_vhangup:\n\n        ret = get_errno(vhangup());\n\n        break;\n\n#ifdef TARGET_NR_idle\n\n    case TARGET_NR_idle:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_syscall\n\n    case TARGET_NR_syscall:\n\n        ret = do_syscall(cpu_env, arg1 & 0xffff, arg2, arg3, arg4, arg5,\n\n                         arg6, arg7, arg8, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_wait4:\n\n        {\n\n            int status;\n\n            abi_long status_ptr = arg2;\n\n            struct rusage rusage, *rusage_ptr;\n\n            abi_ulong target_rusage = arg4;\n\n            if (target_rusage)\n\n                rusage_ptr = &rusage;\n\n            else\n\n                rusage_ptr = NULL;\n\n            ret = get_errno(wait4(arg1, &status, arg3, rusage_ptr));\n\n            if (!is_error(ret)) {\n\n                if (status_ptr && ret) {\n\n                    status = host_to_target_waitstatus(status);\n\n                    if (put_user_s32(status, status_ptr))\n\n                        goto efault;\n\n                }\n\n                if (target_rusage)\n\n                    host_to_target_rusage(target_rusage, &rusage);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_swapoff\n\n    case TARGET_NR_swapoff:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(swapoff(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_sysinfo:\n\n        {\n\n            struct target_sysinfo *target_value;\n\n            struct sysinfo value;\n\n            ret = get_errno(sysinfo(&value));\n\n            if (!is_error(ret) && arg1)\n\n            {\n\n                if (!lock_user_struct(VERIFY_WRITE, target_value, arg1, 0))\n\n                    goto efault;\n\n                __put_user(value.uptime, &target_value->uptime);\n\n                __put_user(value.loads[0], &target_value->loads[0]);\n\n                __put_user(value.loads[1], &target_value->loads[1]);\n\n                __put_user(value.loads[2], &target_value->loads[2]);\n\n                __put_user(value.totalram, &target_value->totalram);\n\n                __put_user(value.freeram, &target_value->freeram);\n\n                __put_user(value.sharedram, &target_value->sharedram);\n\n                __put_user(value.bufferram, &target_value->bufferram);\n\n                __put_user(value.totalswap, &target_value->totalswap);\n\n                __put_user(value.freeswap, &target_value->freeswap);\n\n                __put_user(value.procs, &target_value->procs);\n\n                __put_user(value.totalhigh, &target_value->totalhigh);\n\n                __put_user(value.freehigh, &target_value->freehigh);\n\n                __put_user(value.mem_unit, &target_value->mem_unit);\n\n                unlock_user_struct(target_value, arg1, 1);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_ipc\n\n    case TARGET_NR_ipc:\n\n\tret = do_ipc(arg1, arg2, arg3, arg4, arg5, arg6);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_semget\n\n    case TARGET_NR_semget:\n\n        ret = get_errno(semget(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_semop\n\n    case TARGET_NR_semop:\n\n        ret = get_errno(do_semop(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_semctl\n\n    case TARGET_NR_semctl:\n\n        ret = do_semctl(arg1, arg2, arg3, (union target_semun)(abi_ulong)arg4);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgctl\n\n    case TARGET_NR_msgctl:\n\n        ret = do_msgctl(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgget\n\n    case TARGET_NR_msgget:\n\n        ret = get_errno(msgget(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgrcv\n\n    case TARGET_NR_msgrcv:\n\n        ret = do_msgrcv(arg1, arg2, arg3, arg4, arg5);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgsnd\n\n    case TARGET_NR_msgsnd:\n\n        ret = do_msgsnd(arg1, arg2, arg3, arg4);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmget\n\n    case TARGET_NR_shmget:\n\n        ret = get_errno(shmget(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmctl\n\n    case TARGET_NR_shmctl:\n\n        ret = do_shmctl(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmat\n\n    case TARGET_NR_shmat:\n\n        ret = do_shmat(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmdt\n\n    case TARGET_NR_shmdt:\n\n        ret = do_shmdt(arg1);\n\n        break;\n\n#endif\n\n    case TARGET_NR_fsync:\n\n        ret = get_errno(fsync(arg1));\n\n        break;\n\n    case TARGET_NR_clone:\n\n#if defined(TARGET_SH4) || defined(TARGET_ALPHA)\n\n        ret = get_errno(do_fork(cpu_env, arg1, arg2, arg3, arg5, arg4));\n\n#elif defined(TARGET_CRIS)\n\n        ret = get_errno(do_fork(cpu_env, arg2, arg1, arg3, arg4, arg5));\n\n#elif defined(TARGET_S390X)\n\n        ret = get_errno(do_fork(cpu_env, arg2, arg1, arg3, arg5, arg4));\n\n#else\n\n        ret = get_errno(do_fork(cpu_env, arg1, arg2, arg3, arg4, arg5));\n\n#endif\n\n        break;\n\n#ifdef __NR_exit_group\n\n        /* new thread calls */\n\n    case TARGET_NR_exit_group:\n\n#ifdef TARGET_GPROF\n\n        _mcleanup();\n\n#endif\n\n        gdb_exit(cpu_env, arg1);\n\n        ret = get_errno(exit_group(arg1));\n\n        break;\n\n#endif\n\n    case TARGET_NR_setdomainname:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(setdomainname(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_uname:\n\n        /* no need to transcode because we use the linux syscall */\n\n        {\n\n            struct new_utsname * buf;\n\n\n\n            if (!lock_user_struct(VERIFY_WRITE, buf, arg1, 0))\n\n                goto efault;\n\n            ret = get_errno(sys_uname(buf));\n\n            if (!is_error(ret)) {\n\n                /* Overrite the native machine name with whatever is being\n\n                   emulated. */\n\n                strcpy (buf->machine, cpu_to_uname_machine(cpu_env));\n\n                /* Allow the user to override the reported release.  */\n\n                if (qemu_uname_release && *qemu_uname_release)\n\n                  strcpy (buf->release, qemu_uname_release);\n\n            }\n\n            unlock_user_struct(buf, arg1, 1);\n\n        }\n\n        break;\n\n#ifdef TARGET_I386\n\n    case TARGET_NR_modify_ldt:\n\n        ret = do_modify_ldt(cpu_env, arg1, arg2, arg3);\n\n        break;\n\n#if !defined(TARGET_X86_64)\n\n    case TARGET_NR_vm86old:\n\n        goto unimplemented;\n\n    case TARGET_NR_vm86:\n\n        ret = do_vm86(cpu_env, arg1, arg2);\n\n        break;\n\n#endif\n\n#endif\n\n    case TARGET_NR_adjtimex:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_create_module\n\n    case TARGET_NR_create_module:\n\n#endif\n\n    case TARGET_NR_init_module:\n\n    case TARGET_NR_delete_module:\n\n#ifdef TARGET_NR_get_kernel_syms\n\n    case TARGET_NR_get_kernel_syms:\n\n#endif\n\n        goto unimplemented;\n\n    case TARGET_NR_quotactl:\n\n        goto unimplemented;\n\n    case TARGET_NR_getpgid:\n\n        ret = get_errno(getpgid(arg1));\n\n        break;\n\n    case TARGET_NR_fchdir:\n\n        ret = get_errno(fchdir(arg1));\n\n        break;\n\n#ifdef TARGET_NR_bdflush /* not on x86_64 */\n\n    case TARGET_NR_bdflush:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_sysfs\n\n    case TARGET_NR_sysfs:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_personality:\n\n        ret = get_errno(personality(arg1));\n\n        break;\n\n#ifdef TARGET_NR_afs_syscall\n\n    case TARGET_NR_afs_syscall:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR__llseek /* Not on alpha */\n\n    case TARGET_NR__llseek:\n\n        {\n\n            int64_t res;\n\n#if !defined(__NR_llseek)\n\n            res = lseek(arg1, ((uint64_t)arg2 << 32) | arg3, arg5);\n\n            if (res == -1) {\n\n                ret = get_errno(res);\n\n            } else {\n\n                ret = 0;\n\n            }\n\n#else\n\n            ret = get_errno(_llseek(arg1, arg2, arg3, &res, arg5));\n\n#endif\n\n            if ((ret == 0) && put_user_s64(res, arg4)) {\n\n                goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_getdents:\n\n#if TARGET_ABI_BITS == 32 && HOST_LONG_BITS == 64\n\n        {\n\n            struct target_dirent *target_dirp;\n\n            struct linux_dirent *dirp;\n\n            abi_long count = arg3;\n\n\n\n\t    dirp = malloc(count);\n\n\t    if (!dirp) {\n\n                ret = -TARGET_ENOMEM;\n\n                goto fail;\n\n            }\n\n\n\n            ret = get_errno(sys_getdents(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct linux_dirent *de;\n\n\t\tstruct target_dirent *tde;\n\n                int len = ret;\n\n                int reclen, treclen;\n\n\t\tint count1, tnamelen;\n\n\n\n\t\tcount1 = 0;\n\n                de = dirp;\n\n                if (!(target_dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))\n\n                    goto efault;\n\n\t\ttde = target_dirp;\n\n                while (len > 0) {\n\n                    reclen = de->d_reclen;\n\n                    tnamelen = reclen - offsetof(struct linux_dirent, d_name);\n\n                    assert(tnamelen >= 0);\n\n                    treclen = tnamelen + offsetof(struct target_dirent, d_name);\n\n                    assert(count1 + treclen <= count);\n\n                    tde->d_reclen = tswap16(treclen);\n\n                    tde->d_ino = tswapal(de->d_ino);\n\n                    tde->d_off = tswapal(de->d_off);\n\n                    memcpy(tde->d_name, de->d_name, tnamelen);\n\n                    de = (struct linux_dirent *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                    tde = (struct target_dirent *)((char *)tde + treclen);\n\n\t\t    count1 += treclen;\n\n                }\n\n\t\tret = count1;\n\n                unlock_user(target_dirp, arg2, ret);\n\n            }\n\n\t    free(dirp);\n\n        }\n\n#else\n\n        {\n\n            struct linux_dirent *dirp;\n\n            abi_long count = arg3;\n\n\n\n            if (!(dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))\n\n                goto efault;\n\n            ret = get_errno(sys_getdents(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct linux_dirent *de;\n\n                int len = ret;\n\n                int reclen;\n\n                de = dirp;\n\n                while (len > 0) {\n\n                    reclen = de->d_reclen;\n\n                    if (reclen > len)\n\n                        break;\n\n                    de->d_reclen = tswap16(reclen);\n\n                    tswapls(&de->d_ino);\n\n                    tswapls(&de->d_off);\n\n                    de = (struct linux_dirent *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                }\n\n            }\n\n            unlock_user(dirp, arg2, ret);\n\n        }\n\n#endif\n\n        break;\n\n#if defined(TARGET_NR_getdents64) && defined(__NR_getdents64)\n\n    case TARGET_NR_getdents64:\n\n        {\n\n            struct linux_dirent64 *dirp;\n\n            abi_long count = arg3;\n\n            if (!(dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))\n\n                goto efault;\n\n            ret = get_errno(sys_getdents64(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct linux_dirent64 *de;\n\n                int len = ret;\n\n                int reclen;\n\n                de = dirp;\n\n                while (len > 0) {\n\n                    reclen = de->d_reclen;\n\n                    if (reclen > len)\n\n                        break;\n\n                    de->d_reclen = tswap16(reclen);\n\n                    tswap64s((uint64_t *)&de->d_ino);\n\n                    tswap64s((uint64_t *)&de->d_off);\n\n                    de = (struct linux_dirent64 *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                }\n\n            }\n\n            unlock_user(dirp, arg2, ret);\n\n        }\n\n        break;\n\n#endif /* TARGET_NR_getdents64 */\n\n#if defined(TARGET_NR__newselect) || defined(TARGET_S390X)\n\n#ifdef TARGET_S390X\n\n    case TARGET_NR_select:\n\n#else\n\n    case TARGET_NR__newselect:\n\n#endif\n\n        ret = do_select(arg1, arg2, arg3, arg4, arg5);\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_poll) || defined(TARGET_NR_ppoll)\n\n# ifdef TARGET_NR_poll\n\n    case TARGET_NR_poll:\n\n# endif\n\n# ifdef TARGET_NR_ppoll\n\n    case TARGET_NR_ppoll:\n\n# endif\n\n        {\n\n            struct target_pollfd *target_pfd;\n\n            unsigned int nfds = arg2;\n\n            int timeout = arg3;\n\n            struct pollfd *pfd;\n\n            unsigned int i;\n\n\n\n            target_pfd = lock_user(VERIFY_WRITE, arg1, sizeof(struct target_pollfd) * nfds, 1);\n\n            if (!target_pfd)\n\n                goto efault;\n\n\n\n            pfd = alloca(sizeof(struct pollfd) * nfds);\n\n            for(i = 0; i < nfds; i++) {\n\n                pfd[i].fd = tswap32(target_pfd[i].fd);\n\n                pfd[i].events = tswap16(target_pfd[i].events);\n\n            }\n\n\n\n# ifdef TARGET_NR_ppoll\n\n            if (num == TARGET_NR_ppoll) {\n\n                struct timespec _timeout_ts, *timeout_ts = &_timeout_ts;\n\n                target_sigset_t *target_set;\n\n                sigset_t _set, *set = &_set;\n\n\n\n                if (arg3) {\n\n                    if (target_to_host_timespec(timeout_ts, arg3)) {\n\n                        unlock_user(target_pfd, arg1, 0);\n\n                        goto efault;\n\n                    }\n\n                } else {\n\n                    timeout_ts = NULL;\n\n                }\n\n\n\n                if (arg4) {\n\n                    target_set = lock_user(VERIFY_READ, arg4, sizeof(target_sigset_t), 1);\n\n                    if (!target_set) {\n\n                        unlock_user(target_pfd, arg1, 0);\n\n                        goto efault;\n\n                    }\n\n                    target_to_host_sigset(set, target_set);\n\n                } else {\n\n                    set = NULL;\n\n                }\n\n\n\n                ret = get_errno(sys_ppoll(pfd, nfds, timeout_ts, set, _NSIG/8));\n\n\n\n                if (!is_error(ret) && arg3) {\n\n                    host_to_target_timespec(arg3, timeout_ts);\n\n                }\n\n                if (arg4) {\n\n                    unlock_user(target_set, arg4, 0);\n\n                }\n\n            } else\n\n# endif\n\n                ret = get_errno(poll(pfd, nfds, timeout));\n\n\n\n            if (!is_error(ret)) {\n\n                for(i = 0; i < nfds; i++) {\n\n                    target_pfd[i].revents = tswap16(pfd[i].revents);\n\n                }\n\n            }\n\n            unlock_user(target_pfd, arg1, sizeof(struct target_pollfd) * nfds);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_flock:\n\n        /* NOTE: the flock constant seems to be the same for every\n\n           Linux platform */\n\n        ret = get_errno(flock(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_readv:\n\n        {\n\n            int count = arg3;\n\n            struct iovec *vec;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            if (lock_iovec(VERIFY_WRITE, vec, arg2, count, 0) < 0)\n\n                goto efault;\n\n            ret = get_errno(readv(arg1, vec, count));\n\n            unlock_iovec(vec, arg2, count, 1);\n\n        }\n\n        break;\n\n    case TARGET_NR_writev:\n\n        {\n\n            int count = arg3;\n\n            struct iovec *vec;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            if (lock_iovec(VERIFY_READ, vec, arg2, count, 1) < 0)\n\n                goto efault;\n\n            ret = get_errno(writev(arg1, vec, count));\n\n            unlock_iovec(vec, arg2, count, 0);\n\n        }\n\n        break;\n\n    case TARGET_NR_getsid:\n\n        ret = get_errno(getsid(arg1));\n\n        break;\n\n#if defined(TARGET_NR_fdatasync) /* Not on alpha (osf_datasync ?) */\n\n    case TARGET_NR_fdatasync:\n\n        ret = get_errno(fdatasync(arg1));\n\n        break;\n\n#endif\n\n    case TARGET_NR__sysctl:\n\n        /* We don't implement this, but ENOTDIR is always a safe\n\n           return value. */\n\n        ret = -TARGET_ENOTDIR;\n\n        break;\n\n    case TARGET_NR_sched_getaffinity:\n\n        {\n\n            unsigned int mask_size;\n\n            unsigned long *mask;\n\n\n\n            /*\n\n             * sched_getaffinity needs multiples of ulong, so need to take\n\n             * care of mismatches between target ulong and host ulong sizes.\n\n             */\n\n            if (arg2 & (sizeof(abi_ulong) - 1)) {\n\n                ret = -TARGET_EINVAL;\n\n                break;\n\n            }\n\n            mask_size = (arg2 + (sizeof(*mask) - 1)) & ~(sizeof(*mask) - 1);\n\n\n\n            mask = alloca(mask_size);\n\n            ret = get_errno(sys_sched_getaffinity(arg1, mask_size, mask));\n\n\n\n            if (!is_error(ret)) {\n\n                if (copy_to_user(arg3, mask, ret)) {\n\n                    goto efault;\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_setaffinity:\n\n        {\n\n            unsigned int mask_size;\n\n            unsigned long *mask;\n\n\n\n            /*\n\n             * sched_setaffinity needs multiples of ulong, so need to take\n\n             * care of mismatches between target ulong and host ulong sizes.\n\n             */\n\n            if (arg2 & (sizeof(abi_ulong) - 1)) {\n\n                ret = -TARGET_EINVAL;\n\n                break;\n\n            }\n\n            mask_size = (arg2 + (sizeof(*mask) - 1)) & ~(sizeof(*mask) - 1);\n\n\n\n            mask = alloca(mask_size);\n\n            if (!lock_user_struct(VERIFY_READ, p, arg3, 1)) {\n\n                goto efault;\n\n            }\n\n            memcpy(mask, p, arg2);\n\n            unlock_user_struct(p, arg2, 0);\n\n\n\n            ret = get_errno(sys_sched_setaffinity(arg1, mask_size, mask));\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_setparam:\n\n        {\n\n            struct sched_param *target_schp;\n\n            struct sched_param schp;\n\n\n\n            if (!lock_user_struct(VERIFY_READ, target_schp, arg2, 1))\n\n                goto efault;\n\n            schp.sched_priority = tswap32(target_schp->sched_priority);\n\n            unlock_user_struct(target_schp, arg2, 0);\n\n            ret = get_errno(sched_setparam(arg1, &schp));\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_getparam:\n\n        {\n\n            struct sched_param *target_schp;\n\n            struct sched_param schp;\n\n            ret = get_errno(sched_getparam(arg1, &schp));\n\n            if (!is_error(ret)) {\n\n                if (!lock_user_struct(VERIFY_WRITE, target_schp, arg2, 0))\n\n                    goto efault;\n\n                target_schp->sched_priority = tswap32(schp.sched_priority);\n\n                unlock_user_struct(target_schp, arg2, 1);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_setscheduler:\n\n        {\n\n            struct sched_param *target_schp;\n\n            struct sched_param schp;\n\n            if (!lock_user_struct(VERIFY_READ, target_schp, arg3, 1))\n\n                goto efault;\n\n            schp.sched_priority = tswap32(target_schp->sched_priority);\n\n            unlock_user_struct(target_schp, arg3, 0);\n\n            ret = get_errno(sched_setscheduler(arg1, arg2, &schp));\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_getscheduler:\n\n        ret = get_errno(sched_getscheduler(arg1));\n\n        break;\n\n    case TARGET_NR_sched_yield:\n\n        ret = get_errno(sched_yield());\n\n        break;\n\n    case TARGET_NR_sched_get_priority_max:\n\n        ret = get_errno(sched_get_priority_max(arg1));\n\n        break;\n\n    case TARGET_NR_sched_get_priority_min:\n\n        ret = get_errno(sched_get_priority_min(arg1));\n\n        break;\n\n    case TARGET_NR_sched_rr_get_interval:\n\n        {\n\n            struct timespec ts;\n\n            ret = get_errno(sched_rr_get_interval(arg1, &ts));\n\n            if (!is_error(ret)) {\n\n                host_to_target_timespec(arg2, &ts);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_nanosleep:\n\n        {\n\n            struct timespec req, rem;\n\n            target_to_host_timespec(&req, arg1);\n\n            ret = get_errno(nanosleep(&req, &rem));\n\n            if (is_error(ret) && arg2) {\n\n                host_to_target_timespec(arg2, &rem);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_query_module\n\n    case TARGET_NR_query_module:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_nfsservctl\n\n    case TARGET_NR_nfsservctl:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_prctl:\n\n        switch (arg1) {\n\n        case PR_GET_PDEATHSIG:\n\n        {\n\n            int deathsig;\n\n            ret = get_errno(prctl(arg1, &deathsig, arg3, arg4, arg5));\n\n            if (!is_error(ret) && arg2\n\n                && put_user_ual(deathsig, arg2)) {\n\n                goto efault;\n\n            }\n\n            break;\n\n        }\n\n#ifdef PR_GET_NAME\n\n        case PR_GET_NAME:\n\n        {\n\n            void *name = lock_user(VERIFY_WRITE, arg2, 16, 1);\n\n            if (!name) {\n\n                goto efault;\n\n            }\n\n            ret = get_errno(prctl(arg1, (unsigned long)name,\n\n                                  arg3, arg4, arg5));\n\n            unlock_user(name, arg2, 16);\n\n            break;\n\n        }\n\n        case PR_SET_NAME:\n\n        {\n\n            void *name = lock_user(VERIFY_READ, arg2, 16, 1);\n\n            if (!name) {\n\n                goto efault;\n\n            }\n\n            ret = get_errno(prctl(arg1, (unsigned long)name,\n\n                                  arg3, arg4, arg5));\n\n            unlock_user(name, arg2, 0);\n\n            break;\n\n        }\n\n#endif\n\n        default:\n\n            /* Most prctl options have no pointer arguments */\n\n            ret = get_errno(prctl(arg1, arg2, arg3, arg4, arg5));\n\n            break;\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_arch_prctl\n\n    case TARGET_NR_arch_prctl:\n\n#if defined(TARGET_I386) && !defined(TARGET_ABI32)\n\n        ret = do_arch_prctl(cpu_env, arg1, arg2);\n\n        break;\n\n#else\n\n        goto unimplemented;\n\n#endif\n\n#endif\n\n#ifdef TARGET_NR_pread\n\n    case TARGET_NR_pread:\n\n        if (regpairs_aligned(cpu_env))\n\n            arg4 = arg5;\n\n        if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))\n\n            goto efault;\n\n        ret = get_errno(pread(arg1, p, arg3, arg4));\n\n        unlock_user(p, arg2, ret);\n\n        break;\n\n    case TARGET_NR_pwrite:\n\n        if (regpairs_aligned(cpu_env))\n\n            arg4 = arg5;\n\n        if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))\n\n            goto efault;\n\n        ret = get_errno(pwrite(arg1, p, arg3, arg4));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_pread64\n\n    case TARGET_NR_pread64:\n\n        if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))\n\n            goto efault;\n\n        ret = get_errno(pread64(arg1, p, arg3, target_offset64(arg4, arg5)));\n\n        unlock_user(p, arg2, ret);\n\n        break;\n\n    case TARGET_NR_pwrite64:\n\n        if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))\n\n            goto efault;\n\n        ret = get_errno(pwrite64(arg1, p, arg3, target_offset64(arg4, arg5)));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_getcwd:\n\n        if (!(p = lock_user(VERIFY_WRITE, arg1, arg2, 0)))\n\n            goto efault;\n\n        ret = get_errno(sys_getcwd1(p, arg2));\n\n        unlock_user(p, arg1, ret);\n\n        break;\n\n    case TARGET_NR_capget:\n\n        goto unimplemented;\n\n    case TARGET_NR_capset:\n\n        goto unimplemented;\n\n    case TARGET_NR_sigaltstack:\n\n#if defined(TARGET_I386) || defined(TARGET_ARM) || defined(TARGET_MIPS) || \\\n\n    defined(TARGET_SPARC) || defined(TARGET_PPC) || defined(TARGET_ALPHA) || \\\n\n    defined(TARGET_M68K) || defined(TARGET_S390X) || defined(TARGET_OPENRISC)\n\n        ret = do_sigaltstack(arg1, arg2, get_sp_from_cpustate((CPUArchState *)cpu_env));\n\n        break;\n\n#else\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_sendfile:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_getpmsg\n\n    case TARGET_NR_getpmsg:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_putpmsg\n\n    case TARGET_NR_putpmsg:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_vfork\n\n    case TARGET_NR_vfork:\n\n        ret = get_errno(do_fork(cpu_env, CLONE_VFORK | CLONE_VM | SIGCHLD,\n\n                        0, 0, 0, 0));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_ugetrlimit\n\n    case TARGET_NR_ugetrlimit:\n\n    {\n\n\tstruct rlimit rlim;\n\n\tint resource = target_to_host_resource(arg1);\n\n\tret = get_errno(getrlimit(resource, &rlim));\n\n\tif (!is_error(ret)) {\n\n\t    struct target_rlimit *target_rlim;\n\n            if (!lock_user_struct(VERIFY_WRITE, target_rlim, arg2, 0))\n\n                goto efault;\n\n\t    target_rlim->rlim_cur = host_to_target_rlim(rlim.rlim_cur);\n\n\t    target_rlim->rlim_max = host_to_target_rlim(rlim.rlim_max);\n\n            unlock_user_struct(target_rlim, arg2, 1);\n\n\t}\n\n\tbreak;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_truncate64\n\n    case TARGET_NR_truncate64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n\tret = target_truncate64(cpu_env, p, arg2, arg3, arg4);\n\n        unlock_user(p, arg1, 0);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_ftruncate64\n\n    case TARGET_NR_ftruncate64:\n\n\tret = target_ftruncate64(cpu_env, arg1, arg2, arg3, arg4);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_stat64\n\n    case TARGET_NR_stat64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(stat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg2, &st);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_lstat64\n\n    case TARGET_NR_lstat64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lstat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg2, &st);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_fstat64\n\n    case TARGET_NR_fstat64:\n\n        ret = get_errno(fstat(arg1, &st));\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg2, &st);\n\n        break;\n\n#endif\n\n#if (defined(TARGET_NR_fstatat64) || defined(TARGET_NR_newfstatat)) && \\\n\n        (defined(__NR_fstatat64) || defined(__NR_newfstatat))\n\n#ifdef TARGET_NR_fstatat64\n\n    case TARGET_NR_fstatat64:\n\n#endif\n\n#ifdef TARGET_NR_newfstatat\n\n    case TARGET_NR_newfstatat:\n\n#endif\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n#ifdef __NR_fstatat64\n\n        ret = get_errno(sys_fstatat64(arg1, path(p), &st, arg4));\n\n#else\n\n        ret = get_errno(sys_newfstatat(arg1, path(p), &st, arg4));\n\n#endif\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg3, &st);\n\n        break;\n\n#endif\n\n    case TARGET_NR_lchown:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lchown(p, low2highuid(arg2), low2highgid(arg3)));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_getuid\n\n    case TARGET_NR_getuid:\n\n        ret = get_errno(high2lowuid(getuid()));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getgid\n\n    case TARGET_NR_getgid:\n\n        ret = get_errno(high2lowgid(getgid()));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_geteuid\n\n    case TARGET_NR_geteuid:\n\n        ret = get_errno(high2lowuid(geteuid()));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getegid\n\n    case TARGET_NR_getegid:\n\n        ret = get_errno(high2lowgid(getegid()));\n\n        break;\n\n#endif\n\n    case TARGET_NR_setreuid:\n\n        ret = get_errno(setreuid(low2highuid(arg1), low2highuid(arg2)));\n\n        break;\n\n    case TARGET_NR_setregid:\n\n        ret = get_errno(setregid(low2highgid(arg1), low2highgid(arg2)));\n\n        break;\n\n    case TARGET_NR_getgroups:\n\n        {\n\n            int gidsetsize = arg1;\n\n            target_id *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            ret = get_errno(getgroups(gidsetsize, grouplist));\n\n            if (gidsetsize == 0)\n\n                break;\n\n            if (!is_error(ret)) {\n\n                target_grouplist = lock_user(VERIFY_WRITE, arg2, gidsetsize * 2, 0);\n\n                if (!target_grouplist)\n\n                    goto efault;\n\n                for(i = 0;i < ret; i++)\n\n                    target_grouplist[i] = tswapid(high2lowgid(grouplist[i]));\n\n                unlock_user(target_grouplist, arg2, gidsetsize * 2);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_setgroups:\n\n        {\n\n            int gidsetsize = arg1;\n\n            target_id *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            target_grouplist = lock_user(VERIFY_READ, arg2, gidsetsize * 2, 1);\n\n            if (!target_grouplist) {\n\n                ret = -TARGET_EFAULT;\n\n                goto fail;\n\n            }\n\n            for(i = 0;i < gidsetsize; i++)\n\n                grouplist[i] = low2highgid(tswapid(target_grouplist[i]));\n\n            unlock_user(target_grouplist, arg2, 0);\n\n            ret = get_errno(setgroups(gidsetsize, grouplist));\n\n        }\n\n        break;\n\n    case TARGET_NR_fchown:\n\n        ret = get_errno(fchown(arg1, low2highuid(arg2), low2highgid(arg3)));\n\n        break;\n\n#if defined(TARGET_NR_fchownat) && defined(__NR_fchownat)\n\n    case TARGET_NR_fchownat:\n\n        if (!(p = lock_user_string(arg2))) \n\n            goto efault;\n\n        ret = get_errno(sys_fchownat(arg1, p, low2highuid(arg3), low2highgid(arg4), arg5));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setresuid\n\n    case TARGET_NR_setresuid:\n\n        ret = get_errno(setresuid(low2highuid(arg1),\n\n                                  low2highuid(arg2),\n\n                                  low2highuid(arg3)));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresuid\n\n    case TARGET_NR_getresuid:\n\n        {\n\n            uid_t ruid, euid, suid;\n\n            ret = get_errno(getresuid(&ruid, &euid, &suid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u16(high2lowuid(ruid), arg1)\n\n                    || put_user_u16(high2lowuid(euid), arg2)\n\n                    || put_user_u16(high2lowuid(suid), arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresgid\n\n    case TARGET_NR_setresgid:\n\n        ret = get_errno(setresgid(low2highgid(arg1),\n\n                                  low2highgid(arg2),\n\n                                  low2highgid(arg3)));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresgid\n\n    case TARGET_NR_getresgid:\n\n        {\n\n            gid_t rgid, egid, sgid;\n\n            ret = get_errno(getresgid(&rgid, &egid, &sgid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u16(high2lowgid(rgid), arg1)\n\n                    || put_user_u16(high2lowgid(egid), arg2)\n\n                    || put_user_u16(high2lowgid(sgid), arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_chown:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chown(p, low2highuid(arg2), low2highgid(arg3)));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_setuid:\n\n        ret = get_errno(setuid(low2highuid(arg1)));\n\n        break;\n\n    case TARGET_NR_setgid:\n\n        ret = get_errno(setgid(low2highgid(arg1)));\n\n        break;\n\n    case TARGET_NR_setfsuid:\n\n        ret = get_errno(setfsuid(arg1));\n\n        break;\n\n    case TARGET_NR_setfsgid:\n\n        ret = get_errno(setfsgid(arg1));\n\n        break;\n\n\n\n#ifdef TARGET_NR_lchown32\n\n    case TARGET_NR_lchown32:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lchown(p, arg2, arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getuid32\n\n    case TARGET_NR_getuid32:\n\n        ret = get_errno(getuid());\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_getxuid) && defined(TARGET_ALPHA)\n\n   /* Alpha specific */\n\n    case TARGET_NR_getxuid:\n\n         {\n\n            uid_t euid;\n\n            euid=geteuid();\n\n            ((CPUAlphaState *)cpu_env)->ir[IR_A4]=euid;\n\n         }\n\n        ret = get_errno(getuid());\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_getxgid) && defined(TARGET_ALPHA)\n\n   /* Alpha specific */\n\n    case TARGET_NR_getxgid:\n\n         {\n\n            uid_t egid;\n\n            egid=getegid();\n\n            ((CPUAlphaState *)cpu_env)->ir[IR_A4]=egid;\n\n         }\n\n        ret = get_errno(getgid());\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_osf_getsysinfo) && defined(TARGET_ALPHA)\n\n    /* Alpha specific */\n\n    case TARGET_NR_osf_getsysinfo:\n\n        ret = -TARGET_EOPNOTSUPP;\n\n        switch (arg1) {\n\n          case TARGET_GSI_IEEE_FP_CONTROL:\n\n            {\n\n                uint64_t swcr, fpcr = cpu_alpha_load_fpcr (cpu_env);\n\n\n\n                /* Copied from linux ieee_fpcr_to_swcr.  */\n\n                swcr = (fpcr >> 35) & SWCR_STATUS_MASK;\n\n                swcr |= (fpcr >> 36) & SWCR_MAP_DMZ;\n\n                swcr |= (~fpcr >> 48) & (SWCR_TRAP_ENABLE_INV\n\n                                        | SWCR_TRAP_ENABLE_DZE\n\n                                        | SWCR_TRAP_ENABLE_OVF);\n\n                swcr |= (~fpcr >> 57) & (SWCR_TRAP_ENABLE_UNF\n\n                                        | SWCR_TRAP_ENABLE_INE);\n\n                swcr |= (fpcr >> 47) & SWCR_MAP_UMZ;\n\n                swcr |= (~fpcr >> 41) & SWCR_TRAP_ENABLE_DNO;\n\n\n\n                if (put_user_u64 (swcr, arg2))\n\n                        goto efault;\n\n                ret = 0;\n\n            }\n\n            break;\n\n\n\n          /* case GSI_IEEE_STATE_AT_SIGNAL:\n\n             -- Not implemented in linux kernel.\n\n             case GSI_UACPROC:\n\n             -- Retrieves current unaligned access state; not much used.\n\n             case GSI_PROC_TYPE:\n\n             -- Retrieves implver information; surely not used.\n\n             case GSI_GET_HWRPB:\n\n             -- Grabs a copy of the HWRPB; surely not used.\n\n          */\n\n        }\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_osf_setsysinfo) && defined(TARGET_ALPHA)\n\n    /* Alpha specific */\n\n    case TARGET_NR_osf_setsysinfo:\n\n        ret = -TARGET_EOPNOTSUPP;\n\n        switch (arg1) {\n\n          case TARGET_SSI_IEEE_FP_CONTROL:\n\n            {\n\n                uint64_t swcr, fpcr, orig_fpcr;\n\n\n\n                if (get_user_u64 (swcr, arg2)) {\n\n                    goto efault;\n\n                }\n\n                orig_fpcr = cpu_alpha_load_fpcr(cpu_env);\n\n                fpcr = orig_fpcr & FPCR_DYN_MASK;\n\n\n\n                /* Copied from linux ieee_swcr_to_fpcr.  */\n\n                fpcr |= (swcr & SWCR_STATUS_MASK) << 35;\n\n                fpcr |= (swcr & SWCR_MAP_DMZ) << 36;\n\n                fpcr |= (~swcr & (SWCR_TRAP_ENABLE_INV\n\n                                  | SWCR_TRAP_ENABLE_DZE\n\n                                  | SWCR_TRAP_ENABLE_OVF)) << 48;\n\n                fpcr |= (~swcr & (SWCR_TRAP_ENABLE_UNF\n\n                                  | SWCR_TRAP_ENABLE_INE)) << 57;\n\n                fpcr |= (swcr & SWCR_MAP_UMZ ? FPCR_UNDZ | FPCR_UNFD : 0);\n\n                fpcr |= (~swcr & SWCR_TRAP_ENABLE_DNO) << 41;\n\n\n\n                cpu_alpha_store_fpcr(cpu_env, fpcr);\n\n                ret = 0;\n\n            }\n\n            break;\n\n\n\n          case TARGET_SSI_IEEE_RAISE_EXCEPTION:\n\n            {\n\n                uint64_t exc, fpcr, orig_fpcr;\n\n                int si_code;\n\n\n\n                if (get_user_u64(exc, arg2)) {\n\n                    goto efault;\n\n                }\n\n\n\n                orig_fpcr = cpu_alpha_load_fpcr(cpu_env);\n\n\n\n                /* We only add to the exception status here.  */\n\n                fpcr = orig_fpcr | ((exc & SWCR_STATUS_MASK) << 35);\n\n\n\n                cpu_alpha_store_fpcr(cpu_env, fpcr);\n\n                ret = 0;\n\n\n\n                /* Old exceptions are not signaled.  */\n\n                fpcr &= ~(orig_fpcr & FPCR_STATUS_MASK);\n\n\n\n                /* If any exceptions set by this call,\n\n                   and are unmasked, send a signal.  */\n\n                si_code = 0;\n\n                if ((fpcr & (FPCR_INE | FPCR_INED)) == FPCR_INE) {\n\n                    si_code = TARGET_FPE_FLTRES;\n\n                }\n\n                if ((fpcr & (FPCR_UNF | FPCR_UNFD)) == FPCR_UNF) {\n\n                    si_code = TARGET_FPE_FLTUND;\n\n                }\n\n                if ((fpcr & (FPCR_OVF | FPCR_OVFD)) == FPCR_OVF) {\n\n                    si_code = TARGET_FPE_FLTOVF;\n\n                }\n\n                if ((fpcr & (FPCR_DZE | FPCR_DZED)) == FPCR_DZE) {\n\n                    si_code = TARGET_FPE_FLTDIV;\n\n                }\n\n                if ((fpcr & (FPCR_INV | FPCR_INVD)) == FPCR_INV) {\n\n                    si_code = TARGET_FPE_FLTINV;\n\n                }\n\n                if (si_code != 0) {\n\n                    target_siginfo_t info;\n\n                    info.si_signo = SIGFPE;\n\n                    info.si_errno = 0;\n\n                    info.si_code = si_code;\n\n                    info._sifields._sigfault._addr\n\n                        = ((CPUArchState *)cpu_env)->pc;\n\n                    queue_signal((CPUArchState *)cpu_env, info.si_signo, &info);\n\n                }\n\n            }\n\n            break;\n\n\n\n          /* case SSI_NVPAIRS:\n\n             -- Used with SSIN_UACPROC to enable unaligned accesses.\n\n             case SSI_IEEE_STATE_AT_SIGNAL:\n\n             case SSI_IEEE_IGNORE_STATE_AT_SIGNAL:\n\n             -- Not implemented in linux kernel\n\n          */\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_osf_sigprocmask\n\n    /* Alpha specific.  */\n\n    case TARGET_NR_osf_sigprocmask:\n\n        {\n\n            abi_ulong mask;\n\n            int how;\n\n            sigset_t set, oldset;\n\n\n\n            switch(arg1) {\n\n            case TARGET_SIG_BLOCK:\n\n                how = SIG_BLOCK;\n\n                break;\n\n            case TARGET_SIG_UNBLOCK:\n\n                how = SIG_UNBLOCK;\n\n                break;\n\n            case TARGET_SIG_SETMASK:\n\n                how = SIG_SETMASK;\n\n                break;\n\n            default:\n\n                ret = -TARGET_EINVAL;\n\n                goto fail;\n\n            }\n\n            mask = arg2;\n\n            target_to_host_old_sigset(&set, &mask);\n\n            sigprocmask(how, &set, &oldset);\n\n            host_to_target_old_sigset(&mask, &oldset);\n\n            ret = mask;\n\n        }\n\n        break;\n\n#endif\n\n\n\n#ifdef TARGET_NR_getgid32\n\n    case TARGET_NR_getgid32:\n\n        ret = get_errno(getgid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_geteuid32\n\n    case TARGET_NR_geteuid32:\n\n        ret = get_errno(geteuid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getegid32\n\n    case TARGET_NR_getegid32:\n\n        ret = get_errno(getegid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setreuid32\n\n    case TARGET_NR_setreuid32:\n\n        ret = get_errno(setreuid(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setregid32\n\n    case TARGET_NR_setregid32:\n\n        ret = get_errno(setregid(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getgroups32\n\n    case TARGET_NR_getgroups32:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint32_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            ret = get_errno(getgroups(gidsetsize, grouplist));\n\n            if (gidsetsize == 0)\n\n                break;\n\n            if (!is_error(ret)) {\n\n                target_grouplist = lock_user(VERIFY_WRITE, arg2, gidsetsize * 4, 0);\n\n                if (!target_grouplist) {\n\n                    ret = -TARGET_EFAULT;\n\n                    goto fail;\n\n                }\n\n                for(i = 0;i < ret; i++)\n\n                    target_grouplist[i] = tswap32(grouplist[i]);\n\n                unlock_user(target_grouplist, arg2, gidsetsize * 4);\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setgroups32\n\n    case TARGET_NR_setgroups32:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint32_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            target_grouplist = lock_user(VERIFY_READ, arg2, gidsetsize * 4, 1);\n\n            if (!target_grouplist) {\n\n                ret = -TARGET_EFAULT;\n\n                goto fail;\n\n            }\n\n            for(i = 0;i < gidsetsize; i++)\n\n                grouplist[i] = tswap32(target_grouplist[i]);\n\n            unlock_user(target_grouplist, arg2, 0);\n\n            ret = get_errno(setgroups(gidsetsize, grouplist));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_fchown32\n\n    case TARGET_NR_fchown32:\n\n        ret = get_errno(fchown(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setresuid32\n\n    case TARGET_NR_setresuid32:\n\n        ret = get_errno(setresuid(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresuid32\n\n    case TARGET_NR_getresuid32:\n\n        {\n\n            uid_t ruid, euid, suid;\n\n            ret = get_errno(getresuid(&ruid, &euid, &suid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u32(ruid, arg1)\n\n                    || put_user_u32(euid, arg2)\n\n                    || put_user_u32(suid, arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setresgid32\n\n    case TARGET_NR_setresgid32:\n\n        ret = get_errno(setresgid(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresgid32\n\n    case TARGET_NR_getresgid32:\n\n        {\n\n            gid_t rgid, egid, sgid;\n\n            ret = get_errno(getresgid(&rgid, &egid, &sgid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u32(rgid, arg1)\n\n                    || put_user_u32(egid, arg2)\n\n                    || put_user_u32(sgid, arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_chown32\n\n    case TARGET_NR_chown32:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chown(p, arg2, arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setuid32\n\n    case TARGET_NR_setuid32:\n\n        ret = get_errno(setuid(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setgid32\n\n    case TARGET_NR_setgid32:\n\n        ret = get_errno(setgid(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setfsuid32\n\n    case TARGET_NR_setfsuid32:\n\n        ret = get_errno(setfsuid(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setfsgid32\n\n    case TARGET_NR_setfsgid32:\n\n        ret = get_errno(setfsgid(arg1));\n\n        break;\n\n#endif\n\n\n\n    case TARGET_NR_pivot_root:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_mincore\n\n    case TARGET_NR_mincore:\n\n        {\n\n            void *a;\n\n            ret = -TARGET_EFAULT;\n\n            if (!(a = lock_user(VERIFY_READ, arg1,arg2, 0)))\n\n                goto efault;\n\n            if (!(p = lock_user_string(arg3)))\n\n                goto mincore_fail;\n\n            ret = get_errno(mincore(a, arg2, p));\n\n            unlock_user(p, arg3, ret);\n\n            mincore_fail:\n\n            unlock_user(a, arg1, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_arm_fadvise64_64\n\n    case TARGET_NR_arm_fadvise64_64:\n\n\t{\n\n\t\t/*\n\n\t\t * arm_fadvise64_64 looks like fadvise64_64 but\n\n\t\t * with different argument order\n\n\t\t */\n\n\t\tabi_long temp;\n\n\t\ttemp = arg3;\n\n\t\targ3 = arg4;\n\n\t\targ4 = temp;\n\n\t}\n\n#endif\n\n#if defined(TARGET_NR_fadvise64_64) || defined(TARGET_NR_arm_fadvise64_64) || defined(TARGET_NR_fadvise64)\n\n#ifdef TARGET_NR_fadvise64_64\n\n    case TARGET_NR_fadvise64_64:\n\n#endif\n\n#ifdef TARGET_NR_fadvise64\n\n    case TARGET_NR_fadvise64:\n\n#endif\n\n#ifdef TARGET_S390X\n\n        switch (arg4) {\n\n        case 4: arg4 = POSIX_FADV_NOREUSE + 1; break; /* make sure it's an invalid value */\n\n        case 5: arg4 = POSIX_FADV_NOREUSE + 2; break; /* ditto */\n\n        case 6: arg4 = POSIX_FADV_DONTNEED; break;\n\n        case 7: arg4 = POSIX_FADV_NOREUSE; break;\n\n        default: break;\n\n        }\n\n#endif\n\n        ret = -posix_fadvise(arg1, arg2, arg3, arg4);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_madvise\n\n    case TARGET_NR_madvise:\n\n        /* A straight passthrough may not be safe because qemu sometimes\n\n           turns private flie-backed mappings into anonymous mappings.\n\n           This will break MADV_DONTNEED.\n\n           This is a hint, so ignoring and returning success is ok.  */\n\n        ret = get_errno(0);\n\n        break;\n\n#endif\n\n#if TARGET_ABI_BITS == 32\n\n    case TARGET_NR_fcntl64:\n\n    {\n\n\tint cmd;\n\n\tstruct flock64 fl;\n\n\tstruct target_flock64 *target_fl;\n\n#ifdef TARGET_ARM\n\n\tstruct target_eabi_flock64 *target_efl;\n\n#endif\n\n\n\n\tcmd = target_to_host_fcntl_cmd(arg2);\n\n        if (cmd == -TARGET_EINVAL) {\n\n            ret = cmd;\n\n            break;\n\n        }\n\n\n\n        switch(arg2) {\n\n        case TARGET_F_GETLK64:\n\n#ifdef TARGET_ARM\n\n            if (((CPUARMState *)cpu_env)->eabi) {\n\n                if (!lock_user_struct(VERIFY_READ, target_efl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_efl->l_type);\n\n                fl.l_whence = tswap16(target_efl->l_whence);\n\n                fl.l_start = tswap64(target_efl->l_start);\n\n                fl.l_len = tswap64(target_efl->l_len);\n\n                fl.l_pid = tswap32(target_efl->l_pid);\n\n                unlock_user_struct(target_efl, arg3, 0);\n\n            } else\n\n#endif\n\n            {\n\n                if (!lock_user_struct(VERIFY_READ, target_fl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_fl->l_type);\n\n                fl.l_whence = tswap16(target_fl->l_whence);\n\n                fl.l_start = tswap64(target_fl->l_start);\n\n                fl.l_len = tswap64(target_fl->l_len);\n\n                fl.l_pid = tswap32(target_fl->l_pid);\n\n                unlock_user_struct(target_fl, arg3, 0);\n\n            }\n\n            ret = get_errno(fcntl(arg1, cmd, &fl));\n\n\t    if (ret == 0) {\n\n#ifdef TARGET_ARM\n\n                if (((CPUARMState *)cpu_env)->eabi) {\n\n                    if (!lock_user_struct(VERIFY_WRITE, target_efl, arg3, 0)) \n\n                        goto efault;\n\n                    target_efl->l_type = tswap16(fl.l_type);\n\n                    target_efl->l_whence = tswap16(fl.l_whence);\n\n                    target_efl->l_start = tswap64(fl.l_start);\n\n                    target_efl->l_len = tswap64(fl.l_len);\n\n                    target_efl->l_pid = tswap32(fl.l_pid);\n\n                    unlock_user_struct(target_efl, arg3, 1);\n\n                } else\n\n#endif\n\n                {\n\n                    if (!lock_user_struct(VERIFY_WRITE, target_fl, arg3, 0)) \n\n                        goto efault;\n\n                    target_fl->l_type = tswap16(fl.l_type);\n\n                    target_fl->l_whence = tswap16(fl.l_whence);\n\n                    target_fl->l_start = tswap64(fl.l_start);\n\n                    target_fl->l_len = tswap64(fl.l_len);\n\n                    target_fl->l_pid = tswap32(fl.l_pid);\n\n                    unlock_user_struct(target_fl, arg3, 1);\n\n                }\n\n\t    }\n\n\t    break;\n\n\n\n        case TARGET_F_SETLK64:\n\n        case TARGET_F_SETLKW64:\n\n#ifdef TARGET_ARM\n\n            if (((CPUARMState *)cpu_env)->eabi) {\n\n                if (!lock_user_struct(VERIFY_READ, target_efl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_efl->l_type);\n\n                fl.l_whence = tswap16(target_efl->l_whence);\n\n                fl.l_start = tswap64(target_efl->l_start);\n\n                fl.l_len = tswap64(target_efl->l_len);\n\n                fl.l_pid = tswap32(target_efl->l_pid);\n\n                unlock_user_struct(target_efl, arg3, 0);\n\n            } else\n\n#endif\n\n            {\n\n                if (!lock_user_struct(VERIFY_READ, target_fl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_fl->l_type);\n\n                fl.l_whence = tswap16(target_fl->l_whence);\n\n                fl.l_start = tswap64(target_fl->l_start);\n\n                fl.l_len = tswap64(target_fl->l_len);\n\n                fl.l_pid = tswap32(target_fl->l_pid);\n\n                unlock_user_struct(target_fl, arg3, 0);\n\n            }\n\n            ret = get_errno(fcntl(arg1, cmd, &fl));\n\n\t    break;\n\n        default:\n\n            ret = do_fcntl(arg1, arg2, arg3);\n\n            break;\n\n        }\n\n\tbreak;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_cacheflush\n\n    case TARGET_NR_cacheflush:\n\n        /* self-modifying code is handled automatically, so nothing needed */\n\n        ret = 0;\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_security\n\n    case TARGET_NR_security:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_getpagesize\n\n    case TARGET_NR_getpagesize:\n\n        ret = TARGET_PAGE_SIZE;\n\n        break;\n\n#endif\n\n    case TARGET_NR_gettid:\n\n        ret = get_errno(gettid());\n\n        break;\n\n#ifdef TARGET_NR_readahead\n\n    case TARGET_NR_readahead:\n\n#if TARGET_ABI_BITS == 32\n\n        if (regpairs_aligned(cpu_env)) {\n\n            arg2 = arg3;\n\n            arg3 = arg4;\n\n            arg4 = arg5;\n\n        }\n\n        ret = get_errno(readahead(arg1, ((off64_t)arg3 << 32) | arg2, arg4));\n\n#else\n\n        ret = get_errno(readahead(arg1, arg2, arg3));\n\n#endif\n\n        break;\n\n#endif\n\n#ifdef CONFIG_ATTR\n\n#ifdef TARGET_NR_setxattr\n\n    case TARGET_NR_listxattr:\n\n    case TARGET_NR_llistxattr:\n\n    {\n\n        void *p, *b = 0;\n\n        if (arg2) {\n\n            b = lock_user(VERIFY_WRITE, arg2, arg3, 0);\n\n            if (!b) {\n\n                ret = -TARGET_EFAULT;\n\n                break;\n\n            }\n\n        }\n\n        p = lock_user_string(arg1);\n\n        if (p) {\n\n            if (num == TARGET_NR_listxattr) {\n\n                ret = get_errno(listxattr(p, b, arg3));\n\n            } else {\n\n                ret = get_errno(llistxattr(p, b, arg3));\n\n            }\n\n        } else {\n\n            ret = -TARGET_EFAULT;\n\n        }\n\n        unlock_user(p, arg1, 0);\n\n        unlock_user(b, arg2, arg3);\n\n        break;\n\n    }\n\n    case TARGET_NR_flistxattr:\n\n    {\n\n        void *b = 0;\n\n        if (arg2) {\n\n            b = lock_user(VERIFY_WRITE, arg2, arg3, 0);\n\n            if (!b) {\n\n                ret = -TARGET_EFAULT;\n\n                break;\n\n            }\n\n        }\n\n        ret = get_errno(flistxattr(arg1, b, arg3));\n\n        unlock_user(b, arg2, arg3);\n\n        break;\n\n    }\n\n    case TARGET_NR_setxattr:\n\n    case TARGET_NR_lsetxattr:\n\n        {\n\n            void *p, *n, *v = 0;\n\n            if (arg3) {\n\n                v = lock_user(VERIFY_READ, arg3, arg4, 1);\n\n                if (!v) {\n\n                    ret = -TARGET_EFAULT;\n\n                    break;\n\n                }\n\n            }\n\n            p = lock_user_string(arg1);\n\n            n = lock_user_string(arg2);\n\n            if (p && n) {\n\n                if (num == TARGET_NR_setxattr) {\n\n                    ret = get_errno(setxattr(p, n, v, arg4, arg5));\n\n                } else {\n\n                    ret = get_errno(lsetxattr(p, n, v, arg4, arg5));\n\n                }\n\n            } else {\n\n                ret = -TARGET_EFAULT;\n\n            }\n\n            unlock_user(p, arg1, 0);\n\n            unlock_user(n, arg2, 0);\n\n            unlock_user(v, arg3, 0);\n\n        }\n\n        break;\n\n    case TARGET_NR_fsetxattr:\n\n        {\n\n            void *n, *v = 0;\n\n            if (arg3) {\n\n                v = lock_user(VERIFY_READ, arg3, arg4, 1);\n\n                if (!v) {\n\n                    ret = -TARGET_EFAULT;\n\n                    break;\n\n                }\n\n            }\n\n            n = lock_user_string(arg2);\n\n            if (n) {\n\n                ret = get_errno(fsetxattr(arg1, n, v, arg4, arg5));\n\n            } else {\n\n                ret = -TARGET_EFAULT;\n\n            }\n\n            unlock_user(n, arg2, 0);\n\n            unlock_user(v, arg3, 0);\n\n        }\n\n        break;\n\n    case TARGET_NR_getxattr:\n\n    case TARGET_NR_lgetxattr:\n\n        {\n\n            void *p, *n, *v = 0;\n\n            if (arg3) {\n\n                v = lock_user(VERIFY_WRITE, arg3, arg4, 0);\n\n                if (!v) {\n\n                    ret = -TARGET_EFAULT;\n\n                    break;\n\n                }\n\n            }\n\n            p = lock_user_string(arg1);\n\n            n = lock_user_string(arg2);\n\n            if (p && n) {\n\n                if (num == TARGET_NR_getxattr) {\n\n                    ret = get_errno(getxattr(p, n, v, arg4));\n\n                } else {\n\n                    ret = get_errno(lgetxattr(p, n, v, arg4));\n\n                }\n\n            } else {\n\n                ret = -TARGET_EFAULT;\n\n            }\n\n            unlock_user(p, arg1, 0);\n\n            unlock_user(n, arg2, 0);\n\n            unlock_user(v, arg3, arg4);\n\n        }\n\n        break;\n\n    case TARGET_NR_fgetxattr:\n\n        {\n\n            void *n, *v = 0;\n\n            if (arg3) {\n\n                v = lock_user(VERIFY_WRITE, arg3, arg4, 0);\n\n                if (!v) {\n\n                    ret = -TARGET_EFAULT;\n\n                    break;\n\n                }\n\n            }\n\n            n = lock_user_string(arg2);\n\n            if (n) {\n\n                ret = get_errno(fgetxattr(arg1, n, v, arg4));\n\n            } else {\n\n                ret = -TARGET_EFAULT;\n\n            }\n\n            unlock_user(n, arg2, 0);\n\n            unlock_user(v, arg3, arg4);\n\n        }\n\n        break;\n\n    case TARGET_NR_removexattr:\n\n    case TARGET_NR_lremovexattr:\n\n        {\n\n            void *p, *n;\n\n            p = lock_user_string(arg1);\n\n            n = lock_user_string(arg2);\n\n            if (p && n) {\n\n                if (num == TARGET_NR_removexattr) {\n\n                    ret = get_errno(removexattr(p, n));\n\n                } else {\n\n                    ret = get_errno(lremovexattr(p, n));\n\n                }\n\n            } else {\n\n                ret = -TARGET_EFAULT;\n\n            }\n\n            unlock_user(p, arg1, 0);\n\n            unlock_user(n, arg2, 0);\n\n        }\n\n        break;\n\n    case TARGET_NR_fremovexattr:\n\n        {\n\n            void *n;\n\n            n = lock_user_string(arg2);\n\n            if (n) {\n\n                ret = get_errno(fremovexattr(arg1, n));\n\n            } else {\n\n                ret = -TARGET_EFAULT;\n\n            }\n\n            unlock_user(n, arg2, 0);\n\n        }\n\n        break;\n\n#endif\n\n#endif /* CONFIG_ATTR */\n\n#ifdef TARGET_NR_set_thread_area\n\n    case TARGET_NR_set_thread_area:\n\n#if defined(TARGET_MIPS)\n\n      ((CPUMIPSState *) cpu_env)->tls_value = arg1;\n\n      ret = 0;\n\n      break;\n\n#elif defined(TARGET_CRIS)\n\n      if (arg1 & 0xff)\n\n          ret = -TARGET_EINVAL;\n\n      else {\n\n          ((CPUCRISState *) cpu_env)->pregs[PR_PID] = arg1;\n\n          ret = 0;\n\n      }\n\n      break;\n\n#elif defined(TARGET_I386) && defined(TARGET_ABI32)\n\n      ret = do_set_thread_area(cpu_env, arg1);\n\n      break;\n\n#else\n\n      goto unimplemented_nowarn;\n\n#endif\n\n#endif\n\n#ifdef TARGET_NR_get_thread_area\n\n    case TARGET_NR_get_thread_area:\n\n#if defined(TARGET_I386) && defined(TARGET_ABI32)\n\n        ret = do_get_thread_area(cpu_env, arg1);\n\n#else\n\n        goto unimplemented_nowarn;\n\n#endif\n\n#endif\n\n#ifdef TARGET_NR_getdomainname\n\n    case TARGET_NR_getdomainname:\n\n        goto unimplemented_nowarn;\n\n#endif\n\n\n\n#ifdef TARGET_NR_clock_gettime\n\n    case TARGET_NR_clock_gettime:\n\n    {\n\n        struct timespec ts;\n\n        ret = get_errno(clock_gettime(arg1, &ts));\n\n        if (!is_error(ret)) {\n\n            host_to_target_timespec(arg2, &ts);\n\n        }\n\n        break;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_clock_getres\n\n    case TARGET_NR_clock_getres:\n\n    {\n\n        struct timespec ts;\n\n        ret = get_errno(clock_getres(arg1, &ts));\n\n        if (!is_error(ret)) {\n\n            host_to_target_timespec(arg2, &ts);\n\n        }\n\n        break;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_clock_nanosleep\n\n    case TARGET_NR_clock_nanosleep:\n\n    {\n\n        struct timespec ts;\n\n        target_to_host_timespec(&ts, arg3);\n\n        ret = get_errno(clock_nanosleep(arg1, arg2, &ts, arg4 ? &ts : NULL));\n\n        if (arg4)\n\n            host_to_target_timespec(arg4, &ts);\n\n        break;\n\n    }\n\n#endif\n\n\n\n#if defined(TARGET_NR_set_tid_address) && defined(__NR_set_tid_address)\n\n    case TARGET_NR_set_tid_address:\n\n        ret = get_errno(set_tid_address((int *)g2h(arg1)));\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_tkill) && defined(__NR_tkill)\n\n    case TARGET_NR_tkill:\n\n        ret = get_errno(sys_tkill((int)arg1, target_to_host_signal(arg2)));\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_tgkill) && defined(__NR_tgkill)\n\n    case TARGET_NR_tgkill:\n\n\tret = get_errno(sys_tgkill((int)arg1, (int)arg2,\n\n                        target_to_host_signal(arg3)));\n\n\tbreak;\n\n#endif\n\n\n\n#ifdef TARGET_NR_set_robust_list\n\n    case TARGET_NR_set_robust_list:\n\n\tgoto unimplemented_nowarn;\n\n#endif\n\n\n\n#if defined(TARGET_NR_utimensat) && defined(__NR_utimensat)\n\n    case TARGET_NR_utimensat:\n\n        {\n\n            struct timespec *tsp, ts[2];\n\n            if (!arg3) {\n\n                tsp = NULL;\n\n            } else {\n\n                target_to_host_timespec(ts, arg3);\n\n                target_to_host_timespec(ts+1, arg3+sizeof(struct target_timespec));\n\n                tsp = ts;\n\n            }\n\n            if (!arg2)\n\n                ret = get_errno(sys_utimensat(arg1, NULL, tsp, arg4));\n\n            else {\n\n                if (!(p = lock_user_string(arg2))) {\n\n                    ret = -TARGET_EFAULT;\n\n                    goto fail;\n\n                }\n\n                ret = get_errno(sys_utimensat(arg1, path(p), tsp, arg4));\n\n                unlock_user(p, arg2, 0);\n\n            }\n\n        }\n\n\tbreak;\n\n#endif\n\n#if defined(CONFIG_USE_NPTL)\n\n    case TARGET_NR_futex:\n\n        ret = do_futex(arg1, arg2, arg3, arg4, arg5, arg6);\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)\n\n    case TARGET_NR_inotify_init:\n\n        ret = get_errno(sys_inotify_init());\n\n        break;\n\n#endif\n\n#ifdef CONFIG_INOTIFY1\n\n#if defined(TARGET_NR_inotify_init1) && defined(__NR_inotify_init1)\n\n    case TARGET_NR_inotify_init1:\n\n        ret = get_errno(sys_inotify_init1(arg1));\n\n        break;\n\n#endif\n\n#endif\n\n#if defined(TARGET_NR_inotify_add_watch) && defined(__NR_inotify_add_watch)\n\n    case TARGET_NR_inotify_add_watch:\n\n        p = lock_user_string(arg2);\n\n        ret = get_errno(sys_inotify_add_watch(arg1, path(p), arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_inotify_rm_watch) && defined(__NR_inotify_rm_watch)\n\n    case TARGET_NR_inotify_rm_watch:\n\n        ret = get_errno(sys_inotify_rm_watch(arg1, arg2));\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_mq_open) && defined(__NR_mq_open)\n\n    case TARGET_NR_mq_open:\n\n        {\n\n            struct mq_attr posix_mq_attr;\n\n\n\n            p = lock_user_string(arg1 - 1);\n\n            if (arg4 != 0)\n\n                copy_from_user_mq_attr (&posix_mq_attr, arg4);\n\n            ret = get_errno(mq_open(p, arg2, arg3, &posix_mq_attr));\n\n            unlock_user (p, arg1, 0);\n\n        }\n\n        break;\n\n\n\n    case TARGET_NR_mq_unlink:\n\n        p = lock_user_string(arg1 - 1);\n\n        ret = get_errno(mq_unlink(p));\n\n        unlock_user (p, arg1, 0);\n\n        break;\n\n\n\n    case TARGET_NR_mq_timedsend:\n\n        {\n\n            struct timespec ts;\n\n\n\n            p = lock_user (VERIFY_READ, arg2, arg3, 1);\n\n            if (arg5 != 0) {\n\n                target_to_host_timespec(&ts, arg5);\n\n                ret = get_errno(mq_timedsend(arg1, p, arg3, arg4, &ts));\n\n                host_to_target_timespec(arg5, &ts);\n\n            }\n\n            else\n\n                ret = get_errno(mq_send(arg1, p, arg3, arg4));\n\n            unlock_user (p, arg2, arg3);\n\n        }\n\n        break;\n\n\n\n    case TARGET_NR_mq_timedreceive:\n\n        {\n\n            struct timespec ts;\n\n            unsigned int prio;\n\n\n\n            p = lock_user (VERIFY_READ, arg2, arg3, 1);\n\n            if (arg5 != 0) {\n\n                target_to_host_timespec(&ts, arg5);\n\n                ret = get_errno(mq_timedreceive(arg1, p, arg3, &prio, &ts));\n\n                host_to_target_timespec(arg5, &ts);\n\n            }\n\n            else\n\n                ret = get_errno(mq_receive(arg1, p, arg3, &prio));\n\n            unlock_user (p, arg2, arg3);\n\n            if (arg4 != 0)\n\n                put_user_u32(prio, arg4);\n\n        }\n\n        break;\n\n\n\n    /* Not implemented for now... */\n\n/*     case TARGET_NR_mq_notify: */\n\n/*         break; */\n\n\n\n    case TARGET_NR_mq_getsetattr:\n\n        {\n\n            struct mq_attr posix_mq_attr_in, posix_mq_attr_out;\n\n            ret = 0;\n\n            if (arg3 != 0) {\n\n                ret = mq_getattr(arg1, &posix_mq_attr_out);\n\n                copy_to_user_mq_attr(arg3, &posix_mq_attr_out);\n\n            }\n\n            if (arg2 != 0) {\n\n                copy_from_user_mq_attr(&posix_mq_attr_in, arg2);\n\n                ret |= mq_setattr(arg1, &posix_mq_attr_in, &posix_mq_attr_out);\n\n            }\n\n\n\n        }\n\n        break;\n\n#endif\n\n\n\n#ifdef CONFIG_SPLICE\n\n#ifdef TARGET_NR_tee\n\n    case TARGET_NR_tee:\n\n        {\n\n            ret = get_errno(tee(arg1,arg2,arg3,arg4));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_splice\n\n    case TARGET_NR_splice:\n\n        {\n\n            loff_t loff_in, loff_out;\n\n            loff_t *ploff_in = NULL, *ploff_out = NULL;\n\n            if(arg2) {\n\n                get_user_u64(loff_in, arg2);\n\n                ploff_in = &loff_in;\n\n            }\n\n            if(arg4) {\n\n                get_user_u64(loff_out, arg2);\n\n                ploff_out = &loff_out;\n\n            }\n\n            ret = get_errno(splice(arg1, ploff_in, arg3, ploff_out, arg5, arg6));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_vmsplice\n\n\tcase TARGET_NR_vmsplice:\n\n        {\n\n            int count = arg3;\n\n            struct iovec *vec;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            if (lock_iovec(VERIFY_READ, vec, arg2, count, 1) < 0)\n\n                goto efault;\n\n            ret = get_errno(vmsplice(arg1, vec, count, arg4));\n\n            unlock_iovec(vec, arg2, count, 0);\n\n        }\n\n        break;\n\n#endif\n\n#endif /* CONFIG_SPLICE */\n\n#ifdef CONFIG_EVENTFD\n\n#if defined(TARGET_NR_eventfd)\n\n    case TARGET_NR_eventfd:\n\n        ret = get_errno(eventfd(arg1, 0));\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_eventfd2)\n\n    case TARGET_NR_eventfd2:\n\n        ret = get_errno(eventfd(arg1, arg2));\n\n        break;\n\n#endif\n\n#endif /* CONFIG_EVENTFD  */\n\n#if defined(CONFIG_FALLOCATE) && defined(TARGET_NR_fallocate)\n\n    case TARGET_NR_fallocate:\n\n#if TARGET_ABI_BITS == 32\n\n        ret = get_errno(fallocate(arg1, arg2, target_offset64(arg3, arg4),\n\n                                  target_offset64(arg5, arg6)));\n\n#else\n\n        ret = get_errno(fallocate(arg1, arg2, arg3, arg4));\n\n#endif\n\n        break;\n\n#endif\n\n#if defined(CONFIG_SYNC_FILE_RANGE)\n\n#if defined(TARGET_NR_sync_file_range)\n\n    case TARGET_NR_sync_file_range:\n\n#if TARGET_ABI_BITS == 32\n\n#if defined(TARGET_MIPS)\n\n        ret = get_errno(sync_file_range(arg1, target_offset64(arg3, arg4),\n\n                                        target_offset64(arg5, arg6), arg7));\n\n#else\n\n        ret = get_errno(sync_file_range(arg1, target_offset64(arg2, arg3),\n\n                                        target_offset64(arg4, arg5), arg6));\n\n#endif /* !TARGET_MIPS */\n\n#else\n\n        ret = get_errno(sync_file_range(arg1, arg2, arg3, arg4));\n\n#endif\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_sync_file_range2)\n\n    case TARGET_NR_sync_file_range2:\n\n        /* This is like sync_file_range but the arguments are reordered */\n\n#if TARGET_ABI_BITS == 32\n\n        ret = get_errno(sync_file_range(arg1, target_offset64(arg3, arg4),\n\n                                        target_offset64(arg5, arg6), arg2));\n\n#else\n\n        ret = get_errno(sync_file_range(arg1, arg3, arg4, arg2));\n\n#endif\n\n        break;\n\n#endif\n\n#endif\n\n#if defined(CONFIG_EPOLL)\n\n#if defined(TARGET_NR_epoll_create)\n\n    case TARGET_NR_epoll_create:\n\n        ret = get_errno(epoll_create(arg1));\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_epoll_create1) && defined(CONFIG_EPOLL_CREATE1)\n\n    case TARGET_NR_epoll_create1:\n\n        ret = get_errno(epoll_create1(arg1));\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_epoll_ctl)\n\n    case TARGET_NR_epoll_ctl:\n\n    {\n\n        struct epoll_event ep;\n\n        struct epoll_event *epp = 0;\n\n        if (arg4) {\n\n            struct target_epoll_event *target_ep;\n\n            if (!lock_user_struct(VERIFY_READ, target_ep, arg4, 1)) {\n\n                goto efault;\n\n            }\n\n            ep.events = tswap32(target_ep->events);\n\n            /* The epoll_data_t union is just opaque data to the kernel,\n\n             * so we transfer all 64 bits across and need not worry what\n\n             * actual data type it is.\n\n             */\n\n            ep.data.u64 = tswap64(target_ep->data.u64);\n\n            unlock_user_struct(target_ep, arg4, 0);\n\n            epp = &ep;\n\n        }\n\n        ret = get_errno(epoll_ctl(arg1, arg2, arg3, epp));\n\n        break;\n\n    }\n\n#endif\n\n\n\n#if defined(TARGET_NR_epoll_pwait) && defined(CONFIG_EPOLL_PWAIT)\n\n#define IMPLEMENT_EPOLL_PWAIT\n\n#endif\n\n#if defined(TARGET_NR_epoll_wait) || defined(IMPLEMENT_EPOLL_PWAIT)\n\n#if defined(TARGET_NR_epoll_wait)\n\n    case TARGET_NR_epoll_wait:\n\n#endif\n\n#if defined(IMPLEMENT_EPOLL_PWAIT)\n\n    case TARGET_NR_epoll_pwait:\n\n#endif\n\n    {\n\n        struct target_epoll_event *target_ep;\n\n        struct epoll_event *ep;\n\n        int epfd = arg1;\n\n        int maxevents = arg3;\n\n        int timeout = arg4;\n\n\n\n        target_ep = lock_user(VERIFY_WRITE, arg2,\n\n                              maxevents * sizeof(struct target_epoll_event), 1);\n\n        if (!target_ep) {\n\n            goto efault;\n\n        }\n\n\n\n        ep = alloca(maxevents * sizeof(struct epoll_event));\n\n\n\n        switch (num) {\n\n#if defined(IMPLEMENT_EPOLL_PWAIT)\n\n        case TARGET_NR_epoll_pwait:\n\n        {\n\n            target_sigset_t *target_set;\n\n            sigset_t _set, *set = &_set;\n\n\n\n            if (arg5) {\n\n                target_set = lock_user(VERIFY_READ, arg5,\n\n                                       sizeof(target_sigset_t), 1);\n\n                if (!target_set) {\n\n                    unlock_user(target_ep, arg2, 0);\n\n                    goto efault;\n\n                }\n\n                target_to_host_sigset(set, target_set);\n\n                unlock_user(target_set, arg5, 0);\n\n            } else {\n\n                set = NULL;\n\n            }\n\n\n\n            ret = get_errno(epoll_pwait(epfd, ep, maxevents, timeout, set));\n\n            break;\n\n        }\n\n#endif\n\n#if defined(TARGET_NR_epoll_wait)\n\n        case TARGET_NR_epoll_wait:\n\n            ret = get_errno(epoll_wait(epfd, ep, maxevents, timeout));\n\n            break;\n\n#endif\n\n        default:\n\n            ret = -TARGET_ENOSYS;\n\n        }\n\n        if (!is_error(ret)) {\n\n            int i;\n\n            for (i = 0; i < ret; i++) {\n\n                target_ep[i].events = tswap32(ep[i].events);\n\n                target_ep[i].data.u64 = tswap64(ep[i].data.u64);\n\n            }\n\n        }\n\n        unlock_user(target_ep, arg2, ret * sizeof(struct target_epoll_event));\n\n        break;\n\n    }\n\n#endif\n\n#endif\n\n#ifdef TARGET_NR_prlimit64\n\n    case TARGET_NR_prlimit64:\n\n    {\n\n        /* args: pid, resource number, ptr to new rlimit, ptr to old rlimit */\n\n        struct target_rlimit64 *target_rnew, *target_rold;\n\n        struct host_rlimit64 rnew, rold, *rnewp = 0;\n\n        if (arg3) {\n\n            if (!lock_user_struct(VERIFY_READ, target_rnew, arg3, 1)) {\n\n                goto efault;\n\n            }\n\n            rnew.rlim_cur = tswap64(target_rnew->rlim_cur);\n\n            rnew.rlim_max = tswap64(target_rnew->rlim_max);\n\n            unlock_user_struct(target_rnew, arg3, 0);\n\n            rnewp = &rnew;\n\n        }\n\n\n\n        ret = get_errno(sys_prlimit64(arg1, arg2, rnewp, arg4 ? &rold : 0));\n\n        if (!is_error(ret) && arg4) {\n\n            if (!lock_user_struct(VERIFY_WRITE, target_rold, arg4, 1)) {\n\n                goto efault;\n\n            }\n\n            target_rold->rlim_cur = tswap64(rold.rlim_cur);\n\n            target_rold->rlim_max = tswap64(rold.rlim_max);\n\n            unlock_user_struct(target_rold, arg4, 1);\n\n        }\n\n        break;\n\n    }\n\n#endif\n\n    default:\n\n    unimplemented:\n\n        gemu_log(\"qemu: Unsupported syscall: %d\\n\", num);\n\n#if defined(TARGET_NR_setxattr) || defined(TARGET_NR_get_thread_area) || defined(TARGET_NR_getdomainname) || defined(TARGET_NR_set_robust_list)\n\n    unimplemented_nowarn:\n\n#endif\n\n        ret = -TARGET_ENOSYS;\n\n        break;\n\n    }\n\nfail:\n\n#ifdef DEBUG\n\n    gemu_log(\" = \" TARGET_ABI_FMT_ld \"\\n\", ret);\n\n#endif\n\n    if(do_strace)\n\n        print_syscall_ret(num, ret);\n\n    return ret;\n\nefault:\n\n    ret = -TARGET_EFAULT;\n\n    goto fail;\n\n}\n", "idx": 22174}
{"project": "qemu", "commit_id": "67a0fd2a9bca204d2b39f910a97c7137636a0715", "target": 0, "func": "static int64_t coroutine_fn vmdk_co_get_block_status(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, int *pnum)\n\n{\n\n    BDRVVmdkState *s = bs->opaque;\n\n    int64_t index_in_cluster, n, ret;\n\n    uint64_t offset;\n\n    VmdkExtent *extent;\n\n\n\n    extent = find_extent(s, sector_num, NULL);\n\n    if (!extent) {\n\n        return 0;\n\n    }\n\n    qemu_co_mutex_lock(&s->lock);\n\n    ret = get_cluster_offset(bs, extent, NULL,\n\n                             sector_num * 512, false, &offset,\n\n                             0, 0);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    switch (ret) {\n\n    case VMDK_ERROR:\n\n        ret = -EIO;\n\n        break;\n\n    case VMDK_UNALLOC:\n\n        ret = 0;\n\n        break;\n\n    case VMDK_ZEROED:\n\n        ret = BDRV_BLOCK_ZERO;\n\n        break;\n\n    case VMDK_OK:\n\n        ret = BDRV_BLOCK_DATA;\n\n        if (extent->file == bs->file && !extent->compressed) {\n\n            ret |= BDRV_BLOCK_OFFSET_VALID | offset;\n\n        }\n\n\n\n        break;\n\n    }\n\n\n\n    index_in_cluster = vmdk_find_index_in_cluster(extent, sector_num);\n\n    n = extent->cluster_sectors - index_in_cluster;\n\n    if (n > nb_sectors) {\n\n        n = nb_sectors;\n\n    }\n\n    *pnum = n;\n\n    return ret;\n\n}\n", "idx": 22175}
{"project": "qemu", "commit_id": "698feb5e13a2d763369909ce33f2bd7a7c1c11c0", "target": 0, "func": "static void vfio_listener_region_add(MemoryListener *listener,\n\n                                     MemoryRegionSection *section)\n\n{\n\n    VFIOContainer *container = container_of(listener, VFIOContainer, listener);\n\n    hwaddr iova, end;\n\n    Int128 llend, llsize;\n\n    void *vaddr;\n\n    int ret;\n\n    VFIOHostDMAWindow *hostwin;\n\n    bool hostwin_found;\n\n\n\n    if (vfio_listener_skipped_section(section)) {\n\n        trace_vfio_listener_region_add_skip(\n\n                section->offset_within_address_space,\n\n                section->offset_within_address_space +\n\n                int128_get64(int128_sub(section->size, int128_one())));\n\n        return;\n\n    }\n\n\n\n    if (unlikely((section->offset_within_address_space & ~TARGET_PAGE_MASK) !=\n\n                 (section->offset_within_region & ~TARGET_PAGE_MASK))) {\n\n        error_report(\"%s received unaligned region\", __func__);\n\n        return;\n\n    }\n\n\n\n    iova = TARGET_PAGE_ALIGN(section->offset_within_address_space);\n\n    llend = int128_make64(section->offset_within_address_space);\n\n    llend = int128_add(llend, section->size);\n\n    llend = int128_and(llend, int128_exts64(TARGET_PAGE_MASK));\n\n\n\n    if (int128_ge(int128_make64(iova), llend)) {\n\n        return;\n\n    }\n\n    end = int128_get64(int128_sub(llend, int128_one()));\n\n\n\n    if (container->iommu_type == VFIO_SPAPR_TCE_v2_IOMMU) {\n\n        VFIOHostDMAWindow *hostwin;\n\n        hwaddr pgsize = 0;\n\n\n\n        /* For now intersections are not allowed, we may relax this later */\n\n        QLIST_FOREACH(hostwin, &container->hostwin_list, hostwin_next) {\n\n            if (ranges_overlap(hostwin->min_iova,\n\n                               hostwin->max_iova - hostwin->min_iova + 1,\n\n                               section->offset_within_address_space,\n\n                               int128_get64(section->size))) {\n\n                ret = -1;\n\n                goto fail;\n\n            }\n\n        }\n\n\n\n        ret = vfio_spapr_create_window(container, section, &pgsize);\n\n        if (ret) {\n\n            goto fail;\n\n        }\n\n\n\n        vfio_host_win_add(container, section->offset_within_address_space,\n\n                          section->offset_within_address_space +\n\n                          int128_get64(section->size) - 1, pgsize);\n\n    }\n\n\n\n    hostwin_found = false;\n\n    QLIST_FOREACH(hostwin, &container->hostwin_list, hostwin_next) {\n\n        if (hostwin->min_iova <= iova && end <= hostwin->max_iova) {\n\n            hostwin_found = true;\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (!hostwin_found) {\n\n        error_report(\"vfio: IOMMU container %p can't map guest IOVA region\"\n\n                     \" 0x%\"HWADDR_PRIx\"..0x%\"HWADDR_PRIx,\n\n                     container, iova, end);\n\n        ret = -EFAULT;\n\n        goto fail;\n\n    }\n\n\n\n    memory_region_ref(section->mr);\n\n\n\n    if (memory_region_is_iommu(section->mr)) {\n\n        VFIOGuestIOMMU *giommu;\n\n\n\n        trace_vfio_listener_region_add_iommu(iova, end);\n\n        /*\n\n         * FIXME: For VFIO iommu types which have KVM acceleration to\n\n         * avoid bouncing all map/unmaps through qemu this way, this\n\n         * would be the right place to wire that up (tell the KVM\n\n         * device emulation the VFIO iommu handles to use).\n\n         */\n\n        giommu = g_malloc0(sizeof(*giommu));\n\n        giommu->iommu = section->mr;\n\n        giommu->iommu_offset = section->offset_within_address_space -\n\n                               section->offset_within_region;\n\n        giommu->container = container;\n\n        giommu->n.notify = vfio_iommu_map_notify;\n\n        giommu->n.notifier_flags = IOMMU_NOTIFIER_ALL;\n\n        QLIST_INSERT_HEAD(&container->giommu_list, giommu, giommu_next);\n\n\n\n        memory_region_register_iommu_notifier(giommu->iommu, &giommu->n);\n\n        memory_region_iommu_replay(giommu->iommu, &giommu->n, false);\n\n\n\n        return;\n\n    }\n\n\n\n    /* Here we assume that memory_region_is_ram(section->mr)==true */\n\n\n\n    vaddr = memory_region_get_ram_ptr(section->mr) +\n\n            section->offset_within_region +\n\n            (iova - section->offset_within_address_space);\n\n\n\n    trace_vfio_listener_region_add_ram(iova, end, vaddr);\n\n\n\n    llsize = int128_sub(llend, int128_make64(iova));\n\n\n\n    ret = vfio_dma_map(container, iova, int128_get64(llsize),\n\n                       vaddr, section->readonly);\n\n    if (ret) {\n\n        error_report(\"vfio_dma_map(%p, 0x%\"HWADDR_PRIx\", \"\n\n                     \"0x%\"HWADDR_PRIx\", %p) = %d (%m)\",\n\n                     container, iova, int128_get64(llsize), vaddr, ret);\n\n        goto fail;\n\n    }\n\n\n\n    return;\n\n\n\nfail:\n\n    /*\n\n     * On the initfn path, store the first error in the container so we\n\n     * can gracefully fail.  Runtime, there's not much we can do other\n\n     * than throw a hardware error.\n\n     */\n\n    if (!container->initialized) {\n\n        if (!container->error) {\n\n            container->error = ret;\n\n        }\n\n    } else {\n\n        hw_error(\"vfio: DMA mapping failed, unable to continue\");\n\n    }\n\n}\n", "idx": 22176}
{"project": "qemu", "commit_id": "a5a08302d44a8b1a8c5819b1411002f85bb5f847", "target": 0, "func": "static void niagara_init(MachineState *machine)\n\n{\n\n    NiagaraBoardState *s = g_new(NiagaraBoardState, 1);\n\n    DriveInfo *dinfo = drive_get_next(IF_PFLASH);\n\n    MemoryRegion *sysmem = get_system_memory();\n\n\n\n    /* init CPUs */\n\n    sparc64_cpu_devinit(machine->cpu_model, \"Sun UltraSparc T1\",\n\n                        NIAGARA_PROM_BASE);\n\n    /* set up devices */\n\n    memory_region_allocate_system_memory(&s->hv_ram, NULL, \"sun4v-hv.ram\",\n\n                                         NIAGARA_HV_RAM_SIZE);\n\n    memory_region_add_subregion(sysmem, NIAGARA_HV_RAM_BASE, &s->hv_ram);\n\n\n\n    memory_region_allocate_system_memory(&s->partition_ram, NULL,\n\n                                         \"sun4v-partition.ram\",\n\n                                         machine->ram_size);\n\n    memory_region_add_subregion(sysmem, NIAGARA_PARTITION_RAM_BASE,\n\n                                &s->partition_ram);\n\n\n\n    memory_region_allocate_system_memory(&s->nvram, NULL,\n\n                                         \"sun4v.nvram\", NIAGARA_NVRAM_SIZE);\n\n    memory_region_add_subregion(sysmem, NIAGARA_NVRAM_BASE, &s->nvram);\n\n    memory_region_allocate_system_memory(&s->md_rom, NULL,\n\n                                         \"sun4v-md.rom\", NIAGARA_MD_ROM_SIZE);\n\n    memory_region_add_subregion(sysmem, NIAGARA_MD_ROM_BASE, &s->md_rom);\n\n    memory_region_allocate_system_memory(&s->hv_rom, NULL,\n\n                                         \"sun4v-hv.rom\", NIAGARA_HV_ROM_SIZE);\n\n    memory_region_add_subregion(sysmem, NIAGARA_HV_ROM_BASE, &s->hv_rom);\n\n    memory_region_allocate_system_memory(&s->prom, NULL,\n\n                                         \"sun4v.prom\", PROM_SIZE_MAX);\n\n    memory_region_add_subregion(sysmem, NIAGARA_PROM_BASE, &s->prom);\n\n\n\n    add_rom_or_fail(\"nvram1\", NIAGARA_NVRAM_BASE);\n\n    add_rom_or_fail(\"1up-md.bin\", NIAGARA_MD_ROM_BASE);\n\n    add_rom_or_fail(\"1up-hv.bin\", NIAGARA_HV_ROM_BASE);\n\n\n\n    add_rom_or_fail(\"reset.bin\", NIAGARA_PROM_BASE);\n\n    add_rom_or_fail(\"q.bin\", NIAGARA_PROM_BASE + NIAGARA_Q_OFFSET);\n\n    add_rom_or_fail(\"openboot.bin\", NIAGARA_PROM_BASE + NIAGARA_OBP_OFFSET);\n\n\n\n    /* the virtual ramdisk is kind of initrd, but it resides\n\n       outside of the partition RAM */\n\n    if (dinfo) {\n\n        BlockBackend *blk = blk_by_legacy_dinfo(dinfo);\n\n        int size = blk_getlength(blk);\n\n        if (size > 0) {\n\n            memory_region_allocate_system_memory(&s->vdisk_ram, NULL,\n\n                                                 \"sun4v_vdisk.ram\", size);\n\n            memory_region_add_subregion(get_system_memory(),\n\n                                        NIAGARA_VDISK_BASE, &s->vdisk_ram);\n\n            dinfo->is_default = 1;\n\n            rom_add_file_fixed(blk_bs(blk)->filename, NIAGARA_VDISK_BASE, -1);\n\n        } else {\n\n            fprintf(stderr, \"qemu: could not load ram disk '%s'\\n\",\n\n                    blk_bs(blk)->filename);\n\n            exit(1);\n\n        }\n\n    }\n\n    serial_mm_init(sysmem, NIAGARA_UART_BASE, 0, NULL, 115200,\n\n                   serial_hds[0], DEVICE_BIG_ENDIAN);\n\n\n\n    empty_slot_init(NIAGARA_IOBBASE, NIAGARA_IOBSIZE);\n\n    sun4v_rtc_init(NIAGARA_RTC_BASE);\n\n}\n", "idx": 22177}
{"project": "qemu", "commit_id": "be1fea9bc286f64c6c995bb0d7145a0b738aeddb", "target": 0, "func": "static int virtqueue_num_heads(VirtQueue *vq, unsigned int idx)\n\n{\n\n    uint16_t num_heads = vring_avail_idx(vq) - idx;\n\n\n\n    /* Check it isn't doing very strange things with descriptor numbers. */\n\n    if (num_heads > vq->vring.num) {\n\n        error_report(\"Guest moved used index from %u to %u\",\n\n                     idx, vring_avail_idx(vq));\n\n        exit(1);\n\n    }\n\n    /* On success, callers read a descriptor at vq->last_avail_idx.\n\n     * Make sure descriptor read does not bypass avail index read. */\n\n    if (num_heads) {\n\n        smp_rmb();\n\n    }\n\n\n\n    return num_heads;\n\n}\n", "idx": 22178}
{"project": "qemu", "commit_id": "45a50b1668822c23afc2a89f724654e176518bc4", "target": 0, "func": "static void load_linux(void *fw_cfg,\n\n                       target_phys_addr_t option_rom,\n\n                       const char *kernel_filename,\n\n\t\t       const char *initrd_filename,\n\n\t\t       const char *kernel_cmdline,\n\n               target_phys_addr_t max_ram_size)\n\n{\n\n    uint16_t protocol;\n\n    uint32_t gpr[8];\n\n    uint16_t seg[6];\n\n    uint16_t real_seg;\n\n    int setup_size, kernel_size, initrd_size = 0, cmdline_size;\n\n    uint32_t initrd_max;\n\n    uint8_t header[8192];\n\n    target_phys_addr_t real_addr, prot_addr, cmdline_addr, initrd_addr = 0;\n\n    FILE *f, *fi;\n\n    char *vmode;\n\n\n\n    /* Align to 16 bytes as a paranoia measure */\n\n    cmdline_size = (strlen(kernel_cmdline)+16) & ~15;\n\n\n\n    /* load the kernel header */\n\n    f = fopen(kernel_filename, \"rb\");\n\n    if (!f || !(kernel_size = get_file_size(f)) ||\n\n\tfread(header, 1, MIN(ARRAY_SIZE(header), kernel_size), f) !=\n\n\tMIN(ARRAY_SIZE(header), kernel_size)) {\n\n\tfprintf(stderr, \"qemu: could not load kernel '%s': %s\\n\",\n\n\t\tkernel_filename, strerror(errno));\n\n\texit(1);\n\n    }\n\n\n\n    /* kernel protocol version */\n\n#if 0\n\n    fprintf(stderr, \"header magic: %#x\\n\", ldl_p(header+0x202));\n\n#endif\n\n    if (ldl_p(header+0x202) == 0x53726448)\n\n\tprotocol = lduw_p(header+0x206);\n\n    else {\n\n\t/* This looks like a multiboot kernel. If it is, let's stop\n\n\t   treating it like a Linux kernel. */\n\n\tif (load_multiboot(fw_cfg, f, kernel_filename,\n\n                           initrd_filename, kernel_cmdline, header))\n\n            return;\n\n\tprotocol = 0;\n\n    }\n\n\n\n    if (protocol < 0x200 || !(header[0x211] & 0x01)) {\n\n\t/* Low kernel */\n\n\treal_addr    = 0x90000;\n\n\tcmdline_addr = 0x9a000 - cmdline_size;\n\n\tprot_addr    = 0x10000;\n\n    } else if (protocol < 0x202) {\n\n\t/* High but ancient kernel */\n\n\treal_addr    = 0x90000;\n\n\tcmdline_addr = 0x9a000 - cmdline_size;\n\n\tprot_addr    = 0x100000;\n\n    } else {\n\n\t/* High and recent kernel */\n\n\treal_addr    = 0x10000;\n\n\tcmdline_addr = 0x20000;\n\n\tprot_addr    = 0x100000;\n\n    }\n\n\n\n#if 0\n\n    fprintf(stderr,\n\n\t    \"qemu: real_addr     = 0x\" TARGET_FMT_plx \"\\n\"\n\n\t    \"qemu: cmdline_addr  = 0x\" TARGET_FMT_plx \"\\n\"\n\n\t    \"qemu: prot_addr     = 0x\" TARGET_FMT_plx \"\\n\",\n\n\t    real_addr,\n\n\t    cmdline_addr,\n\n\t    prot_addr);\n\n#endif\n\n\n\n    /* highest address for loading the initrd */\n\n    if (protocol >= 0x203)\n\n\tinitrd_max = ldl_p(header+0x22c);\n\n    else\n\n\tinitrd_max = 0x37ffffff;\n\n\n\n    if (initrd_max >= max_ram_size-ACPI_DATA_SIZE)\n\n    \tinitrd_max = max_ram_size-ACPI_DATA_SIZE-1;\n\n\n\n    /* kernel command line */\n\n    pstrcpy_targphys(cmdline_addr, 4096, kernel_cmdline);\n\n\n\n    if (protocol >= 0x202) {\n\n\tstl_p(header+0x228, cmdline_addr);\n\n    } else {\n\n\tstw_p(header+0x20, 0xA33F);\n\n\tstw_p(header+0x22, cmdline_addr-real_addr);\n\n    }\n\n\n\n    /* handle vga= parameter */\n\n    vmode = strstr(kernel_cmdline, \"vga=\");\n\n    if (vmode) {\n\n        unsigned int video_mode;\n\n        /* skip \"vga=\" */\n\n        vmode += 4;\n\n        if (!strncmp(vmode, \"normal\", 6)) {\n\n            video_mode = 0xffff;\n\n        } else if (!strncmp(vmode, \"ext\", 3)) {\n\n            video_mode = 0xfffe;\n\n        } else if (!strncmp(vmode, \"ask\", 3)) {\n\n            video_mode = 0xfffd;\n\n        } else {\n\n            video_mode = strtol(vmode, NULL, 0);\n\n        }\n\n        stw_p(header+0x1fa, video_mode);\n\n    }\n\n\n\n    /* loader type */\n\n    /* High nybble = B reserved for Qemu; low nybble is revision number.\n\n       If this code is substantially changed, you may want to consider\n\n       incrementing the revision. */\n\n    if (protocol >= 0x200)\n\n\theader[0x210] = 0xB0;\n\n\n\n    /* heap */\n\n    if (protocol >= 0x201) {\n\n\theader[0x211] |= 0x80;\t/* CAN_USE_HEAP */\n\n\tstw_p(header+0x224, cmdline_addr-real_addr-0x200);\n\n    }\n\n\n\n    /* load initrd */\n\n    if (initrd_filename) {\n\n\tif (protocol < 0x200) {\n\n\t    fprintf(stderr, \"qemu: linux kernel too old to load a ram disk\\n\");\n\n\t    exit(1);\n\n\t}\n\n\n\n\tfi = fopen(initrd_filename, \"rb\");\n\n\tif (!fi) {\n\n\t    fprintf(stderr, \"qemu: could not load initial ram disk '%s': %s\\n\",\n\n\t\t    initrd_filename, strerror(errno));\n\n\t    exit(1);\n\n\t}\n\n\n\n\tinitrd_size = get_file_size(fi);\n\n\tinitrd_addr = (initrd_max-initrd_size) & ~4095;\n\n\n\n\tif (!fread_targphys_ok(initrd_addr, initrd_size, fi)) {\n\n\t    fprintf(stderr, \"qemu: read error on initial ram disk '%s': %s\\n\",\n\n\t\t    initrd_filename, strerror(errno));\n\n\t    exit(1);\n\n\t}\n\n\tfclose(fi);\n\n\n\n\tstl_p(header+0x218, initrd_addr);\n\n\tstl_p(header+0x21c, initrd_size);\n\n    }\n\n\n\n    /* store the finalized header and load the rest of the kernel */\n\n    cpu_physical_memory_write(real_addr, header, ARRAY_SIZE(header));\n\n\n\n    setup_size = header[0x1f1];\n\n    if (setup_size == 0)\n\n\tsetup_size = 4;\n\n\n\n    setup_size = (setup_size+1)*512;\n\n    /* Size of protected-mode code */\n\n    kernel_size -= (setup_size > ARRAY_SIZE(header)) ? setup_size : ARRAY_SIZE(header);\n\n\n\n    /* In case we have read too much already, copy that over */\n\n    if (setup_size < ARRAY_SIZE(header)) {\n\n        cpu_physical_memory_write(prot_addr, header + setup_size, ARRAY_SIZE(header) - setup_size);\n\n        prot_addr += (ARRAY_SIZE(header) - setup_size);\n\n        setup_size = ARRAY_SIZE(header);\n\n    }\n\n\n\n    if (!fread_targphys_ok(real_addr + ARRAY_SIZE(header),\n\n                           setup_size - ARRAY_SIZE(header), f) ||\n\n\t!fread_targphys_ok(prot_addr, kernel_size, f)) {\n\n\tfprintf(stderr, \"qemu: read error on kernel '%s'\\n\",\n\n\t\tkernel_filename);\n\n\texit(1);\n\n    }\n\n    fclose(f);\n\n\n\n    /* generate bootsector to set up the initial register state */\n\n    real_seg = real_addr >> 4;\n\n    seg[0] = seg[2] = seg[3] = seg[4] = seg[4] = real_seg;\n\n    seg[1] = real_seg+0x20;\t/* CS */\n\n    memset(gpr, 0, sizeof gpr);\n\n    gpr[4] = cmdline_addr-real_addr-16;\t/* SP (-16 is paranoia) */\n\n\n\n    option_rom_setup_reset(real_addr, setup_size);\n\n    option_rom_setup_reset(prot_addr, kernel_size);\n\n    option_rom_setup_reset(cmdline_addr, cmdline_size);\n\n    if (initrd_filename)\n\n        option_rom_setup_reset(initrd_addr, initrd_size);\n\n\n\n    generate_bootsect(option_rom, gpr, seg, 0);\n\n}\n", "idx": 22179}
{"project": "qemu", "commit_id": "ddcd55316fb2851e144e719171621ad2816487dc", "target": 0, "func": "void qemu_boot_set(const char *boot_order, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n\n\n    if (!boot_set_handler) {\n\n        error_setg(errp, \"no function defined to set boot device list for\"\n\n                         \" this architecture\");\n\n        return;\n\n    }\n\n\n\n    validate_bootdevices(boot_order, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    if (boot_set_handler(boot_set_opaque, boot_order)) {\n\n        error_setg(errp, \"setting boot device list failed\");\n\n        return;\n\n    }\n\n}\n", "idx": 22180}
{"project": "qemu", "commit_id": "ac531cb6e542b1e61d668604adf9dc5306a948c0", "target": 0, "func": "START_TEST(qdict_get_test)\n\n{\n\n    QInt *qi;\n\n    QObject *obj;\n\n    const int value = -42;\n\n    const char *key = \"test\";\n\n\n\n    qdict_put(tests_dict, key, qint_from_int(value));\n\n\n\n    obj = qdict_get(tests_dict, key);\n\n    fail_unless(obj != NULL);\n\n\n\n    qi = qobject_to_qint(obj);\n\n    fail_unless(qint_get_int(qi) == value);\n\n}\n", "idx": 22181}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static int qio_dns_resolver_lookup_sync_nop(QIODNSResolver *resolver,\n\n                                            SocketAddressLegacy *addr,\n\n                                            size_t *naddrs,\n\n                                            SocketAddressLegacy ***addrs,\n\n                                            Error **errp)\n\n{\n\n    *naddrs = 1;\n\n    *addrs = g_new0(SocketAddressLegacy *, 1);\n\n    (*addrs)[0] = QAPI_CLONE(SocketAddressLegacy, addr);\n\n\n\n    return 0;\n\n}\n", "idx": 22183}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int drive_get_max_bus(BlockInterfaceType type)\n\n{\n\n    int max_bus;\n\n    DriveInfo *dinfo;\n\n\n\n    max_bus = -1;\n\n    TAILQ_FOREACH(dinfo, &drives, next) {\n\n        if(dinfo->type == type &&\n\n           dinfo->bus > max_bus)\n\n            max_bus = dinfo->bus;\n\n    }\n\n    return max_bus;\n\n}\n", "idx": 22184}
{"project": "qemu", "commit_id": "9359a58b122187964d7465d48165680eadbf69d3", "target": 0, "func": "static uint64_t ehci_opreg_read(void *ptr, hwaddr addr,\n\n                                unsigned size)\n\n{\n\n    EHCIState *s = ptr;\n\n    uint32_t val;\n\n\n\n    val = s->opreg[addr >> 2];\n\n    trace_usb_ehci_opreg_read(addr + s->opregbase, addr2str(addr), val);\n\n    return val;\n\n}\n", "idx": 22185}
{"project": "qemu", "commit_id": "4eb938102b3d533e142de23e255e46da1326fc5a", "target": 0, "func": "static void qemu_fflush(QEMUFile *f)\n\n{\n\n    int ret = 0;\n\n\n\n    if (!f->ops->put_buffer) {\n\n        return;\n\n    }\n\n    if (f->is_write && f->buf_index > 0) {\n\n        ret = f->ops->put_buffer(f->opaque, f->buf, f->buf_offset, f->buf_index);\n\n        if (ret >= 0) {\n\n            f->buf_offset += f->buf_index;\n\n        }\n\n        f->buf_index = 0;\n\n    }\n\n    if (ret < 0) {\n\n        qemu_file_set_error(f, ret);\n\n    }\n\n}\n", "idx": 22186}
{"project": "qemu", "commit_id": "c021f8e65f5009a5ab5711d9d5326fcab553ef1c", "target": 0, "func": "PCIBus *pci_find_bus(PCIBus *bus, int bus_num)\n\n{\n\n    PCIBus *sec;\n\n\n\n    if (!bus)\n\n        return NULL;\n\n\n\n    if (pci_bus_num(bus) == bus_num) {\n\n        return bus;\n\n    }\n\n\n\n    /* try child bus */\n\n    QLIST_FOREACH(sec, &bus->child, sibling) {\n\n\n\n        if (!bus->parent_dev /* pci host bridge */\n\n            || (pci_bus_num(sec) <= bus_num &&\n\n                bus->parent_dev->config[PCI_SUBORDINATE_BUS])) {\n\n            return pci_find_bus(sec, bus_num);\n\n        }\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 22187}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_mpui_write(void *opaque, target_phys_addr_t addr,\n\n                            uint64_t value, unsigned size)\n\n{\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *) opaque;\n\n\n\n    if (size != 4) {\n\n        return omap_badwidth_write32(opaque, addr, value);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x00:\t/* CTRL */\n\n        s->mpui_ctrl = value & 0x007fffff;\n\n        break;\n\n\n\n    case 0x04:\t/* DEBUG_ADDR */\n\n    case 0x08:\t/* DEBUG_DATA */\n\n    case 0x0c:\t/* DEBUG_FLAG */\n\n    case 0x10:\t/* STATUS */\n\n    /* Not in OMAP310 */\n\n    case 0x14:\t/* DSP_STATUS */\n\n        OMAP_RO_REG(addr);\n\n    case 0x18:\t/* DSP_BOOT_CONFIG */\n\n    case 0x1c:\t/* DSP_MPUI_CONFIG */\n\n        break;\n\n\n\n    default:\n\n        OMAP_BAD_REG(addr);\n\n    }\n\n}\n", "idx": 22188}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "ser_write(void *opaque, target_phys_addr_t addr,\n\n          uint64_t val64, unsigned int size)\n\n{\n\n    struct etrax_serial *s = opaque;\n\n    uint32_t value = val64;\n\n    unsigned char ch = val64;\n\n    D(CPUCRISState *env = s->env);\n\n\n\n    D(qemu_log(\"%s \" TARGET_FMT_plx \"=%x\\n\",  __func__, addr, value));\n\n    addr >>= 2;\n\n    switch (addr)\n\n    {\n\n        case RW_DOUT:\n\n            qemu_chr_fe_write(s->chr, &ch, 1);\n\n            s->regs[R_INTR] |= 3;\n\n            s->pending_tx = 1;\n\n            s->regs[addr] = value;\n\n            break;\n\n        case RW_ACK_INTR:\n\n            if (s->pending_tx) {\n\n                value &= ~1;\n\n                s->pending_tx = 0;\n\n                D(qemu_log(\"fixedup value=%x r_intr=%x\\n\",\n\n                           value, s->regs[R_INTR]));\n\n            }\n\n            s->regs[addr] = value;\n\n            s->regs[R_INTR] &= ~value;\n\n            D(printf(\"r_intr=%x\\n\", s->regs[R_INTR]));\n\n            break;\n\n        default:\n\n            s->regs[addr] = value;\n\n            break;\n\n    }\n\n    ser_update_irq(s);\n\n}\n", "idx": 22189}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void gic_dist_writeb(void *opaque, target_phys_addr_t offset,\n\n                            uint32_t value)\n\n{\n\n    GICState *s = (GICState *)opaque;\n\n    int irq;\n\n    int i;\n\n    int cpu;\n\n\n\n    cpu = gic_get_current_cpu(s);\n\n    if (offset < 0x100) {\n\n        if (offset == 0) {\n\n            s->enabled = (value & 1);\n\n            DPRINTF(\"Distribution %sabled\\n\", s->enabled ? \"En\" : \"Dis\");\n\n        } else if (offset < 4) {\n\n            /* ignored.  */\n\n        } else if (offset >= 0x80) {\n\n            /* Interrupt Security Registers, RAZ/WI */\n\n        } else {\n\n            goto bad_reg;\n\n        }\n\n    } else if (offset < 0x180) {\n\n        /* Interrupt Set Enable.  */\n\n        irq = (offset - 0x100) * 8 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        if (irq < 16)\n\n          value = 0xff;\n\n        for (i = 0; i < 8; i++) {\n\n            if (value & (1 << i)) {\n\n                int mask = (irq < GIC_INTERNAL) ? (1 << cpu) : GIC_TARGET(irq);\n\n                int cm = (irq < GIC_INTERNAL) ? (1 << cpu) : ALL_CPU_MASK;\n\n\n\n                if (!GIC_TEST_ENABLED(irq + i, cm)) {\n\n                    DPRINTF(\"Enabled IRQ %d\\n\", irq + i);\n\n                }\n\n                GIC_SET_ENABLED(irq + i, cm);\n\n                /* If a raised level triggered IRQ enabled then mark\n\n                   is as pending.  */\n\n                if (GIC_TEST_LEVEL(irq + i, mask)\n\n                        && !GIC_TEST_TRIGGER(irq + i)) {\n\n                    DPRINTF(\"Set %d pending mask %x\\n\", irq + i, mask);\n\n                    GIC_SET_PENDING(irq + i, mask);\n\n                }\n\n            }\n\n        }\n\n    } else if (offset < 0x200) {\n\n        /* Interrupt Clear Enable.  */\n\n        irq = (offset - 0x180) * 8 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        if (irq < 16)\n\n          value = 0;\n\n        for (i = 0; i < 8; i++) {\n\n            if (value & (1 << i)) {\n\n                int cm = (irq < GIC_INTERNAL) ? (1 << cpu) : ALL_CPU_MASK;\n\n\n\n                if (GIC_TEST_ENABLED(irq + i, cm)) {\n\n                    DPRINTF(\"Disabled IRQ %d\\n\", irq + i);\n\n                }\n\n                GIC_CLEAR_ENABLED(irq + i, cm);\n\n            }\n\n        }\n\n    } else if (offset < 0x280) {\n\n        /* Interrupt Set Pending.  */\n\n        irq = (offset - 0x200) * 8 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        if (irq < 16)\n\n          irq = 0;\n\n\n\n        for (i = 0; i < 8; i++) {\n\n            if (value & (1 << i)) {\n\n                GIC_SET_PENDING(irq + i, GIC_TARGET(irq));\n\n            }\n\n        }\n\n    } else if (offset < 0x300) {\n\n        /* Interrupt Clear Pending.  */\n\n        irq = (offset - 0x280) * 8 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        for (i = 0; i < 8; i++) {\n\n            /* ??? This currently clears the pending bit for all CPUs, even\n\n               for per-CPU interrupts.  It's unclear whether this is the\n\n               corect behavior.  */\n\n            if (value & (1 << i)) {\n\n                GIC_CLEAR_PENDING(irq + i, ALL_CPU_MASK);\n\n            }\n\n        }\n\n    } else if (offset < 0x400) {\n\n        /* Interrupt Active.  */\n\n        goto bad_reg;\n\n    } else if (offset < 0x800) {\n\n        /* Interrupt Priority.  */\n\n        irq = (offset - 0x400) + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        if (irq < GIC_INTERNAL) {\n\n            s->priority1[irq][cpu] = value;\n\n        } else {\n\n            s->priority2[irq - GIC_INTERNAL] = value;\n\n        }\n\n    } else if (offset < 0xc00) {\n\n        /* Interrupt CPU Target. RAZ/WI on uniprocessor GICs, with the\n\n         * annoying exception of the 11MPCore's GIC.\n\n         */\n\n        if (s->num_cpu != 1 || s->revision == REV_11MPCORE) {\n\n            irq = (offset - 0x800) + GIC_BASE_IRQ;\n\n            if (irq >= s->num_irq) {\n\n                goto bad_reg;\n\n            }\n\n            if (irq < 29) {\n\n                value = 0;\n\n            } else if (irq < GIC_INTERNAL) {\n\n                value = ALL_CPU_MASK;\n\n            }\n\n            s->irq_target[irq] = value & ALL_CPU_MASK;\n\n        }\n\n    } else if (offset < 0xf00) {\n\n        /* Interrupt Configuration.  */\n\n        irq = (offset - 0xc00) * 4 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        if (irq < GIC_INTERNAL)\n\n            value |= 0xaa;\n\n        for (i = 0; i < 4; i++) {\n\n            if (value & (1 << (i * 2))) {\n\n                GIC_SET_MODEL(irq + i);\n\n            } else {\n\n                GIC_CLEAR_MODEL(irq + i);\n\n            }\n\n            if (value & (2 << (i * 2))) {\n\n                GIC_SET_TRIGGER(irq + i);\n\n            } else {\n\n                GIC_CLEAR_TRIGGER(irq + i);\n\n            }\n\n        }\n\n    } else {\n\n        /* 0xf00 is only handled for 32-bit writes.  */\n\n        goto bad_reg;\n\n    }\n\n    gic_update(s);\n\n    return;\n\nbad_reg:\n\n    hw_error(\"gic_dist_writeb: Bad offset %x\\n\", (int)offset);\n\n}\n", "idx": 22190}
{"project": "qemu", "commit_id": "35b0f237205dc6a5c9aa3eae14f19ef4d37dafcd", "target": 0, "func": "static void sdl_mouse_mode_change(Notifier *notify, void *data)\n\n{\n\n    if (kbd_mouse_is_absolute()) {\n\n        if (!absolute_enabled) {\n\n            sdl_hide_cursor();\n\n            if (gui_grab) {\n\n                sdl_grab_end();\n\n            }\n\n            absolute_enabled = 1;\n\n        }\n\n    } else if (absolute_enabled) {\n\n\tsdl_show_cursor();\n\n\tabsolute_enabled = 0;\n\n    }\n\n}\n", "idx": 22191}
{"project": "qemu", "commit_id": "ee17e84830e2e7030d57db5b415719e9022573cd", "target": 0, "func": "static void virtio_blk_handle_request(VirtIOBlockReq *req,\n\n    MultiReqBuffer *mrb)\n\n{\n\n    uint32_t type;\n\n    struct iovec *iov = req->elem->out_sg;\n\n    unsigned out_num = req->elem->out_num;\n\n\n\n    if (req->elem->out_num < 1 || req->elem->in_num < 1) {\n\n        error_report(\"virtio-blk missing headers\");\n\n        exit(1);\n\n    }\n\n\n\n    if (req->elem->out_sg[0].iov_len < sizeof(req->out) ||\n\n        req->elem->in_sg[req->elem->in_num - 1].iov_len < sizeof(*req->in)) {\n\n        error_report(\"virtio-blk header not in correct element\");\n\n        exit(1);\n\n    }\n\n\n\n    if (unlikely(iov_to_buf(iov, out_num, 0, &req->out,\n\n                            sizeof(req->out)) != sizeof(req->out))) {\n\n        error_report(\"virtio-blk request outhdr too short\");\n\n        exit(1);\n\n    }\n\n    iov_discard_front(&iov, &out_num, sizeof(req->out));\n\n    req->in = (void *)req->elem->in_sg[req->elem->in_num - 1].iov_base;\n\n\n\n    type = ldl_p(&req->out.type);\n\n\n\n    if (type & VIRTIO_BLK_T_FLUSH) {\n\n        virtio_blk_handle_flush(req, mrb);\n\n    } else if (type & VIRTIO_BLK_T_SCSI_CMD) {\n\n        virtio_blk_handle_scsi(req);\n\n    } else if (type & VIRTIO_BLK_T_GET_ID) {\n\n        VirtIOBlock *s = req->dev;\n\n\n\n        /*\n\n         * NB: per existing s/n string convention the string is\n\n         * terminated by '\\0' only when shorter than buffer.\n\n         */\n\n        strncpy(req->elem->in_sg[0].iov_base,\n\n                s->blk.serial ? s->blk.serial : \"\",\n\n                MIN(req->elem->in_sg[0].iov_len, VIRTIO_BLK_ID_BYTES));\n\n        virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);\n\n        virtio_blk_free_request(req);\n\n    } else if (type & VIRTIO_BLK_T_OUT) {\n\n        qemu_iovec_init_external(&req->qiov, &req->elem->out_sg[1],\n\n                                 req->elem->out_num - 1);\n\n        virtio_blk_handle_write(req, mrb);\n\n    } else if (type == VIRTIO_BLK_T_IN || type == VIRTIO_BLK_T_BARRIER) {\n\n        /* VIRTIO_BLK_T_IN is 0, so we can't just & it. */\n\n        qemu_iovec_init_external(&req->qiov, &req->elem->in_sg[0],\n\n                                 req->elem->in_num - 1);\n\n        virtio_blk_handle_read(req);\n\n    } else {\n\n        virtio_blk_req_complete(req, VIRTIO_BLK_S_UNSUPP);\n\n        virtio_blk_free_request(req);\n\n    }\n\n}\n", "idx": 22192}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_clkm_write(void *opaque, target_phys_addr_t addr,\n\n                            uint64_t value, unsigned size)\n\n{\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *) opaque;\n\n    uint16_t diff;\n\n    omap_clk clk;\n\n    static const char *clkschemename[8] = {\n\n        \"fully synchronous\", \"fully asynchronous\", \"synchronous scalable\",\n\n        \"mix mode 1\", \"mix mode 2\", \"bypass mode\", \"mix mode 3\", \"mix mode 4\",\n\n    };\n\n\n\n    if (size != 2) {\n\n        return omap_badwidth_write16(opaque, addr, value);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x00:\t/* ARM_CKCTL */\n\n        diff = s->clkm.arm_ckctl ^ value;\n\n        s->clkm.arm_ckctl = value & 0x7fff;\n\n        omap_clkm_ckctl_update(s, diff, value);\n\n        return;\n\n\n\n    case 0x04:\t/* ARM_IDLECT1 */\n\n        diff = s->clkm.arm_idlect1 ^ value;\n\n        s->clkm.arm_idlect1 = value & 0x0fff;\n\n        omap_clkm_idlect1_update(s, diff, value);\n\n        return;\n\n\n\n    case 0x08:\t/* ARM_IDLECT2 */\n\n        diff = s->clkm.arm_idlect2 ^ value;\n\n        s->clkm.arm_idlect2 = value & 0x07ff;\n\n        omap_clkm_idlect2_update(s, diff, value);\n\n        return;\n\n\n\n    case 0x0c:\t/* ARM_EWUPCT */\n\n        s->clkm.arm_ewupct = value & 0x003f;\n\n        return;\n\n\n\n    case 0x10:\t/* ARM_RSTCT1 */\n\n        diff = s->clkm.arm_rstct1 ^ value;\n\n        s->clkm.arm_rstct1 = value & 0x0007;\n\n        if (value & 9) {\n\n            qemu_system_reset_request();\n\n            s->clkm.cold_start = 0xa;\n\n        }\n\n        if (diff & ~value & 4) {\t\t\t\t/* DSP_RST */\n\n            omap_mpui_reset(s);\n\n            omap_tipb_bridge_reset(s->private_tipb);\n\n            omap_tipb_bridge_reset(s->public_tipb);\n\n        }\n\n        if (diff & 2) {\t\t\t\t\t\t/* DSP_EN */\n\n            clk = omap_findclk(s, \"dsp_ck\");\n\n            omap_clk_canidle(clk, (~value >> 1) & 1);\n\n        }\n\n        return;\n\n\n\n    case 0x14:\t/* ARM_RSTCT2 */\n\n        s->clkm.arm_rstct2 = value & 0x0001;\n\n        return;\n\n\n\n    case 0x18:\t/* ARM_SYSST */\n\n        if ((s->clkm.clocking_scheme ^ (value >> 11)) & 7) {\n\n            s->clkm.clocking_scheme = (value >> 11) & 7;\n\n            printf(\"%s: clocking scheme set to %s\\n\", __FUNCTION__,\n\n                            clkschemename[s->clkm.clocking_scheme]);\n\n        }\n\n        s->clkm.cold_start &= value & 0x3f;\n\n        return;\n\n\n\n    case 0x1c:\t/* ARM_CKOUT1 */\n\n        diff = s->clkm.arm_ckout1 ^ value;\n\n        s->clkm.arm_ckout1 = value & 0x003f;\n\n        omap_clkm_ckout1_update(s, diff, value);\n\n        return;\n\n\n\n    case 0x20:\t/* ARM_CKOUT2 */\n\n    default:\n\n        OMAP_BAD_REG(addr);\n\n    }\n\n}\n", "idx": 22194}
{"project": "qemu", "commit_id": "a22313deca720e038ebc5805cf451b3a685d29ce", "target": 0, "func": "static void vfio_intp_inject_pending_lockheld(VFIOINTp *intp)\n\n{\n\n    trace_vfio_platform_intp_inject_pending_lockheld(intp->pin,\n\n                              event_notifier_get_fd(&intp->interrupt));\n\n\n\n    intp->state = VFIO_IRQ_ACTIVE;\n\n\n\n    /* trigger the virtual IRQ */\n\n    qemu_set_irq(intp->qemuirq, 1);\n\n}\n", "idx": 22196}
{"project": "qemu", "commit_id": "7466bc49107fbd84336ba680f860d5eadd6def13", "target": 0, "func": "void qemu_spice_display_resize(SimpleSpiceDisplay *ssd)\n\n{\n\n    dprint(1, \"%s:\\n\", __FUNCTION__);\n\n\n\n    pthread_mutex_lock(&ssd->lock);\n\n    memset(&ssd->dirty, 0, sizeof(ssd->dirty));\n\n    qemu_pf_conv_put(ssd->conv);\n\n    ssd->conv = NULL;\n\n    pthread_mutex_unlock(&ssd->lock);\n\n\n\n    qemu_spice_destroy_host_primary(ssd);\n\n    qemu_spice_create_host_primary(ssd);\n\n\n\n    pthread_mutex_lock(&ssd->lock);\n\n    memset(&ssd->dirty, 0, sizeof(ssd->dirty));\n\n    ssd->notify++;\n\n    pthread_mutex_unlock(&ssd->lock);\n\n}\n", "idx": 22197}
{"project": "qemu", "commit_id": "539de1246d355d3b8aa33fb7cde732352d8827c7", "target": 0, "func": "void qemu_savevm_state_cancel(Monitor *mon, QEMUFile *f)\n\n{\n\n    SaveStateEntry *se;\n\n\n\n    QTAILQ_FOREACH(se, &savevm_handlers, entry) {\n\n        if (se->save_live_state) {\n\n            se->save_live_state(mon, f, -1, se->opaque);\n\n        }\n\n    }\n\n}\n", "idx": 22198}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "VLANState *qemu_find_vlan(int id, int allocate)\n\n{\n\n    VLANState **pvlan, *vlan;\n\n    for(vlan = first_vlan; vlan != NULL; vlan = vlan->next) {\n\n        if (vlan->id == id)\n\n            return vlan;\n\n    }\n\n    if (!allocate) {\n\n        return NULL;\n\n    }\n\n    vlan = qemu_mallocz(sizeof(VLANState));\n\n    vlan->id = id;\n\n    TAILQ_INIT(&vlan->send_queue);\n\n    vlan->next = NULL;\n\n    pvlan = &first_vlan;\n\n    while (*pvlan != NULL)\n\n        pvlan = &(*pvlan)->next;\n\n    *pvlan = vlan;\n\n    return vlan;\n\n}\n", "idx": 22199}
{"project": "qemu", "commit_id": "e4603fe139e2161464d7e75faa3a650e31f057fc", "target": 0, "func": "static int qcow2_amend_options(BlockDriverState *bs, QemuOpts *opts,\n\n                               BlockDriverAmendStatusCB *status_cb)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int old_version = s->qcow_version, new_version = old_version;\n\n    uint64_t new_size = 0;\n\n    const char *backing_file = NULL, *backing_format = NULL;\n\n    bool lazy_refcounts = s->use_lazy_refcounts;\n\n    const char *compat = NULL;\n\n    uint64_t cluster_size = s->cluster_size;\n\n    bool encrypt;\n\n    int ret;\n\n    QemuOptDesc *desc = opts->list->desc;\n\n\n\n    while (desc && desc->name) {\n\n        if (!qemu_opt_find(opts, desc->name)) {\n\n            /* only change explicitly defined options */\n\n            desc++;\n\n            continue;\n\n        }\n\n\n\n        if (!strcmp(desc->name, BLOCK_OPT_COMPAT_LEVEL)) {\n\n            compat = qemu_opt_get(opts, BLOCK_OPT_COMPAT_LEVEL);\n\n            if (!compat) {\n\n                /* preserve default */\n\n            } else if (!strcmp(compat, \"0.10\")) {\n\n                new_version = 2;\n\n            } else if (!strcmp(compat, \"1.1\")) {\n\n                new_version = 3;\n\n            } else {\n\n                fprintf(stderr, \"Unknown compatibility level %s.\\n\", compat);\n\n                return -EINVAL;\n\n            }\n\n        } else if (!strcmp(desc->name, BLOCK_OPT_PREALLOC)) {\n\n            fprintf(stderr, \"Cannot change preallocation mode.\\n\");\n\n            return -ENOTSUP;\n\n        } else if (!strcmp(desc->name, BLOCK_OPT_SIZE)) {\n\n            new_size = qemu_opt_get_size(opts, BLOCK_OPT_SIZE, 0);\n\n        } else if (!strcmp(desc->name, BLOCK_OPT_BACKING_FILE)) {\n\n            backing_file = qemu_opt_get(opts, BLOCK_OPT_BACKING_FILE);\n\n        } else if (!strcmp(desc->name, BLOCK_OPT_BACKING_FMT)) {\n\n            backing_format = qemu_opt_get(opts, BLOCK_OPT_BACKING_FMT);\n\n        } else if (!strcmp(desc->name, BLOCK_OPT_ENCRYPT)) {\n\n            encrypt = qemu_opt_get_bool(opts, BLOCK_OPT_ENCRYPT,\n\n                                        s->crypt_method);\n\n            if (encrypt != !!s->crypt_method) {\n\n                fprintf(stderr, \"Changing the encryption flag is not \"\n\n                        \"supported.\\n\");\n\n                return -ENOTSUP;\n\n            }\n\n        } else if (!strcmp(desc->name, BLOCK_OPT_CLUSTER_SIZE)) {\n\n            cluster_size = qemu_opt_get_size(opts, BLOCK_OPT_CLUSTER_SIZE,\n\n                                             cluster_size);\n\n            if (cluster_size != s->cluster_size) {\n\n                fprintf(stderr, \"Changing the cluster size is not \"\n\n                        \"supported.\\n\");\n\n                return -ENOTSUP;\n\n            }\n\n        } else if (!strcmp(desc->name, BLOCK_OPT_LAZY_REFCOUNTS)) {\n\n            lazy_refcounts = qemu_opt_get_bool(opts, BLOCK_OPT_LAZY_REFCOUNTS,\n\n                                               lazy_refcounts);\n\n        } else if (!strcmp(desc->name, BLOCK_OPT_REFCOUNT_BITS)) {\n\n            error_report(\"Cannot change refcount entry width\");\n\n            return -ENOTSUP;\n\n        } else {\n\n            /* if this assertion fails, this probably means a new option was\n\n             * added without having it covered here */\n\n            assert(false);\n\n        }\n\n\n\n        desc++;\n\n    }\n\n\n\n    if (new_version != old_version) {\n\n        if (new_version > old_version) {\n\n            /* Upgrade */\n\n            s->qcow_version = new_version;\n\n            ret = qcow2_update_header(bs);\n\n            if (ret < 0) {\n\n                s->qcow_version = old_version;\n\n                return ret;\n\n            }\n\n        } else {\n\n            ret = qcow2_downgrade(bs, new_version, status_cb);\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (backing_file || backing_format) {\n\n        ret = qcow2_change_backing_file(bs, backing_file ?: bs->backing_file,\n\n                                        backing_format ?: bs->backing_format);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    if (s->use_lazy_refcounts != lazy_refcounts) {\n\n        if (lazy_refcounts) {\n\n            if (s->qcow_version < 3) {\n\n                fprintf(stderr, \"Lazy refcounts only supported with compatibility \"\n\n                        \"level 1.1 and above (use compat=1.1 or greater)\\n\");\n\n                return -EINVAL;\n\n            }\n\n            s->compatible_features |= QCOW2_COMPAT_LAZY_REFCOUNTS;\n\n            ret = qcow2_update_header(bs);\n\n            if (ret < 0) {\n\n                s->compatible_features &= ~QCOW2_COMPAT_LAZY_REFCOUNTS;\n\n                return ret;\n\n            }\n\n            s->use_lazy_refcounts = true;\n\n        } else {\n\n            /* make image clean first */\n\n            ret = qcow2_mark_clean(bs);\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n            /* now disallow lazy refcounts */\n\n            s->compatible_features &= ~QCOW2_COMPAT_LAZY_REFCOUNTS;\n\n            ret = qcow2_update_header(bs);\n\n            if (ret < 0) {\n\n                s->compatible_features |= QCOW2_COMPAT_LAZY_REFCOUNTS;\n\n                return ret;\n\n            }\n\n            s->use_lazy_refcounts = false;\n\n        }\n\n    }\n\n\n\n    if (new_size) {\n\n        ret = bdrv_truncate(bs, new_size);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 22200}
{"project": "qemu", "commit_id": "3db3659bf60094657e1465cc809acb09551816ee", "target": 0, "func": "static void apic_update_irq(APICCommonState *s)\n\n{\n\n    if (!(s->spurious_vec & APIC_SV_ENABLE)) {\n\n        return;\n\n    }\n\n    if (apic_irq_pending(s) > 0) {\n\n        cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);\n\n    } else if (apic_accept_pic_intr(&s->busdev.qdev) &&\n\n               pic_get_output(isa_pic)) {\n\n        apic_deliver_pic_intr(&s->busdev.qdev, 1);\n\n    }\n\n}\n", "idx": 22201}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void aio_set_event_notifier(AioContext *ctx,\n\n                            EventNotifier *e,\n\n                            bool is_external,\n\n                            EventNotifierHandler *io_notify,\n\n                            AioPollFn *io_poll)\n\n{\n\n    AioHandler *node;\n\n\n\n    qemu_lockcnt_lock(&ctx->list_lock);\n\n    QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n        if (node->e == e && !node->deleted) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* Are we deleting the fd handler? */\n\n    if (!io_notify) {\n\n        if (node) {\n\n            g_source_remove_poll(&ctx->source, &node->pfd);\n\n\n\n            /* aio_poll is in progress, just mark the node as deleted */\n\n            if (qemu_lockcnt_count(&ctx->list_lock)) {\n\n                node->deleted = 1;\n\n                node->pfd.revents = 0;\n\n            } else {\n\n                /* Otherwise, delete it for real.  We can't just mark it as\n\n                 * deleted because deleted nodes are only cleaned up after\n\n                 * releasing the list_lock.\n\n                 */\n\n                QLIST_REMOVE(node, node);\n\n                g_free(node);\n\n            }\n\n        }\n\n    } else {\n\n        if (node == NULL) {\n\n            /* Alloc and insert if it's not already there */\n\n            node = g_new0(AioHandler, 1);\n\n            node->e = e;\n\n            node->pfd.fd = (uintptr_t)event_notifier_get_handle(e);\n\n            node->pfd.events = G_IO_IN;\n\n            node->is_external = is_external;\n\n            QLIST_INSERT_HEAD_RCU(&ctx->aio_handlers, node, node);\n\n\n\n            g_source_add_poll(&ctx->source, &node->pfd);\n\n        }\n\n        /* Update handler with latest information */\n\n        node->io_notify = io_notify;\n\n    }\n\n\n\n    qemu_lockcnt_unlock(&ctx->list_lock);\n\n    aio_notify(ctx);\n\n}\n", "idx": 22202}
{"project": "qemu", "commit_id": "b4ea86649915eca5551a5166f76e7a9d9032de50", "target": 0, "func": "static int ehci_state_fetchqtd(EHCIQueue *q)\n\n{\n\n    EHCIqtd qtd;\n\n    EHCIPacket *p;\n\n    int again = 0;\n\n\n\n    get_dwords(q->ehci, NLPTR_GET(q->qtdaddr), (uint32_t *) &qtd,\n\n               sizeof(EHCIqtd) >> 2);\n\n    ehci_trace_qtd(q, NLPTR_GET(q->qtdaddr), &qtd);\n\n\n\n    p = QTAILQ_FIRST(&q->packets);\n\n    if (p != NULL) {\n\n        if (p->qtdaddr != q->qtdaddr ||\n\n            (!NLPTR_TBIT(p->qtd.next) && (p->qtd.next != qtd.next)) ||\n\n            (!NLPTR_TBIT(p->qtd.altnext) && (p->qtd.altnext != qtd.altnext)) ||\n\n            p->qtd.bufptr[0] != qtd.bufptr[0]) {\n\n            ehci_cancel_queue(q);\n\n            ehci_trace_guest_bug(q->ehci, \"guest updated active QH or qTD\");\n\n            p = NULL;\n\n        } else {\n\n            p->qtd = qtd;\n\n            ehci_qh_do_overlay(q);\n\n        }\n\n    }\n\n\n\n    if (!(qtd.token & QTD_TOKEN_ACTIVE)) {\n\n        if (p != NULL) {\n\n            /* transfer canceled by guest (clear active) */\n\n            ehci_cancel_queue(q);\n\n            p = NULL;\n\n        }\n\n        ehci_set_state(q->ehci, q->async, EST_HORIZONTALQH);\n\n        again = 1;\n\n    } else if (p != NULL) {\n\n        switch (p->async) {\n\n        case EHCI_ASYNC_NONE:\n\n        case EHCI_ASYNC_INITIALIZED:\n\n            /* Not yet executed (MULT), or previously nacked (int) packet */\n\n            ehci_set_state(q->ehci, q->async, EST_EXECUTE);\n\n            break;\n\n        case EHCI_ASYNC_INFLIGHT:\n\n            /* Unfinished async handled packet, go horizontal */\n\n            ehci_set_state(q->ehci, q->async, EST_HORIZONTALQH);\n\n            break;\n\n        case EHCI_ASYNC_FINISHED:\n\n            /*\n\n             * We get here when advqueue moves to a packet which is already\n\n             * finished, which can happen with packets queued up by fill_queue\n\n             */\n\n            ehci_set_state(q->ehci, q->async, EST_EXECUTING);\n\n            break;\n\n        }\n\n        again = 1;\n\n    } else {\n\n        p = ehci_alloc_packet(q);\n\n        p->qtdaddr = q->qtdaddr;\n\n        p->qtd = qtd;\n\n        ehci_set_state(q->ehci, q->async, EST_EXECUTE);\n\n        again = 1;\n\n    }\n\n\n\n    return again;\n\n}\n", "idx": 22203}
{"project": "qemu", "commit_id": "ca7eb1848bb06d9b75784d7760b83c7b0beb1102", "target": 0, "func": "int net_init_hubport(const NetClientOptions *opts, const char *name,\n\n                     NetClientState *peer)\n\n{\n\n    const NetdevHubPortOptions *hubport;\n\n\n\n    assert(opts->kind == NET_CLIENT_OPTIONS_KIND_HUBPORT);\n\n    hubport = opts->hubport;\n\n\n\n    if (peer) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    net_hub_add_port(hubport->hubid, name);\n\n    return 0;\n\n}\n", "idx": 22204}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int cpu_breakpoint_remove(CPUState *env, target_ulong pc, int flags)\n\n{\n\n#if defined(TARGET_HAS_ICE)\n\n    CPUBreakpoint *bp;\n\n\n\n    TAILQ_FOREACH(bp, &env->breakpoints, entry) {\n\n        if (bp->pc == pc && bp->flags == flags) {\n\n            cpu_breakpoint_remove_by_ref(env, bp);\n\n            return 0;\n\n        }\n\n    }\n\n    return -ENOENT;\n\n#else\n\n    return -ENOSYS;\n\n#endif\n\n}\n", "idx": 22205}
{"project": "qemu", "commit_id": "7d1476898fd58d6ae5c054e6afddf18c335d9d89", "target": 0, "func": "static void pxa2xx_ssp_fifo_update(PXA2xxSSPState *s)\n\n{\n\n    s->sssr &= ~(0xf << 12);\t/* Clear RFL */\n\n    s->sssr &= ~(0xf << 8);\t/* Clear TFL */\n\n    s->sssr &= ~SSSR_TNF;\n\n    if (s->enable) {\n\n        s->sssr |= ((s->rx_level - 1) & 0xf) << 12;\n\n        if (s->rx_level >= SSCR1_RFT(s->sscr[1]))\n\n            s->sssr |= SSSR_RFS;\n\n        else\n\n            s->sssr &= ~SSSR_RFS;\n\n        if (0 <= SSCR1_TFT(s->sscr[1]))\n\n            s->sssr |= SSSR_TFS;\n\n        else\n\n            s->sssr &= ~SSSR_TFS;\n\n        if (s->rx_level)\n\n            s->sssr |= SSSR_RNE;\n\n        else\n\n            s->sssr &= ~SSSR_RNE;\n\n        s->sssr |= SSSR_TNF;\n\n    }\n\n\n\n    pxa2xx_ssp_int_update(s);\n\n}\n", "idx": 22207}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void grlib_apbuart_write(void *opaque, target_phys_addr_t addr,\n\n                                uint64_t value, unsigned size)\n\n{\n\n    UART          *uart = opaque;\n\n    unsigned char  c    = 0;\n\n\n\n    addr &= 0xff;\n\n\n\n    /* Unit registers */\n\n    switch (addr) {\n\n    case DATA_OFFSET:\n\n    case DATA_OFFSET + 3:       /* When only one byte write */\n\n        c = value & 0xFF;\n\n        qemu_chr_fe_write(uart->chr, &c, 1);\n\n        return;\n\n\n\n    case STATUS_OFFSET:\n\n        /* Read Only */\n\n        return;\n\n\n\n    case CONTROL_OFFSET:\n\n        uart->control = value;\n\n        return;\n\n\n\n    case SCALER_OFFSET:\n\n        /* Not supported */\n\n        return;\n\n\n\n    default:\n\n        break;\n\n    }\n\n\n\n    trace_grlib_apbuart_writel_unknown(addr, value);\n\n}\n", "idx": 22208}
{"project": "qemu", "commit_id": "1ac157da77c863b62b1d2f467626a440d57cf17d", "target": 0, "func": "int cpu_x86_handle_mmu_fault(CPUX86State *env, uint32_t addr, \n\n                             int is_write, int is_user, int is_softmmu)\n\n{\n\n    uint8_t *pde_ptr, *pte_ptr;\n\n    uint32_t pde, pte, virt_addr, ptep;\n\n    int error_code, is_dirty, prot, page_size, ret;\n\n    unsigned long paddr, vaddr, page_offset;\n\n    \n\n#if defined(DEBUG_MMU)\n\n    printf(\"MMU fault: addr=0x%08x w=%d u=%d eip=%08x\\n\", \n\n           addr, is_write, is_user, env->eip);\n\n#endif\n\n\n\n    if (env->user_mode_only) {\n\n        /* user mode only emulation */\n\n        error_code = 0;\n\n        goto do_fault;\n\n    }\n\n\n\n    if (!(env->cr[0] & CR0_PG_MASK)) {\n\n        pte = addr;\n\n        virt_addr = addr & TARGET_PAGE_MASK;\n\n        prot = PROT_READ | PROT_WRITE;\n\n        page_size = 4096;\n\n        goto do_mapping;\n\n    }\n\n\n\n    /* page directory entry */\n\n    pde_ptr = phys_ram_base + \n\n        (((env->cr[3] & ~0xfff) + ((addr >> 20) & ~3)) & a20_mask);\n\n    pde = ldl_raw(pde_ptr);\n\n    if (!(pde & PG_PRESENT_MASK)) {\n\n        error_code = 0;\n\n        goto do_fault;\n\n    }\n\n    /* if PSE bit is set, then we use a 4MB page */\n\n    if ((pde & PG_PSE_MASK) && (env->cr[4] & CR4_PSE_MASK)) {\n\n        if (is_user) {\n\n            if (!(pde & PG_USER_MASK))\n\n                goto do_fault_protect;\n\n            if (is_write && !(pde & PG_RW_MASK))\n\n                goto do_fault_protect;\n\n        } else {\n\n            if ((env->cr[0] & CR0_WP_MASK) && (pde & PG_USER_MASK) &&\n\n                is_write && !(pde & PG_RW_MASK)) \n\n                goto do_fault_protect;\n\n        }\n\n        is_dirty = is_write && !(pde & PG_DIRTY_MASK);\n\n        if (!(pde & PG_ACCESSED_MASK) || is_dirty) {\n\n            pde |= PG_ACCESSED_MASK;\n\n            if (is_dirty)\n\n                pde |= PG_DIRTY_MASK;\n\n            stl_raw(pde_ptr, pde);\n\n        }\n\n        \n\n        pte = pde & ~0x003ff000; /* align to 4MB */\n\n        ptep = pte;\n\n        page_size = 4096 * 1024;\n\n        virt_addr = addr & ~0x003fffff;\n\n    } else {\n\n        if (!(pde & PG_ACCESSED_MASK)) {\n\n            pde |= PG_ACCESSED_MASK;\n\n            stl_raw(pde_ptr, pde);\n\n        }\n\n\n\n        /* page directory entry */\n\n        pte_ptr = phys_ram_base + \n\n            (((pde & ~0xfff) + ((addr >> 10) & 0xffc)) & a20_mask);\n\n        pte = ldl_raw(pte_ptr);\n\n        if (!(pte & PG_PRESENT_MASK)) {\n\n            error_code = 0;\n\n            goto do_fault;\n\n        }\n\n        /* combine pde and pte user and rw protections */\n\n        ptep = pte & pde;\n\n        if (is_user) {\n\n            if (!(ptep & PG_USER_MASK))\n\n                goto do_fault_protect;\n\n            if (is_write && !(ptep & PG_RW_MASK))\n\n                goto do_fault_protect;\n\n        } else {\n\n            if ((env->cr[0] & CR0_WP_MASK) && (ptep & PG_USER_MASK) &&\n\n                is_write && !(ptep & PG_RW_MASK)) \n\n                goto do_fault_protect;\n\n        }\n\n        is_dirty = is_write && !(pte & PG_DIRTY_MASK);\n\n        if (!(pte & PG_ACCESSED_MASK) || is_dirty) {\n\n            pte |= PG_ACCESSED_MASK;\n\n            if (is_dirty)\n\n                pte |= PG_DIRTY_MASK;\n\n            stl_raw(pte_ptr, pte);\n\n        }\n\n        page_size = 4096;\n\n        virt_addr = addr & ~0xfff;\n\n    }\n\n\n\n    /* the page can be put in the TLB */\n\n    prot = PROT_READ;\n\n    if (pte & PG_DIRTY_MASK) {\n\n        /* only set write access if already dirty... otherwise wait\n\n           for dirty access */\n\n        if (is_user) {\n\n            if (ptep & PG_RW_MASK)\n\n                prot |= PROT_WRITE;\n\n        } else {\n\n            if (!(env->cr[0] & CR0_WP_MASK) || !(ptep & PG_USER_MASK) ||\n\n                (ptep & PG_RW_MASK))\n\n                prot |= PROT_WRITE;\n\n        }\n\n    }\n\n\n\n do_mapping:\n\n    pte = pte & a20_mask;\n\n\n\n    /* Even if 4MB pages, we map only one 4KB page in the cache to\n\n       avoid filling it too fast */\n\n    page_offset = (addr & TARGET_PAGE_MASK) & (page_size - 1);\n\n    paddr = (pte & TARGET_PAGE_MASK) + page_offset;\n\n    vaddr = virt_addr + page_offset;\n\n    \n\n    ret = tlb_set_page(env, vaddr, paddr, prot, is_user, is_softmmu);\n\n    return ret;\n\n do_fault_protect:\n\n    error_code = PG_ERROR_P_MASK;\n\n do_fault:\n\n    env->cr[2] = addr;\n\n    env->error_code = (is_write << PG_ERROR_W_BIT) | error_code;\n\n    if (is_user)\n\n        env->error_code |= PG_ERROR_U_MASK;\n\n    return 1;\n\n}\n", "idx": 22209}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_delete_char(void)\n\n{\n\n    if (term_cmd_buf_index < term_cmd_buf_size) {\n\n        memmove(term_cmd_buf + term_cmd_buf_index,\n\n                term_cmd_buf + term_cmd_buf_index + 1,\n\n                term_cmd_buf_size - term_cmd_buf_index - 1);\n\n        term_cmd_buf_size--;\n\n    }\n\n}\n", "idx": 22210}
{"project": "qemu", "commit_id": "bab482d7405f9fe3cac9c213d60f9ca9442c047b", "target": 0, "func": "static void sch_handle_start_func(SubchDev *sch, ORB *orb)\n\n{\n\n\n\n    PMCW *p = &sch->curr_status.pmcw;\n\n    SCSW *s = &sch->curr_status.scsw;\n\n    int path;\n\n    int ret;\n\n    bool suspend_allowed;\n\n\n\n    /* Path management: In our simple css, we always choose the only path. */\n\n    path = 0x80;\n\n\n\n    if (!(s->ctrl & SCSW_ACTL_SUSP)) {\n\n        /* Start Function triggered via ssch, i.e. we have an ORB */\n\n        s->cstat = 0;\n\n        s->dstat = 0;\n\n        /* Look at the orb and try to execute the channel program. */\n\n        assert(orb != NULL); /* resume does not pass an orb */\n\n        p->intparm = orb->intparm;\n\n        if (!(orb->lpm & path)) {\n\n            /* Generate a deferred cc 3 condition. */\n\n            s->flags |= SCSW_FLAGS_MASK_CC;\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= (SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND);\n\n            return;\n\n        }\n\n        sch->ccw_fmt_1 = !!(orb->ctrl0 & ORB_CTRL0_MASK_FMT);\n\n        s->flags |= (sch->ccw_fmt_1) ? SCSW_FLAGS_MASK_FMT : 0;\n\n        sch->ccw_no_data_cnt = 0;\n\n        suspend_allowed = !!(orb->ctrl0 & ORB_CTRL0_MASK_SPND);\n\n    } else {\n\n        /* Start Function resumed via rsch, i.e. we don't have an\n\n         * ORB */\n\n        s->ctrl &= ~(SCSW_ACTL_SUSP | SCSW_ACTL_RESUME_PEND);\n\n        /* The channel program had been suspended before. */\n\n        suspend_allowed = true;\n\n    }\n\n    sch->last_cmd_valid = false;\n\n    do {\n\n        ret = css_interpret_ccw(sch, sch->channel_prog, suspend_allowed);\n\n        switch (ret) {\n\n        case -EAGAIN:\n\n            /* ccw chain, continue processing */\n\n            break;\n\n        case 0:\n\n            /* success */\n\n            s->ctrl &= ~SCSW_ACTL_START_PEND;\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= SCSW_STCTL_PRIMARY | SCSW_STCTL_SECONDARY |\n\n                    SCSW_STCTL_STATUS_PEND;\n\n            s->dstat = SCSW_DSTAT_CHANNEL_END | SCSW_DSTAT_DEVICE_END;\n\n            s->cpa = sch->channel_prog + 8;\n\n            break;\n\n        case -EIO:\n\n            /* I/O errors, status depends on specific devices */\n\n            break;\n\n        case -ENOSYS:\n\n            /* unsupported command, generate unit check (command reject) */\n\n            s->ctrl &= ~SCSW_ACTL_START_PEND;\n\n            s->dstat = SCSW_DSTAT_UNIT_CHECK;\n\n            /* Set sense bit 0 in ecw0. */\n\n            sch->sense_data[0] = 0x80;\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= SCSW_STCTL_PRIMARY | SCSW_STCTL_SECONDARY |\n\n                    SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND;\n\n            s->cpa = sch->channel_prog + 8;\n\n            break;\n\n        case -EFAULT:\n\n            /* memory problem, generate channel data check */\n\n            s->ctrl &= ~SCSW_ACTL_START_PEND;\n\n            s->cstat = SCSW_CSTAT_DATA_CHECK;\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= SCSW_STCTL_PRIMARY | SCSW_STCTL_SECONDARY |\n\n                    SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND;\n\n            s->cpa = sch->channel_prog + 8;\n\n            break;\n\n        case -EBUSY:\n\n            /* subchannel busy, generate deferred cc 1 */\n\n            s->flags &= ~SCSW_FLAGS_MASK_CC;\n\n            s->flags |= (1 << 8);\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND;\n\n            break;\n\n        case -EINPROGRESS:\n\n            /* channel program has been suspended */\n\n            s->ctrl &= ~SCSW_ACTL_START_PEND;\n\n            s->ctrl |= SCSW_ACTL_SUSP;\n\n            break;\n\n        default:\n\n            /* error, generate channel program check */\n\n            s->ctrl &= ~SCSW_ACTL_START_PEND;\n\n            s->cstat = SCSW_CSTAT_PROG_CHECK;\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= SCSW_STCTL_PRIMARY | SCSW_STCTL_SECONDARY |\n\n                    SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND;\n\n            s->cpa = sch->channel_prog + 8;\n\n            break;\n\n        }\n\n    } while (ret == -EAGAIN);\n\n\n\n}\n", "idx": 22211}
{"project": "qemu", "commit_id": "c09f4cb2b3243085a86aee3c7ed4f31c77e4db87", "target": 0, "func": "QEMUFile *qemu_fopen_ops_buffered(MigrationState *migration_state)\n\n{\n\n    QEMUFileBuffered *s;\n\n\n\n    s = g_malloc0(sizeof(*s));\n\n\n\n    s->migration_state = migration_state;\n\n    s->xfer_limit = migration_state->bandwidth_limit / 10;\n\n\n\n    s->file = qemu_fopen_ops(s, &buffered_file_ops);\n\n\n\n    s->timer = qemu_new_timer_ms(rt_clock, buffered_rate_tick, s);\n\n\n\n    qemu_mod_timer(s->timer, qemu_get_clock_ms(rt_clock) + 100);\n\n\n\n    return s->file;\n\n}\n", "idx": 22212}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void gen_addq_lo(DisasContext *s, TCGv val, int rlow)\n\n{\n\n    TCGv tmp;\n\n    TCGv tmp2;\n\n\n\n    /* Load value and extend to 64 bits.  */\n\n    tmp = tcg_temp_new(TCG_TYPE_I64);\n\n    tmp2 = load_reg(s, rlow);\n\n    tcg_gen_extu_i32_i64(tmp, tmp2);\n\n    dead_tmp(tmp2);\n\n    tcg_gen_add_i64(val, val, tmp);\n\n}\n", "idx": 22213}
{"project": "qemu", "commit_id": "03f4995781a64e106e6f73864a1e9c4163dac53b", "target": 0, "func": "static int walk_memory_regions_1(struct walk_memory_regions_data *data,\n\n                                 abi_ulong base, int level, void **lp)\n\n{\n\n    abi_ulong pa;\n\n    int i, rc;\n\n\n\n    if (*lp == NULL) {\n\n        return walk_memory_regions_end(data, base, 0);\n\n    }\n\n\n\n    if (level == 0) {\n\n        PageDesc *pd = *lp;\n\n\n\n        for (i = 0; i < L2_SIZE; ++i) {\n\n            int prot = pd[i].flags;\n\n\n\n            pa = base | (i << TARGET_PAGE_BITS);\n\n            if (prot != data->prot) {\n\n                rc = walk_memory_regions_end(data, pa, prot);\n\n                if (rc != 0) {\n\n                    return rc;\n\n                }\n\n            }\n\n        }\n\n    } else {\n\n        void **pp = *lp;\n\n\n\n        for (i = 0; i < L2_SIZE; ++i) {\n\n            pa = base | ((abi_ulong)i <<\n\n                (TARGET_PAGE_BITS + L2_BITS * level));\n\n            rc = walk_memory_regions_1(data, pa, level - 1, pp + i);\n\n            if (rc != 0) {\n\n                return rc;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 22214}
{"project": "qemu", "commit_id": "2374e73edafff0586cbfb67c333c5a7588f81fd5", "target": 0, "func": "void helper_ldq_data(uint64_t t0, uint64_t t1)\n\n{\n\n    ldq_data(t1, t0);\n\n}\n", "idx": 22215}
{"project": "qemu", "commit_id": "c1568af597d71b2171c9b2ffffb336c2fdee205e", "target": 0, "func": "static int v9fs_do_open2(V9fsState *s, V9fsCreateState *vs)\n\n{\n\n    FsCred cred;\n\n    int flags;\n\n\n\n    cred_init(&cred);\n\n    cred.fc_uid = vs->fidp->uid;\n\n    cred.fc_mode = vs->perm & 0777;\n\n    flags = omode_to_uflags(vs->mode) | O_CREAT;\n\n\n\n    return s->ops->open2(&s->ctx, vs->fullname.data, flags, &cred);\n\n}\n", "idx": 22216}
{"project": "qemu", "commit_id": "cea5f9a28faa528b6b1b117c9ab2d8828f473fef", "target": 0, "func": "static TranslationBlock *tb_find_slow(target_ulong pc,\n\n                                      target_ulong cs_base,\n\n                                      uint64_t flags)\n\n{\n\n    TranslationBlock *tb, **ptb1;\n\n    unsigned int h;\n\n    tb_page_addr_t phys_pc, phys_page1, phys_page2;\n\n    target_ulong virt_page2;\n\n\n\n    tb_invalidated_flag = 0;\n\n\n\n    /* find translated block using physical mappings */\n\n    phys_pc = get_page_addr_code(env, pc);\n\n    phys_page1 = phys_pc & TARGET_PAGE_MASK;\n\n    phys_page2 = -1;\n\n    h = tb_phys_hash_func(phys_pc);\n\n    ptb1 = &tb_phys_hash[h];\n\n    for(;;) {\n\n        tb = *ptb1;\n\n        if (!tb)\n\n            goto not_found;\n\n        if (tb->pc == pc &&\n\n            tb->page_addr[0] == phys_page1 &&\n\n            tb->cs_base == cs_base &&\n\n            tb->flags == flags) {\n\n            /* check next page if needed */\n\n            if (tb->page_addr[1] != -1) {\n\n                virt_page2 = (pc & TARGET_PAGE_MASK) +\n\n                    TARGET_PAGE_SIZE;\n\n                phys_page2 = get_page_addr_code(env, virt_page2);\n\n                if (tb->page_addr[1] == phys_page2)\n\n                    goto found;\n\n            } else {\n\n                goto found;\n\n            }\n\n        }\n\n        ptb1 = &tb->phys_hash_next;\n\n    }\n\n not_found:\n\n   /* if no translated code available, then translate it now */\n\n    tb = tb_gen_code(env, pc, cs_base, flags, 0);\n\n\n\n found:\n\n    /* Move the last found TB to the head of the list */\n\n    if (likely(*ptb1)) {\n\n        *ptb1 = tb->phys_hash_next;\n\n        tb->phys_hash_next = tb_phys_hash[h];\n\n        tb_phys_hash[h] = tb;\n\n    }\n\n    /* we add the TB in the virtual pc hash table */\n\n    env->tb_jmp_cache[tb_jmp_cache_hash_func(pc)] = tb;\n\n    return tb;\n\n}\n", "idx": 22218}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static int megasas_init_firmware(MegasasState *s, MegasasCmd *cmd)\n\n{\n\n    uint32_t pa_hi, pa_lo;\n\n    target_phys_addr_t iq_pa, initq_size;\n\n    struct mfi_init_qinfo *initq;\n\n    uint32_t flags;\n\n    int ret = MFI_STAT_OK;\n\n\n\n    pa_lo = le32_to_cpu(cmd->frame->init.qinfo_new_addr_lo);\n\n    pa_hi = le32_to_cpu(cmd->frame->init.qinfo_new_addr_hi);\n\n    iq_pa = (((uint64_t) pa_hi << 32) | pa_lo);\n\n    trace_megasas_init_firmware((uint64_t)iq_pa);\n\n    initq_size = sizeof(*initq);\n\n    initq = cpu_physical_memory_map(iq_pa, &initq_size, 0);\n\n    if (!initq || initq_size != sizeof(*initq)) {\n\n        trace_megasas_initq_map_failed(cmd->index);\n\n        s->event_count++;\n\n        ret = MFI_STAT_MEMORY_NOT_AVAILABLE;\n\n        goto out;\n\n    }\n\n    s->reply_queue_len = le32_to_cpu(initq->rq_entries) & 0xFFFF;\n\n    if (s->reply_queue_len > s->fw_cmds) {\n\n        trace_megasas_initq_mismatch(s->reply_queue_len, s->fw_cmds);\n\n        s->event_count++;\n\n        ret = MFI_STAT_INVALID_PARAMETER;\n\n        goto out;\n\n    }\n\n    pa_lo = le32_to_cpu(initq->rq_addr_lo);\n\n    pa_hi = le32_to_cpu(initq->rq_addr_hi);\n\n    s->reply_queue_pa = ((uint64_t) pa_hi << 32) | pa_lo;\n\n    pa_lo = le32_to_cpu(initq->ci_addr_lo);\n\n    pa_hi = le32_to_cpu(initq->ci_addr_hi);\n\n    s->consumer_pa = ((uint64_t) pa_hi << 32) | pa_lo;\n\n    pa_lo = le32_to_cpu(initq->pi_addr_lo);\n\n    pa_hi = le32_to_cpu(initq->pi_addr_hi);\n\n    s->producer_pa = ((uint64_t) pa_hi << 32) | pa_lo;\n\n    s->reply_queue_head = ldl_le_phys(s->producer_pa);\n\n    s->reply_queue_tail = ldl_le_phys(s->consumer_pa);\n\n    flags = le32_to_cpu(initq->flags);\n\n    if (flags & MFI_QUEUE_FLAG_CONTEXT64) {\n\n        s->flags |= MEGASAS_MASK_USE_QUEUE64;\n\n    }\n\n    trace_megasas_init_queue((unsigned long)s->reply_queue_pa,\n\n                             s->reply_queue_len, s->reply_queue_head,\n\n                             s->reply_queue_tail, flags);\n\n    megasas_reset_frames(s);\n\n    s->fw_state = MFI_FWSTATE_OPERATIONAL;\n\nout:\n\n    if (initq) {\n\n        cpu_physical_memory_unmap(initq, initq_size, 0, 0);\n\n    }\n\n    return ret;\n\n}\n", "idx": 22219}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void pmac_ide_writel (void *opaque,\n\n                             target_phys_addr_t addr, uint32_t val)\n\n{\n\n    MACIOIDEState *d = opaque;\n\n\n\n    addr = (addr & 0xFFF) >> 4;\n\n    val = bswap32(val);\n\n    if (addr == 0) {\n\n        ide_data_writel(&d->bus, 0, val);\n\n    }\n\n}\n", "idx": 22220}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static void control_out(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    VirtQueueElement elem;\n\n    VirtIOSerial *vser;\n\n    uint8_t *buf;\n\n    size_t len;\n\n\n\n    vser = VIRTIO_SERIAL(vdev);\n\n\n\n    len = 0;\n\n    buf = NULL;\n\n    while (virtqueue_pop(vq, &elem)) {\n\n        size_t cur_len;\n\n\n\n        cur_len = iov_size(elem.out_sg, elem.out_num);\n\n        /*\n\n         * Allocate a new buf only if we didn't have one previously or\n\n         * if the size of the buf differs\n\n         */\n\n        if (cur_len > len) {\n\n            g_free(buf);\n\n\n\n            buf = g_malloc(cur_len);\n\n            len = cur_len;\n\n        }\n\n        iov_to_buf(elem.out_sg, elem.out_num, 0, buf, cur_len);\n\n\n\n        handle_control_message(vser, buf, cur_len);\n\n        virtqueue_push(vq, &elem, 0);\n\n    }\n\n    g_free(buf);\n\n    virtio_notify(vdev, vq);\n\n}\n", "idx": 22221}
{"project": "qemu", "commit_id": "d2d979c628e4b2c4a3cb71a31841875795c79043", "target": 1, "func": "static void nbd_close(BlockDriverState *bs)\n{\n    nbd_teardown_connection(bs);\n}", "idx": 22223}
{"project": "qemu", "commit_id": "e0c270d946dc8efd723129b6a9d956b3084b55b1", "target": 1, "func": "static int disas_thumb2_insn(CPUARMState *env, DisasContext *s, uint16_t insn_hw1)\n\n{\n\n    uint32_t insn, imm, shift, offset;\n\n    uint32_t rd, rn, rm, rs;\n\n    TCGv_i32 tmp;\n\n    TCGv_i32 tmp2;\n\n    TCGv_i32 tmp3;\n\n    TCGv_i32 addr;\n\n    TCGv_i64 tmp64;\n\n    int op;\n\n    int shiftop;\n\n    int conds;\n\n    int logic_cc;\n\n\n\n    if (!(arm_feature(env, ARM_FEATURE_THUMB2)\n\n          || arm_feature (env, ARM_FEATURE_M))) {\n\n        /* Thumb-1 cores may need to treat bl and blx as a pair of\n\n           16-bit instructions to get correct prefetch abort behavior.  */\n\n        insn = insn_hw1;\n\n        if ((insn & (1 << 12)) == 0) {\n\n            ARCH(5);\n\n            /* Second half of blx.  */\n\n            offset = ((insn & 0x7ff) << 1);\n\n            tmp = load_reg(s, 14);\n\n            tcg_gen_addi_i32(tmp, tmp, offset);\n\n            tcg_gen_andi_i32(tmp, tmp, 0xfffffffc);\n\n\n\n            tmp2 = tcg_temp_new_i32();\n\n            tcg_gen_movi_i32(tmp2, s->pc | 1);\n\n            store_reg(s, 14, tmp2);\n\n            gen_bx(s, tmp);\n\n            return 0;\n\n        }\n\n        if (insn & (1 << 11)) {\n\n            /* Second half of bl.  */\n\n            offset = ((insn & 0x7ff) << 1) | 1;\n\n            tmp = load_reg(s, 14);\n\n            tcg_gen_addi_i32(tmp, tmp, offset);\n\n\n\n            tmp2 = tcg_temp_new_i32();\n\n            tcg_gen_movi_i32(tmp2, s->pc | 1);\n\n            store_reg(s, 14, tmp2);\n\n            gen_bx(s, tmp);\n\n            return 0;\n\n        }\n\n        if ((s->pc & ~TARGET_PAGE_MASK) == 0) {\n\n            /* Instruction spans a page boundary.  Implement it as two\n\n               16-bit instructions in case the second half causes an\n\n               prefetch abort.  */\n\n            offset = ((int32_t)insn << 21) >> 9;\n\n            tcg_gen_movi_i32(cpu_R[14], s->pc + 2 + offset);\n\n            return 0;\n\n        }\n\n        /* Fall through to 32-bit decode.  */\n\n    }\n\n\n\n    insn = arm_lduw_code(env, s->pc, s->bswap_code);\n\n    s->pc += 2;\n\n    insn |= (uint32_t)insn_hw1 << 16;\n\n\n\n    if ((insn & 0xf800e800) != 0xf000e800) {\n\n        ARCH(6T2);\n\n    }\n\n\n\n    rn = (insn >> 16) & 0xf;\n\n    rs = (insn >> 12) & 0xf;\n\n    rd = (insn >> 8) & 0xf;\n\n    rm = insn & 0xf;\n\n    switch ((insn >> 25) & 0xf) {\n\n    case 0: case 1: case 2: case 3:\n\n        /* 16-bit instructions.  Should never happen.  */\n\n        abort();\n\n    case 4:\n\n        if (insn & (1 << 22)) {\n\n            /* Other load/store, table branch.  */\n\n            if (insn & 0x01200000) {\n\n                /* Load/store doubleword.  */\n\n                if (rn == 15) {\n\n                    addr = tcg_temp_new_i32();\n\n                    tcg_gen_movi_i32(addr, s->pc & ~3);\n\n                } else {\n\n                    addr = load_reg(s, rn);\n\n                }\n\n                offset = (insn & 0xff) * 4;\n\n                if ((insn & (1 << 23)) == 0)\n\n                    offset = -offset;\n\n                if (insn & (1 << 24)) {\n\n                    tcg_gen_addi_i32(addr, addr, offset);\n\n                    offset = 0;\n\n                }\n\n                if (insn & (1 << 20)) {\n\n                    /* ldrd */\n\n                    tmp = tcg_temp_new_i32();\n\n                    tcg_gen_qemu_ld32u(tmp, addr, IS_USER(s));\n\n                    store_reg(s, rs, tmp);\n\n                    tcg_gen_addi_i32(addr, addr, 4);\n\n                    tmp = tcg_temp_new_i32();\n\n                    tcg_gen_qemu_ld32u(tmp, addr, IS_USER(s));\n\n                    store_reg(s, rd, tmp);\n\n                } else {\n\n                    /* strd */\n\n                    tmp = load_reg(s, rs);\n\n                    tcg_gen_qemu_st32(tmp, addr, IS_USER(s));\n\n                    tcg_temp_free_i32(tmp);\n\n                    tcg_gen_addi_i32(addr, addr, 4);\n\n                    tmp = load_reg(s, rd);\n\n                    tcg_gen_qemu_st32(tmp, addr, IS_USER(s));\n\n                    tcg_temp_free_i32(tmp);\n\n                }\n\n                if (insn & (1 << 21)) {\n\n                    /* Base writeback.  */\n\n                    if (rn == 15)\n\n                        goto illegal_op;\n\n                    tcg_gen_addi_i32(addr, addr, offset - 4);\n\n                    store_reg(s, rn, addr);\n\n                } else {\n\n                    tcg_temp_free_i32(addr);\n\n                }\n\n            } else if ((insn & (1 << 23)) == 0) {\n\n                /* Load/store exclusive word.  */\n\n                addr = tcg_temp_local_new_i32();\n\n                load_reg_var(s, addr, rn);\n\n                tcg_gen_addi_i32(addr, addr, (insn & 0xff) << 2);\n\n                if (insn & (1 << 20)) {\n\n                    gen_load_exclusive(s, rs, 15, addr, 2);\n\n                } else {\n\n                    gen_store_exclusive(s, rd, rs, 15, addr, 2);\n\n                }\n\n                tcg_temp_free_i32(addr);\n\n            } else if ((insn & (7 << 5)) == 0) {\n\n                /* Table Branch.  */\n\n                if (rn == 15) {\n\n                    addr = tcg_temp_new_i32();\n\n                    tcg_gen_movi_i32(addr, s->pc);\n\n                } else {\n\n                    addr = load_reg(s, rn);\n\n                }\n\n                tmp = load_reg(s, rm);\n\n                tcg_gen_add_i32(addr, addr, tmp);\n\n                if (insn & (1 << 4)) {\n\n                    /* tbh */\n\n                    tcg_gen_add_i32(addr, addr, tmp);\n\n                    tcg_temp_free_i32(tmp);\n\n                    tmp = tcg_temp_new_i32();\n\n                    tcg_gen_qemu_ld16u(tmp, addr, IS_USER(s));\n\n                } else { /* tbb */\n\n                    tcg_temp_free_i32(tmp);\n\n                    tmp = tcg_temp_new_i32();\n\n                    tcg_gen_qemu_ld8u(tmp, addr, IS_USER(s));\n\n                }\n\n                tcg_temp_free_i32(addr);\n\n                tcg_gen_shli_i32(tmp, tmp, 1);\n\n                tcg_gen_addi_i32(tmp, tmp, s->pc);\n\n                store_reg(s, 15, tmp);\n\n            } else {\n\n                int op2 = (insn >> 6) & 0x3;\n\n                op = (insn >> 4) & 0x3;\n\n                switch (op2) {\n\n                case 0:\n\n                    goto illegal_op;\n\n                case 1:\n\n                    /* Load/store exclusive byte/halfword/doubleword */\n\n                    if (op == 2) {\n\n                        goto illegal_op;\n\n                    }\n\n                    ARCH(7);\n\n                    break;\n\n                case 2:\n\n                    /* Load-acquire/store-release */\n\n                    if (op == 3) {\n\n                        goto illegal_op;\n\n                    }\n\n                    /* Fall through */\n\n                case 3:\n\n                    /* Load-acquire/store-release exclusive */\n\n                    ARCH(8);\n\n                    break;\n\n                }\n\n                addr = tcg_temp_local_new_i32();\n\n                load_reg_var(s, addr, rn);\n\n                if (!(op2 & 1)) {\n\n                    if (insn & (1 << 20)) {\n\n                        tmp = tcg_temp_new_i32();\n\n                        switch (op) {\n\n                        case 0: /* ldab */\n\n                            tcg_gen_qemu_ld8u(tmp, addr, IS_USER(s));\n\n                            break;\n\n                        case 1: /* ldah */\n\n                            tcg_gen_qemu_ld16u(tmp, addr, IS_USER(s));\n\n                            break;\n\n                        case 2: /* lda */\n\n                            tcg_gen_qemu_ld32u(tmp, addr, IS_USER(s));\n\n                            break;\n\n                        default:\n\n                            abort();\n\n                        }\n\n                        store_reg(s, rs, tmp);\n\n                    } else {\n\n                        tmp = load_reg(s, rs);\n\n                        switch (op) {\n\n                        case 0: /* stlb */\n\n                            tcg_gen_qemu_st8(tmp, addr, IS_USER(s));\n\n                            break;\n\n                        case 1: /* stlh */\n\n                            tcg_gen_qemu_st16(tmp, addr, IS_USER(s));\n\n                            break;\n\n                        case 2: /* stl */\n\n                            tcg_gen_qemu_st32(tmp, addr, IS_USER(s));\n\n                            break;\n\n                        default:\n\n                            abort();\n\n                        }\n\n                        tcg_temp_free_i32(tmp);\n\n                    }\n\n                } else if (insn & (1 << 20)) {\n\n                    gen_load_exclusive(s, rs, rd, addr, op);\n\n                } else {\n\n                    gen_store_exclusive(s, rm, rs, rd, addr, op);\n\n                }\n\n                tcg_temp_free_i32(addr);\n\n            }\n\n        } else {\n\n            /* Load/store multiple, RFE, SRS.  */\n\n            if (((insn >> 23) & 1) == ((insn >> 24) & 1)) {\n\n                /* RFE, SRS: not available in user mode or on M profile */\n\n                if (IS_USER(s) || IS_M(env)) {\n\n                    goto illegal_op;\n\n                }\n\n                if (insn & (1 << 20)) {\n\n                    /* rfe */\n\n                    addr = load_reg(s, rn);\n\n                    if ((insn & (1 << 24)) == 0)\n\n                        tcg_gen_addi_i32(addr, addr, -8);\n\n                    /* Load PC into tmp and CPSR into tmp2.  */\n\n                    tmp = tcg_temp_new_i32();\n\n                    tcg_gen_qemu_ld32u(tmp, addr, 0);\n\n                    tcg_gen_addi_i32(addr, addr, 4);\n\n                    tmp2 = tcg_temp_new_i32();\n\n                    tcg_gen_qemu_ld32u(tmp2, addr, 0);\n\n                    if (insn & (1 << 21)) {\n\n                        /* Base writeback.  */\n\n                        if (insn & (1 << 24)) {\n\n                            tcg_gen_addi_i32(addr, addr, 4);\n\n                        } else {\n\n                            tcg_gen_addi_i32(addr, addr, -4);\n\n                        }\n\n                        store_reg(s, rn, addr);\n\n                    } else {\n\n                        tcg_temp_free_i32(addr);\n\n                    }\n\n                    gen_rfe(s, tmp, tmp2);\n\n                } else {\n\n                    /* srs */\n\n                    gen_srs(s, (insn & 0x1f), (insn & (1 << 24)) ? 1 : 2,\n\n                            insn & (1 << 21));\n\n                }\n\n            } else {\n\n                int i, loaded_base = 0;\n\n                TCGv_i32 loaded_var;\n\n                /* Load/store multiple.  */\n\n                addr = load_reg(s, rn);\n\n                offset = 0;\n\n                for (i = 0; i < 16; i++) {\n\n                    if (insn & (1 << i))\n\n                        offset += 4;\n\n                }\n\n                if (insn & (1 << 24)) {\n\n                    tcg_gen_addi_i32(addr, addr, -offset);\n\n                }\n\n\n\n                TCGV_UNUSED_I32(loaded_var);\n\n                for (i = 0; i < 16; i++) {\n\n                    if ((insn & (1 << i)) == 0)\n\n                        continue;\n\n                    if (insn & (1 << 20)) {\n\n                        /* Load.  */\n\n                        tmp = tcg_temp_new_i32();\n\n                        tcg_gen_qemu_ld32u(tmp, addr, IS_USER(s));\n\n                        if (i == 15) {\n\n                            gen_bx(s, tmp);\n\n                        } else if (i == rn) {\n\n                            loaded_var = tmp;\n\n                            loaded_base = 1;\n\n                        } else {\n\n                            store_reg(s, i, tmp);\n\n                        }\n\n                    } else {\n\n                        /* Store.  */\n\n                        tmp = load_reg(s, i);\n\n                        tcg_gen_qemu_st32(tmp, addr, IS_USER(s));\n\n                        tcg_temp_free_i32(tmp);\n\n                    }\n\n                    tcg_gen_addi_i32(addr, addr, 4);\n\n                }\n\n                if (loaded_base) {\n\n                    store_reg(s, rn, loaded_var);\n\n                }\n\n                if (insn & (1 << 21)) {\n\n                    /* Base register writeback.  */\n\n                    if (insn & (1 << 24)) {\n\n                        tcg_gen_addi_i32(addr, addr, -offset);\n\n                    }\n\n                    /* Fault if writeback register is in register list.  */\n\n                    if (insn & (1 << rn))\n\n                        goto illegal_op;\n\n                    store_reg(s, rn, addr);\n\n                } else {\n\n                    tcg_temp_free_i32(addr);\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    case 5:\n\n\n\n        op = (insn >> 21) & 0xf;\n\n        if (op == 6) {\n\n            /* Halfword pack.  */\n\n            tmp = load_reg(s, rn);\n\n            tmp2 = load_reg(s, rm);\n\n            shift = ((insn >> 10) & 0x1c) | ((insn >> 6) & 0x3);\n\n            if (insn & (1 << 5)) {\n\n                /* pkhtb */\n\n                if (shift == 0)\n\n                    shift = 31;\n\n                tcg_gen_sari_i32(tmp2, tmp2, shift);\n\n                tcg_gen_andi_i32(tmp, tmp, 0xffff0000);\n\n                tcg_gen_ext16u_i32(tmp2, tmp2);\n\n            } else {\n\n                /* pkhbt */\n\n                if (shift)\n\n                    tcg_gen_shli_i32(tmp2, tmp2, shift);\n\n                tcg_gen_ext16u_i32(tmp, tmp);\n\n                tcg_gen_andi_i32(tmp2, tmp2, 0xffff0000);\n\n            }\n\n            tcg_gen_or_i32(tmp, tmp, tmp2);\n\n            tcg_temp_free_i32(tmp2);\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            /* Data processing register constant shift.  */\n\n            if (rn == 15) {\n\n                tmp = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(tmp, 0);\n\n            } else {\n\n                tmp = load_reg(s, rn);\n\n            }\n\n            tmp2 = load_reg(s, rm);\n\n\n\n            shiftop = (insn >> 4) & 3;\n\n            shift = ((insn >> 6) & 3) | ((insn >> 10) & 0x1c);\n\n            conds = (insn & (1 << 20)) != 0;\n\n            logic_cc = (conds && thumb2_logic_op(op));\n\n            gen_arm_shift_im(tmp2, shiftop, shift, logic_cc);\n\n            if (gen_thumb2_data_op(s, op, conds, 0, tmp, tmp2))\n\n                goto illegal_op;\n\n            tcg_temp_free_i32(tmp2);\n\n            if (rd != 15) {\n\n                store_reg(s, rd, tmp);\n\n            } else {\n\n                tcg_temp_free_i32(tmp);\n\n            }\n\n        }\n\n        break;\n\n    case 13: /* Misc data processing.  */\n\n        op = ((insn >> 22) & 6) | ((insn >> 7) & 1);\n\n        if (op < 4 && (insn & 0xf000) != 0xf000)\n\n            goto illegal_op;\n\n        switch (op) {\n\n        case 0: /* Register controlled shift.  */\n\n            tmp = load_reg(s, rn);\n\n            tmp2 = load_reg(s, rm);\n\n            if ((insn & 0x70) != 0)\n\n                goto illegal_op;\n\n            op = (insn >> 21) & 3;\n\n            logic_cc = (insn & (1 << 20)) != 0;\n\n            gen_arm_shift_reg(tmp, op, tmp2, logic_cc);\n\n            if (logic_cc)\n\n                gen_logic_CC(tmp);\n\n            store_reg_bx(env, s, rd, tmp);\n\n            break;\n\n        case 1: /* Sign/zero extend.  */\n\n            tmp = load_reg(s, rm);\n\n            shift = (insn >> 4) & 3;\n\n            /* ??? In many cases it's not necessary to do a\n\n               rotate, a shift is sufficient.  */\n\n            if (shift != 0)\n\n                tcg_gen_rotri_i32(tmp, tmp, shift * 8);\n\n            op = (insn >> 20) & 7;\n\n            switch (op) {\n\n            case 0: gen_sxth(tmp);   break;\n\n            case 1: gen_uxth(tmp);   break;\n\n            case 2: gen_sxtb16(tmp); break;\n\n            case 3: gen_uxtb16(tmp); break;\n\n            case 4: gen_sxtb(tmp);   break;\n\n            case 5: gen_uxtb(tmp);   break;\n\n            default: goto illegal_op;\n\n            }\n\n            if (rn != 15) {\n\n                tmp2 = load_reg(s, rn);\n\n                if ((op >> 1) == 1) {\n\n                    gen_add16(tmp, tmp2);\n\n                } else {\n\n                    tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                    tcg_temp_free_i32(tmp2);\n\n                }\n\n            }\n\n            store_reg(s, rd, tmp);\n\n            break;\n\n        case 2: /* SIMD add/subtract.  */\n\n            op = (insn >> 20) & 7;\n\n            shift = (insn >> 4) & 7;\n\n            if ((op & 3) == 3 || (shift & 3) == 3)\n\n                goto illegal_op;\n\n            tmp = load_reg(s, rn);\n\n            tmp2 = load_reg(s, rm);\n\n            gen_thumb2_parallel_addsub(op, shift, tmp, tmp2);\n\n            tcg_temp_free_i32(tmp2);\n\n            store_reg(s, rd, tmp);\n\n            break;\n\n        case 3: /* Other data processing.  */\n\n            op = ((insn >> 17) & 0x38) | ((insn >> 4) & 7);\n\n            if (op < 4) {\n\n                /* Saturating add/subtract.  */\n\n                tmp = load_reg(s, rn);\n\n                tmp2 = load_reg(s, rm);\n\n                if (op & 1)\n\n                    gen_helper_double_saturate(tmp, cpu_env, tmp);\n\n                if (op & 2)\n\n                    gen_helper_sub_saturate(tmp, cpu_env, tmp2, tmp);\n\n                else\n\n                    gen_helper_add_saturate(tmp, cpu_env, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp2);\n\n            } else {\n\n                tmp = load_reg(s, rn);\n\n                switch (op) {\n\n                case 0x0a: /* rbit */\n\n                    gen_helper_rbit(tmp, tmp);\n\n                    break;\n\n                case 0x08: /* rev */\n\n                    tcg_gen_bswap32_i32(tmp, tmp);\n\n                    break;\n\n                case 0x09: /* rev16 */\n\n                    gen_rev16(tmp);\n\n                    break;\n\n                case 0x0b: /* revsh */\n\n                    gen_revsh(tmp);\n\n                    break;\n\n                case 0x10: /* sel */\n\n                    tmp2 = load_reg(s, rm);\n\n                    tmp3 = tcg_temp_new_i32();\n\n                    tcg_gen_ld_i32(tmp3, cpu_env, offsetof(CPUARMState, GE));\n\n                    gen_helper_sel_flags(tmp, tmp3, tmp, tmp2);\n\n                    tcg_temp_free_i32(tmp3);\n\n                    tcg_temp_free_i32(tmp2);\n\n                    break;\n\n                case 0x18: /* clz */\n\n                    gen_helper_clz(tmp, tmp);\n\n                    break;\n\n                default:\n\n                    goto illegal_op;\n\n                }\n\n            }\n\n            store_reg(s, rd, tmp);\n\n            break;\n\n        case 4: case 5: /* 32-bit multiply.  Sum of absolute differences.  */\n\n            op = (insn >> 4) & 0xf;\n\n            tmp = load_reg(s, rn);\n\n            tmp2 = load_reg(s, rm);\n\n            switch ((insn >> 20) & 7) {\n\n            case 0: /* 32 x 32 -> 32 */\n\n                tcg_gen_mul_i32(tmp, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp2);\n\n                if (rs != 15) {\n\n                    tmp2 = load_reg(s, rs);\n\n                    if (op)\n\n                        tcg_gen_sub_i32(tmp, tmp2, tmp);\n\n                    else\n\n                        tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                    tcg_temp_free_i32(tmp2);\n\n                }\n\n                break;\n\n            case 1: /* 16 x 16 -> 32 */\n\n                gen_mulxy(tmp, tmp2, op & 2, op & 1);\n\n                tcg_temp_free_i32(tmp2);\n\n                if (rs != 15) {\n\n                    tmp2 = load_reg(s, rs);\n\n                    gen_helper_add_setq(tmp, cpu_env, tmp, tmp2);\n\n                    tcg_temp_free_i32(tmp2);\n\n                }\n\n                break;\n\n            case 2: /* Dual multiply add.  */\n\n            case 4: /* Dual multiply subtract.  */\n\n                if (op)\n\n                    gen_swap_half(tmp2);\n\n                gen_smul_dual(tmp, tmp2);\n\n                if (insn & (1 << 22)) {\n\n                    /* This subtraction cannot overflow. */\n\n                    tcg_gen_sub_i32(tmp, tmp, tmp2);\n\n                } else {\n\n                    /* This addition cannot overflow 32 bits;\n\n                     * however it may overflow considered as a signed\n\n                     * operation, in which case we must set the Q flag.\n\n                     */\n\n                    gen_helper_add_setq(tmp, cpu_env, tmp, tmp2);\n\n                }\n\n                tcg_temp_free_i32(tmp2);\n\n                if (rs != 15)\n\n                  {\n\n                    tmp2 = load_reg(s, rs);\n\n                    gen_helper_add_setq(tmp, cpu_env, tmp, tmp2);\n\n                    tcg_temp_free_i32(tmp2);\n\n                  }\n\n                break;\n\n            case 3: /* 32 * 16 -> 32msb */\n\n                if (op)\n\n                    tcg_gen_sari_i32(tmp2, tmp2, 16);\n\n                else\n\n                    gen_sxth(tmp2);\n\n                tmp64 = gen_muls_i64_i32(tmp, tmp2);\n\n                tcg_gen_shri_i64(tmp64, tmp64, 16);\n\n                tmp = tcg_temp_new_i32();\n\n                tcg_gen_trunc_i64_i32(tmp, tmp64);\n\n                tcg_temp_free_i64(tmp64);\n\n                if (rs != 15)\n\n                  {\n\n                    tmp2 = load_reg(s, rs);\n\n                    gen_helper_add_setq(tmp, cpu_env, tmp, tmp2);\n\n                    tcg_temp_free_i32(tmp2);\n\n                  }\n\n                break;\n\n            case 5: case 6: /* 32 * 32 -> 32msb (SMMUL, SMMLA, SMMLS) */\n\n                tmp64 = gen_muls_i64_i32(tmp, tmp2);\n\n                if (rs != 15) {\n\n                    tmp = load_reg(s, rs);\n\n                    if (insn & (1 << 20)) {\n\n                        tmp64 = gen_addq_msw(tmp64, tmp);\n\n                    } else {\n\n                        tmp64 = gen_subq_msw(tmp64, tmp);\n\n                    }\n\n                }\n\n                if (insn & (1 << 4)) {\n\n                    tcg_gen_addi_i64(tmp64, tmp64, 0x80000000u);\n\n                }\n\n                tcg_gen_shri_i64(tmp64, tmp64, 32);\n\n                tmp = tcg_temp_new_i32();\n\n                tcg_gen_trunc_i64_i32(tmp, tmp64);\n\n                tcg_temp_free_i64(tmp64);\n\n                break;\n\n            case 7: /* Unsigned sum of absolute differences.  */\n\n                gen_helper_usad8(tmp, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp2);\n\n                if (rs != 15) {\n\n                    tmp2 = load_reg(s, rs);\n\n                    tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                    tcg_temp_free_i32(tmp2);\n\n                }\n\n                break;\n\n            }\n\n            store_reg(s, rd, tmp);\n\n            break;\n\n        case 6: case 7: /* 64-bit multiply, Divide.  */\n\n            op = ((insn >> 4) & 0xf) | ((insn >> 16) & 0x70);\n\n            tmp = load_reg(s, rn);\n\n            tmp2 = load_reg(s, rm);\n\n            if ((op & 0x50) == 0x10) {\n\n                /* sdiv, udiv */\n\n                if (!arm_feature(env, ARM_FEATURE_THUMB_DIV)) {\n\n                    goto illegal_op;\n\n                }\n\n                if (op & 0x20)\n\n                    gen_helper_udiv(tmp, tmp, tmp2);\n\n                else\n\n                    gen_helper_sdiv(tmp, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp2);\n\n                store_reg(s, rd, tmp);\n\n            } else if ((op & 0xe) == 0xc) {\n\n                /* Dual multiply accumulate long.  */\n\n                if (op & 1)\n\n                    gen_swap_half(tmp2);\n\n                gen_smul_dual(tmp, tmp2);\n\n                if (op & 0x10) {\n\n                    tcg_gen_sub_i32(tmp, tmp, tmp2);\n\n                } else {\n\n                    tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                }\n\n                tcg_temp_free_i32(tmp2);\n\n                /* BUGFIX */\n\n                tmp64 = tcg_temp_new_i64();\n\n                tcg_gen_ext_i32_i64(tmp64, tmp);\n\n                tcg_temp_free_i32(tmp);\n\n                gen_addq(s, tmp64, rs, rd);\n\n                gen_storeq_reg(s, rs, rd, tmp64);\n\n                tcg_temp_free_i64(tmp64);\n\n            } else {\n\n                if (op & 0x20) {\n\n                    /* Unsigned 64-bit multiply  */\n\n                    tmp64 = gen_mulu_i64_i32(tmp, tmp2);\n\n                } else {\n\n                    if (op & 8) {\n\n                        /* smlalxy */\n\n                        gen_mulxy(tmp, tmp2, op & 2, op & 1);\n\n                        tcg_temp_free_i32(tmp2);\n\n                        tmp64 = tcg_temp_new_i64();\n\n                        tcg_gen_ext_i32_i64(tmp64, tmp);\n\n                        tcg_temp_free_i32(tmp);\n\n                    } else {\n\n                        /* Signed 64-bit multiply  */\n\n                        tmp64 = gen_muls_i64_i32(tmp, tmp2);\n\n                    }\n\n                }\n\n                if (op & 4) {\n\n                    /* umaal */\n\n                    gen_addq_lo(s, tmp64, rs);\n\n                    gen_addq_lo(s, tmp64, rd);\n\n                } else if (op & 0x40) {\n\n                    /* 64-bit accumulate.  */\n\n                    gen_addq(s, tmp64, rs, rd);\n\n                }\n\n                gen_storeq_reg(s, rs, rd, tmp64);\n\n                tcg_temp_free_i64(tmp64);\n\n            }\n\n            break;\n\n        }\n\n        break;\n\n    case 6: case 7: case 14: case 15:\n\n        /* Coprocessor.  */\n\n        if (((insn >> 24) & 3) == 3) {\n\n            /* Translate into the equivalent ARM encoding.  */\n\n            insn = (insn & 0xe2ffffff) | ((insn & (1 << 28)) >> 4) | (1 << 28);\n\n            if (disas_neon_data_insn(env, s, insn))\n\n                goto illegal_op;\n\n        } else {\n\n            if (insn & (1 << 28))\n\n                goto illegal_op;\n\n            if (disas_coproc_insn (env, s, insn))\n\n                goto illegal_op;\n\n        }\n\n        break;\n\n    case 8: case 9: case 10: case 11:\n\n        if (insn & (1 << 15)) {\n\n            /* Branches, misc control.  */\n\n            if (insn & 0x5000) {\n\n                /* Unconditional branch.  */\n\n                /* signextend(hw1[10:0]) -> offset[:12].  */\n\n                offset = ((int32_t)insn << 5) >> 9 & ~(int32_t)0xfff;\n\n                /* hw1[10:0] -> offset[11:1].  */\n\n                offset |= (insn & 0x7ff) << 1;\n\n                /* (~hw2[13, 11] ^ offset[24]) -> offset[23,22]\n\n                   offset[24:22] already have the same value because of the\n\n                   sign extension above.  */\n\n                offset ^= ((~insn) & (1 << 13)) << 10;\n\n                offset ^= ((~insn) & (1 << 11)) << 11;\n\n\n\n                if (insn & (1 << 14)) {\n\n                    /* Branch and link.  */\n\n                    tcg_gen_movi_i32(cpu_R[14], s->pc | 1);\n\n                }\n\n\n\n                offset += s->pc;\n\n                if (insn & (1 << 12)) {\n\n                    /* b/bl */\n\n                    gen_jmp(s, offset);\n\n                } else {\n\n                    /* blx */\n\n                    offset &= ~(uint32_t)2;\n\n                    /* thumb2 bx, no need to check */\n\n                    gen_bx_im(s, offset);\n\n                }\n\n            } else if (((insn >> 23) & 7) == 7) {\n\n                /* Misc control */\n\n                if (insn & (1 << 13))\n\n                    goto illegal_op;\n\n\n\n                if (insn & (1 << 26)) {\n\n                    /* Secure monitor call (v6Z) */\n\n\n\n                    goto illegal_op; /* not implemented.  */\n\n                } else {\n\n                    op = (insn >> 20) & 7;\n\n                    switch (op) {\n\n                    case 0: /* msr cpsr.  */\n\n                        if (IS_M(env)) {\n\n                            tmp = load_reg(s, rn);\n\n                            addr = tcg_const_i32(insn & 0xff);\n\n                            gen_helper_v7m_msr(cpu_env, addr, tmp);\n\n                            tcg_temp_free_i32(addr);\n\n                            tcg_temp_free_i32(tmp);\n\n                            gen_lookup_tb(s);\n\n                            break;\n\n                        }\n\n                        /* fall through */\n\n                    case 1: /* msr spsr.  */\n\n                        if (IS_M(env))\n\n                            goto illegal_op;\n\n                        tmp = load_reg(s, rn);\n\n                        if (gen_set_psr(s,\n\n                              msr_mask(env, s, (insn >> 8) & 0xf, op == 1),\n\n                              op == 1, tmp))\n\n                            goto illegal_op;\n\n                        break;\n\n                    case 2: /* cps, nop-hint.  */\n\n                        if (((insn >> 8) & 7) == 0) {\n\n                            gen_nop_hint(s, insn & 0xff);\n\n                        }\n\n                        /* Implemented as NOP in user mode.  */\n\n                        if (IS_USER(s))\n\n                            break;\n\n                        offset = 0;\n\n                        imm = 0;\n\n                        if (insn & (1 << 10)) {\n\n                            if (insn & (1 << 7))\n\n                                offset |= CPSR_A;\n\n                            if (insn & (1 << 6))\n\n                                offset |= CPSR_I;\n\n                            if (insn & (1 << 5))\n\n                                offset |= CPSR_F;\n\n                            if (insn & (1 << 9))\n\n                                imm = CPSR_A | CPSR_I | CPSR_F;\n\n                        }\n\n                        if (insn & (1 << 8)) {\n\n                            offset |= 0x1f;\n\n                            imm |= (insn & 0x1f);\n\n                        }\n\n                        if (offset) {\n\n                            gen_set_psr_im(s, offset, 0, imm);\n\n                        }\n\n                        break;\n\n                    case 3: /* Special control operations.  */\n\n                        ARCH(7);\n\n                        op = (insn >> 4) & 0xf;\n\n                        switch (op) {\n\n                        case 2: /* clrex */\n\n                            gen_clrex(s);\n\n                            break;\n\n                        case 4: /* dsb */\n\n                        case 5: /* dmb */\n\n                        case 6: /* isb */\n\n                            /* These execute as NOPs.  */\n\n                            break;\n\n                        default:\n\n                            goto illegal_op;\n\n                        }\n\n                        break;\n\n                    case 4: /* bxj */\n\n                        /* Trivial implementation equivalent to bx.  */\n\n                        tmp = load_reg(s, rn);\n\n                        gen_bx(s, tmp);\n\n                        break;\n\n                    case 5: /* Exception return.  */\n\n                        if (IS_USER(s)) {\n\n                            goto illegal_op;\n\n                        }\n\n                        if (rn != 14 || rd != 15) {\n\n                            goto illegal_op;\n\n                        }\n\n                        tmp = load_reg(s, rn);\n\n                        tcg_gen_subi_i32(tmp, tmp, insn & 0xff);\n\n                        gen_exception_return(s, tmp);\n\n                        break;\n\n                    case 6: /* mrs cpsr.  */\n\n                        tmp = tcg_temp_new_i32();\n\n                        if (IS_M(env)) {\n\n                            addr = tcg_const_i32(insn & 0xff);\n\n                            gen_helper_v7m_mrs(tmp, cpu_env, addr);\n\n                            tcg_temp_free_i32(addr);\n\n                        } else {\n\n                            gen_helper_cpsr_read(tmp, cpu_env);\n\n                        }\n\n                        store_reg(s, rd, tmp);\n\n                        break;\n\n                    case 7: /* mrs spsr.  */\n\n                        /* Not accessible in user mode.  */\n\n                        if (IS_USER(s) || IS_M(env))\n\n                            goto illegal_op;\n\n                        tmp = load_cpu_field(spsr);\n\n                        store_reg(s, rd, tmp);\n\n                        break;\n\n                    }\n\n                }\n\n            } else {\n\n                /* Conditional branch.  */\n\n                op = (insn >> 22) & 0xf;\n\n                /* Generate a conditional jump to next instruction.  */\n\n                s->condlabel = gen_new_label();\n\n                gen_test_cc(op ^ 1, s->condlabel);\n\n                s->condjmp = 1;\n\n\n\n                /* offset[11:1] = insn[10:0] */\n\n                offset = (insn & 0x7ff) << 1;\n\n                /* offset[17:12] = insn[21:16].  */\n\n                offset |= (insn & 0x003f0000) >> 4;\n\n                /* offset[31:20] = insn[26].  */\n\n                offset |= ((int32_t)((insn << 5) & 0x80000000)) >> 11;\n\n                /* offset[18] = insn[13].  */\n\n                offset |= (insn & (1 << 13)) << 5;\n\n                /* offset[19] = insn[11].  */\n\n                offset |= (insn & (1 << 11)) << 8;\n\n\n\n                /* jump to the offset */\n\n                gen_jmp(s, s->pc + offset);\n\n            }\n\n        } else {\n\n            /* Data processing immediate.  */\n\n            if (insn & (1 << 25)) {\n\n                if (insn & (1 << 24)) {\n\n                    if (insn & (1 << 20))\n\n                        goto illegal_op;\n\n                    /* Bitfield/Saturate.  */\n\n                    op = (insn >> 21) & 7;\n\n                    imm = insn & 0x1f;\n\n                    shift = ((insn >> 6) & 3) | ((insn >> 10) & 0x1c);\n\n                    if (rn == 15) {\n\n                        tmp = tcg_temp_new_i32();\n\n                        tcg_gen_movi_i32(tmp, 0);\n\n                    } else {\n\n                        tmp = load_reg(s, rn);\n\n                    }\n\n                    switch (op) {\n\n                    case 2: /* Signed bitfield extract.  */\n\n                        imm++;\n\n                        if (shift + imm > 32)\n\n                            goto illegal_op;\n\n                        if (imm < 32)\n\n                            gen_sbfx(tmp, shift, imm);\n\n                        break;\n\n                    case 6: /* Unsigned bitfield extract.  */\n\n                        imm++;\n\n                        if (shift + imm > 32)\n\n                            goto illegal_op;\n\n                        if (imm < 32)\n\n                            gen_ubfx(tmp, shift, (1u << imm) - 1);\n\n                        break;\n\n                    case 3: /* Bitfield insert/clear.  */\n\n                        if (imm < shift)\n\n                            goto illegal_op;\n\n                        imm = imm + 1 - shift;\n\n                        if (imm != 32) {\n\n                            tmp2 = load_reg(s, rd);\n\n                            tcg_gen_deposit_i32(tmp, tmp2, tmp, shift, imm);\n\n                            tcg_temp_free_i32(tmp2);\n\n                        }\n\n                        break;\n\n                    case 7:\n\n                        goto illegal_op;\n\n                    default: /* Saturate.  */\n\n                        if (shift) {\n\n                            if (op & 1)\n\n                                tcg_gen_sari_i32(tmp, tmp, shift);\n\n                            else\n\n                                tcg_gen_shli_i32(tmp, tmp, shift);\n\n                        }\n\n                        tmp2 = tcg_const_i32(imm);\n\n                        if (op & 4) {\n\n                            /* Unsigned.  */\n\n                            if ((op & 1) && shift == 0)\n\n                                gen_helper_usat16(tmp, cpu_env, tmp, tmp2);\n\n                            else\n\n                                gen_helper_usat(tmp, cpu_env, tmp, tmp2);\n\n                        } else {\n\n                            /* Signed.  */\n\n                            if ((op & 1) && shift == 0)\n\n                                gen_helper_ssat16(tmp, cpu_env, tmp, tmp2);\n\n                            else\n\n                                gen_helper_ssat(tmp, cpu_env, tmp, tmp2);\n\n                        }\n\n                        tcg_temp_free_i32(tmp2);\n\n                        break;\n\n                    }\n\n                    store_reg(s, rd, tmp);\n\n                } else {\n\n                    imm = ((insn & 0x04000000) >> 15)\n\n                          | ((insn & 0x7000) >> 4) | (insn & 0xff);\n\n                    if (insn & (1 << 22)) {\n\n                        /* 16-bit immediate.  */\n\n                        imm |= (insn >> 4) & 0xf000;\n\n                        if (insn & (1 << 23)) {\n\n                            /* movt */\n\n                            tmp = load_reg(s, rd);\n\n                            tcg_gen_ext16u_i32(tmp, tmp);\n\n                            tcg_gen_ori_i32(tmp, tmp, imm << 16);\n\n                        } else {\n\n                            /* movw */\n\n                            tmp = tcg_temp_new_i32();\n\n                            tcg_gen_movi_i32(tmp, imm);\n\n                        }\n\n                    } else {\n\n                        /* Add/sub 12-bit immediate.  */\n\n                        if (rn == 15) {\n\n                            offset = s->pc & ~(uint32_t)3;\n\n                            if (insn & (1 << 23))\n\n                                offset -= imm;\n\n                            else\n\n                                offset += imm;\n\n                            tmp = tcg_temp_new_i32();\n\n                            tcg_gen_movi_i32(tmp, offset);\n\n                        } else {\n\n                            tmp = load_reg(s, rn);\n\n                            if (insn & (1 << 23))\n\n                                tcg_gen_subi_i32(tmp, tmp, imm);\n\n                            else\n\n                                tcg_gen_addi_i32(tmp, tmp, imm);\n\n                        }\n\n                    }\n\n                    store_reg(s, rd, tmp);\n\n                }\n\n            } else {\n\n                int shifter_out = 0;\n\n                /* modified 12-bit immediate.  */\n\n                shift = ((insn & 0x04000000) >> 23) | ((insn & 0x7000) >> 12);\n\n                imm = (insn & 0xff);\n\n                switch (shift) {\n\n                case 0: /* XY */\n\n                    /* Nothing to do.  */\n\n                    break;\n\n                case 1: /* 00XY00XY */\n\n                    imm |= imm << 16;\n\n                    break;\n\n                case 2: /* XY00XY00 */\n\n                    imm |= imm << 16;\n\n                    imm <<= 8;\n\n                    break;\n\n                case 3: /* XYXYXYXY */\n\n                    imm |= imm << 16;\n\n                    imm |= imm << 8;\n\n                    break;\n\n                default: /* Rotated constant.  */\n\n                    shift = (shift << 1) | (imm >> 7);\n\n                    imm |= 0x80;\n\n                    imm = imm << (32 - shift);\n\n                    shifter_out = 1;\n\n                    break;\n\n                }\n\n                tmp2 = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(tmp2, imm);\n\n                rn = (insn >> 16) & 0xf;\n\n                if (rn == 15) {\n\n                    tmp = tcg_temp_new_i32();\n\n                    tcg_gen_movi_i32(tmp, 0);\n\n                } else {\n\n                    tmp = load_reg(s, rn);\n\n                }\n\n                op = (insn >> 21) & 0xf;\n\n                if (gen_thumb2_data_op(s, op, (insn & (1 << 20)) != 0,\n\n                                       shifter_out, tmp, tmp2))\n\n                    goto illegal_op;\n\n                tcg_temp_free_i32(tmp2);\n\n                rd = (insn >> 8) & 0xf;\n\n                if (rd != 15) {\n\n                    store_reg(s, rd, tmp);\n\n                } else {\n\n                    tcg_temp_free_i32(tmp);\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    case 12: /* Load/store single data item.  */\n\n        {\n\n        int postinc = 0;\n\n        int writeback = 0;\n\n        int user;\n\n        if ((insn & 0x01100000) == 0x01000000) {\n\n            if (disas_neon_ls_insn(env, s, insn))\n\n                goto illegal_op;\n\n            break;\n\n        }\n\n        op = ((insn >> 21) & 3) | ((insn >> 22) & 4);\n\n        if (rs == 15) {\n\n            if (!(insn & (1 << 20))) {\n\n                goto illegal_op;\n\n            }\n\n            if (op != 2) {\n\n                /* Byte or halfword load space with dest == r15 : memory hints.\n\n                 * Catch them early so we don't emit pointless addressing code.\n\n                 * This space is a mix of:\n\n                 *  PLD/PLDW/PLI,  which we implement as NOPs (note that unlike\n\n                 *     the ARM encodings, PLDW space doesn't UNDEF for non-v7MP\n\n                 *     cores)\n\n                 *  unallocated hints, which must be treated as NOPs\n\n                 *  UNPREDICTABLE space, which we NOP or UNDEF depending on\n\n                 *     which is easiest for the decoding logic\n\n                 *  Some space which must UNDEF\n\n                 */\n\n                int op1 = (insn >> 23) & 3;\n\n                int op2 = (insn >> 6) & 0x3f;\n\n                if (op & 2) {\n\n                    goto illegal_op;\n\n                }\n\n                if (rn == 15) {\n\n                    /* UNPREDICTABLE, unallocated hint or\n\n                     * PLD/PLDW/PLI (literal)\n\n                     */\n\n                    return 0;\n\n                }\n\n                if (op1 & 1) {\n\n                    return 0; /* PLD/PLDW/PLI or unallocated hint */\n\n                }\n\n                if ((op2 == 0) || ((op2 & 0x3c) == 0x30)) {\n\n                    return 0; /* PLD/PLDW/PLI or unallocated hint */\n\n                }\n\n                /* UNDEF space, or an UNPREDICTABLE */\n\n                return 1;\n\n            }\n\n        }\n\n        user = IS_USER(s);\n\n        if (rn == 15) {\n\n            addr = tcg_temp_new_i32();\n\n            /* PC relative.  */\n\n            /* s->pc has already been incremented by 4.  */\n\n            imm = s->pc & 0xfffffffc;\n\n            if (insn & (1 << 23))\n\n                imm += insn & 0xfff;\n\n            else\n\n                imm -= insn & 0xfff;\n\n            tcg_gen_movi_i32(addr, imm);\n\n        } else {\n\n            addr = load_reg(s, rn);\n\n            if (insn & (1 << 23)) {\n\n                /* Positive offset.  */\n\n                imm = insn & 0xfff;\n\n                tcg_gen_addi_i32(addr, addr, imm);\n\n            } else {\n\n                imm = insn & 0xff;\n\n                switch ((insn >> 8) & 0xf) {\n\n                case 0x0: /* Shifted Register.  */\n\n                    shift = (insn >> 4) & 0xf;\n\n                    if (shift > 3) {\n\n                        tcg_temp_free_i32(addr);\n\n                        goto illegal_op;\n\n                    }\n\n                    tmp = load_reg(s, rm);\n\n                    if (shift)\n\n                        tcg_gen_shli_i32(tmp, tmp, shift);\n\n                    tcg_gen_add_i32(addr, addr, tmp);\n\n                    tcg_temp_free_i32(tmp);\n\n                    break;\n\n                case 0xc: /* Negative offset.  */\n\n                    tcg_gen_addi_i32(addr, addr, -imm);\n\n                    break;\n\n                case 0xe: /* User privilege.  */\n\n                    tcg_gen_addi_i32(addr, addr, imm);\n\n                    user = 1;\n\n                    break;\n\n                case 0x9: /* Post-decrement.  */\n\n                    imm = -imm;\n\n                    /* Fall through.  */\n\n                case 0xb: /* Post-increment.  */\n\n                    postinc = 1;\n\n                    writeback = 1;\n\n                    break;\n\n                case 0xd: /* Pre-decrement.  */\n\n                    imm = -imm;\n\n                    /* Fall through.  */\n\n                case 0xf: /* Pre-increment.  */\n\n                    tcg_gen_addi_i32(addr, addr, imm);\n\n                    writeback = 1;\n\n                    break;\n\n                default:\n\n                    tcg_temp_free_i32(addr);\n\n                    goto illegal_op;\n\n                }\n\n            }\n\n        }\n\n        if (insn & (1 << 20)) {\n\n            /* Load.  */\n\n            tmp = tcg_temp_new_i32();\n\n            switch (op) {\n\n            case 0:\n\n                tcg_gen_qemu_ld8u(tmp, addr, user);\n\n                break;\n\n            case 4:\n\n                tcg_gen_qemu_ld8s(tmp, addr, user);\n\n                break;\n\n            case 1:\n\n                tcg_gen_qemu_ld16u(tmp, addr, user);\n\n                break;\n\n            case 5:\n\n                tcg_gen_qemu_ld16s(tmp, addr, user);\n\n                break;\n\n            case 2:\n\n                tcg_gen_qemu_ld32u(tmp, addr, user);\n\n                break;\n\n            default:\n\n                tcg_temp_free_i32(tmp);\n\n                tcg_temp_free_i32(addr);\n\n                goto illegal_op;\n\n            }\n\n            if (rs == 15) {\n\n                gen_bx(s, tmp);\n\n            } else {\n\n                store_reg(s, rs, tmp);\n\n            }\n\n        } else {\n\n            /* Store.  */\n\n            tmp = load_reg(s, rs);\n\n            switch (op) {\n\n            case 0:\n\n                tcg_gen_qemu_st8(tmp, addr, user);\n\n                break;\n\n            case 1:\n\n                tcg_gen_qemu_st16(tmp, addr, user);\n\n                break;\n\n            case 2:\n\n                tcg_gen_qemu_st32(tmp, addr, user);\n\n                break;\n\n            default:\n\n                tcg_temp_free_i32(tmp);\n\n                tcg_temp_free_i32(addr);\n\n                goto illegal_op;\n\n            }\n\n            tcg_temp_free_i32(tmp);\n\n        }\n\n        if (postinc)\n\n            tcg_gen_addi_i32(addr, addr, imm);\n\n        if (writeback) {\n\n            store_reg(s, rn, addr);\n\n        } else {\n\n            tcg_temp_free_i32(addr);\n\n        }\n\n        }\n\n        break;\n\n    default:\n\n        goto illegal_op;\n\n    }\n\n    return 0;\n\nillegal_op:\n\n    return 1;\n\n}", "idx": 22224}
{"project": "qemu", "commit_id": "aa4a3dce1c88ed51b616806b8214b7c8428b7470", "target": 1, "func": "static void vmxnet3_handle_command(VMXNET3State *s, uint64_t cmd)\n\n{\n\n    s->last_command = cmd;\n\n\n\n    switch (cmd) {\n\n    case VMXNET3_CMD_GET_PERM_MAC_HI:\n\n        VMW_CBPRN(\"Set: Get upper part of permanent MAC\");\n\n        break;\n\n\n\n    case VMXNET3_CMD_GET_PERM_MAC_LO:\n\n        VMW_CBPRN(\"Set: Get lower part of permanent MAC\");\n\n        break;\n\n\n\n    case VMXNET3_CMD_GET_STATS:\n\n        VMW_CBPRN(\"Set: Get device statistics\");\n\n        vmxnet3_fill_stats(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_ACTIVATE_DEV:\n\n        VMW_CBPRN(\"Set: Activating vmxnet3 device\");\n\n        vmxnet3_activate_device(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_UPDATE_RX_MODE:\n\n        VMW_CBPRN(\"Set: Update rx mode\");\n\n        vmxnet3_update_rx_mode(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_UPDATE_VLAN_FILTERS:\n\n        VMW_CBPRN(\"Set: Update VLAN filters\");\n\n        vmxnet3_update_vlan_filters(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_UPDATE_MAC_FILTERS:\n\n        VMW_CBPRN(\"Set: Update MAC filters\");\n\n        vmxnet3_update_mcast_filters(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_UPDATE_FEATURE:\n\n        VMW_CBPRN(\"Set: Update features\");\n\n        vmxnet3_update_features(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_UPDATE_PMCFG:\n\n        VMW_CBPRN(\"Set: Update power management config\");\n\n        vmxnet3_update_pm_state(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_GET_LINK:\n\n        VMW_CBPRN(\"Set: Get link\");\n\n        break;\n\n\n\n    case VMXNET3_CMD_RESET_DEV:\n\n        VMW_CBPRN(\"Set: Reset device\");\n\n        vmxnet3_reset(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_QUIESCE_DEV:\n\n        VMW_CBPRN(\"Set: VMXNET3_CMD_QUIESCE_DEV - pause the device\");\n\n        vmxnet3_deactivate_device(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_GET_CONF_INTR:\n\n        VMW_CBPRN(\"Set: VMXNET3_CMD_GET_CONF_INTR - interrupt configuration\");\n\n        break;\n\n\n\n    case VMXNET3_CMD_GET_ADAPTIVE_RING_INFO:\n\n        VMW_CBPRN(\"Set: VMXNET3_CMD_GET_ADAPTIVE_RING_INFO - \"\n\n                  \"adaptive ring info flags\");\n\n        break;\n\n\n\n    default:\n\n        VMW_CBPRN(\"Received unknown command: %\" PRIx64, cmd);\n\n        break;\n\n    }\n\n}\n", "idx": 22226}
{"project": "qemu", "commit_id": "d6f723b513a0c3c4e58343b7c52a2f9850861fa0", "target": 1, "func": "static void test_qemu_strtoll_full_max(void)\n\n{\n\n\n\n    const char *str = g_strdup_printf(\"%lld\", LLONG_MAX);\n\n    int64_t res;\n\n    int err;\n\n\n\n    err = qemu_strtoll(str, NULL, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, LLONG_MAX);\n\n}\n", "idx": 22227}
{"project": "qemu", "commit_id": "b53ccc30c40df52d192e469a86c188a8649c6df3", "target": 1, "func": "static int dump_init(DumpState *s, int fd, bool paging, bool has_filter,\n\n                     int64_t begin, int64_t length, Error **errp)\n\n{\n\n    CPUState *cpu;\n\n    int nr_cpus;\n\n    Error *err = NULL;\n\n    int ret;\n\n\n\n    if (runstate_is_running()) {\n\n        vm_stop(RUN_STATE_SAVE_VM);\n\n        s->resume = true;\n\n    } else {\n\n        s->resume = false;\n\n    }\n\n\n\n    /* If we use KVM, we should synchronize the registers before we get dump\n\n     * info or physmap info.\n\n     */\n\n    cpu_synchronize_all_states();\n\n    nr_cpus = 0;\n\n    CPU_FOREACH(cpu) {\n\n        nr_cpus++;\n\n    }\n\n\n\n    s->errp = errp;\n\n    s->fd = fd;\n\n    s->has_filter = has_filter;\n\n    s->begin = begin;\n\n    s->length = length;\n\n\n\n    guest_phys_blocks_init(&s->guest_phys_blocks);\n\n    guest_phys_blocks_append(&s->guest_phys_blocks);\n\n\n\n    s->start = get_start_block(s);\n\n    if (s->start == -1) {\n\n        error_set(errp, QERR_INVALID_PARAMETER, \"begin\");\n\n        goto cleanup;\n\n    }\n\n\n\n    /* get dump info: endian, class and architecture.\n\n     * If the target architecture is not supported, cpu_get_dump_info() will\n\n     * return -1.\n\n     */\n\n    ret = cpu_get_dump_info(&s->dump_info, &s->guest_phys_blocks);\n\n    if (ret < 0) {\n\n        error_set(errp, QERR_UNSUPPORTED);\n\n        goto cleanup;\n\n    }\n\n\n\n    s->note_size = cpu_get_note_size(s->dump_info.d_class,\n\n                                     s->dump_info.d_machine, nr_cpus);\n\n    if (s->note_size < 0) {\n\n        error_set(errp, QERR_UNSUPPORTED);\n\n        goto cleanup;\n\n    }\n\n\n\n    /* get memory mapping */\n\n    memory_mapping_list_init(&s->list);\n\n    if (paging) {\n\n        qemu_get_guest_memory_mapping(&s->list, &s->guest_phys_blocks, &err);\n\n        if (err != NULL) {\n\n            error_propagate(errp, err);\n\n            goto cleanup;\n\n        }\n\n    } else {\n\n        qemu_get_guest_simple_memory_mapping(&s->list, &s->guest_phys_blocks);\n\n    }\n\n\n\n    s->nr_cpus = nr_cpus;\n\n    s->page_size = TARGET_PAGE_SIZE;\n\n    s->page_shift = ffs(s->page_size) - 1;\n\n\n\n    get_max_mapnr(s);\n\n\n\n    uint64_t tmp;\n\n    tmp = DIV_ROUND_UP(DIV_ROUND_UP(s->max_mapnr, CHAR_BIT), s->page_size);\n\n    s->len_dump_bitmap = tmp * s->page_size;\n\n\n\n    if (s->has_filter) {\n\n        memory_mapping_filter(&s->list, s->begin, s->length);\n\n    }\n\n\n\n    /*\n\n     * calculate phdr_num\n\n     *\n\n     * the type of ehdr->e_phnum is uint16_t, so we should avoid overflow\n\n     */\n\n    s->phdr_num = 1; /* PT_NOTE */\n\n    if (s->list.num < UINT16_MAX - 2) {\n\n        s->phdr_num += s->list.num;\n\n        s->have_section = false;\n\n    } else {\n\n        s->have_section = true;\n\n        s->phdr_num = PN_XNUM;\n\n        s->sh_info = 1; /* PT_NOTE */\n\n\n\n        /* the type of shdr->sh_info is uint32_t, so we should avoid overflow */\n\n        if (s->list.num <= UINT32_MAX - 1) {\n\n            s->sh_info += s->list.num;\n\n        } else {\n\n            s->sh_info = UINT32_MAX;\n\n        }\n\n    }\n\n\n\n    if (s->dump_info.d_class == ELFCLASS64) {\n\n        if (s->have_section) {\n\n            s->memory_offset = sizeof(Elf64_Ehdr) +\n\n                               sizeof(Elf64_Phdr) * s->sh_info +\n\n                               sizeof(Elf64_Shdr) + s->note_size;\n\n        } else {\n\n            s->memory_offset = sizeof(Elf64_Ehdr) +\n\n                               sizeof(Elf64_Phdr) * s->phdr_num + s->note_size;\n\n        }\n\n    } else {\n\n        if (s->have_section) {\n\n            s->memory_offset = sizeof(Elf32_Ehdr) +\n\n                               sizeof(Elf32_Phdr) * s->sh_info +\n\n                               sizeof(Elf32_Shdr) + s->note_size;\n\n        } else {\n\n            s->memory_offset = sizeof(Elf32_Ehdr) +\n\n                               sizeof(Elf32_Phdr) * s->phdr_num + s->note_size;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n\n\ncleanup:\n\n    guest_phys_blocks_free(&s->guest_phys_blocks);\n\n\n\n    if (s->resume) {\n\n        vm_start();\n\n    }\n\n\n\n    return -1;\n\n}\n", "idx": 22228}
{"project": "qemu", "commit_id": "354fb471bd5faf527f3fa25388b8cffa6bd937d0", "target": 1, "func": "static void crs_replace_with_free_ranges(GPtrArray *ranges,\n\n                                         uint64_t start, uint64_t end)\n\n{\n\n    GPtrArray *free_ranges = g_ptr_array_new_with_free_func(crs_range_free);\n\n    uint64_t free_base = start;\n\n    int i;\n\n\n\n    g_ptr_array_sort(ranges, crs_range_compare);\n\n    for (i = 0; i < ranges->len; i++) {\n\n        CrsRangeEntry *used = g_ptr_array_index(ranges, i);\n\n\n\n        if (free_base < used->base) {\n\n            crs_range_insert(free_ranges, free_base, used->base - 1);\n\n        }\n\n\n\n        free_base = used->limit + 1;\n\n    }\n\n\n\n    if (free_base < end) {\n\n        crs_range_insert(free_ranges, free_base, end);\n\n    }\n\n\n\n    g_ptr_array_set_size(ranges, 0);\n\n    for (i = 0; i < free_ranges->len; i++) {\n\n        g_ptr_array_add(ranges, g_ptr_array_index(free_ranges, i));\n\n    }\n\n\n\n    g_ptr_array_free(free_ranges, false);\n\n}\n", "idx": 22229}
{"project": "qemu", "commit_id": "eefa3d8ef649f9055611361e2201cca49f8c3433", "target": 1, "func": "static ssize_t qio_channel_websock_decode_payload(QIOChannelWebsock *ioc,\n\n                                                  Error **errp)\n\n{\n\n    size_t i;\n\n    size_t payload_len;\n\n    uint32_t *payload32;\n\n\n\n    if (!ioc->payload_remain) {\n\n        error_setg(errp,\n\n                   \"Decoding payload but no bytes of payload remain\");\n\n        return -1;\n\n    }\n\n\n\n    /* If we aren't at the end of the payload, then drop\n\n     * off the last bytes, so we're always multiple of 4\n\n     * for purpose of unmasking, except at end of payload\n\n     */\n\n    if (ioc->encinput.offset < ioc->payload_remain) {\n\n        payload_len = ioc->encinput.offset - (ioc->encinput.offset % 4);\n\n    } else {\n\n        payload_len = ioc->payload_remain;\n\n    }\n\n    if (payload_len == 0) {\n\n        return QIO_CHANNEL_ERR_BLOCK;\n\n    }\n\n\n\n    ioc->payload_remain -= payload_len;\n\n\n\n    /* unmask frame */\n\n    /* process 1 frame (32 bit op) */\n\n    payload32 = (uint32_t *)ioc->encinput.buffer;\n\n    for (i = 0; i < payload_len / 4; i++) {\n\n        payload32[i] ^= ioc->mask.u;\n\n    }\n\n    /* process the remaining bytes (if any) */\n\n    for (i *= 4; i < payload_len; i++) {\n\n        ioc->encinput.buffer[i] ^= ioc->mask.c[i % 4];\n\n    }\n\n\n\n    buffer_reserve(&ioc->rawinput, payload_len);\n\n    buffer_append(&ioc->rawinput, ioc->encinput.buffer, payload_len);\n\n    buffer_advance(&ioc->encinput, payload_len);\n\n    return payload_len;\n\n}\n", "idx": 22230}
{"project": "qemu", "commit_id": "c408d27a42318227092128b04cca555f78cf703d", "target": 1, "func": "static void create_flash(const VirtBoardInfo *vbi)\n\n{\n\n    /* Create two flash devices to fill the VIRT_FLASH space in the memmap.\n\n     * Any file passed via -bios goes in the first of these.\n\n     */\n\n    hwaddr flashsize = vbi->memmap[VIRT_FLASH].size / 2;\n\n    hwaddr flashbase = vbi->memmap[VIRT_FLASH].base;\n\n    char *nodename;\n\n\n\n    if (bios_name) {\n\n        char *fn;\n\n        int image_size;\n\n\n\n        if (drive_get(IF_PFLASH, 0, 0)) {\n\n            error_report(\"The contents of the first flash device may be \"\n\n                         \"specified with -bios or with -drive if=pflash... \"\n\n                         \"but you cannot use both options at once\");\n\n            exit(1);\n\n        }\n\n        fn = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n        if (!fn) {\n\n            error_report(\"Could not find ROM image '%s'\", bios_name);\n\n            exit(1);\n\n        }\n\n        image_size = load_image_targphys(fn, flashbase, flashsize);\n\n        g_free(fn);\n\n        if (image_size < 0) {\n\n            error_report(\"Could not load ROM image '%s'\", bios_name);\n\n            exit(1);\n\n        }\n\n        g_free(fn);\n\n    }\n\n\n\n    create_one_flash(\"virt.flash0\", flashbase, flashsize);\n\n    create_one_flash(\"virt.flash1\", flashbase + flashsize, flashsize);\n\n\n\n    nodename = g_strdup_printf(\"/flash@%\" PRIx64, flashbase);\n\n    qemu_fdt_add_subnode(vbi->fdt, nodename);\n\n    qemu_fdt_setprop_string(vbi->fdt, nodename, \"compatible\", \"cfi-flash\");\n\n    qemu_fdt_setprop_sized_cells(vbi->fdt, nodename, \"reg\",\n\n                                 2, flashbase, 2, flashsize,\n\n                                 2, flashbase + flashsize, 2, flashsize);\n\n    qemu_fdt_setprop_cell(vbi->fdt, nodename, \"bank-width\", 4);\n\n    g_free(nodename);\n\n}\n", "idx": 22232}
{"project": "qemu", "commit_id": "cc413a39355ed910f22f8f0be5e233c08a0773a0", "target": 1, "func": "void mips_malta_init(QEMUMachineInitArgs *args)\n{\n    ram_addr_t ram_size = args->ram_size;\n    const char *cpu_model = args->cpu_model;\n    const char *kernel_filename = args->kernel_filename;\n    const char *kernel_cmdline = args->kernel_cmdline;\n    const char *initrd_filename = args->initrd_filename;\n    char *filename;\n    pflash_t *fl;\n    MemoryRegion *system_memory = get_system_memory();\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n    MemoryRegion *bios, *bios_copy = g_new(MemoryRegion, 1);\n    target_long bios_size = FLASH_SIZE;\n    const size_t smbus_eeprom_size = 8 * 256;\n    uint8_t *smbus_eeprom_buf = g_malloc0(smbus_eeprom_size);\n    int64_t kernel_entry;\n    PCIBus *pci_bus;\n    ISABus *isa_bus;\n    MIPSCPU *cpu;\n    CPUMIPSState *env;\n    qemu_irq *isa_irq;\n    qemu_irq *cpu_exit_irq;\n    int piix4_devfn;\n    i2c_bus *smbus;\n    int i;\n    DriveInfo *dinfo;\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n    DriveInfo *fd[MAX_FD];\n    int fl_idx = 0;\n    int fl_sectors = bios_size >> 16;\n    int be;\n    DeviceState *dev = qdev_create(NULL, TYPE_MIPS_MALTA);\n    MaltaState *s = MIPS_MALTA(dev);\n    qdev_init_nofail(dev);\n    /* Make sure the first 3 serial ports are associated with a device. */\n    for(i = 0; i < 3; i++) {\n        if (!serial_hds[i]) {\n            char label[32];\n            snprintf(label, sizeof(label), \"serial%d\", i);\n            serial_hds[i] = qemu_chr_new(label, \"null\", NULL);\n        }\n    }\n    /* init CPUs */\n    if (cpu_model == NULL) {\n#ifdef TARGET_MIPS64\n        cpu_model = \"20Kc\";\n#else\n        cpu_model = \"24Kf\";\n#endif\n    }\n    for (i = 0; i < smp_cpus; i++) {\n        cpu = cpu_mips_init(cpu_model);\n        if (cpu == NULL) {\n            fprintf(stderr, \"Unable to find CPU definition\\n\");\n            exit(1);\n        }\n        env = &cpu->env;\n        /* Init internal devices */\n        cpu_mips_irq_init_cpu(env);\n        cpu_mips_clock_init(env);\n        qemu_register_reset(main_cpu_reset, cpu);\n    }\n    cpu = MIPS_CPU(first_cpu);\n    env = &cpu->env;\n    /* allocate RAM */\n    if (ram_size > (256 << 20)) {\n        fprintf(stderr,\n                \"qemu: Too much memory for this machine: %d MB, maximum 256 MB\\n\",\n                ((unsigned int)ram_size / (1 << 20)));\n        exit(1);\n    }\n    memory_region_init_ram(ram, NULL, \"mips_malta.ram\", ram_size);\n    vmstate_register_ram_global(ram);\n    memory_region_add_subregion(system_memory, 0, ram);\n    /* generate SPD EEPROM data */\n    generate_eeprom_spd(&smbus_eeprom_buf[0 * 256], ram_size);\n    generate_eeprom_serial(&smbus_eeprom_buf[6 * 256]);\n#ifdef TARGET_WORDS_BIGENDIAN\n    be = 1;\n#else\n    be = 0;\n#endif\n    /* FPGA */\n    /* The CBUS UART is attached to the MIPS CPU INT2 pin, ie interrupt 4 */\n    malta_fpga_init(system_memory, FPGA_ADDRESS, env->irq[4], serial_hds[2]);\n    /* Load firmware in flash / BIOS. */\n    dinfo = drive_get(IF_PFLASH, 0, fl_idx);\n#ifdef DEBUG_BOARD_INIT\n    if (dinfo) {\n        printf(\"Register parallel flash %d size \" TARGET_FMT_lx \" at \"\n               \"addr %08llx '%s' %x\\n\",\n               fl_idx, bios_size, FLASH_ADDRESS,\n               bdrv_get_device_name(dinfo->bdrv), fl_sectors);\n    }\n#endif\n    fl = pflash_cfi01_register(FLASH_ADDRESS, NULL, \"mips_malta.bios\",\n                               BIOS_SIZE, dinfo ? dinfo->bdrv : NULL,\n                               65536, fl_sectors,\n                               4, 0x0000, 0x0000, 0x0000, 0x0000, be);\n    bios = pflash_cfi01_get_memory(fl);\n    fl_idx++;\n    if (kernel_filename) {\n        /* Write a small bootloader to the flash location. */\n        loaderparams.ram_size = ram_size;\n        loaderparams.kernel_filename = kernel_filename;\n        loaderparams.kernel_cmdline = kernel_cmdline;\n        loaderparams.initrd_filename = initrd_filename;\n        kernel_entry = load_kernel();\n        write_bootloader(env, memory_region_get_ram_ptr(bios), kernel_entry);\n    } else {\n        /* Load firmware from flash. */\n        if (!dinfo) {\n            /* Load a BIOS image. */\n            if (bios_name == NULL) {\n                bios_name = BIOS_FILENAME;\n            }\n            filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n            if (filename) {\n                bios_size = load_image_targphys(filename, FLASH_ADDRESS,\n                                                BIOS_SIZE);\n                g_free(filename);\n            } else {\n                bios_size = -1;\n            }\n            if ((bios_size < 0 || bios_size > BIOS_SIZE) &&\n                !kernel_filename && !qtest_enabled()) {\n                error_report(\"Could not load MIPS bios '%s', and no \"\n                             \"-kernel argument was specified\", bios_name);\n                exit(1);\n            }\n        }\n        /* In little endian mode the 32bit words in the bios are swapped,\n           a neat trick which allows bi-endian firmware. */\n#ifndef TARGET_WORDS_BIGENDIAN\n        {\n            uint32_t *end, *addr = rom_ptr(FLASH_ADDRESS);\n            if (!addr) {\n                addr = memory_region_get_ram_ptr(bios);\n            }\n            end = (void *)addr + MIN(bios_size, 0x3e0000);\n            while (addr < end) {\n                bswap32s(addr);\n                addr++;\n            }\n        }\n#endif\n    }\n    /*\n     * Map the BIOS at a 2nd physical location, as on the real board.\n     * Copy it so that we can patch in the MIPS revision, which cannot be\n     * handled by an overlapping region as the resulting ROM code subpage\n     * regions are not executable.\n     */\n    memory_region_init_ram(bios_copy, NULL, \"bios.1fc\", BIOS_SIZE);\n    if (!rom_copy(memory_region_get_ram_ptr(bios_copy),\n                  FLASH_ADDRESS, BIOS_SIZE)) {\n        memcpy(memory_region_get_ram_ptr(bios_copy),\n               memory_region_get_ram_ptr(bios), BIOS_SIZE);\n    }\n    memory_region_set_readonly(bios_copy, true);\n    memory_region_add_subregion(system_memory, RESET_ADDRESS, bios_copy);\n    /* Board ID = 0x420 (Malta Board with CoreLV) */\n    stl_p(memory_region_get_ram_ptr(bios_copy) + 0x10, 0x00000420);\n    /* Init internal devices */\n    cpu_mips_irq_init_cpu(env);\n    cpu_mips_clock_init(env);\n    /*\n     * We have a circular dependency problem: pci_bus depends on isa_irq,\n     * isa_irq is provided by i8259, i8259 depends on ISA, ISA depends\n     * on piix4, and piix4 depends on pci_bus.  To stop the cycle we have\n     * qemu_irq_proxy() adds an extra bit of indirection, allowing us\n     * to resolve the isa_irq -> i8259 dependency after i8259 is initialized.\n     */\n    isa_irq = qemu_irq_proxy(&s->i8259, 16);\n    /* Northbridge */\n    pci_bus = gt64120_register(isa_irq);\n    /* Southbridge */\n    ide_drive_get(hd, MAX_IDE_BUS);\n    piix4_devfn = piix4_init(pci_bus, &isa_bus, 80);\n    /* Interrupt controller */\n    /* The 8259 is attached to the MIPS CPU INT0 pin, ie interrupt 2 */\n    s->i8259 = i8259_init(isa_bus, env->irq[2]);\n    isa_bus_irqs(isa_bus, s->i8259);\n    pci_piix4_ide_init(pci_bus, hd, piix4_devfn + 1);\n    pci_create_simple(pci_bus, piix4_devfn + 2, \"piix4-usb-uhci\");\n    smbus = piix4_pm_init(pci_bus, piix4_devfn + 3, 0x1100,\n                          isa_get_irq(NULL, 9), NULL, 0, NULL);\n    smbus_eeprom_init(smbus, 8, smbus_eeprom_buf, smbus_eeprom_size);\n    g_free(smbus_eeprom_buf);\n    pit = pit_init(isa_bus, 0x40, 0, NULL);\n    cpu_exit_irq = qemu_allocate_irqs(cpu_request_exit, NULL, 1);\n    DMA_init(0, cpu_exit_irq);\n    /* Super I/O */\n    isa_create_simple(isa_bus, \"i8042\");\n    rtc_init(isa_bus, 2000, NULL);\n    serial_isa_init(isa_bus, 0, serial_hds[0]);\n    serial_isa_init(isa_bus, 1, serial_hds[1]);\n    if (parallel_hds[0])\n        parallel_init(isa_bus, 0, parallel_hds[0]);\n    for(i = 0; i < MAX_FD; i++) {\n        fd[i] = drive_get(IF_FLOPPY, 0, i);\n    }\n    fdctrl_init_isa(isa_bus, fd);\n    /* Network card */\n    network_init(pci_bus);\n    /* Optional PCI video card */\n    pci_vga_init(pci_bus);\n}", "idx": 22233}
{"project": "qemu", "commit_id": "36ad0e948e15d8d86c8dec1c17a8588d87b0107d", "target": 1, "func": "static qemu_irq *ppce500_init_mpic(PPCE500Params *params, MemoryRegion *ccsr,\n\n                                   qemu_irq **irqs)\n\n{\n\n    QemuOptsList *list;\n\n    qemu_irq *mpic;\n\n    DeviceState *dev = NULL;\n\n    SysBusDevice *s;\n\n    int i;\n\n\n\n    mpic = g_new(qemu_irq, 256);\n\n\n\n    if (kvm_enabled()) {\n\n        bool irqchip_allowed = true, irqchip_required = false;\n\n\n\n        list = qemu_find_opts(\"machine\");\n\n        if (!QTAILQ_EMPTY(&list->head)) {\n\n            irqchip_allowed = qemu_opt_get_bool(QTAILQ_FIRST(&list->head),\n\n                                                \"kernel_irqchip\", true);\n\n            irqchip_required = qemu_opt_get_bool(QTAILQ_FIRST(&list->head),\n\n                                                 \"kernel_irqchip\", false);\n\n        }\n\n\n\n        if (irqchip_allowed) {\n\n            dev = ppce500_init_mpic_kvm(params, irqs);\n\n        }\n\n\n\n        if (irqchip_required && !dev) {\n\n            fprintf(stderr, \"%s: irqchip requested but unavailable\\n\",\n\n                    __func__);\n\n            abort();\n\n        }\n\n    }\n\n\n\n    if (!dev) {\n\n        dev = ppce500_init_mpic_qemu(params, irqs);\n\n    }\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        mpic[i] = qdev_get_gpio_in(dev, i);\n\n    }\n\n\n\n    s = SYS_BUS_DEVICE(dev);\n\n    memory_region_add_subregion(ccsr, MPC8544_MPIC_REGS_OFFSET,\n\n                                s->mmio[0].memory);\n\n\n\n    return mpic;\n\n}\n", "idx": 22234}
{"project": "qemu", "commit_id": "bac658d1a4dc9dd637b2eb5006abda137071f17f", "target": 1, "func": "static char *spapr_get_fw_dev_path(FWPathProvider *p, BusState *bus,\n\n                                   DeviceState *dev)\n\n{\n\n#define CAST(type, obj, name) \\\n\n    ((type *)object_dynamic_cast(OBJECT(obj), (name)))\n\n    SCSIDevice *d = CAST(SCSIDevice,  dev, TYPE_SCSI_DEVICE);\n\n    sPAPRPHBState *phb = CAST(sPAPRPHBState, dev, TYPE_SPAPR_PCI_HOST_BRIDGE);\n\n    VHostSCSICommon *vsc = CAST(VHostSCSICommon, dev, TYPE_VHOST_SCSI_COMMON);\n\n\n\n    if (d) {\n\n        void *spapr = CAST(void, bus->parent, \"spapr-vscsi\");\n\n        VirtIOSCSI *virtio = CAST(VirtIOSCSI, bus->parent, TYPE_VIRTIO_SCSI);\n\n        USBDevice *usb = CAST(USBDevice, bus->parent, TYPE_USB_DEVICE);\n\n\n\n        if (spapr) {\n\n            /*\n\n             * Replace \"channel@0/disk@0,0\" with \"disk@8000000000000000\":\n\n             * We use SRP luns of the form 8000 | (bus << 8) | (id << 5) | lun\n\n             * in the top 16 bits of the 64-bit LUN\n\n             */\n\n            unsigned id = 0x8000 | (d->id << 8) | d->lun;\n\n            return g_strdup_printf(\"%s@%\"PRIX64, qdev_fw_name(dev),\n\n                                   (uint64_t)id << 48);\n\n        } else if (virtio) {\n\n            /*\n\n             * We use SRP luns of the form 01000000 | (target << 8) | lun\n\n             * in the top 32 bits of the 64-bit LUN\n\n             * Note: the quote above is from SLOF and it is wrong,\n\n             * the actual binding is:\n\n             * swap 0100 or 10 << or 20 << ( target lun-id -- srplun )\n\n             */\n\n            unsigned id = 0x1000000 | (d->id << 16) | d->lun;\n\n\n\n\n\n            return g_strdup_printf(\"%s@%\"PRIX64, qdev_fw_name(dev),\n\n                                   (uint64_t)id << 32);\n\n        } else if (usb) {\n\n            /*\n\n             * We use SRP luns of the form 01000000 | (usb-port << 16) | lun\n\n             * in the top 32 bits of the 64-bit LUN\n\n             */\n\n            unsigned usb_port = atoi(usb->port->path);\n\n            unsigned id = 0x1000000 | (usb_port << 16) | d->lun;\n\n            return g_strdup_printf(\"%s@%\"PRIX64, qdev_fw_name(dev),\n\n                                   (uint64_t)id << 32);\n\n\n\n\n\n    /*\n\n     * SLOF probes the USB devices, and if it recognizes that the device is a\n\n     * storage device, it changes its name to \"storage\" instead of \"usb-host\",\n\n     * and additionally adds a child node for the SCSI LUN, so the correct\n\n     * boot path in SLOF is something like .../storage@1/disk@xxx\" instead.\n\n     */\n\n    if (strcmp(\"usb-host\", qdev_fw_name(dev)) == 0) {\n\n        USBDevice *usbdev = CAST(USBDevice, dev, TYPE_USB_DEVICE);\n\n        if (usb_host_dev_is_scsi_storage(usbdev)) {\n\n            return g_strdup_printf(\"storage@%s/disk\", usbdev->port->path);\n\n\n\n\n\n    if (phb) {\n\n        /* Replace \"pci\" with \"pci@800000020000000\" */\n\n        return g_strdup_printf(\"pci@%\"PRIX64, phb->buid);\n\n\n\n\n    if (vsc) {\n\n        /* Same logic as virtio above */\n\n        unsigned id = 0x1000000 | (vsc->target << 16) | vsc->lun;\n\n        return g_strdup_printf(\"disk@%\"PRIX64, (uint64_t)id << 32);\n\n\n\n\n    if (g_str_equal(\"pci-bridge\", qdev_fw_name(dev))) {\n\n        /* SLOF uses \"pci\" instead of \"pci-bridge\" for PCI bridges */\n\n        PCIDevice *pcidev = CAST(PCIDevice, dev, TYPE_PCI_DEVICE);\n\n        return g_strdup_printf(\"pci@%x\", PCI_SLOT(pcidev->devfn));\n\n\n\n\n    return NULL;\n", "idx": 22235}
{"project": "qemu", "commit_id": "5cbab1bfdeab274e5d4e3353fa626ba8697eed10", "target": 1, "func": "static void kvm_s390_flic_realize(DeviceState *dev, Error **errp)\n\n{\n\n    KVMS390FLICState *flic_state = KVM_S390_FLIC(dev);\n\n    struct kvm_create_device cd = {0};\n\n    struct kvm_device_attr test_attr = {0};\n\n    int ret;\n\n    Error *errp_local = NULL;\n\n\n\n\n\n\n\n    flic_state->fd = -1;\n\n    if (!kvm_check_extension(kvm_state, KVM_CAP_DEVICE_CTRL)) {\n\n        error_setg_errno(&errp_local, errno, \"KVM is missing capability\"\n\n                         \" KVM_CAP_DEVICE_CTRL\");\n\n        trace_flic_no_device_api(errno);\n\n\n\n\n\n    cd.type = KVM_DEV_TYPE_FLIC;\n\n    ret = kvm_vm_ioctl(kvm_state, KVM_CREATE_DEVICE, &cd);\n\n    if (ret < 0) {\n\n        error_setg_errno(&errp_local, errno, \"Creating the KVM device failed\");\n\n        trace_flic_create_device(errno);\n\n\n\n    flic_state->fd = cd.fd;\n\n\n\n    /* Check clear_io_irq support */\n\n    test_attr.group = KVM_DEV_FLIC_CLEAR_IO_IRQ;\n\n    flic_state->clear_io_supported = !ioctl(flic_state->fd,\n\n                                            KVM_HAS_DEVICE_ATTR, test_attr);\n\n\n\n    return;\n\nfail:\n\n    error_propagate(errp, errp_local);\n", "idx": 22236}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int qemu_rdma_alloc_qp(RDMAContext *rdma)\n\n{\n\n    struct ibv_qp_init_attr attr = { 0 };\n\n    int ret;\n\n\n\n    attr.cap.max_send_wr = RDMA_SIGNALED_SEND_MAX;\n\n    attr.cap.max_recv_wr = 3;\n\n    attr.cap.max_send_sge = 1;\n\n    attr.cap.max_recv_sge = 1;\n\n    attr.send_cq = rdma->cq;\n\n    attr.recv_cq = rdma->cq;\n\n    attr.qp_type = IBV_QPT_RC;\n\n\n\n    ret = rdma_create_qp(rdma->cm_id, rdma->pd, &attr);\n\n    if (ret) {\n\n        return -1;\n\n    }\n\n\n\n    rdma->qp = rdma->cm_id->qp;\n\n    return 0;\n\n}\n", "idx": 22237}
{"project": "qemu", "commit_id": "6d5d23b00709510d55711661c7ca41408fd9934e", "target": 1, "func": "static void qio_channel_websock_handshake_process(QIOChannelWebsock *ioc,\n\n                                                  char *buffer,\n\n                                                  Error **errp)\n\n{\n\n    QIOChannelWebsockHTTPHeader hdrs[32];\n\n    size_t nhdrs = G_N_ELEMENTS(hdrs);\n\n    const char *protocols = NULL, *version = NULL, *key = NULL,\n\n        *host = NULL, *connection = NULL, *upgrade = NULL;\n\n\n\n    nhdrs = qio_channel_websock_extract_headers(ioc, buffer, hdrs, nhdrs, errp);\n\n    if (!nhdrs) {\n\n        return;\n\n    }\n\n\n\n    protocols = qio_channel_websock_find_header(\n\n        hdrs, nhdrs, QIO_CHANNEL_WEBSOCK_HEADER_PROTOCOL);\n\n    if (!protocols) {\n\n        error_setg(errp, \"Missing websocket protocol header data\");\n\n        goto bad_request;\n\n    }\n\n\n\n    version = qio_channel_websock_find_header(\n\n        hdrs, nhdrs, QIO_CHANNEL_WEBSOCK_HEADER_VERSION);\n\n    if (!version) {\n\n        error_setg(errp, \"Missing websocket version header data\");\n\n        goto bad_request;\n\n    }\n\n\n\n    key = qio_channel_websock_find_header(\n\n        hdrs, nhdrs, QIO_CHANNEL_WEBSOCK_HEADER_KEY);\n\n    if (!key) {\n\n        error_setg(errp, \"Missing websocket key header data\");\n\n        goto bad_request;\n\n    }\n\n\n\n    host = qio_channel_websock_find_header(\n\n        hdrs, nhdrs, QIO_CHANNEL_WEBSOCK_HEADER_HOST);\n\n    if (!host) {\n\n        error_setg(errp, \"Missing websocket host header data\");\n\n        goto bad_request;\n\n    }\n\n\n\n    connection = qio_channel_websock_find_header(\n\n        hdrs, nhdrs, QIO_CHANNEL_WEBSOCK_HEADER_CONNECTION);\n\n    if (!connection) {\n\n        error_setg(errp, \"Missing websocket connection header data\");\n\n        goto bad_request;\n\n    }\n\n\n\n    upgrade = qio_channel_websock_find_header(\n\n        hdrs, nhdrs, QIO_CHANNEL_WEBSOCK_HEADER_UPGRADE);\n\n    if (!upgrade) {\n\n        error_setg(errp, \"Missing websocket upgrade header data\");\n\n        goto bad_request;\n\n    }\n\n\n\n    if (!g_strrstr(protocols, QIO_CHANNEL_WEBSOCK_PROTOCOL_BINARY)) {\n\n        error_setg(errp, \"No '%s' protocol is supported by client '%s'\",\n\n                   QIO_CHANNEL_WEBSOCK_PROTOCOL_BINARY, protocols);\n\n        goto bad_request;\n\n    }\n\n\n\n    if (!g_str_equal(version, QIO_CHANNEL_WEBSOCK_SUPPORTED_VERSION)) {\n\n        error_setg(errp, \"Version '%s' is not supported by client '%s'\",\n\n                   QIO_CHANNEL_WEBSOCK_SUPPORTED_VERSION, version);\n\n        goto bad_request;\n\n    }\n\n\n\n    if (strlen(key) != QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN) {\n\n        error_setg(errp, \"Key length '%zu' was not as expected '%d'\",\n\n                   strlen(key), QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN);\n\n        goto bad_request;\n\n    }\n\n\n\n    if (strcasecmp(connection, QIO_CHANNEL_WEBSOCK_CONNECTION_UPGRADE) != 0) {\n\n        error_setg(errp, \"No connection upgrade requested '%s'\", connection);\n\n        goto bad_request;\n\n    }\n\n\n\n    if (strcasecmp(upgrade, QIO_CHANNEL_WEBSOCK_UPGRADE_WEBSOCKET) != 0) {\n\n        error_setg(errp, \"Incorrect upgrade method '%s'\", upgrade);\n\n        goto bad_request;\n\n    }\n\n\n\n    qio_channel_websock_handshake_send_res_ok(ioc, key, errp);\n\n    return;\n\n\n\n bad_request:\n\n    qio_channel_websock_handshake_send_res_err(\n\n        ioc, QIO_CHANNEL_WEBSOCK_HANDSHAKE_RES_BAD_REQUEST);\n\n}\n", "idx": 22238}
{"project": "qemu", "commit_id": "e6b3c8ca0222f6633516c0461a713e7bddc4f076", "target": 1, "func": "static void versatile_init(ram_addr_t ram_size,\n\n                     const char *boot_device,\n\n                     const char *kernel_filename, const char *kernel_cmdline,\n\n                     const char *initrd_filename, const char *cpu_model,\n\n                     int board_id)\n\n{\n\n    CPUState *env;\n\n    ram_addr_t ram_offset;\n\n    qemu_irq *cpu_pic;\n\n    qemu_irq pic[32];\n\n    qemu_irq sic[32];\n\n    DeviceState *dev;\n\n    PCIBus *pci_bus;\n\n    NICInfo *nd;\n\n    int n;\n\n    int done_smc = 0;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"arm926\";\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    ram_offset = qemu_ram_alloc(NULL, \"versatile.ram\", ram_size);\n\n    /* ??? RAM should repeat to fill physical memory space.  */\n\n    /* SDRAM at address zero.  */\n\n    cpu_register_physical_memory(0, ram_size, ram_offset | IO_MEM_RAM);\n\n\n\n    arm_sysctl_init(0x10000000, 0x41007004, 0x02000000);\n\n    cpu_pic = arm_pic_init_cpu(env);\n\n    dev = sysbus_create_varargs(\"pl190\", 0x10140000,\n\n                                cpu_pic[0], cpu_pic[1], NULL);\n\n    for (n = 0; n < 32; n++) {\n\n        pic[n] = qdev_get_gpio_in(dev, n);\n\n    }\n\n    dev = sysbus_create_simple(\"versatilepb_sic\", 0x10003000, NULL);\n\n    for (n = 0; n < 32; n++) {\n\n        sysbus_connect_irq(sysbus_from_qdev(dev), n, pic[n]);\n\n        sic[n] = qdev_get_gpio_in(dev, n);\n\n    }\n\n\n\n    sysbus_create_simple(\"pl050_keyboard\", 0x10006000, sic[3]);\n\n    sysbus_create_simple(\"pl050_mouse\", 0x10007000, sic[4]);\n\n\n\n    dev = sysbus_create_varargs(\"versatile_pci\", 0x40000000,\n\n                                sic[27], sic[28], sic[29], sic[30], NULL);\n\n    pci_bus = (PCIBus *)qdev_get_child_bus(dev, \"pci\");\n\n\n\n    /* The Versatile PCI bridge does not provide access to PCI IO space,\n\n       so many of the qemu PCI devices are not useable.  */\n\n    for(n = 0; n < nb_nics; n++) {\n\n        nd = &nd_table[n];\n\n\n\n        if ((!nd->model && !done_smc) || strcmp(nd->model, \"smc91c111\") == 0) {\n\n            smc91c111_init(nd, 0x10010000, sic[25]);\n\n            done_smc = 1;\n\n        } else {\n\n            pci_nic_init_nofail(nd, \"rtl8139\", NULL);\n\n        }\n\n    }\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, -1);\n\n    }\n\n    n = drive_get_max_bus(IF_SCSI);\n\n    while (n >= 0) {\n\n        pci_create_simple(pci_bus, -1, \"lsi53c895a\");\n\n        n--;\n\n    }\n\n\n\n    sysbus_create_simple(\"pl011\", 0x101f1000, pic[12]);\n\n    sysbus_create_simple(\"pl011\", 0x101f2000, pic[13]);\n\n    sysbus_create_simple(\"pl011\", 0x101f3000, pic[14]);\n\n    sysbus_create_simple(\"pl011\", 0x10009000, sic[6]);\n\n\n\n    sysbus_create_simple(\"pl080\", 0x10130000, pic[17]);\n\n    sysbus_create_simple(\"sp804\", 0x101e2000, pic[4]);\n\n    sysbus_create_simple(\"sp804\", 0x101e3000, pic[5]);\n\n\n\n    /* The versatile/PB actually has a modified Color LCD controller\n\n       that includes hardware cursor support from the PL111.  */\n\n    sysbus_create_simple(\"pl110_versatile\", 0x10120000, pic[16]);\n\n\n\n    sysbus_create_varargs(\"pl181\", 0x10005000, sic[22], sic[1], NULL);\n\n    sysbus_create_varargs(\"pl181\", 0x1000b000, sic[23], sic[2], NULL);\n\n\n\n    /* Add PL031 Real Time Clock. */\n\n    sysbus_create_simple(\"pl031\", 0x101e8000, pic[10]);\n\n\n\n    /* Memory map for Versatile/PB:  */\n\n    /* 0x10000000 System registers.  */\n\n    /* 0x10001000 PCI controller config registers.  */\n\n    /* 0x10002000 Serial bus interface.  */\n\n    /*  0x10003000 Secondary interrupt controller.  */\n\n    /* 0x10004000 AACI (audio).  */\n\n    /*  0x10005000 MMCI0.  */\n\n    /*  0x10006000 KMI0 (keyboard).  */\n\n    /*  0x10007000 KMI1 (mouse).  */\n\n    /* 0x10008000 Character LCD Interface.  */\n\n    /*  0x10009000 UART3.  */\n\n    /* 0x1000a000 Smart card 1.  */\n\n    /*  0x1000b000 MMCI1.  */\n\n    /*  0x10010000 Ethernet.  */\n\n    /* 0x10020000 USB.  */\n\n    /* 0x10100000 SSMC.  */\n\n    /* 0x10110000 MPMC.  */\n\n    /*  0x10120000 CLCD Controller.  */\n\n    /*  0x10130000 DMA Controller.  */\n\n    /*  0x10140000 Vectored interrupt controller.  */\n\n    /* 0x101d0000 AHB Monitor Interface.  */\n\n    /* 0x101e0000 System Controller.  */\n\n    /* 0x101e1000 Watchdog Interface.  */\n\n    /* 0x101e2000 Timer 0/1.  */\n\n    /* 0x101e3000 Timer 2/3.  */\n\n    /* 0x101e4000 GPIO port 0.  */\n\n    /* 0x101e5000 GPIO port 1.  */\n\n    /* 0x101e6000 GPIO port 2.  */\n\n    /* 0x101e7000 GPIO port 3.  */\n\n    /* 0x101e8000 RTC.  */\n\n    /* 0x101f0000 Smart card 0.  */\n\n    /*  0x101f1000 UART0.  */\n\n    /*  0x101f2000 UART1.  */\n\n    /*  0x101f3000 UART2.  */\n\n    /* 0x101f4000 SSPI.  */\n\n\n\n    versatile_binfo.ram_size = ram_size;\n\n    versatile_binfo.kernel_filename = kernel_filename;\n\n    versatile_binfo.kernel_cmdline = kernel_cmdline;\n\n    versatile_binfo.initrd_filename = initrd_filename;\n\n    versatile_binfo.board_id = board_id;\n\n    arm_load_kernel(env, &versatile_binfo);\n\n}\n", "idx": 22243}
{"project": "qemu", "commit_id": "a86156401559cb4401cf9ecc704faeab6fc8bb19", "target": 1, "func": "static void test_visitor_out_empty(TestOutputVisitorData *data,\n\n                                   const void *unused)\n\n{\n\n    QObject *arg;\n\n\n\n    arg = qmp_output_get_qobject(data->qov);\n\n    g_assert(qobject_type(arg) == QTYPE_QNULL);\n\n\n\n    qobject_decref(arg);\n\n}", "idx": 22244}
{"project": "qemu", "commit_id": "fa4ba923bd539647ace9d70d226a848bd6a89dac", "target": 1, "func": "static void kvm_mem_ioeventfd_add(MemoryListener *listener,\n\n                                  MemoryRegionSection *section,\n\n                                  bool match_data, uint64_t data,\n\n                                  EventNotifier *e)\n\n{\n\n    int fd = event_notifier_get_fd(e);\n\n    int r;\n\n\n\n    r = kvm_set_ioeventfd_mmio(fd, section->offset_within_address_space,\n\n                               data, true, int128_get64(section->size),\n\n                               match_data);\n\n    if (r < 0) {\n\n\n\n        abort();\n\n    }\n\n}", "idx": 22245}
{"project": "qemu", "commit_id": "d451008e0fdf7fb817c791397e7999d5f3687e58", "target": 1, "func": "static void vfio_probe_rtl8168_bar2_window_quirk(VFIOPCIDevice *vdev, int nr)\n\n{\n\n    PCIDevice *pdev = &vdev->pdev;\n\n    VFIOQuirk *quirk;\n\n\n\n    if (pci_get_word(pdev->config + PCI_VENDOR_ID) != PCI_VENDOR_ID_REALTEK ||\n\n        pci_get_word(pdev->config + PCI_DEVICE_ID) != 0x8168 || nr != 2) {\n\n        return;\n\n    }\n\n\n\n    quirk = g_malloc0(sizeof(*quirk));\n\n    quirk->vdev = vdev;\n\n    quirk->data.bar = nr;\n\n\n\n    memory_region_init_io(&quirk->mem, OBJECT(vdev), &vfio_rtl8168_window_quirk,\n\n                          quirk, \"vfio-rtl8168-window-quirk\", 8);\n\n    memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,\n\n                                        0x70, &quirk->mem, 1);\n\n\n\n    QLIST_INSERT_HEAD(&vdev->bars[nr].quirks, quirk, next);\n\n\n\n    trace_vfio_probe_rtl8168_bar2_window_quirk(vdev->vbasedev.name);\n\n}\n", "idx": 22246}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "tcp_listen(Slirp *slirp, u_int32_t haddr, u_int hport, u_int32_t laddr,\n\n           u_int lport, int flags)\n\n{\n\n\tstruct sockaddr_in addr;\n\n\tstruct socket *so;\n\n\tint s, opt = 1;\n\n\tsocklen_t addrlen = sizeof(addr);\n\n\n\n\tDEBUG_CALL(\"tcp_listen\");\n\n\tDEBUG_ARG(\"haddr = %x\", haddr);\n\n\tDEBUG_ARG(\"hport = %d\", hport);\n\n\tDEBUG_ARG(\"laddr = %x\", laddr);\n\n\tDEBUG_ARG(\"lport = %d\", lport);\n\n\tDEBUG_ARG(\"flags = %x\", flags);\n\n\n\n\tso = socreate(slirp);\n\n\tif (!so) {\n\n\t  return NULL;\n\n\t}\n\n\n\n\t/* Don't tcp_attach... we don't need so_snd nor so_rcv */\n\n\tif ((so->so_tcpcb = tcp_newtcpcb(so)) == NULL) {\n\n\t\tfree(so);\n\n\t\treturn NULL;\n\n\t}\n\n\tinsque(so, &slirp->tcb);\n\n\n\n\t/*\n\n\t * SS_FACCEPTONCE sockets must time out.\n\n\t */\n\n\tif (flags & SS_FACCEPTONCE)\n\n\t   so->so_tcpcb->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT*2;\n\n\n\n\tso->so_state &= SS_PERSISTENT_MASK;\n\n\tso->so_state |= (SS_FACCEPTCONN | flags);\n\n\tso->so_lport = lport; /* Kept in network format */\n\n\tso->so_laddr.s_addr = laddr; /* Ditto */\n\n\n\n\taddr.sin_family = AF_INET;\n\n\taddr.sin_addr.s_addr = haddr;\n\n\taddr.sin_port = hport;\n\n\n\n\tif (((s = socket(AF_INET,SOCK_STREAM,0)) < 0) ||\n\n\t    (setsockopt(s,SOL_SOCKET,SO_REUSEADDR,(char *)&opt,sizeof(int)) < 0) ||\n\n\t    (bind(s,(struct sockaddr *)&addr, sizeof(addr)) < 0) ||\n\n\t    (listen(s,1) < 0)) {\n\n\t\tint tmperrno = errno; /* Don't clobber the real reason we failed */\n\n\n\n\t\tclose(s);\n\n\t\tsofree(so);\n\n\t\t/* Restore the real errno */\n\n#ifdef _WIN32\n\n\t\tWSASetLastError(tmperrno);\n\n#else\n\n\t\terrno = tmperrno;\n\n#endif\n\n\t\treturn NULL;\n\n\t}\n\n\tsetsockopt(s,SOL_SOCKET,SO_OOBINLINE,(char *)&opt,sizeof(int));\n\n\n\n\tgetsockname(s,(struct sockaddr *)&addr,&addrlen);\n\n\tso->so_fport = addr.sin_port;\n\n\tif (addr.sin_addr.s_addr == 0 || addr.sin_addr.s_addr == loopback_addr.s_addr)\n\n\t   so->so_faddr = slirp->vhost_addr;\n\n\telse\n\n\t   so->so_faddr = addr.sin_addr;\n\n\n\n\tso->s = s;\n\n\treturn so;\n\n}\n", "idx": 22247}
{"project": "qemu", "commit_id": "80792eb9257588d9a554605f3411cbc7ed51e9bc", "target": 1, "func": "static void test_dummy_createcmdl(void)\n{\n    QemuOpts *opts;\n    DummyObject *dobj;\n    Error *err = NULL;\n    const char *params = TYPE_DUMMY \\\n                         \",id=dev0,\" \\\n                         \"bv=yes,sv=Hiss hiss hiss,av=platypus\";\n    qemu_add_opts(&qemu_object_opts);\n    opts = qemu_opts_parse(&qemu_object_opts, params, true, &err);\n    g_assert(err == NULL);\n    g_assert(opts);\n    dobj = DUMMY_OBJECT(user_creatable_add_opts(opts, &err));\n    g_assert(err == NULL);\n    g_assert(dobj);\n    g_assert_cmpstr(dobj->sv, ==, \"Hiss hiss hiss\");\n    g_assert(dobj->bv == true);\n    g_assert(dobj->av == DUMMY_PLATYPUS);\n    user_creatable_del(\"dev0\", &err);\n    g_assert(err == NULL);\n    error_free(err);\n    /*\n     * cmdline-parsing via qemu_opts_parse() results in a QemuOpts entry\n     * corresponding to the Object's ID to be added to the QemuOptsList\n     * for objects. To avoid having this entry conflict with future\n     * Objects using the same ID (which can happen in cases where\n     * qemu_opts_parse() is used to parse the object params, such as\n     * with hmp_object_add() at the time of this comment), we need to\n     * check for this in user_creatable_del() and remove the QemuOpts if\n     * it is present.\n     *\n     * The below check ensures this works as expected.\n     */\n    g_assert_null(qemu_opts_find(&qemu_object_opts, \"dev0\"));\n}", "idx": 22248}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(extsh)\n\n{\n\n    T0 = (int32_t)((int16_t)(Ts0));\n\n    RETURN();\n\n}\n", "idx": 22250}
{"project": "qemu", "commit_id": "821c447675728ca06c8d2e4ac8a0e7a1adf775b8", "target": 1, "func": "static int send_status(int sockfd, struct iovec *iovec, int status)\n\n{\n\n    ProxyHeader header;\n\n    int retval, msg_size;\n\n\n\n    if (status < 0) {\n\n        header.type = T_ERROR;\n\n    } else {\n\n        header.type = T_SUCCESS;\n\n\n    header.size = sizeof(status);\n\n    /*\n\n     * marshal the return status. We don't check error.\n\n     * because we are sure we have enough space for the status\n\n     */\n\n    msg_size = proxy_marshal(iovec, 0, \"ddd\", header.type,\n\n                             header.size, status);\n\n\n\n\n    retval = socket_write(sockfd, iovec->iov_base, msg_size);\n\n    if (retval < 0) {\n\n        return retval;\n\n\n    return 0;\n", "idx": 22252}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "int64_t qmp_query_migrate_cache_size(Error **errp)\n\n{\n\n    return migrate_xbzrle_cache_size();\n\n}\n", "idx": 22254}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(addic)\n\n{\n\n    T1 = T0;\n\n    T0 += PARAM(1);\n\n    if (T0 < T1) {\n\n        xer_ca = 1;\n\n    } else {\n\n        xer_ca = 0;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 22257}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_update_position(QEMUFile *f, size_t size)\n\n{\n\n    f->pos += size;\n\n}\n", "idx": 22258}
{"project": "qemu", "commit_id": "4d1628e832dfc6ec02b0d196f6cc250aaa7bf3b3", "target": 1, "func": "static ExitStatus translate_one(DisasContext *ctx, uint32_t insn)\n\n{\n\n    int32_t disp21, disp16, disp12 __attribute__((unused));\n\n    uint16_t fn11;\n\n    uint8_t opc, ra, rb, rc, fpfn, fn7, lit;\n\n    bool islit;\n\n    TCGv va, vb, vc, tmp;\n\n    TCGv_i32 t32;\n\n    ExitStatus ret;\n\n\n\n    /* Decode all instruction fields */\n\n    opc = extract32(insn, 26, 6);\n\n    ra = extract32(insn, 21, 5);\n\n    rb = extract32(insn, 16, 5);\n\n    rc = extract32(insn, 0, 5);\n\n    islit = extract32(insn, 12, 1);\n\n    lit = extract32(insn, 13, 8);\n\n\n\n    disp21 = sextract32(insn, 0, 21);\n\n    disp16 = sextract32(insn, 0, 16);\n\n    disp12 = sextract32(insn, 0, 12);\n\n\n\n    fn11 = extract32(insn, 5, 11);\n\n    fpfn = extract32(insn, 5, 6);\n\n    fn7 = extract32(insn, 5, 7);\n\n\n\n    if (rb == 31 && !islit) {\n\n        islit = true;\n\n        lit = 0;\n\n    }\n\n\n\n    ret = NO_EXIT;\n\n    switch (opc) {\n\n    case 0x00:\n\n        /* CALL_PAL */\n\n        ret = gen_call_pal(ctx, insn & 0x03ffffff);\n\n        break;\n\n    case 0x01:\n\n        /* OPC01 */\n\n        goto invalid_opc;\n\n    case 0x02:\n\n        /* OPC02 */\n\n        goto invalid_opc;\n\n    case 0x03:\n\n        /* OPC03 */\n\n        goto invalid_opc;\n\n    case 0x04:\n\n        /* OPC04 */\n\n        goto invalid_opc;\n\n    case 0x05:\n\n        /* OPC05 */\n\n        goto invalid_opc;\n\n    case 0x06:\n\n        /* OPC06 */\n\n        goto invalid_opc;\n\n    case 0x07:\n\n        /* OPC07 */\n\n        goto invalid_opc;\n\n\n\n    case 0x09:\n\n        /* LDAH */\n\n        disp16 = (uint32_t)disp16 << 16;\n\n        /* fall through */\n\n    case 0x08:\n\n        /* LDA */\n\n        va = dest_gpr(ctx, ra);\n\n        /* It's worth special-casing immediate loads.  */\n\n        if (rb == 31) {\n\n            tcg_gen_movi_i64(va, disp16);\n\n        } else {\n\n            tcg_gen_addi_i64(va, load_gpr(ctx, rb), disp16);\n\n        }\n\n        break;\n\n\n\n    case 0x0A:\n\n        /* LDBU */\n\n        REQUIRE_TB_FLAG(TB_FLAGS_AMASK_BWX);\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld8u, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x0B:\n\n        /* LDQ_U */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld64, ra, rb, disp16, 0, 1);\n\n        break;\n\n    case 0x0C:\n\n        /* LDWU */\n\n        REQUIRE_TB_FLAG(TB_FLAGS_AMASK_BWX);\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld16u, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x0D:\n\n        /* STW */\n\n        REQUIRE_TB_FLAG(TB_FLAGS_AMASK_BWX);\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st16, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x0E:\n\n        /* STB */\n\n        REQUIRE_TB_FLAG(TB_FLAGS_AMASK_BWX);\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st8, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x0F:\n\n        /* STQ_U */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st64, ra, rb, disp16, 0, 1);\n\n        break;\n\n\n\n    case 0x10:\n\n        vc = dest_gpr(ctx, rc);\n\n        vb = load_gpr_lit(ctx, rb, lit, islit);\n\n\n\n        if (ra == 31) {\n\n            if (fn7 == 0x00) {\n\n                /* Special case ADDL as SEXTL.  */\n\n                tcg_gen_ext32s_i64(vc, vb);\n\n                break;\n\n            }\n\n            if (fn7 == 0x29) {\n\n                /* Special case SUBQ as NEGQ.  */\n\n                tcg_gen_neg_i64(vc, vb);\n\n                break;\n\n            }\n\n        }\n\n\n\n        va = load_gpr(ctx, ra);\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* ADDL */\n\n            tcg_gen_add_i64(vc, va, vb);\n\n            tcg_gen_ext32s_i64(vc, vc);\n\n            break;\n\n        case 0x02:\n\n            /* S4ADDL */\n\n            tmp = tcg_temp_new();\n\n            tcg_gen_shli_i64(tmp, va, 2);\n\n            tcg_gen_add_i64(tmp, tmp, vb);\n\n            tcg_gen_ext32s_i64(vc, tmp);\n\n            tcg_temp_free(tmp);\n\n            break;\n\n        case 0x09:\n\n            /* SUBL */\n\n            tcg_gen_sub_i64(vc, va, vb);\n\n            tcg_gen_ext32s_i64(vc, vc);\n\n            break;\n\n        case 0x0B:\n\n            /* S4SUBL */\n\n            tmp = tcg_temp_new();\n\n            tcg_gen_shli_i64(tmp, va, 2);\n\n            tcg_gen_sub_i64(tmp, tmp, vb);\n\n            tcg_gen_ext32s_i64(vc, tmp);\n\n            tcg_temp_free(tmp);\n\n            break;\n\n        case 0x0F:\n\n            /* CMPBGE */\n\n            gen_helper_cmpbge(vc, va, vb);\n\n            break;\n\n        case 0x12:\n\n            /* S8ADDL */\n\n            tmp = tcg_temp_new();\n\n            tcg_gen_shli_i64(tmp, va, 3);\n\n            tcg_gen_add_i64(tmp, tmp, vb);\n\n            tcg_gen_ext32s_i64(vc, tmp);\n\n            tcg_temp_free(tmp);\n\n            break;\n\n        case 0x1B:\n\n            /* S8SUBL */\n\n            tmp = tcg_temp_new();\n\n            tcg_gen_shli_i64(tmp, va, 3);\n\n            tcg_gen_sub_i64(tmp, tmp, vb);\n\n            tcg_gen_ext32s_i64(vc, tmp);\n\n            tcg_temp_free(tmp);\n\n            break;\n\n        case 0x1D:\n\n            /* CMPULT */\n\n            tcg_gen_setcond_i64(TCG_COND_LTU, vc, va, vb);\n\n            break;\n\n        case 0x20:\n\n            /* ADDQ */\n\n            tcg_gen_add_i64(vc, va, vb);\n\n            break;\n\n        case 0x22:\n\n            /* S4ADDQ */\n\n            tmp = tcg_temp_new();\n\n            tcg_gen_shli_i64(tmp, va, 2);\n\n            tcg_gen_add_i64(vc, tmp, vb);\n\n            tcg_temp_free(tmp);\n\n            break;\n\n        case 0x29:\n\n            /* SUBQ */\n\n            tcg_gen_sub_i64(vc, va, vb);\n\n            break;\n\n        case 0x2B:\n\n            /* S4SUBQ */\n\n            tmp = tcg_temp_new();\n\n            tcg_gen_shli_i64(tmp, va, 2);\n\n            tcg_gen_sub_i64(vc, tmp, vb);\n\n            tcg_temp_free(tmp);\n\n            break;\n\n        case 0x2D:\n\n            /* CMPEQ */\n\n            tcg_gen_setcond_i64(TCG_COND_EQ, vc, va, vb);\n\n            break;\n\n        case 0x32:\n\n            /* S8ADDQ */\n\n            tmp = tcg_temp_new();\n\n            tcg_gen_shli_i64(tmp, va, 3);\n\n            tcg_gen_add_i64(vc, tmp, vb);\n\n            tcg_temp_free(tmp);\n\n            break;\n\n        case 0x3B:\n\n            /* S8SUBQ */\n\n            tmp = tcg_temp_new();\n\n            tcg_gen_shli_i64(tmp, va, 3);\n\n            tcg_gen_sub_i64(vc, tmp, vb);\n\n            tcg_temp_free(tmp);\n\n            break;\n\n        case 0x3D:\n\n            /* CMPULE */\n\n            tcg_gen_setcond_i64(TCG_COND_LEU, vc, va, vb);\n\n            break;\n\n        case 0x40:\n\n            /* ADDL/V */\n\n            gen_helper_addlv(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x49:\n\n            /* SUBL/V */\n\n            gen_helper_sublv(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x4D:\n\n            /* CMPLT */\n\n            tcg_gen_setcond_i64(TCG_COND_LT, vc, va, vb);\n\n            break;\n\n        case 0x60:\n\n            /* ADDQ/V */\n\n            gen_helper_addqv(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x69:\n\n            /* SUBQ/V */\n\n            gen_helper_subqv(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x6D:\n\n            /* CMPLE */\n\n            tcg_gen_setcond_i64(TCG_COND_LE, vc, va, vb);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n\n\n    case 0x11:\n\n        if (fn7 == 0x20) {\n\n            if (rc == 31) {\n\n                /* Special case BIS as NOP.  */\n\n                break;\n\n            }\n\n            if (ra == 31) {\n\n                /* Special case BIS as MOV.  */\n\n                vc = dest_gpr(ctx, rc);\n\n                if (islit) {\n\n                    tcg_gen_movi_i64(vc, lit);\n\n                } else {\n\n                    tcg_gen_mov_i64(vc, load_gpr(ctx, rb));\n\n                }\n\n                break;\n\n            }\n\n        }\n\n\n\n        vc = dest_gpr(ctx, rc);\n\n        vb = load_gpr_lit(ctx, rb, lit, islit);\n\n\n\n        if (fn7 == 0x28 && ra == 31) {\n\n            /* Special case ORNOT as NOT.  */\n\n            tcg_gen_not_i64(vc, vb);\n\n            break;\n\n        }\n\n\n\n        va = load_gpr(ctx, ra);\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* AND */\n\n            tcg_gen_and_i64(vc, va, vb);\n\n            break;\n\n        case 0x08:\n\n            /* BIC */\n\n            tcg_gen_andc_i64(vc, va, vb);\n\n            break;\n\n        case 0x14:\n\n            /* CMOVLBS */\n\n            tmp = tcg_temp_new();\n\n            tcg_gen_andi_i64(tmp, va, 1);\n\n            tcg_gen_movcond_i64(TCG_COND_NE, vc, tmp, load_zero(ctx),\n\n                                vb, load_gpr(ctx, rc));\n\n            tcg_temp_free(tmp);\n\n            break;\n\n        case 0x16:\n\n            /* CMOVLBC */\n\n            tmp = tcg_temp_new();\n\n            tcg_gen_andi_i64(tmp, va, 1);\n\n            tcg_gen_movcond_i64(TCG_COND_EQ, vc, tmp, load_zero(ctx),\n\n                                vb, load_gpr(ctx, rc));\n\n            tcg_temp_free(tmp);\n\n            break;\n\n        case 0x20:\n\n            /* BIS */\n\n            tcg_gen_or_i64(vc, va, vb);\n\n            break;\n\n        case 0x24:\n\n            /* CMOVEQ */\n\n            tcg_gen_movcond_i64(TCG_COND_EQ, vc, va, load_zero(ctx),\n\n                                vb, load_gpr(ctx, rc));\n\n            break;\n\n        case 0x26:\n\n            /* CMOVNE */\n\n            tcg_gen_movcond_i64(TCG_COND_NE, vc, va, load_zero(ctx),\n\n                                vb, load_gpr(ctx, rc));\n\n            break;\n\n        case 0x28:\n\n            /* ORNOT */\n\n            tcg_gen_orc_i64(vc, va, vb);\n\n            break;\n\n        case 0x40:\n\n            /* XOR */\n\n            tcg_gen_xor_i64(vc, va, vb);\n\n            break;\n\n        case 0x44:\n\n            /* CMOVLT */\n\n            tcg_gen_movcond_i64(TCG_COND_LT, vc, va, load_zero(ctx),\n\n                                vb, load_gpr(ctx, rc));\n\n            break;\n\n        case 0x46:\n\n            /* CMOVGE */\n\n            tcg_gen_movcond_i64(TCG_COND_GE, vc, va, load_zero(ctx),\n\n                                vb, load_gpr(ctx, rc));\n\n            break;\n\n        case 0x48:\n\n            /* EQV */\n\n            tcg_gen_eqv_i64(vc, va, vb);\n\n            break;\n\n        case 0x61:\n\n            /* AMASK */\n\n            REQUIRE_REG_31(ra);\n\n            {\n\n                uint64_t amask = ctx->tb->flags >> TB_FLAGS_AMASK_SHIFT;\n\n                tcg_gen_andi_i64(vc, vb, ~amask);\n\n            }\n\n            break;\n\n        case 0x64:\n\n            /* CMOVLE */\n\n            tcg_gen_movcond_i64(TCG_COND_LE, vc, va, load_zero(ctx),\n\n                                vb, load_gpr(ctx, rc));\n\n            break;\n\n        case 0x66:\n\n            /* CMOVGT */\n\n            tcg_gen_movcond_i64(TCG_COND_GT, vc, va, load_zero(ctx),\n\n                                vb, load_gpr(ctx, rc));\n\n            break;\n\n        case 0x6C:\n\n            /* IMPLVER */\n\n            REQUIRE_REG_31(ra);\n\n            tcg_gen_movi_i64(vc, ctx->implver);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n\n\n    case 0x12:\n\n        vc = dest_gpr(ctx, rc);\n\n        va = load_gpr(ctx, ra);\n\n        switch (fn7) {\n\n        case 0x02:\n\n            /* MSKBL */\n\n            gen_msk_l(ctx, vc, va, rb, islit, lit, 0x01);\n\n            break;\n\n        case 0x06:\n\n            /* EXTBL */\n\n            gen_ext_l(ctx, vc, va, rb, islit, lit, 0x01);\n\n            break;\n\n        case 0x0B:\n\n            /* INSBL */\n\n            gen_ins_l(ctx, vc, va, rb, islit, lit, 0x01);\n\n            break;\n\n        case 0x12:\n\n            /* MSKWL */\n\n            gen_msk_l(ctx, vc, va, rb, islit, lit, 0x03);\n\n            break;\n\n        case 0x16:\n\n            /* EXTWL */\n\n            gen_ext_l(ctx, vc, va, rb, islit, lit, 0x03);\n\n            break;\n\n        case 0x1B:\n\n            /* INSWL */\n\n            gen_ins_l(ctx, vc, va, rb, islit, lit, 0x03);\n\n            break;\n\n        case 0x22:\n\n            /* MSKLL */\n\n            gen_msk_l(ctx, vc, va, rb, islit, lit, 0x0f);\n\n            break;\n\n        case 0x26:\n\n            /* EXTLL */\n\n            gen_ext_l(ctx, vc, va, rb, islit, lit, 0x0f);\n\n            break;\n\n        case 0x2B:\n\n            /* INSLL */\n\n            gen_ins_l(ctx, vc, va, rb, islit, lit, 0x0f);\n\n            break;\n\n        case 0x30:\n\n            /* ZAP */\n\n            if (islit) {\n\n                gen_zapnoti(vc, va, ~lit);\n\n            } else {\n\n                gen_helper_zap(vc, va, load_gpr(ctx, rb));\n\n            }\n\n            break;\n\n        case 0x31:\n\n            /* ZAPNOT */\n\n            if (islit) {\n\n                gen_zapnoti(vc, va, lit);\n\n            } else {\n\n                gen_helper_zapnot(vc, va, load_gpr(ctx, rb));\n\n            }\n\n            break;\n\n        case 0x32:\n\n            /* MSKQL */\n\n            gen_msk_l(ctx, vc, va, rb, islit, lit, 0xff);\n\n            break;\n\n        case 0x34:\n\n            /* SRL */\n\n            if (islit) {\n\n                tcg_gen_shri_i64(vc, va, lit & 0x3f);\n\n            } else {\n\n                tmp = tcg_temp_new();\n\n                vb = load_gpr(ctx, rb);\n\n                tcg_gen_andi_i64(tmp, vb, 0x3f);\n\n                tcg_gen_shr_i64(vc, va, tmp);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n        case 0x36:\n\n            /* EXTQL */\n\n            gen_ext_l(ctx, vc, va, rb, islit, lit, 0xff);\n\n            break;\n\n        case 0x39:\n\n            /* SLL */\n\n            if (islit) {\n\n                tcg_gen_shli_i64(vc, va, lit & 0x3f);\n\n            } else {\n\n                tmp = tcg_temp_new();\n\n                vb = load_gpr(ctx, rb);\n\n                tcg_gen_andi_i64(tmp, vb, 0x3f);\n\n                tcg_gen_shl_i64(vc, va, tmp);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n        case 0x3B:\n\n            /* INSQL */\n\n            gen_ins_l(ctx, vc, va, rb, islit, lit, 0xff);\n\n            break;\n\n        case 0x3C:\n\n            /* SRA */\n\n            if (islit) {\n\n                tcg_gen_sari_i64(vc, va, lit & 0x3f);\n\n            } else {\n\n                tmp = tcg_temp_new();\n\n                vb = load_gpr(ctx, rb);\n\n                tcg_gen_andi_i64(tmp, vb, 0x3f);\n\n                tcg_gen_sar_i64(vc, va, tmp);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n        case 0x52:\n\n            /* MSKWH */\n\n            gen_msk_h(ctx, vc, va, rb, islit, lit, 0x03);\n\n            break;\n\n        case 0x57:\n\n            /* INSWH */\n\n            gen_ins_h(ctx, vc, va, rb, islit, lit, 0x03);\n\n            break;\n\n        case 0x5A:\n\n            /* EXTWH */\n\n            gen_ext_h(ctx, vc, va, rb, islit, lit, 0x03);\n\n            break;\n\n        case 0x62:\n\n            /* MSKLH */\n\n            gen_msk_h(ctx, vc, va, rb, islit, lit, 0x0f);\n\n            break;\n\n        case 0x67:\n\n            /* INSLH */\n\n            gen_ins_h(ctx, vc, va, rb, islit, lit, 0x0f);\n\n            break;\n\n        case 0x6A:\n\n            /* EXTLH */\n\n            gen_ext_h(ctx, vc, va, rb, islit, lit, 0x0f);\n\n            break;\n\n        case 0x72:\n\n            /* MSKQH */\n\n            gen_msk_h(ctx, vc, va, rb, islit, lit, 0xff);\n\n            break;\n\n        case 0x77:\n\n            /* INSQH */\n\n            gen_ins_h(ctx, vc, va, rb, islit, lit, 0xff);\n\n            break;\n\n        case 0x7A:\n\n            /* EXTQH */\n\n            gen_ext_h(ctx, vc, va, rb, islit, lit, 0xff);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n\n\n    case 0x13:\n\n        vc = dest_gpr(ctx, rc);\n\n        vb = load_gpr_lit(ctx, rb, lit, islit);\n\n        va = load_gpr(ctx, ra);\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* MULL */\n\n            tcg_gen_mul_i64(vc, va, vb);\n\n            tcg_gen_ext32s_i64(vc, vc);\n\n            break;\n\n        case 0x20:\n\n            /* MULQ */\n\n            tcg_gen_mul_i64(vc, va, vb);\n\n            break;\n\n        case 0x30:\n\n            /* UMULH */\n\n            tmp = tcg_temp_new();\n\n            tcg_gen_mulu2_i64(tmp, vc, va, vb);\n\n            tcg_temp_free(tmp);\n\n            break;\n\n        case 0x40:\n\n            /* MULL/V */\n\n            gen_helper_mullv(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x60:\n\n            /* MULQ/V */\n\n            gen_helper_mulqv(vc, cpu_env, va, vb);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n\n\n    case 0x14:\n\n        REQUIRE_TB_FLAG(TB_FLAGS_AMASK_FIX);\n\n        vc = dest_fpr(ctx, rc);\n\n        switch (fpfn) { /* fn11 & 0x3F */\n\n        case 0x04:\n\n            /* ITOFS */\n\n            REQUIRE_REG_31(rb);\n\n            t32 = tcg_temp_new_i32();\n\n            va = load_gpr(ctx, ra);\n\n            tcg_gen_trunc_i64_i32(t32, va);\n\n            gen_helper_memory_to_s(vc, t32);\n\n            tcg_temp_free_i32(t32);\n\n            break;\n\n        case 0x0A:\n\n            /* SQRTF */\n\n            REQUIRE_REG_31(ra);\n\n            vb = load_fpr(ctx, rb);\n\n            gen_helper_sqrtf(vc, cpu_env, vb);\n\n            break;\n\n        case 0x0B:\n\n            /* SQRTS */\n\n            REQUIRE_REG_31(ra);\n\n            gen_sqrts(ctx, rb, rc, fn11);\n\n            break;\n\n        case 0x14:\n\n            /* ITOFF */\n\n            REQUIRE_REG_31(rb);\n\n            t32 = tcg_temp_new_i32();\n\n            va = load_gpr(ctx, ra);\n\n            tcg_gen_trunc_i64_i32(t32, va);\n\n            gen_helper_memory_to_f(vc, t32);\n\n            tcg_temp_free_i32(t32);\n\n            break;\n\n        case 0x24:\n\n            /* ITOFT */\n\n            REQUIRE_REG_31(rb);\n\n            va = load_gpr(ctx, ra);\n\n            tcg_gen_mov_i64(vc, va);\n\n            break;\n\n        case 0x2A:\n\n            /* SQRTG */\n\n            REQUIRE_REG_31(ra);\n\n            vb = load_fpr(ctx, rb);\n\n            gen_helper_sqrtg(vc, cpu_env, vb);\n\n            break;\n\n        case 0x02B:\n\n            /* SQRTT */\n\n            REQUIRE_REG_31(ra);\n\n            gen_sqrtt(ctx, rb, rc, fn11);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n\n\n    case 0x15:\n\n        /* VAX floating point */\n\n        /* XXX: rounding mode and trap are ignored (!) */\n\n        vc = dest_fpr(ctx, rc);\n\n        vb = load_fpr(ctx, rb);\n\n        va = load_fpr(ctx, ra);\n\n        switch (fpfn) { /* fn11 & 0x3F */\n\n        case 0x00:\n\n            /* ADDF */\n\n            gen_helper_addf(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x01:\n\n            /* SUBF */\n\n            gen_helper_subf(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x02:\n\n            /* MULF */\n\n            gen_helper_mulf(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x03:\n\n            /* DIVF */\n\n            gen_helper_divf(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x1E:\n\n            /* CVTDG -- TODO */\n\n            REQUIRE_REG_31(ra);\n\n            goto invalid_opc;\n\n        case 0x20:\n\n            /* ADDG */\n\n            gen_helper_addg(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x21:\n\n            /* SUBG */\n\n            gen_helper_subg(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x22:\n\n            /* MULG */\n\n            gen_helper_mulg(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x23:\n\n            /* DIVG */\n\n            gen_helper_divg(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x25:\n\n            /* CMPGEQ */\n\n            gen_helper_cmpgeq(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x26:\n\n            /* CMPGLT */\n\n            gen_helper_cmpglt(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x27:\n\n            /* CMPGLE */\n\n            gen_helper_cmpgle(vc, cpu_env, va, vb);\n\n            break;\n\n        case 0x2C:\n\n            /* CVTGF */\n\n            REQUIRE_REG_31(ra);\n\n            gen_helper_cvtgf(vc, cpu_env, vb);\n\n            break;\n\n        case 0x2D:\n\n            /* CVTGD -- TODO */\n\n            REQUIRE_REG_31(ra);\n\n            goto invalid_opc;\n\n        case 0x2F:\n\n            /* CVTGQ */\n\n            REQUIRE_REG_31(ra);\n\n            gen_helper_cvtgq(vc, cpu_env, vb);\n\n            break;\n\n        case 0x3C:\n\n            /* CVTQF */\n\n            REQUIRE_REG_31(ra);\n\n            gen_helper_cvtqf(vc, cpu_env, vb);\n\n            break;\n\n        case 0x3E:\n\n            /* CVTQG */\n\n            REQUIRE_REG_31(ra);\n\n            gen_helper_cvtqg(vc, cpu_env, vb);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n\n\n    case 0x16:\n\n        /* IEEE floating-point */\n\n        switch (fpfn) { /* fn11 & 0x3F */\n\n        case 0x00:\n\n            /* ADDS */\n\n            gen_adds(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x01:\n\n            /* SUBS */\n\n            gen_subs(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x02:\n\n            /* MULS */\n\n            gen_muls(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x03:\n\n            /* DIVS */\n\n            gen_divs(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x20:\n\n            /* ADDT */\n\n            gen_addt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x21:\n\n            /* SUBT */\n\n            gen_subt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x22:\n\n            /* MULT */\n\n            gen_mult(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x23:\n\n            /* DIVT */\n\n            gen_divt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x24:\n\n            /* CMPTUN */\n\n            gen_cmptun(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x25:\n\n            /* CMPTEQ */\n\n            gen_cmpteq(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x26:\n\n            /* CMPTLT */\n\n            gen_cmptlt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x27:\n\n            /* CMPTLE */\n\n            gen_cmptle(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x2C:\n\n            REQUIRE_REG_31(ra);\n\n            if (fn11 == 0x2AC || fn11 == 0x6AC) {\n\n                /* CVTST */\n\n                gen_cvtst(ctx, rb, rc, fn11);\n\n            } else {\n\n                /* CVTTS */\n\n                gen_cvtts(ctx, rb, rc, fn11);\n\n            }\n\n            break;\n\n        case 0x2F:\n\n            /* CVTTQ */\n\n            REQUIRE_REG_31(ra);\n\n            gen_cvttq(ctx, rb, rc, fn11);\n\n            break;\n\n        case 0x3C:\n\n            /* CVTQS */\n\n            REQUIRE_REG_31(ra);\n\n            gen_cvtqs(ctx, rb, rc, fn11);\n\n            break;\n\n        case 0x3E:\n\n            /* CVTQT */\n\n            REQUIRE_REG_31(ra);\n\n            gen_cvtqt(ctx, rb, rc, fn11);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n\n\n    case 0x17:\n\n        switch (fn11) {\n\n        case 0x010:\n\n            /* CVTLQ */\n\n            REQUIRE_REG_31(ra);\n\n            vc = dest_fpr(ctx, rc);\n\n            vb = load_fpr(ctx, rb);\n\n            gen_cvtlq(vc, vb);\n\n            break;\n\n        case 0x020:\n\n            /* CPYS */\n\n            if (rc == 31) {\n\n                /* Special case CPYS as FNOP.  */\n\n            } else {\n\n                vc = dest_fpr(ctx, rc);\n\n                va = load_fpr(ctx, ra);\n\n                if (ra == rb) {\n\n                    /* Special case CPYS as FMOV.  */\n\n                    tcg_gen_mov_i64(vc, va);\n\n                } else {\n\n                    vb = load_fpr(ctx, rb);\n\n                    gen_cpy_mask(vc, va, vb, 0, 0x8000000000000000ULL);\n\n                }\n\n            }\n\n            break;\n\n        case 0x021:\n\n            /* CPYSN */\n\n            vc = dest_fpr(ctx, rc);\n\n            vb = load_fpr(ctx, rb);\n\n            va = load_fpr(ctx, ra);\n\n            gen_cpy_mask(vc, va, vb, 1, 0x8000000000000000ULL);\n\n            break;\n\n        case 0x022:\n\n            /* CPYSE */\n\n            vc = dest_fpr(ctx, rc);\n\n            vb = load_fpr(ctx, rb);\n\n            va = load_fpr(ctx, ra);\n\n            gen_cpy_mask(vc, va, vb, 0, 0xFFF0000000000000ULL);\n\n            break;\n\n        case 0x024:\n\n            /* MT_FPCR */\n\n            va = load_fpr(ctx, ra);\n\n            gen_helper_store_fpcr(cpu_env, va);\n\n            if (ctx->tb_rm == QUAL_RM_D) {\n\n                /* Re-do the copy of the rounding mode to fp_status\n\n                   the next time we use dynamic rounding.  */\n\n                ctx->tb_rm = -1;\n\n            }\n\n            break;\n\n        case 0x025:\n\n            /* MF_FPCR */\n\n            va = dest_fpr(ctx, ra);\n\n            gen_helper_load_fpcr(va, cpu_env);\n\n            break;\n\n        case 0x02A:\n\n            /* FCMOVEQ */\n\n            gen_fcmov(ctx, TCG_COND_EQ, ra, rb, rc);\n\n            break;\n\n        case 0x02B:\n\n            /* FCMOVNE */\n\n            gen_fcmov(ctx, TCG_COND_NE, ra, rb, rc);\n\n            break;\n\n        case 0x02C:\n\n            /* FCMOVLT */\n\n            gen_fcmov(ctx, TCG_COND_LT, ra, rb, rc);\n\n            break;\n\n        case 0x02D:\n\n            /* FCMOVGE */\n\n            gen_fcmov(ctx, TCG_COND_GE, ra, rb, rc);\n\n            break;\n\n        case 0x02E:\n\n            /* FCMOVLE */\n\n            gen_fcmov(ctx, TCG_COND_LE, ra, rb, rc);\n\n            break;\n\n        case 0x02F:\n\n            /* FCMOVGT */\n\n            gen_fcmov(ctx, TCG_COND_GT, ra, rb, rc);\n\n            break;\n\n        case 0x030:\n\n            /* CVTQL */\n\n            REQUIRE_REG_31(ra);\n\n            vc = dest_fpr(ctx, rc);\n\n            vb = load_fpr(ctx, rb);\n\n            gen_cvtql(vc, vb);\n\n            break;\n\n        case 0x130:\n\n            /* CVTQL/V */\n\n        case 0x530:\n\n            /* CVTQL/SV */\n\n            REQUIRE_REG_31(ra);\n\n            /* ??? I'm pretty sure there's nothing that /sv needs to do that\n\n               /v doesn't do.  The only thing I can think is that /sv is a\n\n               valid instruction merely for completeness in the ISA.  */\n\n            vc = dest_fpr(ctx, rc);\n\n            vb = load_fpr(ctx, rb);\n\n            gen_helper_cvtql_v_input(cpu_env, vb);\n\n            gen_cvtql(vc, vb);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n\n\n    case 0x18:\n\n        switch ((uint16_t)disp16) {\n\n        case 0x0000:\n\n            /* TRAPB */\n\n            /* No-op.  */\n\n            break;\n\n        case 0x0400:\n\n            /* EXCB */\n\n            /* No-op.  */\n\n            break;\n\n        case 0x4000:\n\n            /* MB */\n\n            /* No-op */\n\n            break;\n\n        case 0x4400:\n\n            /* WMB */\n\n            /* No-op */\n\n            break;\n\n        case 0x8000:\n\n            /* FETCH */\n\n            /* No-op */\n\n            break;\n\n        case 0xA000:\n\n            /* FETCH_M */\n\n            /* No-op */\n\n            break;\n\n        case 0xC000:\n\n            /* RPCC */\n\n            va = dest_gpr(ctx, ra);\n\n            if (ctx->tb->cflags & CF_USE_ICOUNT) {\n\n                gen_io_start();\n\n                gen_helper_load_pcc(va, cpu_env);\n\n                gen_io_end();\n\n                ret = EXIT_PC_STALE;\n\n            } else {\n\n                gen_helper_load_pcc(va, cpu_env);\n\n            }\n\n            break;\n\n        case 0xE000:\n\n            /* RC */\n\n            gen_rx(ra, 0);\n\n            break;\n\n        case 0xE800:\n\n            /* ECB */\n\n            break;\n\n        case 0xF000:\n\n            /* RS */\n\n            gen_rx(ra, 1);\n\n            break;\n\n        case 0xF800:\n\n            /* WH64 */\n\n            /* No-op */\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n\n\n    case 0x19:\n\n        /* HW_MFPR (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        REQUIRE_TB_FLAG(TB_FLAGS_PAL_MODE);\n\n        va = dest_gpr(ctx, ra);\n\n        ret = gen_mfpr(ctx, va, insn & 0xffff);\n\n        break;\n\n#else\n\n        goto invalid_opc;\n\n#endif\n\n\n\n    case 0x1A:\n\n        /* JMP, JSR, RET, JSR_COROUTINE.  These only differ by the branch\n\n           prediction stack action, which of course we don't implement.  */\n\n        vb = load_gpr(ctx, rb);\n\n        tcg_gen_andi_i64(cpu_pc, vb, ~3);\n\n        if (ra != 31) {\n\n            tcg_gen_movi_i64(cpu_ir[ra], ctx->pc);\n\n        }\n\n        ret = EXIT_PC_UPDATED;\n\n        break;\n\n\n\n    case 0x1B:\n\n        /* HW_LD (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        REQUIRE_TB_FLAG(TB_FLAGS_PAL_MODE);\n\n        {\n\n            TCGv addr = tcg_temp_new();\n\n            vb = load_gpr(ctx, rb);\n\n            va = dest_gpr(ctx, ra);\n\n\n\n            tcg_gen_addi_i64(addr, vb, disp12);\n\n            switch ((insn >> 12) & 0xF) {\n\n            case 0x0:\n\n                /* Longword physical access (hw_ldl/p) */\n\n                gen_helper_ldl_phys(va, cpu_env, addr);\n\n                break;\n\n            case 0x1:\n\n                /* Quadword physical access (hw_ldq/p) */\n\n                gen_helper_ldq_phys(va, cpu_env, addr);\n\n                break;\n\n            case 0x2:\n\n                /* Longword physical access with lock (hw_ldl_l/p) */\n\n                gen_helper_ldl_l_phys(va, cpu_env, addr);\n\n                break;\n\n            case 0x3:\n\n                /* Quadword physical access with lock (hw_ldq_l/p) */\n\n                gen_helper_ldq_l_phys(va, cpu_env, addr);\n\n                break;\n\n            case 0x4:\n\n                /* Longword virtual PTE fetch (hw_ldl/v) */\n\n                goto invalid_opc;\n\n            case 0x5:\n\n                /* Quadword virtual PTE fetch (hw_ldq/v) */\n\n                goto invalid_opc;\n\n                break;\n\n            case 0x6:\n\n                /* Incpu_ir[ra]id */\n\n                goto invalid_opc;\n\n            case 0x7:\n\n                /* Incpu_ir[ra]id */\n\n                goto invalid_opc;\n\n            case 0x8:\n\n                /* Longword virtual access (hw_ldl) */\n\n                goto invalid_opc;\n\n            case 0x9:\n\n                /* Quadword virtual access (hw_ldq) */\n\n                goto invalid_opc;\n\n            case 0xA:\n\n                /* Longword virtual access with protection check (hw_ldl/w) */\n\n                tcg_gen_qemu_ld_i64(va, addr, MMU_KERNEL_IDX, MO_LESL);\n\n                break;\n\n            case 0xB:\n\n                /* Quadword virtual access with protection check (hw_ldq/w) */\n\n                tcg_gen_qemu_ld_i64(va, addr, MMU_KERNEL_IDX, MO_LEQ);\n\n                break;\n\n            case 0xC:\n\n                /* Longword virtual access with alt access mode (hw_ldl/a)*/\n\n                goto invalid_opc;\n\n            case 0xD:\n\n                /* Quadword virtual access with alt access mode (hw_ldq/a) */\n\n                goto invalid_opc;\n\n            case 0xE:\n\n                /* Longword virtual access with alternate access mode and\n\n                   protection checks (hw_ldl/wa) */\n\n                tcg_gen_qemu_ld_i64(va, addr, MMU_USER_IDX, MO_LESL);\n\n                break;\n\n            case 0xF:\n\n                /* Quadword virtual access with alternate access mode and\n\n                   protection checks (hw_ldq/wa) */\n\n                tcg_gen_qemu_ld_i64(va, addr, MMU_USER_IDX, MO_LEQ);\n\n                break;\n\n            }\n\n            tcg_temp_free(addr);\n\n            break;\n\n        }\n\n#else\n\n        goto invalid_opc;\n\n#endif\n\n\n\n    case 0x1C:\n\n        vc = dest_gpr(ctx, rc);\n\n        if (fn7 == 0x70) {\n\n            /* FTOIT */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_FIX);\n\n            REQUIRE_REG_31(rb);\n\n            va = load_fpr(ctx, ra);\n\n            tcg_gen_mov_i64(vc, va);\n\n            break;\n\n        } else if (fn7 == 0x78) {\n\n            /* FTOIS */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_FIX);\n\n            REQUIRE_REG_31(rb);\n\n            t32 = tcg_temp_new_i32();\n\n            va = load_fpr(ctx, ra);\n\n            gen_helper_s_to_memory(t32, va);\n\n            tcg_gen_ext_i32_i64(vc, t32);\n\n            tcg_temp_free_i32(t32);\n\n            break;\n\n        }\n\n\n\n        vb = load_gpr_lit(ctx, rb, lit, islit);\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* SEXTB */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_BWX);\n\n            REQUIRE_REG_31(ra);\n\n            tcg_gen_ext8s_i64(vc, vb);\n\n            break;\n\n        case 0x01:\n\n            /* SEXTW */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_BWX);\n\n            REQUIRE_REG_31(ra);\n\n            tcg_gen_ext16s_i64(vc, vb);\n\n            break;\n\n        case 0x30:\n\n            /* CTPOP */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_CIX);\n\n            REQUIRE_REG_31(ra);\n\n            gen_helper_ctpop(vc, vb);\n\n            break;\n\n        case 0x31:\n\n            /* PERR */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_MVI);\n\n            va = load_gpr(ctx, ra);\n\n            gen_helper_perr(vc, va, vb);\n\n            break;\n\n        case 0x32:\n\n            /* CTLZ */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_CIX);\n\n            REQUIRE_REG_31(ra);\n\n            gen_helper_ctlz(vc, vb);\n\n            break;\n\n        case 0x33:\n\n            /* CTTZ */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_CIX);\n\n            REQUIRE_REG_31(ra);\n\n            gen_helper_cttz(vc, vb);\n\n            break;\n\n        case 0x34:\n\n            /* UNPKBW */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_MVI);\n\n            REQUIRE_REG_31(ra);\n\n            gen_helper_unpkbw(vc, vb);\n\n            break;\n\n        case 0x35:\n\n            /* UNPKBL */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_MVI);\n\n            REQUIRE_REG_31(ra);\n\n            gen_helper_unpkbl(vc, vb);\n\n            break;\n\n        case 0x36:\n\n            /* PKWB */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_MVI);\n\n            REQUIRE_REG_31(ra);\n\n            gen_helper_pkwb(vc, vb);\n\n            break;\n\n        case 0x37:\n\n            /* PKLB */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_MVI);\n\n            REQUIRE_REG_31(ra);\n\n            gen_helper_pklb(vc, vb);\n\n            break;\n\n        case 0x38:\n\n            /* MINSB8 */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_MVI);\n\n            va = load_gpr(ctx, ra);\n\n            gen_helper_minsb8(vc, va, vb);\n\n            break;\n\n        case 0x39:\n\n            /* MINSW4 */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_MVI);\n\n            va = load_gpr(ctx, ra);\n\n            gen_helper_minsw4(vc, va, vb);\n\n            break;\n\n        case 0x3A:\n\n            /* MINUB8 */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_MVI);\n\n            va = load_gpr(ctx, ra);\n\n            gen_helper_minub8(vc, va, vb);\n\n            break;\n\n        case 0x3B:\n\n            /* MINUW4 */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_MVI);\n\n            va = load_gpr(ctx, ra);\n\n            gen_helper_minuw4(vc, va, vb);\n\n            break;\n\n        case 0x3C:\n\n            /* MAXUB8 */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_MVI);\n\n            va = load_gpr(ctx, ra);\n\n            gen_helper_maxub8(vc, va, vb);\n\n            break;\n\n        case 0x3D:\n\n            /* MAXUW4 */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_MVI);\n\n            va = load_gpr(ctx, ra);\n\n            gen_helper_maxuw4(vc, va, vb);\n\n            break;\n\n        case 0x3E:\n\n            /* MAXSB8 */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_MVI);\n\n            va = load_gpr(ctx, ra);\n\n            gen_helper_maxsb8(vc, va, vb);\n\n            break;\n\n        case 0x3F:\n\n            /* MAXSW4 */\n\n            REQUIRE_TB_FLAG(TB_FLAGS_AMASK_MVI);\n\n            va = load_gpr(ctx, ra);\n\n            gen_helper_maxsw4(vc, va, vb);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n\n\n    case 0x1D:\n\n        /* HW_MTPR (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        REQUIRE_TB_FLAG(TB_FLAGS_PAL_MODE);\n\n        vb = load_gpr(ctx, rb);\n\n        ret = gen_mtpr(ctx, vb, insn & 0xffff);\n\n        break;\n\n#else\n\n        goto invalid_opc;\n\n#endif\n\n\n\n    case 0x1E:\n\n        /* HW_RET (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        REQUIRE_TB_FLAG(TB_FLAGS_PAL_MODE);\n\n        if (rb == 31) {\n\n            /* Pre-EV6 CPUs interpreted this as HW_REI, loading the return\n\n               address from EXC_ADDR.  This turns out to be useful for our\n\n               emulation PALcode, so continue to accept it.  */\n\n            tmp = tcg_temp_new();\n\n            tcg_gen_ld_i64(tmp, cpu_env, offsetof(CPUAlphaState, exc_addr));\n\n            gen_helper_hw_ret(cpu_env, tmp);\n\n            tcg_temp_free(tmp);\n\n        } else {\n\n            gen_helper_hw_ret(cpu_env, load_gpr(ctx, rb));\n\n        }\n\n        ret = EXIT_PC_UPDATED;\n\n        break;\n\n#else\n\n        goto invalid_opc;\n\n#endif\n\n\n\n    case 0x1F:\n\n        /* HW_ST (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        REQUIRE_TB_FLAG(TB_FLAGS_PAL_MODE);\n\n        {\n\n            TCGv addr = tcg_temp_new();\n\n            va = load_gpr(ctx, ra);\n\n            vb = load_gpr(ctx, rb);\n\n\n\n            tcg_gen_addi_i64(addr, vb, disp12);\n\n            switch ((insn >> 12) & 0xF) {\n\n            case 0x0:\n\n                /* Longword physical access */\n\n                gen_helper_stl_phys(cpu_env, addr, va);\n\n                break;\n\n            case 0x1:\n\n                /* Quadword physical access */\n\n                gen_helper_stq_phys(cpu_env, addr, va);\n\n                break;\n\n            case 0x2:\n\n                /* Longword physical access with lock */\n\n                gen_helper_stl_c_phys(dest_gpr(ctx, ra), cpu_env, addr, va);\n\n                break;\n\n            case 0x3:\n\n                /* Quadword physical access with lock */\n\n                gen_helper_stq_c_phys(dest_gpr(ctx, ra), cpu_env, addr, va);\n\n                break;\n\n            case 0x4:\n\n                /* Longword virtual access */\n\n                goto invalid_opc;\n\n            case 0x5:\n\n                /* Quadword virtual access */\n\n                goto invalid_opc;\n\n            case 0x6:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0x7:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0x8:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0x9:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xA:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xB:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xC:\n\n                /* Longword virtual access with alternate access mode */\n\n                goto invalid_opc;\n\n            case 0xD:\n\n                /* Quadword virtual access with alternate access mode */\n\n                goto invalid_opc;\n\n            case 0xE:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xF:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            }\n\n            tcg_temp_free(addr);\n\n            break;\n\n        }\n\n#else\n\n        goto invalid_opc;\n\n#endif\n\n    case 0x20:\n\n        /* LDF */\n\n        gen_load_mem(ctx, &gen_qemu_ldf, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x21:\n\n        /* LDG */\n\n        gen_load_mem(ctx, &gen_qemu_ldg, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x22:\n\n        /* LDS */\n\n        gen_load_mem(ctx, &gen_qemu_lds, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x23:\n\n        /* LDT */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld64, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x24:\n\n        /* STF */\n\n        gen_store_mem(ctx, &gen_qemu_stf, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x25:\n\n        /* STG */\n\n        gen_store_mem(ctx, &gen_qemu_stg, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x26:\n\n        /* STS */\n\n        gen_store_mem(ctx, &gen_qemu_sts, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x27:\n\n        /* STT */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st64, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x28:\n\n        /* LDL */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld32s, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x29:\n\n        /* LDQ */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld64, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2A:\n\n        /* LDL_L */\n\n        gen_load_mem(ctx, &gen_qemu_ldl_l, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2B:\n\n        /* LDQ_L */\n\n        gen_load_mem(ctx, &gen_qemu_ldq_l, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2C:\n\n        /* STL */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st32, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2D:\n\n        /* STQ */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st64, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2E:\n\n        /* STL_C */\n\n        ret = gen_store_conditional(ctx, ra, rb, disp16, 0);\n\n        break;\n\n    case 0x2F:\n\n        /* STQ_C */\n\n        ret = gen_store_conditional(ctx, ra, rb, disp16, 1);\n\n        break;\n\n    case 0x30:\n\n        /* BR */\n\n        ret = gen_bdirect(ctx, ra, disp21);\n\n        break;\n\n    case 0x31: /* FBEQ */\n\n        ret = gen_fbcond(ctx, TCG_COND_EQ, ra, disp21);\n\n        break;\n\n    case 0x32: /* FBLT */\n\n        ret = gen_fbcond(ctx, TCG_COND_LT, ra, disp21);\n\n        break;\n\n    case 0x33: /* FBLE */\n\n        ret = gen_fbcond(ctx, TCG_COND_LE, ra, disp21);\n\n        break;\n\n    case 0x34:\n\n        /* BSR */\n\n        ret = gen_bdirect(ctx, ra, disp21);\n\n        break;\n\n    case 0x35: /* FBNE */\n\n        ret = gen_fbcond(ctx, TCG_COND_NE, ra, disp21);\n\n        break;\n\n    case 0x36: /* FBGE */\n\n        ret = gen_fbcond(ctx, TCG_COND_GE, ra, disp21);\n\n        break;\n\n    case 0x37: /* FBGT */\n\n        ret = gen_fbcond(ctx, TCG_COND_GT, ra, disp21);\n\n        break;\n\n    case 0x38:\n\n        /* BLBC */\n\n        ret = gen_bcond(ctx, TCG_COND_EQ, ra, disp21, 1);\n\n        break;\n\n    case 0x39:\n\n        /* BEQ */\n\n        ret = gen_bcond(ctx, TCG_COND_EQ, ra, disp21, 0);\n\n        break;\n\n    case 0x3A:\n\n        /* BLT */\n\n        ret = gen_bcond(ctx, TCG_COND_LT, ra, disp21, 0);\n\n        break;\n\n    case 0x3B:\n\n        /* BLE */\n\n        ret = gen_bcond(ctx, TCG_COND_LE, ra, disp21, 0);\n\n        break;\n\n    case 0x3C:\n\n        /* BLBS */\n\n        ret = gen_bcond(ctx, TCG_COND_NE, ra, disp21, 1);\n\n        break;\n\n    case 0x3D:\n\n        /* BNE */\n\n        ret = gen_bcond(ctx, TCG_COND_NE, ra, disp21, 0);\n\n        break;\n\n    case 0x3E:\n\n        /* BGE */\n\n        ret = gen_bcond(ctx, TCG_COND_GE, ra, disp21, 0);\n\n        break;\n\n    case 0x3F:\n\n        /* BGT */\n\n        ret = gen_bcond(ctx, TCG_COND_GT, ra, disp21, 0);\n\n        break;\n\n    invalid_opc:\n\n        ret = gen_invalid(ctx);\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 22259}
{"project": "qemu", "commit_id": "51cc2e783af5586b2e742ce9e5b2762dc50ad325", "target": 1, "func": "CPUMIPSState *cpu_mips_init (const char *cpu_model)\n\n{\n\n    CPUMIPSState *env;\n\n    const mips_def_t *def;\n\n\n\n    def = cpu_mips_find_by_name(cpu_model);\n\n    if (!def)\n\n        return NULL;\n\n    env = qemu_mallocz(sizeof(CPUMIPSState));\n\n    env->cpu_model = def;\n\n\n\n    cpu_exec_init(env);\n\n    env->cpu_model_str = cpu_model;\n\n    mips_tcg_init();\n\n    cpu_reset(env);\n\n    qemu_init_vcpu(env);\n\n    return env;\n\n}\n", "idx": 22260}
{"project": "qemu", "commit_id": "2531088f6c1ce1f620f8d5a545f0af95598e69fc", "target": 1, "func": "uint32_t gic_acknowledge_irq(GICState *s, int cpu, MemTxAttrs attrs)\n\n{\n\n    int ret, irq, src;\n\n    int cm = 1 << cpu;\n\n\n\n    /* gic_get_current_pending_irq() will return 1022 or 1023 appropriately\n\n     * for the case where this GIC supports grouping and the pending interrupt\n\n     * is in the wrong group.\n\n     */\n\n    irq = gic_get_current_pending_irq(s, cpu, attrs);\n\n\n\n\n    if (irq >= GIC_MAXIRQ) {\n\n        DPRINTF(\"ACK, no pending interrupt or it is hidden: %d\\n\", irq);\n\n        return irq;\n\n    }\n\n\n\n    if (GIC_GET_PRIORITY(irq, cpu) >= s->running_priority[cpu]) {\n\n        DPRINTF(\"ACK, pending interrupt (%d) has insufficient priority\\n\", irq);\n\n        return 1023;\n\n    }\n\n\n\n    if (s->revision == REV_11MPCORE || s->revision == REV_NVIC) {\n\n        /* Clear pending flags for both level and edge triggered interrupts.\n\n         * Level triggered IRQs will be reasserted once they become inactive.\n\n         */\n\n        GIC_CLEAR_PENDING(irq, GIC_TEST_MODEL(irq) ? ALL_CPU_MASK : cm);\n\n        ret = irq;\n\n    } else {\n\n        if (irq < GIC_NR_SGIS) {\n\n            /* Lookup the source CPU for the SGI and clear this in the\n\n             * sgi_pending map.  Return the src and clear the overall pending\n\n             * state on this CPU if the SGI is not pending from any CPUs.\n\n             */\n\n            assert(s->sgi_pending[irq][cpu] != 0);\n\n            src = ctz32(s->sgi_pending[irq][cpu]);\n\n            s->sgi_pending[irq][cpu] &= ~(1 << src);\n\n            if (s->sgi_pending[irq][cpu] == 0) {\n\n                GIC_CLEAR_PENDING(irq, GIC_TEST_MODEL(irq) ? ALL_CPU_MASK : cm);\n\n            }\n\n            ret = irq | ((src & 0x7) << 10);\n\n        } else {\n\n            /* Clear pending state for both level and edge triggered\n\n             * interrupts. (level triggered interrupts with an active line\n\n             * remain pending, see gic_test_pending)\n\n             */\n\n            GIC_CLEAR_PENDING(irq, GIC_TEST_MODEL(irq) ? ALL_CPU_MASK : cm);\n\n            ret = irq;\n\n        }\n\n    }\n\n\n\n    gic_activate_irq(s, cpu, irq);\n\n    gic_update(s);\n\n    DPRINTF(\"ACK %d\\n\", irq);\n\n    return ret;\n\n}", "idx": 22261}
{"project": "qemu", "commit_id": "fd5723b385557bc77b93dfe5ab591813407686c0", "target": 1, "func": "static void *qpa_thread_out (void *arg)\n\n{\n\n    PAVoiceOut *pa = arg;\n\n    HWVoiceOut *hw = &pa->hw;\n\n    int threshold;\n\n\n\n    threshold = conf.divisor ? hw->samples / conf.divisor : 0;\n\n\n\n    if (audio_pt_lock (&pa->pt, AUDIO_FUNC)) {\n\n        return NULL;\n\n    }\n\n\n\n    for (;;) {\n\n        int decr, to_mix, rpos;\n\n\n\n        for (;;) {\n\n            if (pa->done) {\n\n                goto exit;\n\n            }\n\n\n\n            if (pa->live > threshold) {\n\n                break;\n\n            }\n\n\n\n            if (audio_pt_wait (&pa->pt, AUDIO_FUNC)) {\n\n                goto exit;\n\n            }\n\n        }\n\n\n\n        decr = to_mix = pa->live;\n\n        rpos = hw->rpos;\n\n\n\n        if (audio_pt_unlock (&pa->pt, AUDIO_FUNC)) {\n\n            return NULL;\n\n        }\n\n\n\n        while (to_mix) {\n\n            int error;\n\n            int chunk = audio_MIN (to_mix, hw->samples - rpos);\n\n            struct st_sample *src = hw->mix_buf + rpos;\n\n\n\n            hw->clip (pa->pcm_buf, src, chunk);\n\n\n\n            if (pa_simple_write (pa->s, pa->pcm_buf,\n\n                                 chunk << hw->info.shift, &error) < 0) {\n\n                qpa_logerr (error, \"pa_simple_write failed\\n\");\n\n                return NULL;\n\n            }\n\n\n\n            rpos = (rpos + chunk) % hw->samples;\n\n            to_mix -= chunk;\n\n        }\n\n\n\n        if (audio_pt_lock (&pa->pt, AUDIO_FUNC)) {\n\n            return NULL;\n\n        }\n\n\n\n        pa->rpos = rpos;\n\n        pa->live -= decr;\n\n        pa->decr += decr;\n\n    }\n\n\n\n exit:\n\n    audio_pt_unlock (&pa->pt, AUDIO_FUNC);\n\n    return NULL;\n\n}\n", "idx": 22262}
{"project": "qemu", "commit_id": "b68cb06093a36bd6fbd4d06cd62c08629fea2242", "target": 1, "func": "static void complete_collecting_data(Flash *s)\n\n{\n\n    int i;\n\n\n\n    s->cur_addr = 0;\n\n\n\n    for (i = 0; i < get_addr_length(s); ++i) {\n\n        s->cur_addr <<= 8;\n\n        s->cur_addr |= s->data[i];\n\n    }\n\n\n\n    if (get_addr_length(s) == 3) {\n\n        s->cur_addr += s->ear * MAX_3BYTES_SIZE;\n\n    }\n\n\n\n    s->state = STATE_IDLE;\n\n\n\n    switch (s->cmd_in_progress) {\n\n    case DPP:\n\n    case QPP:\n\n    case PP:\n\n    case PP4:\n\n    case PP4_4:\n\n        s->state = STATE_PAGE_PROGRAM;\n\n        break;\n\n    case READ:\n\n    case READ4:\n\n    case FAST_READ:\n\n    case FAST_READ4:\n\n    case DOR:\n\n    case DOR4:\n\n    case QOR:\n\n    case QOR4:\n\n    case DIOR:\n\n    case DIOR4:\n\n    case QIOR:\n\n    case QIOR4:\n\n        s->state = STATE_READ;\n\n        break;\n\n    case ERASE_4K:\n\n    case ERASE4_4K:\n\n    case ERASE_32K:\n\n    case ERASE4_32K:\n\n    case ERASE_SECTOR:\n\n    case ERASE4_SECTOR:\n\n        flash_erase(s, s->cur_addr, s->cmd_in_progress);\n\n        break;\n\n    case WRSR:\n\n        switch (get_man(s)) {\n\n        case MAN_SPANSION:\n\n            s->quad_enable = !!(s->data[1] & 0x02);\n\n            break;\n\n        case MAN_MACRONIX:\n\n            s->quad_enable = extract32(s->data[0], 6, 1);\n\n            if (s->len > 1) {\n\n                s->four_bytes_address_mode = extract32(s->data[1], 5, 1);\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        if (s->write_enable) {\n\n            s->write_enable = false;\n\n        }\n\n        break;\n\n    case EXTEND_ADDR_WRITE:\n\n        s->ear = s->data[0];\n\n        break;\n\n    case WNVCR:\n\n        s->nonvolatile_cfg = s->data[0] | (s->data[1] << 8);\n\n        break;\n\n    case WVCR:\n\n        s->volatile_cfg = s->data[0];\n\n        break;\n\n    case WEVCR:\n\n        s->enh_volatile_cfg = s->data[0];\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 22263}
{"project": "qemu", "commit_id": "47ad35f16ae4b6b93cbfa238d51d4edc7dea90b5", "target": 1, "func": "static inline void gen_op_fpexception_im(int fsr_flags)\n\n{\n\n    TCGv r_const;\n\n\n\n    tcg_gen_andi_tl(cpu_fsr, cpu_fsr, ~FSR_FTT_MASK);\n\n    tcg_gen_ori_tl(cpu_fsr, cpu_fsr, fsr_flags);\n\n    r_const = tcg_const_i32(TT_FP_EXCP);\n\n    tcg_gen_helper_0_1(raise_exception, r_const);\n\n    tcg_temp_free(r_const);\n\n}\n", "idx": 22264}
{"project": "qemu", "commit_id": "113fe792fd4931dd0538f03859278b8719ee4fa2", "target": 1, "func": "static int nfs_file_open(BlockDriverState *bs, QDict *options, int flags,\n\n                         Error **errp) {\n\n    NFSClient *client = bs->opaque;\n\n    int64_t ret;\n\n\n\n    client->aio_context = bdrv_get_aio_context(bs);\n\n\n\n    ret = nfs_client_open(client, options,\n\n                          (flags & BDRV_O_RDWR) ? O_RDWR : O_RDONLY,\n\n                          bs->open_flags, errp);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    qemu_mutex_init(&client->mutex);\n\n    bs->total_sectors = ret;\n\n    ret = 0;\n\n    return ret;\n\n}\n", "idx": 22265}
{"project": "qemu", "commit_id": "79853e18d904b0a4bcef62701d48559688007c93", "target": 0, "func": "static void check_exception(PowerPCCPU *cpu, sPAPREnvironment *spapr,\n\n                            uint32_t token, uint32_t nargs,\n\n                            target_ulong args,\n\n                            uint32_t nret, target_ulong rets)\n\n{\n\n    uint32_t mask, buf, len, event_len;\n\n    uint64_t xinfo;\n\n    sPAPREventLogEntry *event;\n\n    struct rtas_error_log *hdr;\n\n\n\n    if ((nargs < 6) || (nargs > 7) || nret != 1) {\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    xinfo = rtas_ld(args, 1);\n\n    mask = rtas_ld(args, 2);\n\n    buf = rtas_ld(args, 4);\n\n    len = rtas_ld(args, 5);\n\n    if (nargs == 7) {\n\n        xinfo |= (uint64_t)rtas_ld(args, 6) << 32;\n\n    }\n\n\n\n    event = rtas_event_log_dequeue(mask);\n\n    if (!event) {\n\n        goto out_no_events;\n\n    }\n\n\n\n    hdr = event->data;\n\n    event_len = be32_to_cpu(hdr->extended_length) + sizeof(*hdr);\n\n\n\n    if (event_len < len) {\n\n        len = event_len;\n\n    }\n\n\n\n    cpu_physical_memory_write(buf, event->data, len);\n\n    rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n    g_free(event->data);\n\n    g_free(event);\n\n\n\n    /* according to PAPR+, the IRQ must be left asserted, or re-asserted, if\n\n     * there are still pending events to be fetched via check-exception. We\n\n     * do the latter here, since our code relies on edge-triggered\n\n     * interrupts.\n\n     */\n\n    if (rtas_event_log_contains(mask)) {\n\n        qemu_irq_pulse(xics_get_qirq(spapr->icp, spapr->check_exception_irq));\n\n    }\n\n\n\n    return;\n\n\n\nout_no_events:\n\n    rtas_st(rets, 0, RTAS_OUT_NO_ERRORS_FOUND);\n\n}\n", "idx": 22267}
{"project": "qemu", "commit_id": "3c529d935923a70519557d420db1d5a09a65086a", "target": 0, "func": "static void raw_fd_pool_put(RawAIOCB *acb)\n\n{\n\n    BDRVRawState *s = acb->common.bs->opaque;\n\n    int i;\n\n\n\n    for (i = 0; i < RAW_FD_POOL_SIZE; i++) {\n\n        if (s->fd_pool[i] == acb->fd) {\n\n            close(s->fd_pool[i]);\n\n            s->fd_pool[i] = -1;\n\n        }\n\n    }\n\n}\n", "idx": 22268}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static void virtio_net_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n    VirtIONet *n = opaque;\n\n    struct virtio_net_hdr_mrg_rxbuf *mhdr = NULL;\n\n    size_t hdr_len, offset, i;\n\n\n\n    if (!do_virtio_net_can_receive(n, size))\n\n        return;\n\n\n\n    if (!receive_filter(n, buf, size))\n\n        return;\n\n\n\n    /* hdr_len refers to the header we supply to the guest */\n\n    hdr_len = n->mergeable_rx_bufs ?\n\n        sizeof(struct virtio_net_hdr_mrg_rxbuf) : sizeof(struct virtio_net_hdr);\n\n\n\n    offset = i = 0;\n\n\n\n    while (offset < size) {\n\n        VirtQueueElement elem;\n\n        int len, total;\n\n        struct iovec sg[VIRTQUEUE_MAX_SIZE];\n\n\n\n        len = total = 0;\n\n\n\n        if ((i != 0 && !n->mergeable_rx_bufs) ||\n\n            virtqueue_pop(n->rx_vq, &elem) == 0) {\n\n            if (i == 0)\n\n                return;\n\n            fprintf(stderr, \"virtio-net truncating packet\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        if (elem.in_num < 1) {\n\n            fprintf(stderr, \"virtio-net receive queue contains no in buffers\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        if (!n->mergeable_rx_bufs && elem.in_sg[0].iov_len != hdr_len) {\n\n            fprintf(stderr, \"virtio-net header not in first element\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        memcpy(&sg, &elem.in_sg[0], sizeof(sg[0]) * elem.in_num);\n\n\n\n        if (i == 0) {\n\n            if (n->mergeable_rx_bufs)\n\n                mhdr = (struct virtio_net_hdr_mrg_rxbuf *)sg[0].iov_base;\n\n\n\n            offset += receive_header(n, sg, elem.in_num,\n\n                                     buf + offset, size - offset, hdr_len);\n\n            total += hdr_len;\n\n        }\n\n\n\n        /* copy in packet.  ugh */\n\n        len = iov_fill(sg, elem.in_num,\n\n                       buf + offset, size - offset);\n\n        total += len;\n\n\n\n        /* signal other side */\n\n        virtqueue_fill(n->rx_vq, &elem, total, i++);\n\n\n\n        offset += len;\n\n    }\n\n\n\n    if (mhdr)\n\n        mhdr->num_buffers = i;\n\n\n\n    virtqueue_flush(n->rx_vq, i);\n\n    virtio_notify(&n->vdev, n->rx_vq);\n\n}\n", "idx": 22269}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t pmac_ide_readb (void *opaque,target_phys_addr_t addr)\n\n{\n\n    uint8_t retval;\n\n    MACIOIDEState *d = opaque;\n\n\n\n    addr = (addr & 0xFFF) >> 4;\n\n    switch (addr) {\n\n    case 1 ... 7:\n\n        retval = ide_ioport_read(&d->bus, addr);\n\n        break;\n\n    case 8:\n\n    case 22:\n\n        retval = ide_status_read(&d->bus, 0);\n\n        break;\n\n    default:\n\n        retval = 0xFF;\n\n        break;\n\n    }\n\n    return retval;\n\n}\n", "idx": 22270}
{"project": "qemu", "commit_id": "ea5bef49eadd240c7924f287f2da1bb457a3f92c", "target": 0, "func": "static void test_redirector_rx(void)\n\n{\n\n    int backend_sock[2], send_sock;\n\n    char *cmdline;\n\n    uint32_t ret = 0, len = 0;\n\n    char send_buf[] = \"Hello!!\";\n\n    char sock_path0[] = \"filter-redirector0.XXXXXX\";\n\n    char sock_path1[] = \"filter-redirector1.XXXXXX\";\n\n    char *recv_buf;\n\n    uint32_t size = sizeof(send_buf);\n\n    size = htonl(size);\n\n\n\n    ret = socketpair(PF_UNIX, SOCK_STREAM, 0, backend_sock);\n\n    g_assert_cmpint(ret, !=, -1);\n\n\n\n    ret = mkstemp(sock_path0);\n\n    g_assert_cmpint(ret, !=, -1);\n\n    ret = mkstemp(sock_path1);\n\n    g_assert_cmpint(ret, !=, -1);\n\n\n\n    cmdline = g_strdup_printf(\"-netdev socket,id=qtest-bn0,fd=%d \"\n\n                \"-device rtl8139,netdev=qtest-bn0,id=qtest-e0 \"\n\n                \"-chardev socket,id=redirector0,path=%s,server,nowait \"\n\n                \"-chardev socket,id=redirector1,path=%s,server,nowait \"\n\n                \"-chardev socket,id=redirector2,path=%s,nowait \"\n\n                \"-object filter-redirector,id=qtest-f0,netdev=qtest-bn0,\"\n\n                \"queue=rx,indev=redirector0 \"\n\n                \"-object filter-redirector,id=qtest-f1,netdev=qtest-bn0,\"\n\n                \"queue=rx,outdev=redirector2 \"\n\n                \"-object filter-redirector,id=qtest-f2,netdev=qtest-bn0,\"\n\n                \"queue=rx,indev=redirector1 \"\n\n                , backend_sock[1], sock_path0, sock_path1, sock_path0);\n\n    qtest_start(cmdline);\n\n    g_free(cmdline);\n\n\n\n    struct iovec iov[] = {\n\n        {\n\n            .iov_base = &size,\n\n            .iov_len = sizeof(size),\n\n        }, {\n\n            .iov_base = send_buf,\n\n            .iov_len = sizeof(send_buf),\n\n        },\n\n    };\n\n\n\n    send_sock = unix_connect(sock_path1, NULL);\n\n    g_assert_cmpint(send_sock, !=, -1);\n\n    /* send a qmp command to guarantee that 'connected' is setting to true. */\n\n    qmp_discard_response(\"{ 'execute' : 'query-status'}\");\n\n\n\n    ret = iov_send(send_sock, iov, 2, 0, sizeof(size) + sizeof(send_buf));\n\n    g_assert_cmpint(ret, ==, sizeof(send_buf) + sizeof(size));\n\n    close(send_sock);\n\n\n\n    ret = qemu_recv(backend_sock[0], &len, sizeof(len), 0);\n\n    g_assert_cmpint(ret, ==, sizeof(len));\n\n    len = ntohl(len);\n\n\n\n    g_assert_cmpint(len, ==, sizeof(send_buf));\n\n    recv_buf = g_malloc(len);\n\n    ret = qemu_recv(backend_sock[0], recv_buf, len, 0);\n\n    g_assert_cmpstr(recv_buf, ==, send_buf);\n\n\n\n    g_free(recv_buf);\n\n    unlink(sock_path0);\n\n    unlink(sock_path1);\n\n    qtest_end();\n\n}\n", "idx": 22271}
{"project": "qemu", "commit_id": "13f1c773640171efa8175b1ba6dcd624c1ad68c1", "target": 0, "func": "static void cpu_openrisc_load_kernel(ram_addr_t ram_size,\n\n                                     const char *kernel_filename,\n\n                                     OpenRISCCPU *cpu)\n\n{\n\n    long kernel_size;\n\n    uint64_t elf_entry;\n\n    hwaddr entry;\n\n\n\n    if (kernel_filename && !qtest_enabled()) {\n\n        kernel_size = load_elf(kernel_filename, NULL, NULL,\n\n                               &elf_entry, NULL, NULL, 1, EM_OPENRISC,\n\n                               1, 0);\n\n        entry = elf_entry;\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_uimage(kernel_filename,\n\n                                      &entry, NULL, NULL, NULL, NULL);\n\n        }\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              KERNEL_LOAD_ADDR,\n\n                                              ram_size - KERNEL_LOAD_ADDR);\n\n            entry = KERNEL_LOAD_ADDR;\n\n        }\n\n\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"QEMU: couldn't load the kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n        cpu->env.pc = entry;\n\n    }\n\n}\n", "idx": 22272}
{"project": "qemu", "commit_id": "2ed1ebcf65edf6757d8904000889ce52cc0a9d1b", "target": 0, "func": "static void configure_rtc_date_offset(const char *startdate, int legacy)\n\n{\n\n    time_t rtc_start_date;\n\n    struct tm tm;\n\n\n\n    if (!strcmp(startdate, \"now\") && legacy) {\n\n        rtc_date_offset = -1;\n\n    } else {\n\n        if (sscanf(startdate, \"%d-%d-%dT%d:%d:%d\",\n\n                   &tm.tm_year,\n\n                   &tm.tm_mon,\n\n                   &tm.tm_mday,\n\n                   &tm.tm_hour,\n\n                   &tm.tm_min,\n\n                   &tm.tm_sec) == 6) {\n\n            /* OK */\n\n        } else if (sscanf(startdate, \"%d-%d-%d\",\n\n                          &tm.tm_year,\n\n                          &tm.tm_mon,\n\n                          &tm.tm_mday) == 3) {\n\n            tm.tm_hour = 0;\n\n            tm.tm_min = 0;\n\n            tm.tm_sec = 0;\n\n        } else {\n\n            goto date_fail;\n\n        }\n\n        tm.tm_year -= 1900;\n\n        tm.tm_mon--;\n\n        rtc_start_date = mktimegm(&tm);\n\n        if (rtc_start_date == -1) {\n\n        date_fail:\n\n            fprintf(stderr, \"Invalid date format. Valid formats are:\\n\"\n\n                            \"'2006-06-17T16:01:21' or '2006-06-17'\\n\");\n\n            exit(1);\n\n        }\n\n        rtc_date_offset = time(NULL) - rtc_start_date;\n\n    }\n\n}\n", "idx": 22274}
{"project": "qemu", "commit_id": "eacc324914c2dc7aecec3b4ea920252b685b5c8e", "target": 0, "func": "void ppc_slb_invalidate_all (CPUPPCState *env)\n\n{\n\n    /* XXX: TODO */\n\n    tlb_flush(env, 1);\n\n}\n", "idx": 22275}
{"project": "qemu", "commit_id": "21a0b6ed1dd9f1d8e3d953954847776c8697bd99", "target": 0, "func": "target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)\n\n{\n\n    uint32_t tlbncfg;\n\n    int tlbn = booke206_tlbm_to_tlbn(env, tlb);\n\n    int tlbm_size;\n\n\n\n    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];\n\n\n\n    if (tlbncfg & TLBnCFG_AVAIL) {\n\n        tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;\n\n    } else {\n\n        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;\n\n        tlbm_size <<= 1;\n\n    }\n\n\n\n    return 1024ULL << tlbm_size;\n\n}\n", "idx": 22276}
{"project": "qemu", "commit_id": "45a50b1668822c23afc2a89f724654e176518bc4", "target": 0, "func": "int load_image_targphys(const char *filename,\n\n\t\t\ttarget_phys_addr_t addr, int max_sz)\n\n{\n\n    FILE *f;\n\n    size_t got;\n\n\n\n    f = fopen(filename, \"rb\");\n\n    if (!f) return -1;\n\n\n\n    got = fread_targphys(addr, max_sz, f);\n\n    if (ferror(f)) { fclose(f); return -1; }\n\n    fclose(f);\n\n\n\n    return got;\n\n}\n", "idx": 22277}
{"project": "qemu", "commit_id": "880a7578381d1c7ed4d41c7599ae3cc06567a824", "target": 0, "func": "int gdbserver_start(int port)\n\n{\n\n    gdbserver_fd = gdbserver_open(port);\n\n    if (gdbserver_fd < 0)\n\n        return -1;\n\n    /* accept connections */\n\n    gdb_accept (NULL);\n\n    return 0;\n\n}\n", "idx": 22278}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)\n\n{\n\n    usb_packet_setup(&xfer->packet,\n\n                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,\n\n                     xfer->xhci->slots[xfer->slotid-1].devaddr,\n\n                     ep & 0x7f);\n\n    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);\n\n    DPRINTF(\"xhci: setup packet pid 0x%x addr %d ep %d\\n\",\n\n            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);\n\n    return 0;\n\n}\n", "idx": 22279}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void thread_pool_cancel(BlockAIOCB *acb)\n\n{\n\n    ThreadPoolElement *elem = (ThreadPoolElement *)acb;\n\n    ThreadPool *pool = elem->pool;\n\n\n\n    trace_thread_pool_cancel(elem, elem->common.opaque);\n\n\n\n    qemu_mutex_lock(&pool->lock);\n\n    if (elem->state == THREAD_QUEUED &&\n\n        /* No thread has yet started working on elem. we can try to \"steal\"\n\n         * the item from the worker if we can get a signal from the\n\n         * semaphore.  Because this is non-blocking, we can do it with\n\n         * the lock taken and ensure that elem will remain THREAD_QUEUED.\n\n         */\n\n        qemu_sem_timedwait(&pool->sem, 0) == 0) {\n\n        QTAILQ_REMOVE(&pool->request_list, elem, reqs);\n\n        qemu_bh_schedule(pool->completion_bh);\n\n\n\n        elem->state = THREAD_DONE;\n\n        elem->ret = -ECANCELED;\n\n    }\n\n\n\n    qemu_mutex_unlock(&pool->lock);\n\n}\n", "idx": 22280}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "CaptureVoiceOut *AUD_add_capture (\n\n    AudioState *s,\n\n    audsettings_t *as,\n\n    struct audio_capture_ops *ops,\n\n    void *cb_opaque\n\n    )\n\n{\n\n    CaptureVoiceOut *cap;\n\n    struct capture_callback *cb;\n\n\n\n    if (!s) {\n\n        /* XXX suppress */\n\n        s = &glob_audio_state;\n\n    }\n\n\n\n    if (audio_validate_settings (as)) {\n\n        dolog (\"Invalid settings were passed when trying to add capture\\n\");\n\n        audio_print_settings (as);\n\n        goto err0;\n\n    }\n\n\n\n    cb = audio_calloc (AUDIO_FUNC, 1, sizeof (*cb));\n\n    if (!cb) {\n\n        dolog (\"Could not allocate capture callback information, size %zu\\n\",\n\n               sizeof (*cb));\n\n        goto err0;\n\n    }\n\n    cb->ops = *ops;\n\n    cb->opaque = cb_opaque;\n\n\n\n    cap = audio_pcm_capture_find_specific (s, as);\n\n    if (cap) {\n\n        LIST_INSERT_HEAD (&cap->cb_head, cb, entries);\n\n        return cap;\n\n    }\n\n    else {\n\n        HWVoiceOut *hw;\n\n        CaptureVoiceOut *cap;\n\n\n\n        cap = audio_calloc (AUDIO_FUNC, 1, sizeof (*cap));\n\n        if (!cap) {\n\n            dolog (\"Could not allocate capture voice, size %zu\\n\",\n\n                   sizeof (*cap));\n\n            goto err1;\n\n        }\n\n\n\n        hw = &cap->hw;\n\n        LIST_INIT (&hw->sw_head);\n\n        LIST_INIT (&cap->cb_head);\n\n\n\n        /* XXX find a more elegant way */\n\n        hw->samples = 4096 * 4;\n\n        hw->mix_buf = audio_calloc (AUDIO_FUNC, hw->samples,\n\n                                    sizeof (st_sample_t));\n\n        if (!hw->mix_buf) {\n\n            dolog (\"Could not allocate capture mix buffer (%d samples)\\n\",\n\n                   hw->samples);\n\n            goto err2;\n\n        }\n\n\n\n        audio_pcm_init_info (&hw->info, as);\n\n\n\n        cap->buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);\n\n        if (!cap->buf) {\n\n            dolog (\"Could not allocate capture buffer \"\n\n                   \"(%d samples, each %d bytes)\\n\",\n\n                   hw->samples, 1 << hw->info.shift);\n\n            goto err3;\n\n        }\n\n\n\n        hw->clip = mixeng_clip\n\n            [hw->info.nchannels == 2]\n\n            [hw->info.sign]\n\n            [hw->info.swap_endianness]\n\n            [audio_bits_to_index (hw->info.bits)];\n\n\n\n        LIST_INSERT_HEAD (&s->cap_head, cap, entries);\n\n        LIST_INSERT_HEAD (&cap->cb_head, cb, entries);\n\n\n\n        hw = NULL;\n\n        while ((hw = audio_pcm_hw_find_any_out (s, hw))) {\n\n            audio_attach_capture (s, hw);\n\n        }\n\n        return cap;\n\n\n\n    err3:\n\n        qemu_free (cap->hw.mix_buf);\n\n    err2:\n\n        qemu_free (cap);\n\n    err1:\n\n        qemu_free (cb);\n\n    err0:\n\n        return NULL;\n\n    }\n\n}\n", "idx": 22281}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "static int nbd_co_writev(BlockDriverState *bs, int64_t sector_num,\n\n                         int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n\n\n    return nbd_client_session_co_writev(&s->client, sector_num,\n\n                                        nb_sectors, qiov);\n\n}\n", "idx": 22282}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void megasas_mmio_write(void *opaque, target_phys_addr_t addr,\n\n                               uint64_t val, unsigned size)\n\n{\n\n    MegasasState *s = opaque;\n\n    uint64_t frame_addr;\n\n    uint32_t frame_count;\n\n    int i;\n\n\n\n    trace_megasas_mmio_writel(addr, val);\n\n    switch (addr) {\n\n    case MFI_IDB:\n\n        if (val & MFI_FWINIT_ABORT) {\n\n            /* Abort all pending cmds */\n\n            for (i = 0; i < s->fw_cmds; i++) {\n\n                megasas_abort_command(&s->frames[i]);\n\n            }\n\n        }\n\n        if (val & MFI_FWINIT_READY) {\n\n            /* move to FW READY */\n\n            megasas_soft_reset(s);\n\n        }\n\n        if (val & MFI_FWINIT_MFIMODE) {\n\n            /* discard MFIs */\n\n        }\n\n        break;\n\n    case MFI_OMSK:\n\n        s->intr_mask = val;\n\n        if (!megasas_intr_enabled(s) && !msix_enabled(&s->dev)) {\n\n            trace_megasas_irq_lower();\n\n            qemu_irq_lower(s->dev.irq[0]);\n\n        }\n\n        if (megasas_intr_enabled(s)) {\n\n            trace_megasas_intr_enabled();\n\n        } else {\n\n            trace_megasas_intr_disabled();\n\n        }\n\n        break;\n\n    case MFI_ODCR0:\n\n        s->doorbell = 0;\n\n        if (s->producer_pa && megasas_intr_enabled(s)) {\n\n            /* Update reply queue pointer */\n\n            trace_megasas_qf_update(s->reply_queue_head, s->busy);\n\n            stl_le_phys(s->producer_pa, s->reply_queue_head);\n\n            if (!msix_enabled(&s->dev)) {\n\n                trace_megasas_irq_lower();\n\n                qemu_irq_lower(s->dev.irq[0]);\n\n            }\n\n        }\n\n        break;\n\n    case MFI_IQPH:\n\n        /* Received high 32 bits of a 64 bit MFI frame address */\n\n        s->frame_hi = val;\n\n        break;\n\n    case MFI_IQPL:\n\n        /* Received low 32 bits of a 64 bit MFI frame address */\n\n    case MFI_IQP:\n\n        /* Received 32 bit MFI frame address */\n\n        frame_addr = (val & ~0x1F);\n\n        /* Add possible 64 bit offset */\n\n        frame_addr |= ((uint64_t)s->frame_hi << 32);\n\n        s->frame_hi = 0;\n\n        frame_count = (val >> 1) & 0xF;\n\n        megasas_handle_frame(s, frame_addr, frame_count);\n\n        break;\n\n    default:\n\n        trace_megasas_mmio_invalid_writel(addr, val);\n\n        break;\n\n    }\n\n}\n", "idx": 22283}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_flt3_arith (DisasContext *ctx, uint32_t opc,\n\n                            int fd, int fr, int fs, int ft)\n\n{\n\n    const char *opn = \"flt3_arith\";\n\n\n\n    switch (opc) {\n\n    case OPC_ALNV_PS:\n\n        check_cp1_64bitmode(ctx);\n\n        {\n\n            TCGv t0 = tcg_temp_local_new();\n\n            TCGv_i32 fp = tcg_temp_new_i32();\n\n            TCGv_i32 fph = tcg_temp_new_i32();\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n\n\n            gen_load_gpr(t0, fr);\n\n            tcg_gen_andi_tl(t0, t0, 0x7);\n\n\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, 0, l1);\n\n            gen_load_fpr32(fp, fs);\n\n            gen_load_fpr32h(ctx, fph, fs);\n\n            gen_store_fpr32(fp, fd);\n\n            gen_store_fpr32h(ctx, fph, fd);\n\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, 4, l2);\n\n            tcg_temp_free(t0);\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n            gen_load_fpr32(fp, fs);\n\n            gen_load_fpr32h(ctx, fph, ft);\n\n            gen_store_fpr32h(ctx, fp, fd);\n\n            gen_store_fpr32(fph, fd);\n\n#else\n\n            gen_load_fpr32h(ctx, fph, fs);\n\n            gen_load_fpr32(fp, ft);\n\n            gen_store_fpr32(fph, fd);\n\n            gen_store_fpr32h(ctx, fp, fd);\n\n#endif\n\n            gen_set_label(l2);\n\n            tcg_temp_free_i32(fp);\n\n            tcg_temp_free_i32(fph);\n\n        }\n\n        opn = \"alnv.ps\";\n\n        break;\n\n    case OPC_MADD_S:\n\n        check_cop1x(ctx);\n\n        {\n\n            TCGv_i32 fp0 = tcg_temp_new_i32();\n\n            TCGv_i32 fp1 = tcg_temp_new_i32();\n\n            TCGv_i32 fp2 = tcg_temp_new_i32();\n\n\n\n            gen_load_fpr32(fp0, fs);\n\n            gen_load_fpr32(fp1, ft);\n\n            gen_load_fpr32(fp2, fr);\n\n            gen_helper_float_madd_s(fp2, cpu_env, fp0, fp1, fp2);\n\n            tcg_temp_free_i32(fp0);\n\n            tcg_temp_free_i32(fp1);\n\n            gen_store_fpr32(fp2, fd);\n\n            tcg_temp_free_i32(fp2);\n\n        }\n\n        opn = \"madd.s\";\n\n        break;\n\n    case OPC_MADD_D:\n\n        check_cop1x(ctx);\n\n        check_cp1_registers(ctx, fd | fs | ft | fr);\n\n        {\n\n            TCGv_i64 fp0 = tcg_temp_new_i64();\n\n            TCGv_i64 fp1 = tcg_temp_new_i64();\n\n            TCGv_i64 fp2 = tcg_temp_new_i64();\n\n\n\n            gen_load_fpr64(ctx, fp0, fs);\n\n            gen_load_fpr64(ctx, fp1, ft);\n\n            gen_load_fpr64(ctx, fp2, fr);\n\n            gen_helper_float_madd_d(fp2, cpu_env, fp0, fp1, fp2);\n\n            tcg_temp_free_i64(fp0);\n\n            tcg_temp_free_i64(fp1);\n\n            gen_store_fpr64(ctx, fp2, fd);\n\n            tcg_temp_free_i64(fp2);\n\n        }\n\n        opn = \"madd.d\";\n\n        break;\n\n    case OPC_MADD_PS:\n\n        check_cp1_64bitmode(ctx);\n\n        {\n\n            TCGv_i64 fp0 = tcg_temp_new_i64();\n\n            TCGv_i64 fp1 = tcg_temp_new_i64();\n\n            TCGv_i64 fp2 = tcg_temp_new_i64();\n\n\n\n            gen_load_fpr64(ctx, fp0, fs);\n\n            gen_load_fpr64(ctx, fp1, ft);\n\n            gen_load_fpr64(ctx, fp2, fr);\n\n            gen_helper_float_madd_ps(fp2, cpu_env, fp0, fp1, fp2);\n\n            tcg_temp_free_i64(fp0);\n\n            tcg_temp_free_i64(fp1);\n\n            gen_store_fpr64(ctx, fp2, fd);\n\n            tcg_temp_free_i64(fp2);\n\n        }\n\n        opn = \"madd.ps\";\n\n        break;\n\n    case OPC_MSUB_S:\n\n        check_cop1x(ctx);\n\n        {\n\n            TCGv_i32 fp0 = tcg_temp_new_i32();\n\n            TCGv_i32 fp1 = tcg_temp_new_i32();\n\n            TCGv_i32 fp2 = tcg_temp_new_i32();\n\n\n\n            gen_load_fpr32(fp0, fs);\n\n            gen_load_fpr32(fp1, ft);\n\n            gen_load_fpr32(fp2, fr);\n\n            gen_helper_float_msub_s(fp2, cpu_env, fp0, fp1, fp2);\n\n            tcg_temp_free_i32(fp0);\n\n            tcg_temp_free_i32(fp1);\n\n            gen_store_fpr32(fp2, fd);\n\n            tcg_temp_free_i32(fp2);\n\n        }\n\n        opn = \"msub.s\";\n\n        break;\n\n    case OPC_MSUB_D:\n\n        check_cop1x(ctx);\n\n        check_cp1_registers(ctx, fd | fs | ft | fr);\n\n        {\n\n            TCGv_i64 fp0 = tcg_temp_new_i64();\n\n            TCGv_i64 fp1 = tcg_temp_new_i64();\n\n            TCGv_i64 fp2 = tcg_temp_new_i64();\n\n\n\n            gen_load_fpr64(ctx, fp0, fs);\n\n            gen_load_fpr64(ctx, fp1, ft);\n\n            gen_load_fpr64(ctx, fp2, fr);\n\n            gen_helper_float_msub_d(fp2, cpu_env, fp0, fp1, fp2);\n\n            tcg_temp_free_i64(fp0);\n\n            tcg_temp_free_i64(fp1);\n\n            gen_store_fpr64(ctx, fp2, fd);\n\n            tcg_temp_free_i64(fp2);\n\n        }\n\n        opn = \"msub.d\";\n\n        break;\n\n    case OPC_MSUB_PS:\n\n        check_cp1_64bitmode(ctx);\n\n        {\n\n            TCGv_i64 fp0 = tcg_temp_new_i64();\n\n            TCGv_i64 fp1 = tcg_temp_new_i64();\n\n            TCGv_i64 fp2 = tcg_temp_new_i64();\n\n\n\n            gen_load_fpr64(ctx, fp0, fs);\n\n            gen_load_fpr64(ctx, fp1, ft);\n\n            gen_load_fpr64(ctx, fp2, fr);\n\n            gen_helper_float_msub_ps(fp2, cpu_env, fp0, fp1, fp2);\n\n            tcg_temp_free_i64(fp0);\n\n            tcg_temp_free_i64(fp1);\n\n            gen_store_fpr64(ctx, fp2, fd);\n\n            tcg_temp_free_i64(fp2);\n\n        }\n\n        opn = \"msub.ps\";\n\n        break;\n\n    case OPC_NMADD_S:\n\n        check_cop1x(ctx);\n\n        {\n\n            TCGv_i32 fp0 = tcg_temp_new_i32();\n\n            TCGv_i32 fp1 = tcg_temp_new_i32();\n\n            TCGv_i32 fp2 = tcg_temp_new_i32();\n\n\n\n            gen_load_fpr32(fp0, fs);\n\n            gen_load_fpr32(fp1, ft);\n\n            gen_load_fpr32(fp2, fr);\n\n            gen_helper_float_nmadd_s(fp2, cpu_env, fp0, fp1, fp2);\n\n            tcg_temp_free_i32(fp0);\n\n            tcg_temp_free_i32(fp1);\n\n            gen_store_fpr32(fp2, fd);\n\n            tcg_temp_free_i32(fp2);\n\n        }\n\n        opn = \"nmadd.s\";\n\n        break;\n\n    case OPC_NMADD_D:\n\n        check_cop1x(ctx);\n\n        check_cp1_registers(ctx, fd | fs | ft | fr);\n\n        {\n\n            TCGv_i64 fp0 = tcg_temp_new_i64();\n\n            TCGv_i64 fp1 = tcg_temp_new_i64();\n\n            TCGv_i64 fp2 = tcg_temp_new_i64();\n\n\n\n            gen_load_fpr64(ctx, fp0, fs);\n\n            gen_load_fpr64(ctx, fp1, ft);\n\n            gen_load_fpr64(ctx, fp2, fr);\n\n            gen_helper_float_nmadd_d(fp2, cpu_env, fp0, fp1, fp2);\n\n            tcg_temp_free_i64(fp0);\n\n            tcg_temp_free_i64(fp1);\n\n            gen_store_fpr64(ctx, fp2, fd);\n\n            tcg_temp_free_i64(fp2);\n\n        }\n\n        opn = \"nmadd.d\";\n\n        break;\n\n    case OPC_NMADD_PS:\n\n        check_cp1_64bitmode(ctx);\n\n        {\n\n            TCGv_i64 fp0 = tcg_temp_new_i64();\n\n            TCGv_i64 fp1 = tcg_temp_new_i64();\n\n            TCGv_i64 fp2 = tcg_temp_new_i64();\n\n\n\n            gen_load_fpr64(ctx, fp0, fs);\n\n            gen_load_fpr64(ctx, fp1, ft);\n\n            gen_load_fpr64(ctx, fp2, fr);\n\n            gen_helper_float_nmadd_ps(fp2, cpu_env, fp0, fp1, fp2);\n\n            tcg_temp_free_i64(fp0);\n\n            tcg_temp_free_i64(fp1);\n\n            gen_store_fpr64(ctx, fp2, fd);\n\n            tcg_temp_free_i64(fp2);\n\n        }\n\n        opn = \"nmadd.ps\";\n\n        break;\n\n    case OPC_NMSUB_S:\n\n        check_cop1x(ctx);\n\n        {\n\n            TCGv_i32 fp0 = tcg_temp_new_i32();\n\n            TCGv_i32 fp1 = tcg_temp_new_i32();\n\n            TCGv_i32 fp2 = tcg_temp_new_i32();\n\n\n\n            gen_load_fpr32(fp0, fs);\n\n            gen_load_fpr32(fp1, ft);\n\n            gen_load_fpr32(fp2, fr);\n\n            gen_helper_float_nmsub_s(fp2, cpu_env, fp0, fp1, fp2);\n\n            tcg_temp_free_i32(fp0);\n\n            tcg_temp_free_i32(fp1);\n\n            gen_store_fpr32(fp2, fd);\n\n            tcg_temp_free_i32(fp2);\n\n        }\n\n        opn = \"nmsub.s\";\n\n        break;\n\n    case OPC_NMSUB_D:\n\n        check_cop1x(ctx);\n\n        check_cp1_registers(ctx, fd | fs | ft | fr);\n\n        {\n\n            TCGv_i64 fp0 = tcg_temp_new_i64();\n\n            TCGv_i64 fp1 = tcg_temp_new_i64();\n\n            TCGv_i64 fp2 = tcg_temp_new_i64();\n\n\n\n            gen_load_fpr64(ctx, fp0, fs);\n\n            gen_load_fpr64(ctx, fp1, ft);\n\n            gen_load_fpr64(ctx, fp2, fr);\n\n            gen_helper_float_nmsub_d(fp2, cpu_env, fp0, fp1, fp2);\n\n            tcg_temp_free_i64(fp0);\n\n            tcg_temp_free_i64(fp1);\n\n            gen_store_fpr64(ctx, fp2, fd);\n\n            tcg_temp_free_i64(fp2);\n\n        }\n\n        opn = \"nmsub.d\";\n\n        break;\n\n    case OPC_NMSUB_PS:\n\n        check_cp1_64bitmode(ctx);\n\n        {\n\n            TCGv_i64 fp0 = tcg_temp_new_i64();\n\n            TCGv_i64 fp1 = tcg_temp_new_i64();\n\n            TCGv_i64 fp2 = tcg_temp_new_i64();\n\n\n\n            gen_load_fpr64(ctx, fp0, fs);\n\n            gen_load_fpr64(ctx, fp1, ft);\n\n            gen_load_fpr64(ctx, fp2, fr);\n\n            gen_helper_float_nmsub_ps(fp2, cpu_env, fp0, fp1, fp2);\n\n            tcg_temp_free_i64(fp0);\n\n            tcg_temp_free_i64(fp1);\n\n            gen_store_fpr64(ctx, fp2, fd);\n\n            tcg_temp_free_i64(fp2);\n\n        }\n\n        opn = \"nmsub.ps\";\n\n        break;\n\n    default:\n\n        MIPS_INVAL(opn);\n\n        generate_exception (ctx, EXCP_RI);\n\n        return;\n\n    }\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s %s, %s, %s, %s\", opn, fregnames[fd], fregnames[fr],\n\n               fregnames[fs], fregnames[ft]);\n\n}\n", "idx": 22285}
{"project": "qemu", "commit_id": "7102fa7073b2cefb33ab4012a11f15fbf297a74b", "target": 0, "func": "static void pc_compat_2_1(MachineState *machine)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(machine);\n\n\n\n    pc_compat_2_2(machine);\n\n    pcms->enforce_aligned_dimm = false;\n\n    smbios_uuid_encoded = false;\n\n    x86_cpu_change_kvm_default(\"svm\", NULL);\n\n}\n", "idx": 22286}
{"project": "qemu", "commit_id": "5861a33898bbddfd1a80c2e202cb9352e3b1ba62", "target": 0, "func": "qemu_irq *openpic_init (MemoryRegion **pmem, int nb_cpus,\n\n                        qemu_irq **irqs, qemu_irq irq_out)\n\n{\n\n    openpic_t *opp;\n\n    int i, m;\n\n    struct {\n\n        const char             *name;\n\n        MemoryRegionOps const  *ops;\n\n        hwaddr      start_addr;\n\n        ram_addr_t              size;\n\n    } const list[] = {\n\n        {\"glb\", &openpic_glb_ops, OPENPIC_GLB_REG_START, OPENPIC_GLB_REG_SIZE},\n\n        {\"tmr\", &openpic_tmr_ops, OPENPIC_TMR_REG_START, OPENPIC_TMR_REG_SIZE},\n\n        {\"src\", &openpic_src_ops, OPENPIC_SRC_REG_START, OPENPIC_SRC_REG_SIZE},\n\n        {\"cpu\", &openpic_cpu_ops, OPENPIC_CPU_REG_START, OPENPIC_CPU_REG_SIZE},\n\n    };\n\n\n\n    /* XXX: for now, only one CPU is supported */\n\n    if (nb_cpus != 1)\n\n        return NULL;\n\n    opp = g_malloc0(sizeof(openpic_t));\n\n\n\n    memory_region_init(&opp->mem, \"openpic\", 0x40000);\n\n\n\n    for (i = 0; i < ARRAY_SIZE(list); i++) {\n\n\n\n        memory_region_init_io(&opp->sub_io_mem[i], list[i].ops, opp,\n\n                              list[i].name, list[i].size);\n\n\n\n        memory_region_add_subregion(&opp->mem, list[i].start_addr,\n\n                                    &opp->sub_io_mem[i]);\n\n    }\n\n\n\n    //    isu_base &= 0xFFFC0000;\n\n    opp->nb_cpus = nb_cpus;\n\n    opp->max_irq = OPENPIC_MAX_IRQ;\n\n    opp->irq_ipi0 = OPENPIC_IRQ_IPI0;\n\n    opp->irq_tim0 = OPENPIC_IRQ_TIM0;\n\n    /* Set IRQ types */\n\n    for (i = 0; i < OPENPIC_EXT_IRQ; i++) {\n\n        opp->src[i].type = IRQ_EXTERNAL;\n\n    }\n\n    for (; i < OPENPIC_IRQ_TIM0; i++) {\n\n        opp->src[i].type = IRQ_SPECIAL;\n\n    }\n\n    m = OPENPIC_IRQ_IPI0;\n\n    for (; i < m; i++) {\n\n        opp->src[i].type = IRQ_TIMER;\n\n    }\n\n    for (; i < OPENPIC_MAX_IRQ; i++) {\n\n        opp->src[i].type = IRQ_INTERNAL;\n\n    }\n\n    for (i = 0; i < nb_cpus; i++)\n\n        opp->dst[i].irqs = irqs[i];\n\n    opp->irq_out = irq_out;\n\n\n\n    register_savevm(&opp->pci_dev.qdev, \"openpic\", 0, 2,\n\n                    openpic_save, openpic_load, opp);\n\n    qemu_register_reset(openpic_reset, opp);\n\n\n\n    opp->irq_raise = openpic_irq_raise;\n\n    opp->reset = openpic_reset;\n\n\n\n    if (pmem)\n\n        *pmem = &opp->mem;\n\n\n\n    return qemu_allocate_irqs(openpic_set_irq, opp, opp->max_irq);\n\n}\n", "idx": 22287}
{"project": "qemu", "commit_id": "be5e7a76010bd14d09f74504ed6368782e701888", "target": 0, "func": "void do_interrupt(CPUARMState *env)\n\n{\n\n    uint32_t addr;\n\n    uint32_t mask;\n\n    int new_mode;\n\n    uint32_t offset;\n\n\n\n    if (IS_M(env)) {\n\n        do_interrupt_v7m(env);\n\n        return;\n\n    }\n\n    /* TODO: Vectored interrupt controller.  */\n\n    switch (env->exception_index) {\n\n    case EXCP_UDEF:\n\n        new_mode = ARM_CPU_MODE_UND;\n\n        addr = 0x04;\n\n        mask = CPSR_I;\n\n        if (env->thumb)\n\n            offset = 2;\n\n        else\n\n            offset = 4;\n\n        break;\n\n    case EXCP_SWI:\n\n        if (semihosting_enabled) {\n\n            /* Check for semihosting interrupt.  */\n\n            if (env->thumb) {\n\n                mask = lduw_code(env->regs[15] - 2) & 0xff;\n\n            } else {\n\n                mask = ldl_code(env->regs[15] - 4) & 0xffffff;\n\n            }\n\n            /* Only intercept calls from privileged modes, to provide some\n\n               semblance of security.  */\n\n            if (((mask == 0x123456 && !env->thumb)\n\n                    || (mask == 0xab && env->thumb))\n\n                  && (env->uncached_cpsr & CPSR_M) != ARM_CPU_MODE_USR) {\n\n                env->regs[0] = do_arm_semihosting(env);\n\n                return;\n\n            }\n\n        }\n\n        new_mode = ARM_CPU_MODE_SVC;\n\n        addr = 0x08;\n\n        mask = CPSR_I;\n\n        /* The PC already points to the next instruction.  */\n\n        offset = 0;\n\n        break;\n\n    case EXCP_BKPT:\n\n        /* See if this is a semihosting syscall.  */\n\n        if (env->thumb && semihosting_enabled) {\n\n            mask = lduw_code(env->regs[15]) & 0xff;\n\n            if (mask == 0xab\n\n                  && (env->uncached_cpsr & CPSR_M) != ARM_CPU_MODE_USR) {\n\n                env->regs[15] += 2;\n\n                env->regs[0] = do_arm_semihosting(env);\n\n                return;\n\n            }\n\n        }\n\n        /* Fall through to prefetch abort.  */\n\n    case EXCP_PREFETCH_ABORT:\n\n        new_mode = ARM_CPU_MODE_ABT;\n\n        addr = 0x0c;\n\n        mask = CPSR_A | CPSR_I;\n\n        offset = 4;\n\n        break;\n\n    case EXCP_DATA_ABORT:\n\n        new_mode = ARM_CPU_MODE_ABT;\n\n        addr = 0x10;\n\n        mask = CPSR_A | CPSR_I;\n\n        offset = 8;\n\n        break;\n\n    case EXCP_IRQ:\n\n        new_mode = ARM_CPU_MODE_IRQ;\n\n        addr = 0x18;\n\n        /* Disable IRQ and imprecise data aborts.  */\n\n        mask = CPSR_A | CPSR_I;\n\n        offset = 4;\n\n        break;\n\n    case EXCP_FIQ:\n\n        new_mode = ARM_CPU_MODE_FIQ;\n\n        addr = 0x1c;\n\n        /* Disable FIQ, IRQ and imprecise data aborts.  */\n\n        mask = CPSR_A | CPSR_I | CPSR_F;\n\n        offset = 4;\n\n        break;\n\n    default:\n\n        cpu_abort(env, \"Unhandled exception 0x%x\\n\", env->exception_index);\n\n        return; /* Never happens.  Keep compiler happy.  */\n\n    }\n\n    /* High vectors.  */\n\n    if (env->cp15.c1_sys & (1 << 13)) {\n\n        addr += 0xffff0000;\n\n    }\n\n    switch_mode (env, new_mode);\n\n    env->spsr = cpsr_read(env);\n\n    /* Clear IT bits.  */\n\n    env->condexec_bits = 0;\n\n    /* Switch to the new mode, and to the correct instruction set.  */\n\n    env->uncached_cpsr = (env->uncached_cpsr & ~CPSR_M) | new_mode;\n\n    env->uncached_cpsr |= mask;\n\n    env->thumb = (env->cp15.c1_sys & (1 << 30)) != 0;\n\n    env->regs[14] = env->regs[15] + offset;\n\n    env->regs[15] = addr;\n\n    env->interrupt_request |= CPU_INTERRUPT_EXITTB;\n\n}\n", "idx": 22288}
{"project": "qemu", "commit_id": "5d1abf234462d13bef3617cc2c55b6815703ddf2", "target": 0, "func": "int stpcifc_service_call(S390CPU *cpu, uint8_t r1, uint64_t fiba, uint8_t ar)\n\n{\n\n    CPUS390XState *env = &cpu->env;\n\n    uint32_t fh;\n\n    ZpciFib fib;\n\n    S390PCIBusDevice *pbdev;\n\n    uint32_t data;\n\n    uint64_t cc = ZPCI_PCI_LS_OK;\n\n\n\n    if (env->psw.mask & PSW_MASK_PSTATE) {\n\n        program_interrupt(env, PGM_PRIVILEGED, 6);\n\n        return 0;\n\n    }\n\n\n\n    fh = env->regs[r1] >> 32;\n\n\n\n    if (fiba & 0x7) {\n\n        program_interrupt(env, PGM_SPECIFICATION, 6);\n\n        return 0;\n\n    }\n\n\n\n    pbdev = s390_pci_find_dev_by_fh(fh);\n\n    if (!pbdev) {\n\n        setcc(cpu, ZPCI_PCI_LS_INVAL_HANDLE);\n\n        return 0;\n\n    }\n\n\n\n    memset(&fib, 0, sizeof(fib));\n\n    stq_p(&fib.pba, pbdev->pba);\n\n    stq_p(&fib.pal, pbdev->pal);\n\n    stq_p(&fib.iota, pbdev->g_iota);\n\n    stq_p(&fib.aibv, pbdev->routes.adapter.ind_addr);\n\n    stq_p(&fib.aisb, pbdev->routes.adapter.summary_addr);\n\n    stq_p(&fib.fmb_addr, pbdev->fmb_addr);\n\n\n\n    data = ((uint32_t)pbdev->isc << 28) | ((uint32_t)pbdev->noi << 16) |\n\n           ((uint32_t)pbdev->routes.adapter.ind_offset << 8) |\n\n           ((uint32_t)pbdev->sum << 7) | pbdev->routes.adapter.summary_offset;\n\n    stl_p(&fib.data, data);\n\n\n\n    if (pbdev->fh & FH_MASK_ENABLE) {\n\n        fib.fc |= 0x80;\n\n    }\n\n\n\n    if (pbdev->error_state) {\n\n        fib.fc |= 0x40;\n\n    }\n\n\n\n    if (pbdev->lgstg_blocked) {\n\n        fib.fc |= 0x20;\n\n    }\n\n\n\n    if (pbdev->g_iota) {\n\n        fib.fc |= 0x10;\n\n    }\n\n\n\n    if (s390_cpu_virt_mem_write(cpu, fiba, ar, (uint8_t *)&fib, sizeof(fib))) {\n\n        return 0;\n\n    }\n\n\n\n    setcc(cpu, cc);\n\n    return 0;\n\n}\n", "idx": 22289}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void mv88w8618_wlan_write(void *opaque, target_phys_addr_t offset,\n\n                                 uint64_t value, unsigned size)\n\n{\n\n}\n", "idx": 22290}
{"project": "qemu", "commit_id": "0e7b176ae01d5a664d4cbf619a7315819494e6cb", "target": 0, "func": "static void aarch64_any_initfn(Object *obj)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(obj);\n\n\n\n    set_feature(&cpu->env, ARM_FEATURE_V8);\n\n    set_feature(&cpu->env, ARM_FEATURE_VFP4);\n\n    set_feature(&cpu->env, ARM_FEATURE_NEON);\n\n    set_feature(&cpu->env, ARM_FEATURE_AARCH64);\n\n    set_feature(&cpu->env, ARM_FEATURE_V8_AES);\n\n    set_feature(&cpu->env, ARM_FEATURE_V8_SHA1);\n\n    set_feature(&cpu->env, ARM_FEATURE_V8_SHA256);\n\n    set_feature(&cpu->env, ARM_FEATURE_V8_PMULL);\n\n    set_feature(&cpu->env, ARM_FEATURE_CRC);\n\n    cpu->ctr = 0x80030003; /* 32 byte I and D cacheline size, VIPT icache */\n\n    cpu->dcz_blocksize = 7; /*  512 bytes */\n\n}\n", "idx": 22291}
{"project": "qemu", "commit_id": "65cdadd2e2de76f7db3bf6b7d8dd8c67abff9659", "target": 0, "func": "START_TEST(qint_from_int_test)\n\n{\n\n    QInt *qi;\n\n    const int value = -42;\n\n\n\n    qi = qint_from_int(value);\n\n    fail_unless(qi != NULL);\n\n    fail_unless(qi->value == value);\n\n    fail_unless(qi->base.refcnt == 1);\n\n    fail_unless(qobject_type(QOBJECT(qi)) == QTYPE_QINT);\n\n\n\n    // destroy doesn't exit yet\n\n    g_free(qi);\n\n}\n", "idx": 22292}
{"project": "qemu", "commit_id": "62deb62d999cf9e2be61272c6b720104f764bd6a", "target": 0, "func": "static int kvm_s390_store_adtl_status(S390CPU *cpu, hwaddr addr)\n\n{\n\n    void *mem;\n\n    hwaddr len = ADTL_SAVE_AREA_SIZE;\n\n\n\n    mem = cpu_physical_memory_map(addr, &len, 1);\n\n    if (!mem) {\n\n        return -EFAULT;\n\n    }\n\n    if (len != ADTL_SAVE_AREA_SIZE) {\n\n        cpu_physical_memory_unmap(mem, len, 1, 0);\n\n        return -EFAULT;\n\n    }\n\n\n\n    memcpy(mem, &cpu->env.vregs, 512);\n\n\n\n    cpu_physical_memory_unmap(mem, len, 1, len);\n\n\n\n    return 0;\n\n}\n", "idx": 22293}
{"project": "qemu", "commit_id": "45d679d64350c44df93d918ddacd6ae0c6da9dbb", "target": 0, "func": "int page_unprotect(target_ulong address, unsigned long pc, void *puc)\n\n{\n\n    unsigned int page_index, prot, pindex;\n\n    PageDesc *p, *p1;\n\n    target_ulong host_start, host_end, addr;\n\n\n\n    /* Technically this isn't safe inside a signal handler.  However we\n\n       know this only ever happens in a synchronous SEGV handler, so in\n\n       practice it seems to be ok.  */\n\n    mmap_lock();\n\n\n\n    host_start = address & qemu_host_page_mask;\n\n    page_index = host_start >> TARGET_PAGE_BITS;\n\n    p1 = page_find(page_index);\n\n    if (!p1) {\n\n        mmap_unlock();\n\n        return 0;\n\n    }\n\n    host_end = host_start + qemu_host_page_size;\n\n    p = p1;\n\n    prot = 0;\n\n    for(addr = host_start;addr < host_end; addr += TARGET_PAGE_SIZE) {\n\n        prot |= p->flags;\n\n        p++;\n\n    }\n\n    /* if the page was really writable, then we change its\n\n       protection back to writable */\n\n    if (prot & PAGE_WRITE_ORG) {\n\n        pindex = (address - host_start) >> TARGET_PAGE_BITS;\n\n        if (!(p1[pindex].flags & PAGE_WRITE)) {\n\n            mprotect((void *)g2h(host_start), qemu_host_page_size,\n\n                     (prot & PAGE_BITS) | PAGE_WRITE);\n\n            p1[pindex].flags |= PAGE_WRITE;\n\n            /* and since the content will be modified, we must invalidate\n\n               the corresponding translated code. */\n\n            tb_invalidate_phys_page(address, pc, puc);\n\n#ifdef DEBUG_TB_CHECK\n\n            tb_invalidate_check(address);\n\n#endif\n\n            mmap_unlock();\n\n            return 1;\n\n        }\n\n    }\n\n    mmap_unlock();\n\n    return 0;\n\n}\n", "idx": 22294}
{"project": "qemu", "commit_id": "c20b7fa4b2fedd979bcb0cc974bb5d08a10e3448", "target": 1, "func": "static void monitor_protocol_event_init(void)\n\n{\n\n    qemu_mutex_init(&monitor_event_state_lock);\n\n    /* Limit RTC & BALLOON events to 1 per second */\n\n    monitor_protocol_event_throttle(QEVENT_RTC_CHANGE, 1000);\n\n    monitor_protocol_event_throttle(QEVENT_BALLOON_CHANGE, 1000);\n\n    monitor_protocol_event_throttle(QEVENT_WATCHDOG, 1000);\n\n}\n", "idx": 22300}
{"project": "qemu", "commit_id": "ce137829e7e58fcdc5ba63b5e256f972e80be438", "target": 1, "func": "static inline int array_roll(array_t* array,int index_to,int index_from,int count)\n\n{\n\n    char* buf;\n\n    char* from;\n\n    char* to;\n\n    int is;\n\n\n\n    if(!array ||\n\n\t    index_to<0 || index_to>=array->next ||\n\n\t    index_from<0 || index_from>=array->next)\n\n\treturn -1;\n\n\n\n    if(index_to==index_from)\n\n\treturn 0;\n\n\n\n    is=array->item_size;\n\n    from=array->pointer+index_from*is;\n\n    to=array->pointer+index_to*is;\n\n    buf=g_malloc(is*count);\n\n    memcpy(buf,from,is*count);\n\n\n\n    if(index_to<index_from)\n\n\tmemmove(to+is*count,to,from-to);\n\n    else\n\n\tmemmove(from,from+is*count,to-from);\n\n\n\n    memcpy(to,buf,is*count);\n\n\n\n    free(buf);\n\n\n\n    return 0;\n\n}\n", "idx": 22303}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "QEMUSizedBuffer *qsb_create(const uint8_t *buffer, size_t len)\n\n{\n\n    QEMUSizedBuffer *qsb;\n\n    size_t alloc_len, num_chunks, i, to_copy;\n\n    size_t chunk_size = (len > QSB_MAX_CHUNK_SIZE)\n\n                        ? QSB_MAX_CHUNK_SIZE\n\n                        : QSB_CHUNK_SIZE;\n\n\n\n    num_chunks = DIV_ROUND_UP(len ? len : QSB_CHUNK_SIZE, chunk_size);\n\n    alloc_len = num_chunks * chunk_size;\n\n\n\n    qsb = g_try_new0(QEMUSizedBuffer, 1);\n\n    if (!qsb) {\n\n        return NULL;\n\n    }\n\n\n\n    qsb->iov = g_try_new0(struct iovec, num_chunks);\n\n    if (!qsb->iov) {\n\n        g_free(qsb);\n\n        return NULL;\n\n    }\n\n\n\n    qsb->n_iov = num_chunks;\n\n\n\n    for (i = 0; i < num_chunks; i++) {\n\n        qsb->iov[i].iov_base = g_try_malloc0(chunk_size);\n\n        if (!qsb->iov[i].iov_base) {\n\n            /* qsb_free is safe since g_free can cope with NULL */\n\n            qsb_free(qsb);\n\n            return NULL;\n\n        }\n\n\n\n        qsb->iov[i].iov_len = chunk_size;\n\n        if (buffer) {\n\n            to_copy = (len - qsb->used) > chunk_size\n\n                      ? chunk_size : (len - qsb->used);\n\n            memcpy(qsb->iov[i].iov_base, &buffer[qsb->used], to_copy);\n\n            qsb->used += to_copy;\n\n        }\n\n    }\n\n\n\n    qsb->size = alloc_len;\n\n\n\n    return qsb;\n\n}\n", "idx": 22306}
{"project": "qemu", "commit_id": "f5ed36635d8fa73feb66fe12b3b9c2ed90a1adbe", "target": 1, "func": "static void virtio_notify_vector(VirtIODevice *vdev, uint16_t vector)\n{\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n    if (k->notify) {\n        k->notify(qbus->parent, vector);", "idx": 22307}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "CPUState *cpu_create(const char *typename)\n\n{\n\n    Error *err = NULL;\n\n    CPUState *cpu = CPU(object_new(typename));\n\n    object_property_set_bool(OBJECT(cpu), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        error_report_err(err);\n\n        object_unref(OBJECT(cpu));\n\n        return NULL;\n\n    }\n\n    return cpu;\n\n}\n", "idx": 22309}
{"project": "qemu", "commit_id": "937470bb5470825e781ae50e92ff973a6b54d80f", "target": 1, "func": "static int qio_channel_socket_connect_worker(QIOTask *task,\n\n                                             Error **errp,\n\n                                             gpointer opaque)\n\n{\n\n    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(qio_task_get_source(task));\n\n    SocketAddress *addr = opaque;\n\n    int ret;\n\n\n\n    ret = qio_channel_socket_connect_sync(ioc,\n\n                                          addr,\n\n                                          errp);\n\n\n\n    object_unref(OBJECT(ioc));\n\n    return ret;\n\n}\n", "idx": 22310}
{"project": "qemu", "commit_id": "2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3", "target": 1, "func": "static const void *boston_kernel_filter(void *opaque, const void *kernel,\n\n                                        hwaddr *load_addr, hwaddr *entry_addr)\n\n{\n\n    BostonState *s = BOSTON(opaque);\n\n\n\n    s->kernel_entry = *entry_addr;\n\n\n\n    return kernel;\n\n}\n", "idx": 22311}
{"project": "qemu", "commit_id": "b946a1533209f61a93e34898aebb5b43154b99c3", "target": 1, "func": "PCIDevice *virtio_net_init(PCIBus *bus, NICInfo *nd, int devfn)\n\n{\n\n    VirtIONet *n;\n\n    static int virtio_net_id;\n\n\n\n    n = (VirtIONet *)virtio_init_pci(bus, \"virtio-net\",\n\n                                     PCI_VENDOR_ID_REDHAT_QUMRANET,\n\n                                     PCI_DEVICE_ID_VIRTIO_NET,\n\n                                     PCI_VENDOR_ID_REDHAT_QUMRANET,\n\n                                     VIRTIO_ID_NET,\n\n                                     PCI_CLASS_NETWORK_ETHERNET, 0x00,\n\n                                     sizeof(struct virtio_net_config),\n\n                                     sizeof(VirtIONet));\n\n    if (!n)\n\n        return NULL;\n\n\n\n    n->vdev.get_config = virtio_net_get_config;\n\n    n->vdev.set_config = virtio_net_set_config;\n\n    n->vdev.get_features = virtio_net_get_features;\n\n    n->vdev.set_features = virtio_net_set_features;\n\n    n->vdev.bad_features = virtio_net_bad_features;\n\n    n->vdev.reset = virtio_net_reset;\n\n    n->rx_vq = virtio_add_queue(&n->vdev, 256, virtio_net_handle_rx);\n\n    n->tx_vq = virtio_add_queue(&n->vdev, 256, virtio_net_handle_tx);\n\n    n->ctrl_vq = virtio_add_queue(&n->vdev, 16, virtio_net_handle_ctrl);\n\n    memcpy(n->mac, nd->macaddr, ETH_ALEN);\n\n    n->status = VIRTIO_NET_S_LINK_UP;\n\n    n->vc = qemu_new_vlan_client(nd->vlan, nd->model, nd->name,\n\n                                 virtio_net_receive, virtio_net_can_receive, n);\n\n    n->vc->link_status_changed = virtio_net_set_link_status;\n\n\n\n    qemu_format_nic_info_str(n->vc, n->mac);\n\n\n\n    n->tx_timer = qemu_new_timer(vm_clock, virtio_net_tx_timer, n);\n\n    n->tx_timer_active = 0;\n\n    n->mergeable_rx_bufs = 0;\n\n    n->promisc = 1; /* for compatibility */\n\n\n\n    n->mac_table.macs = qemu_mallocz(MAC_TABLE_ENTRIES * ETH_ALEN);\n\n\n\n    n->vlans = qemu_mallocz(MAX_VLAN >> 3);\n\n\n\n    register_savevm(\"virtio-net\", virtio_net_id++, VIRTIO_NET_VM_VERSION,\n\n                    virtio_net_save, virtio_net_load, n);\n\n    return (PCIDevice *)n;\n\n}\n", "idx": 22314}
{"project": "qemu", "commit_id": "82342e91b60a4a078811df4e1a545e57abffa11d", "target": 1, "func": "e1000e_set_icr(E1000ECore *core, int index, uint32_t val)\n\n{\n\n    if ((core->mac[ICR] & E1000_ICR_ASSERTED) &&\n\n        (core->mac[CTRL_EXT] & E1000_CTRL_EXT_IAME)) {\n\n        trace_e1000e_irq_icr_process_iame();\n\n        e1000e_clear_ims_bits(core, core->mac[IAM]);\n\n    }\n\n\n\n    trace_e1000e_irq_icr_write(val, core->mac[ICR], core->mac[ICR] & ~val);\n\n    core->mac[ICR] &= ~val;\n\n    e1000e_update_interrupt_state(core);\n\n}\n", "idx": 22315}
{"project": "qemu", "commit_id": "68e5ec64009812dbaa03ed9cfded9344986f5304", "target": 1, "func": "static void tap_send(void *opaque)\n\n{\n\n    TAPState *s = opaque;\n\n    int size;\n\n\n\n    do {\n\n        uint8_t *buf = s->buf;\n\n\n\n        size = tap_read_packet(s->fd, s->buf, sizeof(s->buf));\n\n        if (size <= 0) {\n\n            break;\n\n        }\n\n\n\n        if (s->host_vnet_hdr_len && !s->using_vnet_hdr) {\n\n            buf  += s->host_vnet_hdr_len;\n\n            size -= s->host_vnet_hdr_len;\n\n        }\n\n\n\n        size = qemu_send_packet_async(&s->nc, buf, size, tap_send_completed);\n\n        if (size == 0) {\n\n            tap_read_poll(s, false);\n\n        }\n\n    } while (size > 0 && qemu_can_send_packet(&s->nc));\n\n}\n", "idx": 22319}
{"project": "qemu", "commit_id": "0e321191224c8cd137eef41da3257e096965c3d6", "target": 1, "func": "void hbitmap_reset(HBitmap *hb, uint64_t start, uint64_t count)\n\n{\n\n    /* Compute range in the last layer.  */\n\n    uint64_t last = start + count - 1;\n\n\n\n    trace_hbitmap_reset(hb, start, count,\n\n                        start >> hb->granularity, last >> hb->granularity);\n\n\n\n    start >>= hb->granularity;\n\n    last >>= hb->granularity;\n\n\n\n\n    hb->count -= hb_count_between(hb, start, last);\n\n    hb_reset_between(hb, HBITMAP_LEVELS - 1, start, last);\n\n}", "idx": 22322}
{"project": "qemu", "commit_id": "f6a7240442727cefe000a5b4fdee4d844ddd6bfe", "target": 1, "func": "static int raw_create(const char *filename, QemuOpts *opts, Error **errp)\n\n{\n\n    int fd;\n\n    int result = 0;\n\n    int64_t total_size = 0;\n\n    bool nocow = false;\n\n    PreallocMode prealloc;\n\n    char *buf = NULL;\n\n    Error *local_err = NULL;\n\n\n\n    strstart(filename, \"file:\", &filename);\n\n\n\n    /* Read out options */\n\n    total_size = ROUND_UP(qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0),\n\n                          BDRV_SECTOR_SIZE);\n\n    nocow = qemu_opt_get_bool(opts, BLOCK_OPT_NOCOW, false);\n\n    buf = qemu_opt_get_del(opts, BLOCK_OPT_PREALLOC);\n\n    prealloc = qapi_enum_parse(PreallocMode_lookup, buf,\n\n                               PREALLOC_MODE__MAX, PREALLOC_MODE_OFF,\n\n                               &local_err);\n\n    g_free(buf);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        result = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    fd = qemu_open(filename, O_RDWR | O_CREAT | O_TRUNC | O_BINARY,\n\n                   0644);\n\n    if (fd < 0) {\n\n        result = -errno;\n\n        error_setg_errno(errp, -result, \"Could not create file\");\n\n        goto out;\n\n    }\n\n\n\n    if (nocow) {\n\n#ifdef __linux__\n\n        /* Set NOCOW flag to solve performance issue on fs like btrfs.\n\n         * This is an optimisation. The FS_IOC_SETFLAGS ioctl return value\n\n         * will be ignored since any failure of this operation should not\n\n         * block the left work.\n\n         */\n\n        int attr;\n\n        if (ioctl(fd, FS_IOC_GETFLAGS, &attr) == 0) {\n\n            attr |= FS_NOCOW_FL;\n\n            ioctl(fd, FS_IOC_SETFLAGS, &attr);\n\n        }\n\n#endif\n\n    }\n\n\n\n    if (ftruncate(fd, total_size) != 0) {\n\n        result = -errno;\n\n        error_setg_errno(errp, -result, \"Could not resize file\");\n\n        goto out_close;\n\n    }\n\n\n\n    switch (prealloc) {\n\n#ifdef CONFIG_POSIX_FALLOCATE\n\n    case PREALLOC_MODE_FALLOC:\n\n        /* posix_fallocate() doesn't set errno. */\n\n        result = -posix_fallocate(fd, 0, total_size);\n\n        if (result != 0) {\n\n            error_setg_errno(errp, -result,\n\n                             \"Could not preallocate data for the new file\");\n\n        }\n\n        break;\n\n#endif\n\n    case PREALLOC_MODE_FULL:\n\n    {\n\n        int64_t num = 0, left = total_size;\n\n        buf = g_malloc0(65536);\n\n\n\n        while (left > 0) {\n\n            num = MIN(left, 65536);\n\n            result = write(fd, buf, num);\n\n            if (result < 0) {\n\n                result = -errno;\n\n                error_setg_errno(errp, -result,\n\n                                 \"Could not write to the new file\");\n\n                break;\n\n            }\n\n            left -= result;\n\n        }\n\n        if (result >= 0) {\n\n            result = fsync(fd);\n\n            if (result < 0) {\n\n                result = -errno;\n\n                error_setg_errno(errp, -result,\n\n                                 \"Could not flush new file to disk\");\n\n            }\n\n        }\n\n        g_free(buf);\n\n        break;\n\n    }\n\n    case PREALLOC_MODE_OFF:\n\n        break;\n\n    default:\n\n        result = -EINVAL;\n\n        error_setg(errp, \"Unsupported preallocation mode: %s\",\n\n                   PreallocMode_lookup[prealloc]);\n\n        break;\n\n    }\n\n\n\nout_close:\n\n    if (qemu_close(fd) != 0 && result == 0) {\n\n        result = -errno;\n\n        error_setg_errno(errp, -result, \"Could not close the new file\");\n\n    }\n\nout:\n\n    return result;\n\n}\n", "idx": 22323}
{"project": "qemu", "commit_id": "6e7d82497dc8da7d420c8fa6632d759e08a18bc3", "target": 0, "func": "void mips_malta_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    ram_addr_t ram_low_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    char *filename;\n\n    pflash_t *fl;\n\n    MemoryRegion *system_memory = get_system_memory();\n\n    MemoryRegion *ram_high = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ram_low_preio = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ram_low_postio;\n\n    MemoryRegion *bios, *bios_copy = g_new(MemoryRegion, 1);\n\n    target_long bios_size = FLASH_SIZE;\n\n    const size_t smbus_eeprom_size = 8 * 256;\n\n    uint8_t *smbus_eeprom_buf = g_malloc0(smbus_eeprom_size);\n\n    int64_t kernel_entry, bootloader_run_addr;\n\n    PCIBus *pci_bus;\n\n    ISABus *isa_bus;\n\n    MIPSCPU *cpu;\n\n    CPUMIPSState *env;\n\n    qemu_irq *isa_irq;\n\n    qemu_irq *cpu_exit_irq;\n\n    int piix4_devfn;\n\n    I2CBus *smbus;\n\n    int i;\n\n    DriveInfo *dinfo;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    DriveInfo *fd[MAX_FD];\n\n    int fl_idx = 0;\n\n    int fl_sectors = bios_size >> 16;\n\n    int be;\n\n\n\n    DeviceState *dev = qdev_create(NULL, TYPE_MIPS_MALTA);\n\n    MaltaState *s = MIPS_MALTA(dev);\n\n\n\n    /* The whole address space decoded by the GT-64120A doesn't generate\n\n       exception when accessing invalid memory. Create an empty slot to\n\n       emulate this feature. */\n\n    empty_slot_init(0, 0x20000000);\n\n\n\n    qdev_init_nofail(dev);\n\n\n\n    /* Make sure the first 3 serial ports are associated with a device. */\n\n    for(i = 0; i < 3; i++) {\n\n        if (!serial_hds[i]) {\n\n            char label[32];\n\n            snprintf(label, sizeof(label), \"serial%d\", i);\n\n            serial_hds[i] = qemu_chr_new(label, \"null\", NULL);\n\n        }\n\n    }\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n#ifdef TARGET_MIPS64\n\n        cpu_model = \"20Kc\";\n\n#else\n\n        cpu_model = \"24Kf\";\n\n#endif\n\n    }\n\n\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        cpu = cpu_mips_init(cpu_model);\n\n        if (cpu == NULL) {\n\n            fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        env = &cpu->env;\n\n\n\n        /* Init internal devices */\n\n        cpu_mips_irq_init_cpu(env);\n\n        cpu_mips_clock_init(env);\n\n        qemu_register_reset(main_cpu_reset, cpu);\n\n    }\n\n    cpu = MIPS_CPU(first_cpu);\n\n    env = &cpu->env;\n\n\n\n    /* allocate RAM */\n\n    if (ram_size > (2048u << 20)) {\n\n        fprintf(stderr,\n\n                \"qemu: Too much memory for this machine: %d MB, maximum 2048 MB\\n\",\n\n                ((unsigned int)ram_size / (1 << 20)));\n\n        exit(1);\n\n    }\n\n\n\n    /* register RAM at high address where it is undisturbed by IO */\n\n    memory_region_allocate_system_memory(ram_high, NULL, \"mips_malta.ram\",\n\n                                         ram_size);\n\n    memory_region_add_subregion(system_memory, 0x80000000, ram_high);\n\n\n\n    /* alias for pre IO hole access */\n\n    memory_region_init_alias(ram_low_preio, NULL, \"mips_malta_low_preio.ram\",\n\n                             ram_high, 0, MIN(ram_size, (256 << 20)));\n\n    memory_region_add_subregion(system_memory, 0, ram_low_preio);\n\n\n\n    /* alias for post IO hole access, if there is enough RAM */\n\n    if (ram_size > (512 << 20)) {\n\n        ram_low_postio = g_new(MemoryRegion, 1);\n\n        memory_region_init_alias(ram_low_postio, NULL,\n\n                                 \"mips_malta_low_postio.ram\",\n\n                                 ram_high, 512 << 20,\n\n                                 ram_size - (512 << 20));\n\n        memory_region_add_subregion(system_memory, 512 << 20, ram_low_postio);\n\n    }\n\n\n\n    /* generate SPD EEPROM data */\n\n    generate_eeprom_spd(&smbus_eeprom_buf[0 * 256], ram_size);\n\n    generate_eeprom_serial(&smbus_eeprom_buf[6 * 256]);\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    /* FPGA */\n\n    /* The CBUS UART is attached to the MIPS CPU INT2 pin, ie interrupt 4 */\n\n    malta_fpga_init(system_memory, FPGA_ADDRESS, env->irq[4], serial_hds[2]);\n\n\n\n    /* Load firmware in flash / BIOS. */\n\n    dinfo = drive_get(IF_PFLASH, 0, fl_idx);\n\n#ifdef DEBUG_BOARD_INIT\n\n    if (dinfo) {\n\n        printf(\"Register parallel flash %d size \" TARGET_FMT_lx \" at \"\n\n               \"addr %08llx '%s' %x\\n\",\n\n               fl_idx, bios_size, FLASH_ADDRESS,\n\n               blk_name(dinfo->bdrv), fl_sectors);\n\n    }\n\n#endif\n\n    fl = pflash_cfi01_register(FLASH_ADDRESS, NULL, \"mips_malta.bios\",\n\n                               BIOS_SIZE,\n\n                               dinfo ? blk_by_legacy_dinfo(dinfo) : NULL,\n\n                               65536, fl_sectors,\n\n                               4, 0x0000, 0x0000, 0x0000, 0x0000, be);\n\n    bios = pflash_cfi01_get_memory(fl);\n\n    fl_idx++;\n\n    if (kernel_filename) {\n\n        ram_low_size = MIN(ram_size, 256 << 20);\n\n        /* For KVM we reserve 1MB of RAM for running bootloader */\n\n        if (kvm_enabled()) {\n\n            ram_low_size -= 0x100000;\n\n            bootloader_run_addr = 0x40000000 + ram_low_size;\n\n        } else {\n\n            bootloader_run_addr = 0xbfc00000;\n\n        }\n\n\n\n        /* Write a small bootloader to the flash location. */\n\n        loaderparams.ram_size = ram_low_size;\n\n        loaderparams.kernel_filename = kernel_filename;\n\n        loaderparams.kernel_cmdline = kernel_cmdline;\n\n        loaderparams.initrd_filename = initrd_filename;\n\n        kernel_entry = load_kernel();\n\n\n\n        write_bootloader(env, memory_region_get_ram_ptr(bios),\n\n                         bootloader_run_addr, kernel_entry);\n\n        if (kvm_enabled()) {\n\n            /* Write the bootloader code @ the end of RAM, 1MB reserved */\n\n            write_bootloader(env, memory_region_get_ram_ptr(ram_low_preio) +\n\n                                    ram_low_size,\n\n                             bootloader_run_addr, kernel_entry);\n\n        }\n\n    } else {\n\n        /* The flash region isn't executable from a KVM guest */\n\n        if (kvm_enabled()) {\n\n            error_report(\"KVM enabled but no -kernel argument was specified. \"\n\n                         \"Booting from flash is not supported with KVM.\");\n\n            exit(1);\n\n        }\n\n        /* Load firmware from flash. */\n\n        if (!dinfo) {\n\n            /* Load a BIOS image. */\n\n            if (bios_name == NULL) {\n\n                bios_name = BIOS_FILENAME;\n\n            }\n\n            filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n            if (filename) {\n\n                bios_size = load_image_targphys(filename, FLASH_ADDRESS,\n\n                                                BIOS_SIZE);\n\n                g_free(filename);\n\n            } else {\n\n                bios_size = -1;\n\n            }\n\n            if ((bios_size < 0 || bios_size > BIOS_SIZE) &&\n\n                !kernel_filename && !qtest_enabled()) {\n\n                error_report(\"Could not load MIPS bios '%s', and no \"\n\n                             \"-kernel argument was specified\", bios_name);\n\n                exit(1);\n\n            }\n\n        }\n\n        /* In little endian mode the 32bit words in the bios are swapped,\n\n           a neat trick which allows bi-endian firmware. */\n\n#ifndef TARGET_WORDS_BIGENDIAN\n\n        {\n\n            uint32_t *end, *addr = rom_ptr(FLASH_ADDRESS);\n\n            if (!addr) {\n\n                addr = memory_region_get_ram_ptr(bios);\n\n            }\n\n            end = (void *)addr + MIN(bios_size, 0x3e0000);\n\n            while (addr < end) {\n\n                bswap32s(addr);\n\n                addr++;\n\n            }\n\n        }\n\n#endif\n\n    }\n\n\n\n    /*\n\n     * Map the BIOS at a 2nd physical location, as on the real board.\n\n     * Copy it so that we can patch in the MIPS revision, which cannot be\n\n     * handled by an overlapping region as the resulting ROM code subpage\n\n     * regions are not executable.\n\n     */\n\n    memory_region_init_ram(bios_copy, NULL, \"bios.1fc\", BIOS_SIZE,\n\n                           &error_abort);\n\n    if (!rom_copy(memory_region_get_ram_ptr(bios_copy),\n\n                  FLASH_ADDRESS, BIOS_SIZE)) {\n\n        memcpy(memory_region_get_ram_ptr(bios_copy),\n\n               memory_region_get_ram_ptr(bios), BIOS_SIZE);\n\n    }\n\n    memory_region_set_readonly(bios_copy, true);\n\n    memory_region_add_subregion(system_memory, RESET_ADDRESS, bios_copy);\n\n\n\n    /* Board ID = 0x420 (Malta Board with CoreLV) */\n\n    stl_p(memory_region_get_ram_ptr(bios_copy) + 0x10, 0x00000420);\n\n\n\n    /* Init internal devices */\n\n    cpu_mips_irq_init_cpu(env);\n\n    cpu_mips_clock_init(env);\n\n\n\n    /*\n\n     * We have a circular dependency problem: pci_bus depends on isa_irq,\n\n     * isa_irq is provided by i8259, i8259 depends on ISA, ISA depends\n\n     * on piix4, and piix4 depends on pci_bus.  To stop the cycle we have\n\n     * qemu_irq_proxy() adds an extra bit of indirection, allowing us\n\n     * to resolve the isa_irq -> i8259 dependency after i8259 is initialized.\n\n     */\n\n    isa_irq = qemu_irq_proxy(&s->i8259, 16);\n\n\n\n    /* Northbridge */\n\n    pci_bus = gt64120_register(isa_irq);\n\n\n\n    /* Southbridge */\n\n    ide_drive_get(hd, ARRAY_SIZE(hd));\n\n\n\n    piix4_devfn = piix4_init(pci_bus, &isa_bus, 80);\n\n\n\n    /* Interrupt controller */\n\n    /* The 8259 is attached to the MIPS CPU INT0 pin, ie interrupt 2 */\n\n    s->i8259 = i8259_init(isa_bus, env->irq[2]);\n\n\n\n    isa_bus_irqs(isa_bus, s->i8259);\n\n    pci_piix4_ide_init(pci_bus, hd, piix4_devfn + 1);\n\n    pci_create_simple(pci_bus, piix4_devfn + 2, \"piix4-usb-uhci\");\n\n    smbus = piix4_pm_init(pci_bus, piix4_devfn + 3, 0x1100,\n\n                          isa_get_irq(NULL, 9), NULL, 0, NULL, NULL);\n\n    smbus_eeprom_init(smbus, 8, smbus_eeprom_buf, smbus_eeprom_size);\n\n    g_free(smbus_eeprom_buf);\n\n    pit = pit_init(isa_bus, 0x40, 0, NULL);\n\n    cpu_exit_irq = qemu_allocate_irqs(cpu_request_exit, NULL, 1);\n\n    DMA_init(0, cpu_exit_irq);\n\n\n\n    /* Super I/O */\n\n    isa_create_simple(isa_bus, \"i8042\");\n\n\n\n    rtc_init(isa_bus, 2000, NULL);\n\n    serial_hds_isa_init(isa_bus, 2);\n\n    parallel_hds_isa_init(isa_bus, 1);\n\n\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        fd[i] = drive_get(IF_FLOPPY, 0, i);\n\n    }\n\n    fdctrl_init_isa(isa_bus, fd);\n\n\n\n    /* Network card */\n\n    network_init(pci_bus);\n\n\n\n    /* Optional PCI video card */\n\n    pci_vga_init(pci_bus);\n\n}\n", "idx": 22325}
{"project": "qemu", "commit_id": "e4937694b66d1468aec3cd95e90888f291c3f599", "target": 0, "func": "static int vmdk_parse_extents(const char *desc, BlockDriverState *bs,\n\n                              const char *desc_file_path, QDict *options,\n\n                              Error **errp)\n\n{\n\n    int ret;\n\n    int matches;\n\n    char access[11];\n\n    char type[11];\n\n    char fname[512];\n\n    const char *p = desc;\n\n    int64_t sectors = 0;\n\n    int64_t flat_offset;\n\n    char *extent_path;\n\n    BdrvChild *extent_file;\n\n    BDRVVmdkState *s = bs->opaque;\n\n    VmdkExtent *extent;\n\n    char extent_opt_prefix[32];\n\n    Error *local_err = NULL;\n\n\n\n    while (*p) {\n\n        /* parse extent line in one of below formats:\n\n         *\n\n         * RW [size in sectors] FLAT \"file-name.vmdk\" OFFSET\n\n         * RW [size in sectors] SPARSE \"file-name.vmdk\"\n\n         * RW [size in sectors] VMFS \"file-name.vmdk\"\n\n         * RW [size in sectors] VMFSSPARSE \"file-name.vmdk\"\n\n         */\n\n        flat_offset = -1;\n\n        matches = sscanf(p, \"%10s %\" SCNd64 \" %10s \\\"%511[^\\n\\r\\\"]\\\" %\" SCNd64,\n\n                         access, &sectors, type, fname, &flat_offset);\n\n        if (matches < 4 || strcmp(access, \"RW\")) {\n\n            goto next_line;\n\n        } else if (!strcmp(type, \"FLAT\")) {\n\n            if (matches != 5 || flat_offset < 0) {\n\n                error_setg(errp, \"Invalid extent lines: \\n%s\", p);\n\n                return -EINVAL;\n\n            }\n\n        } else if (!strcmp(type, \"VMFS\")) {\n\n            if (matches == 4) {\n\n                flat_offset = 0;\n\n            } else {\n\n                error_setg(errp, \"Invalid extent lines:\\n%s\", p);\n\n                return -EINVAL;\n\n            }\n\n        } else if (matches != 4) {\n\n            error_setg(errp, \"Invalid extent lines:\\n%s\", p);\n\n            return -EINVAL;\n\n        }\n\n\n\n        if (sectors <= 0 ||\n\n            (strcmp(type, \"FLAT\") && strcmp(type, \"SPARSE\") &&\n\n             strcmp(type, \"VMFS\") && strcmp(type, \"VMFSSPARSE\")) ||\n\n            (strcmp(access, \"RW\"))) {\n\n            goto next_line;\n\n        }\n\n\n\n        if (!path_is_absolute(fname) && !path_has_protocol(fname) &&\n\n            !desc_file_path[0])\n\n        {\n\n            error_setg(errp, \"Cannot use relative extent paths with VMDK \"\n\n                       \"descriptor file '%s'\", bs->file->bs->filename);\n\n            return -EINVAL;\n\n        }\n\n\n\n        extent_path = g_malloc0(PATH_MAX);\n\n        path_combine(extent_path, PATH_MAX, desc_file_path, fname);\n\n\n\n        ret = snprintf(extent_opt_prefix, 32, \"extents.%d\", s->num_extents);\n\n        assert(ret < 32);\n\n\n\n        extent_file = bdrv_open_child(extent_path, options, extent_opt_prefix,\n\n                                      bs, &child_file, false, &local_err);\n\n        g_free(extent_path);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return -EINVAL;\n\n        }\n\n\n\n        /* save to extents array */\n\n        if (!strcmp(type, \"FLAT\") || !strcmp(type, \"VMFS\")) {\n\n            /* FLAT extent */\n\n\n\n            ret = vmdk_add_extent(bs, extent_file, true, sectors,\n\n                            0, 0, 0, 0, 0, &extent, errp);\n\n            if (ret < 0) {\n\n                bdrv_unref_child(bs, extent_file);\n\n                return ret;\n\n            }\n\n            extent->flat_start_offset = flat_offset << 9;\n\n        } else if (!strcmp(type, \"SPARSE\") || !strcmp(type, \"VMFSSPARSE\")) {\n\n            /* SPARSE extent and VMFSSPARSE extent are both \"COWD\" sparse file*/\n\n            char *buf = vmdk_read_desc(extent_file->bs, 0, errp);\n\n            if (!buf) {\n\n                ret = -EINVAL;\n\n            } else {\n\n                ret = vmdk_open_sparse(bs, extent_file, bs->open_flags, buf,\n\n                                       options, errp);\n\n            }\n\n            g_free(buf);\n\n            if (ret) {\n\n                bdrv_unref_child(bs, extent_file);\n\n                return ret;\n\n            }\n\n            extent = &s->extents[s->num_extents - 1];\n\n        } else {\n\n            error_setg(errp, \"Unsupported extent type '%s'\", type);\n\n            bdrv_unref_child(bs, extent_file);\n\n            return -ENOTSUP;\n\n        }\n\n        extent->type = g_strdup(type);\n\nnext_line:\n\n        /* move to next line */\n\n        while (*p) {\n\n            if (*p == '\\n') {\n\n                p++;\n\n                break;\n\n            }\n\n            p++;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 22326}
{"project": "qemu", "commit_id": "3718d8ab65f68de2acccbe6a315907805f54e3cc", "target": 0, "func": "static void external_snapshot_prepare(BlkTransactionState *common,\n\n                                      Error **errp)\n\n{\n\n    BlockDriver *drv;\n\n    int flags, ret;\n\n    QDict *options = NULL;\n\n    Error *local_err = NULL;\n\n    bool has_device = false;\n\n    const char *device;\n\n    bool has_node_name = false;\n\n    const char *node_name;\n\n    bool has_snapshot_node_name = false;\n\n    const char *snapshot_node_name;\n\n    const char *new_image_file;\n\n    const char *format = \"qcow2\";\n\n    enum NewImageMode mode = NEW_IMAGE_MODE_ABSOLUTE_PATHS;\n\n    ExternalSnapshotState *state =\n\n                             DO_UPCAST(ExternalSnapshotState, common, common);\n\n    TransactionAction *action = common->action;\n\n\n\n    /* get parameters */\n\n    g_assert(action->kind == TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT_SYNC);\n\n\n\n    has_device = action->blockdev_snapshot_sync->has_device;\n\n    device = action->blockdev_snapshot_sync->device;\n\n    has_node_name = action->blockdev_snapshot_sync->has_node_name;\n\n    node_name = action->blockdev_snapshot_sync->node_name;\n\n    has_snapshot_node_name =\n\n        action->blockdev_snapshot_sync->has_snapshot_node_name;\n\n    snapshot_node_name = action->blockdev_snapshot_sync->snapshot_node_name;\n\n\n\n    new_image_file = action->blockdev_snapshot_sync->snapshot_file;\n\n    if (action->blockdev_snapshot_sync->has_format) {\n\n        format = action->blockdev_snapshot_sync->format;\n\n    }\n\n    if (action->blockdev_snapshot_sync->has_mode) {\n\n        mode = action->blockdev_snapshot_sync->mode;\n\n    }\n\n\n\n    /* start processing */\n\n    drv = bdrv_find_format(format);\n\n    if (!drv) {\n\n        error_set(errp, QERR_INVALID_BLOCK_FORMAT, format);\n\n        return;\n\n    }\n\n\n\n    state->old_bs = bdrv_lookup_bs(has_device ? device : NULL,\n\n                                   has_node_name ? node_name : NULL,\n\n                                   &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    if (has_node_name && !has_snapshot_node_name) {\n\n        error_setg(errp, \"New snapshot node name missing\");\n\n        return;\n\n    }\n\n\n\n    if (has_snapshot_node_name && bdrv_find_node(snapshot_node_name)) {\n\n        error_setg(errp, \"New snapshot node name already existing\");\n\n        return;\n\n    }\n\n\n\n    if (!bdrv_is_inserted(state->old_bs)) {\n\n        error_set(errp, QERR_DEVICE_HAS_NO_MEDIUM, device);\n\n        return;\n\n    }\n\n\n\n    if (bdrv_in_use(state->old_bs)) {\n\n        error_set(errp, QERR_DEVICE_IN_USE, device);\n\n        return;\n\n    }\n\n\n\n    if (!bdrv_is_read_only(state->old_bs)) {\n\n        if (bdrv_flush(state->old_bs)) {\n\n            error_set(errp, QERR_IO_ERROR);\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (!bdrv_is_first_non_filter(state->old_bs)) {\n\n        error_set(errp, QERR_FEATURE_DISABLED, \"snapshot\");\n\n        return;\n\n    }\n\n\n\n    flags = state->old_bs->open_flags;\n\n\n\n    /* create new image w/backing file */\n\n    if (mode != NEW_IMAGE_MODE_EXISTING) {\n\n        bdrv_img_create(new_image_file, format,\n\n                        state->old_bs->filename,\n\n                        state->old_bs->drv->format_name,\n\n                        NULL, -1, flags, &local_err, false);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (has_snapshot_node_name) {\n\n        options = qdict_new();\n\n        qdict_put(options, \"node-name\",\n\n                  qstring_from_str(snapshot_node_name));\n\n    }\n\n\n\n    /* TODO Inherit bs->options or only take explicit options with an\n\n     * extended QMP command? */\n\n    assert(state->new_bs == NULL);\n\n    ret = bdrv_open(&state->new_bs, new_image_file, NULL, options,\n\n                    flags | BDRV_O_NO_BACKING, drv, &local_err);\n\n    /* We will manually add the backing_hd field to the bs later */\n\n    if (ret != 0) {\n\n        error_propagate(errp, local_err);\n\n    }\n\n}\n", "idx": 22327}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void t_gen_lsl(TCGv d, TCGv a, TCGv b)\n\n{\n\n\tTCGv t0, t_31;\n\n\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\tt_31 = tcg_const_tl(31);\n\n\ttcg_gen_shl_tl(d, a, b);\n\n\n\n\ttcg_gen_sub_tl(t0, t_31, b);\n\n\ttcg_gen_sar_tl(t0, t0, t_31);\n\n\ttcg_gen_and_tl(t0, t0, d);\n\n\ttcg_gen_xor_tl(d, d, t0);\n\n\ttcg_temp_free(t0);\n\n\ttcg_temp_free(t_31);\n\n}\n", "idx": 22328}
{"project": "qemu", "commit_id": "b658c53d2b87c1e9e0ade887a70ecb0de1474a7b", "target": 0, "func": "int unix_listen_opts(QemuOpts *opts, Error **errp)\n\n{\n\n    struct sockaddr_un un;\n\n    const char *path = qemu_opt_get(opts, \"path\");\n\n    int sock, fd;\n\n\n\n    sock = qemu_socket(PF_UNIX, SOCK_STREAM, 0);\n\n    if (sock < 0) {\n\n        error_setg_errno(errp, errno, \"Failed to create socket\");\n\n        return -1;\n\n    }\n\n\n\n    memset(&un, 0, sizeof(un));\n\n    un.sun_family = AF_UNIX;\n\n    if (path && strlen(path)) {\n\n        snprintf(un.sun_path, sizeof(un.sun_path), \"%s\", path);\n\n    } else {\n\n        char *tmpdir = getenv(\"TMPDIR\");\n\n        snprintf(un.sun_path, sizeof(un.sun_path), \"%s/qemu-socket-XXXXXX\",\n\n                 tmpdir ? tmpdir : \"/tmp\");\n\n        /*\n\n         * This dummy fd usage silences the mktemp() unsecure warning.\n\n         * Using mkstemp() doesn't make things more secure here\n\n         * though.  bind() complains about existing files, so we have\n\n         * to unlink first and thus re-open the race window.  The\n\n         * worst case possible is bind() failing, i.e. a DoS attack.\n\n         */\n\n        fd = mkstemp(un.sun_path); close(fd);\n\n        qemu_opt_set(opts, \"path\", un.sun_path);\n\n    }\n\n\n\n    unlink(un.sun_path);\n\n    if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {\n\n        error_setg_errno(errp, errno, \"Failed to bind socket\");\n\n        goto err;\n\n    }\n\n    if (listen(sock, 1) < 0) {\n\n        error_setg_errno(errp, errno, \"Failed to listen on socket\");\n\n        goto err;\n\n    }\n\n\n\n    return sock;\n\n\n\nerr:\n\n    closesocket(sock);\n\n    return -1;\n\n}\n", "idx": 22329}
{"project": "qemu", "commit_id": "5229f45bd98558af84d806a98032df3cb741c357", "target": 0, "func": "AUXReply aux_request(AUXBus *bus, AUXCommand cmd, uint32_t address,\n\n                      uint8_t len, uint8_t *data)\n\n{\n\n    AUXReply ret = AUX_NACK;\n\n    I2CBus *i2c_bus = aux_get_i2c_bus(bus);\n\n    size_t i;\n\n    bool is_write = false;\n\n\n\n    DPRINTF(\"request at address 0x%\" PRIX32 \", command %u, len %u\\n\", address,\n\n            cmd, len);\n\n\n\n    switch (cmd) {\n\n    /*\n\n     * Forward the request on the AUX bus..\n\n     */\n\n    case WRITE_AUX:\n\n    case READ_AUX:\n\n        is_write = cmd == READ_AUX ? false : true;\n\n        for (i = 0; i < len; i++) {\n\n            if (!address_space_rw(&bus->aux_addr_space, address++,\n\n                                  MEMTXATTRS_UNSPECIFIED, data++, 1,\n\n                                  is_write)) {\n\n                ret = AUX_I2C_ACK;\n\n            } else {\n\n                ret = AUX_NACK;\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n    /*\n\n     * Classic I2C transactions..\n\n     */\n\n    case READ_I2C:\n\n    case WRITE_I2C:\n\n        is_write = cmd == READ_I2C ? false : true;\n\n        if (i2c_bus_busy(i2c_bus)) {\n\n            i2c_end_transfer(i2c_bus);\n\n        }\n\n\n\n        if (i2c_start_transfer(i2c_bus, address, is_write)) {\n\n            ret = AUX_I2C_NACK;\n\n            break;\n\n        }\n\n\n\n        ret = AUX_I2C_ACK;\n\n        while (len > 0) {\n\n            if (i2c_send_recv(i2c_bus, data++, is_write) < 0) {\n\n                ret = AUX_I2C_NACK;\n\n                break;\n\n            }\n\n            len--;\n\n        }\n\n        i2c_end_transfer(i2c_bus);\n\n        break;\n\n    /*\n\n     * I2C MOT transactions.\n\n     *\n\n     * Here we send a start when:\n\n     *  - We didn't start transaction yet.\n\n     *  - We had a READ and we do a WRITE.\n\n     *  - We changed the address.\n\n     */\n\n    case WRITE_I2C_MOT:\n\n    case READ_I2C_MOT:\n\n        is_write = cmd == READ_I2C_MOT ? false : true;\n\n        if (!i2c_bus_busy(i2c_bus)) {\n\n            /*\n\n             * No transactions started..\n\n             */\n\n            if (i2c_start_transfer(i2c_bus, address, is_write)) {\n\n                ret = AUX_I2C_NACK;\n\n                break;\n\n            }\n\n        } else if ((address != bus->last_i2c_address) ||\n\n                   (bus->last_transaction != cmd)) {\n\n            /*\n\n             * Transaction started but we need to restart..\n\n             */\n\n            i2c_end_transfer(i2c_bus);\n\n            if (i2c_start_transfer(i2c_bus, address, is_write)) {\n\n                ret = AUX_I2C_NACK;\n\n                break;\n\n            }\n\n        }\n\n\n\n        while (len > 0) {\n\n            if (i2c_send_recv(i2c_bus, data++, is_write) < 0) {\n\n                ret = AUX_I2C_NACK;\n\n                i2c_end_transfer(i2c_bus);\n\n                break;\n\n            }\n\n            len--;\n\n        }\n\n        bus->last_transaction = cmd;\n\n        bus->last_i2c_address = address;\n\n        ret = AUX_I2C_ACK;\n\n        break;\n\n    default:\n\n        DPRINTF(\"Not implemented!\\n\");\n\n        return AUX_NACK;\n\n    }\n\n\n\n    DPRINTF(\"reply: %u\\n\", ret);\n\n    return ret;\n\n}\n", "idx": 22330}
{"project": "qemu", "commit_id": "ac1970fbe8ad5a70174f462109ac0f6c7bf1bc43", "target": 0, "func": "MemoryRegionSection *phys_page_find(target_phys_addr_t index)\n\n{\n\n    PhysPageEntry lp = phys_map;\n\n    PhysPageEntry *p;\n\n    int i;\n\n    uint16_t s_index = phys_section_unassigned;\n\n\n\n    for (i = P_L2_LEVELS - 1; i >= 0 && !lp.is_leaf; i--) {\n\n        if (lp.ptr == PHYS_MAP_NODE_NIL) {\n\n            goto not_found;\n\n        }\n\n        p = phys_map_nodes[lp.ptr];\n\n        lp = p[(index >> (i * L2_BITS)) & (L2_SIZE - 1)];\n\n    }\n\n\n\n    s_index = lp.ptr;\n\nnot_found:\n\n    return &phys_sections[s_index];\n\n}\n", "idx": 22331}
{"project": "qemu", "commit_id": "ef76dc59fa5203d146a2acf85a0ad5a5971a4824", "target": 0, "func": "START_TEST(float_number)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        double decoded;\n\n        int skip;\n\n    } test_cases[] = {\n\n        { \"32.43\", 32.43 },\n\n        { \"0.222\", 0.222 },\n\n        { \"-32.12313\", -32.12313 },\n\n        { \"-32.20e-10\", -32.20e-10, .skip = 1 },\n\n        { },\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QObject *obj;\n\n        QFloat *qfloat;\n\n\n\n        obj = qobject_from_json(test_cases[i].encoded);\n\n        fail_unless(obj != NULL);\n\n        fail_unless(qobject_type(obj) == QTYPE_QFLOAT);\n\n\n\n        qfloat = qobject_to_qfloat(obj);\n\n        fail_unless(qfloat_get_double(qfloat) == test_cases[i].decoded);\n\n\n\n        if (test_cases[i].skip == 0) {\n\n            QString *str;\n\n\n\n            str = qobject_to_json(obj);\n\n            fail_unless(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);\n\n            QDECREF(str);\n\n        }\n\n\n\n        QDECREF(qfloat);\n\n    }\n\n}\n", "idx": 22334}
{"project": "qemu", "commit_id": "b61359781958759317ee6fd1a45b59be0b7dbbe1", "target": 0, "func": "void memory_region_add_subregion(MemoryRegion *mr,\n\n                                 hwaddr offset,\n\n                                 MemoryRegion *subregion)\n\n{\n\n    subregion->may_overlap = false;\n\n    subregion->priority = 0;\n\n    memory_region_add_subregion_common(mr, offset, subregion);\n\n}\n", "idx": 22335}
{"project": "qemu", "commit_id": "a2db2a1edd06a50b8a862c654cf993368cf9f1d9", "target": 0, "func": "static void xen_be_evtchn_event(void *opaque)\n\n{\n\n    struct XenDevice *xendev = opaque;\n\n    evtchn_port_t port;\n\n\n\n    port = xc_evtchn_pending(xendev->evtchndev);\n\n    if (port != xendev->local_port) {\n\n        xen_be_printf(xendev, 0, \"xc_evtchn_pending returned %d (expected %d)\\n\",\n\n                      port, xendev->local_port);\n\n        return;\n\n    }\n\n    xc_evtchn_unmask(xendev->evtchndev, port);\n\n\n\n    if (xendev->ops->event) {\n\n        xendev->ops->event(xendev);\n\n    }\n\n}\n", "idx": 22336}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "static void qpi_mem_writel(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    CPUState *env;\n\n\n\n    env = cpu_single_env;\n\n    if (!env)\n\n        return;\n\n    env->eflags = (env->eflags & ~(IF_MASK | IOPL_MASK)) | \n\n        (val & (IF_MASK | IOPL_MASK));\n\n}\n", "idx": 22337}
{"project": "qemu", "commit_id": "6864fa38972081833f79b39df74b9c08cc94f6cc", "target": 0, "func": "static int pci_apb_map_irq(PCIDevice *pci_dev, int irq_num)\n\n{\n\n    return ((pci_dev->devfn & 0x18) >> 1) + irq_num;\n\n}\n", "idx": 22338}
{"project": "qemu", "commit_id": "b436982f04fb33bb29fcdea190bd1fdc97dc65ef", "target": 0, "func": "static void mirror_read_complete(void *opaque, int ret)\n\n{\n\n    MirrorOp *op = opaque;\n\n    MirrorBlockJob *s = op->s;\n\n\n\n    aio_context_acquire(blk_get_aio_context(s->common.blk));\n\n    if (ret < 0) {\n\n        BlockErrorAction action;\n\n\n\n        bdrv_set_dirty_bitmap(s->dirty_bitmap, op->sector_num, op->nb_sectors);\n\n        action = mirror_error_action(s, true, -ret);\n\n        if (action == BLOCK_ERROR_ACTION_REPORT && s->ret >= 0) {\n\n            s->ret = ret;\n\n        }\n\n\n\n        mirror_iteration_done(op, ret);\n\n    } else {\n\n        blk_aio_pwritev(s->target, op->sector_num * BDRV_SECTOR_SIZE, &op->qiov,\n\n                        0, mirror_write_complete, op);\n\n    }\n\n    aio_context_release(blk_get_aio_context(s->common.blk));\n\n}\n", "idx": 22339}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static struct omap_mpu_timer_s *omap_mpu_timer_init(MemoryRegion *system_memory,\n\n                target_phys_addr_t base,\n\n                qemu_irq irq, omap_clk clk)\n\n{\n\n    struct omap_mpu_timer_s *s = (struct omap_mpu_timer_s *)\n\n            g_malloc0(sizeof(struct omap_mpu_timer_s));\n\n\n\n    s->irq = irq;\n\n    s->clk = clk;\n\n    s->timer = qemu_new_timer_ns(vm_clock, omap_timer_tick, s);\n\n    s->tick = qemu_bh_new(omap_timer_fire, s);\n\n    omap_mpu_timer_reset(s);\n\n    omap_timer_clk_setup(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_mpu_timer_ops, s,\n\n                          \"omap-mpu-timer\", 0x100);\n\n\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 22340}
{"project": "qemu", "commit_id": "9d40cd8a68cfc7606f4548cc9e812bab15c6dc28", "target": 0, "func": "static void arm_cpu_reset(CPUState *s)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(s);\n\n    ARMCPUClass *acc = ARM_CPU_GET_CLASS(cpu);\n\n    CPUARMState *env = &cpu->env;\n\n\n\n    acc->parent_reset(s);\n\n\n\n    memset(env, 0, offsetof(CPUARMState, end_reset_fields));\n\n\n\n    g_hash_table_foreach(cpu->cp_regs, cp_reg_reset, cpu);\n\n    g_hash_table_foreach(cpu->cp_regs, cp_reg_check_reset, cpu);\n\n\n\n    env->vfp.xregs[ARM_VFP_FPSID] = cpu->reset_fpsid;\n\n    env->vfp.xregs[ARM_VFP_MVFR0] = cpu->mvfr0;\n\n    env->vfp.xregs[ARM_VFP_MVFR1] = cpu->mvfr1;\n\n    env->vfp.xregs[ARM_VFP_MVFR2] = cpu->mvfr2;\n\n\n\n    cpu->power_state = cpu->start_powered_off ? PSCI_OFF : PSCI_ON;\n\n    s->halted = cpu->start_powered_off;\n\n\n\n    if (arm_feature(env, ARM_FEATURE_IWMMXT)) {\n\n        env->iwmmxt.cregs[ARM_IWMMXT_wCID] = 0x69051000 | 'Q';\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_AARCH64)) {\n\n        /* 64 bit CPUs always start in 64 bit mode */\n\n        env->aarch64 = 1;\n\n#if defined(CONFIG_USER_ONLY)\n\n        env->pstate = PSTATE_MODE_EL0t;\n\n        /* Userspace expects access to DC ZVA, CTL_EL0 and the cache ops */\n\n        env->cp15.sctlr_el[1] |= SCTLR_UCT | SCTLR_UCI | SCTLR_DZE;\n\n        /* and to the FP/Neon instructions */\n\n        env->cp15.cpacr_el1 = deposit64(env->cp15.cpacr_el1, 20, 2, 3);\n\n#else\n\n        /* Reset into the highest available EL */\n\n        if (arm_feature(env, ARM_FEATURE_EL3)) {\n\n            env->pstate = PSTATE_MODE_EL3h;\n\n        } else if (arm_feature(env, ARM_FEATURE_EL2)) {\n\n            env->pstate = PSTATE_MODE_EL2h;\n\n        } else {\n\n            env->pstate = PSTATE_MODE_EL1h;\n\n        }\n\n        env->pc = cpu->rvbar;\n\n#endif\n\n    } else {\n\n#if defined(CONFIG_USER_ONLY)\n\n        /* Userspace expects access to cp10 and cp11 for FP/Neon */\n\n        env->cp15.cpacr_el1 = deposit64(env->cp15.cpacr_el1, 20, 4, 0xf);\n\n#endif\n\n    }\n\n\n\n#if defined(CONFIG_USER_ONLY)\n\n    env->uncached_cpsr = ARM_CPU_MODE_USR;\n\n    /* For user mode we must enable access to coprocessors */\n\n    env->vfp.xregs[ARM_VFP_FPEXC] = 1 << 30;\n\n    if (arm_feature(env, ARM_FEATURE_IWMMXT)) {\n\n        env->cp15.c15_cpar = 3;\n\n    } else if (arm_feature(env, ARM_FEATURE_XSCALE)) {\n\n        env->cp15.c15_cpar = 1;\n\n    }\n\n#else\n\n    /* SVC mode with interrupts disabled.  */\n\n    env->uncached_cpsr = ARM_CPU_MODE_SVC;\n\n    env->daif = PSTATE_D | PSTATE_A | PSTATE_I | PSTATE_F;\n\n\n\n    if (arm_feature(env, ARM_FEATURE_M)) {\n\n        uint32_t initial_msp; /* Loaded from 0x0 */\n\n        uint32_t initial_pc; /* Loaded from 0x4 */\n\n        uint8_t *rom;\n\n\n\n        if (arm_feature(env, ARM_FEATURE_M_SECURITY)) {\n\n            env->v7m.secure = true;\n\n        }\n\n\n\n        /* The reset value of this bit is IMPDEF, but ARM recommends\n\n         * that it resets to 1, so QEMU always does that rather than making\n\n         * it dependent on CPU model.\n\n         */\n\n        env->v7m.ccr = R_V7M_CCR_STKALIGN_MASK;\n\n\n\n        /* Unlike A/R profile, M profile defines the reset LR value */\n\n        env->regs[14] = 0xffffffff;\n\n\n\n        /* Load the initial SP and PC from the vector table at address 0 */\n\n        rom = rom_ptr(0);\n\n        if (rom) {\n\n            /* Address zero is covered by ROM which hasn't yet been\n\n             * copied into physical memory.\n\n             */\n\n            initial_msp = ldl_p(rom);\n\n            initial_pc = ldl_p(rom + 4);\n\n        } else {\n\n            /* Address zero not covered by a ROM blob, or the ROM blob\n\n             * is in non-modifiable memory and this is a second reset after\n\n             * it got copied into memory. In the latter case, rom_ptr\n\n             * will return a NULL pointer and we should use ldl_phys instead.\n\n             */\n\n            initial_msp = ldl_phys(s->as, 0);\n\n            initial_pc = ldl_phys(s->as, 4);\n\n        }\n\n\n\n        env->regs[13] = initial_msp & 0xFFFFFFFC;\n\n        env->regs[15] = initial_pc & ~1;\n\n        env->thumb = initial_pc & 1;\n\n    }\n\n\n\n    /* AArch32 has a hard highvec setting of 0xFFFF0000.  If we are currently\n\n     * executing as AArch32 then check if highvecs are enabled and\n\n     * adjust the PC accordingly.\n\n     */\n\n    if (A32_BANKED_CURRENT_REG_GET(env, sctlr) & SCTLR_V) {\n\n        env->regs[15] = 0xFFFF0000;\n\n    }\n\n\n\n    env->vfp.xregs[ARM_VFP_FPEXC] = 0;\n\n#endif\n\n\n\n    if (arm_feature(env, ARM_FEATURE_PMSA)) {\n\n        if (cpu->pmsav7_dregion > 0) {\n\n            if (arm_feature(env, ARM_FEATURE_V8)) {\n\n                memset(env->pmsav8.rbar[M_REG_NS], 0,\n\n                       sizeof(*env->pmsav8.rbar[M_REG_NS])\n\n                       * cpu->pmsav7_dregion);\n\n                memset(env->pmsav8.rlar[M_REG_NS], 0,\n\n                       sizeof(*env->pmsav8.rlar[M_REG_NS])\n\n                       * cpu->pmsav7_dregion);\n\n                if (arm_feature(env, ARM_FEATURE_M_SECURITY)) {\n\n                    memset(env->pmsav8.rbar[M_REG_S], 0,\n\n                           sizeof(*env->pmsav8.rbar[M_REG_S])\n\n                           * cpu->pmsav7_dregion);\n\n                    memset(env->pmsav8.rlar[M_REG_S], 0,\n\n                           sizeof(*env->pmsav8.rlar[M_REG_S])\n\n                           * cpu->pmsav7_dregion);\n\n                }\n\n            } else if (arm_feature(env, ARM_FEATURE_V7)) {\n\n                memset(env->pmsav7.drbar, 0,\n\n                       sizeof(*env->pmsav7.drbar) * cpu->pmsav7_dregion);\n\n                memset(env->pmsav7.drsr, 0,\n\n                       sizeof(*env->pmsav7.drsr) * cpu->pmsav7_dregion);\n\n                memset(env->pmsav7.dracr, 0,\n\n                       sizeof(*env->pmsav7.dracr) * cpu->pmsav7_dregion);\n\n            }\n\n        }\n\n        env->pmsav7.rnr[M_REG_NS] = 0;\n\n        env->pmsav7.rnr[M_REG_S] = 0;\n\n        env->pmsav8.mair0[M_REG_NS] = 0;\n\n        env->pmsav8.mair0[M_REG_S] = 0;\n\n        env->pmsav8.mair1[M_REG_NS] = 0;\n\n        env->pmsav8.mair1[M_REG_S] = 0;\n\n    }\n\n\n\n    set_flush_to_zero(1, &env->vfp.standard_fp_status);\n\n    set_flush_inputs_to_zero(1, &env->vfp.standard_fp_status);\n\n    set_default_nan_mode(1, &env->vfp.standard_fp_status);\n\n    set_float_detect_tininess(float_tininess_before_rounding,\n\n                              &env->vfp.fp_status);\n\n    set_float_detect_tininess(float_tininess_before_rounding,\n\n                              &env->vfp.standard_fp_status);\n\n#ifndef CONFIG_USER_ONLY\n\n    if (kvm_enabled()) {\n\n        kvm_arm_reset_vcpu(cpu);\n\n    }\n\n#endif\n\n\n\n    hw_breakpoint_update_all(cpu);\n\n    hw_watchpoint_update_all(cpu);\n\n}\n", "idx": 22341}
{"project": "qemu", "commit_id": "17b74b98676aee5bc470b173b1e528d2fce2cf18", "target": 0, "func": "void json_start_array(QJSON *json, const char *name)\n\n{\n\n    json_emit_element(json, name);\n\n    qstring_append(json->str, \"[ \");\n\n    json->omit_comma = true;\n\n}\n", "idx": 22342}
{"project": "qemu", "commit_id": "1687a089f103f9b7a1b4a1555068054cb46ee9e9", "target": 0, "func": "vreader_get_reader_by_id(vreader_id_t id)\n\n{\n\n    VReader *reader = NULL;\n\n    VReaderListEntry *current_entry = NULL;\n\n\n\n    if (id == (vreader_id_t) -1) {\n\n        return NULL;\n\n    }\n\n\n\n    vreader_list_lock();\n\n    for (current_entry = vreader_list_get_first(vreader_list); current_entry;\n\n            current_entry = vreader_list_get_next(current_entry)) {\n\n        VReader *creader = vreader_list_get_reader(current_entry);\n\n        if (creader->id == id) {\n\n            reader = creader;\n\n            break;\n\n        }\n\n        vreader_free(creader);\n\n    }\n\n    vreader_list_unlock();\n\n    return reader;\n\n}\n", "idx": 22343}
{"project": "qemu", "commit_id": "57407ea44cc0a3d630b9b89a2be011f1955ce5c1", "target": 0, "func": "static void gem_cleanup(NetClientState *nc)\n\n{\n\n    GemState *s = qemu_get_nic_opaque(nc);\n\n\n\n    DB_PRINT(\"\\n\");\n\n    s->nic = NULL;\n\n}\n", "idx": 22345}
{"project": "qemu", "commit_id": "fae2afb10e3fdceab612c62a2b1e8b944ff578d9", "target": 0, "func": "void qxl_render_cursor(PCIQXLDevice *qxl, QXLCommandExt *ext)\n\n{\n\n    QXLCursorCmd *cmd = qxl_phys2virt(qxl, ext->cmd.data, ext->group_id);\n\n    QXLCursor *cursor;\n\n    QEMUCursor *c;\n\n\n\n    if (!qxl->ssd.ds->mouse_set || !qxl->ssd.ds->cursor_define) {\n\n        return;\n\n    }\n\n\n\n    if (qxl->debug > 1 && cmd->type != QXL_CURSOR_MOVE) {\n\n        fprintf(stderr, \"%s\", __FUNCTION__);\n\n        qxl_log_cmd_cursor(qxl, cmd, ext->group_id);\n\n        fprintf(stderr, \"\\n\");\n\n    }\n\n    switch (cmd->type) {\n\n    case QXL_CURSOR_SET:\n\n        cursor = qxl_phys2virt(qxl, cmd->u.set.shape, ext->group_id);\n\n        if (cursor->chunk.data_size != cursor->data_size) {\n\n            fprintf(stderr, \"%s: multiple chunks\\n\", __FUNCTION__);\n\n            return;\n\n        }\n\n        c = qxl_cursor(qxl, cursor);\n\n        if (c == NULL) {\n\n            c = cursor_builtin_left_ptr();\n\n        }\n\n        qemu_mutex_lock(&qxl->ssd.lock);\n\n        if (qxl->ssd.cursor) {\n\n            cursor_put(qxl->ssd.cursor);\n\n        }\n\n        qxl->ssd.cursor = c;\n\n        qxl->ssd.mouse_x = cmd->u.set.position.x;\n\n        qxl->ssd.mouse_y = cmd->u.set.position.y;\n\n        qemu_mutex_unlock(&qxl->ssd.lock);\n\n        break;\n\n    case QXL_CURSOR_MOVE:\n\n        qemu_mutex_lock(&qxl->ssd.lock);\n\n        qxl->ssd.mouse_x = cmd->u.position.x;\n\n        qxl->ssd.mouse_y = cmd->u.position.y;\n\n        qemu_mutex_unlock(&qxl->ssd.lock);\n\n        break;\n\n    }\n\n}\n", "idx": 22346}
{"project": "qemu", "commit_id": "435db4cf29b88b6612e30acda01cd18788dff458", "target": 0, "func": "static uint64_t qemu_opt_get_number_helper(QemuOpts *opts, const char *name,\n\n                                           uint64_t defval, bool del)\n\n{\n\n    QemuOpt *opt = qemu_opt_find(opts, name);\n\n    uint64_t ret = defval;\n\n\n\n    if (opt == NULL) {\n\n        const QemuOptDesc *desc = find_desc_by_name(opts->list->desc, name);\n\n        if (desc && desc->def_value_str) {\n\n            parse_option_number(name, desc->def_value_str, &ret, &error_abort);\n\n        }\n\n        return ret;\n\n    }\n\n    assert(opt->desc && opt->desc->type == QEMU_OPT_NUMBER);\n\n    ret = opt->value.uint;\n\n    if (del) {\n\n        qemu_opt_del_all(opts, name);\n\n    }\n\n    return ret;\n\n}\n", "idx": 22347}
{"project": "qemu", "commit_id": "677ef6230b603571ae05125db469f7b4c8912a77", "target": 0, "func": "void helper_unlock(void)\n\n{\n\n    spin_unlock(&global_cpu_lock);\n\n}\n", "idx": 22348}
{"project": "qemu", "commit_id": "2c62f08ddbf3fa80dc7202eb9a2ea60ae44e2cc5", "target": 0, "func": "static void vmsvga_screen_dump(void *opaque, const char *filename, bool cswitch,\n\n                               Error **errp)\n\n{\n\n    struct vmsvga_state_s *s = opaque;\n\n    DisplaySurface *surface = qemu_console_surface(s->vga.con);\n\n\n\n    if (!s->enable) {\n\n        s->vga.screen_dump(&s->vga, filename, cswitch, errp);\n\n        return;\n\n    }\n\n\n\n    if (surface_bits_per_pixel(surface) == 32) {\n\n        DisplaySurface *ds = qemu_create_displaysurface_from(\n\n                                 surface_width(surface),\n\n                                 surface_height(surface),\n\n                                 32,\n\n                                 surface_stride(surface),\n\n                                 s->vga.vram_ptr, false);\n\n        ppm_save(filename, ds, errp);\n\n        g_free(ds);\n\n    }\n\n}\n", "idx": 22349}
{"project": "qemu", "commit_id": "488d65772ce94aa439f26d7136db384aec460bcb", "target": 1, "func": "static void check_watchpoint(int offset, int len_mask, int flags)\n\n{\n\n    CPUState *env = cpu_single_env;\n\n    target_ulong pc, cs_base;\n\n    TranslationBlock *tb;\n\n    target_ulong vaddr;\n\n    CPUWatchpoint *wp;\n\n    int cpu_flags;\n\n\n\n    if (env->watchpoint_hit) {\n\n        /* We re-entered the check after replacing the TB. Now raise\n\n         * the debug interrupt so that is will trigger after the\n\n         * current instruction. */\n\n        cpu_interrupt(env, CPU_INTERRUPT_DEBUG);\n\n        return;\n\n    }\n\n    vaddr = (env->mem_io_vaddr & TARGET_PAGE_MASK) + offset;\n\n    QTAILQ_FOREACH(wp, &env->watchpoints, entry) {\n\n        if ((vaddr == (wp->vaddr & len_mask) ||\n\n             (vaddr & wp->len_mask) == wp->vaddr) && (wp->flags & flags)) {\n\n            wp->flags |= BP_WATCHPOINT_HIT;\n\n            if (!env->watchpoint_hit) {\n\n                env->watchpoint_hit = wp;\n\n                tb = tb_find_pc(env->mem_io_pc);\n\n                if (!tb) {\n\n                    cpu_abort(env, \"check_watchpoint: could not find TB for \"\n\n                              \"pc=%p\", (void *)env->mem_io_pc);\n\n                }\n\n                cpu_restore_state(tb, env, env->mem_io_pc);\n\n                tb_phys_invalidate(tb, -1);\n\n                if (wp->flags & BP_STOP_BEFORE_ACCESS) {\n\n                    env->exception_index = EXCP_DEBUG;\n\n                } else {\n\n                    cpu_get_tb_cpu_state(env, &pc, &cs_base, &cpu_flags);\n\n                    tb_gen_code(env, pc, cs_base, cpu_flags, 1);\n\n                }\n\n                cpu_resume_from_signal(env, NULL);\n\n            }\n\n        } else {\n\n            wp->flags &= ~BP_WATCHPOINT_HIT;\n\n        }\n\n    }\n\n}\n", "idx": 22350}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "void sth_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint16_t val)\n\n{\n\n    val = tswap16(val);\n\n    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));\n\n}\n", "idx": 22352}
{"project": "qemu", "commit_id": "7372c2b926200db295412efbb53f93773b7f1754", "target": 1, "func": "static inline int opsize_bytes(int opsize)\n\n{\n\n    switch (opsize) {\n\n    case OS_BYTE: return 1;\n\n    case OS_WORD: return 2;\n\n    case OS_LONG: return 4;\n\n    case OS_SINGLE: return 4;\n\n    case OS_DOUBLE: return 8;\n\n    default:\n\n        qemu_assert(0, \"bad operand size\");\n\n        return 0;\n\n    }\n\n}\n", "idx": 22354}
{"project": "qemu", "commit_id": "ce8f0905a59232982c8a220169e11c14c73e7dea", "target": 1, "func": "static void pl011_write(void *opaque, hwaddr offset,\n\n                        uint64_t value, unsigned size)\n\n{\n\n    PL011State *s = (PL011State *)opaque;\n\n    unsigned char ch;\n\n\n\n    switch (offset >> 2) {\n\n    case 0: /* UARTDR */\n\n        /* ??? Check if transmitter is enabled.  */\n\n        ch = value;\n\n        if (s->chr)\n\n            qemu_chr_fe_write(s->chr, &ch, 1);\n\n        s->int_level |= PL011_INT_TX;\n\n        pl011_update(s);\n\n        break;\n\n    case 1: /* UARTCR */\n\n        s->cr = value;\n\n        break;\n\n    case 6: /* UARTFR */\n\n        /* Writes to Flag register are ignored.  */\n\n        break;\n\n    case 8: /* UARTUARTILPR */\n\n        s->ilpr = value;\n\n        break;\n\n    case 9: /* UARTIBRD */\n\n        s->ibrd = value;\n\n        break;\n\n    case 10: /* UARTFBRD */\n\n        s->fbrd = value;\n\n        break;\n\n    case 11: /* UARTLCR_H */\n\n        /* Reset the FIFO state on FIFO enable or disable */\n\n        if ((s->lcr ^ value) & 0x10) {\n\n            s->read_count = 0;\n\n            s->read_pos = 0;\n\n        }\n\n        s->lcr = value;\n\n        pl011_set_read_trigger(s);\n\n        break;\n\n    case 12: /* UARTCR */\n\n        /* ??? Need to implement the enable and loopback bits.  */\n\n        s->cr = value;\n\n        break;\n\n    case 13: /* UARTIFS */\n\n        s->ifl = value;\n\n        pl011_set_read_trigger(s);\n\n        break;\n\n    case 14: /* UARTIMSC */\n\n        s->int_enabled = value;\n\n        pl011_update(s);\n\n        break;\n\n    case 17: /* UARTICR */\n\n        s->int_level &= ~value;\n\n        pl011_update(s);\n\n        break;\n\n    case 18: /* UARTDMACR */\n\n        s->dmacr = value;\n\n        if (value & 3) {\n\n            qemu_log_mask(LOG_UNIMP, \"pl011: DMA not implemented\\n\");\n\n        }\n\n        break;\n\n    default:\n\n        qemu_log_mask(LOG_GUEST_ERROR,\n\n                      \"pl011_write: Bad offset %x\\n\", (int)offset);\n\n    }\n\n}\n", "idx": 22359}
{"project": "qemu", "commit_id": "af7e9e74c6a62a5bcd911726a9e88d28b61490e0", "target": 1, "func": "static uint64_t openpic_gbl_read(void *opaque, hwaddr addr, unsigned len)\n\n{\n\n    OpenPICState *opp = opaque;\n\n    uint32_t retval;\n\n\n\n    DPRINTF(\"%s: addr \" TARGET_FMT_plx \"\\n\", __func__, addr);\n\n    retval = 0xFFFFFFFF;\n\n    if (addr & 0xF)\n\n        return retval;\n\n    switch (addr) {\n\n    case 0x1000: /* FREP */\n\n        retval = opp->frep;\n\n        break;\n\n    case 0x1020: /* GLBC */\n\n        retval = opp->glbc;\n\n        break;\n\n    case 0x1080: /* VENI */\n\n        retval = opp->veni;\n\n        break;\n\n    case 0x1090: /* PINT */\n\n        retval = 0x00000000;\n\n        break;\n\n    case 0x00: /* Block Revision Register1 (BRR1) */\n\n        retval = opp->brr1;\n\n        break;\n\n    case 0x40:\n\n    case 0x50:\n\n    case 0x60:\n\n    case 0x70:\n\n    case 0x80:\n\n    case 0x90:\n\n    case 0xA0:\n\n    case 0xB0:\n\n        retval = openpic_cpu_read_internal(opp, addr, get_current_cpu());\n\n        break;\n\n    case 0x10A0: /* IPI_IPVP */\n\n    case 0x10B0:\n\n    case 0x10C0:\n\n    case 0x10D0:\n\n        {\n\n            int idx;\n\n            idx = (addr - 0x10A0) >> 4;\n\n            retval = read_IRQreg_ipvp(opp, opp->irq_ipi0 + idx);\n\n        }\n\n        break;\n\n    case 0x10E0: /* SPVE */\n\n        retval = opp->spve;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n    DPRINTF(\"%s: => %08x\\n\", __func__, retval);\n\n\n\n    return retval;\n\n}\n", "idx": 22360}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "MigrationInfo *qmp_query_migrate(Error **errp)\n\n{\n\n    MigrationInfo *info = g_malloc0(sizeof(*info));\n\n    MigrationState *s = migrate_get_current();\n\n\n\n    switch (s->state) {\n\n    case MIG_STATE_NONE:\n\n        /* no migration has happened ever */\n\n        break;\n\n    case MIG_STATE_SETUP:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"setup\");\n\n        info->has_total_time = false;\n\n        break;\n\n    case MIG_STATE_ACTIVE:\n\n    case MIG_STATE_CANCELLING:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"active\");\n\n        info->has_total_time = true;\n\n        info->total_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME)\n\n            - s->total_time;\n\n        info->has_expected_downtime = true;\n\n        info->expected_downtime = s->expected_downtime;\n\n        info->has_setup_time = true;\n\n        info->setup_time = s->setup_time;\n\n\n\n        info->has_ram = true;\n\n        info->ram = g_malloc0(sizeof(*info->ram));\n\n        info->ram->transferred = ram_bytes_transferred();\n\n        info->ram->remaining = ram_bytes_remaining();\n\n        info->ram->total = ram_bytes_total();\n\n        info->ram->duplicate = dup_mig_pages_transferred();\n\n        info->ram->skipped = skipped_mig_pages_transferred();\n\n        info->ram->normal = norm_mig_pages_transferred();\n\n        info->ram->normal_bytes = norm_mig_bytes_transferred();\n\n        info->ram->dirty_pages_rate = s->dirty_pages_rate;\n\n        info->ram->mbps = s->mbps;\n\n        info->ram->dirty_sync_count = s->dirty_sync_count;\n\n\n\n        if (blk_mig_active()) {\n\n            info->has_disk = true;\n\n            info->disk = g_malloc0(sizeof(*info->disk));\n\n            info->disk->transferred = blk_mig_bytes_transferred();\n\n            info->disk->remaining = blk_mig_bytes_remaining();\n\n            info->disk->total = blk_mig_bytes_total();\n\n        }\n\n\n\n        get_xbzrle_cache_stats(info);\n\n        break;\n\n    case MIG_STATE_COMPLETED:\n\n        get_xbzrle_cache_stats(info);\n\n\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"completed\");\n\n        info->has_total_time = true;\n\n        info->total_time = s->total_time;\n\n        info->has_downtime = true;\n\n        info->downtime = s->downtime;\n\n        info->has_setup_time = true;\n\n        info->setup_time = s->setup_time;\n\n\n\n        info->has_ram = true;\n\n        info->ram = g_malloc0(sizeof(*info->ram));\n\n        info->ram->transferred = ram_bytes_transferred();\n\n        info->ram->remaining = 0;\n\n        info->ram->total = ram_bytes_total();\n\n        info->ram->duplicate = dup_mig_pages_transferred();\n\n        info->ram->skipped = skipped_mig_pages_transferred();\n\n        info->ram->normal = norm_mig_pages_transferred();\n\n        info->ram->normal_bytes = norm_mig_bytes_transferred();\n\n        info->ram->mbps = s->mbps;\n\n        info->ram->dirty_sync_count = s->dirty_sync_count;\n\n        break;\n\n    case MIG_STATE_ERROR:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"failed\");\n\n        break;\n\n    case MIG_STATE_CANCELLED:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"cancelled\");\n\n        break;\n\n    }\n\n\n\n    return info;\n\n}\n", "idx": 22364}
{"project": "qemu", "commit_id": "b0ad5a455d7e5352d4c86ba945112011dbeadfb8", "target": 1, "func": "static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)\n\n{\n\n    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;\n\n    uint8_t bitmap;\n\n\n\n    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=\n\n\t    sizeof(bitmap)) {\n\n       return -errno;\n\n    }\n\n\n\n    bitmap |= (1 << (bitnum % 8));\n\n\n\n    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=\n\n\t    sizeof(bitmap)) {\n\n       return -errno;\n\n    }\n\n    return 0;\n\n}\n", "idx": 22365}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_swap_half(TCGv var)\n\n{\n\n    TCGv tmp = new_tmp();\n\n    tcg_gen_shri_i32(tmp, var, 16);\n\n    tcg_gen_shli_i32(var, var, 16);\n\n    tcg_gen_or_i32(var, var, tmp);\n\n    dead_tmp(tmp);\n\n}\n", "idx": 22366}
{"project": "qemu", "commit_id": "9d7a4c6690ef9962a3b20034f65008f1ea15c1d6", "target": 1, "func": "void g_free(void *mem)\n\n{\n\n    free(mem);\n\n}\n", "idx": 22367}
{"project": "qemu", "commit_id": "d4370741402a97b8b6d0c38fef18ab38bf25ab22", "target": 1, "func": "static gboolean gd_vc_in(GIOChannel *chan, GIOCondition cond, void *opaque)\n\n{\n\n    VirtualConsole *vc = opaque;\n\n    uint8_t buffer[1024];\n\n    ssize_t len;\n\n\n\n    len = read(vc->fd, buffer, sizeof(buffer));\n\n    if (len <= 0) {\n\n        return FALSE;\n\n    }\n\n\n\n    qemu_chr_be_write(vc->chr, buffer, len);\n\n\n\n    return TRUE;\n\n}\n", "idx": 22368}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(cmpl)\n\n{\n\n    if (T0 < T1) {\n\n        T0 = 0x08;\n\n    } else if (T0 > T1) {\n\n        T0 = 0x04;\n\n    } else {\n\n        T0 = 0x02;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 22369}
{"project": "qemu", "commit_id": "4d1628e832dfc6ec02b0d196f6cc250aaa7bf3b3", "target": 1, "func": "uint64_t helper_mullv(CPUAlphaState *env, uint64_t op1, uint64_t op2)\n\n{\n\n    int64_t res = (int64_t)op1 * (int64_t)op2;\n\n\n\n    if (unlikely((int32_t)res != res)) {\n\n        arith_excp(env, GETPC(), EXC_M_IOV, 0);\n\n    }\n\n    return (int64_t)((int32_t)res);\n\n}\n", "idx": 22372}
{"project": "qemu", "commit_id": "8c6c0478996e8f77374e69b6df68655b0b4ba689", "target": 1, "func": "vmxnet3_init_msi(VMXNET3State *s)\n\n{\n\n    PCIDevice *d = PCI_DEVICE(s);\n\n    int res;\n\n\n\n    res = msi_init(d, VMXNET3_MSI_OFFSET, VMXNET3_MSI_NUM_VECTORS,\n\n                   VMXNET3_USE_64BIT, VMXNET3_PER_VECTOR_MASK);\n\n    if (0 > res) {\n\n        VMW_WRPRN(\"Failed to initialize MSI, error %d\", res);\n\n        s->msi_used = false;\n\n    } else {\n\n        s->msi_used = true;\n\n    }\n\n\n\n    return s->msi_used;\n\n}\n", "idx": 22374}
{"project": "qemu", "commit_id": "2bf3aa85f08186b8162b76e7e8efe5b5a44306a6", "target": 1, "func": "static int ram_save_compressed_page(RAMState *rs, PageSearchStatus *pss,\n\n                                    bool last_stage)\n\n{\n\n    int pages = -1;\n\n    uint64_t bytes_xmit = 0;\n\n    uint8_t *p;\n\n    int ret, blen;\n\n    RAMBlock *block = pss->block;\n\n    ram_addr_t offset = pss->page << TARGET_PAGE_BITS;\n\n\n\n    p = block->host + offset;\n\n\n\n    ret = ram_control_save_page(rs->f, block->offset,\n\n                                offset, TARGET_PAGE_SIZE, &bytes_xmit);\n\n    if (bytes_xmit) {\n\n        rs->bytes_transferred += bytes_xmit;\n\n        pages = 1;\n\n    }\n\n    if (ret != RAM_SAVE_CONTROL_NOT_SUPP) {\n\n        if (ret != RAM_SAVE_CONTROL_DELAYED) {\n\n            if (bytes_xmit > 0) {\n\n                rs->norm_pages++;\n\n            } else if (bytes_xmit == 0) {\n\n                rs->zero_pages++;\n\n            }\n\n        }\n\n    } else {\n\n        /* When starting the process of a new block, the first page of\n\n         * the block should be sent out before other pages in the same\n\n         * block, and all the pages in last block should have been sent\n\n         * out, keeping this order is important, because the 'cont' flag\n\n         * is used to avoid resending the block name.\n\n         */\n\n        if (block != rs->last_sent_block) {\n\n            flush_compressed_data(rs);\n\n            pages = save_zero_page(rs, block, offset, p);\n\n            if (pages == -1) {\n\n                /* Make sure the first page is sent out before other pages */\n\n                bytes_xmit = save_page_header(rs, block, offset |\n\n                                              RAM_SAVE_FLAG_COMPRESS_PAGE);\n\n                blen = qemu_put_compression_data(rs->f, p, TARGET_PAGE_SIZE,\n\n                                                 migrate_compress_level());\n\n                if (blen > 0) {\n\n                    rs->bytes_transferred += bytes_xmit + blen;\n\n                    rs->norm_pages++;\n\n                    pages = 1;\n\n                } else {\n\n                    qemu_file_set_error(rs->f, blen);\n\n                    error_report(\"compressed data failed!\");\n\n                }\n\n            }\n\n            if (pages > 0) {\n\n                ram_release_pages(block->idstr, offset, pages);\n\n            }\n\n        } else {\n\n            pages = save_zero_page(rs, block, offset, p);\n\n            if (pages == -1) {\n\n                pages = compress_page_with_multi_thread(rs, block, offset);\n\n            } else {\n\n                ram_release_pages(block->idstr, offset, pages);\n\n            }\n\n        }\n\n    }\n\n\n\n    return pages;\n\n}\n", "idx": 22376}
{"project": "qemu", "commit_id": "680dfde91981516942ec557ef1c27753db24cbe8", "target": 1, "func": "static int open_self_cmdline(void *cpu_env, int fd)\n\n{\n\n    int fd_orig = -1;\n\n    bool word_skipped = false;\n\n\n\n    fd_orig = open(\"/proc/self/cmdline\", O_RDONLY);\n\n    if (fd_orig < 0) {\n\n        return fd_orig;\n\n    }\n\n\n\n    while (true) {\n\n        ssize_t nb_read;\n\n        char buf[128];\n\n        char *cp_buf = buf;\n\n\n\n        nb_read = read(fd_orig, buf, sizeof(buf));\n\n        if (nb_read < 0) {\n\n            fd_orig = close(fd_orig);\n\n            return -1;\n\n        } else if (nb_read == 0) {\n\n            break;\n\n        }\n\n\n\n        if (!word_skipped) {\n\n            /* Skip the first string, which is the path to qemu-*-static\n\n               instead of the actual command. */\n\n            cp_buf = memchr(buf, 0, sizeof(buf));\n\n            if (cp_buf) {\n\n                /* Null byte found, skip one string */\n\n                cp_buf++;\n\n                nb_read -= cp_buf - buf;\n\n                word_skipped = true;\n\n            }\n\n        }\n\n\n\n        if (word_skipped) {\n\n            if (write(fd, cp_buf, nb_read) != nb_read) {\n\n\n                return -1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return close(fd_orig);\n\n}", "idx": 22377}
{"project": "qemu", "commit_id": "80168bff43760bde98388480dc7c93f94693421c", "target": 1, "func": "int bdrv_create(BlockDriver *drv, const char* filename,\n\n    QEMUOptionParameter *options)\n\n{\n\n    int ret;\n\n\n\n    Coroutine *co;\n\n    CreateCo cco = {\n\n        .drv = drv,\n\n        .filename = g_strdup(filename),\n\n        .options = options,\n\n        .ret = NOT_DONE,\n\n    };\n\n\n\n    if (!drv->bdrv_create) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    if (qemu_in_coroutine()) {\n\n        /* Fast-path if already in coroutine context */\n\n        bdrv_create_co_entry(&cco);\n\n    } else {\n\n        co = qemu_coroutine_create(bdrv_create_co_entry);\n\n        qemu_coroutine_enter(co, &cco);\n\n        while (cco.ret == NOT_DONE) {\n\n            qemu_aio_wait();\n\n        }\n\n    }\n\n\n\n    ret = cco.ret;\n\n    g_free(cco.filename);\n\n\n\n    return ret;\n\n}\n", "idx": 22378}
{"project": "qemu", "commit_id": "e78815a554adaa551d62a71be10ee2fcf128e473", "target": 1, "func": "int ram_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    ram_addr_t addr;\n\n    int flags;\n\n\n\n    if (version_id < 3 || version_id > 4) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    do {\n\n        addr = qemu_get_be64(f);\n\n\n\n        flags = addr & ~TARGET_PAGE_MASK;\n\n        addr &= TARGET_PAGE_MASK;\n\n\n\n        if (flags & RAM_SAVE_FLAG_MEM_SIZE) {\n\n            if (version_id == 3) {\n\n                if (addr != ram_bytes_total()) {\n\n                    return -EINVAL;\n\n                }\n\n            } else {\n\n                /* Synchronize RAM block list */\n\n                char id[256];\n\n                ram_addr_t length;\n\n                ram_addr_t total_ram_bytes = addr;\n\n\n\n                while (total_ram_bytes) {\n\n                    RAMBlock *block;\n\n                    uint8_t len;\n\n\n\n                    len = qemu_get_byte(f);\n\n                    qemu_get_buffer(f, (uint8_t *)id, len);\n\n                    id[len] = 0;\n\n                    length = qemu_get_be64(f);\n\n\n\n                    QLIST_FOREACH(block, &ram_list.blocks, next) {\n\n                        if (!strncmp(id, block->idstr, sizeof(id))) {\n\n                            if (block->length != length)\n\n                                return -EINVAL;\n\n                            break;\n\n                        }\n\n                    }\n\n\n\n                    if (!block) {\n\n                        fprintf(stderr, \"Unknown ramblock \\\"%s\\\", cannot \"\n\n                                \"accept migration\\n\", id);\n\n                        return -EINVAL;\n\n                    }\n\n\n\n                    total_ram_bytes -= length;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (flags & RAM_SAVE_FLAG_COMPRESS) {\n\n            void *host;\n\n            uint8_t ch;\n\n\n\n            if (version_id == 3)\n\n                host = qemu_get_ram_ptr(addr);\n\n            else\n\n                host = host_from_stream_offset(f, addr, flags);\n\n\n\n            ch = qemu_get_byte(f);\n\n            memset(host, ch, TARGET_PAGE_SIZE);\n\n#ifndef _WIN32\n\n            if (ch == 0 &&\n\n                (!kvm_enabled() || kvm_has_sync_mmu())) {\n\n                madvise(host, TARGET_PAGE_SIZE, MADV_DONTNEED);\n\n            }\n\n#endif\n\n        } else if (flags & RAM_SAVE_FLAG_PAGE) {\n\n            void *host;\n\n\n\n            if (version_id == 3)\n\n                host = qemu_get_ram_ptr(addr);\n\n            else\n\n                host = host_from_stream_offset(f, addr, flags);\n\n\n\n            qemu_get_buffer(f, host, TARGET_PAGE_SIZE);\n\n        }\n\n        if (qemu_file_has_error(f)) {\n\n            return -EIO;\n\n        }\n\n    } while (!(flags & RAM_SAVE_FLAG_EOS));\n\n\n\n    return 0;\n\n}\n", "idx": 22381}
{"project": "qemu", "commit_id": "c3e10c7b4377c1cbc0a4fbc12312c2cf41c0cda7", "target": 1, "func": "static always_inline void gen_405_mulladd_insn (DisasContext *ctx,\n\n                                                int opc2, int opc3,\n\n                                                int ra, int rb, int rt, int Rc)\n\n{\n\n    gen_op_load_gpr_T0(ra);\n\n    gen_op_load_gpr_T1(rb);\n\n    switch (opc3 & 0x0D) {\n\n    case 0x05:\n\n        /* macchw    - macchw.    - macchwo   - macchwo.   */\n\n        /* macchws   - macchws.   - macchwso  - macchwso.  */\n\n        /* nmacchw   - nmacchw.   - nmacchwo  - nmacchwo.  */\n\n        /* nmacchws  - nmacchws.  - nmacchwso - nmacchwso. */\n\n        /* mulchw - mulchw. */\n\n        gen_op_405_mulchw();\n\n        break;\n\n    case 0x04:\n\n        /* macchwu   - macchwu.   - macchwuo  - macchwuo.  */\n\n        /* macchwsu  - macchwsu.  - macchwsuo - macchwsuo. */\n\n        /* mulchwu - mulchwu. */\n\n        gen_op_405_mulchwu();\n\n        break;\n\n    case 0x01:\n\n        /* machhw    - machhw.    - machhwo   - machhwo.   */\n\n        /* machhws   - machhws.   - machhwso  - machhwso.  */\n\n        /* nmachhw   - nmachhw.   - nmachhwo  - nmachhwo.  */\n\n        /* nmachhws  - nmachhws.  - nmachhwso - nmachhwso. */\n\n        /* mulhhw - mulhhw. */\n\n        gen_op_405_mulhhw();\n\n        break;\n\n    case 0x00:\n\n        /* machhwu   - machhwu.   - machhwuo  - machhwuo.  */\n\n        /* machhwsu  - machhwsu.  - machhwsuo - machhwsuo. */\n\n        /* mulhhwu - mulhhwu. */\n\n        gen_op_405_mulhhwu();\n\n        break;\n\n    case 0x0D:\n\n        /* maclhw    - maclhw.    - maclhwo   - maclhwo.   */\n\n        /* maclhws   - maclhws.   - maclhwso  - maclhwso.  */\n\n        /* nmaclhw   - nmaclhw.   - nmaclhwo  - nmaclhwo.  */\n\n        /* nmaclhws  - nmaclhws.  - nmaclhwso - nmaclhwso. */\n\n        /* mullhw - mullhw. */\n\n        gen_op_405_mullhw();\n\n        break;\n\n    case 0x0C:\n\n        /* maclhwu   - maclhwu.   - maclhwuo  - maclhwuo.  */\n\n        /* maclhwsu  - maclhwsu.  - maclhwsuo - maclhwsuo. */\n\n        /* mullhwu - mullhwu. */\n\n        gen_op_405_mullhwu();\n\n        break;\n\n    }\n\n    if (opc2 & 0x02) {\n\n        /* nmultiply-and-accumulate (0x0E) */\n\n        gen_op_neg();\n\n    }\n\n    if (opc2 & 0x04) {\n\n        /* (n)multiply-and-accumulate (0x0C - 0x0E) */\n\n        gen_op_load_gpr_T2(rt);\n\n        gen_op_move_T1_T0();\n\n        gen_op_405_add_T0_T2();\n\n    }\n\n    if (opc3 & 0x10) {\n\n        /* Check overflow */\n\n        if (opc3 & 0x01)\n\n            gen_op_405_check_ov();\n\n        else\n\n            gen_op_405_check_ovu();\n\n    }\n\n    if (opc3 & 0x02) {\n\n        /* Saturate */\n\n        if (opc3 & 0x01)\n\n            gen_op_405_check_sat();\n\n        else\n\n            gen_op_405_check_satu();\n\n    }\n\n    gen_op_store_T0_gpr(rt);\n\n    if (unlikely(Rc) != 0) {\n\n        /* Update Rc0 */\n\n        gen_set_Rc0(ctx);\n\n    }\n\n}\n", "idx": 22383}
{"project": "qemu", "commit_id": "2958620f67dcfd11476e62b4ca704dae0b978ea3", "target": 1, "func": "uint64_t helper_subqv (uint64_t op1, uint64_t op2)\n\n{\n\n    uint64_t res;\n\n    res = op1 - op2;\n\n    if (unlikely((op1 ^ op2) & (res ^ op1) & (1ULL << 63))) {\n\n        arith_excp(env, GETPC(), EXC_M_IOV, 0);\n\n    }\n\n    return res;\n\n}\n", "idx": 22384}
{"project": "qemu", "commit_id": "111049a4ecefc9cf1ac75c773f4c5c165f27fe63", "target": 1, "func": "static void drive_backup_prepare(BlkActionState *common, Error **errp)\n\n{\n\n    DriveBackupState *state = DO_UPCAST(DriveBackupState, common, common);\n\n    BlockDriverState *bs;\n\n    DriveBackup *backup;\n\n    Error *local_err = NULL;\n\n\n\n    assert(common->action->type == TRANSACTION_ACTION_KIND_DRIVE_BACKUP);\n\n    backup = common->action->u.drive_backup.data;\n\n\n\n    bs = qmp_get_root_bs(backup->device, errp);\n\n    if (!bs) {\n\n        return;\n\n    }\n\n\n\n    /* AioContext is released in .clean() */\n\n    state->aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(state->aio_context);\n\n    bdrv_drained_begin(bs);\n\n    state->bs = bs;\n\n\n\n    do_drive_backup(backup, common->block_job_txn, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    state->job = state->bs->job;\n\n}\n", "idx": 22387}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "static inline void RET_STOP (DisasContext *ctx)\n\n{\n\n    gen_op_update_nip((ctx)->nip);\n\n    ctx->exception = EXCP_MTMSR;\n\n}\n", "idx": 22389}
{"project": "qemu", "commit_id": "ef29a70d18c2d551cf4bb74b8aa9638caac3391b", "target": 0, "func": "static int cris_mmu_translate_page(struct cris_mmu_result_t *res,\n\n\t\t\t\t   CPUState *env, uint32_t vaddr,\n\n\t\t\t\t   int rw, int usermode)\n\n{\n\n\tunsigned int vpage;\n\n\tunsigned int idx;\n\n\tuint32_t lo, hi;\n\n\tuint32_t tlb_vpn, tlb_pfn = 0;\n\n\tint tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;\n\n\tint cfg_v, cfg_k, cfg_w, cfg_x;\t\n\n\tint set, match = 0;\n\n\tuint32_t r_cause;\n\n\tuint32_t r_cfg;\n\n\tint rwcause;\n\n\tint mmu = 1; /* Data mmu is default.  */\n\n\tint vect_base;\n\n\n\n\tr_cause = env->sregs[SFR_R_MM_CAUSE];\n\n\tr_cfg = env->sregs[SFR_RW_MM_CFG];\n\n\n\n\tswitch (rw) {\n\n\t\tcase 2: rwcause = CRIS_MMU_ERR_EXEC; mmu = 0; break;\n\n\t\tcase 1: rwcause = CRIS_MMU_ERR_WRITE; break;\n\n\t\tdefault:\n\n\t\tcase 0: rwcause = CRIS_MMU_ERR_READ; break;\n\n\t}\n\n\n\n\t/* I exception vectors 4 - 7, D 8 - 11.  */\n\n\tvect_base = (mmu + 1) * 4;\n\n\n\n\tvpage = vaddr >> 13;\n\n\n\n\t/* We know the index which to check on each set.\n\n\t   Scan both I and D.  */\n\n#if 0\n\n\tfor (set = 0; set < 4; set++) {\n\n\t\tfor (idx = 0; idx < 16; idx++) {\n\n\t\t\tlo = env->tlbsets[mmu][set][idx].lo;\n\n\t\t\thi = env->tlbsets[mmu][set][idx].hi;\n\n\t\t\ttlb_vpn = EXTRACT_FIELD(hi, 13, 31);\n\n\t\t\ttlb_pfn = EXTRACT_FIELD(lo, 13, 31);\n\n\n\n\t\t\tprintf (\"TLB: [%d][%d] hi=%x lo=%x v=%x p=%x\\n\", \n\n\t\t\t\t\tset, idx, hi, lo, tlb_vpn, tlb_pfn);\n\n\t\t}\n\n\t}\n\n#endif\n\n\n\n\tidx = vpage & 15;\n\n\tfor (set = 0; set < 4; set++)\n\n\t{\n\n\t\tlo = env->tlbsets[mmu][set][idx].lo;\n\n\t\thi = env->tlbsets[mmu][set][idx].hi;\n\n\n\n\t\ttlb_vpn = EXTRACT_FIELD(hi, 13, 31);\n\n\t\ttlb_pfn = EXTRACT_FIELD(lo, 13, 31);\n\n\n\n\t\tD(printf(\"TLB[%d][%d] v=%x vpage=%x -> pfn=%x lo=%x hi=%x\\n\", \n\n\t\t\t\ti, idx, tlb_vpn, vpage, tlb_pfn, lo, hi));\n\n\t\tif (tlb_vpn == vpage) {\n\n\t\t\tmatch = 1;\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\n\n\tres->bf_vec = vect_base;\n\n\tif (match) {\n\n\t\tcfg_w  = EXTRACT_FIELD(r_cfg, 19, 19);\n\n\t\tcfg_k  = EXTRACT_FIELD(r_cfg, 18, 18);\n\n\t\tcfg_x  = EXTRACT_FIELD(r_cfg, 17, 17);\n\n\t\tcfg_v  = EXTRACT_FIELD(r_cfg, 16, 16);\n\n\n\n\t\ttlb_pid = EXTRACT_FIELD(hi, 0, 7);\n\n\t\ttlb_pfn = EXTRACT_FIELD(lo, 13, 31);\n\n\t\ttlb_g  = EXTRACT_FIELD(lo, 4, 4);\n\n\t\ttlb_v = EXTRACT_FIELD(lo, 3, 3);\n\n\t\ttlb_k = EXTRACT_FIELD(lo, 2, 2);\n\n\t\ttlb_w = EXTRACT_FIELD(lo, 1, 1);\n\n\t\ttlb_x = EXTRACT_FIELD(lo, 0, 0);\n\n\n\n\t\t/*\n\n\t\tset_exception_vector(0x04, i_mmu_refill);\n\n\t\tset_exception_vector(0x05, i_mmu_invalid);\n\n\t\tset_exception_vector(0x06, i_mmu_access);\n\n\t\tset_exception_vector(0x07, i_mmu_execute);\n\n\t\tset_exception_vector(0x08, d_mmu_refill);\n\n\t\tset_exception_vector(0x09, d_mmu_invalid);\n\n\t\tset_exception_vector(0x0a, d_mmu_access);\n\n\t\tset_exception_vector(0x0b, d_mmu_write);\n\n\t\t*/\n\n\t\tif (!tlb_g \n\n\t\t    && tlb_pid != (env->pregs[PR_PID] & 0xff)) {\n\n\t\t\tD(printf (\"tlb: wrong pid %x %x pc=%x\\n\", \n\n\t\t\t\t tlb_pid, env->pregs[PR_PID], env->pc));\n\n\t\t\tmatch = 0;\n\n\t\t\tres->bf_vec = vect_base;\n\n\t\t} else if (rw == 1 && cfg_w && !tlb_w) {\n\n\t\t\tD(printf (\"tlb: write protected %x lo=%x\\n\", \n\n\t\t\t\tvaddr, lo));\n\n\t\t\tmatch = 0;\n\n\t\t\tres->bf_vec = vect_base + 3;\n\n\t\t} else if (cfg_v && !tlb_v) {\n\n\t\t\tD(printf (\"tlb: invalid %x\\n\", vaddr));\n\n\t\t\tset_field(&r_cause, rwcause, 8, 9);\n\n\t\t\tmatch = 0;\n\n\t\t\tres->bf_vec = vect_base + 1;\n\n\t\t}\n\n\n\n\t\tres->prot = 0;\n\n\t\tif (match) {\n\n\t\t\tres->prot |= PAGE_READ;\n\n\t\t\tif (tlb_w)\n\n\t\t\t\tres->prot |= PAGE_WRITE;\n\n\t\t\tif (tlb_x)\n\n\t\t\t\tres->prot |= PAGE_EXEC;\n\n\t\t}\n\n\t\telse\n\n\t\t\tD(dump_tlb(env, mmu));\n\n\n\n\t\tenv->sregs[SFR_RW_MM_TLB_HI] = hi;\n\n\t\tenv->sregs[SFR_RW_MM_TLB_LO] = lo;\n\n\t}\n\n\n\n\tif (!match) {\n\n\t\t/* miss.  */\n\n\t\tidx = vpage & 15;\n\n\t\tset = 0;\n\n\n\n\t\t/* Update RW_MM_TLB_SEL.  */\n\n\t\tenv->sregs[SFR_RW_MM_TLB_SEL] = 0;\n\n\t\tset_field(&env->sregs[SFR_RW_MM_TLB_SEL], idx, 0, 4);\n\n\t\tset_field(&env->sregs[SFR_RW_MM_TLB_SEL], set, 4, 5);\n\n\n\n\t\t/* Update RW_MM_CAUSE.  */\n\n\t\tset_field(&r_cause, rwcause, 8, 2);\n\n\t\tset_field(&r_cause, vpage, 13, 19);\n\n\t\tset_field(&r_cause, env->pregs[PR_PID], 0, 8);\n\n\t\tenv->sregs[SFR_R_MM_CAUSE] = r_cause;\n\n\t\tD(printf(\"refill vaddr=%x pc=%x\\n\", vaddr, env->pc));\n\n\t}\n\n\n\n\n\n\tD(printf (\"%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x\"\n\n\t\t  \" %x cause=%x sel=%x sp=%x %x %x\\n\",\n\n\t\t  __func__, rw, match, env->pc,\n\n\t\t  vaddr, vpage,\n\n\t\t  tlb_vpn, tlb_pfn, tlb_pid, \n\n\t\t  env->pregs[PR_PID],\n\n\t\t  r_cause,\n\n\t\t  env->sregs[SFR_RW_MM_TLB_SEL],\n\n\t\t  env->regs[R_SP], env->pregs[PR_USP], env->ksp));\n\n\n\n\tres->pfn = tlb_pfn;\n\n\treturn !match;\n\n}\n", "idx": 22397}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int proxy_chmod(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)\n\n{\n\n    int retval;\n\n    retval = v9fs_request(fs_ctx->private, T_CHMOD, NULL, \"sd\",\n\n                          fs_path, credp->fc_mode);\n\n    if (retval < 0) {\n\n        errno = -retval;\n\n    }\n\n    return retval;\n\n}\n", "idx": 22398}
{"project": "qemu", "commit_id": "91cda45b69e45a089f9989979a65db3f710c9925", "target": 0, "func": "static int get_segment64(CPUPPCState *env, struct mmu_ctx_hash64 *ctx,\n\n                         target_ulong eaddr, int rw, int type)\n\n{\n\n    hwaddr hash;\n\n    target_ulong vsid;\n\n    int pr, target_page_bits;\n\n    int ret, ret2;\n\n\n\n    pr = msr_pr;\n\n    ctx->eaddr = eaddr;\n\n    ppc_slb_t *slb;\n\n    target_ulong pageaddr;\n\n    int segment_bits;\n\n\n\n    LOG_MMU(\"Check SLBs\\n\");\n\n    slb = slb_lookup(env, eaddr);\n\n    if (!slb) {\n\n        return -5;\n\n    }\n\n\n\n    if (slb->vsid & SLB_VSID_B) {\n\n        vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT_1T;\n\n        segment_bits = 40;\n\n    } else {\n\n        vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT;\n\n        segment_bits = 28;\n\n    }\n\n\n\n    target_page_bits = (slb->vsid & SLB_VSID_L)\n\n        ? TARGET_PAGE_BITS_16M : TARGET_PAGE_BITS;\n\n    ctx->key = !!(pr ? (slb->vsid & SLB_VSID_KP)\n\n                  : (slb->vsid & SLB_VSID_KS));\n\n    ctx->nx = !!(slb->vsid & SLB_VSID_N);\n\n\n\n    pageaddr = eaddr & ((1ULL << segment_bits)\n\n                            - (1ULL << target_page_bits));\n\n    if (slb->vsid & SLB_VSID_B) {\n\n        hash = vsid ^ (vsid << 25) ^ (pageaddr >> target_page_bits);\n\n    } else {\n\n        hash = vsid ^ (pageaddr >> target_page_bits);\n\n    }\n\n    /* Only 5 bits of the page index are used in the AVPN */\n\n    ctx->ptem = (slb->vsid & SLB_VSID_PTEM) |\n\n        ((pageaddr >> 16) & ((1ULL << segment_bits) - 0x80));\n\n\n\n    LOG_MMU(\"pte segment: key=%d nx %d vsid \" TARGET_FMT_lx \"\\n\",\n\n            ctx->key, ctx->nx, vsid);\n\n    ret = -1;\n\n\n\n    /* Check if instruction fetch is allowed, if needed */\n\n    if (type != ACCESS_CODE || ctx->nx == 0) {\n\n        /* Page address translation */\n\n        LOG_MMU(\"htab_base \" TARGET_FMT_plx \" htab_mask \" TARGET_FMT_plx\n\n                \" hash \" TARGET_FMT_plx \"\\n\",\n\n                env->htab_base, env->htab_mask, hash);\n\n        ctx->hash[0] = hash;\n\n        ctx->hash[1] = ~hash;\n\n\n\n        /* Initialize real address with an invalid value */\n\n        ctx->raddr = (hwaddr)-1ULL;\n\n        LOG_MMU(\"0 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n                \" vsid=\" TARGET_FMT_lx \" ptem=\" TARGET_FMT_lx\n\n                \" hash=\" TARGET_FMT_plx \"\\n\",\n\n                env->htab_base, env->htab_mask, vsid, ctx->ptem,\n\n                ctx->hash[0]);\n\n        /* Primary table lookup */\n\n        ret = find_pte64(env, ctx, 0, rw, type, target_page_bits);\n\n        if (ret < 0) {\n\n            /* Secondary table lookup */\n\n            LOG_MMU(\"1 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n                    \" vsid=\" TARGET_FMT_lx \" api=\" TARGET_FMT_lx\n\n                    \" hash=\" TARGET_FMT_plx \"\\n\", env->htab_base,\n\n                    env->htab_mask, vsid, ctx->ptem, ctx->hash[1]);\n\n            ret2 = find_pte64(env, ctx, 1, rw, type, target_page_bits);\n\n            if (ret2 != -1) {\n\n                ret = ret2;\n\n            }\n\n        }\n\n    } else {\n\n        LOG_MMU(\"No access allowed\\n\");\n\n        ret = -3;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 22399}
{"project": "qemu", "commit_id": "621ff94d5074d88253a5818c6b9c4db718fbfc65", "target": 0, "func": "void qmp_blockdev_mirror(const char *device, const char *target,\n\n                         bool has_replaces, const char *replaces,\n\n                         MirrorSyncMode sync,\n\n                         bool has_speed, int64_t speed,\n\n                         bool has_granularity, uint32_t granularity,\n\n                         bool has_buf_size, int64_t buf_size,\n\n                         bool has_on_source_error,\n\n                         BlockdevOnError on_source_error,\n\n                         bool has_on_target_error,\n\n                         BlockdevOnError on_target_error,\n\n                         Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockBackend *blk;\n\n    BlockDriverState *target_bs;\n\n    AioContext *aio_context;\n\n    BlockMirrorBackingMode backing_mode = MIRROR_LEAVE_BACKING_CHAIN;\n\n    Error *local_err = NULL;\n\n\n\n    blk = blk_by_name(device);\n\n    if (!blk) {\n\n        error_setg(errp, \"Device '%s' not found\", device);\n\n        return;\n\n    }\n\n    bs = blk_bs(blk);\n\n\n\n    if (!bs) {\n\n        error_setg(errp, \"Device '%s' has no media\", device);\n\n        return;\n\n    }\n\n\n\n    target_bs = bdrv_lookup_bs(target, target, errp);\n\n    if (!target_bs) {\n\n        return;\n\n    }\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n\n\n    bdrv_set_aio_context(target_bs, aio_context);\n\n\n\n    blockdev_mirror_common(bs, target_bs,\n\n                           has_replaces, replaces, sync, backing_mode,\n\n                           has_speed, speed,\n\n                           has_granularity, granularity,\n\n                           has_buf_size, buf_size,\n\n                           has_on_source_error, on_source_error,\n\n                           has_on_target_error, on_target_error,\n\n                           true, true,\n\n                           &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n    }\n\n\n\n    aio_context_release(aio_context);\n\n}\n", "idx": 22400}
{"project": "qemu", "commit_id": "46232aaacb66733d3e16dcbd0d26c32ec388801d", "target": 0, "func": "static X86CPU *pc_new_cpu(const char *cpu_model, int64_t apic_id,\n\n                          DeviceState *icc_bridge, Error **errp)\n\n{\n\n    X86CPU *cpu = NULL;\n\n    Error *local_err = NULL;\n\n\n\n    if (icc_bridge == NULL) {\n\n        error_setg(&local_err, \"Invalid icc-bridge value\");\n\n        goto out;\n\n    }\n\n\n\n    cpu = cpu_x86_create(cpu_model, &local_err);\n\n    if (local_err != NULL) {\n\n        goto out;\n\n    }\n\n\n\n    qdev_set_parent_bus(DEVICE(cpu), qdev_get_child_bus(icc_bridge, \"icc\"));\n\n\n\n    object_property_set_int(OBJECT(cpu), apic_id, \"apic-id\", &local_err);\n\n    object_property_set_bool(OBJECT(cpu), true, \"realized\", &local_err);\n\n\n\nout:\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        object_unref(OBJECT(cpu));\n\n        cpu = NULL;\n\n    }\n\n    return cpu;\n\n}\n", "idx": 22401}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t lsi_ram_read(void *opaque, target_phys_addr_t addr,\n\n                             unsigned size)\n\n{\n\n    LSIState *s = opaque;\n\n    uint32_t val;\n\n    uint32_t mask;\n\n\n\n    val = s->script_ram[addr >> 2];\n\n    mask = ((uint64_t)1 << (size * 8)) - 1;\n\n    val >>= (addr & 3) * 8;\n\n    return val & mask;\n\n}\n", "idx": 22402}
{"project": "qemu", "commit_id": "d9f62dde1303286b24ac8ce88be27e2b9b9c5f46", "target": 0, "func": "void visit_start_list(Visitor *v, const char *name, Error **errp)\n\n{\n\n    v->start_list(v, name, errp);\n\n}\n", "idx": 22403}
{"project": "qemu", "commit_id": "5b956f415a356449a4171d5e0c7d9a25bbc84b5a", "target": 0, "func": "static void scsi_write_same_complete(void *opaque, int ret)\n\n{\n\n    WriteSameCBData *data = opaque;\n\n    SCSIDiskReq *r = data->r;\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n\n\n    assert(r->req.aiocb != NULL);\n\n    r->req.aiocb = NULL;\n\n    if (r->req.io_canceled) {\n\n        scsi_req_cancel_complete(&r->req);\n\n        goto done;\n\n    }\n\n\n\n    if (ret < 0) {\n\n        if (scsi_handle_rw_error(r, -ret, true)) {\n\n            goto done;\n\n        }\n\n    }\n\n\n\n    block_acct_done(blk_get_stats(s->qdev.conf.blk), &r->acct);\n\n\n\n    data->nb_sectors -= data->iov.iov_len / 512;\n\n    data->sector += data->iov.iov_len / 512;\n\n    data->iov.iov_len = MIN(data->nb_sectors * 512, data->iov.iov_len);\n\n    if (data->iov.iov_len) {\n\n        block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct,\n\n                         data->iov.iov_len, BLOCK_ACCT_WRITE);\n\n        /* Reinitialize qiov, to handle unaligned WRITE SAME request\n\n         * where final qiov may need smaller size */\n\n        qemu_iovec_init_external(&data->qiov, &data->iov, 1);\n\n        r->req.aiocb = blk_aio_pwritev(s->qdev.conf.blk,\n\n                                       data->sector << BDRV_SECTOR_BITS,\n\n                                       &data->qiov, 0,\n\n                                       scsi_write_same_complete, data);\n\n        return;\n\n    }\n\n\n\n    scsi_req_complete(&r->req, GOOD);\n\n\n\ndone:\n\n    scsi_req_unref(&r->req);\n\n    qemu_vfree(data->iov.iov_base);\n\n    g_free(data);\n\n}\n", "idx": 22404}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static inline void gen_op_evslw(TCGv_i32 ret, TCGv_i32 arg1, TCGv_i32 arg2)\n\n{\n\n    TCGv_i32 t0;\n\n    int l1, l2;\n\n\n\n    l1 = gen_new_label();\n\n    l2 = gen_new_label();\n\n    t0 = tcg_temp_local_new_i32();\n\n    /* No error here: 6 bits are used */\n\n    tcg_gen_andi_i32(t0, arg2, 0x3F);\n\n    tcg_gen_brcondi_i32(TCG_COND_GE, t0, 32, l1);\n\n    tcg_gen_shl_i32(ret, arg1, t0);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_movi_i32(ret, 0);\n\n    gen_set_label(l2);\n\n    tcg_temp_free_i32(t0);\n\n}\n", "idx": 22406}
{"project": "qemu", "commit_id": "27a69bb088bee6d4efea254659422fb9c751b3c7", "target": 0, "func": "static inline void gen_efsabs(DisasContext *ctx)\n\n{\n\n    if (unlikely(!ctx->spe_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_APU);\n\n        return;\n\n    }\n\n    tcg_gen_andi_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], (target_long)~0x80000000LL);\n\n}\n", "idx": 22407}
{"project": "qemu", "commit_id": "ba5e6bfa1aee29a8f72c5538c565dfb9889cf273", "target": 0, "func": "static void vfio_exitfn(PCIDevice *pdev)\n\n{\n\n    VFIOPCIDevice *vdev = DO_UPCAST(VFIOPCIDevice, pdev, pdev);\n\n\n\n    vfio_unregister_err_notifier(vdev);\n\n    pci_device_set_intx_routing_notifier(&vdev->pdev, NULL);\n\n    vfio_disable_interrupts(vdev);\n\n    if (vdev->intx.mmap_timer) {\n\n        timer_free(vdev->intx.mmap_timer);\n\n    }\n\n    vfio_teardown_msi(vdev);\n\n    vfio_unmap_bars(vdev);\n\n}\n", "idx": 22408}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t vgafb_read(void *opaque, target_phys_addr_t addr,\n\n                           unsigned size)\n\n{\n\n    MilkymistVgafbState *s = opaque;\n\n    uint32_t r = 0;\n\n\n\n    addr >>= 2;\n\n    switch (addr) {\n\n    case R_CTRL:\n\n    case R_HRES:\n\n    case R_HSYNC_START:\n\n    case R_HSYNC_END:\n\n    case R_HSCAN:\n\n    case R_VRES:\n\n    case R_VSYNC_START:\n\n    case R_VSYNC_END:\n\n    case R_VSCAN:\n\n    case R_BASEADDRESS:\n\n    case R_BURST_COUNT:\n\n    case R_DDC:\n\n    case R_SOURCE_CLOCK:\n\n        r = s->regs[addr];\n\n    break;\n\n    case R_BASEADDRESS_ACT:\n\n        r = s->regs[R_BASEADDRESS];\n\n    break;\n\n\n\n    default:\n\n        error_report(\"milkymist_vgafb: read access to unknown register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    }\n\n\n\n    trace_milkymist_vgafb_memory_read(addr << 2, r);\n\n\n\n    return r;\n\n}\n", "idx": 22409}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "func": "static int local_open2(FsContext *fs_ctx, V9fsPath *dir_path, const char *name,\n\n                       int flags, FsCred *credp, V9fsFidOpenState *fs)\n\n{\n\n    char *path;\n\n    int fd = -1;\n\n    int err = -1;\n\n    int serrno = 0;\n\n    V9fsString fullname;\n\n    char buffer[PATH_MAX];\n\n\n\n    /*\n\n     * Mark all the open to not follow symlinks\n\n     */\n\n    flags |= O_NOFOLLOW;\n\n\n\n    v9fs_string_init(&fullname);\n\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);\n\n    path = fullname.data;\n\n\n\n    /* Determine the security model */\n\n    if (fs_ctx->export_flags & V9FS_SM_MAPPED) {\n\n        fd = open(rpath(fs_ctx, path, buffer), flags, SM_LOCAL_MODE_BITS);\n\n        if (fd == -1) {\n\n            err = fd;\n\n            goto out;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFREG;\n\n        /* Set cleint credentials in xattr */\n\n        err = local_set_xattr(rpath(fs_ctx, path, buffer), credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n\n        fd = open(rpath(fs_ctx, path, buffer), flags, SM_LOCAL_MODE_BITS);\n\n        if (fd == -1) {\n\n            err = fd;\n\n            goto out;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFREG;\n\n        /* Set client credentials in .virtfs_metadata directory files */\n\n        err = local_set_mapped_file_attr(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if ((fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||\n\n               (fs_ctx->export_flags & V9FS_SM_NONE)) {\n\n        fd = open(rpath(fs_ctx, path, buffer), flags, credp->fc_mode);\n\n        if (fd == -1) {\n\n            err = fd;\n\n            goto out;\n\n        }\n\n        err = local_post_create_passthrough(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    }\n\n    err = fd;\n\n    fs->fd = fd;\n\n    goto out;\n\n\n\nerr_end:\n\n    close(fd);\n\n    remove(rpath(fs_ctx, path, buffer));\n\n    errno = serrno;\n\nout:\n\n    v9fs_string_free(&fullname);\n\n    return err;\n\n}\n", "idx": 22410}
{"project": "qemu", "commit_id": "b6d36def6d9e9fd187327182d0abafc9b7085d8f", "target": 0, "func": "static int realloc_refcount_array(BDRVQcow2State *s, void **array,\n\n                                  int64_t *size, int64_t new_size)\n\n{\n\n    size_t old_byte_size, new_byte_size;\n\n    void *new_ptr;\n\n\n\n    /* Round to clusters so the array can be directly written to disk */\n\n    old_byte_size = size_to_clusters(s, refcount_array_byte_size(s, *size))\n\n                    * s->cluster_size;\n\n    new_byte_size = size_to_clusters(s, refcount_array_byte_size(s, new_size))\n\n                    * s->cluster_size;\n\n\n\n    if (new_byte_size == old_byte_size) {\n\n        *size = new_size;\n\n        return 0;\n\n    }\n\n\n\n    assert(new_byte_size > 0);\n\n\n\n    new_ptr = g_try_realloc(*array, new_byte_size);\n\n    if (!new_ptr) {\n\n        return -ENOMEM;\n\n    }\n\n\n\n    if (new_byte_size > old_byte_size) {\n\n        memset((void *)((uintptr_t)new_ptr + old_byte_size), 0,\n\n               new_byte_size - old_byte_size);\n\n    }\n\n\n\n    *array = new_ptr;\n\n    *size  = new_size;\n\n\n\n    return 0;\n\n}\n", "idx": 22411}
{"project": "qemu", "commit_id": "39a7a362e16bb27e98738d63f24d1ab5811e26a8", "target": 0, "func": "Coroutine *qemu_coroutine_new(void)\n\n{\n\n    CoroutineThreadState *s = coroutine_get_thread_state();\n\n    Coroutine *co;\n\n\n\n    co = QLIST_FIRST(&s->pool);\n\n    if (co) {\n\n        QLIST_REMOVE(co, pool_next);\n\n        s->pool_size--;\n\n    } else {\n\n        co = coroutine_new();\n\n    }\n\n    return co;\n\n}\n", "idx": 22412}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int v9fs_receivefd(int sockfd, int *status)\n\n{\n\n    struct iovec iov;\n\n    struct msghdr msg;\n\n    struct cmsghdr *cmsg;\n\n    int retval, data, fd;\n\n    union MsgControl msg_control;\n\n\n\n    iov.iov_base = &data;\n\n    iov.iov_len = sizeof(data);\n\n\n\n    memset(&msg, 0, sizeof(msg));\n\n    msg.msg_iov = &iov;\n\n    msg.msg_iovlen = 1;\n\n    msg.msg_control = &msg_control;\n\n    msg.msg_controllen = sizeof(msg_control);\n\n\n\n    do {\n\n        retval = recvmsg(sockfd, &msg, 0);\n\n    } while (retval < 0 && errno == EINTR);\n\n    if (retval <= 0) {\n\n        return retval;\n\n    }\n\n    /*\n\n     * data is set to V9FS_FD_VALID, if ancillary data is sent.  If this\n\n     * request doesn't need ancillary data (fd) or an error occurred,\n\n     * data is set to negative errno value.\n\n     */\n\n    if (data != V9FS_FD_VALID) {\n\n        *status = data;\n\n        return 0;\n\n    }\n\n    /*\n\n     * File descriptor (fd) is sent in the ancillary data. Check if we\n\n     * indeed received it. One of the reasons to fail to receive it is if\n\n     * we exceeded the maximum number of file descriptors!\n\n     */\n\n    for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n\n        if (cmsg->cmsg_len != CMSG_LEN(sizeof(int)) ||\n\n            cmsg->cmsg_level != SOL_SOCKET ||\n\n            cmsg->cmsg_type != SCM_RIGHTS) {\n\n            continue;\n\n        }\n\n        fd = *((int *)CMSG_DATA(cmsg));\n\n        *status = fd;\n\n        return 0;\n\n    }\n\n    *status = -ENFILE;  /* Ancillary data sent but not received */\n\n    return 0;\n\n}\n", "idx": 22413}
{"project": "qemu", "commit_id": "0fdddf80a88ac2efe068990d1878f472bb6b95d9", "target": 0, "func": "static uint64_t qemu_next_deadline_dyntick(void)\n\n{\n\n    int64_t delta;\n\n    int64_t rtdelta;\n\n\n\n    if (use_icount)\n\n        delta = INT32_MAX;\n\n    else\n\n        delta = (qemu_next_deadline() + 999) / 1000;\n\n\n\n    if (active_timers[QEMU_TIMER_REALTIME]) {\n\n        rtdelta = (active_timers[QEMU_TIMER_REALTIME]->expire_time -\n\n                 qemu_get_clock(rt_clock))*1000;\n\n        if (rtdelta < delta)\n\n            delta = rtdelta;\n\n    }\n\n\n\n    if (delta < MIN_TIMER_REARM_US)\n\n        delta = MIN_TIMER_REARM_US;\n\n\n\n    return delta;\n\n}\n", "idx": 22414}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static void vnc_write_s32(VncState *vs, int32_t value)\n\n{\n\n    vnc_write_u32(vs, *(uint32_t *)&value);\n\n}\n", "idx": 22415}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,\n\n                                  int flag)\n\n{\n\n    struct kvm_x86_mce_data data = {\n\n        .env = env,\n\n        .mce = mce,\n\n        .abort_on_error = (flag & ABORT_ON_ERROR),\n\n    };\n\n\n\n    if (!env->mcg_cap) {\n\n        fprintf(stderr, \"MCE support is not enabled!\\n\");\n\n        return;\n\n    }\n\n\n\n    run_on_cpu(env, kvm_do_inject_x86_mce, &data);\n\n}\n", "idx": 22417}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static AioHandler *find_aio_handler(AioContext *ctx, int fd)\n\n{\n\n    AioHandler *node;\n\n\n\n    QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n        if (node->pfd.fd == fd)\n\n            if (!node->deleted)\n\n                return node;\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 22418}
{"project": "qemu", "commit_id": "554c97dd43e021b626c78ed5bd72bca33d5cb99c", "target": 0, "func": "static uint32_t virtio_net_get_features(VirtIODevice *vdev)\n\n{\n\n    uint32_t features = (1 << VIRTIO_NET_F_MAC);\n\n\n\n    return features;\n\n}\n", "idx": 22419}
{"project": "qemu", "commit_id": "f8b6cc0070aab8b75bd082582c829be1353f395f", "target": 0, "func": "static void s390_init(ram_addr_t ram_size,\n\n                      const char *boot_device,\n\n                      const char *kernel_filename,\n\n                      const char *kernel_cmdline,\n\n                      const char *initrd_filename,\n\n                      const char *cpu_model)\n\n{\n\n    CPUState *env = NULL;\n\n    ram_addr_t ram_addr;\n\n    ram_addr_t kernel_size = 0;\n\n    ram_addr_t initrd_offset;\n\n    ram_addr_t initrd_size = 0;\n\n    int i;\n\n\n\n    /* XXX we only work on KVM for now */\n\n\n\n    if (!kvm_enabled()) {\n\n        fprintf(stderr, \"The S390 target only works with KVM enabled\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* get a BUS */\n\n    s390_bus = s390_virtio_bus_init(&ram_size);\n\n\n\n    /* allocate RAM */\n\n    ram_addr = qemu_ram_alloc(ram_size);\n\n    cpu_register_physical_memory(0, ram_size, ram_addr);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"host\";\n\n    }\n\n\n\n    ipi_states = qemu_malloc(sizeof(CPUState *) * smp_cpus);\n\n\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        CPUState *tmp_env;\n\n\n\n        tmp_env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            env = tmp_env;\n\n        }\n\n        ipi_states[i] = tmp_env;\n\n        tmp_env->halted = 1;\n\n        tmp_env->exception_index = EXCP_HLT;\n\n    }\n\n\n\n    env->halted = 0;\n\n    env->exception_index = 0;\n\n\n\n    if (kernel_filename) {\n\n        kernel_size = load_image(kernel_filename, qemu_get_ram_ptr(0));\n\n\n\n        if (lduw_phys(KERN_IMAGE_START) != 0x0dd0) {\n\n            fprintf(stderr, \"Specified image is not an s390 boot image\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        env->psw.addr = KERN_IMAGE_START;\n\n        env->psw.mask = 0x0000000180000000ULL;\n\n    } else {\n\n        ram_addr_t bios_size = 0;\n\n        char *bios_filename;\n\n\n\n        /* Load zipl bootloader */\n\n        if (bios_name == NULL) {\n\n            bios_name = ZIPL_FILENAME;\n\n        }\n\n\n\n        bios_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n        bios_size = load_image(bios_filename, qemu_get_ram_ptr(ZIPL_LOAD_ADDR));\n\n\n\n        if ((long)bios_size < 0) {\n\n            hw_error(\"could not load bootloader '%s'\\n\", bios_name);\n\n        }\n\n\n\n        if (bios_size > 4096) {\n\n            hw_error(\"stage1 bootloader is > 4k\\n\");\n\n        }\n\n\n\n        env->psw.addr = ZIPL_START;\n\n        env->psw.mask = 0x0000000180000000ULL;\n\n    }\n\n\n\n    if (initrd_filename) {\n\n        initrd_offset = INITRD_START;\n\n        while (kernel_size + 0x100000 > initrd_offset) {\n\n            initrd_offset += 0x100000;\n\n        }\n\n        initrd_size = load_image(initrd_filename, qemu_get_ram_ptr(initrd_offset));\n\n\n\n        stq_phys(INITRD_PARM_START, initrd_offset);\n\n        stq_phys(INITRD_PARM_SIZE, initrd_size);\n\n    }\n\n\n\n    if (kernel_cmdline) {\n\n        cpu_physical_memory_rw(KERN_PARM_AREA, (uint8_t *)kernel_cmdline,\n\n                               strlen(kernel_cmdline), 1);\n\n    }\n\n\n\n    /* Create VirtIO network adapters */\n\n    for(i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n        DeviceState *dev;\n\n\n\n        if (!nd->model) {\n\n            nd->model = qemu_strdup(\"virtio\");\n\n        }\n\n\n\n        if (strcmp(nd->model, \"virtio\")) {\n\n            fprintf(stderr, \"S390 only supports VirtIO nics\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        dev = qdev_create((BusState *)s390_bus, \"virtio-net-s390\");\n\n        qdev_set_nic_properties(dev, nd);\n\n        qdev_init_nofail(dev);\n\n    }\n\n\n\n    /* Create VirtIO disk drives */\n\n    for(i = 0; i < MAX_BLK_DEVS; i++) {\n\n        DriveInfo *dinfo;\n\n        DeviceState *dev;\n\n\n\n        dinfo = drive_get(IF_IDE, 0, i);\n\n        if (!dinfo) {\n\n            continue;\n\n        }\n\n\n\n        dev = qdev_create((BusState *)s390_bus, \"virtio-blk-s390\");\n\n        qdev_prop_set_drive(dev, \"drive\", dinfo);\n\n        qdev_init_nofail(dev);\n\n    }\n\n}\n", "idx": 22420}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void disas_xtensa_insn(CPUXtensaState *env, DisasContext *dc)\n\n{\n\n#define HAS_OPTION_BITS(opt) do { \\\n\n        if (!option_bits_enabled(dc, opt)) { \\\n\n            qemu_log(\"Option is not enabled %s:%d\\n\", \\\n\n                    __FILE__, __LINE__); \\\n\n            goto invalid_opcode; \\\n\n        } \\\n\n    } while (0)\n\n\n\n#define HAS_OPTION(opt) HAS_OPTION_BITS(XTENSA_OPTION_BIT(opt))\n\n\n\n#define TBD() qemu_log(\"TBD(pc = %08x): %s:%d\\n\", dc->pc, __FILE__, __LINE__)\n\n#define RESERVED() do { \\\n\n        qemu_log(\"RESERVED(pc = %08x, %02x%02x%02x): %s:%d\\n\", \\\n\n                dc->pc, b0, b1, b2, __FILE__, __LINE__); \\\n\n        goto invalid_opcode; \\\n\n    } while (0)\n\n\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define OP0 (((b0) & 0xf0) >> 4)\n\n#define OP1 (((b2) & 0xf0) >> 4)\n\n#define OP2 ((b2) & 0xf)\n\n#define RRR_R ((b1) & 0xf)\n\n#define RRR_S (((b1) & 0xf0) >> 4)\n\n#define RRR_T ((b0) & 0xf)\n\n#else\n\n#define OP0 (((b0) & 0xf))\n\n#define OP1 (((b2) & 0xf))\n\n#define OP2 (((b2) & 0xf0) >> 4)\n\n#define RRR_R (((b1) & 0xf0) >> 4)\n\n#define RRR_S (((b1) & 0xf))\n\n#define RRR_T (((b0) & 0xf0) >> 4)\n\n#endif\n\n#define RRR_X ((RRR_R & 0x4) >> 2)\n\n#define RRR_Y ((RRR_T & 0x4) >> 2)\n\n#define RRR_W (RRR_R & 0x3)\n\n\n\n#define RRRN_R RRR_R\n\n#define RRRN_S RRR_S\n\n#define RRRN_T RRR_T\n\n\n\n#define RRI4_R RRR_R\n\n#define RRI4_S RRR_S\n\n#define RRI4_T RRR_T\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define RRI4_IMM4 ((b2) & 0xf)\n\n#else\n\n#define RRI4_IMM4 (((b2) & 0xf0) >> 4)\n\n#endif\n\n\n\n#define RRI8_R RRR_R\n\n#define RRI8_S RRR_S\n\n#define RRI8_T RRR_T\n\n#define RRI8_IMM8 (b2)\n\n#define RRI8_IMM8_SE ((((b2) & 0x80) ? 0xffffff00 : 0) | RRI8_IMM8)\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define RI16_IMM16 (((b1) << 8) | (b2))\n\n#else\n\n#define RI16_IMM16 (((b2) << 8) | (b1))\n\n#endif\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define CALL_N (((b0) & 0xc) >> 2)\n\n#define CALL_OFFSET ((((b0) & 0x3) << 16) | ((b1) << 8) | (b2))\n\n#else\n\n#define CALL_N (((b0) & 0x30) >> 4)\n\n#define CALL_OFFSET ((((b0) & 0xc0) >> 6) | ((b1) << 2) | ((b2) << 10))\n\n#endif\n\n#define CALL_OFFSET_SE \\\n\n    (((CALL_OFFSET & 0x20000) ? 0xfffc0000 : 0) | CALL_OFFSET)\n\n\n\n#define CALLX_N CALL_N\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define CALLX_M ((b0) & 0x3)\n\n#else\n\n#define CALLX_M (((b0) & 0xc0) >> 6)\n\n#endif\n\n#define CALLX_S RRR_S\n\n\n\n#define BRI12_M CALLX_M\n\n#define BRI12_S RRR_S\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define BRI12_IMM12 ((((b1) & 0xf) << 8) | (b2))\n\n#else\n\n#define BRI12_IMM12 ((((b1) & 0xf0) >> 4) | ((b2) << 4))\n\n#endif\n\n#define BRI12_IMM12_SE (((BRI12_IMM12 & 0x800) ? 0xfffff000 : 0) | BRI12_IMM12)\n\n\n\n#define BRI8_M BRI12_M\n\n#define BRI8_R RRI8_R\n\n#define BRI8_S RRI8_S\n\n#define BRI8_IMM8 RRI8_IMM8\n\n#define BRI8_IMM8_SE RRI8_IMM8_SE\n\n\n\n#define RSR_SR (b1)\n\n\n\n    uint8_t b0 = cpu_ldub_code(env, dc->pc);\n\n    uint8_t b1 = cpu_ldub_code(env, dc->pc + 1);\n\n    uint8_t b2 = 0;\n\n    unsigned len = xtensa_op0_insn_len(OP0);\n\n\n\n    static const uint32_t B4CONST[] = {\n\n        0xffffffff, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256\n\n    };\n\n\n\n    static const uint32_t B4CONSTU[] = {\n\n        32768, 65536, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256\n\n    };\n\n\n\n    switch (len) {\n\n    case 2:\n\n        HAS_OPTION(XTENSA_OPTION_CODE_DENSITY);\n\n        break;\n\n\n\n    case 3:\n\n        b2 = cpu_ldub_code(env, dc->pc + 2);\n\n        break;\n\n\n\n    default:\n\n        RESERVED();\n\n    }\n\n    dc->next_pc = dc->pc + len;\n\n\n\n    switch (OP0) {\n\n    case 0: /*QRST*/\n\n        switch (OP1) {\n\n        case 0: /*RST0*/\n\n            switch (OP2) {\n\n            case 0: /*ST0*/\n\n                if ((RRR_R & 0xc) == 0x8) {\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                }\n\n\n\n                switch (RRR_R) {\n\n                case 0: /*SNM0*/\n\n                    switch (CALLX_M) {\n\n                    case 0: /*ILL*/\n\n                        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                        break;\n\n\n\n                    case 1: /*reserved*/\n\n                        RESERVED();\n\n                        break;\n\n\n\n                    case 2: /*JR*/\n\n                        switch (CALLX_N) {\n\n                        case 0: /*RET*/\n\n                        case 2: /*JX*/\n\n                            if (gen_window_check1(dc, CALLX_S)) {\n\n                                gen_jump(dc, cpu_R[CALLX_S]);\n\n                            }\n\n                            break;\n\n\n\n                        case 1: /*RETWw*/\n\n                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                            {\n\n                                TCGv_i32 tmp = tcg_const_i32(dc->pc);\n\n                                gen_advance_ccount(dc);\n\n                                gen_helper_retw(tmp, cpu_env, tmp);\n\n                                gen_jump(dc, tmp);\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n\n\n                        case 3: /*reserved*/\n\n                            RESERVED();\n\n                            break;\n\n                        }\n\n                        break;\n\n\n\n                    case 3: /*CALLX*/\n\n                        if (!gen_window_check2(dc, CALLX_S, CALLX_N << 2)) {\n\n                            break;\n\n                        }\n\n                        switch (CALLX_N) {\n\n                        case 0: /*CALLX0*/\n\n                            {\n\n                                TCGv_i32 tmp = tcg_temp_new_i32();\n\n                                tcg_gen_mov_i32(tmp, cpu_R[CALLX_S]);\n\n                                tcg_gen_movi_i32(cpu_R[0], dc->next_pc);\n\n                                gen_jump(dc, tmp);\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n\n\n                        case 1: /*CALLX4w*/\n\n                        case 2: /*CALLX8w*/\n\n                        case 3: /*CALLX12w*/\n\n                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                            {\n\n                                TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                                tcg_gen_mov_i32(tmp, cpu_R[CALLX_S]);\n\n                                gen_callw(dc, CALLX_N, tmp);\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n                        }\n\n                        break;\n\n                    }\n\n                    break;\n\n\n\n                case 1: /*MOVSPw*/\n\n                    HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                    if (gen_window_check2(dc, RRR_T, RRR_S)) {\n\n                        TCGv_i32 pc = tcg_const_i32(dc->pc);\n\n                        gen_advance_ccount(dc);\n\n                        gen_helper_movsp(cpu_env, pc);\n\n                        tcg_gen_mov_i32(cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                        tcg_temp_free(pc);\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*SYNC*/\n\n                    switch (RRR_T) {\n\n                    case 0: /*ISYNC*/\n\n                        break;\n\n\n\n                    case 1: /*RSYNC*/\n\n                        break;\n\n\n\n                    case 2: /*ESYNC*/\n\n                        break;\n\n\n\n                    case 3: /*DSYNC*/\n\n                        break;\n\n\n\n                    case 8: /*EXCW*/\n\n                        HAS_OPTION(XTENSA_OPTION_EXCEPTION);\n\n                        break;\n\n\n\n                    case 12: /*MEMW*/\n\n                        break;\n\n\n\n                    case 13: /*EXTW*/\n\n                        break;\n\n\n\n                    case 15: /*NOP*/\n\n                        break;\n\n\n\n                    default: /*reserved*/\n\n                        RESERVED();\n\n                        break;\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*RFEIx*/\n\n                    switch (RRR_T) {\n\n                    case 0: /*RFETx*/\n\n                        HAS_OPTION(XTENSA_OPTION_EXCEPTION);\n\n                        switch (RRR_S) {\n\n                        case 0: /*RFEx*/\n\n                            if (gen_check_privilege(dc)) {\n\n                                tcg_gen_andi_i32(cpu_SR[PS], cpu_SR[PS], ~PS_EXCM);\n\n                                gen_helper_check_interrupts(cpu_env);\n\n                                gen_jump(dc, cpu_SR[EPC1]);\n\n                            }\n\n                            break;\n\n\n\n                        case 1: /*RFUEx*/\n\n                            RESERVED();\n\n                            break;\n\n\n\n                        case 2: /*RFDEx*/\n\n                            if (gen_check_privilege(dc)) {\n\n                                gen_jump(dc, cpu_SR[\n\n                                         dc->config->ndepc ? DEPC : EPC1]);\n\n                            }\n\n                            break;\n\n\n\n                        case 4: /*RFWOw*/\n\n                        case 5: /*RFWUw*/\n\n                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                            if (gen_check_privilege(dc)) {\n\n                                TCGv_i32 tmp = tcg_const_i32(1);\n\n\n\n                                tcg_gen_andi_i32(\n\n                                        cpu_SR[PS], cpu_SR[PS], ~PS_EXCM);\n\n                                tcg_gen_shl_i32(tmp, tmp, cpu_SR[WINDOW_BASE]);\n\n\n\n                                if (RRR_S == 4) {\n\n                                    tcg_gen_andc_i32(cpu_SR[WINDOW_START],\n\n                                            cpu_SR[WINDOW_START], tmp);\n\n                                } else {\n\n                                    tcg_gen_or_i32(cpu_SR[WINDOW_START],\n\n                                            cpu_SR[WINDOW_START], tmp);\n\n                                }\n\n\n\n                                gen_helper_restore_owb(cpu_env);\n\n                                gen_helper_check_interrupts(cpu_env);\n\n                                gen_jump(dc, cpu_SR[EPC1]);\n\n\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n\n\n                        default: /*reserved*/\n\n                            RESERVED();\n\n                            break;\n\n                        }\n\n                        break;\n\n\n\n                    case 1: /*RFIx*/\n\n                        HAS_OPTION(XTENSA_OPTION_HIGH_PRIORITY_INTERRUPT);\n\n                        if (RRR_S >= 2 && RRR_S <= dc->config->nlevel) {\n\n                            if (gen_check_privilege(dc)) {\n\n                                tcg_gen_mov_i32(cpu_SR[PS],\n\n                                                cpu_SR[EPS2 + RRR_S - 2]);\n\n                                gen_helper_check_interrupts(cpu_env);\n\n                                gen_jump(dc, cpu_SR[EPC1 + RRR_S - 1]);\n\n                            }\n\n                        } else {\n\n                            qemu_log(\"RFI %d is illegal\\n\", RRR_S);\n\n                            gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                        }\n\n                        break;\n\n\n\n                    case 2: /*RFME*/\n\n                        TBD();\n\n                        break;\n\n\n\n                    default: /*reserved*/\n\n                        RESERVED();\n\n                        break;\n\n\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*BREAKx*/\n\n                    HAS_OPTION(XTENSA_OPTION_DEBUG);\n\n                    if (dc->debug) {\n\n                        gen_debug_exception(dc, DEBUGCAUSE_BI);\n\n                    }\n\n                    break;\n\n\n\n                case 5: /*SYSCALLx*/\n\n                    HAS_OPTION(XTENSA_OPTION_EXCEPTION);\n\n                    switch (RRR_S) {\n\n                    case 0: /*SYSCALLx*/\n\n                        gen_exception_cause(dc, SYSCALL_CAUSE);\n\n                        break;\n\n\n\n                    case 1: /*SIMCALL*/\n\n                        if (semihosting_enabled) {\n\n                            if (gen_check_privilege(dc)) {\n\n                                gen_helper_simcall(cpu_env);\n\n                            }\n\n                        } else {\n\n                            qemu_log(\"SIMCALL but semihosting is disabled\\n\");\n\n                            gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                        }\n\n                        break;\n\n\n\n                    default:\n\n                        RESERVED();\n\n                        break;\n\n                    }\n\n                    break;\n\n\n\n                case 6: /*RSILx*/\n\n                    HAS_OPTION(XTENSA_OPTION_INTERRUPT);\n\n                    if (gen_check_privilege(dc) &&\n\n                        gen_window_check1(dc, RRR_T)) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_T], cpu_SR[PS]);\n\n                        tcg_gen_andi_i32(cpu_SR[PS], cpu_SR[PS], ~PS_INTLEVEL);\n\n                        tcg_gen_ori_i32(cpu_SR[PS], cpu_SR[PS], RRR_S);\n\n                        gen_helper_check_interrupts(cpu_env);\n\n                        gen_jumpi_check_loop_end(dc, 0);\n\n                    }\n\n                    break;\n\n\n\n                case 7: /*WAITIx*/\n\n                    HAS_OPTION(XTENSA_OPTION_INTERRUPT);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_waiti(dc, RRR_S);\n\n                    }\n\n                    break;\n\n\n\n                case 8: /*ANY4p*/\n\n                case 9: /*ALL4p*/\n\n                case 10: /*ANY8p*/\n\n                case 11: /*ALL8p*/\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                    {\n\n                        const unsigned shift = (RRR_R & 2) ? 8 : 4;\n\n                        TCGv_i32 mask = tcg_const_i32(\n\n                                ((1 << shift) - 1) << RRR_S);\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                        tcg_gen_and_i32(tmp, cpu_SR[BR], mask);\n\n                        if (RRR_R & 1) { /*ALL*/\n\n                            tcg_gen_addi_i32(tmp, tmp, 1 << RRR_S);\n\n                        } else { /*ANY*/\n\n                            tcg_gen_add_i32(tmp, tmp, mask);\n\n                        }\n\n                        tcg_gen_shri_i32(tmp, tmp, RRR_S + shift);\n\n                        tcg_gen_deposit_i32(cpu_SR[BR], cpu_SR[BR],\n\n                                tmp, RRR_T, 1);\n\n                        tcg_temp_free(mask);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n\n\n                }\n\n                break;\n\n\n\n            case 1: /*AND*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_and_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 2: /*OR*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_or_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 3: /*XOR*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_xor_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 4: /*ST1*/\n\n                switch (RRR_R) {\n\n                case 0: /*SSR*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        gen_right_shift_sar(dc, cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 1: /*SSL*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        gen_left_shift_sar(dc, cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*SSA8L*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], 3);\n\n                        gen_right_shift_sar(dc, tmp);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*SSA8B*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], 3);\n\n                        gen_left_shift_sar(dc, tmp);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*SSAI*/\n\n                    {\n\n                        TCGv_i32 tmp = tcg_const_i32(\n\n                                RRR_S | ((RRR_T & 1) << 4));\n\n                        gen_right_shift_sar(dc, tmp);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 6: /*RER*/\n\n                    TBD();\n\n                    break;\n\n\n\n                case 7: /*WER*/\n\n                    TBD();\n\n                    break;\n\n\n\n                case 8: /*ROTWw*/\n\n                    HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                    if (gen_check_privilege(dc)) {\n\n                        TCGv_i32 tmp = tcg_const_i32(\n\n                                RRR_T | ((RRR_T & 8) ? 0xfffffff0 : 0));\n\n                        gen_helper_rotw(cpu_env, tmp);\n\n                        tcg_temp_free(tmp);\n\n                        /* This can change tb->flags, so exit tb */\n\n                        gen_jumpi_check_loop_end(dc, -1);\n\n                    }\n\n                    break;\n\n\n\n                case 14: /*NSAu*/\n\n                    HAS_OPTION(XTENSA_OPTION_MISC_OP_NSA);\n\n                    if (gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                        gen_helper_nsa(cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 15: /*NSAUu*/\n\n                    HAS_OPTION(XTENSA_OPTION_MISC_OP_NSA);\n\n                    if (gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                        gen_helper_nsau(cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            case 5: /*TLB*/\n\n                HAS_OPTION_BITS(\n\n                        XTENSA_OPTION_BIT(XTENSA_OPTION_MMU) |\n\n                        XTENSA_OPTION_BIT(XTENSA_OPTION_REGION_PROTECTION) |\n\n                        XTENSA_OPTION_BIT(XTENSA_OPTION_REGION_TRANSLATION));\n\n                if (gen_check_privilege(dc) &&\n\n                    gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                    TCGv_i32 dtlb = tcg_const_i32((RRR_R & 8) != 0);\n\n\n\n                    switch (RRR_R & 7) {\n\n                    case 3: /*RITLB0*/ /*RDTLB0*/\n\n                        gen_helper_rtlb0(cpu_R[RRR_T],\n\n                                cpu_env, cpu_R[RRR_S], dtlb);\n\n                        break;\n\n\n\n                    case 4: /*IITLB*/ /*IDTLB*/\n\n                        gen_helper_itlb(cpu_env, cpu_R[RRR_S], dtlb);\n\n                        /* This could change memory mapping, so exit tb */\n\n                        gen_jumpi_check_loop_end(dc, -1);\n\n                        break;\n\n\n\n                    case 5: /*PITLB*/ /*PDTLB*/\n\n                        tcg_gen_movi_i32(cpu_pc, dc->pc);\n\n                        gen_helper_ptlb(cpu_R[RRR_T],\n\n                                cpu_env, cpu_R[RRR_S], dtlb);\n\n                        break;\n\n\n\n                    case 6: /*WITLB*/ /*WDTLB*/\n\n                        gen_helper_wtlb(\n\n                                cpu_env, cpu_R[RRR_T], cpu_R[RRR_S], dtlb);\n\n                        /* This could change memory mapping, so exit tb */\n\n                        gen_jumpi_check_loop_end(dc, -1);\n\n                        break;\n\n\n\n                    case 7: /*RITLB1*/ /*RDTLB1*/\n\n                        gen_helper_rtlb1(cpu_R[RRR_T],\n\n                                cpu_env, cpu_R[RRR_S], dtlb);\n\n                        break;\n\n\n\n                    default:\n\n                        tcg_temp_free(dtlb);\n\n                        RESERVED();\n\n                        break;\n\n                    }\n\n                    tcg_temp_free(dtlb);\n\n                }\n\n                break;\n\n\n\n            case 6: /*RT0*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    break;\n\n                }\n\n                switch (RRR_S) {\n\n                case 0: /*NEG*/\n\n                    tcg_gen_neg_i32(cpu_R[RRR_R], cpu_R[RRR_T]);\n\n                    break;\n\n\n\n                case 1: /*ABS*/\n\n                    {\n\n                        TCGv_i32 zero = tcg_const_i32(0);\n\n                        TCGv_i32 neg = tcg_temp_new_i32();\n\n\n\n                        tcg_gen_neg_i32(neg, cpu_R[RRR_T]);\n\n                        tcg_gen_movcond_i32(TCG_COND_GE, cpu_R[RRR_R],\n\n                                cpu_R[RRR_T], zero, cpu_R[RRR_T], neg);\n\n                        tcg_temp_free(neg);\n\n                        tcg_temp_free(zero);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            case 7: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n\n\n            case 8: /*ADD*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_add_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 9: /*ADD**/\n\n            case 10:\n\n            case 11:\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_shli_i32(tmp, cpu_R[RRR_S], OP2 - 8);\n\n                    tcg_gen_add_i32(cpu_R[RRR_R], tmp, cpu_R[RRR_T]);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 12: /*SUB*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_sub_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 13: /*SUB**/\n\n            case 14:\n\n            case 15:\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_shli_i32(tmp, cpu_R[RRR_S], OP2 - 12);\n\n                    tcg_gen_sub_i32(cpu_R[RRR_R], tmp, cpu_R[RRR_T]);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 1: /*RST1*/\n\n            switch (OP2) {\n\n            case 0: /*SLLI*/\n\n            case 1:\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    tcg_gen_shli_i32(cpu_R[RRR_R], cpu_R[RRR_S],\n\n                                     32 - (RRR_T | ((OP2 & 1) << 4)));\n\n                }\n\n                break;\n\n\n\n            case 2: /*SRAI*/\n\n            case 3:\n\n                if (gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    tcg_gen_sari_i32(cpu_R[RRR_R], cpu_R[RRR_T],\n\n                                     RRR_S | ((OP2 & 1) << 4));\n\n                }\n\n                break;\n\n\n\n            case 4: /*SRLI*/\n\n                if (gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    tcg_gen_shri_i32(cpu_R[RRR_R], cpu_R[RRR_T], RRR_S);\n\n                }\n\n                break;\n\n\n\n            case 6: /*XSR*/\n\n                if (gen_check_sr(dc, RSR_SR, SR_X) &&\n\n                    (RSR_SR < 64 || gen_check_privilege(dc)) &&\n\n                    gen_window_check1(dc, RRR_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                    tcg_gen_mov_i32(tmp, cpu_R[RRR_T]);\n\n                    gen_rsr(dc, cpu_R[RRR_T], RSR_SR);\n\n                    gen_wsr(dc, RSR_SR, tmp);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n                /*\n\n                 * Note: 64 bit ops are used here solely because SAR values\n\n                 * have range 0..63\n\n                 */\n\n#define gen_shift_reg(cmd, reg) do { \\\n\n                    TCGv_i64 tmp = tcg_temp_new_i64(); \\\n\n                    tcg_gen_extu_i32_i64(tmp, reg); \\\n\n                    tcg_gen_##cmd##_i64(v, v, tmp); \\\n\n                    tcg_gen_trunc_i64_i32(cpu_R[RRR_R], v); \\\n\n                    tcg_temp_free_i64(v); \\\n\n                    tcg_temp_free_i64(tmp); \\\n\n                } while (0)\n\n\n\n#define gen_shift(cmd) gen_shift_reg(cmd, cpu_SR[SAR])\n\n\n\n            case 8: /*SRC*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    tcg_gen_concat_i32_i64(v, cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                    gen_shift(shr);\n\n                }\n\n                break;\n\n\n\n            case 9: /*SRL*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    break;\n\n                }\n\n                if (dc->sar_5bit) {\n\n                    tcg_gen_shr_i32(cpu_R[RRR_R], cpu_R[RRR_T], cpu_SR[SAR]);\n\n                } else {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    tcg_gen_extu_i32_i64(v, cpu_R[RRR_T]);\n\n                    gen_shift(shr);\n\n                }\n\n                break;\n\n\n\n            case 10: /*SLL*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    break;\n\n                }\n\n                if (dc->sar_m32_5bit) {\n\n                    tcg_gen_shl_i32(cpu_R[RRR_R], cpu_R[RRR_S], dc->sar_m32);\n\n                } else {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    TCGv_i32 s = tcg_const_i32(32);\n\n                    tcg_gen_sub_i32(s, s, cpu_SR[SAR]);\n\n                    tcg_gen_andi_i32(s, s, 0x3f);\n\n                    tcg_gen_extu_i32_i64(v, cpu_R[RRR_S]);\n\n                    gen_shift_reg(shl, s);\n\n                    tcg_temp_free(s);\n\n                }\n\n                break;\n\n\n\n            case 11: /*SRA*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    break;\n\n                }\n\n                if (dc->sar_5bit) {\n\n                    tcg_gen_sar_i32(cpu_R[RRR_R], cpu_R[RRR_T], cpu_SR[SAR]);\n\n                } else {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    tcg_gen_ext_i32_i64(v, cpu_R[RRR_T]);\n\n                    gen_shift(sar);\n\n                }\n\n                break;\n\n#undef gen_shift\n\n#undef gen_shift_reg\n\n\n\n            case 12: /*MUL16U*/\n\n                HAS_OPTION(XTENSA_OPTION_16_BIT_IMUL);\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 v1 = tcg_temp_new_i32();\n\n                    TCGv_i32 v2 = tcg_temp_new_i32();\n\n                    tcg_gen_ext16u_i32(v1, cpu_R[RRR_S]);\n\n                    tcg_gen_ext16u_i32(v2, cpu_R[RRR_T]);\n\n                    tcg_gen_mul_i32(cpu_R[RRR_R], v1, v2);\n\n                    tcg_temp_free(v2);\n\n                    tcg_temp_free(v1);\n\n                }\n\n                break;\n\n\n\n            case 13: /*MUL16S*/\n\n                HAS_OPTION(XTENSA_OPTION_16_BIT_IMUL);\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 v1 = tcg_temp_new_i32();\n\n                    TCGv_i32 v2 = tcg_temp_new_i32();\n\n                    tcg_gen_ext16s_i32(v1, cpu_R[RRR_S]);\n\n                    tcg_gen_ext16s_i32(v2, cpu_R[RRR_T]);\n\n                    tcg_gen_mul_i32(cpu_R[RRR_R], v1, v2);\n\n                    tcg_temp_free(v2);\n\n                    tcg_temp_free(v1);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 2: /*RST2*/\n\n            if (OP2 >= 8 && !gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                break;\n\n            }\n\n\n\n            if (OP2 >= 12) {\n\n                HAS_OPTION(XTENSA_OPTION_32_BIT_IDIV);\n\n                int label = gen_new_label();\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_T], 0, label);\n\n                gen_exception_cause(dc, INTEGER_DIVIDE_BY_ZERO_CAUSE);\n\n                gen_set_label(label);\n\n            }\n\n\n\n            switch (OP2) {\n\n#define BOOLEAN_LOGIC(fn, r, s, t) \\\n\n                do { \\\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN); \\\n\n                    TCGv_i32 tmp1 = tcg_temp_new_i32(); \\\n\n                    TCGv_i32 tmp2 = tcg_temp_new_i32(); \\\n\n                    \\\n\n                    tcg_gen_shri_i32(tmp1, cpu_SR[BR], s); \\\n\n                    tcg_gen_shri_i32(tmp2, cpu_SR[BR], t); \\\n\n                    tcg_gen_##fn##_i32(tmp1, tmp1, tmp2); \\\n\n                    tcg_gen_deposit_i32(cpu_SR[BR], cpu_SR[BR], tmp1, r, 1); \\\n\n                    tcg_temp_free(tmp1); \\\n\n                    tcg_temp_free(tmp2); \\\n\n                } while (0)\n\n\n\n            case 0: /*ANDBp*/\n\n                BOOLEAN_LOGIC(and, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 1: /*ANDBCp*/\n\n                BOOLEAN_LOGIC(andc, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 2: /*ORBp*/\n\n                BOOLEAN_LOGIC(or, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 3: /*ORBCp*/\n\n                BOOLEAN_LOGIC(orc, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 4: /*XORBp*/\n\n                BOOLEAN_LOGIC(xor, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n#undef BOOLEAN_LOGIC\n\n\n\n            case 8: /*MULLi*/\n\n                HAS_OPTION(XTENSA_OPTION_32_BIT_IMUL);\n\n                tcg_gen_mul_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            case 10: /*MULUHi*/\n\n            case 11: /*MULSHi*/\n\n                HAS_OPTION(XTENSA_OPTION_32_BIT_IMUL_HIGH);\n\n                {\n\n                    TCGv lo = tcg_temp_new();\n\n\n\n                    if (OP2 == 10) {\n\n                        tcg_gen_mulu2_i32(lo, cpu_R[RRR_R],\n\n                                          cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    } else {\n\n                        tcg_gen_muls2_i32(lo, cpu_R[RRR_R],\n\n                                          cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    }\n\n                    tcg_temp_free(lo);\n\n                }\n\n                break;\n\n\n\n            case 12: /*QUOUi*/\n\n                tcg_gen_divu_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            case 13: /*QUOSi*/\n\n            case 15: /*REMSi*/\n\n                {\n\n                    int label1 = gen_new_label();\n\n                    int label2 = gen_new_label();\n\n\n\n                    tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_S], 0x80000000,\n\n                            label1);\n\n                    tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_T], 0xffffffff,\n\n                            label1);\n\n                    tcg_gen_movi_i32(cpu_R[RRR_R],\n\n                            OP2 == 13 ? 0x80000000 : 0);\n\n                    tcg_gen_br(label2);\n\n                    gen_set_label(label1);\n\n                    if (OP2 == 13) {\n\n                        tcg_gen_div_i32(cpu_R[RRR_R],\n\n                                cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    } else {\n\n                        tcg_gen_rem_i32(cpu_R[RRR_R],\n\n                                cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    }\n\n                    gen_set_label(label2);\n\n                }\n\n                break;\n\n\n\n            case 14: /*REMUi*/\n\n                tcg_gen_remu_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 3: /*RST3*/\n\n            switch (OP2) {\n\n            case 0: /*RSR*/\n\n                if (gen_check_sr(dc, RSR_SR, SR_R) &&\n\n                    (RSR_SR < 64 || gen_check_privilege(dc)) &&\n\n                    gen_window_check1(dc, RRR_T)) {\n\n                    gen_rsr(dc, cpu_R[RRR_T], RSR_SR);\n\n                }\n\n                break;\n\n\n\n            case 1: /*WSR*/\n\n                if (gen_check_sr(dc, RSR_SR, SR_W) &&\n\n                    (RSR_SR < 64 || gen_check_privilege(dc)) &&\n\n                    gen_window_check1(dc, RRR_T)) {\n\n                    gen_wsr(dc, RSR_SR, cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 2: /*SEXTu*/\n\n                HAS_OPTION(XTENSA_OPTION_MISC_OP_SEXT);\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    int shift = 24 - RRR_T;\n\n\n\n                    if (shift == 24) {\n\n                        tcg_gen_ext8s_i32(cpu_R[RRR_R], cpu_R[RRR_S]);\n\n                    } else if (shift == 16) {\n\n                        tcg_gen_ext16s_i32(cpu_R[RRR_R], cpu_R[RRR_S]);\n\n                    } else {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], shift);\n\n                        tcg_gen_sari_i32(cpu_R[RRR_R], tmp, shift);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                }\n\n                break;\n\n\n\n            case 3: /*CLAMPSu*/\n\n                HAS_OPTION(XTENSA_OPTION_MISC_OP_CLAMPS);\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    TCGv_i32 tmp1 = tcg_temp_new_i32();\n\n                    TCGv_i32 tmp2 = tcg_temp_new_i32();\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n\n\n                    tcg_gen_sari_i32(tmp1, cpu_R[RRR_S], 24 - RRR_T);\n\n                    tcg_gen_xor_i32(tmp2, tmp1, cpu_R[RRR_S]);\n\n                    tcg_gen_andi_i32(tmp2, tmp2, 0xffffffff << (RRR_T + 7));\n\n\n\n                    tcg_gen_sari_i32(tmp1, cpu_R[RRR_S], 31);\n\n                    tcg_gen_xori_i32(tmp1, tmp1, 0xffffffff >> (25 - RRR_T));\n\n\n\n                    tcg_gen_movcond_i32(TCG_COND_EQ, cpu_R[RRR_R], tmp2, zero,\n\n                            cpu_R[RRR_S], tmp1);\n\n                    tcg_temp_free(tmp1);\n\n                    tcg_temp_free(tmp2);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 4: /*MINu*/\n\n            case 5: /*MAXu*/\n\n            case 6: /*MINUu*/\n\n            case 7: /*MAXUu*/\n\n                HAS_OPTION(XTENSA_OPTION_MISC_OP_MINMAX);\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    static const TCGCond cond[] = {\n\n                        TCG_COND_LE,\n\n                        TCG_COND_GE,\n\n                        TCG_COND_LEU,\n\n                        TCG_COND_GEU\n\n                    };\n\n                    tcg_gen_movcond_i32(cond[OP2 - 4], cpu_R[RRR_R],\n\n                            cpu_R[RRR_S], cpu_R[RRR_T],\n\n                            cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 8: /*MOVEQZ*/\n\n            case 9: /*MOVNEZ*/\n\n            case 10: /*MOVLTZ*/\n\n            case 11: /*MOVGEZ*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    static const TCGCond cond[] = {\n\n                        TCG_COND_EQ,\n\n                        TCG_COND_NE,\n\n                        TCG_COND_LT,\n\n                        TCG_COND_GE,\n\n                    };\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n\n\n                    tcg_gen_movcond_i32(cond[OP2 - 8], cpu_R[RRR_R],\n\n                            cpu_R[RRR_T], zero, cpu_R[RRR_S], cpu_R[RRR_R]);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 12: /*MOVFp*/\n\n            case 13: /*MOVTp*/\n\n                HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                    tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRR_T);\n\n                    tcg_gen_movcond_i32(OP2 & 1 ? TCG_COND_NE : TCG_COND_EQ,\n\n                            cpu_R[RRR_R], tmp, zero,\n\n                            cpu_R[RRR_S], cpu_R[RRR_R]);\n\n\n\n                    tcg_temp_free(tmp);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 14: /*RUR*/\n\n                if (gen_window_check1(dc, RRR_R)) {\n\n                    int st = (RRR_S << 4) + RRR_T;\n\n                    if (uregnames[st].name) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_UR[st]);\n\n                    } else {\n\n                        qemu_log(\"RUR %d not implemented, \", st);\n\n                        TBD();\n\n                    }\n\n                }\n\n                break;\n\n\n\n            case 15: /*WUR*/\n\n                if (gen_window_check1(dc, RRR_T)) {\n\n                    if (uregnames[RSR_SR].name) {\n\n                        gen_wur(RSR_SR, cpu_R[RRR_T]);\n\n                    } else {\n\n                        qemu_log(\"WUR %d not implemented, \", RSR_SR);\n\n                        TBD();\n\n                    }\n\n                }\n\n                break;\n\n\n\n            }\n\n            break;\n\n\n\n        case 4: /*EXTUI*/\n\n        case 5:\n\n            if (gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                int shiftimm = RRR_S | ((OP1 & 1) << 4);\n\n                int maskimm = (1 << (OP2 + 1)) - 1;\n\n\n\n                TCGv_i32 tmp = tcg_temp_new_i32();\n\n                tcg_gen_shri_i32(tmp, cpu_R[RRR_T], shiftimm);\n\n                tcg_gen_andi_i32(cpu_R[RRR_R], tmp, maskimm);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n\n\n        case 6: /*CUST0*/\n\n            RESERVED();\n\n            break;\n\n\n\n        case 7: /*CUST1*/\n\n            RESERVED();\n\n            break;\n\n\n\n        case 8: /*LSCXp*/\n\n            switch (OP2) {\n\n            case 0: /*LSXf*/\n\n            case 1: /*LSXUf*/\n\n            case 4: /*SSXf*/\n\n            case 5: /*SSXUf*/\n\n                HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n                if (gen_window_check2(dc, RRR_S, RRR_T) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    TCGv_i32 addr = tcg_temp_new_i32();\n\n                    tcg_gen_add_i32(addr, cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    gen_load_store_alignment(dc, 2, addr, false);\n\n                    if (OP2 & 0x4) {\n\n                        tcg_gen_qemu_st32(cpu_FR[RRR_R], addr, dc->cring);\n\n                    } else {\n\n                        tcg_gen_qemu_ld32u(cpu_FR[RRR_R], addr, dc->cring);\n\n                    }\n\n                    if (OP2 & 0x1) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_S], addr);\n\n                    }\n\n                    tcg_temp_free(addr);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 9: /*LSC4*/\n\n            if (!gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                break;\n\n            }\n\n            switch (OP2) {\n\n            case 0: /*L32E*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                if (gen_check_privilege(dc)) {\n\n                    TCGv_i32 addr = tcg_temp_new_i32();\n\n                    tcg_gen_addi_i32(addr, cpu_R[RRR_S],\n\n                            (0xffffffc0 | (RRR_R << 2)));\n\n                    tcg_gen_qemu_ld32u(cpu_R[RRR_T], addr, dc->ring);\n\n                    tcg_temp_free(addr);\n\n                }\n\n                break;\n\n\n\n            case 4: /*S32E*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                if (gen_check_privilege(dc)) {\n\n                    TCGv_i32 addr = tcg_temp_new_i32();\n\n                    tcg_gen_addi_i32(addr, cpu_R[RRR_S],\n\n                            (0xffffffc0 | (RRR_R << 2)));\n\n                    tcg_gen_qemu_st32(cpu_R[RRR_T], addr, dc->ring);\n\n                    tcg_temp_free(addr);\n\n                }\n\n                break;\n\n\n\n            default:\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 10: /*FP0*/\n\n            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n            switch (OP2) {\n\n            case 0: /*ADD.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_add_s(cpu_FR[RRR_R], cpu_env,\n\n                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 1: /*SUB.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_sub_s(cpu_FR[RRR_R], cpu_env,\n\n                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 2: /*MUL.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_mul_s(cpu_FR[RRR_R], cpu_env,\n\n                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 4: /*MADD.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_madd_s(cpu_FR[RRR_R], cpu_env,\n\n                                      cpu_FR[RRR_R], cpu_FR[RRR_S],\n\n                                      cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 5: /*MSUB.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_msub_s(cpu_FR[RRR_R], cpu_env,\n\n                                      cpu_FR[RRR_R], cpu_FR[RRR_S],\n\n                                      cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 8: /*ROUND.Sf*/\n\n            case 9: /*TRUNC.Sf*/\n\n            case 10: /*FLOOR.Sf*/\n\n            case 11: /*CEIL.Sf*/\n\n            case 14: /*UTRUNC.Sf*/\n\n                if (gen_window_check1(dc, RRR_R) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    static const unsigned rounding_mode_const[] = {\n\n                        float_round_nearest_even,\n\n                        float_round_to_zero,\n\n                        float_round_down,\n\n                        float_round_up,\n\n                        [6] = float_round_to_zero,\n\n                    };\n\n                    TCGv_i32 rounding_mode = tcg_const_i32(\n\n                            rounding_mode_const[OP2 & 7]);\n\n                    TCGv_i32 scale = tcg_const_i32(RRR_T);\n\n\n\n                    if (OP2 == 14) {\n\n                        gen_helper_ftoui(cpu_R[RRR_R], cpu_FR[RRR_S],\n\n                                rounding_mode, scale);\n\n                    } else {\n\n                        gen_helper_ftoi(cpu_R[RRR_R], cpu_FR[RRR_S],\n\n                                rounding_mode, scale);\n\n                    }\n\n\n\n                    tcg_temp_free(rounding_mode);\n\n                    tcg_temp_free(scale);\n\n                }\n\n                break;\n\n\n\n            case 12: /*FLOAT.Sf*/\n\n            case 13: /*UFLOAT.Sf*/\n\n                if (gen_window_check1(dc, RRR_S) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    TCGv_i32 scale = tcg_const_i32(-RRR_T);\n\n\n\n                    if (OP2 == 13) {\n\n                        gen_helper_uitof(cpu_FR[RRR_R], cpu_env,\n\n                                cpu_R[RRR_S], scale);\n\n                    } else {\n\n                        gen_helper_itof(cpu_FR[RRR_R], cpu_env,\n\n                                cpu_R[RRR_S], scale);\n\n                    }\n\n                    tcg_temp_free(scale);\n\n                }\n\n                break;\n\n\n\n            case 15: /*FP1OP*/\n\n                switch (RRR_T) {\n\n                case 0: /*MOV.Sf*/\n\n                    if (gen_check_cpenable(dc, 0)) {\n\n                        tcg_gen_mov_i32(cpu_FR[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 1: /*ABS.Sf*/\n\n                    if (gen_check_cpenable(dc, 0)) {\n\n                        gen_helper_abs_s(cpu_FR[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*RFRf*/\n\n                    if (gen_window_check1(dc, RRR_R) &&\n\n                        gen_check_cpenable(dc, 0)) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 5: /*WFRf*/\n\n                    if (gen_window_check1(dc, RRR_S) &&\n\n                        gen_check_cpenable(dc, 0)) {\n\n                        tcg_gen_mov_i32(cpu_FR[RRR_R], cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 6: /*NEG.Sf*/\n\n                    if (gen_check_cpenable(dc, 0)) {\n\n                        gen_helper_neg_s(cpu_FR[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 11: /*FP1*/\n\n            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n\n\n#define gen_compare(rel, br, a, b) \\\n\n    do { \\\n\n        if (gen_check_cpenable(dc, 0)) { \\\n\n            TCGv_i32 bit = tcg_const_i32(1 << br); \\\n\n            \\\n\n            gen_helper_##rel(cpu_env, bit, cpu_FR[a], cpu_FR[b]); \\\n\n            tcg_temp_free(bit); \\\n\n        } \\\n\n    } while (0)\n\n\n\n            switch (OP2) {\n\n            case 1: /*UN.Sf*/\n\n                gen_compare(un_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 2: /*OEQ.Sf*/\n\n                gen_compare(oeq_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 3: /*UEQ.Sf*/\n\n                gen_compare(ueq_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 4: /*OLT.Sf*/\n\n                gen_compare(olt_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 5: /*ULT.Sf*/\n\n                gen_compare(ult_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 6: /*OLE.Sf*/\n\n                gen_compare(ole_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 7: /*ULE.Sf*/\n\n                gen_compare(ule_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n#undef gen_compare\n\n\n\n            case 8: /*MOVEQZ.Sf*/\n\n            case 9: /*MOVNEZ.Sf*/\n\n            case 10: /*MOVLTZ.Sf*/\n\n            case 11: /*MOVGEZ.Sf*/\n\n                if (gen_window_check1(dc, RRR_T) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    static const TCGCond cond[] = {\n\n                        TCG_COND_EQ,\n\n                        TCG_COND_NE,\n\n                        TCG_COND_LT,\n\n                        TCG_COND_GE,\n\n                    };\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n\n\n                    tcg_gen_movcond_i32(cond[OP2 - 8], cpu_FR[RRR_R],\n\n                            cpu_R[RRR_T], zero, cpu_FR[RRR_S], cpu_FR[RRR_R]);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 12: /*MOVF.Sf*/\n\n            case 13: /*MOVT.Sf*/\n\n                HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                    tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRR_T);\n\n                    tcg_gen_movcond_i32(OP2 & 1 ? TCG_COND_NE : TCG_COND_EQ,\n\n                            cpu_FR[RRR_R], tmp, zero,\n\n                            cpu_FR[RRR_S], cpu_FR[RRR_R]);\n\n\n\n                    tcg_temp_free(tmp);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 1: /*L32R*/\n\n        if (gen_window_check1(dc, RRR_T)) {\n\n            TCGv_i32 tmp = tcg_const_i32(\n\n                    ((dc->tb->flags & XTENSA_TBFLAG_LITBASE) ?\n\n                     0 : ((dc->pc + 3) & ~3)) +\n\n                    (0xfffc0000 | (RI16_IMM16 << 2)));\n\n\n\n            if (dc->tb->flags & XTENSA_TBFLAG_LITBASE) {\n\n                tcg_gen_add_i32(tmp, tmp, dc->litbase);\n\n            }\n\n            tcg_gen_qemu_ld32u(cpu_R[RRR_T], tmp, dc->cring);\n\n            tcg_temp_free(tmp);\n\n        }\n\n        break;\n\n\n\n    case 2: /*LSAI*/\n\n#define gen_load_store(type, shift) do { \\\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << shift); \\\n\n                if (shift) { \\\n\n                    gen_load_store_alignment(dc, shift, addr, false); \\\n\n                } \\\n\n                tcg_gen_qemu_##type(cpu_R[RRI8_T], addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n            } \\\n\n        } while (0)\n\n\n\n        switch (RRI8_R) {\n\n        case 0: /*L8UI*/\n\n            gen_load_store(ld8u, 0);\n\n            break;\n\n\n\n        case 1: /*L16UI*/\n\n            gen_load_store(ld16u, 1);\n\n            break;\n\n\n\n        case 2: /*L32I*/\n\n            gen_load_store(ld32u, 2);\n\n            break;\n\n\n\n        case 4: /*S8I*/\n\n            gen_load_store(st8, 0);\n\n            break;\n\n\n\n        case 5: /*S16I*/\n\n            gen_load_store(st16, 1);\n\n            break;\n\n\n\n        case 6: /*S32I*/\n\n            gen_load_store(st32, 2);\n\n            break;\n\n\n\n#define gen_dcache_hit_test(w, shift) do { \\\n\n            if (gen_window_check1(dc, RRI##w##_S)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                TCGv_i32 res = tcg_temp_new_i32(); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI##w##_S], \\\n\n                                 RRI##w##_IMM##w << shift); \\\n\n                tcg_gen_qemu_ld8u(res, addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n                tcg_temp_free(res); \\\n\n            } \\\n\n        } while (0)\n\n\n\n#define gen_dcache_hit_test4() gen_dcache_hit_test(4, 4)\n\n#define gen_dcache_hit_test8() gen_dcache_hit_test(8, 2)\n\n\n\n        case 7: /*CACHEc*/\n\n            if (RRI8_T < 8) {\n\n                HAS_OPTION(XTENSA_OPTION_DCACHE);\n\n            }\n\n\n\n            switch (RRI8_T) {\n\n            case 0: /*DPFRc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 1: /*DPFWc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 2: /*DPFROc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 3: /*DPFWOc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 4: /*DHWBc*/\n\n                gen_dcache_hit_test8();\n\n                break;\n\n\n\n            case 5: /*DHWBIc*/\n\n                gen_dcache_hit_test8();\n\n                break;\n\n\n\n            case 6: /*DHIc*/\n\n                if (gen_check_privilege(dc)) {\n\n                    gen_dcache_hit_test8();\n\n                }\n\n                break;\n\n\n\n            case 7: /*DIIc*/\n\n                if (gen_check_privilege(dc)) {\n\n                    gen_window_check1(dc, RRI8_S);\n\n                }\n\n                break;\n\n\n\n            case 8: /*DCEc*/\n\n                switch (OP1) {\n\n                case 0: /*DPFLl*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_dcache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*DHUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_dcache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*DIUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*DIWBc*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                case 5: /*DIWBIc*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n\n\n                }\n\n                break;\n\n\n\n#undef gen_dcache_hit_test\n\n#undef gen_dcache_hit_test4\n\n#undef gen_dcache_hit_test8\n\n\n\n#define gen_icache_hit_test(w, shift) do { \\\n\n            if (gen_window_check1(dc, RRI##w##_S)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                tcg_gen_movi_i32(cpu_pc, dc->pc); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI##w##_S], \\\n\n                                 RRI##w##_IMM##w << shift); \\\n\n                gen_helper_itlb_hit_test(cpu_env, addr); \\\n\n                tcg_temp_free(addr); \\\n\n            }\\\n\n        } while (0)\n\n\n\n#define gen_icache_hit_test4() gen_icache_hit_test(4, 4)\n\n#define gen_icache_hit_test8() gen_icache_hit_test(8, 2)\n\n\n\n            case 12: /*IPFc*/\n\n                HAS_OPTION(XTENSA_OPTION_ICACHE);\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 13: /*ICEc*/\n\n                switch (OP1) {\n\n                case 0: /*IPFLl*/\n\n                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_icache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*IHUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_icache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*IIUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            case 14: /*IHIc*/\n\n                HAS_OPTION(XTENSA_OPTION_ICACHE);\n\n                gen_icache_hit_test8();\n\n                break;\n\n\n\n            case 15: /*IIIc*/\n\n                HAS_OPTION(XTENSA_OPTION_ICACHE);\n\n                if (gen_check_privilege(dc)) {\n\n                    gen_window_check1(dc, RRI8_S);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n#undef gen_icache_hit_test\n\n#undef gen_icache_hit_test4\n\n#undef gen_icache_hit_test8\n\n\n\n        case 9: /*L16SI*/\n\n            gen_load_store(ld16s, 1);\n\n            break;\n\n#undef gen_load_store\n\n\n\n        case 10: /*MOVI*/\n\n            if (gen_window_check1(dc, RRI8_T)) {\n\n                tcg_gen_movi_i32(cpu_R[RRI8_T],\n\n                                 RRI8_IMM8 | (RRI8_S << 8) |\n\n                                 ((RRI8_S & 0x8) ? 0xfffff000 : 0));\n\n            }\n\n            break;\n\n\n\n#define gen_load_store_no_hw_align(type) do { \\\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) { \\\n\n                TCGv_i32 addr = tcg_temp_local_new_i32(); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2); \\\n\n                gen_load_store_alignment(dc, 2, addr, true); \\\n\n                tcg_gen_qemu_##type(cpu_R[RRI8_T], addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n            } \\\n\n        } while (0)\n\n\n\n        case 11: /*L32AIy*/\n\n            HAS_OPTION(XTENSA_OPTION_MP_SYNCHRO);\n\n            gen_load_store_no_hw_align(ld32u); /*TODO acquire?*/\n\n            break;\n\n\n\n        case 12: /*ADDI*/\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                tcg_gen_addi_i32(cpu_R[RRI8_T], cpu_R[RRI8_S], RRI8_IMM8_SE);\n\n            }\n\n            break;\n\n\n\n        case 13: /*ADDMI*/\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                tcg_gen_addi_i32(cpu_R[RRI8_T], cpu_R[RRI8_S],\n\n                                 RRI8_IMM8_SE << 8);\n\n            }\n\n            break;\n\n\n\n        case 14: /*S32C1Iy*/\n\n            HAS_OPTION(XTENSA_OPTION_CONDITIONAL_STORE);\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                int label = gen_new_label();\n\n                TCGv_i32 tmp = tcg_temp_local_new_i32();\n\n                TCGv_i32 addr = tcg_temp_local_new_i32();\n\n                TCGv_i32 tpc;\n\n\n\n                tcg_gen_mov_i32(tmp, cpu_R[RRI8_T]);\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2);\n\n                gen_load_store_alignment(dc, 2, addr, true);\n\n\n\n                gen_advance_ccount(dc);\n\n                tpc = tcg_const_i32(dc->pc);\n\n                gen_helper_check_atomctl(cpu_env, tpc, addr);\n\n                tcg_gen_qemu_ld32u(cpu_R[RRI8_T], addr, dc->cring);\n\n                tcg_gen_brcond_i32(TCG_COND_NE, cpu_R[RRI8_T],\n\n                        cpu_SR[SCOMPARE1], label);\n\n\n\n                tcg_gen_qemu_st32(tmp, addr, dc->cring);\n\n\n\n                gen_set_label(label);\n\n                tcg_temp_free(tpc);\n\n                tcg_temp_free(addr);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n\n\n        case 15: /*S32RIy*/\n\n            HAS_OPTION(XTENSA_OPTION_MP_SYNCHRO);\n\n            gen_load_store_no_hw_align(st32); /*TODO release?*/\n\n            break;\n\n#undef gen_load_store_no_hw_align\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 3: /*LSCIp*/\n\n        switch (RRI8_R) {\n\n        case 0: /*LSIf*/\n\n        case 4: /*SSIf*/\n\n        case 8: /*LSIUf*/\n\n        case 12: /*SSIUf*/\n\n            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n            if (gen_window_check1(dc, RRI8_S) &&\n\n                gen_check_cpenable(dc, 0)) {\n\n                TCGv_i32 addr = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2);\n\n                gen_load_store_alignment(dc, 2, addr, false);\n\n                if (RRI8_R & 0x4) {\n\n                    tcg_gen_qemu_st32(cpu_FR[RRI8_T], addr, dc->cring);\n\n                } else {\n\n                    tcg_gen_qemu_ld32u(cpu_FR[RRI8_T], addr, dc->cring);\n\n                }\n\n                if (RRI8_R & 0x8) {\n\n                    tcg_gen_mov_i32(cpu_R[RRI8_S], addr);\n\n                }\n\n                tcg_temp_free(addr);\n\n            }\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 4: /*MAC16d*/\n\n        HAS_OPTION(XTENSA_OPTION_MAC16);\n\n        {\n\n            enum {\n\n                MAC16_UMUL = 0x0,\n\n                MAC16_MUL  = 0x4,\n\n                MAC16_MULA = 0x8,\n\n                MAC16_MULS = 0xc,\n\n                MAC16_NONE = 0xf,\n\n            } op = OP1 & 0xc;\n\n            bool is_m1_sr = (OP2 & 0x3) == 2;\n\n            bool is_m2_sr = (OP2 & 0xc) == 0;\n\n            uint32_t ld_offset = 0;\n\n\n\n            if (OP2 > 9) {\n\n                RESERVED();\n\n            }\n\n\n\n            switch (OP2 & 2) {\n\n            case 0: /*MACI?/MACC?*/\n\n                is_m1_sr = true;\n\n                ld_offset = (OP2 & 1) ? -4 : 4;\n\n\n\n                if (OP2 >= 8) { /*MACI/MACC*/\n\n                    if (OP1 == 0) { /*LDINC/LDDEC*/\n\n                        op = MAC16_NONE;\n\n                    } else {\n\n                        RESERVED();\n\n                    }\n\n                } else if (op != MAC16_MULA) { /*MULA.*.*.LDINC/LDDEC*/\n\n                    RESERVED();\n\n                }\n\n                break;\n\n\n\n            case 2: /*MACD?/MACA?*/\n\n                if (op == MAC16_UMUL && OP2 != 7) { /*UMUL only in MACAA*/\n\n                    RESERVED();\n\n                }\n\n                break;\n\n            }\n\n\n\n            if (op != MAC16_NONE) {\n\n                if (!is_m1_sr && !gen_window_check1(dc, RRR_S)) {\n\n                    break;\n\n                }\n\n                if (!is_m2_sr && !gen_window_check1(dc, RRR_T)) {\n\n                    break;\n\n                }\n\n            }\n\n\n\n            if (ld_offset && !gen_window_check1(dc, RRR_S)) {\n\n                break;\n\n            }\n\n\n\n            {\n\n                TCGv_i32 vaddr = tcg_temp_new_i32();\n\n                TCGv_i32 mem32 = tcg_temp_new_i32();\n\n\n\n                if (ld_offset) {\n\n                    tcg_gen_addi_i32(vaddr, cpu_R[RRR_S], ld_offset);\n\n                    gen_load_store_alignment(dc, 2, vaddr, false);\n\n                    tcg_gen_qemu_ld32u(mem32, vaddr, dc->cring);\n\n                }\n\n                if (op != MAC16_NONE) {\n\n                    TCGv_i32 m1 = gen_mac16_m(\n\n                            is_m1_sr ? cpu_SR[MR + RRR_X] : cpu_R[RRR_S],\n\n                            OP1 & 1, op == MAC16_UMUL);\n\n                    TCGv_i32 m2 = gen_mac16_m(\n\n                            is_m2_sr ? cpu_SR[MR + 2 + RRR_Y] : cpu_R[RRR_T],\n\n                            OP1 & 2, op == MAC16_UMUL);\n\n\n\n                    if (op == MAC16_MUL || op == MAC16_UMUL) {\n\n                        tcg_gen_mul_i32(cpu_SR[ACCLO], m1, m2);\n\n                        if (op == MAC16_UMUL) {\n\n                            tcg_gen_movi_i32(cpu_SR[ACCHI], 0);\n\n                        } else {\n\n                            tcg_gen_sari_i32(cpu_SR[ACCHI], cpu_SR[ACCLO], 31);\n\n                        }\n\n                    } else {\n\n                        TCGv_i32 lo = tcg_temp_new_i32();\n\n                        TCGv_i32 hi = tcg_temp_new_i32();\n\n\n\n                        tcg_gen_mul_i32(lo, m1, m2);\n\n                        tcg_gen_sari_i32(hi, lo, 31);\n\n                        if (op == MAC16_MULA) {\n\n                            tcg_gen_add2_i32(cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             lo, hi);\n\n                        } else {\n\n                            tcg_gen_sub2_i32(cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             lo, hi);\n\n                        }\n\n                        tcg_gen_ext8s_i32(cpu_SR[ACCHI], cpu_SR[ACCHI]);\n\n\n\n                        tcg_temp_free_i32(lo);\n\n                        tcg_temp_free_i32(hi);\n\n                    }\n\n                    tcg_temp_free(m1);\n\n                    tcg_temp_free(m2);\n\n                }\n\n                if (ld_offset) {\n\n                    tcg_gen_mov_i32(cpu_R[RRR_S], vaddr);\n\n                    tcg_gen_mov_i32(cpu_SR[MR + RRR_W], mem32);\n\n                }\n\n                tcg_temp_free(vaddr);\n\n                tcg_temp_free(mem32);\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 5: /*CALLN*/\n\n        switch (CALL_N) {\n\n        case 0: /*CALL0*/\n\n            tcg_gen_movi_i32(cpu_R[0], dc->next_pc);\n\n            gen_jumpi(dc, (dc->pc & ~3) + (CALL_OFFSET_SE << 2) + 4, 0);\n\n            break;\n\n\n\n        case 1: /*CALL4w*/\n\n        case 2: /*CALL8w*/\n\n        case 3: /*CALL12w*/\n\n            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n            if (gen_window_check1(dc, CALL_N << 2)) {\n\n                gen_callwi(dc, CALL_N,\n\n                           (dc->pc & ~3) + (CALL_OFFSET_SE << 2) + 4, 0);\n\n            }\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 6: /*SI*/\n\n        switch (CALL_N) {\n\n        case 0: /*J*/\n\n            gen_jumpi(dc, dc->pc + 4 + CALL_OFFSET_SE, 0);\n\n            break;\n\n\n\n        case 1: /*BZ*/\n\n            if (gen_window_check1(dc, BRI12_S)) {\n\n                static const TCGCond cond[] = {\n\n                    TCG_COND_EQ, /*BEQZ*/\n\n                    TCG_COND_NE, /*BNEZ*/\n\n                    TCG_COND_LT, /*BLTZ*/\n\n                    TCG_COND_GE, /*BGEZ*/\n\n                };\n\n\n\n                gen_brcondi(dc, cond[BRI12_M & 3], cpu_R[BRI12_S], 0,\n\n                        4 + BRI12_IMM12_SE);\n\n            }\n\n            break;\n\n\n\n        case 2: /*BI0*/\n\n            if (gen_window_check1(dc, BRI8_S)) {\n\n                static const TCGCond cond[] = {\n\n                    TCG_COND_EQ, /*BEQI*/\n\n                    TCG_COND_NE, /*BNEI*/\n\n                    TCG_COND_LT, /*BLTI*/\n\n                    TCG_COND_GE, /*BGEI*/\n\n                };\n\n\n\n                gen_brcondi(dc, cond[BRI8_M & 3],\n\n                        cpu_R[BRI8_S], B4CONST[BRI8_R], 4 + BRI8_IMM8_SE);\n\n            }\n\n            break;\n\n\n\n        case 3: /*BI1*/\n\n            switch (BRI8_M) {\n\n            case 0: /*ENTRYw*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                {\n\n                    TCGv_i32 pc = tcg_const_i32(dc->pc);\n\n                    TCGv_i32 s = tcg_const_i32(BRI12_S);\n\n                    TCGv_i32 imm = tcg_const_i32(BRI12_IMM12);\n\n                    gen_advance_ccount(dc);\n\n                    gen_helper_entry(cpu_env, pc, s, imm);\n\n                    tcg_temp_free(imm);\n\n                    tcg_temp_free(s);\n\n                    tcg_temp_free(pc);\n\n                    /* This can change tb->flags, so exit tb */\n\n                    gen_jumpi_check_loop_end(dc, -1);\n\n                }\n\n                break;\n\n\n\n            case 1: /*B1*/\n\n                switch (BRI8_R) {\n\n                case 0: /*BFp*/\n\n                case 1: /*BTp*/\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                    {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRI8_S);\n\n                        gen_brcondi(dc,\n\n                                BRI8_R == 1 ? TCG_COND_NE : TCG_COND_EQ,\n\n                                tmp, 0, 4 + RRI8_IMM8_SE);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 8: /*LOOP*/\n\n                case 9: /*LOOPNEZ*/\n\n                case 10: /*LOOPGTZ*/\n\n                    HAS_OPTION(XTENSA_OPTION_LOOP);\n\n                    if (gen_window_check1(dc, RRI8_S)) {\n\n                        uint32_t lend = dc->pc + RRI8_IMM8 + 4;\n\n                        TCGv_i32 tmp = tcg_const_i32(lend);\n\n\n\n                        tcg_gen_subi_i32(cpu_SR[LCOUNT], cpu_R[RRI8_S], 1);\n\n                        tcg_gen_movi_i32(cpu_SR[LBEG], dc->next_pc);\n\n                        gen_helper_wsr_lend(cpu_env, tmp);\n\n                        tcg_temp_free(tmp);\n\n\n\n                        if (BRI8_R > 8) {\n\n                            int label = gen_new_label();\n\n                            tcg_gen_brcondi_i32(\n\n                                    BRI8_R == 9 ? TCG_COND_NE : TCG_COND_GT,\n\n                                    cpu_R[RRI8_S], 0, label);\n\n                            gen_jumpi(dc, lend, 1);\n\n                            gen_set_label(label);\n\n                        }\n\n\n\n                        gen_jumpi(dc, dc->next_pc, 0);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n\n\n                }\n\n                break;\n\n\n\n            case 2: /*BLTUI*/\n\n            case 3: /*BGEUI*/\n\n                if (gen_window_check1(dc, BRI8_S)) {\n\n                    gen_brcondi(dc, BRI8_M == 2 ? TCG_COND_LTU : TCG_COND_GEU,\n\n                                cpu_R[BRI8_S], B4CONSTU[BRI8_R],\n\n                                4 + BRI8_IMM8_SE);\n\n                }\n\n                break;\n\n            }\n\n            break;\n\n\n\n        }\n\n        break;\n\n\n\n    case 7: /*B*/\n\n        {\n\n            TCGCond eq_ne = (RRI8_R & 8) ? TCG_COND_NE : TCG_COND_EQ;\n\n\n\n            switch (RRI8_R & 7) {\n\n            case 0: /*BNONE*/ /*BANY*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], cpu_R[RRI8_T]);\n\n                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 1: /*BEQ*/ /*BNE*/\n\n            case 2: /*BLT*/ /*BGE*/\n\n            case 3: /*BLTU*/ /*BGEU*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                    static const TCGCond cond[] = {\n\n                        [1] = TCG_COND_EQ,\n\n                        [2] = TCG_COND_LT,\n\n                        [3] = TCG_COND_LTU,\n\n                        [9] = TCG_COND_NE,\n\n                        [10] = TCG_COND_GE,\n\n                        [11] = TCG_COND_GEU,\n\n                    };\n\n                    gen_brcond(dc, cond[RRI8_R], cpu_R[RRI8_S], cpu_R[RRI8_T],\n\n                            4 + RRI8_IMM8_SE);\n\n                }\n\n                break;\n\n\n\n            case 4: /*BALL*/ /*BNALL*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], cpu_R[RRI8_T]);\n\n                    gen_brcond(dc, eq_ne, tmp, cpu_R[RRI8_T],\n\n                            4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 5: /*BBC*/ /*BBS*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n                    TCGv_i32 bit = tcg_const_i32(0x80000000);\n\n#else\n\n                    TCGv_i32 bit = tcg_const_i32(0x00000001);\n\n#endif\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_andi_i32(tmp, cpu_R[RRI8_T], 0x1f);\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n                    tcg_gen_shr_i32(bit, bit, tmp);\n\n#else\n\n                    tcg_gen_shl_i32(bit, bit, tmp);\n\n#endif\n\n                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], bit);\n\n                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                    tcg_temp_free(bit);\n\n                }\n\n                break;\n\n\n\n            case 6: /*BBCI*/ /*BBSI*/\n\n            case 7:\n\n                if (gen_window_check1(dc, RRI8_S)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_andi_i32(tmp, cpu_R[RRI8_S],\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n                            0x80000000 >> (((RRI8_R & 1) << 4) | RRI8_T));\n\n#else\n\n                            0x00000001 << (((RRI8_R & 1) << 4) | RRI8_T));\n\n#endif\n\n                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            }\n\n        }\n\n        break;\n\n\n\n#define gen_narrow_load_store(type) do { \\\n\n            if (gen_window_check2(dc, RRRN_S, RRRN_T)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRRN_S], RRRN_R << 2); \\\n\n                gen_load_store_alignment(dc, 2, addr, false); \\\n\n                tcg_gen_qemu_##type(cpu_R[RRRN_T], addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n            } \\\n\n        } while (0)\n\n\n\n    case 8: /*L32I.Nn*/\n\n        gen_narrow_load_store(ld32u);\n\n        break;\n\n\n\n    case 9: /*S32I.Nn*/\n\n        gen_narrow_load_store(st32);\n\n        break;\n\n#undef gen_narrow_load_store\n\n\n\n    case 10: /*ADD.Nn*/\n\n        if (gen_window_check3(dc, RRRN_R, RRRN_S, RRRN_T)) {\n\n            tcg_gen_add_i32(cpu_R[RRRN_R], cpu_R[RRRN_S], cpu_R[RRRN_T]);\n\n        }\n\n        break;\n\n\n\n    case 11: /*ADDI.Nn*/\n\n        if (gen_window_check2(dc, RRRN_R, RRRN_S)) {\n\n            tcg_gen_addi_i32(cpu_R[RRRN_R], cpu_R[RRRN_S],\n\n                             RRRN_T ? RRRN_T : -1);\n\n        }\n\n        break;\n\n\n\n    case 12: /*ST2n*/\n\n        if (!gen_window_check1(dc, RRRN_S)) {\n\n            break;\n\n        }\n\n        if (RRRN_T < 8) { /*MOVI.Nn*/\n\n            tcg_gen_movi_i32(cpu_R[RRRN_S],\n\n                    RRRN_R | (RRRN_T << 4) |\n\n                    ((RRRN_T & 6) == 6 ? 0xffffff80 : 0));\n\n        } else { /*BEQZ.Nn*/ /*BNEZ.Nn*/\n\n            TCGCond eq_ne = (RRRN_T & 4) ? TCG_COND_NE : TCG_COND_EQ;\n\n\n\n            gen_brcondi(dc, eq_ne, cpu_R[RRRN_S], 0,\n\n                    4 + (RRRN_R | ((RRRN_T & 3) << 4)));\n\n        }\n\n        break;\n\n\n\n    case 13: /*ST3n*/\n\n        switch (RRRN_R) {\n\n        case 0: /*MOV.Nn*/\n\n            if (gen_window_check2(dc, RRRN_S, RRRN_T)) {\n\n                tcg_gen_mov_i32(cpu_R[RRRN_T], cpu_R[RRRN_S]);\n\n            }\n\n            break;\n\n\n\n        case 15: /*S3*/\n\n            switch (RRRN_T) {\n\n            case 0: /*RET.Nn*/\n\n                gen_jump(dc, cpu_R[0]);\n\n                break;\n\n\n\n            case 1: /*RETW.Nn*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                {\n\n                    TCGv_i32 tmp = tcg_const_i32(dc->pc);\n\n                    gen_advance_ccount(dc);\n\n                    gen_helper_retw(tmp, cpu_env, tmp);\n\n                    gen_jump(dc, tmp);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 2: /*BREAK.Nn*/\n\n                HAS_OPTION(XTENSA_OPTION_DEBUG);\n\n                if (dc->debug) {\n\n                    gen_debug_exception(dc, DEBUGCAUSE_BN);\n\n                }\n\n                break;\n\n\n\n            case 3: /*NOP.Nn*/\n\n                break;\n\n\n\n            case 6: /*ILL.Nn*/\n\n                gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default: /*reserved*/\n\n        RESERVED();\n\n        break;\n\n    }\n\n\n\n    if (dc->is_jmp == DISAS_NEXT) {\n\n        gen_check_loop_end(dc, 0);\n\n    }\n\n    dc->pc = dc->next_pc;\n\n\n\n    return;\n\n\n\ninvalid_opcode:\n\n    qemu_log(\"INVALID(pc = %08x)\\n\", dc->pc);\n\n    gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n#undef HAS_OPTION\n\n}\n", "idx": 22421}
{"project": "qemu", "commit_id": "b74cddcbf6063f684725e3f8bca49a68e30cba71", "target": 0, "func": "static void decode_opc(CPUMIPSState *env, DisasContext *ctx)\n\n{\n\n    int32_t offset;\n\n    int rs, rt, rd, sa;\n\n    uint32_t op, op1;\n\n    int16_t imm;\n\n\n\n    /* make sure instructions are on a word boundary */\n\n    if (ctx->pc & 0x3) {\n\n        env->CP0_BadVAddr = ctx->pc;\n\n        generate_exception_err(ctx, EXCP_AdEL, EXCP_INST_NOTAVAIL);\n\n        return;\n\n    }\n\n\n\n    /* Handle blikely not taken case */\n\n    if ((ctx->hflags & MIPS_HFLAG_BMASK_BASE) == MIPS_HFLAG_BL) {\n\n        TCGLabel *l1 = gen_new_label();\n\n\n\n        tcg_gen_brcondi_tl(TCG_COND_NE, bcond, 0, l1);\n\n        tcg_gen_movi_i32(hflags, ctx->hflags & ~MIPS_HFLAG_BMASK);\n\n        gen_goto_tb(ctx, 1, ctx->pc + 4);\n\n        gen_set_label(l1);\n\n    }\n\n\n\n    op = MASK_OP_MAJOR(ctx->opcode);\n\n    rs = (ctx->opcode >> 21) & 0x1f;\n\n    rt = (ctx->opcode >> 16) & 0x1f;\n\n    rd = (ctx->opcode >> 11) & 0x1f;\n\n    sa = (ctx->opcode >> 6) & 0x1f;\n\n    imm = (int16_t)ctx->opcode;\n\n    switch (op) {\n\n    case OPC_SPECIAL:\n\n        decode_opc_special(env, ctx);\n\n        break;\n\n    case OPC_SPECIAL2:\n\n        decode_opc_special2_legacy(env, ctx);\n\n        break;\n\n    case OPC_SPECIAL3:\n\n        decode_opc_special3(env, ctx);\n\n        break;\n\n    case OPC_REGIMM:\n\n        op1 = MASK_REGIMM(ctx->opcode);\n\n        switch (op1) {\n\n        case OPC_BLTZL: /* REGIMM branches */\n\n        case OPC_BGEZL:\n\n        case OPC_BLTZALL:\n\n        case OPC_BGEZALL:\n\n            check_insn(ctx, ISA_MIPS2);\n\n            check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n            /* Fallthrough */\n\n        case OPC_BLTZ:\n\n        case OPC_BGEZ:\n\n            gen_compute_branch(ctx, op1, 4, rs, -1, imm << 2, 4);\n\n            break;\n\n        case OPC_BLTZAL:\n\n        case OPC_BGEZAL:\n\n            if (ctx->insn_flags & ISA_MIPS32R6) {\n\n                if (rs == 0) {\n\n                    /* OPC_NAL, OPC_BAL */\n\n                    gen_compute_branch(ctx, op1, 4, 0, -1, imm << 2, 4);\n\n                } else {\n\n                    generate_exception_end(ctx, EXCP_RI);\n\n                }\n\n            } else {\n\n                gen_compute_branch(ctx, op1, 4, rs, -1, imm << 2, 4);\n\n            }\n\n            break;\n\n        case OPC_TGEI ... OPC_TEQI: /* REGIMM traps */\n\n        case OPC_TNEI:\n\n            check_insn(ctx, ISA_MIPS2);\n\n            check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n            gen_trap(ctx, op1, rs, -1, imm);\n\n            break;\n\n        case OPC_SIGRIE:\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            generate_exception_end(ctx, EXCP_RI);\n\n            break;\n\n        case OPC_SYNCI:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            /* Break the TB to be able to sync copied instructions\n\n               immediately */\n\n            ctx->bstate = BS_STOP;\n\n            break;\n\n        case OPC_BPOSGE32:    /* MIPS DSP branch */\n\n#if defined(TARGET_MIPS64)\n\n        case OPC_BPOSGE64:\n\n#endif\n\n            check_dsp(ctx);\n\n            gen_compute_branch(ctx, op1, 4, -1, -2, (int32_t)imm << 2, 4);\n\n            break;\n\n#if defined(TARGET_MIPS64)\n\n        case OPC_DAHI:\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            check_mips_64(ctx);\n\n            if (rs != 0) {\n\n                tcg_gen_addi_tl(cpu_gpr[rs], cpu_gpr[rs], (int64_t)imm << 32);\n\n            }\n\n            break;\n\n        case OPC_DATI:\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            check_mips_64(ctx);\n\n            if (rs != 0) {\n\n                tcg_gen_addi_tl(cpu_gpr[rs], cpu_gpr[rs], (int64_t)imm << 48);\n\n            }\n\n            break;\n\n#endif\n\n        default:            /* Invalid */\n\n            MIPS_INVAL(\"regimm\");\n\n            generate_exception_end(ctx, EXCP_RI);\n\n            break;\n\n        }\n\n        break;\n\n    case OPC_CP0:\n\n        check_cp0_enabled(ctx);\n\n        op1 = MASK_CP0(ctx->opcode);\n\n        switch (op1) {\n\n        case OPC_MFC0:\n\n        case OPC_MTC0:\n\n        case OPC_MFTR:\n\n        case OPC_MTTR:\n\n        case OPC_MFHC0:\n\n        case OPC_MTHC0:\n\n#if defined(TARGET_MIPS64)\n\n        case OPC_DMFC0:\n\n        case OPC_DMTC0:\n\n#endif\n\n#ifndef CONFIG_USER_ONLY\n\n            gen_cp0(env, ctx, op1, rt, rd);\n\n#endif /* !CONFIG_USER_ONLY */\n\n            break;\n\n        case OPC_C0_FIRST ... OPC_C0_LAST:\n\n#ifndef CONFIG_USER_ONLY\n\n            gen_cp0(env, ctx, MASK_C0(ctx->opcode), rt, rd);\n\n#endif /* !CONFIG_USER_ONLY */\n\n            break;\n\n        case OPC_MFMC0:\n\n#ifndef CONFIG_USER_ONLY\n\n            {\n\n                uint32_t op2;\n\n                TCGv t0 = tcg_temp_new();\n\n\n\n                op2 = MASK_MFMC0(ctx->opcode);\n\n                switch (op2) {\n\n                case OPC_DMT:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_dmt(t0);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_EMT:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_emt(t0);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_DVPE:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_dvpe(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_EVPE:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_evpe(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_DVP:\n\n                    check_insn(ctx, ISA_MIPS32R6);\n\n                    if (ctx->vp) {\n\n                        gen_helper_dvp(t0, cpu_env);\n\n                        gen_store_gpr(t0, rt);\n\n                    }\n\n                    break;\n\n                case OPC_EVP:\n\n                    check_insn(ctx, ISA_MIPS32R6);\n\n                    if (ctx->vp) {\n\n                        gen_helper_evp(t0, cpu_env);\n\n                        gen_store_gpr(t0, rt);\n\n                    }\n\n                    break;\n\n                case OPC_DI:\n\n                    check_insn(ctx, ISA_MIPS32R2);\n\n                    save_cpu_state(ctx, 1);\n\n                    gen_helper_di(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    /* Stop translation as we may have switched\n\n                       the execution mode.  */\n\n                    ctx->bstate = BS_STOP;\n\n                    break;\n\n                case OPC_EI:\n\n                    check_insn(ctx, ISA_MIPS32R2);\n\n                    save_cpu_state(ctx, 1);\n\n                    gen_helper_ei(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    /* Stop translation as we may have switched\n\n                       the execution mode.  */\n\n                    ctx->bstate = BS_STOP;\n\n                    break;\n\n                default:            /* Invalid */\n\n                    MIPS_INVAL(\"mfmc0\");\n\n                    generate_exception_end(ctx, EXCP_RI);\n\n                    break;\n\n                }\n\n                tcg_temp_free(t0);\n\n            }\n\n#endif /* !CONFIG_USER_ONLY */\n\n            break;\n\n        case OPC_RDPGPR:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_load_srsgpr(rt, rd);\n\n            break;\n\n        case OPC_WRPGPR:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_store_srsgpr(rt, rd);\n\n            break;\n\n        default:\n\n            MIPS_INVAL(\"cp0\");\n\n            generate_exception_end(ctx, EXCP_RI);\n\n            break;\n\n        }\n\n        break;\n\n    case OPC_BOVC: /* OPC_BEQZALC, OPC_BEQC, OPC_ADDI */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            /* OPC_BOVC, OPC_BEQZALC, OPC_BEQC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_ADDI */\n\n            /* Arithmetic with immediate opcode */\n\n            gen_arith_imm(ctx, op, rt, rs, imm);\n\n        }\n\n        break;\n\n    case OPC_ADDIU:\n\n         gen_arith_imm(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_SLTI: /* Set on less than with immediate opcode */\n\n    case OPC_SLTIU:\n\n         gen_slt_imm(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_ANDI: /* Arithmetic with immediate opcode */\n\n    case OPC_LUI: /* OPC_AUI */\n\n    case OPC_ORI:\n\n    case OPC_XORI:\n\n         gen_logic_imm(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_J ... OPC_JAL: /* Jump */\n\n         offset = (int32_t)(ctx->opcode & 0x3FFFFFF) << 2;\n\n         gen_compute_branch(ctx, op, 4, rs, rt, offset, 4);\n\n         break;\n\n    /* Branch */\n\n    case OPC_BLEZC: /* OPC_BGEZC, OPC_BGEC, OPC_BLEZL */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            if (rt == 0) {\n\n                generate_exception_end(ctx, EXCP_RI);\n\n                break;\n\n            }\n\n            /* OPC_BLEZC, OPC_BGEZC, OPC_BGEC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_BLEZL */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        }\n\n        break;\n\n    case OPC_BGTZC: /* OPC_BLTZC, OPC_BLTC, OPC_BGTZL */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            if (rt == 0) {\n\n                generate_exception_end(ctx, EXCP_RI);\n\n                break;\n\n            }\n\n            /* OPC_BGTZC, OPC_BLTZC, OPC_BLTC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_BGTZL */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        }\n\n        break;\n\n    case OPC_BLEZALC: /* OPC_BGEZALC, OPC_BGEUC, OPC_BLEZ */\n\n        if (rt == 0) {\n\n            /* OPC_BLEZ */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        } else {\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            /* OPC_BLEZALC, OPC_BGEZALC, OPC_BGEUC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        }\n\n        break;\n\n    case OPC_BGTZALC: /* OPC_BLTZALC, OPC_BLTUC, OPC_BGTZ */\n\n        if (rt == 0) {\n\n            /* OPC_BGTZ */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        } else {\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            /* OPC_BGTZALC, OPC_BLTZALC, OPC_BLTUC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        }\n\n        break;\n\n    case OPC_BEQL:\n\n    case OPC_BNEL:\n\n        check_insn(ctx, ISA_MIPS2);\n\n         check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        /* Fallthrough */\n\n    case OPC_BEQ:\n\n    case OPC_BNE:\n\n         gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n         break;\n\n    case OPC_LL: /* Load and stores */\n\n        check_insn(ctx, ISA_MIPS2);\n\n        /* Fallthrough */\n\n    case OPC_LWL:\n\n    case OPC_LWR:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n         /* Fallthrough */\n\n    case OPC_LB ... OPC_LH:\n\n    case OPC_LW ... OPC_LHU:\n\n         gen_ld(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_SWL:\n\n    case OPC_SWR:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        /* fall through */\n\n    case OPC_SB ... OPC_SH:\n\n    case OPC_SW:\n\n         gen_st(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_SC:\n\n        check_insn(ctx, ISA_MIPS2);\n\n         check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n         gen_st_cond(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_CACHE:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        check_cp0_enabled(ctx);\n\n        check_insn(ctx, ISA_MIPS3 | ISA_MIPS32);\n\n        if (ctx->hflags & MIPS_HFLAG_ITC_CACHE) {\n\n            gen_cache_operation(ctx, rt, rs, imm);\n\n        }\n\n        /* Treat as NOP. */\n\n        break;\n\n    case OPC_PREF:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        check_insn(ctx, ISA_MIPS4 | ISA_MIPS32);\n\n        /* Treat as NOP. */\n\n        break;\n\n\n\n    /* Floating point (COP1). */\n\n    case OPC_LWC1:\n\n    case OPC_LDC1:\n\n    case OPC_SWC1:\n\n    case OPC_SDC1:\n\n        gen_cop1_ldst(ctx, op, rt, rs, imm);\n\n        break;\n\n\n\n    case OPC_CP1:\n\n        op1 = MASK_CP1(ctx->opcode);\n\n\n\n        switch (op1) {\n\n        case OPC_MFHC1:\n\n        case OPC_MTHC1:\n\n            check_cp1_enabled(ctx);\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n        case OPC_MFC1:\n\n        case OPC_CFC1:\n\n        case OPC_MTC1:\n\n        case OPC_CTC1:\n\n            check_cp1_enabled(ctx);\n\n            gen_cp1(ctx, op1, rt, rd);\n\n            break;\n\n#if defined(TARGET_MIPS64)\n\n        case OPC_DMFC1:\n\n        case OPC_DMTC1:\n\n            check_cp1_enabled(ctx);\n\n            check_insn(ctx, ISA_MIPS3);\n\n            check_mips_64(ctx);\n\n            gen_cp1(ctx, op1, rt, rd);\n\n            break;\n\n#endif\n\n        case OPC_BC1EQZ: /* OPC_BC1ANY2 */\n\n            check_cp1_enabled(ctx);\n\n            if (ctx->insn_flags & ISA_MIPS32R6) {\n\n                /* OPC_BC1EQZ */\n\n                gen_compute_branch1_r6(ctx, MASK_CP1(ctx->opcode),\n\n                                       rt, imm << 2, 4);\n\n            } else {\n\n                /* OPC_BC1ANY2 */\n\n                check_cop1x(ctx);\n\n                check_insn(ctx, ASE_MIPS3D);\n\n                gen_compute_branch1(ctx, MASK_BC1(ctx->opcode),\n\n                                    (rt >> 2) & 0x7, imm << 2);\n\n            }\n\n            break;\n\n        case OPC_BC1NEZ:\n\n            check_cp1_enabled(ctx);\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            gen_compute_branch1_r6(ctx, MASK_CP1(ctx->opcode),\n\n                                   rt, imm << 2, 4);\n\n            break;\n\n        case OPC_BC1ANY4:\n\n            check_cp1_enabled(ctx);\n\n            check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n            check_cop1x(ctx);\n\n            check_insn(ctx, ASE_MIPS3D);\n\n            /* fall through */\n\n        case OPC_BC1:\n\n            check_cp1_enabled(ctx);\n\n            check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n            gen_compute_branch1(ctx, MASK_BC1(ctx->opcode),\n\n                                (rt >> 2) & 0x7, imm << 2);\n\n            break;\n\n        case OPC_PS_FMT:\n\n            check_ps(ctx);\n\n            /* fall through */\n\n        case OPC_S_FMT:\n\n        case OPC_D_FMT:\n\n            check_cp1_enabled(ctx);\n\n            gen_farith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa,\n\n                       (imm >> 8) & 0x7);\n\n            break;\n\n        case OPC_W_FMT:\n\n        case OPC_L_FMT:\n\n        {\n\n            int r6_op = ctx->opcode & FOP(0x3f, 0x1f);\n\n            check_cp1_enabled(ctx);\n\n            if (ctx->insn_flags & ISA_MIPS32R6) {\n\n                switch (r6_op) {\n\n                case R6_OPC_CMP_AF_S:\n\n                case R6_OPC_CMP_UN_S:\n\n                case R6_OPC_CMP_EQ_S:\n\n                case R6_OPC_CMP_UEQ_S:\n\n                case R6_OPC_CMP_LT_S:\n\n                case R6_OPC_CMP_ULT_S:\n\n                case R6_OPC_CMP_LE_S:\n\n                case R6_OPC_CMP_ULE_S:\n\n                case R6_OPC_CMP_SAF_S:\n\n                case R6_OPC_CMP_SUN_S:\n\n                case R6_OPC_CMP_SEQ_S:\n\n                case R6_OPC_CMP_SEUQ_S:\n\n                case R6_OPC_CMP_SLT_S:\n\n                case R6_OPC_CMP_SULT_S:\n\n                case R6_OPC_CMP_SLE_S:\n\n                case R6_OPC_CMP_SULE_S:\n\n                case R6_OPC_CMP_OR_S:\n\n                case R6_OPC_CMP_UNE_S:\n\n                case R6_OPC_CMP_NE_S:\n\n                case R6_OPC_CMP_SOR_S:\n\n                case R6_OPC_CMP_SUNE_S:\n\n                case R6_OPC_CMP_SNE_S:\n\n                    gen_r6_cmp_s(ctx, ctx->opcode & 0x1f, rt, rd, sa);\n\n                    break;\n\n                case R6_OPC_CMP_AF_D:\n\n                case R6_OPC_CMP_UN_D:\n\n                case R6_OPC_CMP_EQ_D:\n\n                case R6_OPC_CMP_UEQ_D:\n\n                case R6_OPC_CMP_LT_D:\n\n                case R6_OPC_CMP_ULT_D:\n\n                case R6_OPC_CMP_LE_D:\n\n                case R6_OPC_CMP_ULE_D:\n\n                case R6_OPC_CMP_SAF_D:\n\n                case R6_OPC_CMP_SUN_D:\n\n                case R6_OPC_CMP_SEQ_D:\n\n                case R6_OPC_CMP_SEUQ_D:\n\n                case R6_OPC_CMP_SLT_D:\n\n                case R6_OPC_CMP_SULT_D:\n\n                case R6_OPC_CMP_SLE_D:\n\n                case R6_OPC_CMP_SULE_D:\n\n                case R6_OPC_CMP_OR_D:\n\n                case R6_OPC_CMP_UNE_D:\n\n                case R6_OPC_CMP_NE_D:\n\n                case R6_OPC_CMP_SOR_D:\n\n                case R6_OPC_CMP_SUNE_D:\n\n                case R6_OPC_CMP_SNE_D:\n\n                    gen_r6_cmp_d(ctx, ctx->opcode & 0x1f, rt, rd, sa);\n\n                    break;\n\n                default:\n\n                    gen_farith(ctx, ctx->opcode & FOP(0x3f, 0x1f),\n\n                               rt, rd, sa, (imm >> 8) & 0x7);\n\n\n\n                    break;\n\n                }\n\n            } else {\n\n                gen_farith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa,\n\n                           (imm >> 8) & 0x7);\n\n            }\n\n            break;\n\n        }\n\n        case OPC_BZ_V:\n\n        case OPC_BNZ_V:\n\n        case OPC_BZ_B:\n\n        case OPC_BZ_H:\n\n        case OPC_BZ_W:\n\n        case OPC_BZ_D:\n\n        case OPC_BNZ_B:\n\n        case OPC_BNZ_H:\n\n        case OPC_BNZ_W:\n\n        case OPC_BNZ_D:\n\n            check_insn(ctx, ASE_MSA);\n\n            gen_msa_branch(env, ctx, op1);\n\n            break;\n\n        default:\n\n            MIPS_INVAL(\"cp1\");\n\n            generate_exception_end(ctx, EXCP_RI);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    /* Compact branches [R6] and COP2 [non-R6] */\n\n    case OPC_BC: /* OPC_LWC2 */\n\n    case OPC_BALC: /* OPC_SWC2 */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            /* OPC_BC, OPC_BALC */\n\n            gen_compute_compact_branch(ctx, op, 0, 0,\n\n                                       sextract32(ctx->opcode << 2, 0, 28));\n\n        } else {\n\n            /* OPC_LWC2, OPC_SWC2 */\n\n            /* COP2: Not implemented. */\n\n            generate_exception_err(ctx, EXCP_CpU, 2);\n\n        }\n\n        break;\n\n    case OPC_BEQZC: /* OPC_JIC, OPC_LDC2 */\n\n    case OPC_BNEZC: /* OPC_JIALC, OPC_SDC2 */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            if (rs != 0) {\n\n                /* OPC_BEQZC, OPC_BNEZC */\n\n                gen_compute_compact_branch(ctx, op, rs, 0,\n\n                                           sextract32(ctx->opcode << 2, 0, 23));\n\n            } else {\n\n                /* OPC_JIC, OPC_JIALC */\n\n                gen_compute_compact_branch(ctx, op, 0, rt, imm);\n\n            }\n\n        } else {\n\n            /* OPC_LWC2, OPC_SWC2 */\n\n            /* COP2: Not implemented. */\n\n            generate_exception_err(ctx, EXCP_CpU, 2);\n\n        }\n\n        break;\n\n    case OPC_CP2:\n\n        check_insn(ctx, INSN_LOONGSON2F);\n\n        /* Note that these instructions use different fields.  */\n\n        gen_loongson_multimedia(ctx, sa, rd, rt);\n\n        break;\n\n\n\n    case OPC_CP3:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        if (ctx->CP0_Config1 & (1 << CP0C1_FP)) {\n\n            check_cp1_enabled(ctx);\n\n            op1 = MASK_CP3(ctx->opcode);\n\n            switch (op1) {\n\n            case OPC_LUXC1:\n\n            case OPC_SUXC1:\n\n                check_insn(ctx, ISA_MIPS5 | ISA_MIPS32R2);\n\n                /* Fallthrough */\n\n            case OPC_LWXC1:\n\n            case OPC_LDXC1:\n\n            case OPC_SWXC1:\n\n            case OPC_SDXC1:\n\n                check_insn(ctx, ISA_MIPS4 | ISA_MIPS32R2);\n\n                gen_flt3_ldst(ctx, op1, sa, rd, rs, rt);\n\n                break;\n\n            case OPC_PREFX:\n\n                check_insn(ctx, ISA_MIPS4 | ISA_MIPS32R2);\n\n                /* Treat as NOP. */\n\n                break;\n\n            case OPC_ALNV_PS:\n\n                check_insn(ctx, ISA_MIPS5 | ISA_MIPS32R2);\n\n                /* Fallthrough */\n\n            case OPC_MADD_S:\n\n            case OPC_MADD_D:\n\n            case OPC_MADD_PS:\n\n            case OPC_MSUB_S:\n\n            case OPC_MSUB_D:\n\n            case OPC_MSUB_PS:\n\n            case OPC_NMADD_S:\n\n            case OPC_NMADD_D:\n\n            case OPC_NMADD_PS:\n\n            case OPC_NMSUB_S:\n\n            case OPC_NMSUB_D:\n\n            case OPC_NMSUB_PS:\n\n                check_insn(ctx, ISA_MIPS4 | ISA_MIPS32R2);\n\n                gen_flt3_arith(ctx, op1, sa, rs, rd, rt);\n\n                break;\n\n            default:\n\n                MIPS_INVAL(\"cp3\");\n\n                generate_exception_end(ctx, EXCP_RI);\n\n                break;\n\n            }\n\n        } else {\n\n            generate_exception_err(ctx, EXCP_CpU, 1);\n\n        }\n\n        break;\n\n\n\n#if defined(TARGET_MIPS64)\n\n    /* MIPS64 opcodes */\n\n    case OPC_LDL ... OPC_LDR:\n\n    case OPC_LLD:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        /* fall through */\n\n    case OPC_LWU:\n\n    case OPC_LD:\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_ld(ctx, op, rt, rs, imm);\n\n        break;\n\n    case OPC_SDL ... OPC_SDR:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        /* fall through */\n\n    case OPC_SD:\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_st(ctx, op, rt, rs, imm);\n\n        break;\n\n    case OPC_SCD:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_st_cond(ctx, op, rt, rs, imm);\n\n        break;\n\n    case OPC_BNVC: /* OPC_BNEZALC, OPC_BNEC, OPC_DADDI */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            /* OPC_BNVC, OPC_BNEZALC, OPC_BNEC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_DADDI */\n\n            check_insn(ctx, ISA_MIPS3);\n\n            check_mips_64(ctx);\n\n            gen_arith_imm(ctx, op, rt, rs, imm);\n\n        }\n\n        break;\n\n    case OPC_DADDIU:\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_arith_imm(ctx, op, rt, rs, imm);\n\n        break;\n\n#else\n\n    case OPC_BNVC: /* OPC_BNEZALC, OPC_BNEC */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            MIPS_INVAL(\"major opcode\");\n\n            generate_exception_end(ctx, EXCP_RI);\n\n        }\n\n        break;\n\n#endif\n\n    case OPC_DAUI: /* OPC_JALX */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n#if defined(TARGET_MIPS64)\n\n            /* OPC_DAUI */\n\n            check_mips_64(ctx);\n\n            if (rs == 0) {\n\n                generate_exception(ctx, EXCP_RI);\n\n            } else if (rt != 0) {\n\n                TCGv t0 = tcg_temp_new();\n\n                gen_load_gpr(t0, rs);\n\n                tcg_gen_addi_tl(cpu_gpr[rt], t0, imm << 16);\n\n                tcg_temp_free(t0);\n\n            }\n\n#else\n\n            generate_exception_end(ctx, EXCP_RI);\n\n            MIPS_INVAL(\"major opcode\");\n\n#endif\n\n        } else {\n\n            /* OPC_JALX */\n\n            check_insn(ctx, ASE_MIPS16 | ASE_MICROMIPS);\n\n            offset = (int32_t)(ctx->opcode & 0x3FFFFFF) << 2;\n\n            gen_compute_branch(ctx, op, 4, rs, rt, offset, 4);\n\n        }\n\n        break;\n\n    case OPC_MSA: /* OPC_MDMX */\n\n        /* MDMX: Not implemented. */\n\n        gen_msa(env, ctx);\n\n        break;\n\n    case OPC_PCREL:\n\n        check_insn(ctx, ISA_MIPS32R6);\n\n        gen_pcrel(ctx, ctx->opcode, ctx->pc, rs);\n\n        break;\n\n    default:            /* Invalid */\n\n        MIPS_INVAL(\"major opcode\");\n\n        generate_exception_end(ctx, EXCP_RI);\n\n        break;\n\n    }\n\n}\n", "idx": 22422}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static int vnc_zlib_stop(VncState *vs)\n\n{\n\n    z_streamp zstream = &vs->zlib_stream;\n\n    int previous_out;\n\n\n\n    // switch back to normal output/zlib buffers\n\n    vs->zlib = vs->output;\n\n    vs->output = vs->zlib_tmp;\n\n\n\n    // compress the zlib buffer\n\n\n\n    // initialize the stream\n\n    // XXX need one stream per session\n\n    if (zstream->opaque != vs) {\n\n        int err;\n\n\n\n        VNC_DEBUG(\"VNC: initializing zlib stream\\n\");\n\n        VNC_DEBUG(\"VNC: opaque = %p | vs = %p\\n\", zstream->opaque, vs);\n\n        zstream->zalloc = vnc_zlib_zalloc;\n\n        zstream->zfree = vnc_zlib_zfree;\n\n\n\n        err = deflateInit2(zstream, vs->tight_compression, Z_DEFLATED, MAX_WBITS,\n\n                           MAX_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n\n\n\n        if (err != Z_OK) {\n\n            fprintf(stderr, \"VNC: error initializing zlib\\n\");\n\n            return -1;\n\n        }\n\n\n\n        vs->zlib_level = vs->tight_compression;\n\n        zstream->opaque = vs;\n\n    }\n\n\n\n    if (vs->tight_compression != vs->zlib_level) {\n\n        if (deflateParams(zstream, vs->tight_compression,\n\n                          Z_DEFAULT_STRATEGY) != Z_OK) {\n\n            return -1;\n\n        }\n\n        vs->zlib_level = vs->tight_compression;\n\n    }\n\n\n\n    // reserve memory in output buffer\n\n    buffer_reserve(&vs->output, vs->zlib.offset + 64);\n\n\n\n    // set pointers\n\n    zstream->next_in = vs->zlib.buffer;\n\n    zstream->avail_in = vs->zlib.offset;\n\n    zstream->next_out = vs->output.buffer + vs->output.offset;\n\n    zstream->avail_out = vs->output.capacity - vs->output.offset;\n\n    zstream->data_type = Z_BINARY;\n\n    previous_out = zstream->total_out;\n\n\n\n    // start encoding\n\n    if (deflate(zstream, Z_SYNC_FLUSH) != Z_OK) {\n\n        fprintf(stderr, \"VNC: error during zlib compression\\n\");\n\n        return -1;\n\n    }\n\n\n\n    vs->output.offset = vs->output.capacity - zstream->avail_out;\n\n    return zstream->total_out - previous_out;\n\n}\n", "idx": 22423}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void pl080_class_init(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n    dc->no_user = 1;\n\n    dc->vmsd = &vmstate_pl080;\n\n}\n", "idx": 22427}
{"project": "qemu", "commit_id": "3a4496903795e05c1e8367bb4c9862d5670f48d7", "target": 1, "func": "static void guest_panicked(void)\n\n{\n\n    QObject *data;\n\n\n\n    data = qobject_from_jsonf(\"{ 'action': %s }\", \"pause\");\n\n    monitor_protocol_event(QEVENT_GUEST_PANICKED, data);\n\n    qobject_decref(data);\n\n\n\n    vm_stop(RUN_STATE_GUEST_PANICKED);\n\n}\n", "idx": 22428}
{"project": "qemu", "commit_id": "e5f34cdd2da54f28d90889a3afd15fad2d6105ff", "target": 1, "func": "void vnc_init_state(VncState *vs)\n\n{\n\n    vs->initialized = true;\n\n    VncDisplay *vd = vs->vd;\n\n\n\n    vs->last_x = -1;\n\n    vs->last_y = -1;\n\n\n\n    vs->as.freq = 44100;\n\n    vs->as.nchannels = 2;\n\n    vs->as.fmt = AUD_FMT_S16;\n\n    vs->as.endianness = 0;\n\n\n\n    qemu_mutex_init(&vs->output_mutex);\n\n    vs->bh = qemu_bh_new(vnc_jobs_bh, vs);\n\n\n\n    QTAILQ_INSERT_HEAD(&vd->clients, vs, next);\n\n\n\n    graphic_hw_update(vd->dcl.con);\n\n\n\n    vnc_write(vs, \"RFB 003.008\\n\", 12);\n\n    vnc_flush(vs);\n\n    vnc_read_when(vs, protocol_version, 12);\n\n    reset_keys(vs);\n\n    if (vs->vd->lock_key_sync)\n\n        vs->led = qemu_add_led_event_handler(kbd_leds, vs);\n\n\n\n    vs->mouse_mode_notifier.notify = check_pointer_type_change;\n\n    qemu_add_mouse_mode_change_notifier(&vs->mouse_mode_notifier);\n\n\n\n    /* vs might be free()ed here */\n\n}\n", "idx": 22430}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_file_set_error(QEMUFile *f, int ret)\n\n{\n\n    if (f->last_error == 0) {\n\n        f->last_error = ret;\n\n    }\n\n}\n", "idx": 22431}
{"project": "qemu", "commit_id": "36bed541ca886da735bef1e8d76d09f8849ed5dd", "target": 1, "func": "static void puv3_load_kernel(const char *kernel_filename)\n\n{\n\n    int size;\n\n\n\n    if (kernel_filename == NULL && qtest_enabled()) {\n\n        return;\n\n    }\n\n    assert(kernel_filename != NULL);\n\n\n\n    /* only zImage format supported */\n\n    size = load_image_targphys(kernel_filename, KERNEL_LOAD_ADDR,\n\n            KERNEL_MAX_SIZE);\n\n    if (size < 0) {\n\n        error_report(\"Load kernel error: '%s'\", kernel_filename);\n\n        exit(1);\n\n    }\n\n\n\n    /* cheat curses that we have a graphic console, only under ocd console */\n\n    graphic_console_init(NULL, 0, &no_ops, NULL);\n\n}\n", "idx": 22432}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void init_blk_migration(QEMUFile *f)\n\n{\n\n    BlockDriverState *bs;\n\n    BlkMigDevState *bmds;\n\n    int64_t sectors;\n\n\n\n    block_mig_state.submitted = 0;\n\n    block_mig_state.read_done = 0;\n\n    block_mig_state.transferred = 0;\n\n    block_mig_state.total_sector_sum = 0;\n\n    block_mig_state.prev_progress = -1;\n\n    block_mig_state.bulk_completed = 0;\n\n    block_mig_state.zero_blocks = migrate_zero_blocks();\n\n\n\n    for (bs = bdrv_next(NULL); bs; bs = bdrv_next(bs)) {\n\n        if (bdrv_is_read_only(bs)) {\n\n            continue;\n\n        }\n\n\n\n        sectors = bdrv_nb_sectors(bs);\n\n        if (sectors <= 0) {\n\n            return;\n\n        }\n\n\n\n        bmds = g_new0(BlkMigDevState, 1);\n\n        bmds->bs = bs;\n\n        bmds->bulk_completed = 0;\n\n        bmds->total_sectors = sectors;\n\n        bmds->completed_sectors = 0;\n\n        bmds->shared_base = block_mig_state.shared_base;\n\n        alloc_aio_bitmap(bmds);\n\n        error_setg(&bmds->blocker, \"block device is in use by migration\");\n\n        bdrv_op_block_all(bs, bmds->blocker);\n\n        bdrv_ref(bs);\n\n\n\n        block_mig_state.total_sector_sum += sectors;\n\n\n\n        if (bmds->shared_base) {\n\n            DPRINTF(\"Start migration for %s with shared base image\\n\",\n\n                    bdrv_get_device_name(bs));\n\n        } else {\n\n            DPRINTF(\"Start full migration for %s\\n\", bdrv_get_device_name(bs));\n\n        }\n\n\n\n        QSIMPLEQ_INSERT_TAIL(&block_mig_state.bmds_list, bmds, entry);\n\n    }\n\n}\n", "idx": 22434}
{"project": "qemu", "commit_id": "361dcc790db8c87b2e46ab610739191ced894c44", "target": 1, "func": "void virtio_scsi_dataplane_stop(VirtIOSCSI *s)\n\n{\n\n    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(s)));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(s);\n\n    int i;\n\n\n\n    if (!s->dataplane_started || s->dataplane_stopping) {\n\n        return;\n\n    }\n\n    error_free(s->blocker);\n\n    s->blocker = NULL;\n\n    s->dataplane_stopping = true;\n\n    assert(s->ctx == iothread_get_aio_context(vs->conf.iothread));\n\n\n\n    aio_context_acquire(s->ctx);\n\n\n\n    aio_set_event_notifier(s->ctx, &s->ctrl_vring->host_notifier, NULL);\n\n    aio_set_event_notifier(s->ctx, &s->event_vring->host_notifier, NULL);\n\n    for (i = 0; i < vs->conf.num_queues; i++) {\n\n        aio_set_event_notifier(s->ctx, &s->cmd_vrings[i]->host_notifier, NULL);\n\n    }\n\n\n\n    blk_drain_all(); /* ensure there are no in-flight requests */\n\n\n\n    aio_context_release(s->ctx);\n\n\n\n    /* Sync vring state back to virtqueue so that non-dataplane request\n\n     * processing can continue when we disable the host notifier below.\n\n     */\n\n    vring_teardown(&s->ctrl_vring->vring, vdev, 0);\n\n    vring_teardown(&s->event_vring->vring, vdev, 1);\n\n    for (i = 0; i < vs->conf.num_queues; i++) {\n\n        vring_teardown(&s->cmd_vrings[i]->vring, vdev, 2 + i);\n\n    }\n\n\n\n    for (i = 0; i < vs->conf.num_queues + 2; i++) {\n\n        k->set_host_notifier(qbus->parent, i, false);\n\n    }\n\n\n\n    /* Clean up guest notifier (irq) */\n\n    k->set_guest_notifiers(qbus->parent, vs->conf.num_queues + 2, false);\n\n    s->dataplane_stopping = false;\n\n    s->dataplane_started = false;\n\n}\n", "idx": 22438}
{"project": "qemu", "commit_id": "48779e501810c5046ff8af7b9cf9c99bec2928a1", "target": 1, "func": "static void fw_cfg_boot_set(void *opaque, const char *boot_device,\n\n                            Error **errp)\n\n{\n\n    fw_cfg_add_i16(opaque, FW_CFG_BOOT_DEVICE, boot_device[0]);\n\n}\n", "idx": 22439}
{"project": "qemu", "commit_id": "6b37a23df98faa26391a93373930bfb15b943e00", "target": 1, "func": "static int vhost_sync_dirty_bitmap(struct vhost_dev *dev,\n\n                                   MemoryRegionSection *section,\n\n                                   hwaddr start_addr,\n\n                                   hwaddr end_addr)\n\n{\n\n    int i;\n\n\n\n    if (!dev->log_enabled || !dev->started) {\n\n        return 0;\n\n    }\n\n    for (i = 0; i < dev->mem->nregions; ++i) {\n\n        struct vhost_memory_region *reg = dev->mem->regions + i;\n\n        vhost_dev_sync_region(dev, section, start_addr, end_addr,\n\n                              reg->guest_phys_addr,\n\n                              range_get_last(reg->guest_phys_addr,\n\n                                             reg->memory_size));\n\n    }\n\n    for (i = 0; i < dev->nvqs; ++i) {\n\n        struct vhost_virtqueue *vq = dev->vqs + i;\n\n        vhost_dev_sync_region(dev, section, start_addr, end_addr, vq->used_phys,\n\n                              range_get_last(vq->used_phys, vq->used_size));\n\n    }\n\n    return 0;\n\n}\n", "idx": 22440}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void cris_cpu_class_init(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(oc);\n\n    CRISCPUClass *ccc = CRIS_CPU_CLASS(oc);\n\n\n\n    ccc->parent_realize = dc->realize;\n\n    dc->realize = cris_cpu_realizefn;\n\n\n\n    ccc->parent_reset = cc->reset;\n\n    cc->reset = cris_cpu_reset;\n\n\n\n    cc->class_by_name = cris_cpu_class_by_name;\n\n    cc->has_work = cris_cpu_has_work;\n\n    cc->do_interrupt = cris_cpu_do_interrupt;\n\n    cc->cpu_exec_interrupt = cris_cpu_exec_interrupt;\n\n    cc->dump_state = cris_cpu_dump_state;\n\n    cc->set_pc = cris_cpu_set_pc;\n\n    cc->gdb_read_register = cris_cpu_gdb_read_register;\n\n    cc->gdb_write_register = cris_cpu_gdb_write_register;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = cris_cpu_handle_mmu_fault;\n\n#else\n\n    cc->get_phys_page_debug = cris_cpu_get_phys_page_debug;\n\n    dc->vmsd = &vmstate_cris_cpu;\n\n#endif\n\n\n\n    cc->gdb_num_core_regs = 49;\n\n    cc->gdb_stop_before_watchpoint = true;\n\n\n\n    cc->disas_set_info = cris_disas_set_info;\n\n\n\n    /*\n\n     * Reason: cris_cpu_initfn() calls cpu_exec_init(), which saves\n\n     * the object in cpus -> dangling pointer after final\n\n     * object_unref().\n\n     */\n\n    dc->cannot_destroy_with_object_finalize_yet = true;\n\n}\n", "idx": 22441}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void blk_mig_lock(void)\n\n{\n\n    qemu_mutex_lock(&block_mig_state.lock);\n\n}\n", "idx": 22443}
{"project": "qemu", "commit_id": "2d3e302ec2246d703ffa8d8f8769a3fa448d8145", "target": 1, "func": "bool kvmppc_is_mem_backend_page_size_ok(const char *obj_path)\n\n{\n\n    Object *mem_obj = object_resolve_path(obj_path, NULL);\n\n    char *mempath = object_property_get_str(mem_obj, \"mem-path\", NULL);\n\n    long pagesize;\n\n\n\n    if (mempath) {\n\n        pagesize = qemu_mempath_getpagesize(mempath);\n\n\n    } else {\n\n        pagesize = getpagesize();\n\n    }\n\n\n\n    return pagesize >= max_cpu_page_size;\n\n}", "idx": 22444}
{"project": "qemu", "commit_id": "eb513f82f04fab442cdef9db698dafc852275f7f", "target": 1, "func": "void helper_ldqf(CPUSPARCState *env, target_ulong addr, int mem_idx)\n\n{\n\n    /* XXX add 128 bit load */\n\n    CPU_QuadU u;\n\n\n\n    helper_check_align(env, addr, 7);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    switch (mem_idx) {\n\n    case MMU_USER_IDX:\n\n        u.ll.upper = cpu_ldq_user(env, addr);\n\n        u.ll.lower = cpu_ldq_user(env, addr + 8);\n\n        QT0 = u.q;\n\n        break;\n\n    case MMU_KERNEL_IDX:\n\n        u.ll.upper = cpu_ldq_kernel(env, addr);\n\n        u.ll.lower = cpu_ldq_kernel(env, addr + 8);\n\n        QT0 = u.q;\n\n        break;\n\n#ifdef TARGET_SPARC64\n\n    case MMU_HYPV_IDX:\n\n        u.ll.upper = cpu_ldq_hypv(env, addr);\n\n        u.ll.lower = cpu_ldq_hypv(env, addr + 8);\n\n        QT0 = u.q;\n\n        break;\n\n#endif\n\n    default:\n\n        DPRINTF_MMU(\"helper_ldqf: need to check MMU idx %d\\n\", mem_idx);\n\n        break;\n\n    }\n\n#else\n\n    u.ll.upper = ldq_raw(address_mask(env, addr));\n\n    u.ll.lower = ldq_raw(address_mask(env, addr + 8));\n\n    QT0 = u.q;\n\n#endif\n\n}\n", "idx": 22446}
{"project": "qemu", "commit_id": "f2d089425d43735b5369f70f3a36b712440578e5", "target": 1, "func": "static MemTxResult memory_region_write_accessor(MemoryRegion *mr,\n\n                                                hwaddr addr,\n\n                                                uint64_t *value,\n\n                                                unsigned size,\n\n                                                unsigned shift,\n\n                                                uint64_t mask,\n\n                                                MemTxAttrs attrs)\n\n{\n\n    uint64_t tmp;\n\n\n\n    tmp = (*value >> shift) & mask;\n\n    if (mr->subpage) {\n\n        trace_memory_region_subpage_write(get_cpu_index(), mr, addr, tmp, size);\n\n\n\n\n\n\n    } else if (TRACE_MEMORY_REGION_OPS_WRITE_ENABLED) {\n\n        hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);\n\n        trace_memory_region_ops_write(get_cpu_index(), mr, abs_addr, tmp, size);\n\n    }\n\n    mr->ops->write(mr->opaque, addr, tmp, size);\n\n    return MEMTX_OK;\n\n}", "idx": 22449}
{"project": "qemu", "commit_id": "a083a89d7277f3268a251ce635d9aae5559242bd", "target": 1, "func": "void qemu_del_vlan_client(VLANClientState *vc)\n\n{\n\n    if (vc->vlan) {\n\n        QTAILQ_REMOVE(&vc->vlan->clients, vc, next);\n\n    } else {\n\n        if (vc->send_queue) {\n\n            qemu_del_net_queue(vc->send_queue);\n\n        }\n\n        QTAILQ_REMOVE(&non_vlan_clients, vc, next);\n\n        if (vc->peer) {\n\n            vc->peer->peer = NULL;\n\n        }\n\n    }\n\n\n\n    if (vc->info->cleanup) {\n\n        vc->info->cleanup(vc);\n\n    }\n\n\n\n    qemu_free(vc->name);\n\n    qemu_free(vc->model);\n\n    qemu_free(vc);\n\n}\n", "idx": 22450}
{"project": "qemu", "commit_id": "65207c59d99f2260c5f1d3b9c491146616a522aa", "target": 1, "func": "static void user_monitor_complete(void *opaque, QObject *ret_data)\n\n{\n\n    MonitorCompletionData *data = (MonitorCompletionData *)opaque; \n\n\n\n    if (ret_data) {\n\n        data->user_print(data->mon, ret_data);\n\n    }\n\n    monitor_resume(data->mon);\n\n    g_free(data);\n\n}\n", "idx": 22452}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint64_t helper_efdctuidz (uint64_t val)\n\n{\n\n    CPU_DoubleU u;\n\n\n\n    u.ll = val;\n\n    /* NaN are not treated the same way IEEE 754 does */\n\n    if (unlikely(float64_is_nan(u.d)))\n\n        return 0;\n\n\n\n    return float64_to_uint64_round_to_zero(u.d, &env->vec_status);\n\n}\n", "idx": 22462}
{"project": "qemu", "commit_id": "5819e3e072f41cbf81ad80d822a5c468a91f54e0", "target": 0, "func": "static void put_buffer(GDBState *s, const uint8_t *buf, int len)\n\n{\n\n#ifdef CONFIG_USER_ONLY\n\n    int ret;\n\n\n\n    while (len > 0) {\n\n        ret = send(s->fd, buf, len, 0);\n\n        if (ret < 0) {\n\n            if (errno != EINTR && errno != EAGAIN)\n\n                return;\n\n        } else {\n\n            buf += ret;\n\n            len -= ret;\n\n        }\n\n    }\n\n#else\n\n    qemu_chr_fe_write(s->chr, buf, len);\n\n#endif\n\n}\n", "idx": 22463}
{"project": "qemu", "commit_id": "ac531cb6e542b1e61d668604adf9dc5306a948c0", "target": 0, "func": "static Suite *qdict_suite(void)\n\n{\n\n    Suite *s;\n\n    TCase *qdict_public_tcase;\n\n    TCase *qdict_public2_tcase;\n\n    TCase *qdict_stress_tcase;\n\n    TCase *qdict_errors_tcase;\n\n\n\n    s = suite_create(\"QDict test-suite\");\n\n\n\n    qdict_public_tcase = tcase_create(\"Public Interface\");\n\n    suite_add_tcase(s, qdict_public_tcase);\n\n    tcase_add_test(qdict_public_tcase, qdict_new_test);\n\n    tcase_add_test(qdict_public_tcase, qdict_put_obj_test);\n\n    tcase_add_test(qdict_public_tcase, qdict_destroy_simple_test);\n\n\n\n    /* Continue, but now with fixtures */\n\n    qdict_public2_tcase = tcase_create(\"Public Interface (2)\");\n\n    suite_add_tcase(s, qdict_public2_tcase);\n\n    tcase_add_checked_fixture(qdict_public2_tcase, qdict_setup, qdict_teardown);\n\n    tcase_add_test(qdict_public2_tcase, qdict_get_test);\n\n    tcase_add_test(qdict_public2_tcase, qdict_get_int_test);\n\n    tcase_add_test(qdict_public2_tcase, qdict_get_try_int_test);\n\n    tcase_add_test(qdict_public2_tcase, qdict_get_str_test);\n\n    tcase_add_test(qdict_public2_tcase, qdict_get_try_str_test);\n\n    tcase_add_test(qdict_public2_tcase, qdict_haskey_not_test);\n\n    tcase_add_test(qdict_public2_tcase, qdict_haskey_test);\n\n    tcase_add_test(qdict_public2_tcase, qdict_del_test);\n\n    tcase_add_test(qdict_public2_tcase, qobject_to_qdict_test);\n\n    tcase_add_test(qdict_public2_tcase, qdict_iterapi_test);\n\n\n\n    qdict_errors_tcase = tcase_create(\"Errors\");\n\n    suite_add_tcase(s, qdict_errors_tcase);\n\n    tcase_add_checked_fixture(qdict_errors_tcase, qdict_setup, qdict_teardown);\n\n    tcase_add_test(qdict_errors_tcase, qdict_put_exists_test);\n\n    tcase_add_test(qdict_errors_tcase, qdict_get_not_exists_test);\n\n\n\n    /* The Big one */\n\n    qdict_stress_tcase = tcase_create(\"Stress Test\");\n\n    suite_add_tcase(s, qdict_stress_tcase);\n\n    tcase_add_test(qdict_stress_tcase, qdict_stress_test);\n\n\n\n    return s;\n\n}\n", "idx": 22464}
{"project": "qemu", "commit_id": "28213cb6a61a724e2cb1e3a76d2bb17aa0ce9b36", "target": 0, "func": "void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *file_name,\n\n                                     void *start, unsigned size,\n\n                                     uint8_t *checksum)\n\n{\n\n    BiosLinkerLoaderEntry entry;\n\n    const BiosLinkerFileEntry *file = bios_linker_find_file(linker, file_name);\n\n    ptrdiff_t checksum_offset = (gchar *)checksum - file->blob->data;\n\n    ptrdiff_t start_offset = (gchar *)start - file->blob->data;\n\n\n\n    assert(checksum_offset >= 0);\n\n    assert(start_offset >= 0);\n\n    assert(checksum_offset + 1 <= file->blob->len);\n\n    assert(start_offset + size <= file->blob->len);\n\n    assert(*checksum == 0x0);\n\n\n\n    memset(&entry, 0, sizeof entry);\n\n    strncpy(entry.cksum.file, file_name, sizeof entry.cksum.file - 1);\n\n    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);\n\n    entry.cksum.offset = cpu_to_le32(checksum_offset);\n\n    entry.cksum.start = cpu_to_le32(start_offset);\n\n    entry.cksum.length = cpu_to_le32(size);\n\n\n\n    g_array_append_vals(linker->cmd_blob, &entry, sizeof entry);\n\n}\n", "idx": 22465}
{"project": "qemu", "commit_id": "4086182fcd9b106345b5cc535d78bcc6d13a7683", "target": 0, "func": "static void handle_qmp_command(JSONMessageParser *parser, QList *tokens)\n\n{\n\n    Error *local_err = NULL;\n\n    QObject *obj, *data;\n\n    QDict *input, *args;\n\n    const mon_cmd_t *cmd;\n\n    const char *cmd_name;\n\n    Monitor *mon = cur_mon;\n\n\n\n    args = input = NULL;\n\n    data = NULL;\n\n\n\n    obj = json_parser_parse(tokens, NULL);\n\n    if (!obj) {\n\n        // FIXME: should be triggered in json_parser_parse()\n\n        qerror_report(QERR_JSON_PARSING);\n\n        goto err_out;\n\n    }\n\n\n\n    input = qmp_check_input_obj(obj, &local_err);\n\n    if (!input) {\n\n        qerror_report_err(local_err);\n\n        qobject_decref(obj);\n\n        goto err_out;\n\n    }\n\n\n\n    mon->mc->id = qdict_get(input, \"id\");\n\n    qobject_incref(mon->mc->id);\n\n\n\n    cmd_name = qdict_get_str(input, \"execute\");\n\n    trace_handle_qmp_command(mon, cmd_name);\n\n    cmd = qmp_find_cmd(cmd_name);\n\n    if (!cmd) {\n\n        qerror_report(ERROR_CLASS_COMMAND_NOT_FOUND,\n\n                      \"The command %s has not been found\", cmd_name);\n\n        goto err_out;\n\n    }\n\n    if (invalid_qmp_mode(mon, cmd)) {\n\n        goto err_out;\n\n    }\n\n\n\n    obj = qdict_get(input, \"arguments\");\n\n    if (!obj) {\n\n        args = qdict_new();\n\n    } else {\n\n        args = qobject_to_qdict(obj);\n\n        QINCREF(args);\n\n    }\n\n\n\n    qmp_check_client_args(cmd, args, &local_err);\n\n    if (local_err) {\n\n        qerror_report_err(local_err);\n\n        goto err_out;\n\n    }\n\n\n\n    if (cmd->mhandler.cmd_new(mon, args, &data)) {\n\n        /* Command failed... */\n\n        if (!monitor_has_error(mon)) {\n\n            /* ... without setting an error, so make one up */\n\n            qerror_report(QERR_UNDEFINED_ERROR);\n\n        }\n\n    }\n\n\n\nerr_out:\n\n    monitor_protocol_emitter(mon, data);\n\n    qobject_decref(data);\n\n    QDECREF(input);\n\n    QDECREF(args);\n\n}\n", "idx": 22466}
{"project": "qemu", "commit_id": "9e41bade85ef338afd983c109368d1bbbe931f80", "target": 0, "func": "static void aer915_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    I2CSlaveClass *k = I2C_SLAVE_CLASS(klass);\n\n\n\n    k->init = aer915_init;\n\n    k->event = aer915_event;\n\n    k->recv = aer915_recv;\n\n    k->send = aer915_send;\n\n    dc->vmsd = &vmstate_aer915_state;\n\n}\n", "idx": 22467}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t mcf_fec_read(void *opaque, target_phys_addr_t addr,\n\n                             unsigned size)\n\n{\n\n    mcf_fec_state *s = (mcf_fec_state *)opaque;\n\n    switch (addr & 0x3ff) {\n\n    case 0x004: return s->eir;\n\n    case 0x008: return s->eimr;\n\n    case 0x010: return s->rx_enabled ? (1 << 24) : 0; /* RDAR */\n\n    case 0x014: return 0; /* TDAR */\n\n    case 0x024: return s->ecr;\n\n    case 0x040: return s->mmfr;\n\n    case 0x044: return s->mscr;\n\n    case 0x064: return 0; /* MIBC */\n\n    case 0x084: return s->rcr;\n\n    case 0x0c4: return s->tcr;\n\n    case 0x0e4: /* PALR */\n\n        return (s->conf.macaddr.a[0] << 24) | (s->conf.macaddr.a[1] << 16)\n\n              | (s->conf.macaddr.a[2] << 8) | s->conf.macaddr.a[3];\n\n        break;\n\n    case 0x0e8: /* PAUR */\n\n        return (s->conf.macaddr.a[4] << 24) | (s->conf.macaddr.a[5] << 16) | 0x8808;\n\n    case 0x0ec: return 0x10000; /* OPD */\n\n    case 0x118: return 0;\n\n    case 0x11c: return 0;\n\n    case 0x120: return 0;\n\n    case 0x124: return 0;\n\n    case 0x144: return s->tfwr;\n\n    case 0x14c: return 0x600;\n\n    case 0x150: return s->rfsr;\n\n    case 0x180: return s->erdsr;\n\n    case 0x184: return s->etdsr;\n\n    case 0x188: return s->emrbr;\n\n    default:\n\n        hw_error(\"mcf_fec_read: Bad address 0x%x\\n\", (int)addr);\n\n        return 0;\n\n    }\n\n}\n", "idx": 22469}
{"project": "qemu", "commit_id": "36778660d7fd0748a6129916e47ecedd67bdb758", "target": 0, "func": "static hwaddr ppc_hash64_pteg_search(PowerPCCPU *cpu, hwaddr hash,\n\n                                     const struct ppc_one_seg_page_size *sps,\n\n                                     target_ulong ptem,\n\n                                     ppc_hash_pte64_t *pte, unsigned *pshift)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    int i;\n\n    const ppc_hash_pte64_t *pteg;\n\n    target_ulong pte0, pte1;\n\n    target_ulong ptex;\n\n\n\n    ptex = (hash & env->htab_mask) * HPTES_PER_GROUP;\n\n    pteg = ppc_hash64_map_hptes(cpu, ptex, HPTES_PER_GROUP);\n\n    if (!pteg) {\n\n        return -1;\n\n    }\n\n    for (i = 0; i < HPTES_PER_GROUP; i++) {\n\n        pte0 = ppc_hash64_hpte0(cpu, pteg, i);\n\n        pte1 = ppc_hash64_hpte1(cpu, pteg, i);\n\n\n\n        /* This compares V, B, H (secondary) and the AVPN */\n\n        if (HPTE64_V_COMPARE(pte0, ptem)) {\n\n            *pshift = hpte_page_shift(sps, pte0, pte1);\n\n            /*\n\n             * If there is no match, ignore the PTE, it could simply\n\n             * be for a different segment size encoding and the\n\n             * architecture specifies we should not match. Linux will\n\n             * potentially leave behind PTEs for the wrong base page\n\n             * size when demoting segments.\n\n             */\n\n            if (*pshift == 0) {\n\n                continue;\n\n            }\n\n            /* We don't do anything with pshift yet as qemu TLB only deals\n\n             * with 4K pages anyway\n\n             */\n\n            pte->pte0 = pte0;\n\n            pte->pte1 = pte1;\n\n            ppc_hash64_unmap_hptes(cpu, pteg, ptex, HPTES_PER_GROUP);\n\n            return ptex + i;\n\n        }\n\n    }\n\n    ppc_hash64_unmap_hptes(cpu, pteg, ptex, HPTES_PER_GROUP);\n\n    /*\n\n     * We didn't find a valid entry.\n\n     */\n\n    return -1;\n\n}\n", "idx": 22470}
{"project": "qemu", "commit_id": "2e6fc7eb1a4af1b127df5f07b8bb28af891946fa", "target": 0, "func": "static int64_t coroutine_fn raw_co_get_block_status(BlockDriverState *bs,\n\n                                            int64_t sector_num,\n\n                                            int nb_sectors, int *pnum,\n\n                                            BlockDriverState **file)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    *pnum = nb_sectors;\n\n    *file = bs->file->bs;\n\n    sector_num += s->offset / BDRV_SECTOR_SIZE;\n\n    return BDRV_BLOCK_RAW | BDRV_BLOCK_OFFSET_VALID | BDRV_BLOCK_DATA |\n\n           (sector_num << BDRV_SECTOR_BITS);\n\n}\n", "idx": 22471}
{"project": "qemu", "commit_id": "c7b4b0b302709928b84582881a7b4fb6c1e39e2b", "target": 0, "func": "static void v9fs_wstat_post_rename(V9fsState *s, V9fsWstatState *vs, int err)\n\n{\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n\n\n    if (vs->v9stat.name.size != 0) {\n\n        v9fs_string_free(&vs->nname);\n\n    }\n\n\n\n    if (vs->v9stat.length != -1) {\n\n        if (v9fs_do_truncate(s, &vs->fidp->path, vs->v9stat.length) < 0) {\n\n            err = -errno;\n\n        }\n\n    }\n\n    v9fs_wstat_post_truncate(s, vs, err);\n\n    return;\n\n\n\nout:\n\n    v9fs_stat_free(&vs->v9stat);\n\n    complete_pdu(s, vs->pdu, err);\n\n    qemu_free(vs);\n\n}\n", "idx": 22472}
{"project": "qemu", "commit_id": "4f5e19e6c570459cd524b29b24374f03860f5149", "target": 0, "func": "static int pci_unin_internal_init_device(SysBusDevice *dev)\n\n{\n\n    UNINState *s;\n\n    int pci_mem_config, pci_mem_data;\n\n\n\n    /* Uninorth internal bus */\n\n    s = FROM_SYSBUS(UNINState, dev);\n\n\n\n    pci_mem_config = cpu_register_io_memory(pci_unin_config_read,\n\n                                            pci_unin_config_write, s);\n\n    pci_mem_data = cpu_register_io_memory(pci_unin_read,\n\n                                          pci_unin_write, s);\n\n    sysbus_init_mmio(dev, 0x1000, pci_mem_config);\n\n    sysbus_init_mmio(dev, 0x1000, pci_mem_data);\n\n    return 0;\n\n}\n", "idx": 22473}
{"project": "qemu", "commit_id": "7d08c73e7bdc39b10e5f2f5acdce700f17ffe962", "target": 0, "func": "e1000e_process_tx_desc(E1000ECore *core,\n\n                       struct e1000e_tx *tx,\n\n                       struct e1000_tx_desc *dp,\n\n                       int queue_index)\n\n{\n\n    uint32_t txd_lower = le32_to_cpu(dp->lower.data);\n\n    uint32_t dtype = txd_lower & (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D);\n\n    unsigned int split_size = txd_lower & 0xffff;\n\n    uint64_t addr;\n\n    struct e1000_context_desc *xp = (struct e1000_context_desc *)dp;\n\n    bool eop = txd_lower & E1000_TXD_CMD_EOP;\n\n\n\n    if (dtype == E1000_TXD_CMD_DEXT) { /* context descriptor */\n\n        e1000x_read_tx_ctx_descr(xp, &tx->props);\n\n        e1000e_process_snap_option(core, le32_to_cpu(xp->cmd_and_length));\n\n        return;\n\n    } else if (dtype == (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D)) {\n\n        /* data descriptor */\n\n        tx->props.sum_needed = le32_to_cpu(dp->upper.data) >> 8;\n\n        tx->props.cptse = (txd_lower & E1000_TXD_CMD_TSE) ? 1 : 0;\n\n        e1000e_process_ts_option(core, dp);\n\n    } else {\n\n        /* legacy descriptor */\n\n        e1000e_process_ts_option(core, dp);\n\n        tx->props.cptse = 0;\n\n    }\n\n\n\n    addr = le64_to_cpu(dp->buffer_addr);\n\n\n\n    if (!tx->skip_cp) {\n\n        if (!net_tx_pkt_add_raw_fragment(tx->tx_pkt, addr, split_size)) {\n\n            tx->skip_cp = true;\n\n        }\n\n    }\n\n\n\n    if (eop) {\n\n        if (!tx->skip_cp && net_tx_pkt_parse(tx->tx_pkt)) {\n\n            if (e1000x_vlan_enabled(core->mac) &&\n\n                e1000x_is_vlan_txd(txd_lower)) {\n\n                net_tx_pkt_setup_vlan_header_ex(tx->tx_pkt,\n\n                    le16_to_cpu(dp->upper.fields.special), core->vet);\n\n            }\n\n            if (e1000e_tx_pkt_send(core, tx, queue_index)) {\n\n                e1000e_on_tx_done_update_stats(core, tx->tx_pkt);\n\n            }\n\n        }\n\n\n\n        tx->skip_cp = false;\n\n        net_tx_pkt_reset(tx->tx_pkt);\n\n\n\n        tx->props.sum_needed = 0;\n\n        tx->props.cptse = 0;\n\n    }\n\n}\n", "idx": 22474}
{"project": "qemu", "commit_id": "ef0e64a9838c0a20b5cb8a0bd2dcbcc59b0b812d", "target": 0, "func": "BlockAIOCB *ide_issue_trim(\n\n        int64_t offset, QEMUIOVector *qiov,\n\n        BlockCompletionFunc *cb, void *cb_opaque, void *opaque)\n\n{\n\n    BlockBackend *blk = opaque;\n\n    TrimAIOCB *iocb;\n\n\n\n    iocb = blk_aio_get(&trim_aiocb_info, blk, cb, cb_opaque);\n\n    iocb->blk = blk;\n\n    iocb->bh = qemu_bh_new(ide_trim_bh_cb, iocb);\n\n    iocb->ret = 0;\n\n    iocb->qiov = qiov;\n\n    iocb->i = -1;\n\n    iocb->j = 0;\n\n    ide_issue_trim_cb(iocb, 0);\n\n    return &iocb->common;\n\n}\n", "idx": 22475}
{"project": "qemu", "commit_id": "ddcd55316fb2851e144e719171621ad2816487dc", "target": 0, "func": "static int fw_cfg_boot_set(void *opaque, const char *boot_device)\n\n{\n\n    fw_cfg_add_i16(opaque, FW_CFG_BOOT_DEVICE, boot_device[0]);\n\n    return 0;\n\n}\n", "idx": 22476}
{"project": "qemu", "commit_id": "4828b10bda6a74a22a7695303e0648157d0e3ea4", "target": 0, "func": "void acpi_memory_plug_cb(ACPIREGS *ar, qemu_irq irq, MemHotplugState *mem_st,\n\n                         DeviceState *dev, Error **errp)\n\n{\n\n    MemStatus *mdev;\n\n\n\n    mdev = acpi_memory_slot_status(mem_st, dev, errp);\n\n    if (!mdev) {\n\n        return;\n\n    }\n\n\n\n    mdev->dimm = dev;\n\n    mdev->is_enabled = true;\n\n    mdev->is_inserting = true;\n\n\n\n    /* do ACPI magic */\n\n    acpi_send_gpe_event(ar, irq, ACPI_MEMORY_HOTPLUG_STATUS);\n\n    return;\n\n}\n", "idx": 22477}
{"project": "qemu", "commit_id": "a6baa60807f88ba7d97b1787797fb58882ccbfb9", "target": 0, "func": "static bool next_query_bds(BlockBackend **blk, BlockDriverState **bs,\n\n                           bool query_nodes)\n\n{\n\n    if (query_nodes) {\n\n        *bs = bdrv_next_node(*bs);\n\n        return !!*bs;\n\n    }\n\n\n\n    *blk = blk_next(*blk);\n\n    *bs = *blk ? blk_bs(*blk) : NULL;\n\n\n\n    return !!*blk;\n\n}\n", "idx": 22478}
{"project": "qemu", "commit_id": "22e4104079a4a92a4800d516fc1d968a3e8b8157", "target": 0, "func": "unsigned int EmulateAll(unsigned int opcode, FPA11* qfpa, CPUARMState* qregs)\n\n{\n\n  unsigned int nRc = 0;\n\n//  unsigned long flags;\n\n  FPA11 *fpa11;\n\n//  save_flags(flags); sti();\n\n\n\n  qemufpa=qfpa;\n\n  user_registers=qregs;\n\n\n\n#if 0\n\n  fprintf(stderr,\"emulating FP insn 0x%08x, PC=0x%08x\\n\",\n\n          opcode, qregs[REG_PC]);\n\n#endif\n\n  fpa11 = GET_FPA11();\n\n\n\n  if (fpa11->initflag == 0)\t\t/* good place for __builtin_expect */\n\n  {\n\n    resetFPA11();\n\n    SetRoundingMode(ROUND_TO_NEAREST);\n\n    SetRoundingPrecision(ROUND_EXTENDED);\n\n    fpa11->initflag = 1;\n\n  }\n\n\n\n  set_float_exception_flags(0, &fpa11->fp_status);\n\n\n\n  if (TEST_OPCODE(opcode,MASK_CPRT))\n\n  {\n\n    //fprintf(stderr,\"emulating CPRT\\n\");\n\n    /* Emulate conversion opcodes. */\n\n    /* Emulate register transfer opcodes. */\n\n    /* Emulate comparison opcodes. */\n\n    nRc = EmulateCPRT(opcode);\n\n  }\n\n  else if (TEST_OPCODE(opcode,MASK_CPDO))\n\n  {\n\n    //fprintf(stderr,\"emulating CPDO\\n\");\n\n    /* Emulate monadic arithmetic opcodes. */\n\n    /* Emulate dyadic arithmetic opcodes. */\n\n    nRc = EmulateCPDO(opcode);\n\n  }\n\n  else if (TEST_OPCODE(opcode,MASK_CPDT))\n\n  {\n\n    //fprintf(stderr,\"emulating CPDT\\n\");\n\n    /* Emulate load/store opcodes. */\n\n    /* Emulate load/store multiple opcodes. */\n\n    nRc = EmulateCPDT(opcode);\n\n  }\n\n  else\n\n  {\n\n    /* Invalid instruction detected.  Return FALSE. */\n\n    nRc = 0;\n\n  }\n\n\n\n//  restore_flags(flags);\n\n  if(nRc == 1 && get_float_exception_flags(&fpa11->fp_status))\n\n  {\n\n    //printf(\"fef 0x%x\\n\",float_exception_flags);\n\n    nRc -= get_float_exception_flags(&fpa11->fp_status);\n\n  }\n\n\n\n  //printf(\"returning %d\\n\",nRc);\n\n  return(nRc);\n\n}\n", "idx": 22480}
{"project": "qemu", "commit_id": "d185c094b404b4ff392b77d1244c0233da7d53bd", "target": 0, "func": "static gboolean io_watch_poll_dispatch(GSource *source, GSourceFunc callback,\n\n                                       gpointer user_data)\n\n{\n\n    return g_io_watch_funcs.dispatch(source, callback, user_data);\n\n}\n", "idx": 22481}
{"project": "qemu", "commit_id": "dd4d607e40dcd2cb7646b510504880a70939d91b", "target": 0, "func": "static int vtd_page_walk(VTDContextEntry *ce, uint64_t start, uint64_t end,\n\n                         vtd_page_walk_hook hook_fn, void *private)\n\n{\n\n    dma_addr_t addr = vtd_get_slpt_base_from_context(ce);\n\n    uint32_t level = vtd_get_level_from_context_entry(ce);\n\n\n\n    if (!vtd_iova_range_check(start, ce)) {\n\n        return -VTD_FR_ADDR_BEYOND_MGAW;\n\n    }\n\n\n\n    if (!vtd_iova_range_check(end, ce)) {\n\n        /* Fix end so that it reaches the maximum */\n\n        end = vtd_iova_limit(ce);\n\n    }\n\n\n\n    return vtd_page_walk_level(addr, start, end, hook_fn, private,\n\n                               level, true, true, false);\n\n}\n", "idx": 22482}
{"project": "qemu", "commit_id": "08844473820c93541fc47bdfeae0f2cc88cfab59", "target": 0, "func": "static int coroutine_fn bdrv_co_readv_em(BlockDriverState *bs,\n\n                                         int64_t sector_num, int nb_sectors,\n\n                                         QEMUIOVector *iov)\n\n{\n\n    return bdrv_co_io_em(bs, sector_num, nb_sectors, iov, false);\n\n}\n", "idx": 22483}
{"project": "qemu", "commit_id": "ab31979a7e835832605f8425d0eaa5c74d1e6375", "target": 0, "func": "static void iostatus_bdrv_it(void *opaque, BlockDriverState *bs)\n\n{\n\n    bdrv_iostatus_reset(bs);\n\n}\n", "idx": 22484}
{"project": "qemu", "commit_id": "df1561e22df42643d769aacdcc7d6d239f243366", "target": 0, "func": "void op_flush_icache_range(void) {\n\n    CALL_FROM_TB2(tlb_flush_page, env, T0 + T1);\n\n    RETURN();\n\n}\n", "idx": 22485}
{"project": "qemu", "commit_id": "52b4bb7383b32e4e7512f98c57738c8fc9cb35ba", "target": 0, "func": "static uint64_t lan9118_readl(void *opaque, hwaddr offset,\n\n                              unsigned size)\n\n{\n\n    lan9118_state *s = (lan9118_state *)opaque;\n\n\n\n    //DPRINTF(\"Read reg 0x%02x\\n\", (int)offset);\n\n    if (offset < 0x20) {\n\n        /* RX FIFO */\n\n        return rx_fifo_pop(s);\n\n    }\n\n    switch (offset) {\n\n    case 0x40:\n\n        return rx_status_fifo_pop(s);\n\n    case 0x44:\n\n        return s->rx_status_fifo[s->tx_status_fifo_head];\n\n    case 0x48:\n\n        return tx_status_fifo_pop(s);\n\n    case 0x4c:\n\n        return s->tx_status_fifo[s->tx_status_fifo_head];\n\n    case CSR_ID_REV:\n\n        return 0x01180001;\n\n    case CSR_IRQ_CFG:\n\n        return s->irq_cfg;\n\n    case CSR_INT_STS:\n\n        return s->int_sts;\n\n    case CSR_INT_EN:\n\n        return s->int_en;\n\n    case CSR_BYTE_TEST:\n\n        return 0x87654321;\n\n    case CSR_FIFO_INT:\n\n        return s->fifo_int;\n\n    case CSR_RX_CFG:\n\n        return s->rx_cfg;\n\n    case CSR_TX_CFG:\n\n        return s->tx_cfg;\n\n    case CSR_HW_CFG:\n\n        return s->hw_cfg;\n\n    case CSR_RX_DP_CTRL:\n\n        return 0;\n\n    case CSR_RX_FIFO_INF:\n\n        return (s->rx_status_fifo_used << 16) | (s->rx_fifo_used << 2);\n\n    case CSR_TX_FIFO_INF:\n\n        return (s->tx_status_fifo_used << 16)\n\n               | (s->tx_fifo_size - s->txp->fifo_used);\n\n    case CSR_PMT_CTRL:\n\n        return s->pmt_ctrl;\n\n    case CSR_GPIO_CFG:\n\n        return s->gpio_cfg;\n\n    case CSR_GPT_CFG:\n\n        return s->gpt_cfg;\n\n    case CSR_GPT_CNT:\n\n        return ptimer_get_count(s->timer);\n\n    case CSR_WORD_SWAP:\n\n        return s->word_swap;\n\n    case CSR_FREE_RUN:\n\n        return (qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) / 40) - s->free_timer_start;\n\n    case CSR_RX_DROP:\n\n        /* TODO: Implement dropped frames counter.  */\n\n        return 0;\n\n    case CSR_MAC_CSR_CMD:\n\n        return s->mac_cmd;\n\n    case CSR_MAC_CSR_DATA:\n\n        return s->mac_data;\n\n    case CSR_AFC_CFG:\n\n        return s->afc_cfg;\n\n    case CSR_E2P_CMD:\n\n        return s->e2p_cmd;\n\n    case CSR_E2P_DATA:\n\n        return s->e2p_data;\n\n    }\n\n    hw_error(\"lan9118_read: Bad reg 0x%x\\n\", (int)offset);\n\n    return 0;\n\n}\n", "idx": 22486}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void do_attach(USBDevice *dev)\n\n{\n\n    USBBus *bus = usb_bus_from_device(dev);\n\n    USBPort *port;\n\n\n\n    if (dev->attached) {\n\n        fprintf(stderr, \"Warning: tried to attach usb device %s twice\\n\",\n\n                dev->devname);\n\n        return;\n\n    }\n\n    dev->attached++;\n\n\n\n    port = TAILQ_FIRST(&bus->free);\n\n    TAILQ_REMOVE(&bus->free, port, next);\n\n    bus->nfree--;\n\n\n\n    usb_attach(port, dev);\n\n\n\n    TAILQ_INSERT_TAIL(&bus->used, port, next);\n\n    bus->nused++;\n\n}\n", "idx": 22487}
{"project": "qemu", "commit_id": "d2fc39b4208709db95b6825c0e1b00ce6fbf0ecc", "target": 1, "func": "static int tcp_get_msgfds(CharDriverState *chr, int *fds, int num)\n{\n    TCPCharDriver *s = chr->opaque;\n    int to_copy = (s->read_msgfds_num < num) ? s->read_msgfds_num : num;\n    if (to_copy) {\n        memcpy(fds, s->read_msgfds, to_copy * sizeof(int));\n        g_free(s->read_msgfds);\n        s->read_msgfds = 0;\n        s->read_msgfds_num = 0;\n    return to_copy;", "idx": 22489}
{"project": "qemu", "commit_id": "a890643958f03aaa344290700093b280cb606c28", "target": 1, "func": "void *qht_do_lookup(struct qht_bucket *head, qht_lookup_func_t func,\n\n                    const void *userp, uint32_t hash)\n\n{\n\n    struct qht_bucket *b = head;\n\n    int i;\n\n\n\n    do {\n\n        for (i = 0; i < QHT_BUCKET_ENTRIES; i++) {\n\n            if (b->hashes[i] == hash) {\n\n                /* The pointer is dereferenced before seqlock_read_retry,\n\n                 * so (unlike qht_insert__locked) we need to use\n\n                 * atomic_rcu_read here.\n\n                 */\n\n                void *p = atomic_rcu_read(&b->pointers[i]);\n\n\n\n                if (likely(p) && likely(func(p, userp))) {\n\n                    return p;\n\n                }\n\n            }\n\n        }\n\n        b = atomic_rcu_read(&b->next);\n\n    } while (b);\n\n\n\n    return NULL;\n\n}\n", "idx": 22490}
{"project": "qemu", "commit_id": "14324f585d76abd8a609c119d627503e6a0961be", "target": 1, "func": "static void test_io_channel_command_fifo(bool async)\n\n{\n\n#define TEST_FIFO \"tests/test-io-channel-command.fifo\"\n\n    QIOChannel *src, *dst;\n\n    QIOChannelTest *test;\n\n    char *srcfifo = g_strdup_printf(\"PIPE:%s,wronly\", TEST_FIFO);\n\n    char *dstfifo = g_strdup_printf(\"PIPE:%s,rdonly\", TEST_FIFO);\n\n    const char *srcargv[] = {\n\n        \"/bin/socat\", \"-\", srcfifo, NULL,\n\n    };\n\n    const char *dstargv[] = {\n\n        \"/bin/socat\", dstfifo, \"-\", NULL,\n\n    };\n\n\n\n    unlink(TEST_FIFO);\n\n    if (access(\"/bin/socat\", X_OK) < 0) {\n\n        return; /* Pretend success if socat is not present */\n\n    }\n\n    if (mkfifo(TEST_FIFO, 0600) < 0) {\n\n        abort();\n\n    }\n\n    src = QIO_CHANNEL(qio_channel_command_new_spawn(srcargv,\n\n                                                    O_WRONLY,\n\n                                                    &error_abort));\n\n    dst = QIO_CHANNEL(qio_channel_command_new_spawn(dstargv,\n\n                                                    O_RDONLY,\n\n                                                    &error_abort));\n\n\n\n    test = qio_channel_test_new();\n\n    qio_channel_test_run_threads(test, async, src, dst);\n\n    qio_channel_test_validate(test);\n\n\n\n    object_unref(OBJECT(src));\n\n    object_unref(OBJECT(dst));\n\n\n\n    g_free(srcfifo);\n\n    g_free(dstfifo);\n\n    unlink(TEST_FIFO);\n\n}\n", "idx": 22491}
{"project": "qemu", "commit_id": "c4237dfa635900e4d1cdc6038d5efe3507f45f0c", "target": 1, "func": "static uint64_t coroutine_fn mirror_iteration(MirrorBlockJob *s)\n\n{\n\n    BlockDriverState *source = s->common.bs;\n\n    int nb_sectors, sectors_per_chunk, nb_chunks;\n\n    int64_t end, sector_num, next_chunk, next_sector, hbitmap_next_sector;\n\n    uint64_t delay_ns = 0;\n\n    MirrorOp *op;\n\n\n\n    s->sector_num = hbitmap_iter_next(&s->hbi);\n\n    if (s->sector_num < 0) {\n\n        bdrv_dirty_iter_init(source, s->dirty_bitmap, &s->hbi);\n\n        s->sector_num = hbitmap_iter_next(&s->hbi);\n\n        trace_mirror_restart_iter(s,\n\n                                  bdrv_get_dirty_count(source, s->dirty_bitmap));\n\n        assert(s->sector_num >= 0);\n\n    }\n\n\n\n    hbitmap_next_sector = s->sector_num;\n\n    sector_num = s->sector_num;\n\n    sectors_per_chunk = s->granularity >> BDRV_SECTOR_BITS;\n\n    end = s->bdev_length / BDRV_SECTOR_SIZE;\n\n\n\n    /* Extend the QEMUIOVector to include all adjacent blocks that will\n\n     * be copied in this operation.\n\n     *\n\n     * We have to do this if we have no backing file yet in the destination,\n\n     * and the cluster size is very large.  Then we need to do COW ourselves.\n\n     * The first time a cluster is copied, copy it entirely.  Note that,\n\n     * because both the granularity and the cluster size are powers of two,\n\n     * the number of sectors to copy cannot exceed one cluster.\n\n     *\n\n     * We also want to extend the QEMUIOVector to include more adjacent\n\n     * dirty blocks if possible, to limit the number of I/O operations and\n\n     * run efficiently even with a small granularity.\n\n     */\n\n    nb_chunks = 0;\n\n    nb_sectors = 0;\n\n    next_sector = sector_num;\n\n    next_chunk = sector_num / sectors_per_chunk;\n\n\n\n    /* Wait for I/O to this cluster (from a previous iteration) to be done.  */\n\n    while (test_bit(next_chunk, s->in_flight_bitmap)) {\n\n        trace_mirror_yield_in_flight(s, sector_num, s->in_flight);\n\n        qemu_coroutine_yield();\n\n    }\n\n\n\n    do {\n\n        int added_sectors, added_chunks;\n\n\n\n        if (!bdrv_get_dirty(source, s->dirty_bitmap, next_sector) ||\n\n            test_bit(next_chunk, s->in_flight_bitmap)) {\n\n            assert(nb_sectors > 0);\n\n            break;\n\n        }\n\n\n\n        added_sectors = sectors_per_chunk;\n\n        if (s->cow_bitmap && !test_bit(next_chunk, s->cow_bitmap)) {\n\n            bdrv_round_to_clusters(s->target,\n\n                                   next_sector, added_sectors,\n\n                                   &next_sector, &added_sectors);\n\n\n\n            /* On the first iteration, the rounding may make us copy\n\n             * sectors before the first dirty one.\n\n             */\n\n            if (next_sector < sector_num) {\n\n                assert(nb_sectors == 0);\n\n                sector_num = next_sector;\n\n                next_chunk = next_sector / sectors_per_chunk;\n\n            }\n\n        }\n\n\n\n        added_sectors = MIN(added_sectors, end - (sector_num + nb_sectors));\n\n        added_chunks = (added_sectors + sectors_per_chunk - 1) / sectors_per_chunk;\n\n\n\n        /* When doing COW, it may happen that there is not enough space for\n\n         * a full cluster.  Wait if that is the case.\n\n         */\n\n        while (nb_chunks == 0 && s->buf_free_count < added_chunks) {\n\n            trace_mirror_yield_buf_busy(s, nb_chunks, s->in_flight);\n\n            qemu_coroutine_yield();\n\n        }\n\n        if (s->buf_free_count < nb_chunks + added_chunks) {\n\n            trace_mirror_break_buf_busy(s, nb_chunks, s->in_flight);\n\n            break;\n\n        }\n\n\n\n        /* We have enough free space to copy these sectors.  */\n\n        bitmap_set(s->in_flight_bitmap, next_chunk, added_chunks);\n\n\n\n        nb_sectors += added_sectors;\n\n        nb_chunks += added_chunks;\n\n        next_sector += added_sectors;\n\n        next_chunk += added_chunks;\n\n        if (!s->synced && s->common.speed) {\n\n            delay_ns = ratelimit_calculate_delay(&s->limit, added_sectors);\n\n        }\n\n    } while (delay_ns == 0 && next_sector < end);\n\n\n\n    /* Allocate a MirrorOp that is used as an AIO callback.  */\n\n    op = g_slice_new(MirrorOp);\n\n    op->s = s;\n\n    op->sector_num = sector_num;\n\n    op->nb_sectors = nb_sectors;\n\n\n\n    /* Now make a QEMUIOVector taking enough granularity-sized chunks\n\n     * from s->buf_free.\n\n     */\n\n    qemu_iovec_init(&op->qiov, nb_chunks);\n\n    next_sector = sector_num;\n\n    while (nb_chunks-- > 0) {\n\n        MirrorBuffer *buf = QSIMPLEQ_FIRST(&s->buf_free);\n\n        size_t remaining = (nb_sectors * BDRV_SECTOR_SIZE) - op->qiov.size;\n\n\n\n        QSIMPLEQ_REMOVE_HEAD(&s->buf_free, next);\n\n        s->buf_free_count--;\n\n        qemu_iovec_add(&op->qiov, buf, MIN(s->granularity, remaining));\n\n\n\n        /* Advance the HBitmapIter in parallel, so that we do not examine\n\n         * the same sector twice.\n\n         */\n\n        if (next_sector > hbitmap_next_sector\n\n            && bdrv_get_dirty(source, s->dirty_bitmap, next_sector)) {\n\n            hbitmap_next_sector = hbitmap_iter_next(&s->hbi);\n\n        }\n\n\n\n        next_sector += sectors_per_chunk;\n\n    }\n\n\n\n    bdrv_reset_dirty(source, sector_num, nb_sectors);\n\n\n\n    /* Copy the dirty cluster.  */\n\n    s->in_flight++;\n\n    s->sectors_in_flight += nb_sectors;\n\n    trace_mirror_one_iteration(s, sector_num, nb_sectors);\n\n    bdrv_aio_readv(source, sector_num, &op->qiov, nb_sectors,\n\n                   mirror_read_complete, op);\n\n    return delay_ns;\n\n}\n", "idx": 22492}
{"project": "qemu", "commit_id": "5e30a07d6d70d3073ff61e6db79d61c2b688502f", "target": 1, "func": "static int32_t scsi_send_command(SCSIRequest *req, uint8_t *buf)\n\n{\n\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    int32_t len;\n\n    uint8_t command;\n\n    uint8_t *outbuf;\n\n    int rc;\n\n\n\n    command = buf[0];\n\n    outbuf = (uint8_t *)r->iov.iov_base;\n\n    DPRINTF(\"Command: lun=%d tag=0x%x data=0x%02x\", req->lun, req->tag, buf[0]);\n\n\n\n    if (scsi_req_parse(&r->req, buf) != 0) {\n\n        BADF(\"Unsupported command length, command %x\\n\", command);\n\n        scsi_command_complete(r, CHECK_CONDITION, SENSE_CODE(INVALID_OPCODE));\n\n        return 0;\n\n    }\n\n#ifdef DEBUG_SCSI\n\n    {\n\n        int i;\n\n        for (i = 1; i < r->req.cmd.len; i++) {\n\n            printf(\" 0x%02x\", buf[i]);\n\n        }\n\n        printf(\"\\n\");\n\n    }\n\n#endif\n\n\n\n    if (req->lun) {\n\n        /* Only LUN 0 supported.  */\n\n        DPRINTF(\"Unimplemented LUN %d\\n\", req->lun);\n\n        if (command != REQUEST_SENSE && command != INQUIRY) {\n\n            scsi_command_complete(r, CHECK_CONDITION,\n\n                                  SENSE_CODE(LUN_NOT_SUPPORTED));\n\n            return 0;\n\n        }\n\n    }\n\n    switch (command) {\n\n    case TEST_UNIT_READY:\n\n    case REQUEST_SENSE:\n\n    case INQUIRY:\n\n    case MODE_SENSE:\n\n    case MODE_SENSE_10:\n\n    case RESERVE:\n\n    case RESERVE_10:\n\n    case RELEASE:\n\n    case RELEASE_10:\n\n    case START_STOP:\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n    case READ_CAPACITY:\n\n    case SYNCHRONIZE_CACHE:\n\n    case READ_TOC:\n\n    case GET_CONFIGURATION:\n\n    case SERVICE_ACTION_IN:\n\n    case REPORT_LUNS:\n\n    case VERIFY:\n\n        rc = scsi_disk_emulate_command(r, outbuf);\n\n        if (rc < 0) {\n\n            return 0;\n\n        }\n\n\n\n        r->iov.iov_len = rc;\n\n        break;\n\n    case READ_6:\n\n    case READ_10:\n\n    case READ_12:\n\n    case READ_16:\n\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n\n        DPRINTF(\"Read (sector %\" PRId64 \", count %d)\\n\", r->req.cmd.lba, len);\n\n        if (r->req.cmd.lba > s->max_lba)\n\n            goto illegal_lba;\n\n        r->sector = r->req.cmd.lba * s->cluster_size;\n\n        r->sector_count = len * s->cluster_size;\n\n        break;\n\n    case WRITE_6:\n\n    case WRITE_10:\n\n    case WRITE_12:\n\n    case WRITE_16:\n\n    case WRITE_VERIFY:\n\n    case WRITE_VERIFY_12:\n\n    case WRITE_VERIFY_16:\n\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n\n        DPRINTF(\"Write %s(sector %\" PRId64 \", count %d)\\n\",\n\n                (command & 0xe) == 0xe ? \"And Verify \" : \"\",\n\n                r->req.cmd.lba, len);\n\n        if (r->req.cmd.lba > s->max_lba)\n\n            goto illegal_lba;\n\n        r->sector = r->req.cmd.lba * s->cluster_size;\n\n        r->sector_count = len * s->cluster_size;\n\n        break;\n\n    case MODE_SELECT:\n\n        DPRINTF(\"Mode Select(6) (len %lu)\\n\", (long)r->req.cmd.xfer);\n\n        /* We don't support mode parameter changes.\n\n           Allow the mode parameter header + block descriptors only. */\n\n        if (r->req.cmd.xfer > 12) {\n\n            goto fail;\n\n        }\n\n        break;\n\n    case MODE_SELECT_10:\n\n        DPRINTF(\"Mode Select(10) (len %lu)\\n\", (long)r->req.cmd.xfer);\n\n        /* We don't support mode parameter changes.\n\n           Allow the mode parameter header + block descriptors only. */\n\n        if (r->req.cmd.xfer > 16) {\n\n            goto fail;\n\n        }\n\n        break;\n\n    case SEEK_6:\n\n    case SEEK_10:\n\n        DPRINTF(\"Seek(%d) (sector %\" PRId64 \")\\n\", command == SEEK_6 ? 6 : 10,\n\n                r->req.cmd.lba);\n\n        if (r->req.cmd.lba > s->max_lba) {\n\n            goto illegal_lba;\n\n        }\n\n        break;\n\n    case WRITE_SAME_16:\n\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n\n\n\n        DPRINTF(\"WRITE SAME(16) (sector %\" PRId64 \", count %d)\\n\",\n\n                r->req.cmd.lba, len);\n\n\n\n        if (r->req.cmd.lba > s->max_lba) {\n\n            goto illegal_lba;\n\n        }\n\n\n\n        /*\n\n         * We only support WRITE SAME with the unmap bit set for now.\n\n         */\n\n        if (!(buf[1] & 0x8)) {\n\n            goto fail;\n\n        }\n\n\n\n        rc = bdrv_discard(s->bs, r->req.cmd.lba * s->cluster_size,\n\n                          len * s->cluster_size);\n\n        if (rc < 0) {\n\n            /* XXX: better error code ?*/\n\n            goto fail;\n\n        }\n\n\n\n        break;\n\n    default:\n\n        DPRINTF(\"Unknown SCSI command (%2.2x)\\n\", buf[0]);\n\n        scsi_command_complete(r, CHECK_CONDITION, SENSE_CODE(INVALID_OPCODE));\n\n        return 0;\n\n    fail:\n\n        scsi_command_complete(r, CHECK_CONDITION, SENSE_CODE(INVALID_FIELD));\n\n        return 0;\n\n    illegal_lba:\n\n        scsi_command_complete(r, CHECK_CONDITION, SENSE_CODE(LBA_OUT_OF_RANGE));\n\n        return 0;\n\n    }\n\n    if (r->sector_count == 0 && r->iov.iov_len == 0) {\n\n        scsi_command_complete(r, GOOD, SENSE_CODE(NO_SENSE));\n\n    }\n\n    len = r->sector_count * 512 + r->iov.iov_len;\n\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n\n        return -len;\n\n    } else {\n\n        if (!r->sector_count)\n\n            r->sector_count = -1;\n\n        return len;\n\n    }\n\n}\n", "idx": 22494}
{"project": "qemu", "commit_id": "bd16430777cc3d25930e479fdbe290d92cec0888", "target": 1, "func": "static void sysbus_ahci_realize(DeviceState *dev, Error **errp)\n\n{\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);\n\n    SysbusAHCIState *s = SYSBUS_AHCI(dev);\n\n\n\n    ahci_init(&s->ahci, dev, NULL, s->num_ports);\n\n\n\n    sysbus_init_mmio(sbd, &s->ahci.mem);\n\n    sysbus_init_irq(sbd, &s->ahci.irq);\n\n}\n", "idx": 22495}
{"project": "qemu", "commit_id": "57285302af51a8bae334c03e1f8243e935373953", "target": 1, "func": "static int spapr_vty_init(VIOsPAPRDevice *sdev)\n{\n    VIOsPAPRVTYDevice *dev = (VIOsPAPRVTYDevice *)sdev;\n    qemu_chr_add_handlers(dev->chardev, vty_can_receive,\n                          vty_receive, NULL, dev);\n    return 0;", "idx": 22496}
{"project": "qemu", "commit_id": "c3a699be3c63f75b6ea5877080ea9b96b37524c4", "target": 1, "func": "static void exynos4210_ltick_recalc_count(struct tick_timer *s)\n\n{\n\n    uint64_t to_count;\n\n\n\n    if ((s->cnt_run && s->last_tcnto) || (s->int_run && s->last_icnto)) {\n\n        /*\n\n         * one or both timers run and not counted to the end;\n\n         * distance is not passed, recalculate with last_tcnto * last_icnto\n\n         */\n\n\n\n        if (s->last_tcnto) {\n\n            to_count = s->last_tcnto * s->last_icnto;\n\n        } else {\n\n            to_count = s->last_icnto;\n\n        }\n\n    } else {\n\n        /* distance is passed, recalculate with tcnto * icnto */\n\n        if (s->icntb) {\n\n            s->distance = s->tcntb * s->icntb;\n\n        } else {\n\n            s->distance = s->tcntb;\n\n        }\n\n\n\n        to_count = s->distance;\n\n        s->progress = 0;\n\n    }\n\n\n\n    if (to_count > MCT_LT_COUNTER_STEP) {\n\n        /* count by step */\n\n        s->count = MCT_LT_COUNTER_STEP;\n\n    } else {\n\n        s->count = to_count;\n\n    }\n\n}\n", "idx": 22497}
{"project": "qemu", "commit_id": "d3c8c67469ee70fcae116d5abc277a7ebc8a19fd", "target": 1, "func": "static void mirror_start_job(const char *job_id, BlockDriverState *bs,\n\n                             int creation_flags, BlockDriverState *target,\n\n                             const char *replaces, int64_t speed,\n\n                             uint32_t granularity, int64_t buf_size,\n\n                             BlockMirrorBackingMode backing_mode,\n\n                             BlockdevOnError on_source_error,\n\n                             BlockdevOnError on_target_error,\n\n                             bool unmap,\n\n                             BlockCompletionFunc *cb,\n\n                             void *opaque,\n\n                             const BlockJobDriver *driver,\n\n                             bool is_none_mode, BlockDriverState *base,\n\n                             bool auto_complete, const char *filter_node_name,\n\n                             Error **errp)\n\n{\n\n    MirrorBlockJob *s;\n\n    BlockDriverState *mirror_top_bs;\n\n    bool target_graph_mod;\n\n    bool target_is_backing;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    if (granularity == 0) {\n\n        granularity = bdrv_get_default_bitmap_granularity(target);\n\n\n\n\n    assert ((granularity & (granularity - 1)) == 0);\n\n    /* Granularity must be large enough for sector-based dirty bitmap */\n\n    assert(granularity >= BDRV_SECTOR_SIZE);\n\n\n\n    if (buf_size < 0) {\n\n        error_setg(errp, \"Invalid parameter 'buf-size'\");\n\n        return;\n\n\n\n\n    if (buf_size == 0) {\n\n        buf_size = DEFAULT_MIRROR_BUF_SIZE;\n\n\n\n\n    /* In the case of active commit, add dummy driver to provide consistent\n\n     * reads on the top, while disabling it in the intermediate nodes, and make\n\n     * the backing chain writable. */\n\n    mirror_top_bs = bdrv_new_open_driver(&bdrv_mirror_top, filter_node_name,\n\n                                         BDRV_O_RDWR, errp);\n\n    if (mirror_top_bs == NULL) {\n\n        return;\n\n\n\n\n\n    mirror_top_bs->total_sectors = bs->total_sectors;\n\n    bdrv_set_aio_context(mirror_top_bs, bdrv_get_aio_context(bs));\n\n\n\n    /* bdrv_append takes ownership of the mirror_top_bs reference, need to keep\n\n     * it alive until block_job_create() succeeds even if bs has no parent. */\n\n    bdrv_ref(mirror_top_bs);\n\n    bdrv_drained_begin(bs);\n\n    bdrv_append(mirror_top_bs, bs, &local_err);\n\n    bdrv_drained_end(bs);\n\n\n\n    if (local_err) {\n\n        bdrv_unref(mirror_top_bs);\n\n        error_propagate(errp, local_err);\n\n        return;\n\n\n\n\n    /* Make sure that the source is not resized while the job is running */\n\n    s = block_job_create(job_id, driver, mirror_top_bs,\n\n                         BLK_PERM_CONSISTENT_READ,\n\n                         BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE_UNCHANGED |\n\n                         BLK_PERM_WRITE | BLK_PERM_GRAPH_MOD, speed,\n\n                         creation_flags, cb, opaque, errp);\n\n    if (!s) {\n\n        goto fail;\n\n\n    /* The block job now has a reference to this node */\n\n    bdrv_unref(mirror_top_bs);\n\n\n\n    s->source = bs;\n\n    s->mirror_top_bs = mirror_top_bs;\n\n\n\n    /* No resize for the target either; while the mirror is still running, a\n\n     * consistent read isn't necessarily possible. We could possibly allow\n\n     * writes and graph modifications, though it would likely defeat the\n\n     * purpose of a mirror, so leave them blocked for now.\n\n     *\n\n     * In the case of active commit, things look a bit different, though,\n\n     * because the target is an already populated backing file in active use.\n\n     * We can allow anything except resize there.*/\n\n    target_is_backing = bdrv_chain_contains(bs, target);\n\n    target_graph_mod = (backing_mode != MIRROR_LEAVE_BACKING_CHAIN);\n\n    s->target = blk_new(BLK_PERM_WRITE | BLK_PERM_RESIZE |\n\n                        (target_graph_mod ? BLK_PERM_GRAPH_MOD : 0),\n\n                        BLK_PERM_WRITE_UNCHANGED |\n\n                        (target_is_backing ? BLK_PERM_CONSISTENT_READ |\n\n                                             BLK_PERM_WRITE |\n\n                                             BLK_PERM_GRAPH_MOD : 0));\n\n    ret = blk_insert_bs(s->target, target, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    s->replaces = g_strdup(replaces);\n\n    s->on_source_error = on_source_error;\n\n    s->on_target_error = on_target_error;\n\n    s->is_none_mode = is_none_mode;\n\n    s->backing_mode = backing_mode;\n\n    s->base = base;\n\n    s->granularity = granularity;\n\n    s->buf_size = ROUND_UP(buf_size, granularity);\n\n    s->unmap = unmap;\n\n    if (auto_complete) {\n\n        s->should_complete = true;\n\n\n\n\n    s->dirty_bitmap = bdrv_create_dirty_bitmap(bs, granularity, NULL, errp);\n\n    if (!s->dirty_bitmap) {\n\n        goto fail;\n\n\n\n\n    /* Required permissions are already taken with blk_new() */\n\n    block_job_add_bdrv(&s->common, \"target\", target, 0, BLK_PERM_ALL,\n\n                       &error_abort);\n\n\n\n    /* In commit_active_start() all intermediate nodes disappear, so\n\n     * any jobs in them must be blocked */\n\n    if (target_is_backing) {\n\n        BlockDriverState *iter;\n\n        for (iter = backing_bs(bs); iter != target; iter = backing_bs(iter)) {\n\n            /* XXX BLK_PERM_WRITE needs to be allowed so we don't block\n\n             * ourselves at s->base (if writes are blocked for a node, they are\n\n             * also blocked for its backing file). The other options would be a\n\n             * second filter driver above s->base (== target). */\n\n            ret = block_job_add_bdrv(&s->common, \"intermediate node\", iter, 0,\n\n                                     BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE,\n\n                                     errp);\n\n            if (ret < 0) {\n\n                goto fail;\n\n\n\n\n\n\n    trace_mirror_start(bs, s, opaque);\n\n    block_job_start(&s->common);\n\n    return;\n\n\n\nfail:\n\n    if (s) {\n\n        /* Make sure this BDS does not go away until we have completed the graph\n\n         * changes below */\n\n        bdrv_ref(mirror_top_bs);\n\n\n\n        g_free(s->replaces);\n\n        blk_unref(s->target);\n\n        block_job_early_fail(&s->common);\n\n\n\n\n    bdrv_child_try_set_perm(mirror_top_bs->backing, 0, BLK_PERM_ALL,\n\n                            &error_abort);\n\n    bdrv_replace_node(mirror_top_bs, backing_bs(mirror_top_bs), &error_abort);\n\n\n\n    bdrv_unref(mirror_top_bs);\n", "idx": 22498}
{"project": "qemu", "commit_id": "afd9096eb1882f23929f5b5c177898ed231bac66", "target": 1, "func": "void *virtqueue_pop(VirtQueue *vq, size_t sz)\n{\n    unsigned int i, head, max;\n    hwaddr desc_pa = vq->vring.desc;\n    VirtIODevice *vdev = vq->vdev;\n    VirtQueueElement *elem;\n    unsigned out_num, in_num;\n    hwaddr addr[VIRTQUEUE_MAX_SIZE];\n    struct iovec iov[VIRTQUEUE_MAX_SIZE];\n    VRingDesc desc;\n    if (virtio_queue_empty(vq)) {\n        return NULL;\n    /* Needed after virtio_queue_empty(), see comment in\n     * virtqueue_num_heads(). */\n    smp_rmb();\n    /* When we start there are none of either input nor output. */\n    out_num = in_num = 0;\n    max = vq->vring.num;\n    i = head = virtqueue_get_head(vq, vq->last_avail_idx++);\n    if (virtio_vdev_has_feature(vdev, VIRTIO_RING_F_EVENT_IDX)) {\n        vring_set_avail_event(vq, vq->last_avail_idx);\n    vring_desc_read(vdev, &desc, desc_pa, i);\n    if (desc.flags & VRING_DESC_F_INDIRECT) {\n        if (desc.len % sizeof(VRingDesc)) {\n            error_report(\"Invalid size for indirect buffer table\");\n        /* loop over the indirect descriptor table */\n        max = desc.len / sizeof(VRingDesc);\n        desc_pa = desc.addr;\n        i = 0;\n        vring_desc_read(vdev, &desc, desc_pa, i);\n    /* Collect all the descriptors */\n    do {\n        if (desc.flags & VRING_DESC_F_WRITE) {\n            virtqueue_map_desc(&in_num, addr + out_num, iov + out_num,\n                               VIRTQUEUE_MAX_SIZE - out_num, true, desc.addr, desc.len);\n        } else {\n            if (in_num) {\n                error_report(\"Incorrect order for descriptors\");\n            virtqueue_map_desc(&out_num, addr, iov,\n                               VIRTQUEUE_MAX_SIZE, false, desc.addr, desc.len);\n        /* If we've got too many, that implies a descriptor loop. */\n        if ((in_num + out_num) > max) {\n            error_report(\"Looped descriptor\");\n    } while ((i = virtqueue_read_next_desc(vdev, &desc, desc_pa, max)) != max);\n    /* Now copy what we have collected and mapped */\n    elem = virtqueue_alloc_element(sz, out_num, in_num);\n    elem->index = head;\n    for (i = 0; i < out_num; i++) {\n        elem->out_addr[i] = addr[i];\n        elem->out_sg[i] = iov[i];\n    for (i = 0; i < in_num; i++) {\n        elem->in_addr[i] = addr[out_num + i];\n        elem->in_sg[i] = iov[out_num + i];\n    vq->inuse++;\n    trace_virtqueue_pop(vq, elem, elem->in_num, elem->out_num);\n    return elem;", "idx": 22502}
{"project": "qemu", "commit_id": "788cf9f8c8cbda53843e060540f3e91a060eb744", "target": 1, "func": "static int img_open_password(BlockBackend *blk, const char *filename,\n\n                             int flags, bool quiet)\n\n{\n\n    BlockDriverState *bs;\n\n    char password[256];\n\n\n\n    bs = blk_bs(blk);\n\n    if (bdrv_is_encrypted(bs) && bdrv_key_required(bs) &&\n\n        !(flags & BDRV_O_NO_IO)) {\n\n        qprintf(quiet, \"Disk image '%s' is encrypted.\\n\", filename);\n\n        if (qemu_read_password(password, sizeof(password)) < 0) {\n\n            error_report(\"No password given\");\n\n            return -1;\n\n        }\n\n        if (bdrv_set_key(bs, password) < 0) {\n\n            error_report(\"invalid password\");\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 22504}
{"project": "qemu", "commit_id": "5706db1deb061ee9affdcea81e59c4c2cad7c41e", "target": 1, "func": "static int wav_init_out (HWVoiceOut *hw, struct audsettings *as)\n\n{\n\n    WAVVoiceOut *wav = (WAVVoiceOut *) hw;\n\n    int bits16 = 0, stereo = 0;\n\n    uint8_t hdr[] = {\n\n        0x52, 0x49, 0x46, 0x46, 0x00, 0x00, 0x00, 0x00, 0x57, 0x41, 0x56,\n\n        0x45, 0x66, 0x6d, 0x74, 0x20, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00,\n\n        0x02, 0x00, 0x44, 0xac, 0x00, 0x00, 0x10, 0xb1, 0x02, 0x00, 0x04,\n\n        0x00, 0x10, 0x00, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00\n\n    };\n\n    struct audsettings wav_as = conf.settings;\n\n\n\n    (void) as;\n\n\n\n    stereo = wav_as.nchannels == 2;\n\n    switch (wav_as.fmt) {\n\n    case AUD_FMT_S8:\n\n    case AUD_FMT_U8:\n\n        bits16 = 0;\n\n        break;\n\n\n\n    case AUD_FMT_S16:\n\n    case AUD_FMT_U16:\n\n        bits16 = 1;\n\n        break;\n\n\n\n    case AUD_FMT_S32:\n\n    case AUD_FMT_U32:\n\n        dolog (\"WAVE files can not handle 32bit formats\\n\");\n\n        return -1;\n\n    }\n\n\n\n    hdr[34] = bits16 ? 0x10 : 0x08;\n\n\n\n    wav_as.endianness = 0;\n\n    audio_pcm_init_info (&hw->info, &wav_as);\n\n\n\n    hw->samples = 1024;\n\n    wav->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);\n\n    if (!wav->pcm_buf) {\n\n        dolog (\"Could not allocate buffer (%d bytes)\\n\",\n\n               hw->samples << hw->info.shift);\n\n        return -1;\n\n    }\n\n\n\n    le_store (hdr + 22, hw->info.nchannels, 2);\n\n    le_store (hdr + 24, hw->info.freq, 4);\n\n    le_store (hdr + 28, hw->info.freq << (bits16 + stereo), 4);\n\n    le_store (hdr + 32, 1 << (bits16 + stereo), 2);\n\n\n\n    wav->f = fopen (conf.wav_path, \"wb\");\n\n    if (!wav->f) {\n\n        dolog (\"Failed to open wave file `%s'\\nReason: %s\\n\",\n\n               conf.wav_path, strerror (errno));\n\n        g_free (wav->pcm_buf);\n\n        wav->pcm_buf = NULL;\n\n        return -1;\n\n    }\n\n\n\n    if (fwrite (hdr, sizeof (hdr), 1, wav->f) != 1) {\n\n        dolog (\"wav_init_out: failed to write header\\nReason: %s\\n\",\n\n               strerror(errno));\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 22507}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mfdcrx(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    /* NIP cannot be restored if the memory exception comes from an helper */\n\n    gen_update_nip(ctx, ctx->nip - 4);\n\n    gen_helper_load_dcr(cpu_gpr[rD(ctx->opcode)], cpu_env,\n\n                        cpu_gpr[rA(ctx->opcode)]);\n\n    /* Note: Rc update flag set leads to undefined state of Rc0 */\n\n#endif\n\n}\n", "idx": 22510}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_slbie(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    gen_helper_slbie(cpu_env, cpu_gpr[rB(ctx->opcode)]);\n\n#endif\n\n}\n", "idx": 22515}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int usb_hid_handle_data(USBDevice *dev, USBPacket *p)\n\n{\n\n    USBHIDState *s = (USBHIDState *)dev;\n\n    int ret = 0;\n\n\n\n    switch(p->pid) {\n\n    case USB_TOKEN_IN:\n\n        if (p->devep == 1) {\n\n            int64_t curtime = qemu_get_clock_ns(vm_clock);\n\n            if (!s->changed && (!s->idle || s->next_idle_clock - curtime > 0))\n\n                return USB_RET_NAK;\n\n            usb_hid_set_next_idle(s, curtime);\n\n            if (s->kind == USB_MOUSE || s->kind == USB_TABLET) {\n\n                ret = usb_pointer_poll(s, p->data, p->len);\n\n            }\n\n            else if (s->kind == USB_KEYBOARD) {\n\n                ret = usb_keyboard_poll(s, p->data, p->len);\n\n            }\n\n            s->changed = s->n > 0;\n\n        } else {\n\n            goto fail;\n\n        }\n\n        break;\n\n    case USB_TOKEN_OUT:\n\n    default:\n\n    fail:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n    return ret;\n\n}\n", "idx": 22516}
{"project": "qemu", "commit_id": "b125f9dc7bd68cd4c57189db4da83b0620b28a72", "target": 1, "func": "void dump_exec_info(FILE *f, fprintf_function cpu_fprintf)\n\n{\n\n    int i, target_code_size, max_target_code_size;\n\n    int direct_jmp_count, direct_jmp2_count, cross_page;\n\n    TranslationBlock *tb;\n\n\n\n    target_code_size = 0;\n\n    max_target_code_size = 0;\n\n    cross_page = 0;\n\n    direct_jmp_count = 0;\n\n    direct_jmp2_count = 0;\n\n    for (i = 0; i < tcg_ctx.tb_ctx.nb_tbs; i++) {\n\n        tb = &tcg_ctx.tb_ctx.tbs[i];\n\n        target_code_size += tb->size;\n\n        if (tb->size > max_target_code_size) {\n\n            max_target_code_size = tb->size;\n\n        }\n\n        if (tb->page_addr[1] != -1) {\n\n            cross_page++;\n\n        }\n\n        if (tb->tb_next_offset[0] != 0xffff) {\n\n            direct_jmp_count++;\n\n            if (tb->tb_next_offset[1] != 0xffff) {\n\n                direct_jmp2_count++;\n\n            }\n\n        }\n\n    }\n\n    /* XXX: avoid using doubles ? */\n\n    cpu_fprintf(f, \"Translation buffer state:\\n\");\n\n    cpu_fprintf(f, \"gen code size       %td/%zd\\n\",\n\n                tcg_ctx.code_gen_ptr - tcg_ctx.code_gen_buffer,\n\n                tcg_ctx.code_gen_buffer_max_size);\n\n    cpu_fprintf(f, \"TB count            %d/%d\\n\",\n\n            tcg_ctx.tb_ctx.nb_tbs, tcg_ctx.code_gen_max_blocks);\n\n    cpu_fprintf(f, \"TB avg target size  %d max=%d bytes\\n\",\n\n            tcg_ctx.tb_ctx.nb_tbs ? target_code_size /\n\n                    tcg_ctx.tb_ctx.nb_tbs : 0,\n\n            max_target_code_size);\n\n    cpu_fprintf(f, \"TB avg host size    %td bytes (expansion ratio: %0.1f)\\n\",\n\n            tcg_ctx.tb_ctx.nb_tbs ? (tcg_ctx.code_gen_ptr -\n\n                                     tcg_ctx.code_gen_buffer) /\n\n                                     tcg_ctx.tb_ctx.nb_tbs : 0,\n\n                target_code_size ? (double) (tcg_ctx.code_gen_ptr -\n\n                                             tcg_ctx.code_gen_buffer) /\n\n                                             target_code_size : 0);\n\n    cpu_fprintf(f, \"cross page TB count %d (%d%%)\\n\", cross_page,\n\n            tcg_ctx.tb_ctx.nb_tbs ? (cross_page * 100) /\n\n                                    tcg_ctx.tb_ctx.nb_tbs : 0);\n\n    cpu_fprintf(f, \"direct jump count   %d (%d%%) (2 jumps=%d %d%%)\\n\",\n\n                direct_jmp_count,\n\n                tcg_ctx.tb_ctx.nb_tbs ? (direct_jmp_count * 100) /\n\n                        tcg_ctx.tb_ctx.nb_tbs : 0,\n\n                direct_jmp2_count,\n\n                tcg_ctx.tb_ctx.nb_tbs ? (direct_jmp2_count * 100) /\n\n                        tcg_ctx.tb_ctx.nb_tbs : 0);\n\n    cpu_fprintf(f, \"\\nStatistics:\\n\");\n\n    cpu_fprintf(f, \"TB flush count      %d\\n\", tcg_ctx.tb_ctx.tb_flush_count);\n\n    cpu_fprintf(f, \"TB invalidate count %d\\n\",\n\n            tcg_ctx.tb_ctx.tb_phys_invalidate_count);\n\n    cpu_fprintf(f, \"TLB flush count     %d\\n\", tlb_flush_count);\n\n    tcg_dump_info(f, cpu_fprintf);\n\n}\n", "idx": 22519}
{"project": "qemu", "commit_id": "39e594dbcd897849f2ca95b3310ea00fff29ea99", "target": 1, "func": "static sd_rsp_type_t sd_normal_command(SDState *sd,\n                                       SDRequest req)\n{\n    uint32_t rca = 0x0000;\n    uint64_t addr = (sd->ocr & (1 << 30)) ? (uint64_t) req.arg << 9 : req.arg;\n    if (sd_cmd_type[req.cmd] == sd_ac || sd_cmd_type[req.cmd] == sd_adtc)\n        rca = req.arg >> 16;\n    DPRINTF(\"CMD%d 0x%08x state %d\\n\", req.cmd, req.arg, sd->state);\n    switch (req.cmd) {\n    /* Basic commands (Class 0 and Class 1) */\n    case 0:\t/* CMD0:   GO_IDLE_STATE */\n        switch (sd->state) {\n        case sd_inactive_state:\n            return sd->spi ? sd_r1 : sd_r0;\n        default:\n            sd->state = sd_idle_state;\n            sd_reset(sd, sd->bdrv);\n            return sd->spi ? sd_r1 : sd_r0;\n        }\n        break;\n    case 1:\t/* CMD1:   SEND_OP_CMD */\n        if (!sd->spi)\n            goto bad_cmd;\n        sd->state = sd_transfer_state;\n        return sd_r1;\n    case 2:\t/* CMD2:   ALL_SEND_CID */\n        if (sd->spi)\n            goto bad_cmd;\n        switch (sd->state) {\n        case sd_ready_state:\n            sd->state = sd_identification_state;\n            return sd_r2_i;\n        default:\n            break;\n        }\n        break;\n    case 3:\t/* CMD3:   SEND_RELATIVE_ADDR */\n        if (sd->spi)\n            goto bad_cmd;\n        switch (sd->state) {\n        case sd_identification_state:\n        case sd_standby_state:\n            sd->state = sd_standby_state;\n            sd_set_rca(sd);\n            return sd_r6;\n        default:\n            break;\n        }\n        break;\n    case 4:\t/* CMD4:   SEND_DSR */\n        if (sd->spi)\n            goto bad_cmd;\n        switch (sd->state) {\n        case sd_standby_state:\n            break;\n        default:\n            break;\n        }\n        break;\n    case 5: /* CMD5: reserved for SDIO cards */\n    case 6:\t/* CMD6:   SWITCH_FUNCTION */\n        if (sd->spi)\n            goto bad_cmd;\n        switch (sd->mode) {\n        case sd_data_transfer_mode:\n            sd_function_switch(sd, req.arg);\n            sd->state = sd_sendingdata_state;\n            sd->data_start = 0;\n            sd->data_offset = 0;\n            return sd_r1;\n        default:\n            break;\n        }\n        break;\n    case 7:\t/* CMD7:   SELECT/DESELECT_CARD */\n        if (sd->spi)\n            goto bad_cmd;\n        switch (sd->state) {\n        case sd_standby_state:\n            if (sd->rca != rca)\n            sd->state = sd_transfer_state;\n            return sd_r1b;\n        case sd_transfer_state:\n        case sd_sendingdata_state:\n            if (sd->rca == rca)\n                break;\n            sd->state = sd_standby_state;\n            return sd_r1b;\n        case sd_disconnect_state:\n            if (sd->rca != rca)\n            sd->state = sd_programming_state;\n            return sd_r1b;\n        case sd_programming_state:\n            if (sd->rca == rca)\n                break;\n            sd->state = sd_disconnect_state;\n            return sd_r1b;\n        default:\n            break;\n        }\n        break;\n    case 8:\t/* CMD8:   SEND_IF_COND */\n        /* Physical Layer Specification Version 2.00 command */\n        switch (sd->state) {\n        case sd_idle_state:\n            sd->vhs = 0;\n            /* No response if not exactly one VHS bit is set.  */\n            if (!(req.arg >> 8) || (req.arg >> ffs(req.arg & ~0xff)))\n                return sd->spi ? sd_r7 : sd_r0;\n            /* Accept.  */\n            sd->vhs = req.arg;\n            return sd_r7;\n        default:\n            break;\n        }\n        break;\n    case 9:\t/* CMD9:   SEND_CSD */\n        switch (sd->state) {\n        case sd_standby_state:\n            if (sd->rca != rca)\n            return sd_r2_s;\n        case sd_transfer_state:\n            if (!sd->spi)\n                break;\n            sd->state = sd_sendingdata_state;\n            memcpy(sd->data, sd->csd, 16);\n            sd->data_start = addr;\n            sd->data_offset = 0;\n            return sd_r1;\n        default:\n            break;\n        }\n        break;\n    case 10:\t/* CMD10:  SEND_CID */\n        switch (sd->state) {\n        case sd_standby_state:\n            if (sd->rca != rca)\n            return sd_r2_i;\n        case sd_transfer_state:\n            if (!sd->spi)\n                break;\n            sd->state = sd_sendingdata_state;\n            memcpy(sd->data, sd->cid, 16);\n            sd->data_start = addr;\n            sd->data_offset = 0;\n            return sd_r1;\n        default:\n            break;\n        }\n        break;\n    case 11:\t/* CMD11:  READ_DAT_UNTIL_STOP */\n        if (sd->spi)\n            goto bad_cmd;\n        switch (sd->state) {\n        case sd_transfer_state:\n            sd->state = sd_sendingdata_state;\n            sd->data_start = req.arg;\n            sd->data_offset = 0;\n            if (sd->data_start + sd->blk_len > sd->size)\n                sd->card_status |= ADDRESS_ERROR;\n        default:\n            break;\n        }\n        break;\n    case 12:\t/* CMD12:  STOP_TRANSMISSION */\n        switch (sd->state) {\n        case sd_sendingdata_state:\n            sd->state = sd_transfer_state;\n            return sd_r1b;\n        case sd_receivingdata_state:\n            sd->state = sd_programming_state;\n            /* Bzzzzzzztt .... Operation complete.  */\n            sd->state = sd_transfer_state;\n            return sd_r1b;\n        default:\n            break;\n        }\n        break;\n    case 13:\t/* CMD13:  SEND_STATUS */\n        switch (sd->mode) {\n        case sd_data_transfer_mode:\n            if (sd->rca != rca)\n            return sd_r1;\n        default:\n            break;\n        }\n        break;\n    case 15:\t/* CMD15:  GO_INACTIVE_STATE */\n        if (sd->spi)\n            goto bad_cmd;\n        switch (sd->mode) {\n        case sd_data_transfer_mode:\n            if (sd->rca != rca)\n            sd->state = sd_inactive_state;\n        default:\n            break;\n        }\n        break;\n    /* Block read commands (Classs 2) */\n    case 16:\t/* CMD16:  SET_BLOCKLEN */\n        switch (sd->state) {\n        case sd_transfer_state:\n            if (req.arg > (1 << HWBLOCK_SHIFT))\n                sd->card_status |= BLOCK_LEN_ERROR;\n            else\n                sd->blk_len = req.arg;\n            return sd_r1;\n        default:\n            break;\n        }\n        break;\n    case 17:\t/* CMD17:  READ_SINGLE_BLOCK */\n        switch (sd->state) {\n        case sd_transfer_state:\n            sd->state = sd_sendingdata_state;\n            sd->data_start = addr;\n            sd->data_offset = 0;\n            if (sd->data_start + sd->blk_len > sd->size)\n                sd->card_status |= ADDRESS_ERROR;\n            return sd_r1;\n        default:\n            break;\n        }\n        break;\n    case 18:\t/* CMD18:  READ_MULTIPLE_BLOCK */\n        switch (sd->state) {\n        case sd_transfer_state:\n            sd->state = sd_sendingdata_state;\n            sd->data_start = addr;\n            sd->data_offset = 0;\n            if (sd->data_start + sd->blk_len > sd->size)\n                sd->card_status |= ADDRESS_ERROR;\n            return sd_r1;\n        default:\n            break;\n        }\n        break;\n    /* Block write commands (Class 4) */\n    case 24:\t/* CMD24:  WRITE_SINGLE_BLOCK */\n        if (sd->spi)\n            goto unimplemented_cmd;\n        switch (sd->state) {\n        case sd_transfer_state:\n            /* Writing in SPI mode not implemented.  */\n            if (sd->spi)\n                break;\n            sd->state = sd_receivingdata_state;\n            sd->data_start = addr;\n            sd->data_offset = 0;\n            sd->blk_written = 0;\n            if (sd->data_start + sd->blk_len > sd->size)\n                sd->card_status |= ADDRESS_ERROR;\n            if (sd_wp_addr(sd, sd->data_start))\n                sd->card_status |= WP_VIOLATION;\n            if (sd->csd[14] & 0x30)\n                sd->card_status |= WP_VIOLATION;\n            return sd_r1;\n        default:\n            break;\n        }\n        break;\n    case 25:\t/* CMD25:  WRITE_MULTIPLE_BLOCK */\n        if (sd->spi)\n            goto unimplemented_cmd;\n        switch (sd->state) {\n        case sd_transfer_state:\n            /* Writing in SPI mode not implemented.  */\n            if (sd->spi)\n                break;\n            sd->state = sd_receivingdata_state;\n            sd->data_start = addr;\n            sd->data_offset = 0;\n            sd->blk_written = 0;\n            if (sd->data_start + sd->blk_len > sd->size)\n                sd->card_status |= ADDRESS_ERROR;\n            if (sd_wp_addr(sd, sd->data_start))\n                sd->card_status |= WP_VIOLATION;\n            if (sd->csd[14] & 0x30)\n                sd->card_status |= WP_VIOLATION;\n            return sd_r1;\n        default:\n            break;\n        }\n        break;\n    case 26:\t/* CMD26:  PROGRAM_CID */\n        if (sd->spi)\n            goto bad_cmd;\n        switch (sd->state) {\n        case sd_transfer_state:\n            sd->state = sd_receivingdata_state;\n            sd->data_start = 0;\n            sd->data_offset = 0;\n            return sd_r1;\n        default:\n            break;\n        }\n        break;\n    case 27:\t/* CMD27:  PROGRAM_CSD */\n        if (sd->spi)\n            goto unimplemented_cmd;\n        switch (sd->state) {\n        case sd_transfer_state:\n            sd->state = sd_receivingdata_state;\n            sd->data_start = 0;\n            sd->data_offset = 0;\n            return sd_r1;\n        default:\n            break;\n        }\n        break;\n    /* Write protection (Class 6) */\n    case 28:\t/* CMD28:  SET_WRITE_PROT */\n        switch (sd->state) {\n        case sd_transfer_state:\n            if (addr >= sd->size) {\n                sd->card_status = ADDRESS_ERROR;\n                return sd_r1b;\n            }\n            sd->state = sd_programming_state;\n            sd->wp_groups[addr >> (HWBLOCK_SHIFT +\n                            SECTOR_SHIFT + WPGROUP_SHIFT)] = 1;\n            /* Bzzzzzzztt .... Operation complete.  */\n            sd->state = sd_transfer_state;\n            return sd_r1b;\n        default:\n            break;\n        }\n        break;\n    case 29:\t/* CMD29:  CLR_WRITE_PROT */\n        switch (sd->state) {\n        case sd_transfer_state:\n            if (addr >= sd->size) {\n                sd->card_status = ADDRESS_ERROR;\n                return sd_r1b;\n            }\n            sd->state = sd_programming_state;\n            sd->wp_groups[addr >> (HWBLOCK_SHIFT +\n                            SECTOR_SHIFT + WPGROUP_SHIFT)] = 0;\n            /* Bzzzzzzztt .... Operation complete.  */\n            sd->state = sd_transfer_state;\n            return sd_r1b;\n        default:\n            break;\n        }\n        break;\n    case 30:\t/* CMD30:  SEND_WRITE_PROT */\n        switch (sd->state) {\n        case sd_transfer_state:\n            sd->state = sd_sendingdata_state;\n            *(uint32_t *) sd->data = sd_wpbits(sd, req.arg);\n            sd->data_start = addr;\n            sd->data_offset = 0;\n            return sd_r1b;\n        default:\n            break;\n        }\n        break;\n    /* Erase commands (Class 5) */\n    case 32:\t/* CMD32:  ERASE_WR_BLK_START */\n        switch (sd->state) {\n        case sd_transfer_state:\n            sd->erase_start = req.arg;\n            return sd_r1;\n        default:\n            break;\n        }\n        break;\n    case 33:\t/* CMD33:  ERASE_WR_BLK_END */\n        switch (sd->state) {\n        case sd_transfer_state:\n            sd->erase_end = req.arg;\n            return sd_r1;\n        default:\n            break;\n        }\n        break;\n    case 38:\t/* CMD38:  ERASE */\n        switch (sd->state) {\n        case sd_transfer_state:\n            if (sd->csd[14] & 0x30) {\n                sd->card_status |= WP_VIOLATION;\n                return sd_r1b;\n            }\n            sd->state = sd_programming_state;\n            sd_erase(sd);\n            /* Bzzzzzzztt .... Operation complete.  */\n            sd->state = sd_transfer_state;\n            return sd_r1b;\n        default:\n            break;\n        }\n        break;\n    /* Lock card commands (Class 7) */\n    case 42:\t/* CMD42:  LOCK_UNLOCK */\n        if (sd->spi)\n            goto unimplemented_cmd;\n        switch (sd->state) {\n        case sd_transfer_state:\n            sd->state = sd_receivingdata_state;\n            sd->data_start = 0;\n            sd->data_offset = 0;\n            return sd_r1;\n        default:\n            break;\n        }\n        break;\n    /* Application specific commands (Class 8) */\n    case 55:\t/* CMD55:  APP_CMD */\n        if (sd->rca != rca)\n        sd->card_status |= APP_CMD;\n        return sd_r1;\n    case 56:\t/* CMD56:  GEN_CMD */\n        fprintf(stderr, \"SD: GEN_CMD 0x%08x\\n\", req.arg);\n        switch (sd->state) {\n        case sd_transfer_state:\n            sd->data_offset = 0;\n            if (req.arg & 1)\n                sd->state = sd_sendingdata_state;\n            else\n                sd->state = sd_receivingdata_state;\n            return sd_r1;\n        default:\n            break;\n        }\n        break;\n    default:\n    bad_cmd:\n        fprintf(stderr, \"SD: Unknown CMD%i\\n\", req.cmd);\n    unimplemented_cmd:\n        /* Commands that are recognised but not yet implemented in SPI mode.  */\n        fprintf(stderr, \"SD: CMD%i not implemented in SPI mode\\n\", req.cmd);\n    }\n    fprintf(stderr, \"SD: CMD%i in a wrong state\\n\", req.cmd);\n}", "idx": 22520}
{"project": "qemu", "commit_id": "c3e10c7b4377c1cbc0a4fbc12312c2cf41c0cda7", "target": 1, "func": "void OPPROTO op_405_check_ov (void)\n\n{\n\n    do_405_check_ov();\n\n    RETURN();\n\n}\n", "idx": 22525}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void put_int32(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    int32_t *v = pv;\n\n    qemu_put_sbe32s(f, v);\n\n}\n", "idx": 22526}
{"project": "qemu", "commit_id": "eff235eb2bcd7092901f4698a7907e742f3b7f2f", "target": 1, "func": "static ExitStatus trans_fop_wew_0c(DisasContext *ctx, uint32_t insn,\n\n                                   const DisasInsn *di)\n\n{\n\n    unsigned rt = extract32(insn, 0, 5);\n\n    unsigned ra = extract32(insn, 21, 5);\n\n    return do_fop_wew(ctx, rt, ra, di->f_wew);\n\n}\n", "idx": 22527}
{"project": "qemu", "commit_id": "9ed257d1d1c65dbe5a08f207e5106e98384e1860", "target": 1, "func": "static int common_bind(struct common *c)\n\n{\n\n    uint64_t mfn;\n\n\n\n    if (xenstore_read_fe_uint64(&c->xendev, \"page-ref\", &mfn) == -1)\n\n\treturn -1;\n\n    assert(mfn == (xen_pfn_t)mfn);\n\n\n\n    if (xenstore_read_fe_int(&c->xendev, \"event-channel\", &c->xendev.remote_port) == -1)\n\n\treturn -1;\n\n\n\n    c->page = xc_map_foreign_range(xen_xc, c->xendev.dom,\n\n\t\t\t\t   XC_PAGE_SIZE,\n\n\t\t\t\t   PROT_READ | PROT_WRITE, mfn);\n\n    if (c->page == NULL)\n\n\treturn -1;\n\n\n\n    xen_be_bind_evtchn(&c->xendev);\n\n    xen_be_printf(&c->xendev, 1, \"ring mfn %\"PRIx64\", remote-port %d, local-port %d\\n\",\n\n\t\t  mfn, c->xendev.remote_port, c->xendev.local_port);\n\n\n\n    return 0;\n\n}\n", "idx": 22529}
{"project": "qemu", "commit_id": "6b49809c597331803ea941eadda813e5bb4e8fe2", "target": 1, "func": "void qemu_mutex_lock_iothread(void)\n\n{\n\n    if (!tcg_enabled()) {\n\n        qemu_mutex_lock(&qemu_global_mutex);\n\n    } else {\n\n        iothread_requesting_mutex = true;\n\n        if (qemu_mutex_trylock(&qemu_global_mutex)) {\n\n            qemu_cpu_kick_thread(first_cpu);\n\n            qemu_mutex_lock(&qemu_global_mutex);\n\n        }\n\n        iothread_requesting_mutex = false;\n\n        qemu_cond_broadcast(&qemu_io_proceeded_cond);\n\n    }\n\n}\n", "idx": 22534}
{"project": "qemu", "commit_id": "9ef91a677110ec200d7b2904fc4bcae5a77329ad", "target": 0, "func": "static int qemu_paio_submit(struct qemu_paiocb *aiocb, int type)\n\n{\n\n    aiocb->aio_type = type;\n\n    aiocb->ret = -EINPROGRESS;\n\n    aiocb->active = 0;\n\n    mutex_lock(&lock);\n\n    if (idle_threads == 0 && cur_threads < max_threads)\n\n        spawn_thread();\n\n    TAILQ_INSERT_TAIL(&request_list, aiocb, node);\n\n    mutex_unlock(&lock);\n\n    cond_signal(&cond);\n\n\n\n    return 0;\n\n}\n", "idx": 22539}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fnmadd(CPUPPCState *env, uint64_t arg1, uint64_t arg2,\n\n                       uint64_t arg3)\n\n{\n\n    CPU_DoubleU farg1, farg2, farg3;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n    farg3.ll = arg3;\n\n\n\n    if (unlikely((float64_is_infinity(farg1.d) && float64_is_zero(farg2.d)) ||\n\n                 (float64_is_zero(farg1.d) && float64_is_infinity(farg2.d)))) {\n\n        /* Multiplication of zero by infinity */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIMZ);\n\n    } else {\n\n        if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                     float64_is_signaling_nan(farg2.d) ||\n\n                     float64_is_signaling_nan(farg3.d))) {\n\n            /* sNaN operation */\n\n            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n        }\n\n        /* This is the way the PowerPC specification defines it */\n\n        float128 ft0_128, ft1_128;\n\n\n\n        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);\n\n        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);\n\n        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);\n\n        if (unlikely(float128_is_infinity(ft0_128) &&\n\n                     float64_is_infinity(farg3.d) &&\n\n                     float128_is_neg(ft0_128) != float64_is_neg(farg3.d))) {\n\n            /* Magnitude subtraction of infinities */\n\n            farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXISI);\n\n        } else {\n\n            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);\n\n            ft0_128 = float128_add(ft0_128, ft1_128, &env->fp_status);\n\n            farg1.d = float128_to_float64(ft0_128, &env->fp_status);\n\n        }\n\n        if (likely(!float64_is_any_nan(farg1.d))) {\n\n            farg1.d = float64_chs(farg1.d);\n\n        }\n\n    }\n\n    return farg1.ll;\n\n}\n", "idx": 22540}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static BlockAIOCB *bdrv_aio_writev_em(BlockDriverState *bs,\n\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n        BlockCompletionFunc *cb, void *opaque)\n\n{\n\n    return bdrv_aio_rw_vector(bs, sector_num, qiov, nb_sectors, cb, opaque, 1);\n\n}\n", "idx": 22541}
{"project": "qemu", "commit_id": "b02ef3d92b19ad304a84433d3817f0903296ebc7", "target": 0, "func": "static void attach_storage_element(SCLPDevice *sclp, SCCB *sccb,\n\n                                   uint16_t element)\n\n{\n\n    int i, assigned, subincrement_id;\n\n    AttachStorageElement *attach_info = (AttachStorageElement *) sccb;\n\n    sclpMemoryHotplugDev *mhd = get_sclp_memory_hotplug_dev();\n\n\n\n    assert(mhd);\n\n\n\n    if (element != 1) {\n\n        sccb->h.response_code = cpu_to_be16(SCLP_RC_INVALID_SCLP_COMMAND);\n\n        return;\n\n    }\n\n\n\n    assigned = mhd->standby_mem_size >> mhd->increment_size;\n\n    attach_info->assigned = cpu_to_be16(assigned);\n\n    subincrement_id = ((ram_size >> mhd->increment_size) << 16)\n\n                      + SCLP_STARTING_SUBINCREMENT_ID;\n\n    for (i = 0; i < assigned; i++) {\n\n        attach_info->entries[i] = cpu_to_be32(subincrement_id);\n\n        subincrement_id += SCLP_INCREMENT_UNIT;\n\n    }\n\n    sccb->h.response_code = cpu_to_be16(SCLP_RC_NORMAL_COMPLETION);\n\n}\n", "idx": 22542}
{"project": "qemu", "commit_id": "1ec26c757d5996468afcc0dced4fad04139574b3", "target": 0, "func": "static void kvmppc_pivot_hpt_cpu(CPUState *cs, run_on_cpu_data arg)\n\n{\n\n    target_ulong sdr1 = arg.target_ptr;\n\n    PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n    CPUPPCState *env = &cpu->env;\n\n\n\n    /* This is just for the benefit of PR KVM */\n\n    cpu_synchronize_state(cs);\n\n    env->spr[SPR_SDR1] = sdr1;\n\n    if (kvmppc_put_books_sregs(cpu) < 0) {\n\n        error_report(\"Unable to update SDR1 in KVM\");\n\n        exit(1);\n\n    }\n\n}\n", "idx": 22543}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static int send_rect_simple(VncState *vs, int x, int y, int w, int h)\n\n{\n\n    int max_size, max_width;\n\n    int max_sub_width, max_sub_height;\n\n    int dx, dy;\n\n    int rw, rh;\n\n    int n = 0;\n\n\n\n    max_size = tight_conf[vs->tight_compression].max_rect_size;\n\n    max_width = tight_conf[vs->tight_compression].max_rect_width;\n\n\n\n    if (w > max_width || w * h > max_size) {\n\n        max_sub_width = (w > max_width) ? max_width : w;\n\n        max_sub_height = max_size / max_sub_width;\n\n\n\n        for (dy = 0; dy < h; dy += max_sub_height) {\n\n            for (dx = 0; dx < w; dx += max_width) {\n\n                rw = MIN(max_sub_width, w - dx);\n\n                rh = MIN(max_sub_height, h - dy);\n\n                n += send_sub_rect(vs, x+dx, y+dy, rw, rh);\n\n            }\n\n        }\n\n    } else {\n\n        n += send_sub_rect(vs, x, y, w, h);\n\n    }\n\n\n\n    return n;\n\n}\n", "idx": 22544}
{"project": "qemu", "commit_id": "6e0d8677cb443e7408c0b7a25a93c6596d7fa380", "target": 0, "func": "static inline void gen_op_addl_ESP_im(int32_t val)\n\n{\n\n    tcg_gen_ld_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));\n\n    tcg_gen_addi_tl(cpu_tmp0, cpu_tmp0, val);\n\n#ifdef TARGET_X86_64\n\n    tcg_gen_andi_tl(cpu_tmp0, cpu_tmp0, 0xffffffff);\n\n#endif\n\n    tcg_gen_st_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));\n\n}\n", "idx": 22545}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void t_gen_cc_jmp(TCGv pc_true, TCGv pc_false)\n\n{\n\n\tTCGv btaken;\n\n\tint l1;\n\n\n\n\tl1 = gen_new_label();\n\n\tbtaken = tcg_temp_new(TCG_TYPE_TL);\n\n\n\n\t/* Conditional jmp.  */\n\n\ttcg_gen_mov_tl(btaken, env_btaken);\n\n\ttcg_gen_mov_tl(env_pc, pc_false);\n\n\ttcg_gen_brcondi_tl(TCG_COND_EQ, btaken, 0, l1);\n\n\ttcg_gen_mov_tl(env_pc, pc_true);\n\n\tgen_set_label(l1);\n\n\n\n\ttcg_temp_free(btaken);\n\n}\n", "idx": 22546}
{"project": "qemu", "commit_id": "958c717df97ea9ca47a2253b8371130fe5f22980", "target": 0, "func": "NBDClient *nbd_client_new(NBDExport *exp, int csock,\n\n                          void (*close)(NBDClient *))\n\n{\n\n    NBDClient *client;\n\n    client = g_malloc0(sizeof(NBDClient));\n\n    client->refcount = 1;\n\n    client->exp = exp;\n\n    client->sock = csock;\n\n    if (nbd_send_negotiate(client)) {\n\n        g_free(client);\n\n        return NULL;\n\n    }\n\n    client->close = close;\n\n    qemu_co_mutex_init(&client->send_lock);\n\n    qemu_set_fd_handler2(csock, nbd_can_read, nbd_read, NULL, client);\n\n\n\n    if (exp) {\n\n        QTAILQ_INSERT_TAIL(&exp->clients, client, next);\n\n        nbd_export_get(exp);\n\n    }\n\n    return client;\n\n}\n", "idx": 22547}
{"project": "qemu", "commit_id": "6e0d8677cb443e7408c0b7a25a93c6596d7fa380", "target": 0, "func": "static void gen_extu(int ot, TCGv reg)\n\n{\n\n    switch(ot) {\n\n    case OT_BYTE:\n\n        tcg_gen_ext8u_tl(reg, reg);\n\n        break;\n\n    case OT_WORD:\n\n        tcg_gen_ext16u_tl(reg, reg);\n\n        break;\n\n    case OT_LONG:\n\n        tcg_gen_ext32u_tl(reg, reg);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 22549}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "ssize_t read_targphys(const char *name,\n\n                      int fd, target_phys_addr_t dst_addr, size_t nbytes)\n\n{\n\n    uint8_t *buf;\n\n    ssize_t did;\n\n\n\n    buf = g_malloc(nbytes);\n\n    did = read(fd, buf, nbytes);\n\n    if (did > 0)\n\n        rom_add_blob_fixed(\"read\", buf, did, dst_addr);\n\n    g_free(buf);\n\n    return did;\n\n}\n", "idx": 22550}
{"project": "qemu", "commit_id": "6acbe4c6f18e7de00481ff30574262b58526de45", "target": 0, "func": "DeviceState *qdev_device_add(QemuOpts *opts)\n\n{\n\n    DeviceClass *k;\n\n    const char *driver, *path, *id;\n\n    DeviceState *qdev;\n\n    BusState *bus;\n\n\n\n    driver = qemu_opt_get(opts, \"driver\");\n\n    if (!driver) {\n\n        qerror_report(QERR_MISSING_PARAMETER, \"driver\");\n\n        return NULL;\n\n    }\n\n\n\n    /* find driver */\n\n    k = DEVICE_CLASS(object_class_by_name(driver));\n\n\n\n    /* find bus */\n\n    path = qemu_opt_get(opts, \"bus\");\n\n    if (path != NULL) {\n\n        bus = qbus_find(path);\n\n        if (!bus) {\n\n            return NULL;\n\n        }\n\n        if (bus->info != k->bus_info) {\n\n            qerror_report(QERR_BAD_BUS_FOR_DEVICE,\n\n                           driver, bus->info->name);\n\n            return NULL;\n\n        }\n\n    } else {\n\n        bus = qbus_find_recursive(main_system_bus, NULL, k->bus_info);\n\n        if (!bus) {\n\n            qerror_report(QERR_NO_BUS_FOR_DEVICE,\n\n                          driver, k->bus_info->name);\n\n            return NULL;\n\n        }\n\n    }\n\n    if (qdev_hotplug && !bus->allow_hotplug) {\n\n        qerror_report(QERR_BUS_NO_HOTPLUG, bus->name);\n\n        return NULL;\n\n    }\n\n\n\n    /* create device, set properties */\n\n    qdev = qdev_create_from_info(bus, driver);\n\n    id = qemu_opts_id(opts);\n\n    if (id) {\n\n        qdev->id = id;\n\n        qdev_property_add_child(qdev_get_peripheral(), qdev->id, qdev, NULL);\n\n    } else {\n\n        static int anon_count;\n\n        gchar *name = g_strdup_printf(\"device[%d]\", anon_count++);\n\n        qdev_property_add_child(qdev_get_peripheral_anon(), name,\n\n                                qdev, NULL);\n\n        g_free(name);\n\n    }        \n\n    if (qemu_opt_foreach(opts, set_property, qdev, 1) != 0) {\n\n        qdev_free(qdev);\n\n        return NULL;\n\n    }\n\n    if (qdev_init(qdev) < 0) {\n\n        qerror_report(QERR_DEVICE_INIT_FAILED, driver);\n\n        return NULL;\n\n    }\n\n    qdev->opts = opts;\n\n    return qdev;\n\n}\n", "idx": 22551}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_movu_r(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tint size = memsize_z(dc);\n\n\tDIS(fprintf (logfile, \"movu.%c $r%u, $r%u\\n\",\n\n\t\t    memsize_char(size),\n\n\t\t    dc->op1, dc->op2));\n\n\n\n\tcris_cc_mask(dc, CC_MASK_NZ);\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\tdec_prep_move_r(dc, dc->op1, dc->op2, size, 0, t0);\n\n\tcris_alu(dc, CC_OP_MOVE, cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n", "idx": 22552}
{"project": "qemu", "commit_id": "7e84c2498f0ff3999937d18d1e9abaa030400000", "target": 0, "func": "void helper_ljmp_protected_T0_T1(void)\n\n{\n\n    int new_cs, new_eip;\n\n    uint32_t e1, e2, cpl, dpl, rpl, limit;\n\n\n\n    new_cs = T0;\n\n    new_eip = T1;\n\n    if ((new_cs & 0xfffc) == 0)\n\n        raise_exception_err(EXCP0D_GPF, 0);\n\n    if (load_segment(&e1, &e2, new_cs) != 0)\n\n        raise_exception_err(EXCP0D_GPF, new_cs & 0xfffc);\n\n    cpl = env->hflags & HF_CPL_MASK;\n\n    if (e2 & DESC_S_MASK) {\n\n        if (!(e2 & DESC_CS_MASK))\n\n            raise_exception_err(EXCP0D_GPF, new_cs & 0xfffc);\n\n        dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n        if (e2 & DESC_CS_MASK) {\n\n            /* conforming code segment */\n\n            if (dpl > cpl)\n\n                raise_exception_err(EXCP0D_GPF, new_cs & 0xfffc);\n\n        } else {\n\n            /* non conforming code segment */\n\n            rpl = new_cs & 3;\n\n            if (rpl > cpl)\n\n                raise_exception_err(EXCP0D_GPF, new_cs & 0xfffc);\n\n            if (dpl != cpl)\n\n                raise_exception_err(EXCP0D_GPF, new_cs & 0xfffc);\n\n        }\n\n        if (!(e2 & DESC_P_MASK))\n\n            raise_exception_err(EXCP0B_NOSEG, new_cs & 0xfffc);\n\n        limit = get_seg_limit(e1, e2);\n\n        if (new_eip > limit)\n\n            raise_exception_err(EXCP0D_GPF, new_cs & 0xfffc);\n\n        cpu_x86_load_seg_cache(env, R_CS, (new_cs & 0xfffc) | cpl,\n\n                       get_seg_base(e1, e2), limit, e2);\n\n        EIP = new_eip;\n\n    } else {\n\n        cpu_abort(env, \"jmp to call/task gate not supported 0x%04x:0x%08x\", \n\n                  new_cs, new_eip);\n\n    }\n\n}\n", "idx": 22553}
{"project": "qemu", "commit_id": "ac531cb6e542b1e61d668604adf9dc5306a948c0", "target": 0, "func": "static void qdict_teardown(void)\n\n{\n\n    QDECREF(tests_dict);\n\n    tests_dict = NULL;\n\n}\n", "idx": 22554}
{"project": "qemu", "commit_id": "bec1631100323fac0900aea71043d5c4e22fc2fa", "target": 0, "func": "static void tcg_out_brcond(TCGContext *s, TCGCond cond,\n\n                           TCGArg arg1, TCGArg arg2, int const_arg2,\n\n                           int label_index, TCGType type)\n\n{\n\n    tcg_out_cmp(s, cond, arg1, arg2, const_arg2, 7, type);\n\n    tcg_out_bc(s, tcg_to_bc[cond], label_index);\n\n}\n", "idx": 22555}
{"project": "qemu", "commit_id": "fae2afb10e3fdceab612c62a2b1e8b944ff578d9", "target": 0, "func": "static void qxl_track_command(PCIQXLDevice *qxl, struct QXLCommandExt *ext)\n\n{\n\n    switch (le32_to_cpu(ext->cmd.type)) {\n\n    case QXL_CMD_SURFACE:\n\n    {\n\n        QXLSurfaceCmd *cmd = qxl_phys2virt(qxl, ext->cmd.data, ext->group_id);\n\n        uint32_t id = le32_to_cpu(cmd->surface_id);\n\n        PANIC_ON(id >= NUM_SURFACES);\n\n        qemu_mutex_lock(&qxl->track_lock);\n\n        if (cmd->type == QXL_SURFACE_CMD_CREATE) {\n\n            qxl->guest_surfaces.cmds[id] = ext->cmd.data;\n\n            qxl->guest_surfaces.count++;\n\n            if (qxl->guest_surfaces.max < qxl->guest_surfaces.count)\n\n                qxl->guest_surfaces.max = qxl->guest_surfaces.count;\n\n        }\n\n        if (cmd->type == QXL_SURFACE_CMD_DESTROY) {\n\n            qxl->guest_surfaces.cmds[id] = 0;\n\n            qxl->guest_surfaces.count--;\n\n        }\n\n        qemu_mutex_unlock(&qxl->track_lock);\n\n        break;\n\n    }\n\n    case QXL_CMD_CURSOR:\n\n    {\n\n        QXLCursorCmd *cmd = qxl_phys2virt(qxl, ext->cmd.data, ext->group_id);\n\n        if (cmd->type == QXL_CURSOR_SET) {\n\n            qemu_mutex_lock(&qxl->track_lock);\n\n            qxl->guest_cursor = ext->cmd.data;\n\n            qemu_mutex_unlock(&qxl->track_lock);\n\n        }\n\n        break;\n\n    }\n\n    }\n\n}\n", "idx": 22556}
{"project": "qemu", "commit_id": "c2fa30757a2ba1bb5b053883773a9a61fbdd7082", "target": 0, "func": "static void nvdimm_dsm_label_size(NVDIMMDevice *nvdimm, hwaddr dsm_mem_addr)\n\n{\n\n    NvdimmFuncGetLabelSizeOut label_size_out = {\n\n        .len = cpu_to_le32(sizeof(label_size_out)),\n\n    };\n\n    uint32_t label_size, mxfer;\n\n\n\n    label_size = nvdimm->label_size;\n\n    mxfer = nvdimm_get_max_xfer_label_size();\n\n\n\n    nvdimm_debug(\"label_size %#x, max_xfer %#x.\\n\", label_size, mxfer);\n\n\n\n    label_size_out.func_ret_status = cpu_to_le32(0 /* Success */);\n\n    label_size_out.label_size = cpu_to_le32(label_size);\n\n    label_size_out.max_xfer = cpu_to_le32(mxfer);\n\n\n\n    cpu_physical_memory_write(dsm_mem_addr, &label_size_out,\n\n                              sizeof(label_size_out));\n\n}\n", "idx": 22557}
{"project": "qemu", "commit_id": "bdb11366b9370e97fb436444c697c01fe839dc11", "target": 0, "func": "qemu_irq *armv7m_init(int flash_size, int sram_size,\n\n                      const char *kernel_filename, const char *cpu_model)\n\n{\n\n    CPUState *env;\n\n    DeviceState *nvic;\n\n    /* FIXME: make this local state.  */\n\n    static qemu_irq pic[64];\n\n    qemu_irq *cpu_pic;\n\n    uint32_t pc;\n\n    int image_size;\n\n    uint64_t entry;\n\n    uint64_t lowaddr;\n\n    int i;\n\n\n\n    flash_size *= 1024;\n\n    sram_size *= 1024;\n\n\n\n    if (!cpu_model)\n\n\tcpu_model = \"cortex-m3\";\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n\n\n#if 0\n\n    /* > 32Mb SRAM gets complicated because it overlaps the bitband area.\n\n       We don't have proper commandline options, so allocate half of memory\n\n       as SRAM, up to a maximum of 32Mb, and the rest as code.  */\n\n    if (ram_size > (512 + 32) * 1024 * 1024)\n\n        ram_size = (512 + 32) * 1024 * 1024;\n\n    sram_size = (ram_size / 2) & TARGET_PAGE_MASK;\n\n    if (sram_size > 32 * 1024 * 1024)\n\n        sram_size = 32 * 1024 * 1024;\n\n    code_size = ram_size - sram_size;\n\n#endif\n\n\n\n    /* Flash programming is done via the SCU, so pretend it is ROM.  */\n\n    cpu_register_physical_memory(0, flash_size,\n\n                                 qemu_ram_alloc(flash_size) | IO_MEM_ROM);\n\n    cpu_register_physical_memory(0x20000000, sram_size,\n\n                                 qemu_ram_alloc(sram_size) | IO_MEM_RAM);\n\n    armv7m_bitband_init();\n\n\n\n    nvic = qdev_create(NULL, \"armv7m_nvic\");\n\n    qdev_set_prop_ptr(nvic, \"cpu\", env);\n\n    qdev_init(nvic);\n\n    cpu_pic = arm_pic_init_cpu(env);\n\n    sysbus_connect_irq(sysbus_from_qdev(nvic), 0, cpu_pic[ARM_PIC_CPU_IRQ]);\n\n    for (i = 0; i < 64; i++) {\n\n        pic[i] = qdev_get_gpio_in(nvic, i);\n\n    }\n\n\n\n    image_size = load_elf(kernel_filename, 0, &entry, &lowaddr, NULL);\n\n    if (image_size < 0) {\n\n        image_size = load_image_targphys(kernel_filename, 0, flash_size);\n\n\tlowaddr = 0;\n\n    }\n\n    if (image_size < 0) {\n\n        fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                kernel_filename);\n\n        exit(1);\n\n    }\n\n\n\n    /* If the image was loaded at address zero then assume it is a\n\n       regular ROM image and perform the normal CPU reset sequence.\n\n       Otherwise jump directly to the entry point.  */\n\n    if (lowaddr == 0) {\n\n\tenv->regs[13] = ldl_phys(0);\n\n\tpc = ldl_phys(4);\n\n    } else {\n\n\tpc = entry;\n\n    }\n\n    env->thumb = pc & 1;\n\n    env->regs[15] = pc & ~1;\n\n\n\n    /* Hack to map an additional page of ram at the top of the address\n\n       space.  This stops qemu complaining about executing code outside RAM\n\n       when returning from an exception.  */\n\n    cpu_register_physical_memory(0xfffff000, 0x1000,\n\n                                 qemu_ram_alloc(0x1000) | IO_MEM_RAM);\n\n\n\n    return pic;\n\n}\n", "idx": 22558}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int monitor_get_fd(Monitor *mon, const char *fdname)\n\n{\n\n    mon_fd_t *monfd;\n\n\n\n    LIST_FOREACH(monfd, &mon->fds, next) {\n\n        int fd;\n\n\n\n        if (strcmp(monfd->name, fdname) != 0) {\n\n            continue;\n\n        }\n\n\n\n        fd = monfd->fd;\n\n\n\n        /* caller takes ownership of fd */\n\n        LIST_REMOVE(monfd, next);\n\n        qemu_free(monfd->name);\n\n        qemu_free(monfd);\n\n\n\n        return fd;\n\n    }\n\n\n\n    return -1;\n\n}\n", "idx": 22560}
{"project": "qemu", "commit_id": "fdfab37dfeffefbd4533b4158055c9b82d7c3e69", "target": 0, "func": "static int count_cow_clusters(BDRVQcow2State *s, int nb_clusters,\n\n    uint64_t *l2_table, int l2_index)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < nb_clusters; i++) {\n\n        uint64_t l2_entry = be64_to_cpu(l2_table[l2_index + i]);\n\n        QCow2ClusterType cluster_type = qcow2_get_cluster_type(l2_entry);\n\n\n\n        switch(cluster_type) {\n\n        case QCOW2_CLUSTER_NORMAL:\n\n            if (l2_entry & QCOW_OFLAG_COPIED) {\n\n                goto out;\n\n            }\n\n            break;\n\n        case QCOW2_CLUSTER_UNALLOCATED:\n\n        case QCOW2_CLUSTER_COMPRESSED:\n\n        case QCOW2_CLUSTER_ZERO:\n\n            break;\n\n        default:\n\n            abort();\n\n        }\n\n    }\n\n\n\nout:\n\n    assert(i <= nb_clusters);\n\n    return i;\n\n}\n", "idx": 22561}
{"project": "qemu", "commit_id": "74c85296dc880568005b8e7572e08a39d66bcdca", "target": 0, "func": "VirtIOS390Device *s390_virtio_bus_find_vring(VirtIOS390Bus *bus,\n\n                                             ram_addr_t mem,\n\n                                             int *vq_num)\n\n{\n\n    BusChild *kid;\n\n    int i;\n\n\n\n    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {\n\n        VirtIOS390Device *dev = (VirtIOS390Device *)kid->child;\n\n\n\n        for(i = 0; i < VIRTIO_PCI_QUEUE_MAX; i++) {\n\n            if (!virtio_queue_get_addr(dev->vdev, i))\n\n                break;\n\n            if (virtio_queue_get_addr(dev->vdev, i) == mem) {\n\n                if (vq_num) {\n\n                    *vq_num = i;\n\n                }\n\n                return dev;\n\n            }\n\n        }\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 22562}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "void sp804_init(uint32_t base, qemu_irq irq)\n\n{\n\n    int iomemtype;\n\n    sp804_state *s;\n\n    qemu_irq *qi;\n\n\n\n    s = (sp804_state *)qemu_mallocz(sizeof(sp804_state));\n\n    qi = qemu_allocate_irqs(sp804_set_irq, s, 2);\n\n    s->base = base;\n\n    s->irq = irq;\n\n    /* ??? The timers are actually configurable between 32kHz and 1MHz, but\n\n       we don't implement that.  */\n\n    s->timer[0] = arm_timer_init(1000000, qi[0]);\n\n    s->timer[1] = arm_timer_init(1000000, qi[1]);\n\n    iomemtype = cpu_register_io_memory(0, sp804_readfn,\n\n                                       sp804_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n    /* ??? Save/restore.  */\n\n}\n", "idx": 22569}
{"project": "qemu", "commit_id": "07caea315a85ebfe90851f9c2e4ef3fdd24117b5", "target": 1, "func": "static void network_init(void)\n\n{\n\n    int i;\n\n\n\n    for(i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n        const char *default_devaddr = NULL;\n\n\n\n        if (i == 0 && (!nd->model || strcmp(nd->model, \"pcnet\") == 0))\n\n            /* The malta board has a PCNet card using PCI SLOT 11 */\n\n            default_devaddr = \"0b\";\n\n\n\n        pci_nic_init(nd, \"pcnet\", default_devaddr);\n\n    }\n\n}\n", "idx": 22570}
{"project": "qemu", "commit_id": "2f9606b3736c3be4dbd606c46525c7b770ced119", "target": 1, "func": "static uint8_t *buffer_end(Buffer *buffer)\n\n{\n\n    return buffer->buffer + buffer->offset;\n\n}\n", "idx": 22571}
{"project": "qemu", "commit_id": "b45c03f585ea9bb1af76c73e82195418c294919d", "target": 1, "func": "PXA2xxState *pxa270_init(MemoryRegion *address_space,\n\n                         unsigned int sdram_size, const char *revision)\n\n{\n\n    PXA2xxState *s;\n\n    int i;\n\n    DriveInfo *dinfo;\n\n    s = (PXA2xxState *) g_malloc0(sizeof(PXA2xxState));\n\n\n\n    if (revision && strncmp(revision, \"pxa27\", 5)) {\n\n        fprintf(stderr, \"Machine requires a PXA27x processor.\\n\");\n\n        exit(1);\n\n    }\n\n    if (!revision)\n\n        revision = \"pxa270\";\n\n    \n\n    s->cpu = cpu_arm_init(revision);\n\n    if (s->cpu == NULL) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    s->reset = qemu_allocate_irq(pxa2xx_reset, s, 0);\n\n\n\n    /* SDRAM & Internal Memory Storage */\n\n    memory_region_init_ram(&s->sdram, NULL, \"pxa270.sdram\", sdram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->sdram);\n\n    memory_region_add_subregion(address_space, PXA2XX_SDRAM_BASE, &s->sdram);\n\n    memory_region_init_ram(&s->internal, NULL, \"pxa270.internal\", 0x40000,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->internal);\n\n    memory_region_add_subregion(address_space, PXA2XX_INTERNAL_BASE,\n\n                                &s->internal);\n\n\n\n    s->pic = pxa2xx_pic_init(0x40d00000, s->cpu);\n\n\n\n    s->dma = pxa27x_dma_init(0x40000000,\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_DMA));\n\n\n\n    sysbus_create_varargs(\"pxa27x-timer\", 0x40a00000,\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_OST_0 + 0),\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_OST_0 + 1),\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_OST_0 + 2),\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_OST_0 + 3),\n\n                    qdev_get_gpio_in(s->pic, PXA27X_PIC_OST_4_11),\n\n                    NULL);\n\n\n\n    s->gpio = pxa2xx_gpio_init(0x40e00000, s->cpu, s->pic, 121);\n\n\n\n    dinfo = drive_get(IF_SD, 0, 0);\n\n    if (!dinfo) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital device\\n\");\n\n        exit(1);\n\n    }\n\n    s->mmc = pxa2xx_mmci_init(address_space, 0x41100000,\n\n                    blk_by_legacy_dinfo(dinfo),\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_MMC),\n\n                    qdev_get_gpio_in(s->dma, PXA2XX_RX_RQ_MMCI),\n\n                    qdev_get_gpio_in(s->dma, PXA2XX_TX_RQ_MMCI));\n\n\n\n    for (i = 0; pxa270_serial[i].io_base; i++) {\n\n        if (serial_hds[i]) {\n\n            serial_mm_init(address_space, pxa270_serial[i].io_base, 2,\n\n                           qdev_get_gpio_in(s->pic, pxa270_serial[i].irqn),\n\n                           14857000 / 16, serial_hds[i],\n\n                           DEVICE_NATIVE_ENDIAN);\n\n        } else {\n\n            break;\n\n        }\n\n    }\n\n    if (serial_hds[i])\n\n        s->fir = pxa2xx_fir_init(address_space, 0x40800000,\n\n                        qdev_get_gpio_in(s->pic, PXA2XX_PIC_ICP),\n\n                        qdev_get_gpio_in(s->dma, PXA2XX_RX_RQ_ICP),\n\n                        qdev_get_gpio_in(s->dma, PXA2XX_TX_RQ_ICP),\n\n                        serial_hds[i]);\n\n\n\n    s->lcd = pxa2xx_lcdc_init(address_space, 0x44000000,\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_LCD));\n\n\n\n    s->cm_base = 0x41300000;\n\n    s->cm_regs[CCCR >> 2] = 0x02000210;\t/* 416.0 MHz */\n\n    s->clkcfg = 0x00000009;\t\t/* Turbo mode active */\n\n    memory_region_init_io(&s->cm_iomem, NULL, &pxa2xx_cm_ops, s, \"pxa2xx-cm\", 0x1000);\n\n    memory_region_add_subregion(address_space, s->cm_base, &s->cm_iomem);\n\n    vmstate_register(NULL, 0, &vmstate_pxa2xx_cm, s);\n\n\n\n    pxa2xx_setup_cp14(s);\n\n\n\n    s->mm_base = 0x48000000;\n\n    s->mm_regs[MDMRS >> 2] = 0x00020002;\n\n    s->mm_regs[MDREFR >> 2] = 0x03ca4000;\n\n    s->mm_regs[MECR >> 2] = 0x00000001;\t/* Two PC Card sockets */\n\n    memory_region_init_io(&s->mm_iomem, NULL, &pxa2xx_mm_ops, s, \"pxa2xx-mm\", 0x1000);\n\n    memory_region_add_subregion(address_space, s->mm_base, &s->mm_iomem);\n\n    vmstate_register(NULL, 0, &vmstate_pxa2xx_mm, s);\n\n\n\n    s->pm_base = 0x40f00000;\n\n    memory_region_init_io(&s->pm_iomem, NULL, &pxa2xx_pm_ops, s, \"pxa2xx-pm\", 0x100);\n\n    memory_region_add_subregion(address_space, s->pm_base, &s->pm_iomem);\n\n    vmstate_register(NULL, 0, &vmstate_pxa2xx_pm, s);\n\n\n\n    for (i = 0; pxa27x_ssp[i].io_base; i ++);\n\n    s->ssp = (SSIBus **)g_malloc0(sizeof(SSIBus *) * i);\n\n    for (i = 0; pxa27x_ssp[i].io_base; i ++) {\n\n        DeviceState *dev;\n\n        dev = sysbus_create_simple(TYPE_PXA2XX_SSP, pxa27x_ssp[i].io_base,\n\n                        qdev_get_gpio_in(s->pic, pxa27x_ssp[i].irqn));\n\n        s->ssp[i] = (SSIBus *)qdev_get_child_bus(dev, \"ssi\");\n\n    }\n\n\n\n    if (usb_enabled()) {\n\n        sysbus_create_simple(\"sysbus-ohci\", 0x4c000000,\n\n                        qdev_get_gpio_in(s->pic, PXA2XX_PIC_USBH1));\n\n    }\n\n\n\n    s->pcmcia[0] = pxa2xx_pcmcia_init(address_space, 0x20000000);\n\n    s->pcmcia[1] = pxa2xx_pcmcia_init(address_space, 0x30000000);\n\n\n\n    sysbus_create_simple(TYPE_PXA2XX_RTC, 0x40900000,\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_RTCALARM));\n\n\n\n    s->i2c[0] = pxa2xx_i2c_init(0x40301600,\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_I2C), 0xffff);\n\n    s->i2c[1] = pxa2xx_i2c_init(0x40f00100,\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_PWRI2C), 0xff);\n\n\n\n    s->i2s = pxa2xx_i2s_init(address_space, 0x40400000,\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_I2S),\n\n                    qdev_get_gpio_in(s->dma, PXA2XX_RX_RQ_I2S),\n\n                    qdev_get_gpio_in(s->dma, PXA2XX_TX_RQ_I2S));\n\n\n\n    s->kp = pxa27x_keypad_init(address_space, 0x41500000,\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_KEYPAD));\n\n\n\n    /* GPIO1 resets the processor */\n\n    /* The handler can be overridden by board-specific code */\n\n    qdev_connect_gpio_out(s->gpio, 1, s->reset);\n\n    return s;\n\n}\n", "idx": 22572}
{"project": "qemu", "commit_id": "51cc2e783af5586b2e742ce9e5b2762dc50ad325", "target": 1, "func": "static int cpu_mips_register (CPUMIPSState *env, const mips_def_t *def)\n\n{\n\n    env->CP0_PRid = def->CP0_PRid;\n\n    env->CP0_Config0 = def->CP0_Config0;\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    env->CP0_Config0 |= (1 << CP0C0_BE);\n\n#endif\n\n    env->CP0_Config1 = def->CP0_Config1;\n\n    env->CP0_Config2 = def->CP0_Config2;\n\n    env->CP0_Config3 = def->CP0_Config3;\n\n    env->CP0_Config6 = def->CP0_Config6;\n\n    env->CP0_Config7 = def->CP0_Config7;\n\n    env->SYNCI_Step = def->SYNCI_Step;\n\n    env->CCRes = def->CCRes;\n\n    env->CP0_Status_rw_bitmask = def->CP0_Status_rw_bitmask;\n\n    env->CP0_TCStatus_rw_bitmask = def->CP0_TCStatus_rw_bitmask;\n\n    env->CP0_SRSCtl = def->CP0_SRSCtl;\n\n    env->current_tc = 0;\n\n    env->SEGBITS = def->SEGBITS;\n\n    env->SEGMask = (target_ulong)((1ULL << def->SEGBITS) - 1);\n\n#if defined(TARGET_MIPS64)\n\n    if (def->insn_flags & ISA_MIPS3) {\n\n        env->hflags |= MIPS_HFLAG_64;\n\n        env->SEGMask |= 3ULL << 62;\n\n    }\n\n#endif\n\n    env->PABITS = def->PABITS;\n\n    env->PAMask = (target_ulong)((1ULL << def->PABITS) - 1);\n\n    env->CP0_SRSConf0_rw_bitmask = def->CP0_SRSConf0_rw_bitmask;\n\n    env->CP0_SRSConf0 = def->CP0_SRSConf0;\n\n    env->CP0_SRSConf1_rw_bitmask = def->CP0_SRSConf1_rw_bitmask;\n\n    env->CP0_SRSConf1 = def->CP0_SRSConf1;\n\n    env->CP0_SRSConf2_rw_bitmask = def->CP0_SRSConf2_rw_bitmask;\n\n    env->CP0_SRSConf2 = def->CP0_SRSConf2;\n\n    env->CP0_SRSConf3_rw_bitmask = def->CP0_SRSConf3_rw_bitmask;\n\n    env->CP0_SRSConf3 = def->CP0_SRSConf3;\n\n    env->CP0_SRSConf4_rw_bitmask = def->CP0_SRSConf4_rw_bitmask;\n\n    env->CP0_SRSConf4 = def->CP0_SRSConf4;\n\n    env->insn_flags = def->insn_flags;\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    mmu_init(env, def);\n\n#endif\n\n    fpu_init(env, def);\n\n    mvp_init(env, def);\n\n    return 0;\n\n}\n", "idx": 22574}
{"project": "qemu", "commit_id": "21ef45d71221b4577330fe3aacfb06afad91ad46", "target": 1, "func": "static void gd_update(DisplayChangeListener *dcl,\n\n                      DisplayState *ds, int x, int y, int w, int h)\n\n{\n\n    GtkDisplayState *s = ds->opaque;\n\n    int x1, x2, y1, y2;\n\n    int mx, my;\n\n    int fbw, fbh;\n\n    int ww, wh;\n\n\n\n    DPRINTF(\"update(x=%d, y=%d, w=%d, h=%d)\\n\", x, y, w, h);\n\n\n\n    x1 = floor(x * s->scale_x);\n\n    y1 = floor(y * s->scale_y);\n\n\n\n    x2 = ceil(x * s->scale_x + w * s->scale_x);\n\n    y2 = ceil(y * s->scale_y + h * s->scale_y);\n\n\n\n    fbw = ds_get_width(s->ds) * s->scale_x;\n\n    fbh = ds_get_height(s->ds) * s->scale_y;\n\n\n\n    gdk_drawable_get_size(gtk_widget_get_window(s->drawing_area), &ww, &wh);\n\n\n\n    mx = my = 0;\n\n    if (ww > fbw) {\n\n        mx = (ww - fbw) / 2;\n\n    }\n\n    if (wh > fbh) {\n\n        my = (wh - fbh) / 2;\n\n    }\n\n\n\n    gtk_widget_queue_draw_area(s->drawing_area, mx + x1, my + y1, (x2 - x1), (y2 - y1));\n\n}\n", "idx": 22575}
{"project": "qemu", "commit_id": "54e6814360ab2110ed3ed07b2b9a3f9907e1202a", "target": 1, "func": "int qcow2_alloc_cluster_offset(BlockDriverState *bs, uint64_t offset,\n\n    int n_start, int n_end, int *num, QCowL2Meta *m)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int l2_index, ret, sectors;\n\n    uint64_t *l2_table;\n\n    unsigned int nb_clusters, keep_clusters;\n\n    uint64_t cluster_offset;\n\n\n\n    trace_qcow2_alloc_clusters_offset(qemu_coroutine_self(), offset,\n\n                                      n_start, n_end);\n\n\n\n    /* Find L2 entry for the first involved cluster */\n\nagain:\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * Calculate the number of clusters to look for. We stop at L2 table\n\n     * boundaries to keep things simple.\n\n     */\n\n    nb_clusters = MIN(size_to_clusters(s, n_end << BDRV_SECTOR_BITS),\n\n                      s->l2_size - l2_index);\n\n\n\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n\n\n    /*\n\n     * Check how many clusters are already allocated and don't need COW, and how\n\n     * many need a new allocation.\n\n     */\n\n    if (qcow2_get_cluster_type(cluster_offset) == QCOW2_CLUSTER_NORMAL\n\n        && (cluster_offset & QCOW_OFLAG_COPIED))\n\n    {\n\n        /* We keep all QCOW_OFLAG_COPIED clusters */\n\n        keep_clusters =\n\n            count_contiguous_clusters(nb_clusters, s->cluster_size,\n\n                                      &l2_table[l2_index], 0,\n\n                                      QCOW_OFLAG_COPIED | QCOW_OFLAG_ZERO);\n\n        assert(keep_clusters <= nb_clusters);\n\n        nb_clusters -= keep_clusters;\n\n    } else {\n\n        /* For the moment, overwrite compressed clusters one by one */\n\n        if (cluster_offset & QCOW_OFLAG_COMPRESSED) {\n\n            nb_clusters = 1;\n\n        } else {\n\n            nb_clusters = count_cow_clusters(s, nb_clusters, l2_table, l2_index);\n\n        }\n\n\n\n        keep_clusters = 0;\n\n        cluster_offset = 0;\n\n    }\n\n\n\n    cluster_offset &= L2E_OFFSET_MASK;\n\n\n\n    /*\n\n     * The L2 table isn't used any more after this. As long as the cache works\n\n     * synchronously, it's important to release it before calling\n\n     * do_alloc_cluster_offset, which may yield if we need to wait for another\n\n     * request to complete. If we still had the reference, we could use up the\n\n     * whole cache with sleeping requests.\n\n     */\n\n    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* If there is something left to allocate, do that now */\n\n    *m = (QCowL2Meta) {\n\n        .cluster_offset     = cluster_offset,\n\n        .nb_clusters        = 0,\n\n    };\n\n    qemu_co_queue_init(&m->dependent_requests);\n\n\n\n    if (nb_clusters > 0) {\n\n        uint64_t alloc_offset;\n\n        uint64_t alloc_cluster_offset;\n\n        uint64_t keep_bytes = keep_clusters * s->cluster_size;\n\n\n\n        /* Calculate start and size of allocation */\n\n        alloc_offset = offset + keep_bytes;\n\n\n\n        if (keep_clusters == 0) {\n\n            alloc_cluster_offset = 0;\n\n        } else {\n\n            alloc_cluster_offset = cluster_offset + keep_bytes;\n\n        }\n\n\n\n        /* Allocate, if necessary at a given offset in the image file */\n\n        ret = do_alloc_cluster_offset(bs, alloc_offset, &alloc_cluster_offset,\n\n                                      &nb_clusters);\n\n        if (ret == -EAGAIN) {\n\n            goto again;\n\n        } else if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        /* save info needed for meta data update */\n\n        if (nb_clusters > 0) {\n\n            int requested_sectors = n_end - keep_clusters * s->cluster_sectors;\n\n            int avail_sectors = (keep_clusters + nb_clusters)\n\n                                << (s->cluster_bits - BDRV_SECTOR_BITS);\n\n\n\n            *m = (QCowL2Meta) {\n\n                .cluster_offset = keep_clusters == 0 ?\n\n                                  alloc_cluster_offset : cluster_offset,\n\n                .alloc_offset   = alloc_cluster_offset,\n\n                .offset         = alloc_offset,\n\n                .n_start        = keep_clusters == 0 ? n_start : 0,\n\n                .nb_clusters    = nb_clusters,\n\n                .nb_available   = MIN(requested_sectors, avail_sectors),\n\n            };\n\n            qemu_co_queue_init(&m->dependent_requests);\n\n            QLIST_INSERT_HEAD(&s->cluster_allocs, m, next_in_flight);\n\n        }\n\n    }\n\n\n\n    /* Some cleanup work */\n\n    sectors = (keep_clusters + nb_clusters) << (s->cluster_bits - 9);\n\n    if (sectors > n_end) {\n\n        sectors = n_end;\n\n    }\n\n\n\n    assert(sectors > n_start);\n\n    *num = sectors - n_start;\n\n\n\n    return 0;\n\n\n\nfail:\n\n    if (m->nb_clusters > 0) {\n\n        QLIST_REMOVE(m, next_in_flight);\n\n    }\n\n    return ret;\n\n}\n", "idx": 22580}
{"project": "qemu", "commit_id": "d07bde88a52bf293c3f8846cfd162e0a57e1557c", "target": 1, "func": "static void tb_gen_code(CPUState *env,\n\n                        target_ulong pc, target_ulong cs_base, int flags,\n\n                        int cflags)\n\n{\n\n    TranslationBlock *tb;\n\n    uint8_t *tc_ptr;\n\n    target_ulong phys_pc, phys_page2, virt_page2;\n\n    int code_gen_size;\n\n\n\n    phys_pc = get_phys_addr_code(env, pc);\n\n    tb = tb_alloc(pc);\n\n    if (!tb) {\n\n        /* flush must be done */\n\n        tb_flush(env);\n\n        /* cannot fail at this point */\n\n        tb = tb_alloc(pc);\n\n    }\n\n    tc_ptr = code_gen_ptr;\n\n    tb->tc_ptr = tc_ptr;\n\n    tb->cs_base = cs_base;\n\n    tb->flags = flags;\n\n    tb->cflags = cflags;\n\n    cpu_gen_code(env, tb, CODE_GEN_MAX_SIZE, &code_gen_size);\n\n    code_gen_ptr = (void *)(((unsigned long)code_gen_ptr + code_gen_size + CODE_GEN_ALIGN - 1) & ~(CODE_GEN_ALIGN - 1));\n\n\n\n    /* check next page if needed */\n\n    virt_page2 = (pc + tb->size - 1) & TARGET_PAGE_MASK;\n\n    phys_page2 = -1;\n\n    if ((pc & TARGET_PAGE_MASK) != virt_page2) {\n\n        phys_page2 = get_phys_addr_code(env, virt_page2);\n\n    }\n\n    tb_link_phys(tb, phys_pc, phys_page2);\n\n}\n", "idx": 22581}
{"project": "qemu", "commit_id": "c0532a76b407af4b276dc5a62d8178db59857ea6", "target": 1, "func": "void cpu_inject_x86_mce(CPUState *cenv, int bank, uint64_t status,\n\n                        uint64_t mcg_status, uint64_t addr, uint64_t misc)\n\n{\n\n    uint64_t mcg_cap = cenv->mcg_cap;\n\n    unsigned bank_num = mcg_cap & 0xff;\n\n    uint64_t *banks = cenv->mce_banks;\n\n\n\n    if (bank >= bank_num || !(status & MCI_STATUS_VAL))\n\n        return;\n\n\n\n    if (kvm_enabled()) {\n\n        kvm_inject_x86_mce(cenv, bank, status, mcg_status, addr, misc);\n\n        return;\n\n    }\n\n\n\n    /*\n\n     * if MSR_MCG_CTL is not all 1s, the uncorrected error\n\n     * reporting is disabled\n\n     */\n\n    if ((status & MCI_STATUS_UC) && (mcg_cap & MCG_CTL_P) &&\n\n        cenv->mcg_ctl != ~(uint64_t)0)\n\n        return;\n\n    banks += 4 * bank;\n\n    /*\n\n     * if MSR_MCi_CTL is not all 1s, the uncorrected error\n\n     * reporting is disabled for the bank\n\n     */\n\n    if ((status & MCI_STATUS_UC) && banks[0] != ~(uint64_t)0)\n\n        return;\n\n    if (status & MCI_STATUS_UC) {\n\n        if ((cenv->mcg_status & MCG_STATUS_MCIP) ||\n\n            !(cenv->cr[4] & CR4_MCE_MASK)) {\n\n            fprintf(stderr, \"injects mce exception while previous \"\n\n                    \"one is in progress!\\n\");\n\n            qemu_log_mask(CPU_LOG_RESET, \"Triple fault\\n\");\n\n            qemu_system_reset_request();\n\n            return;\n\n        }\n\n        if (banks[1] & MCI_STATUS_VAL)\n\n            status |= MCI_STATUS_OVER;\n\n        banks[2] = addr;\n\n        banks[3] = misc;\n\n        cenv->mcg_status = mcg_status;\n\n        banks[1] = status;\n\n        cpu_interrupt(cenv, CPU_INTERRUPT_MCE);\n\n    } else if (!(banks[1] & MCI_STATUS_VAL)\n\n               || !(banks[1] & MCI_STATUS_UC)) {\n\n        if (banks[1] & MCI_STATUS_VAL)\n\n            status |= MCI_STATUS_OVER;\n\n        banks[2] = addr;\n\n        banks[3] = misc;\n\n        banks[1] = status;\n\n    } else\n\n        banks[1] |= MCI_STATUS_OVER;\n\n}\n", "idx": 22582}
{"project": "qemu", "commit_id": "baf35cb90204d75404892aa4e52628ae7a00669b", "target": 1, "func": "void qemu_aio_poll(void)\n\n{\n\n}\n", "idx": 22583}
{"project": "qemu", "commit_id": "8059feee004111534c4c0652e2f0715e9b4e0754", "target": 1, "func": "void virtqueue_map_sg(struct iovec *sg, hwaddr *addr,\n\n    size_t num_sg, int is_write)\n\n{\n\n    unsigned int i;\n\n    hwaddr len;\n\n\n\n    if (num_sg > VIRTQUEUE_MAX_SIZE) {\n\n        error_report(\"virtio: map attempt out of bounds: %zd > %d\",\n\n                     num_sg, VIRTQUEUE_MAX_SIZE);\n\n        exit(1);\n\n    }\n\n\n\n    for (i = 0; i < num_sg; i++) {\n\n        len = sg[i].iov_len;\n\n        sg[i].iov_base = cpu_physical_memory_map(addr[i], &len, is_write);\n\n        if (sg[i].iov_base == NULL || len != sg[i].iov_len) {\n\n            error_report(\"virtio: error trying to map MMIO memory\");\n\n            exit(1);\n\n        }\n\n    }\n\n}\n", "idx": 22584}
{"project": "qemu", "commit_id": "ac0c14d71b68ac18f03a876028e332534e1e6a3e", "target": 1, "func": "static int virtio_blk_init_pci(PCIDevice *pci_dev)\n\n{\n\n    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);\n\n    VirtIODevice *vdev;\n\n\n\n    if (proxy->class_code != PCI_CLASS_STORAGE_SCSI &&\n\n        proxy->class_code != PCI_CLASS_STORAGE_OTHER)\n\n        proxy->class_code = PCI_CLASS_STORAGE_SCSI;\n\n\n\n    if (!proxy->block.bs) {\n\n        error_report(\"virtio-blk-pci: drive property not set\");\n\n\n\n    vdev = virtio_blk_init(&pci_dev->qdev, &proxy->block);\n\n\n\n\n    vdev->nvectors = proxy->nvectors;\n\n    virtio_init_pci(proxy, vdev,\n\n                    PCI_VENDOR_ID_REDHAT_QUMRANET,\n\n                    PCI_DEVICE_ID_VIRTIO_BLOCK,\n\n                    proxy->class_code, 0x00);\n\n    /* make the actual value visible */\n\n    proxy->nvectors = vdev->nvectors;\n\n    return 0;\n", "idx": 22587}
{"project": "qemu", "commit_id": "6a5b69a959483c7404576a7dc54221ced41e6515", "target": 1, "func": "static target_ulong helper_sdiv_common(CPUSPARCState *env, target_ulong a,\n\n                                       target_ulong b, int cc)\n\n{\n\n    SPARCCPU *cpu = sparc_env_get_cpu(env);\n\n    int overflow = 0;\n\n    int64_t x0;\n\n    int32_t x1;\n\n\n\n    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);\n\n    x1 = (b & 0xffffffff);\n\n\n\n    if (x1 == 0) {\n\n        cpu_restore_state(CPU(cpu), GETPC());\n\n        helper_raise_exception(env, TT_DIV_ZERO);\n\n    }\n\n\n\n    x0 = x0 / x1;\n\n    if ((int32_t) x0 != x0) {\n\n        x0 = x0 < 0 ? 0x80000000 : 0x7fffffff;\n\n        overflow = 1;\n\n    }\n\n\n\n    if (cc) {\n\n        env->cc_dst = x0;\n\n        env->cc_src2 = overflow;\n\n        env->cc_op = CC_OP_DIV;\n\n    }\n\n    return x0;\n\n}\n", "idx": 22588}
{"project": "qemu", "commit_id": "e8bccad5ac6095b5af7946cd72d9aacb57f7c0a3", "target": 1, "func": "static void win32_aio_process_completion(QEMUWin32AIOState *s,\n\n    QEMUWin32AIOCB *waiocb, DWORD count)\n\n{\n\n    int ret;\n\n    s->count--;\n\n\n\n    if (waiocb->ov.Internal != 0) {\n\n        ret = -EIO;\n\n    } else {\n\n        ret = 0;\n\n        if (count < waiocb->nbytes) {\n\n            /* Short reads mean EOF, pad with zeros. */\n\n            if (waiocb->is_read) {\n\n                qemu_iovec_memset(waiocb->qiov, count, 0,\n\n                    waiocb->qiov->size - count);\n\n            } else {\n\n                ret = -EINVAL;\n\n            }\n\n       }\n\n    }\n\n\n\n    if (!waiocb->is_linear) {\n\n        if (ret == 0 && waiocb->is_read) {\n\n            QEMUIOVector *qiov = waiocb->qiov;\n\n            char *p = waiocb->buf;\n\n            int i;\n\n\n\n            for (i = 0; i < qiov->niov; ++i) {\n\n                memcpy(qiov->iov[i].iov_base, p, qiov->iov[i].iov_len);\n\n                p += qiov->iov[i].iov_len;\n\n            }\n\n            qemu_vfree(waiocb->buf);\n\n        }\n\n    }\n\n\n\n\n\n    waiocb->common.cb(waiocb->common.opaque, ret);\n\n    qemu_aio_release(waiocb);\n\n}\n", "idx": 22592}
{"project": "qemu", "commit_id": "107e4b352cc309f9bd7588ef1a44549200620078", "target": 1, "func": "static int of_dpa_cmd_group_add(OfDpa *of_dpa, uint32_t group_id,\n\n                                RockerTlv **group_tlvs)\n\n{\n\n    OfDpaGroup *group = of_dpa_group_find(of_dpa, group_id);\n\n    int err;\n\n\n\n    if (group) {\n\n        return -ROCKER_EEXIST;\n\n    }\n\n\n\n    group = of_dpa_group_alloc(group_id);\n\n    if (!group) {\n\n        return -ROCKER_ENOMEM;\n\n    }\n\n\n\n    err = of_dpa_cmd_group_do(of_dpa, group_id, group, group_tlvs);\n\n    if (err) {\n\n        goto err_cmd_add;\n\n    }\n\n\n\n    err = of_dpa_group_add(of_dpa, group);\n\n    if (err) {\n\n        goto err_cmd_add;\n\n    }\n\n\n\n    return ROCKER_OK;\n\n\n\nerr_cmd_add:\n\n    g_free(group);\n\n    return err;\n\n}\n", "idx": 22598}
{"project": "qemu", "commit_id": "f1d3b99154138741161fc52f5a8c373bf71613c6", "target": 1, "func": "static void pci_msix(void)\n\n{\n\n    QVirtioPCIDevice *dev;\n\n    QPCIBus *bus;\n\n    QVirtQueuePCI *vqpci;\n\n    QGuestAllocator *alloc;\n\n    QVirtioBlkReq req;\n\n    int n_size = TEST_IMAGE_SIZE / 2;\n\n    void *addr;\n\n    uint64_t req_addr;\n\n    uint64_t capacity;\n\n    uint32_t features;\n\n    uint32_t free_head;\n\n    uint8_t status;\n\n    char *data;\n\n\n\n    bus = pci_test_start();\n\n    alloc = pc_alloc_init();\n\n\n\n    dev = virtio_blk_pci_init(bus, PCI_SLOT);\n\n    qpci_msix_enable(dev->pdev);\n\n\n\n    qvirtio_pci_set_msix_configuration_vector(dev, alloc, 0);\n\n\n\n    /* MSI-X is enabled */\n\n    addr = dev->addr + VIRTIO_PCI_CONFIG_OFF(true);\n\n\n\n    capacity = qvirtio_config_readq(&qvirtio_pci, &dev->vdev,\n\n                                                    (uint64_t)(uintptr_t)addr);\n\n    g_assert_cmpint(capacity, ==, TEST_IMAGE_SIZE / 512);\n\n\n\n    features = qvirtio_get_features(&qvirtio_pci, &dev->vdev);\n\n    features = features & ~(QVIRTIO_F_BAD_FEATURE |\n\n                            (1u << VIRTIO_RING_F_INDIRECT_DESC) |\n\n                            (1u << VIRTIO_RING_F_EVENT_IDX) |\n\n                            (1u << VIRTIO_BLK_F_SCSI));\n\n    qvirtio_set_features(&qvirtio_pci, &dev->vdev, features);\n\n\n\n    vqpci = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,\n\n                                                                    alloc, 0);\n\n    qvirtqueue_pci_msix_setup(dev, vqpci, alloc, 1);\n\n\n\n    qvirtio_set_driver_ok(&qvirtio_pci, &dev->vdev);\n\n\n\n    qmp(\"{ 'execute': 'block_resize', 'arguments': { 'device': 'drive0', \"\n\n                                                    \" 'size': %d } }\", n_size);\n\n\n\n    qvirtio_wait_config_isr(&qvirtio_pci, &dev->vdev, QVIRTIO_BLK_TIMEOUT_US);\n\n\n\n    capacity = qvirtio_config_readq(&qvirtio_pci, &dev->vdev,\n\n                                                    (uint64_t)(uintptr_t)addr);\n\n    g_assert_cmpint(capacity, ==, n_size / 512);\n\n\n\n    /* Write request */\n\n    req.type = VIRTIO_BLK_T_OUT;\n\n    req.ioprio = 1;\n\n    req.sector = 0;\n\n    req.data = g_malloc0(512);\n\n    strcpy(req.data, \"TEST\");\n\n\n\n    req_addr = virtio_blk_request(alloc, &req, 512);\n\n\n\n    g_free(req.data);\n\n\n\n    free_head = qvirtqueue_add(&vqpci->vq, req_addr, 16, false, true);\n\n    qvirtqueue_add(&vqpci->vq, req_addr + 16, 512, false, true);\n\n    qvirtqueue_add(&vqpci->vq, req_addr + 528, 1, true, false);\n\n    qvirtqueue_kick(&qvirtio_pci, &dev->vdev, &vqpci->vq, free_head);\n\n\n\n    qvirtio_wait_queue_isr(&qvirtio_pci, &dev->vdev, &vqpci->vq,\n\n                           QVIRTIO_BLK_TIMEOUT_US);\n\n\n\n    status = readb(req_addr + 528);\n\n    g_assert_cmpint(status, ==, 0);\n\n\n\n    guest_free(alloc, req_addr);\n\n\n\n    /* Read request */\n\n    req.type = VIRTIO_BLK_T_IN;\n\n    req.ioprio = 1;\n\n    req.sector = 0;\n\n    req.data = g_malloc0(512);\n\n\n\n    req_addr = virtio_blk_request(alloc, &req, 512);\n\n\n\n    g_free(req.data);\n\n\n\n    free_head = qvirtqueue_add(&vqpci->vq, req_addr, 16, false, true);\n\n    qvirtqueue_add(&vqpci->vq, req_addr + 16, 512, true, true);\n\n    qvirtqueue_add(&vqpci->vq, req_addr + 528, 1, true, false);\n\n\n\n    qvirtqueue_kick(&qvirtio_pci, &dev->vdev, &vqpci->vq, free_head);\n\n\n\n\n\n    qvirtio_wait_queue_isr(&qvirtio_pci, &dev->vdev, &vqpci->vq,\n\n                           QVIRTIO_BLK_TIMEOUT_US);\n\n\n\n    status = readb(req_addr + 528);\n\n    g_assert_cmpint(status, ==, 0);\n\n\n\n    data = g_malloc0(512);\n\n    memread(req_addr + 16, data, 512);\n\n    g_assert_cmpstr(data, ==, \"TEST\");\n\n    g_free(data);\n\n\n\n    guest_free(alloc, req_addr);\n\n\n\n    /* End test */\n\n    guest_free(alloc, vqpci->vq.desc);\n\n    pc_alloc_uninit(alloc);\n\n    qpci_msix_disable(dev->pdev);\n\n    qvirtio_pci_device_disable(dev);\n\n    g_free(dev);\n\n    qpci_free_pc(bus);\n\n    test_end();\n\n}\n", "idx": 22604}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void test_co_queue(void)\n\n{\n\n    Coroutine *c1;\n\n    Coroutine *c2;\n\n\n\n    c1 = qemu_coroutine_create(c1_fn);\n\n    c2 = qemu_coroutine_create(c2_fn);\n\n\n\n    qemu_coroutine_enter(c1, c2);\n\n    memset(c1, 0xff, sizeof(Coroutine));\n\n    qemu_coroutine_enter(c2, NULL);\n\n}\n", "idx": 22605}
{"project": "qemu", "commit_id": "f575f145f4fa97fdbb9bbb4df62dfeada3f15dc4", "target": 1, "func": "static bool is_zero_cluster(BlockDriverState *bs, int64_t start)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int nr;\n\n    BlockDriverState *file;\n\n    int64_t res = bdrv_get_block_status_above(bs, NULL, start,\n\n                                              s->cluster_sectors, &nr, &file);\n\n    return res >= 0 && ((res & BDRV_BLOCK_ZERO) || !(res & BDRV_BLOCK_DATA));\n\n}\n", "idx": 22609}
{"project": "qemu", "commit_id": "cdeaf1f15909e2e8af38f45aea7cfa467a729c52", "target": 1, "func": "static int get_cluster_offset(BlockDriverState *bs,\n\n                                    VmdkExtent *extent,\n\n                                    VmdkMetaData *m_data,\n\n                                    uint64_t offset,\n\n                                    int allocate,\n\n                                    uint64_t *cluster_offset)\n\n{\n\n    unsigned int l1_index, l2_offset, l2_index;\n\n    int min_index, i, j;\n\n    uint32_t min_count, *l2_table;\n\n    bool zeroed = false;\n\n\n\n    if (m_data) {\n\n        m_data->valid = 0;\n\n    }\n\n    if (extent->flat) {\n\n        *cluster_offset = extent->flat_start_offset;\n\n        return VMDK_OK;\n\n    }\n\n\n\n    offset -= (extent->end_sector - extent->sectors) * SECTOR_SIZE;\n\n    l1_index = (offset >> 9) / extent->l1_entry_sectors;\n\n    if (l1_index >= extent->l1_size) {\n\n        return VMDK_ERROR;\n\n    }\n\n    l2_offset = extent->l1_table[l1_index];\n\n    if (!l2_offset) {\n\n        return VMDK_UNALLOC;\n\n    }\n\n    for (i = 0; i < L2_CACHE_SIZE; i++) {\n\n        if (l2_offset == extent->l2_cache_offsets[i]) {\n\n            /* increment the hit count */\n\n            if (++extent->l2_cache_counts[i] == 0xffffffff) {\n\n                for (j = 0; j < L2_CACHE_SIZE; j++) {\n\n                    extent->l2_cache_counts[j] >>= 1;\n\n                }\n\n            }\n\n            l2_table = extent->l2_cache + (i * extent->l2_size);\n\n            goto found;\n\n        }\n\n    }\n\n    /* not found: load a new entry in the least used one */\n\n    min_index = 0;\n\n    min_count = 0xffffffff;\n\n    for (i = 0; i < L2_CACHE_SIZE; i++) {\n\n        if (extent->l2_cache_counts[i] < min_count) {\n\n            min_count = extent->l2_cache_counts[i];\n\n            min_index = i;\n\n        }\n\n    }\n\n    l2_table = extent->l2_cache + (min_index * extent->l2_size);\n\n    if (bdrv_pread(\n\n                extent->file,\n\n                (int64_t)l2_offset * 512,\n\n                l2_table,\n\n                extent->l2_size * sizeof(uint32_t)\n\n            ) != extent->l2_size * sizeof(uint32_t)) {\n\n        return VMDK_ERROR;\n\n    }\n\n\n\n    extent->l2_cache_offsets[min_index] = l2_offset;\n\n    extent->l2_cache_counts[min_index] = 1;\n\n found:\n\n    l2_index = ((offset >> 9) / extent->cluster_sectors) % extent->l2_size;\n\n    *cluster_offset = le32_to_cpu(l2_table[l2_index]);\n\n\n\n    if (extent->has_zero_grain && *cluster_offset == VMDK_GTE_ZEROED) {\n\n        zeroed = true;\n\n    }\n\n\n\n    if (!*cluster_offset || zeroed) {\n\n        if (!allocate) {\n\n            return zeroed ? VMDK_ZEROED : VMDK_UNALLOC;\n\n        }\n\n\n\n        /* Avoid the L2 tables update for the images that have snapshots. */\n\n        *cluster_offset = bdrv_getlength(extent->file);\n\n        if (!extent->compressed) {\n\n            bdrv_truncate(\n\n                extent->file,\n\n                *cluster_offset + (extent->cluster_sectors << 9)\n\n            );\n\n        }\n\n\n\n        *cluster_offset >>= 9;\n\n        l2_table[l2_index] = cpu_to_le32(*cluster_offset);\n\n\n\n        /* First of all we write grain itself, to avoid race condition\n\n         * that may to corrupt the image.\n\n         * This problem may occur because of insufficient space on host disk\n\n         * or inappropriate VM shutdown.\n\n         */\n\n        if (get_whole_cluster(\n\n                bs, extent, *cluster_offset, offset, allocate) == -1) {\n\n            return VMDK_ERROR;\n\n        }\n\n\n\n        if (m_data) {\n\n            m_data->offset = *cluster_offset;\n\n            m_data->l1_index = l1_index;\n\n            m_data->l2_index = l2_index;\n\n            m_data->l2_offset = l2_offset;\n\n            m_data->valid = 1;\n\n        }\n\n    }\n\n    *cluster_offset <<= 9;\n\n    return VMDK_OK;\n\n}\n", "idx": 22610}
{"project": "qemu", "commit_id": "357d1e3bc7d2d80e5271bc4f3ac8537e30dc8046", "target": 1, "func": "QPCIBus *qpci_init_spapr(QGuestAllocator *alloc)\n\n{\n\n    QPCIBusSPAPR *ret;\n\n\n\n    ret = g_malloc(sizeof(*ret));\n\n\n\n    ret->alloc = alloc;\n\n\n\n    ret->bus.io_readb = qpci_spapr_io_readb;\n\n    ret->bus.io_readw = qpci_spapr_io_readw;\n\n    ret->bus.io_readl = qpci_spapr_io_readl;\n\n\n\n    ret->bus.io_writeb = qpci_spapr_io_writeb;\n\n    ret->bus.io_writew = qpci_spapr_io_writew;\n\n    ret->bus.io_writel = qpci_spapr_io_writel;\n\n\n\n    ret->bus.config_readb = qpci_spapr_config_readb;\n\n    ret->bus.config_readw = qpci_spapr_config_readw;\n\n    ret->bus.config_readl = qpci_spapr_config_readl;\n\n\n\n    ret->bus.config_writeb = qpci_spapr_config_writeb;\n\n    ret->bus.config_writew = qpci_spapr_config_writew;\n\n    ret->bus.config_writel = qpci_spapr_config_writel;\n\n\n\n    ret->bus.iomap = qpci_spapr_iomap;\n\n    ret->bus.iounmap = qpci_spapr_iounmap;\n\n\n\n    /* FIXME: We assume the default location of the PHB for now.\n\n     * Ideally we'd parse the device tree deposited in the guest to\n\n     * get the window locations */\n\n    ret->buid = 0x800000020000000ULL;\n\n\n\n    ret->pio_cpu_base = SPAPR_PCI_WINDOW_BASE + SPAPR_PCI_IO_WIN_OFF;\n\n    ret->pio.pci_base = 0;\n\n    ret->pio.size = SPAPR_PCI_IO_WIN_SIZE;\n\n\n\n    /* 32-bit portion of the MMIO window is at PCI address 2..4 GiB */\n\n    ret->mmio32_cpu_base = SPAPR_PCI_WINDOW_BASE + SPAPR_PCI_MMIO32_WIN_OFF;\n\n    ret->mmio32.pci_base = 0x80000000; /* 2 GiB */\n\n    ret->mmio32.size = SPAPR_PCI_MMIO32_WIN_SIZE;\n\n\n\n    ret->pci_hole_start = 0xC0000000;\n\n    ret->pci_hole_size =\n\n        ret->mmio32.pci_base + ret->mmio32.size - ret->pci_hole_start;\n\n    ret->pci_hole_alloc = 0;\n\n\n\n    ret->pci_iohole_start = 0xc000;\n\n    ret->pci_iohole_size =\n\n        ret->pio.pci_base + ret->pio.size - ret->pci_iohole_start;\n\n    ret->pci_iohole_alloc = 0;\n\n\n\n    return &ret->bus;\n\n}\n", "idx": 22611}
{"project": "qemu", "commit_id": "80e1eea37a25a7696137e680285e36d0bfdc9f34", "target": 1, "func": "static void pci_config(void)\n\n{\n\n    QVirtioPCIDevice *dev;\n\n    QOSState *qs;\n\n    int n_size = TEST_IMAGE_SIZE / 2;\n\n    uint64_t capacity;\n\n\n\n    qs = pci_test_start();\n\n\n\n    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT);\n\n\n\n    capacity = qvirtio_config_readq(&dev->vdev, 0);\n\n    g_assert_cmpint(capacity, ==, TEST_IMAGE_SIZE / 512);\n\n\n\n    qvirtio_set_driver_ok(&dev->vdev);\n\n\n\n    qmp_discard_response(\"{ 'execute': 'block_resize', \"\n\n                         \" 'arguments': { 'device': 'drive0', \"\n\n                         \" 'size': %d } }\", n_size);\n\n    qvirtio_wait_config_isr(&dev->vdev, QVIRTIO_BLK_TIMEOUT_US);\n\n\n\n    capacity = qvirtio_config_readq(&dev->vdev, 0);\n\n    g_assert_cmpint(capacity, ==, n_size / 512);\n\n\n\n    qvirtio_pci_device_disable(dev);\n\n    g_free(dev);\n\n\n\n    qtest_shutdown(qs);\n\n}\n", "idx": 22613}
{"project": "qemu", "commit_id": "654598c944aa31cdbea435bd468055af9c918d16", "target": 1, "func": "static void pc_fw_add_pflash_drv(void)\n\n{\n\n    QemuOpts *opts;\n\n    QEMUMachine *machine;\n\n    char *filename;\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = BIOS_FILENAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n\n\n    opts = drive_add(IF_PFLASH, -1, filename, \"readonly=on\");\n\n\n\n    g_free(filename);\n\n\n\n    if (opts == NULL) {\n\n      return;\n\n    }\n\n\n\n    machine = find_default_machine();\n\n    if (machine == NULL) {\n\n      return;\n\n    }\n\n\n\n    drive_init(opts, machine->use_scsi);\n\n}\n", "idx": 22615}
{"project": "qemu", "commit_id": "b946a1533209f61a93e34898aebb5b43154b99c3", "target": 1, "func": "static int net_vde_init(VLANState *vlan, const char *model,\n\n                        const char *name, const char *sock,\n\n                        int port, const char *group, int mode)\n\n{\n\n    VDEState *s;\n\n    char *init_group = strlen(group) ? (char *)group : NULL;\n\n    char *init_sock = strlen(sock) ? (char *)sock : NULL;\n\n\n\n    struct vde_open_args args = {\n\n        .port = port,\n\n        .group = init_group,\n\n        .mode = mode,\n\n    };\n\n\n\n    s = qemu_mallocz(sizeof(VDEState));\n\n    s->vde = vde_open(init_sock, \"QEMU\", &args);\n\n    if (!s->vde){\n\n        free(s);\n\n        return -1;\n\n    }\n\n    s->vc = qemu_new_vlan_client(vlan, model, name, vde_from_qemu, NULL, s);\n\n    qemu_set_fd_handler(vde_datafd(s->vde), vde_to_qemu, NULL, s);\n\n    snprintf(s->vc->info_str, sizeof(s->vc->info_str), \"sock=%s,fd=%d\",\n\n             sock, vde_datafd(s->vde));\n\n    return 0;\n\n}\n", "idx": 22618}
{"project": "qemu", "commit_id": "b53dd4495ced2432a0b652ea895e651d07336f7e", "target": 1, "func": "static void usb_xhci_exit(PCIDevice *dev)\n\n{\n\n    int i;\n\n    XHCIState *xhci = XHCI(dev);\n\n\n\n    trace_usb_xhci_exit();\n\n\n\n    for (i = 0; i < xhci->numslots; i++) {\n\n        xhci_disable_slot(xhci, i + 1);\n\n    }\n\n\n\n    if (xhci->mfwrap_timer) {\n\n        timer_del(xhci->mfwrap_timer);\n\n        timer_free(xhci->mfwrap_timer);\n\n        xhci->mfwrap_timer = NULL;\n\n    }\n\n\n\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_cap);\n\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_oper);\n\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_runtime);\n\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_doorbell);\n\n\n\n    for (i = 0; i < xhci->numports; i++) {\n\n        XHCIPort *port = &xhci->ports[i];\n\n        memory_region_del_subregion(&xhci->mem, &port->mem);\n\n    }\n\n\n\n    /* destroy msix memory region */\n\n    if (dev->msix_table && dev->msix_pba\n\n        && dev->msix_entry_used) {\n\n        memory_region_del_subregion(&xhci->mem, &dev->msix_table_mmio);\n\n        memory_region_del_subregion(&xhci->mem, &dev->msix_pba_mmio);\n\n    }\n\n\n\n    usb_bus_release(&xhci->bus);\n\n}\n", "idx": 22619}
{"project": "qemu", "commit_id": "e175bce587936bf479889881488821ea8d61c89c", "target": 1, "func": "void breakpoint_handler(CPUX86State *env)\n\n{\n\n    CPUBreakpoint *bp;\n\n\n\n    if (env->watchpoint_hit) {\n\n        if (env->watchpoint_hit->flags & BP_CPU) {\n\n            env->watchpoint_hit = NULL;\n\n            if (check_hw_breakpoints(env, 0))\n\n                raise_exception(env, EXCP01_DB);\n\n            else\n\n                cpu_resume_from_signal(env, NULL);\n\n        }\n\n    } else {\n\n        QTAILQ_FOREACH(bp, &env->breakpoints, entry)\n\n            if (bp->pc == env->eip) {\n\n                if (bp->flags & BP_CPU) {\n\n                    check_hw_breakpoints(env, 1);\n\n                    raise_exception(env, EXCP01_DB);\n\n                }\n\n                break;\n\n            }\n\n    }\n\n}\n", "idx": 22622}
{"project": "qemu", "commit_id": "a32354e206895400d17c3de9a8df1de96d3df289", "target": 1, "func": "static uint32_t m5206_mbar_readl(void *opaque, target_phys_addr_t offset)\n\n{\n\n    m5206_mbar_state *s = (m5206_mbar_state *)opaque;\n\n    int width;\n\n    offset &= 0x3ff;\n\n    if (offset > 0x200) {\n\n        hw_error(\"Bad MBAR read offset 0x%x\", (int)offset);\n\n    }\n\n    width = m5206_mbar_width[offset >> 2];\n\n    if (width < 4) {\n\n        uint32_t val;\n\n        val = m5206_mbar_readw(opaque, offset) << 16;\n\n        val |= m5206_mbar_readw(opaque, offset + 2);\n\n        return val;\n\n    }\n\n    return m5206_mbar_read(s, offset, 4);\n\n}\n", "idx": 22623}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtoul_empty(void)\n\n{\n\n    const char *str = \"\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoul(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n", "idx": 22624}
{"project": "qemu", "commit_id": "4c315c27661502a0813b129e41c0bf640c34a8d6", "target": 1, "func": "static void lm32_cpu_class_init(ObjectClass *oc, void *data)\n{\n    LM32CPUClass *lcc = LM32_CPU_CLASS(oc);\n    CPUClass *cc = CPU_CLASS(oc);\n    DeviceClass *dc = DEVICE_CLASS(oc);\n    lcc->parent_realize = dc->realize;\n    dc->realize = lm32_cpu_realizefn;\n    lcc->parent_reset = cc->reset;\n    cc->reset = lm32_cpu_reset;\n    cc->class_by_name = lm32_cpu_class_by_name;\n    cc->has_work = lm32_cpu_has_work;\n    cc->do_interrupt = lm32_cpu_do_interrupt;\n    cc->cpu_exec_interrupt = lm32_cpu_exec_interrupt;\n    cc->dump_state = lm32_cpu_dump_state;\n    cc->set_pc = lm32_cpu_set_pc;\n    cc->gdb_read_register = lm32_cpu_gdb_read_register;\n    cc->gdb_write_register = lm32_cpu_gdb_write_register;\n#ifdef CONFIG_USER_ONLY\n    cc->handle_mmu_fault = lm32_cpu_handle_mmu_fault;\n#else\n    cc->get_phys_page_debug = lm32_cpu_get_phys_page_debug;\n    cc->vmsd = &vmstate_lm32_cpu;\n#endif\n    cc->gdb_num_core_regs = 32 + 7;\n    cc->gdb_stop_before_watchpoint = true;\n    cc->debug_excp_handler = lm32_debug_excp_handler;\n}", "idx": 22625}
{"project": "qemu", "commit_id": "50628d3479e4f9aa97e323506856e394fe7ad7a6", "target": 1, "func": "static void vnc_copy(VncState *vs, int src_x, int src_y, int dst_x, int dst_y, int w, int h)\n\n{\n\n    /* send bitblit op to the vnc client */\n\n    vnc_lock_output(vs);\n\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n\n    vnc_write_u8(vs, 0);\n\n    vnc_write_u16(vs, 1); /* number of rects */\n\n    vnc_framebuffer_update(vs, dst_x, dst_y, w, h, VNC_ENCODING_COPYRECT);\n\n    vnc_write_u16(vs, src_x);\n\n    vnc_write_u16(vs, src_y);\n\n    vnc_unlock_output(vs);\n\n    vnc_flush(vs);\n\n}\n", "idx": 22627}
{"project": "qemu", "commit_id": "fbaa6bb3d3b4be71b7e234e908cb3c6bd280a222", "target": 1, "func": "static coroutine_fn int qcow2_co_pwrite_zeroes(BlockDriverState *bs,\n\n    int64_t offset, int count, BdrvRequestFlags flags)\n\n{\n\n    int ret;\n\n    BDRVQcow2State *s = bs->opaque;\n\n\n\n    uint32_t head = offset % s->cluster_size;\n\n    uint32_t tail = (offset + count) % s->cluster_size;\n\n\n\n    trace_qcow2_pwrite_zeroes_start_req(qemu_coroutine_self(), offset, count);\n\n\n\n\n\n\n    if (head || tail) {\n\n        int64_t cl_start = (offset - head) >> BDRV_SECTOR_BITS;\n\n        uint64_t off;\n\n        unsigned int nr;\n\n\n\n        assert(head + count <= s->cluster_size);\n\n\n\n        /* check whether remainder of cluster already reads as zero */\n\n        if (!(is_zero_sectors(bs, cl_start,\n\n                              DIV_ROUND_UP(head, BDRV_SECTOR_SIZE)) &&\n\n              is_zero_sectors(bs, (offset + count) >> BDRV_SECTOR_BITS,\n\n                              DIV_ROUND_UP(-tail & (s->cluster_size - 1),\n\n                                           BDRV_SECTOR_SIZE)))) {\n\n            return -ENOTSUP;\n\n\n\n\n        qemu_co_mutex_lock(&s->lock);\n\n        /* We can have new write after previous check */\n\n        offset = cl_start << BDRV_SECTOR_BITS;\n\n        count = s->cluster_size;\n\n        nr = s->cluster_size;\n\n        ret = qcow2_get_cluster_offset(bs, offset, &nr, &off);\n\n        if (ret != QCOW2_CLUSTER_UNALLOCATED &&\n\n            ret != QCOW2_CLUSTER_ZERO_PLAIN &&\n\n            ret != QCOW2_CLUSTER_ZERO_ALLOC) {\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            return -ENOTSUP;\n\n\n    } else {\n\n        qemu_co_mutex_lock(&s->lock);\n\n\n\n\n    trace_qcow2_pwrite_zeroes(qemu_coroutine_self(), offset, count);\n\n\n\n    /* Whatever is left can use real zero clusters */\n\n    ret = qcow2_zero_clusters(bs, offset, count >> BDRV_SECTOR_BITS, flags);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    return ret;\n", "idx": 22639}
{"project": "qemu", "commit_id": "f03a1af581b926118d619ad1acc3304ad84d5e5b", "target": 1, "func": "static void init_excp_POWER7 (CPUPPCState *env)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;\n\n    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;\n\n    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;\n\n    env->excp_vectors[POWERPC_EXCP_DSEG]     = 0x00000380;\n\n    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;\n\n    env->excp_vectors[POWERPC_EXCP_ISEG]     = 0x00000480;\n\n    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;\n\n    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;\n\n    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;\n\n    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;\n\n    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;\n\n    env->excp_vectors[POWERPC_EXCP_HDECR]    = 0x00000980;\n\n    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;\n\n    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;\n\n    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;\n\n    env->excp_vectors[POWERPC_EXCP_VPU]      = 0x00000F20;\n\n    env->excp_vectors[POWERPC_EXCP_VSXU]     = 0x00000F40;\n\n    env->excp_vectors[POWERPC_EXCP_FU]       = 0x00000F60;\n\n    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;\n\n    env->excp_vectors[POWERPC_EXCP_MAINT]    = 0x00001600;\n\n    env->excp_vectors[POWERPC_EXCP_VPUA]     = 0x00001700;\n\n    env->excp_vectors[POWERPC_EXCP_THERM]    = 0x00001800;\n\n    /* Hardware reset vector */\n\n    env->hreset_vector = 0x0000000000000100ULL;\n\n#endif\n\n}\n", "idx": 22640}
{"project": "qemu", "commit_id": "f897bf751fbd95e4015b95d202c706548586813a", "target": 1, "func": "static void virtio_blk_complete_request(VirtIOBlockReq *req,\n\n                                        unsigned char status)\n\n{\n\n    VirtIOBlock *s = req->dev;\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n\n\n    trace_virtio_blk_req_complete(req, status);\n\n\n\n    stb_p(&req->in->status, status);\n\n    virtqueue_push(s->vq, req->elem, req->qiov.size + sizeof(*req->in));\n\n    virtio_notify(vdev, s->vq);\n\n}\n", "idx": 22641}
{"project": "qemu", "commit_id": "b3ebc10c373ed5922d4bdb5076fd0e9fd7ff8056", "target": 1, "func": "static void vfio_enable_msi(VFIODevice *vdev)\n\n{\n\n    int ret, i;\n\n\n\n    vfio_disable_interrupts(vdev);\n\n\n\n    vdev->nr_vectors = msi_nr_vectors_allocated(&vdev->pdev);\n\nretry:\n\n    vdev->msi_vectors = g_malloc0(vdev->nr_vectors * sizeof(VFIOMSIVector));\n\n\n\n    for (i = 0; i < vdev->nr_vectors; i++) {\n\n        VFIOMSIVector *vector = &vdev->msi_vectors[i];\n\n\n\n        vector->vdev = vdev;\n\n        vector->use = true;\n\n\n\n        if (event_notifier_init(&vector->interrupt, 0)) {\n\n            error_report(\"vfio: Error: event_notifier_init failed\");\n\n        }\n\n\n\n        vector->msg = msi_get_message(&vdev->pdev, i);\n\n\n\n        /*\n\n         * Attempt to enable route through KVM irqchip,\n\n         * default to userspace handling if unavailable.\n\n         */\n\n        vector->virq = kvm_irqchip_add_msi_route(kvm_state, vector->msg);\n\n        if (vector->virq < 0 ||\n\n            kvm_irqchip_add_irqfd_notifier(kvm_state, &vector->interrupt,\n\n                                           NULL, vector->virq) < 0) {\n\n            qemu_set_fd_handler(event_notifier_get_fd(&vector->interrupt),\n\n                                vfio_msi_interrupt, NULL, vector);\n\n        }\n\n    }\n\n\n\n    ret = vfio_enable_vectors(vdev, false);\n\n    if (ret) {\n\n        if (ret < 0) {\n\n            error_report(\"vfio: Error: Failed to setup MSI fds: %m\");\n\n        } else if (ret != vdev->nr_vectors) {\n\n            error_report(\"vfio: Error: Failed to enable %d \"\n\n                         \"MSI vectors, retry with %d\", vdev->nr_vectors, ret);\n\n        }\n\n\n\n        for (i = 0; i < vdev->nr_vectors; i++) {\n\n            VFIOMSIVector *vector = &vdev->msi_vectors[i];\n\n            if (vector->virq >= 0) {\n\n                kvm_irqchip_remove_irqfd_notifier(kvm_state, &vector->interrupt,\n\n                                                  vector->virq);\n\n                kvm_irqchip_release_virq(kvm_state, vector->virq);\n\n                vector->virq = -1;\n\n            } else {\n\n                qemu_set_fd_handler(event_notifier_get_fd(&vector->interrupt),\n\n                                    NULL, NULL, NULL);\n\n            }\n\n            event_notifier_cleanup(&vector->interrupt);\n\n        }\n\n\n\n        g_free(vdev->msi_vectors);\n\n\n\n        if (ret > 0 && ret != vdev->nr_vectors) {\n\n            vdev->nr_vectors = ret;\n\n            goto retry;\n\n        }\n\n        vdev->nr_vectors = 0;\n\n\n\n        return;\n\n    }\n\n\n\n    vdev->interrupt = VFIO_INT_MSI;\n\n\n\n    DPRINTF(\"%s(%04x:%02x:%02x.%x) Enabled %d MSI vectors\\n\", __func__,\n\n            vdev->host.domain, vdev->host.bus, vdev->host.slot,\n\n            vdev->host.function, vdev->nr_vectors);\n\n}\n", "idx": 22642}
{"project": "qemu", "commit_id": "fc40787abcf8452b8f50d92b7a13243a12972c7a", "target": 1, "func": "HELPER_LD_ATOMIC(ll, lw)\n\n#ifdef TARGET_MIPS64\n\nHELPER_LD_ATOMIC(lld, ld)\n\n#endif\n\n#undef HELPER_LD_ATOMIC\n\n\n\n#define HELPER_ST_ATOMIC(name, ld_insn, st_insn, almask)                      \\\n\ntarget_ulong helper_##name(CPUMIPSState *env, target_ulong arg1,              \\\n\n                           target_ulong arg2, int mem_idx)                    \\\n\n{                                                                             \\\n\n    target_long tmp;                                                          \\\n\n                                                                              \\\n\n    if (arg2 & almask) {                                                      \\\n\n        env->CP0_BadVAddr = arg2;                                             \\\n\n        helper_raise_exception(env, EXCP_AdES);                               \\\n\n    }                                                                         \\\n\n    if (do_translate_address(env, arg2, 1) == env->lladdr) {                  \\\n\n        tmp = do_##ld_insn(env, arg2, mem_idx);                               \\\n\n        if (tmp == env->llval) {                                              \\\n\n            do_##st_insn(env, arg2, arg1, mem_idx);                           \\\n\n            return 1;                                                         \\\n\n        }                                                                     \\\n\n    }                                                                         \\\n\n    return 0;                                                                 \\\n\n}\n\nHELPER_ST_ATOMIC(sc, lw, sw, 0x3)\n\n#ifdef TARGET_MIPS64\n\nHELPER_ST_ATOMIC(scd, ld, sd, 0x7)\n\n#endif\n\n#undef HELPER_ST_ATOMIC\n\n#endif\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define GET_LMASK(v) ((v) & 3)\n\n#define GET_OFFSET(addr, offset) (addr + (offset))\n\n#else\n\n#define GET_LMASK(v) (((v) & 3) ^ 3)\n\n#define GET_OFFSET(addr, offset) (addr - (offset))\n\n#endif\n\n\n\ntarget_ulong helper_lwl(CPUMIPSState *env, target_ulong arg1,\n\n                        target_ulong arg2, int mem_idx)\n\n{\n\n    target_ulong tmp;\n\n\n\n    tmp = do_lbu(env, arg2, mem_idx);\n\n    arg1 = (arg1 & 0x00FFFFFF) | (tmp << 24);\n\n\n\n    if (GET_LMASK(arg2) <= 2) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 1), mem_idx);\n\n        arg1 = (arg1 & 0xFF00FFFF) | (tmp << 16);\n\n    }\n\n\n\n    if (GET_LMASK(arg2) <= 1) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 2), mem_idx);\n\n        arg1 = (arg1 & 0xFFFF00FF) | (tmp << 8);\n\n    }\n\n\n\n    if (GET_LMASK(arg2) == 0) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 3), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFF00) | tmp;\n\n    }\n\n    return (int32_t)arg1;\n\n}\n", "idx": 22647}
{"project": "qemu", "commit_id": "978fae9f1ac47e22890a1bd9ebf5fa46fe8b6ef7", "target": 1, "func": "static long do_sigreturn_v2(CPUARMState *env)\n\n{\n\n        abi_ulong frame_addr;\n\n\tstruct sigframe_v2 *frame;\n\n\n\n\t/*\n\n\t * Since we stacked the signal on a 64-bit boundary,\n\n\t * then 'sp' should be word aligned here.  If it's\n\n\t * not, then the user is trying to mess with us.\n\n\t */\n\n\tif (env->regs[13] & 7)\n\n\t\tgoto badframe;\n\n\n\n        frame_addr = env->regs[13];\n\n\tif (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))\n\n                goto badframe;\n\n\n\n        if (do_sigframe_return_v2(env, frame_addr, &frame->uc))\n\n                goto badframe;\n\n\n\n\tunlock_user_struct(frame, frame_addr, 0);\n\n\treturn env->regs[0];\n\n\n\nbadframe:\n\n\tunlock_user_struct(frame, frame_addr, 0);\n\n        force_sig(TARGET_SIGSEGV /* , current */);\n\n\treturn 0;\n\n}\n", "idx": 22651}
{"project": "qemu", "commit_id": "fa4478d5c8b74a5f0c8b93cc00590ec007be5016", "target": 1, "func": "void stream_start(BlockDriverState *bs, BlockDriverState *base,\n\n                  const char *base_id, int64_t speed,\n\n                  BlockDriverCompletionFunc *cb,\n\n                  void *opaque, Error **errp)\n\n{\n\n    StreamBlockJob *s;\n\n    Coroutine *co;\n\n\n\n    s = block_job_create(&stream_job_type, bs, speed, cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->base = base;\n\n    if (base_id) {\n\n        pstrcpy(s->backing_file_id, sizeof(s->backing_file_id), base_id);\n\n    }\n\n\n\n    co = qemu_coroutine_create(stream_run);\n\n    trace_stream_start(bs, base, s, co, opaque);\n\n    qemu_coroutine_enter(co, s);\n\n}\n", "idx": 22652}
{"project": "qemu", "commit_id": "9894c5d4b467d24e281c22f2f5e24822c9b55fb3", "target": 1, "func": "static PCIDevice *find_dev(sPAPREnvironment *spapr,\n\n                           uint64_t buid, uint32_t config_addr)\n\n{\n\n    int devfn = (config_addr >> 8) & 0xFF;\n\n    sPAPRPHBState *phb;\n\n\n\n    QLIST_FOREACH(phb, &spapr->phbs, list) {\n\n        BusChild *kid;\n\n\n\n        if (phb->buid != buid) {\n\n            continue;\n\n        }\n\n\n\n        QTAILQ_FOREACH(kid, &phb->host_state.bus->qbus.children, sibling) {\n\n            PCIDevice *dev = (PCIDevice *)kid->child;\n\n            if (dev->devfn == devfn) {\n\n                return dev;\n\n            }\n\n        }\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 22653}
{"project": "qemu", "commit_id": "a005b3ef50439b5bc6b2eb0b5bda8e8c7c2368bf", "target": 1, "func": "int xics_alloc(XICSState *icp, int src, int irq_hint, bool lsi)\n\n{\n\n    ICSState *ics = &icp->ics[src];\n\n    int irq;\n\n\n\n    if (irq_hint) {\n\n        assert(src == xics_find_source(icp, irq_hint));\n\n        if (!ICS_IRQ_FREE(ics, irq_hint - ics->offset)) {\n\n            trace_xics_alloc_failed_hint(src, irq_hint);\n\n            return -1;\n\n        }\n\n        irq = irq_hint;\n\n    } else {\n\n        irq = ics_find_free_block(ics, 1, 1);\n\n        if (irq < 0) {\n\n            trace_xics_alloc_failed_no_left(src);\n\n            return -1;\n\n        }\n\n        irq += ics->offset;\n\n    }\n\n\n\n    ics_set_irq_type(ics, irq - ics->offset, lsi);\n\n    trace_xics_alloc(src, irq);\n\n\n\n    return irq;\n\n}\n", "idx": 22654}
{"project": "qemu", "commit_id": "5839e53bbc0fec56021d758aab7610df421ed8c8", "target": 1, "func": "static int archipelago_submit_request(BDRVArchipelagoState *s,\n\n                                        uint64_t bufidx,\n\n                                        size_t count,\n\n                                        off_t offset,\n\n                                        ArchipelagoAIOCB *aio_cb,\n\n                                        ArchipelagoSegmentedRequest *segreq,\n\n                                        int op)\n\n{\n\n    int ret, targetlen;\n\n    char *target;\n\n    void *data = NULL;\n\n    struct xseg_request *req;\n\n    AIORequestData *reqdata = g_malloc(sizeof(AIORequestData));\n\n\n\n    targetlen = strlen(s->volname);\n\n    req = xseg_get_request(s->xseg, s->srcport, s->vportno, X_ALLOC);\n\n    if (!req) {\n\n        archipelagolog(\"Cannot get XSEG request\\n\");\n\n        goto err_exit2;\n\n    }\n\n    ret = xseg_prep_request(s->xseg, req, targetlen, count);\n\n    if (ret < 0) {\n\n        archipelagolog(\"Cannot prepare XSEG request\\n\");\n\n        goto err_exit;\n\n    }\n\n    target = xseg_get_target(s->xseg, req);\n\n    if (!target) {\n\n        archipelagolog(\"Cannot get XSEG target\\n\");\n\n        goto err_exit;\n\n    }\n\n    memcpy(target, s->volname, targetlen);\n\n    req->size = count;\n\n    req->offset = offset;\n\n\n\n    switch (op) {\n\n    case ARCHIP_OP_READ:\n\n        req->op = X_READ;\n\n        break;\n\n    case ARCHIP_OP_WRITE:\n\n        req->op = X_WRITE;\n\n        break;\n\n    case ARCHIP_OP_FLUSH:\n\n        req->op = X_FLUSH;\n\n        break;\n\n    }\n\n    reqdata->volname = s->volname;\n\n    reqdata->offset = offset;\n\n    reqdata->size = count;\n\n    reqdata->bufidx = bufidx;\n\n    reqdata->aio_cb = aio_cb;\n\n    reqdata->segreq = segreq;\n\n    reqdata->op = op;\n\n\n\n    xseg_set_req_data(s->xseg, req, reqdata);\n\n    if (op == ARCHIP_OP_WRITE) {\n\n        data = xseg_get_data(s->xseg, req);\n\n        if (!data) {\n\n            archipelagolog(\"Cannot get XSEG data\\n\");\n\n            goto err_exit;\n\n        }\n\n        qemu_iovec_to_buf(aio_cb->qiov, bufidx, data, count);\n\n    }\n\n\n\n    xport p = xseg_submit(s->xseg, req, s->srcport, X_ALLOC);\n\n    if (p == NoPort) {\n\n        archipelagolog(\"Could not submit XSEG request\\n\");\n\n        goto err_exit;\n\n    }\n\n    xseg_signal(s->xseg, p);\n\n    return 0;\n\n\n\nerr_exit:\n\n    g_free(reqdata);\n\n    xseg_put_request(s->xseg, req, s->srcport);\n\n    return -EIO;\n\nerr_exit2:\n\n    g_free(reqdata);\n\n    return -EIO;\n\n}\n", "idx": 22659}
{"project": "qemu", "commit_id": "16617e36b02ebdc83f215d89db9ac00f7d6d6d83", "target": 1, "func": "int vhost_dev_enable_notifiers(struct vhost_dev *hdev, VirtIODevice *vdev)\n\n{\n\n    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));\n\n    VirtioBusState *vbus = VIRTIO_BUS(qbus);\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(vbus);\n\n    int i, r;\n\n    if (!k->set_host_notifier) {\n\n        fprintf(stderr, \"binding does not support host notifiers\\n\");\n\n        r = -ENOSYS;\n\n        goto fail;\n\n    }\n\n\n\n    for (i = 0; i < hdev->nvqs; ++i) {\n\n        r = k->set_host_notifier(qbus->parent, hdev->vq_index + i, true);\n\n        if (r < 0) {\n\n            fprintf(stderr, \"vhost VQ %d notifier binding failed: %d\\n\", i, -r);\n\n            goto fail_vq;\n\n        }\n\n    }\n\n\n\n    return 0;\n\nfail_vq:\n\n    while (--i >= 0) {\n\n        r = k->set_host_notifier(qbus->parent, hdev->vq_index + i, false);\n\n        if (r < 0) {\n\n            fprintf(stderr, \"vhost VQ %d notifier cleanup error: %d\\n\", i, -r);\n\n            fflush(stderr);\n\n        }\n\n        assert (r >= 0);\n\n    }\n\nfail:\n\n    return r;\n\n}\n", "idx": 22660}
{"project": "qemu", "commit_id": "02c4f26b1517d9e403ec10d6f6ca3c0276d19e43", "target": 1, "func": "static int multiwrite_f(BlockDriverState *bs, int argc, char **argv)\n\n{\n\n    struct timeval t1, t2;\n\n    int Cflag = 0, qflag = 0;\n\n    int c, cnt;\n\n    char **buf;\n\n    int64_t offset, first_offset = 0;\n\n    /* Some compilers get confused and warn if this is not initialized.  */\n\n    int total = 0;\n\n    int nr_iov;\n\n    int nr_reqs;\n\n    int pattern = 0xcd;\n\n    QEMUIOVector *qiovs;\n\n    int i;\n\n    BlockRequest *reqs;\n\n\n\n    while ((c = getopt(argc, argv, \"CqP:\")) != EOF) {\n\n        switch (c) {\n\n        case 'C':\n\n            Cflag = 1;\n\n            break;\n\n        case 'q':\n\n            qflag = 1;\n\n            break;\n\n        case 'P':\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n                return 0;\n\n            }\n\n            break;\n\n        default:\n\n            return qemuio_command_usage(&writev_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind > argc - 2) {\n\n        return qemuio_command_usage(&writev_cmd);\n\n    }\n\n\n\n    nr_reqs = 1;\n\n    for (i = optind; i < argc; i++) {\n\n        if (!strcmp(argv[i], \";\")) {\n\n            nr_reqs++;\n\n        }\n\n    }\n\n\n\n    reqs = g_malloc0(nr_reqs * sizeof(*reqs));\n\n    buf = g_malloc0(nr_reqs * sizeof(*buf));\n\n    qiovs = g_malloc(nr_reqs * sizeof(*qiovs));\n\n\n\n    for (i = 0; i < nr_reqs && optind < argc; i++) {\n\n        int j;\n\n\n\n        /* Read the offset of the request */\n\n        offset = cvtnum(argv[optind]);\n\n        if (offset < 0) {\n\n            printf(\"non-numeric offset argument -- %s\\n\", argv[optind]);\n\n            goto out;\n\n        }\n\n        optind++;\n\n\n\n        if (offset & 0x1ff) {\n\n            printf(\"offset %lld is not sector aligned\\n\",\n\n                   (long long)offset);\n\n            goto out;\n\n        }\n\n\n\n        if (i == 0) {\n\n            first_offset = offset;\n\n        }\n\n\n\n        /* Read lengths for qiov entries */\n\n        for (j = optind; j < argc; j++) {\n\n            if (!strcmp(argv[j], \";\")) {\n\n                break;\n\n            }\n\n        }\n\n\n\n        nr_iov = j - optind;\n\n\n\n        /* Build request */\n\n        buf[i] = create_iovec(bs, &qiovs[i], &argv[optind], nr_iov, pattern);\n\n        if (buf[i] == NULL) {\n\n            goto out;\n\n        }\n\n\n\n        reqs[i].qiov = &qiovs[i];\n\n        reqs[i].sector = offset >> 9;\n\n        reqs[i].nb_sectors = reqs[i].qiov->size >> 9;\n\n\n\n        optind = j + 1;\n\n\n\n        pattern++;\n\n    }\n\n\n\n    /* If there were empty requests at the end, ignore them */\n\n    nr_reqs = i;\n\n\n\n    gettimeofday(&t1, NULL);\n\n    cnt = do_aio_multiwrite(bs, reqs, nr_reqs, &total);\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (cnt < 0) {\n\n        printf(\"aio_multiwrite failed: %s\\n\", strerror(-cnt));\n\n        goto out;\n\n    }\n\n\n\n    if (qflag) {\n\n        goto out;\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, t1);\n\n    print_report(\"wrote\", &t2, first_offset, total, total, cnt, Cflag);\n\nout:\n\n    for (i = 0; i < nr_reqs; i++) {\n\n        qemu_io_free(buf[i]);\n\n        if (reqs[i].qiov != NULL) {\n\n            qemu_iovec_destroy(&qiovs[i]);\n\n        }\n\n    }\n\n    g_free(buf);\n\n    g_free(reqs);\n\n    g_free(qiovs);\n\n    return 0;\n\n}\n", "idx": 22661}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int socket_get_fd(void *opaque)\n\n{\n\n    QEMUFileSocket *s = opaque;\n\n\n\n    return s->fd;\n\n}\n", "idx": 22666}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void mips_cps_realize(DeviceState *dev, Error **errp)\n\n{\n\n    MIPSCPSState *s = MIPS_CPS(dev);\n\n    CPUMIPSState *env;\n\n    MIPSCPU *cpu;\n\n    int i;\n\n    Error *err = NULL;\n\n    target_ulong gcr_base;\n\n    bool itu_present = false;\n\n\n\n    for (i = 0; i < s->num_vp; i++) {\n\n        cpu = cpu_mips_init(s->cpu_model);\n\n        if (cpu == NULL) {\n\n            error_setg(errp, \"%s: CPU initialization failed\",  __func__);\n\n            return;\n\n        }\n\n\n\n        /* Init internal devices */\n\n        cpu_mips_irq_init_cpu(cpu);\n\n        cpu_mips_clock_init(cpu);\n\n\n\n        env = &cpu->env;\n\n        if (cpu_mips_itu_supported(env)) {\n\n            itu_present = true;\n\n            /* Attach ITC Tag to the VP */\n\n            env->itc_tag = mips_itu_get_tag_region(&s->itu);\n\n        }\n\n        qemu_register_reset(main_cpu_reset, cpu);\n\n    }\n\n\n\n    cpu = MIPS_CPU(first_cpu);\n\n    env = &cpu->env;\n\n\n\n    /* Inter-Thread Communication Unit */\n\n    if (itu_present) {\n\n        object_initialize(&s->itu, sizeof(s->itu), TYPE_MIPS_ITU);\n\n        qdev_set_parent_bus(DEVICE(&s->itu), sysbus_get_default());\n\n\n\n        object_property_set_int(OBJECT(&s->itu), 16, \"num-fifo\", &err);\n\n        object_property_set_int(OBJECT(&s->itu), 16, \"num-semaphores\", &err);\n\n        object_property_set_bool(OBJECT(&s->itu), true, \"realized\", &err);\n\n        if (err != NULL) {\n\n            error_propagate(errp, err);\n\n            return;\n\n        }\n\n\n\n        memory_region_add_subregion(&s->container, 0,\n\n                           sysbus_mmio_get_region(SYS_BUS_DEVICE(&s->itu), 0));\n\n    }\n\n\n\n    /* Cluster Power Controller */\n\n    object_initialize(&s->cpc, sizeof(s->cpc), TYPE_MIPS_CPC);\n\n    qdev_set_parent_bus(DEVICE(&s->cpc), sysbus_get_default());\n\n\n\n    object_property_set_int(OBJECT(&s->cpc), s->num_vp, \"num-vp\", &err);\n\n    object_property_set_int(OBJECT(&s->cpc), 1, \"vp-start-running\", &err);\n\n    object_property_set_bool(OBJECT(&s->cpc), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n\n\n    memory_region_add_subregion(&s->container, 0,\n\n                            sysbus_mmio_get_region(SYS_BUS_DEVICE(&s->cpc), 0));\n\n\n\n    /* Global Interrupt Controller */\n\n    object_initialize(&s->gic, sizeof(s->gic), TYPE_MIPS_GIC);\n\n    qdev_set_parent_bus(DEVICE(&s->gic), sysbus_get_default());\n\n\n\n    object_property_set_int(OBJECT(&s->gic), s->num_vp, \"num-vp\", &err);\n\n    object_property_set_int(OBJECT(&s->gic), 128, \"num-irq\", &err);\n\n    object_property_set_bool(OBJECT(&s->gic), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n\n\n    memory_region_add_subregion(&s->container, 0,\n\n                            sysbus_mmio_get_region(SYS_BUS_DEVICE(&s->gic), 0));\n\n\n\n    /* Global Configuration Registers */\n\n    gcr_base = env->CP0_CMGCRBase << 4;\n\n\n\n    object_initialize(&s->gcr, sizeof(s->gcr), TYPE_MIPS_GCR);\n\n    qdev_set_parent_bus(DEVICE(&s->gcr), sysbus_get_default());\n\n\n\n    object_property_set_int(OBJECT(&s->gcr), s->num_vp, \"num-vp\", &err);\n\n    object_property_set_int(OBJECT(&s->gcr), 0x800, \"gcr-rev\", &err);\n\n    object_property_set_int(OBJECT(&s->gcr), gcr_base, \"gcr-base\", &err);\n\n    object_property_set_link(OBJECT(&s->gcr), OBJECT(&s->gic.mr), \"gic\", &err);\n\n    object_property_set_link(OBJECT(&s->gcr), OBJECT(&s->cpc.mr), \"cpc\", &err);\n\n    object_property_set_bool(OBJECT(&s->gcr), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n\n\n    memory_region_add_subregion(&s->container, gcr_base,\n\n                            sysbus_mmio_get_region(SYS_BUS_DEVICE(&s->gcr), 0));\n\n}\n", "idx": 22667}
{"project": "qemu", "commit_id": "1e06262da615fcc0ddd658f96c5673a73b856fb6", "target": 1, "func": "static void load_symbols(struct elfhdr *hdr, int fd, abi_ulong load_bias)\n\n{\n\n    int i, shnum, nsyms, sym_idx = 0, str_idx = 0;\n\n    struct elf_shdr *shdr;\n\n    char *strings = NULL;\n\n    struct syminfo *s = NULL;\n\n    struct elf_sym *new_syms, *syms = NULL;\n\n\n\n    shnum = hdr->e_shnum;\n\n    i = shnum * sizeof(struct elf_shdr);\n\n    shdr = (struct elf_shdr *)alloca(i);\n\n    if (pread(fd, shdr, i, hdr->e_shoff) != i) {\n\n        return;\n\n    }\n\n\n\n    bswap_shdr(shdr, shnum);\n\n    for (i = 0; i < shnum; ++i) {\n\n        if (shdr[i].sh_type == SHT_SYMTAB) {\n\n            sym_idx = i;\n\n            str_idx = shdr[i].sh_link;\n\n            goto found;\n\n        }\n\n    }\n\n\n\n    /* There will be no symbol table if the file was stripped.  */\n\n    return;\n\n\n\n found:\n\n    /* Now know where the strtab and symtab are.  Snarf them.  */\n\n    s = g_try_new(struct syminfo, 1);\n\n    if (!s) {\n\n        goto give_up;\n\n    }\n\n\n\n    i = shdr[str_idx].sh_size;\n\n    s->disas_strtab = strings = g_try_malloc(i);\n\n    if (!strings || pread(fd, strings, i, shdr[str_idx].sh_offset) != i) {\n\n        goto give_up;\n\n    }\n\n\n\n    i = shdr[sym_idx].sh_size;\n\n    syms = g_try_malloc(i);\n\n    if (!syms || pread(fd, syms, i, shdr[sym_idx].sh_offset) != i) {\n\n        goto give_up;\n\n    }\n\n\n\n    nsyms = i / sizeof(struct elf_sym);\n\n    for (i = 0; i < nsyms; ) {\n\n        bswap_sym(syms + i);\n\n        /* Throw away entries which we do not need.  */\n\n        if (syms[i].st_shndx == SHN_UNDEF\n\n            || syms[i].st_shndx >= SHN_LORESERVE\n\n            || ELF_ST_TYPE(syms[i].st_info) != STT_FUNC) {\n\n            if (i < --nsyms) {\n\n                syms[i] = syms[nsyms];\n\n            }\n\n        } else {\n\n#if defined(TARGET_ARM) || defined (TARGET_MIPS)\n\n            /* The bottom address bit marks a Thumb or MIPS16 symbol.  */\n\n            syms[i].st_value &= ~(target_ulong)1;\n\n#endif\n\n            syms[i].st_value += load_bias;\n\n            i++;\n\n        }\n\n    }\n\n\n\n    /* No \"useful\" symbol.  */\n\n    if (nsyms == 0) {\n\n        goto give_up;\n\n    }\n\n\n\n    /* Attempt to free the storage associated with the local symbols\n\n       that we threw away.  Whether or not this has any effect on the\n\n       memory allocation depends on the malloc implementation and how\n\n       many symbols we managed to discard.  */\n\n    new_syms = g_try_renew(struct elf_sym, syms, nsyms);\n\n    if (new_syms == NULL) {\n\n        goto give_up;\n\n    }\n\n    syms = new_syms;\n\n\n\n    qsort(syms, nsyms, sizeof(*syms), symcmp);\n\n\n\n    s->disas_num_syms = nsyms;\n\n#if ELF_CLASS == ELFCLASS32\n\n    s->disas_symtab.elf32 = syms;\n\n#else\n\n    s->disas_symtab.elf64 = syms;\n\n#endif\n\n    s->lookup_symbol = lookup_symbolxx;\n\n    s->next = syminfos;\n\n    syminfos = s;\n\n\n\n    return;\n\n\n\ngive_up:\n\n    g_free(s);\n\n    g_free(strings);\n\n    g_free(syms);\n\n}\n", "idx": 22668}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void qvirtio_pci_set_queue_address(QVirtioDevice *d, uint32_t pfn)\n\n{\n\n    QVirtioPCIDevice *dev = (QVirtioPCIDevice *)d;\n\n    qpci_io_writel(dev->pdev, dev->addr + VIRTIO_PCI_QUEUE_PFN, pfn);\n\n}\n", "idx": 22669}
{"project": "qemu", "commit_id": "89f26e6b7b5e5c9657f2abd6ef5a336bea11add2", "target": 1, "func": "static void fill_prefetch_fifo(struct omap_gpmc_s *s)\n{\n    /* Fill the prefetch FIFO by reading data from NAND.\n     * We do this synchronously, unlike the hardware which\n     * will do this asynchronously. We refill when the\n     * FIFO has THRESHOLD bytes free, and we always refill\n     * as much data as possible starting at the top end\n     * of the FIFO.\n     * (We have to refill at THRESHOLD rather than waiting\n     * for the FIFO to empty to allow for the case where\n     * the FIFO size isn't an exact multiple of THRESHOLD\n     * and we're doing DMA transfers.)\n     * This means we never need to handle wrap-around in\n     * the fifo-reading code, and the next byte of data\n     * to read is always fifo[63 - fifopointer].\n     */\n    int fptr;\n    int cs = prefetch_cs(s->prefetch.config1);\n    int is16bit = (((s->cs_file[cs].config[0] >> 12) & 3) != 0);\n    int bytes;\n    /* Don't believe the bit of the OMAP TRM that says that COUNTVALUE\n     * and TRANSFERCOUNT are in units of 16 bit words for 16 bit NAND.\n     * Instead believe the bit that says it is always a byte count.\n     */\n    bytes = 64 - s->prefetch.fifopointer;\n    if (bytes > s->prefetch.count) {\n        bytes = s->prefetch.count;\n    s->prefetch.count -= bytes;\n    s->prefetch.fifopointer += bytes;\n    fptr = 64 - s->prefetch.fifopointer;\n    /* Move the existing data in the FIFO so it sits just\n     * before what we're about to read in\n     */\n    while (fptr < (64 - bytes)) {\n        s->prefetch.fifo[fptr] = s->prefetch.fifo[fptr + bytes];\n        fptr++;\n    while (fptr < 64) {\n            uint32_t v = omap_nand_read(&s->cs_file[cs], 0, 2);\n            s->prefetch.fifo[fptr++] = v & 0xff;\n            s->prefetch.fifo[fptr++] = (v >> 8) & 0xff;\n        } else {\n            s->prefetch.fifo[fptr++] = omap_nand_read(&s->cs_file[cs], 0, 1);\n    if (s->prefetch.startengine && (s->prefetch.count == 0)) {\n        /* This was the final transfer: raise TERMINALCOUNTSTATUS */\n        s->irqst |= 2;\n        s->prefetch.startengine = 0;\n    /* If there are any bytes in the FIFO at this point then\n     * we must raise a DMA request (either this is a final part\n     * transfer, or we filled the FIFO in which case we certainly\n     * have THRESHOLD bytes available)\n     */\n    if (s->prefetch.fifopointer != 0) {\n        omap_gpmc_dma_update(s, 1);\n    omap_gpmc_int_update(s);", "idx": 22676}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "void vnc_disconnect_finish(VncState *vs)\n\n{\n\n    int i;\n\n\n\n    vnc_jobs_join(vs); /* Wait encoding jobs */\n\n\n\n    vnc_lock_output(vs);\n\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_DISCONNECTED);\n\n\n\n    buffer_free(&vs->input);\n\n    buffer_free(&vs->output);\n\n    buffer_free(&vs->ws_input);\n\n    buffer_free(&vs->ws_output);\n\n\n\n    qapi_free_VncClientInfo(vs->info);\n\n\n\n    vnc_zlib_clear(vs);\n\n    vnc_tight_clear(vs);\n\n    vnc_zrle_clear(vs);\n\n\n\n#ifdef CONFIG_VNC_TLS\n\n    vnc_tls_client_cleanup(vs);\n\n#endif /* CONFIG_VNC_TLS */\n\n#ifdef CONFIG_VNC_SASL\n\n    vnc_sasl_client_cleanup(vs);\n\n#endif /* CONFIG_VNC_SASL */\n\n    audio_del(vs);\n\n    vnc_release_modifiers(vs);\n\n\n\n    if (vs->initialized) {\n\n        QTAILQ_REMOVE(&vs->vd->clients, vs, next);\n\n        qemu_remove_mouse_mode_change_notifier(&vs->mouse_mode_notifier);\n\n    }\n\n\n\n    if (vs->vd->lock_key_sync)\n\n        qemu_remove_led_event_handler(vs->led);\n\n    vnc_unlock_output(vs);\n\n\n\n    qemu_mutex_destroy(&vs->output_mutex);\n\n    if (vs->bh != NULL) {\n\n        qemu_bh_delete(vs->bh);\n\n    }\n\n    buffer_free(&vs->jobs_buffer);\n\n\n\n    for (i = 0; i < VNC_STAT_ROWS; ++i) {\n\n        g_free(vs->lossy_rect[i]);\n\n    }\n\n    g_free(vs->lossy_rect);\n\n    g_free(vs);\n\n}\n", "idx": 22680}
{"project": "qemu", "commit_id": "630530a6529bc3da9ab8aead7053dc753cb9ac77", "target": 1, "func": "static int get_whole_cluster(BlockDriverState *bs, uint64_t cluster_offset,\n\n                             uint64_t offset, int allocate)\n\n{\n\n    uint64_t parent_cluster_offset;\n\n    BDRVVmdkState *s = bs->opaque;\n\n    uint8_t  whole_grain[s->cluster_sectors*512];        // 128 sectors * 512 bytes each = grain size 64KB\n\n\n\n    // we will be here if it's first write on non-exist grain(cluster).\n\n    // try to read from parent image, if exist\n\n    if (s->hd->backing_hd) {\n\n        BDRVVmdkState *ps = s->hd->backing_hd->opaque;\n\n\n\n        if (!vmdk_is_cid_valid(bs))\n\n            return -1;\n\n        parent_cluster_offset = get_cluster_offset(s->hd->backing_hd, offset, allocate);\n\n        if (bdrv_pread(ps->hd, parent_cluster_offset, whole_grain, ps->cluster_sectors*512) != \n\n                                                                            ps->cluster_sectors*512)\n\n            return -1;\n\n\n\n        if (bdrv_pwrite(s->hd, cluster_offset << 9, whole_grain, sizeof(whole_grain)) != \n\n                                                                            sizeof(whole_grain))\n\n            return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 22681}
{"project": "qemu", "commit_id": "3494d650273e619606c6cb2c38aa9b8b7bed98e2", "target": 1, "func": "static int curl_open(BlockDriverState *bs, QDict *options, int flags)\n\n{\n\n    BDRVCURLState *s = bs->opaque;\n\n    CURLState *state = NULL;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n    const char *file;\n\n    double d;\n\n\n\n    static int inited = 0;\n\n\n\n    if (flags & BDRV_O_RDWR) {\n\n        qerror_report(ERROR_CLASS_GENERIC_ERROR,\n\n                      \"curl block device does not support writes\");\n\n        return -EROFS;\n\n    }\n\n\n\n    opts = qemu_opts_create_nofail(&runtime_opts);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        goto out_noclean;\n\n    }\n\n\n\n    s->readahead_size = qemu_opt_get_size(opts, \"readahead\", READ_AHEAD_SIZE);\n\n    if ((s->readahead_size & 0x1ff) != 0) {\n\n        fprintf(stderr, \"HTTP_READAHEAD_SIZE %zd is not a multiple of 512\\n\",\n\n                s->readahead_size);\n\n        goto out_noclean;\n\n    }\n\n\n\n    file = qemu_opt_get(opts, \"url\");\n\n    if (file == NULL) {\n\n        qerror_report(ERROR_CLASS_GENERIC_ERROR, \"curl block driver requires \"\n\n                      \"an 'url' option\");\n\n        goto out_noclean;\n\n    }\n\n\n\n    if (!inited) {\n\n        curl_global_init(CURL_GLOBAL_ALL);\n\n        inited = 1;\n\n    }\n\n\n\n    DPRINTF(\"CURL: Opening %s\\n\", file);\n\n    s->url = g_strdup(file);\n\n    state = curl_init_state(s);\n\n    if (!state)\n\n        goto out_noclean;\n\n\n\n    // Get file size\n\n\n\n    curl_easy_setopt(state->curl, CURLOPT_NOBODY, 1);\n\n    curl_easy_setopt(state->curl, CURLOPT_WRITEFUNCTION, (void *)curl_size_cb);\n\n    if (curl_easy_perform(state->curl))\n\n        goto out;\n\n    curl_easy_getinfo(state->curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &d);\n\n    if (d)\n\n        s->len = (size_t)d;\n\n    else if(!s->len)\n\n        goto out;\n\n    DPRINTF(\"CURL: Size = %zd\\n\", s->len);\n\n\n\n    curl_clean_state(state);\n\n    curl_easy_cleanup(state->curl);\n\n    state->curl = NULL;\n\n\n\n    // Now we know the file exists and its size, so let's\n\n    // initialize the multi interface!\n\n\n\n    s->multi = curl_multi_init();\n\n    curl_multi_setopt(s->multi, CURLMOPT_SOCKETDATA, s);\n\n    curl_multi_setopt(s->multi, CURLMOPT_SOCKETFUNCTION, curl_sock_cb);\n\n    curl_multi_do(s);\n\n\n\n    qemu_opts_del(opts);\n\n    return 0;\n\n\n\nout:\n\n    fprintf(stderr, \"CURL: Error opening file: %s\\n\", state->errmsg);\n\n    curl_easy_cleanup(state->curl);\n\n    state->curl = NULL;\n\nout_noclean:\n\n    g_free(s->url);\n\n    qemu_opts_del(opts);\n\n    return -EINVAL;\n\n}\n", "idx": 22682}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(srawi)\n\n{\n\n    T1 = T0;\n\n    T0 = (Ts0 >> PARAM(1));\n\n    if (Ts1 < 0 && (Ts1 & PARAM(2)) != 0) {\n\n        xer_ca = 1;\n\n    } else {\n\n        xer_ca = 0;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 22683}
{"project": "qemu", "commit_id": "66dc50f7057b9a0191f54e55764412202306858d", "target": 1, "func": "static int do_subchannel_work(SubchDev *sch)\n\n{\n\n    if (!sch->do_subchannel_work) {\n\n        return -EINVAL;\n\n    }\n\n    g_assert(sch->curr_status.scsw.ctrl & SCSW_CTRL_MASK_FCTL);\n\n    return sch->do_subchannel_work(sch);\n\n}\n", "idx": 22684}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_type_uint8(Visitor *v, uint8_t *obj, const char *name, Error **errp)\n\n{\n\n    int64_t value;\n\n    if (!error_is_set(errp)) {\n\n        if (v->type_uint8) {\n\n            v->type_uint8(v, obj, name, errp);\n\n        } else {\n\n            value = *obj;\n\n            v->type_int(v, &value, name, errp);\n\n            if (value < 0 || value > UINT8_MAX) {\n\n                error_set(errp, QERR_INVALID_PARAMETER_VALUE, name ? name : \"null\",\n\n                          \"uint8_t\");\n\n                return;\n\n            }\n\n            *obj = value;\n\n        }\n\n    }\n\n}\n", "idx": 22686}
{"project": "qemu", "commit_id": "b45c03f585ea9bb1af76c73e82195418c294919d", "target": 1, "func": "static struct omap_uwire_s *omap_uwire_init(MemoryRegion *system_memory,\n\n                                            hwaddr base,\n\n                                            qemu_irq txirq, qemu_irq rxirq,\n\n                                            qemu_irq dma,\n\n                                            omap_clk clk)\n\n{\n\n    struct omap_uwire_s *s = (struct omap_uwire_s *)\n\n            g_malloc0(sizeof(struct omap_uwire_s));\n\n\n\n    s->txirq = txirq;\n\n    s->rxirq = rxirq;\n\n    s->txdrq = dma;\n\n    omap_uwire_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &omap_uwire_ops, s, \"omap-uwire\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 22687}
{"project": "qemu", "commit_id": "966439a67830239a6c520c5df6c55627b8153c8b", "target": 1, "func": "void do_addmeo_64 (void)\n\n{\n\n    T1 = T0;\n\n    T0 += xer_ca + (-1);\n\n    if (likely(!((uint64_t)T1 &\n\n                 ((uint64_t)T1 ^ (uint64_t)T0) & (1ULL << 63)))) {\n\n        xer_ov = 0;\n\n    } else {\n\n        xer_so = 1;\n\n        xer_ov = 1;\n\n    }\n\n    if (likely(T1 != 0))\n\n        xer_ca = 1;\n\n}\n", "idx": 22688}
{"project": "qemu", "commit_id": "9fbf4a58c90183b30bb2c8ad971ccce7e6716a16", "target": 1, "func": "hwaddr mips_cpu_get_phys_page_debug(CPUState *cs, vaddr addr)\n\n{\n\n    MIPSCPU *cpu = MIPS_CPU(cs);\n\n    hwaddr phys_addr;\n\n    int prot;\n\n\n\n    if (get_physical_address(&cpu->env, &phys_addr, &prot, addr, 0,\n\n                             ACCESS_INT) != 0) {\n\n        return -1;\n\n    }\n\n    return phys_addr;\n\n}\n", "idx": 22691}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "qemu_irq qemu_irq_split(qemu_irq irq1, qemu_irq irq2)\n\n{\n\n    qemu_irq *s = g_malloc0(2 * sizeof(qemu_irq));\n\n    s[0] = irq1;\n\n    s[1] = irq2;\n\n    return qemu_allocate_irqs(qemu_splitirq, s, 1)[0];\n\n}\n", "idx": 22692}
{"project": "qemu", "commit_id": "daa76aa416b1e18ab1fac650ff53d966d8f21f68", "target": 1, "func": "void trace_init_file(const char *file)\n\n{\n\n#ifdef CONFIG_TRACE_SIMPLE\n\n    st_set_trace_file(file);\n\n#elif defined CONFIG_TRACE_LOG\n\n    /* If both the simple and the log backends are enabled, \"-trace file\"\n\n     * only applies to the simple backend; use \"-D\" for the log backend.\n\n     */\n\n    if (file) {\n\n        qemu_set_log_filename(file);\n\n    }\n\n#else\n\n    if (file) {\n\n        fprintf(stderr, \"error: -trace file=...: \"\n\n                \"option not supported by the selected tracing backends\\n\");\n\n        exit(1);\n\n    }\n\n#endif\n\n}\n", "idx": 22693}
{"project": "qemu", "commit_id": "d9968827032039d99b38db7ad3598767e1a53bbb", "target": 1, "func": "static int disas_iwmmxt_insn(CPUState *env, DisasContext *s, uint32_t insn)\n\n{\n\n    int rd, wrd;\n\n    int rdhi, rdlo, rd0, rd1, i;\n\n    TCGv addr;\n\n    TCGv tmp, tmp2, tmp3;\n\n\n\n    if ((insn & 0x0e000e00) == 0x0c000000) {\n\n        if ((insn & 0x0fe00ff0) == 0x0c400000) {\n\n            wrd = insn & 0xf;\n\n            rdlo = (insn >> 12) & 0xf;\n\n            rdhi = (insn >> 16) & 0xf;\n\n            if (insn & ARM_CP_RW_BIT) {\t\t\t/* TMRRC */\n\n                iwmmxt_load_reg(cpu_V0, wrd);\n\n                tcg_gen_trunc_i64_i32(cpu_R[rdlo], cpu_V0);\n\n                tcg_gen_shri_i64(cpu_V0, cpu_V0, 32);\n\n                tcg_gen_trunc_i64_i32(cpu_R[rdhi], cpu_V0);\n\n            } else {\t\t\t\t\t/* TMCRR */\n\n                tcg_gen_concat_i32_i64(cpu_V0, cpu_R[rdlo], cpu_R[rdhi]);\n\n                iwmmxt_store_reg(cpu_V0, wrd);\n\n                gen_op_iwmmxt_set_mup();\n\n            }\n\n            return 0;\n\n        }\n\n\n\n        wrd = (insn >> 12) & 0xf;\n\n        addr = new_tmp();\n\n        if (gen_iwmmxt_address(s, insn, addr)) {\n\n\n            return 1;\n\n        }\n\n        if (insn & ARM_CP_RW_BIT) {\n\n            if ((insn >> 28) == 0xf) {\t\t\t/* WLDRW wCx */\n\n                tmp = new_tmp();\n\n                tcg_gen_qemu_ld32u(tmp, addr, IS_USER(s));\n\n                iwmmxt_store_creg(wrd, tmp);\n\n            } else {\n\n                i = 1;\n\n                if (insn & (1 << 8)) {\n\n                    if (insn & (1 << 22)) {\t\t/* WLDRD */\n\n                        tcg_gen_qemu_ld64(cpu_M0, addr, IS_USER(s));\n\n                        i = 0;\n\n                    } else {\t\t\t\t/* WLDRW wRd */\n\n                        tmp = gen_ld32(addr, IS_USER(s));\n\n                    }\n\n                } else {\n\n                    if (insn & (1 << 22)) {\t\t/* WLDRH */\n\n                        tmp = gen_ld16u(addr, IS_USER(s));\n\n                    } else {\t\t\t\t/* WLDRB */\n\n                        tmp = gen_ld8u(addr, IS_USER(s));\n\n                    }\n\n                }\n\n                if (i) {\n\n                    tcg_gen_extu_i32_i64(cpu_M0, tmp);\n\n                    dead_tmp(tmp);\n\n                }\n\n                gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n            }\n\n        } else {\n\n            if ((insn >> 28) == 0xf) {\t\t\t/* WSTRW wCx */\n\n                tmp = iwmmxt_load_creg(wrd);\n\n                gen_st32(tmp, addr, IS_USER(s));\n\n            } else {\n\n                gen_op_iwmmxt_movq_M0_wRn(wrd);\n\n                tmp = new_tmp();\n\n                if (insn & (1 << 8)) {\n\n                    if (insn & (1 << 22)) {\t\t/* WSTRD */\n\n                        dead_tmp(tmp);\n\n                        tcg_gen_qemu_st64(cpu_M0, addr, IS_USER(s));\n\n                    } else {\t\t\t\t/* WSTRW wRd */\n\n                        tcg_gen_trunc_i64_i32(tmp, cpu_M0);\n\n                        gen_st32(tmp, addr, IS_USER(s));\n\n                    }\n\n                } else {\n\n                    if (insn & (1 << 22)) {\t\t/* WSTRH */\n\n                        tcg_gen_trunc_i64_i32(tmp, cpu_M0);\n\n                        gen_st16(tmp, addr, IS_USER(s));\n\n                    } else {\t\t\t\t/* WSTRB */\n\n                        tcg_gen_trunc_i64_i32(tmp, cpu_M0);\n\n                        gen_st8(tmp, addr, IS_USER(s));\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n        return 0;\n\n    }\n\n\n\n    if ((insn & 0x0f000000) != 0x0e000000)\n\n        return 1;\n\n\n\n    switch (((insn >> 12) & 0xf00) | ((insn >> 4) & 0xff)) {\n\n    case 0x000:\t\t\t\t\t\t/* WOR */\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 0) & 0xf;\n\n        rd1 = (insn >> 16) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        gen_op_iwmmxt_orq_M0_wRn(rd1);\n\n        gen_op_iwmmxt_setpsr_nz();\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        gen_op_iwmmxt_set_cup();\n\n        break;\n\n    case 0x011:\t\t\t\t\t\t/* TMCR */\n\n        if (insn & 0xf)\n\n            return 1;\n\n        rd = (insn >> 12) & 0xf;\n\n        wrd = (insn >> 16) & 0xf;\n\n        switch (wrd) {\n\n        case ARM_IWMMXT_wCID:\n\n        case ARM_IWMMXT_wCASF:\n\n            break;\n\n        case ARM_IWMMXT_wCon:\n\n            gen_op_iwmmxt_set_cup();\n\n            /* Fall through.  */\n\n        case ARM_IWMMXT_wCSSF:\n\n            tmp = iwmmxt_load_creg(wrd);\n\n            tmp2 = load_reg(s, rd);\n\n            tcg_gen_andc_i32(tmp, tmp, tmp2);\n\n            dead_tmp(tmp2);\n\n            iwmmxt_store_creg(wrd, tmp);\n\n            break;\n\n        case ARM_IWMMXT_wCGR0:\n\n        case ARM_IWMMXT_wCGR1:\n\n        case ARM_IWMMXT_wCGR2:\n\n        case ARM_IWMMXT_wCGR3:\n\n            gen_op_iwmmxt_set_cup();\n\n            tmp = load_reg(s, rd);\n\n            iwmmxt_store_creg(wrd, tmp);\n\n            break;\n\n        default:\n\n            return 1;\n\n        }\n\n        break;\n\n    case 0x100:\t\t\t\t\t\t/* WXOR */\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 0) & 0xf;\n\n        rd1 = (insn >> 16) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        gen_op_iwmmxt_xorq_M0_wRn(rd1);\n\n        gen_op_iwmmxt_setpsr_nz();\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        gen_op_iwmmxt_set_cup();\n\n        break;\n\n    case 0x111:\t\t\t\t\t\t/* TMRC */\n\n        if (insn & 0xf)\n\n            return 1;\n\n        rd = (insn >> 12) & 0xf;\n\n        wrd = (insn >> 16) & 0xf;\n\n        tmp = iwmmxt_load_creg(wrd);\n\n        store_reg(s, rd, tmp);\n\n        break;\n\n    case 0x300:\t\t\t\t\t\t/* WANDN */\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 0) & 0xf;\n\n        rd1 = (insn >> 16) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        tcg_gen_neg_i64(cpu_M0, cpu_M0);\n\n        gen_op_iwmmxt_andq_M0_wRn(rd1);\n\n        gen_op_iwmmxt_setpsr_nz();\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        gen_op_iwmmxt_set_cup();\n\n        break;\n\n    case 0x200:\t\t\t\t\t\t/* WAND */\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 0) & 0xf;\n\n        rd1 = (insn >> 16) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        gen_op_iwmmxt_andq_M0_wRn(rd1);\n\n        gen_op_iwmmxt_setpsr_nz();\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        gen_op_iwmmxt_set_cup();\n\n        break;\n\n    case 0x810: case 0xa10:\t\t\t\t/* WMADD */\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 0) & 0xf;\n\n        rd1 = (insn >> 16) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        if (insn & (1 << 21))\n\n            gen_op_iwmmxt_maddsq_M0_wRn(rd1);\n\n        else\n\n            gen_op_iwmmxt_madduq_M0_wRn(rd1);\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        break;\n\n    case 0x10e: case 0x50e: case 0x90e: case 0xd0e:\t/* WUNPCKIL */\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 16) & 0xf;\n\n        rd1 = (insn >> 0) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        switch ((insn >> 22) & 3) {\n\n        case 0:\n\n            gen_op_iwmmxt_unpacklb_M0_wRn(rd1);\n\n            break;\n\n        case 1:\n\n            gen_op_iwmmxt_unpacklw_M0_wRn(rd1);\n\n            break;\n\n        case 2:\n\n            gen_op_iwmmxt_unpackll_M0_wRn(rd1);\n\n            break;\n\n        case 3:\n\n            return 1;\n\n        }\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        gen_op_iwmmxt_set_cup();\n\n        break;\n\n    case 0x10c: case 0x50c: case 0x90c: case 0xd0c:\t/* WUNPCKIH */\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 16) & 0xf;\n\n        rd1 = (insn >> 0) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        switch ((insn >> 22) & 3) {\n\n        case 0:\n\n            gen_op_iwmmxt_unpackhb_M0_wRn(rd1);\n\n            break;\n\n        case 1:\n\n            gen_op_iwmmxt_unpackhw_M0_wRn(rd1);\n\n            break;\n\n        case 2:\n\n            gen_op_iwmmxt_unpackhl_M0_wRn(rd1);\n\n            break;\n\n        case 3:\n\n            return 1;\n\n        }\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        gen_op_iwmmxt_set_cup();\n\n        break;\n\n    case 0x012: case 0x112: case 0x412: case 0x512:\t/* WSAD */\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 16) & 0xf;\n\n        rd1 = (insn >> 0) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        if (insn & (1 << 22))\n\n            gen_op_iwmmxt_sadw_M0_wRn(rd1);\n\n        else\n\n            gen_op_iwmmxt_sadb_M0_wRn(rd1);\n\n        if (!(insn & (1 << 20)))\n\n            gen_op_iwmmxt_addl_M0_wRn(wrd);\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        break;\n\n    case 0x010: case 0x110: case 0x210: case 0x310:\t/* WMUL */\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 16) & 0xf;\n\n        rd1 = (insn >> 0) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        if (insn & (1 << 21)) {\n\n            if (insn & (1 << 20))\n\n                gen_op_iwmmxt_mulshw_M0_wRn(rd1);\n\n            else\n\n                gen_op_iwmmxt_mulslw_M0_wRn(rd1);\n\n        } else {\n\n            if (insn & (1 << 20))\n\n                gen_op_iwmmxt_muluhw_M0_wRn(rd1);\n\n            else\n\n                gen_op_iwmmxt_mululw_M0_wRn(rd1);\n\n        }\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        break;\n\n    case 0x410: case 0x510: case 0x610: case 0x710:\t/* WMAC */\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 16) & 0xf;\n\n        rd1 = (insn >> 0) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        if (insn & (1 << 21))\n\n            gen_op_iwmmxt_macsw_M0_wRn(rd1);\n\n        else\n\n            gen_op_iwmmxt_macuw_M0_wRn(rd1);\n\n        if (!(insn & (1 << 20))) {\n\n            iwmmxt_load_reg(cpu_V1, wrd);\n\n            tcg_gen_add_i64(cpu_M0, cpu_M0, cpu_V1);\n\n        }\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        break;\n\n    case 0x006: case 0x406: case 0x806: case 0xc06:\t/* WCMPEQ */\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 16) & 0xf;\n\n        rd1 = (insn >> 0) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        switch ((insn >> 22) & 3) {\n\n        case 0:\n\n            gen_op_iwmmxt_cmpeqb_M0_wRn(rd1);\n\n            break;\n\n        case 1:\n\n            gen_op_iwmmxt_cmpeqw_M0_wRn(rd1);\n\n            break;\n\n        case 2:\n\n            gen_op_iwmmxt_cmpeql_M0_wRn(rd1);\n\n            break;\n\n        case 3:\n\n            return 1;\n\n        }\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        gen_op_iwmmxt_set_cup();\n\n        break;\n\n    case 0x800: case 0x900: case 0xc00: case 0xd00:\t/* WAVG2 */\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 16) & 0xf;\n\n        rd1 = (insn >> 0) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        if (insn & (1 << 22)) {\n\n            if (insn & (1 << 20))\n\n                gen_op_iwmmxt_avgw1_M0_wRn(rd1);\n\n            else\n\n                gen_op_iwmmxt_avgw0_M0_wRn(rd1);\n\n        } else {\n\n            if (insn & (1 << 20))\n\n                gen_op_iwmmxt_avgb1_M0_wRn(rd1);\n\n            else\n\n                gen_op_iwmmxt_avgb0_M0_wRn(rd1);\n\n        }\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        gen_op_iwmmxt_set_cup();\n\n        break;\n\n    case 0x802: case 0x902: case 0xa02: case 0xb02:\t/* WALIGNR */\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 16) & 0xf;\n\n        rd1 = (insn >> 0) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        tmp = iwmmxt_load_creg(ARM_IWMMXT_wCGR0 + ((insn >> 20) & 3));\n\n        tcg_gen_andi_i32(tmp, tmp, 7);\n\n        iwmmxt_load_reg(cpu_V1, rd1);\n\n        gen_helper_iwmmxt_align(cpu_M0, cpu_M0, cpu_V1, tmp);\n\n        dead_tmp(tmp);\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        break;\n\n    case 0x601: case 0x605: case 0x609: case 0x60d:\t/* TINSR */\n\n        if (((insn >> 6) & 3) == 3)\n\n            return 1;\n\n        rd = (insn >> 12) & 0xf;\n\n        wrd = (insn >> 16) & 0xf;\n\n        tmp = load_reg(s, rd);\n\n        gen_op_iwmmxt_movq_M0_wRn(wrd);\n\n        switch ((insn >> 6) & 3) {\n\n        case 0:\n\n            tmp2 = tcg_const_i32(0xff);\n\n            tmp3 = tcg_const_i32((insn & 7) << 3);\n\n            break;\n\n        case 1:\n\n            tmp2 = tcg_const_i32(0xffff);\n\n            tmp3 = tcg_const_i32((insn & 3) << 4);\n\n            break;\n\n        case 2:\n\n            tmp2 = tcg_const_i32(0xffffffff);\n\n            tmp3 = tcg_const_i32((insn & 1) << 5);\n\n            break;\n\n        default:\n\n            TCGV_UNUSED(tmp2);\n\n            TCGV_UNUSED(tmp3);\n\n        }\n\n        gen_helper_iwmmxt_insr(cpu_M0, cpu_M0, tmp, tmp2, tmp3);\n\n        tcg_temp_free(tmp3);\n\n        tcg_temp_free(tmp2);\n\n        dead_tmp(tmp);\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        break;\n\n    case 0x107: case 0x507: case 0x907: case 0xd07:\t/* TEXTRM */\n\n        rd = (insn >> 12) & 0xf;\n\n        wrd = (insn >> 16) & 0xf;\n\n        if (rd == 15 || ((insn >> 22) & 3) == 3)\n\n            return 1;\n\n        gen_op_iwmmxt_movq_M0_wRn(wrd);\n\n        tmp = new_tmp();\n\n        switch ((insn >> 22) & 3) {\n\n        case 0:\n\n            tcg_gen_shri_i64(cpu_M0, cpu_M0, (insn & 7) << 3);\n\n            tcg_gen_trunc_i64_i32(tmp, cpu_M0);\n\n            if (insn & 8) {\n\n                tcg_gen_ext8s_i32(tmp, tmp);\n\n            } else {\n\n                tcg_gen_andi_i32(tmp, tmp, 0xff);\n\n            }\n\n            break;\n\n        case 1:\n\n            tcg_gen_shri_i64(cpu_M0, cpu_M0, (insn & 3) << 4);\n\n            tcg_gen_trunc_i64_i32(tmp, cpu_M0);\n\n            if (insn & 8) {\n\n                tcg_gen_ext16s_i32(tmp, tmp);\n\n            } else {\n\n                tcg_gen_andi_i32(tmp, tmp, 0xffff);\n\n            }\n\n            break;\n\n        case 2:\n\n            tcg_gen_shri_i64(cpu_M0, cpu_M0, (insn & 1) << 5);\n\n            tcg_gen_trunc_i64_i32(tmp, cpu_M0);\n\n            break;\n\n        }\n\n        store_reg(s, rd, tmp);\n\n        break;\n\n    case 0x117: case 0x517: case 0x917: case 0xd17:\t/* TEXTRC */\n\n        if ((insn & 0x000ff008) != 0x0003f000 || ((insn >> 22) & 3) == 3)\n\n            return 1;\n\n        tmp = iwmmxt_load_creg(ARM_IWMMXT_wCASF);\n\n        switch ((insn >> 22) & 3) {\n\n        case 0:\n\n            tcg_gen_shri_i32(tmp, tmp, ((insn & 7) << 2) + 0);\n\n            break;\n\n        case 1:\n\n            tcg_gen_shri_i32(tmp, tmp, ((insn & 3) << 3) + 4);\n\n            break;\n\n        case 2:\n\n            tcg_gen_shri_i32(tmp, tmp, ((insn & 1) << 4) + 12);\n\n            break;\n\n        }\n\n        tcg_gen_shli_i32(tmp, tmp, 28);\n\n        gen_set_nzcv(tmp);\n\n        dead_tmp(tmp);\n\n        break;\n\n    case 0x401: case 0x405: case 0x409: case 0x40d:\t/* TBCST */\n\n        if (((insn >> 6) & 3) == 3)\n\n            return 1;\n\n        rd = (insn >> 12) & 0xf;\n\n        wrd = (insn >> 16) & 0xf;\n\n        tmp = load_reg(s, rd);\n\n        switch ((insn >> 6) & 3) {\n\n        case 0:\n\n            gen_helper_iwmmxt_bcstb(cpu_M0, tmp);\n\n            break;\n\n        case 1:\n\n            gen_helper_iwmmxt_bcstw(cpu_M0, tmp);\n\n            break;\n\n        case 2:\n\n            gen_helper_iwmmxt_bcstl(cpu_M0, tmp);\n\n            break;\n\n        }\n\n        dead_tmp(tmp);\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        break;\n\n    case 0x113: case 0x513: case 0x913: case 0xd13:\t/* TANDC */\n\n        if ((insn & 0x000ff00f) != 0x0003f000 || ((insn >> 22) & 3) == 3)\n\n            return 1;\n\n        tmp = iwmmxt_load_creg(ARM_IWMMXT_wCASF);\n\n        tmp2 = new_tmp();\n\n        tcg_gen_mov_i32(tmp2, tmp);\n\n        switch ((insn >> 22) & 3) {\n\n        case 0:\n\n            for (i = 0; i < 7; i ++) {\n\n                tcg_gen_shli_i32(tmp2, tmp2, 4);\n\n                tcg_gen_and_i32(tmp, tmp, tmp2);\n\n            }\n\n            break;\n\n        case 1:\n\n            for (i = 0; i < 3; i ++) {\n\n                tcg_gen_shli_i32(tmp2, tmp2, 8);\n\n                tcg_gen_and_i32(tmp, tmp, tmp2);\n\n            }\n\n            break;\n\n        case 2:\n\n            tcg_gen_shli_i32(tmp2, tmp2, 16);\n\n            tcg_gen_and_i32(tmp, tmp, tmp2);\n\n            break;\n\n        }\n\n        gen_set_nzcv(tmp);\n\n        dead_tmp(tmp2);\n\n        dead_tmp(tmp);\n\n        break;\n\n    case 0x01c: case 0x41c: case 0x81c: case 0xc1c:\t/* WACC */\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 16) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        switch ((insn >> 22) & 3) {\n\n        case 0:\n\n            gen_helper_iwmmxt_addcb(cpu_M0, cpu_M0);\n\n            break;\n\n        case 1:\n\n            gen_helper_iwmmxt_addcw(cpu_M0, cpu_M0);\n\n            break;\n\n        case 2:\n\n            gen_helper_iwmmxt_addcl(cpu_M0, cpu_M0);\n\n            break;\n\n        case 3:\n\n            return 1;\n\n        }\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        break;\n\n    case 0x115: case 0x515: case 0x915: case 0xd15:\t/* TORC */\n\n        if ((insn & 0x000ff00f) != 0x0003f000 || ((insn >> 22) & 3) == 3)\n\n            return 1;\n\n        tmp = iwmmxt_load_creg(ARM_IWMMXT_wCASF);\n\n        tmp2 = new_tmp();\n\n        tcg_gen_mov_i32(tmp2, tmp);\n\n        switch ((insn >> 22) & 3) {\n\n        case 0:\n\n            for (i = 0; i < 7; i ++) {\n\n                tcg_gen_shli_i32(tmp2, tmp2, 4);\n\n                tcg_gen_or_i32(tmp, tmp, tmp2);\n\n            }\n\n            break;\n\n        case 1:\n\n            for (i = 0; i < 3; i ++) {\n\n                tcg_gen_shli_i32(tmp2, tmp2, 8);\n\n                tcg_gen_or_i32(tmp, tmp, tmp2);\n\n            }\n\n            break;\n\n        case 2:\n\n            tcg_gen_shli_i32(tmp2, tmp2, 16);\n\n            tcg_gen_or_i32(tmp, tmp, tmp2);\n\n            break;\n\n        }\n\n        gen_set_nzcv(tmp);\n\n        dead_tmp(tmp2);\n\n        dead_tmp(tmp);\n\n        break;\n\n    case 0x103: case 0x503: case 0x903: case 0xd03:\t/* TMOVMSK */\n\n        rd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 16) & 0xf;\n\n        if ((insn & 0xf) != 0 || ((insn >> 22) & 3) == 3)\n\n            return 1;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        tmp = new_tmp();\n\n        switch ((insn >> 22) & 3) {\n\n        case 0:\n\n            gen_helper_iwmmxt_msbb(tmp, cpu_M0);\n\n            break;\n\n        case 1:\n\n            gen_helper_iwmmxt_msbw(tmp, cpu_M0);\n\n            break;\n\n        case 2:\n\n            gen_helper_iwmmxt_msbl(tmp, cpu_M0);\n\n            break;\n\n        }\n\n        store_reg(s, rd, tmp);\n\n        break;\n\n    case 0x106: case 0x306: case 0x506: case 0x706:\t/* WCMPGT */\n\n    case 0x906: case 0xb06: case 0xd06: case 0xf06:\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 16) & 0xf;\n\n        rd1 = (insn >> 0) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        switch ((insn >> 22) & 3) {\n\n        case 0:\n\n            if (insn & (1 << 21))\n\n                gen_op_iwmmxt_cmpgtsb_M0_wRn(rd1);\n\n            else\n\n                gen_op_iwmmxt_cmpgtub_M0_wRn(rd1);\n\n            break;\n\n        case 1:\n\n            if (insn & (1 << 21))\n\n                gen_op_iwmmxt_cmpgtsw_M0_wRn(rd1);\n\n            else\n\n                gen_op_iwmmxt_cmpgtuw_M0_wRn(rd1);\n\n            break;\n\n        case 2:\n\n            if (insn & (1 << 21))\n\n                gen_op_iwmmxt_cmpgtsl_M0_wRn(rd1);\n\n            else\n\n                gen_op_iwmmxt_cmpgtul_M0_wRn(rd1);\n\n            break;\n\n        case 3:\n\n            return 1;\n\n        }\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        gen_op_iwmmxt_set_cup();\n\n        break;\n\n    case 0x00e: case 0x20e: case 0x40e: case 0x60e:\t/* WUNPCKEL */\n\n    case 0x80e: case 0xa0e: case 0xc0e: case 0xe0e:\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 16) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        switch ((insn >> 22) & 3) {\n\n        case 0:\n\n            if (insn & (1 << 21))\n\n                gen_op_iwmmxt_unpacklsb_M0();\n\n            else\n\n                gen_op_iwmmxt_unpacklub_M0();\n\n            break;\n\n        case 1:\n\n            if (insn & (1 << 21))\n\n                gen_op_iwmmxt_unpacklsw_M0();\n\n            else\n\n                gen_op_iwmmxt_unpackluw_M0();\n\n            break;\n\n        case 2:\n\n            if (insn & (1 << 21))\n\n                gen_op_iwmmxt_unpacklsl_M0();\n\n            else\n\n                gen_op_iwmmxt_unpacklul_M0();\n\n            break;\n\n        case 3:\n\n            return 1;\n\n        }\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        gen_op_iwmmxt_set_cup();\n\n        break;\n\n    case 0x00c: case 0x20c: case 0x40c: case 0x60c:\t/* WUNPCKEH */\n\n    case 0x80c: case 0xa0c: case 0xc0c: case 0xe0c:\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 16) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        switch ((insn >> 22) & 3) {\n\n        case 0:\n\n            if (insn & (1 << 21))\n\n                gen_op_iwmmxt_unpackhsb_M0();\n\n            else\n\n                gen_op_iwmmxt_unpackhub_M0();\n\n            break;\n\n        case 1:\n\n            if (insn & (1 << 21))\n\n                gen_op_iwmmxt_unpackhsw_M0();\n\n            else\n\n                gen_op_iwmmxt_unpackhuw_M0();\n\n            break;\n\n        case 2:\n\n            if (insn & (1 << 21))\n\n                gen_op_iwmmxt_unpackhsl_M0();\n\n            else\n\n                gen_op_iwmmxt_unpackhul_M0();\n\n            break;\n\n        case 3:\n\n            return 1;\n\n        }\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        gen_op_iwmmxt_set_cup();\n\n        break;\n\n    case 0x204: case 0x604: case 0xa04: case 0xe04:\t/* WSRL */\n\n    case 0x214: case 0x614: case 0xa14: case 0xe14:\n\n        if (((insn >> 22) & 3) == 0)\n\n            return 1;\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 16) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        tmp = new_tmp();\n\n        if (gen_iwmmxt_shift(insn, 0xff, tmp)) {\n\n            dead_tmp(tmp);\n\n            return 1;\n\n        }\n\n        switch ((insn >> 22) & 3) {\n\n        case 1:\n\n            gen_helper_iwmmxt_srlw(cpu_M0, cpu_env, cpu_M0, tmp);\n\n            break;\n\n        case 2:\n\n            gen_helper_iwmmxt_srll(cpu_M0, cpu_env, cpu_M0, tmp);\n\n            break;\n\n        case 3:\n\n            gen_helper_iwmmxt_srlq(cpu_M0, cpu_env, cpu_M0, tmp);\n\n            break;\n\n        }\n\n        dead_tmp(tmp);\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        gen_op_iwmmxt_set_cup();\n\n        break;\n\n    case 0x004: case 0x404: case 0x804: case 0xc04:\t/* WSRA */\n\n    case 0x014: case 0x414: case 0x814: case 0xc14:\n\n        if (((insn >> 22) & 3) == 0)\n\n            return 1;\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 16) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        tmp = new_tmp();\n\n        if (gen_iwmmxt_shift(insn, 0xff, tmp)) {\n\n            dead_tmp(tmp);\n\n            return 1;\n\n        }\n\n        switch ((insn >> 22) & 3) {\n\n        case 1:\n\n            gen_helper_iwmmxt_sraw(cpu_M0, cpu_env, cpu_M0, tmp);\n\n            break;\n\n        case 2:\n\n            gen_helper_iwmmxt_sral(cpu_M0, cpu_env, cpu_M0, tmp);\n\n            break;\n\n        case 3:\n\n            gen_helper_iwmmxt_sraq(cpu_M0, cpu_env, cpu_M0, tmp);\n\n            break;\n\n        }\n\n        dead_tmp(tmp);\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        gen_op_iwmmxt_set_cup();\n\n        break;\n\n    case 0x104: case 0x504: case 0x904: case 0xd04:\t/* WSLL */\n\n    case 0x114: case 0x514: case 0x914: case 0xd14:\n\n        if (((insn >> 22) & 3) == 0)\n\n            return 1;\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 16) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        tmp = new_tmp();\n\n        if (gen_iwmmxt_shift(insn, 0xff, tmp)) {\n\n            dead_tmp(tmp);\n\n            return 1;\n\n        }\n\n        switch ((insn >> 22) & 3) {\n\n        case 1:\n\n            gen_helper_iwmmxt_sllw(cpu_M0, cpu_env, cpu_M0, tmp);\n\n            break;\n\n        case 2:\n\n            gen_helper_iwmmxt_slll(cpu_M0, cpu_env, cpu_M0, tmp);\n\n            break;\n\n        case 3:\n\n            gen_helper_iwmmxt_sllq(cpu_M0, cpu_env, cpu_M0, tmp);\n\n            break;\n\n        }\n\n        dead_tmp(tmp);\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        gen_op_iwmmxt_set_cup();\n\n        break;\n\n    case 0x304: case 0x704: case 0xb04: case 0xf04:\t/* WROR */\n\n    case 0x314: case 0x714: case 0xb14: case 0xf14:\n\n        if (((insn >> 22) & 3) == 0)\n\n            return 1;\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 16) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        tmp = new_tmp();\n\n        switch ((insn >> 22) & 3) {\n\n        case 1:\n\n            if (gen_iwmmxt_shift(insn, 0xf, tmp)) {\n\n                dead_tmp(tmp);\n\n                return 1;\n\n            }\n\n            gen_helper_iwmmxt_rorw(cpu_M0, cpu_env, cpu_M0, tmp);\n\n            break;\n\n        case 2:\n\n            if (gen_iwmmxt_shift(insn, 0x1f, tmp)) {\n\n                dead_tmp(tmp);\n\n                return 1;\n\n            }\n\n            gen_helper_iwmmxt_rorl(cpu_M0, cpu_env, cpu_M0, tmp);\n\n            break;\n\n        case 3:\n\n            if (gen_iwmmxt_shift(insn, 0x3f, tmp)) {\n\n                dead_tmp(tmp);\n\n                return 1;\n\n            }\n\n            gen_helper_iwmmxt_rorq(cpu_M0, cpu_env, cpu_M0, tmp);\n\n            break;\n\n        }\n\n        dead_tmp(tmp);\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        gen_op_iwmmxt_set_cup();\n\n        break;\n\n    case 0x116: case 0x316: case 0x516: case 0x716:\t/* WMIN */\n\n    case 0x916: case 0xb16: case 0xd16: case 0xf16:\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 16) & 0xf;\n\n        rd1 = (insn >> 0) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        switch ((insn >> 22) & 3) {\n\n        case 0:\n\n            if (insn & (1 << 21))\n\n                gen_op_iwmmxt_minsb_M0_wRn(rd1);\n\n            else\n\n                gen_op_iwmmxt_minub_M0_wRn(rd1);\n\n            break;\n\n        case 1:\n\n            if (insn & (1 << 21))\n\n                gen_op_iwmmxt_minsw_M0_wRn(rd1);\n\n            else\n\n                gen_op_iwmmxt_minuw_M0_wRn(rd1);\n\n            break;\n\n        case 2:\n\n            if (insn & (1 << 21))\n\n                gen_op_iwmmxt_minsl_M0_wRn(rd1);\n\n            else\n\n                gen_op_iwmmxt_minul_M0_wRn(rd1);\n\n            break;\n\n        case 3:\n\n            return 1;\n\n        }\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        break;\n\n    case 0x016: case 0x216: case 0x416: case 0x616:\t/* WMAX */\n\n    case 0x816: case 0xa16: case 0xc16: case 0xe16:\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 16) & 0xf;\n\n        rd1 = (insn >> 0) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        switch ((insn >> 22) & 3) {\n\n        case 0:\n\n            if (insn & (1 << 21))\n\n                gen_op_iwmmxt_maxsb_M0_wRn(rd1);\n\n            else\n\n                gen_op_iwmmxt_maxub_M0_wRn(rd1);\n\n            break;\n\n        case 1:\n\n            if (insn & (1 << 21))\n\n                gen_op_iwmmxt_maxsw_M0_wRn(rd1);\n\n            else\n\n                gen_op_iwmmxt_maxuw_M0_wRn(rd1);\n\n            break;\n\n        case 2:\n\n            if (insn & (1 << 21))\n\n                gen_op_iwmmxt_maxsl_M0_wRn(rd1);\n\n            else\n\n                gen_op_iwmmxt_maxul_M0_wRn(rd1);\n\n            break;\n\n        case 3:\n\n            return 1;\n\n        }\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        break;\n\n    case 0x002: case 0x102: case 0x202: case 0x302:\t/* WALIGNI */\n\n    case 0x402: case 0x502: case 0x602: case 0x702:\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 16) & 0xf;\n\n        rd1 = (insn >> 0) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        tmp = tcg_const_i32((insn >> 20) & 3);\n\n        iwmmxt_load_reg(cpu_V1, rd1);\n\n        gen_helper_iwmmxt_align(cpu_M0, cpu_M0, cpu_V1, tmp);\n\n        tcg_temp_free(tmp);\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        break;\n\n    case 0x01a: case 0x11a: case 0x21a: case 0x31a:\t/* WSUB */\n\n    case 0x41a: case 0x51a: case 0x61a: case 0x71a:\n\n    case 0x81a: case 0x91a: case 0xa1a: case 0xb1a:\n\n    case 0xc1a: case 0xd1a: case 0xe1a: case 0xf1a:\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 16) & 0xf;\n\n        rd1 = (insn >> 0) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        switch ((insn >> 20) & 0xf) {\n\n        case 0x0:\n\n            gen_op_iwmmxt_subnb_M0_wRn(rd1);\n\n            break;\n\n        case 0x1:\n\n            gen_op_iwmmxt_subub_M0_wRn(rd1);\n\n            break;\n\n        case 0x3:\n\n            gen_op_iwmmxt_subsb_M0_wRn(rd1);\n\n            break;\n\n        case 0x4:\n\n            gen_op_iwmmxt_subnw_M0_wRn(rd1);\n\n            break;\n\n        case 0x5:\n\n            gen_op_iwmmxt_subuw_M0_wRn(rd1);\n\n            break;\n\n        case 0x7:\n\n            gen_op_iwmmxt_subsw_M0_wRn(rd1);\n\n            break;\n\n        case 0x8:\n\n            gen_op_iwmmxt_subnl_M0_wRn(rd1);\n\n            break;\n\n        case 0x9:\n\n            gen_op_iwmmxt_subul_M0_wRn(rd1);\n\n            break;\n\n        case 0xb:\n\n            gen_op_iwmmxt_subsl_M0_wRn(rd1);\n\n            break;\n\n        default:\n\n            return 1;\n\n        }\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        gen_op_iwmmxt_set_cup();\n\n        break;\n\n    case 0x01e: case 0x11e: case 0x21e: case 0x31e:\t/* WSHUFH */\n\n    case 0x41e: case 0x51e: case 0x61e: case 0x71e:\n\n    case 0x81e: case 0x91e: case 0xa1e: case 0xb1e:\n\n    case 0xc1e: case 0xd1e: case 0xe1e: case 0xf1e:\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 16) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        tmp = tcg_const_i32(((insn >> 16) & 0xf0) | (insn & 0x0f));\n\n        gen_helper_iwmmxt_shufh(cpu_M0, cpu_env, cpu_M0, tmp);\n\n        tcg_temp_free(tmp);\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        gen_op_iwmmxt_set_cup();\n\n        break;\n\n    case 0x018: case 0x118: case 0x218: case 0x318:\t/* WADD */\n\n    case 0x418: case 0x518: case 0x618: case 0x718:\n\n    case 0x818: case 0x918: case 0xa18: case 0xb18:\n\n    case 0xc18: case 0xd18: case 0xe18: case 0xf18:\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 16) & 0xf;\n\n        rd1 = (insn >> 0) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        switch ((insn >> 20) & 0xf) {\n\n        case 0x0:\n\n            gen_op_iwmmxt_addnb_M0_wRn(rd1);\n\n            break;\n\n        case 0x1:\n\n            gen_op_iwmmxt_addub_M0_wRn(rd1);\n\n            break;\n\n        case 0x3:\n\n            gen_op_iwmmxt_addsb_M0_wRn(rd1);\n\n            break;\n\n        case 0x4:\n\n            gen_op_iwmmxt_addnw_M0_wRn(rd1);\n\n            break;\n\n        case 0x5:\n\n            gen_op_iwmmxt_adduw_M0_wRn(rd1);\n\n            break;\n\n        case 0x7:\n\n            gen_op_iwmmxt_addsw_M0_wRn(rd1);\n\n            break;\n\n        case 0x8:\n\n            gen_op_iwmmxt_addnl_M0_wRn(rd1);\n\n            break;\n\n        case 0x9:\n\n            gen_op_iwmmxt_addul_M0_wRn(rd1);\n\n            break;\n\n        case 0xb:\n\n            gen_op_iwmmxt_addsl_M0_wRn(rd1);\n\n            break;\n\n        default:\n\n            return 1;\n\n        }\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        gen_op_iwmmxt_set_cup();\n\n        break;\n\n    case 0x008: case 0x108: case 0x208: case 0x308:\t/* WPACK */\n\n    case 0x408: case 0x508: case 0x608: case 0x708:\n\n    case 0x808: case 0x908: case 0xa08: case 0xb08:\n\n    case 0xc08: case 0xd08: case 0xe08: case 0xf08:\n\n        if (!(insn & (1 << 20)) || ((insn >> 22) & 3) == 0)\n\n            return 1;\n\n        wrd = (insn >> 12) & 0xf;\n\n        rd0 = (insn >> 16) & 0xf;\n\n        rd1 = (insn >> 0) & 0xf;\n\n        gen_op_iwmmxt_movq_M0_wRn(rd0);\n\n        switch ((insn >> 22) & 3) {\n\n        case 1:\n\n            if (insn & (1 << 21))\n\n                gen_op_iwmmxt_packsw_M0_wRn(rd1);\n\n            else\n\n                gen_op_iwmmxt_packuw_M0_wRn(rd1);\n\n            break;\n\n        case 2:\n\n            if (insn & (1 << 21))\n\n                gen_op_iwmmxt_packsl_M0_wRn(rd1);\n\n            else\n\n                gen_op_iwmmxt_packul_M0_wRn(rd1);\n\n            break;\n\n        case 3:\n\n            if (insn & (1 << 21))\n\n                gen_op_iwmmxt_packsq_M0_wRn(rd1);\n\n            else\n\n                gen_op_iwmmxt_packuq_M0_wRn(rd1);\n\n            break;\n\n        }\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        gen_op_iwmmxt_set_cup();\n\n        break;\n\n    case 0x201: case 0x203: case 0x205: case 0x207:\n\n    case 0x209: case 0x20b: case 0x20d: case 0x20f:\n\n    case 0x211: case 0x213: case 0x215: case 0x217:\n\n    case 0x219: case 0x21b: case 0x21d: case 0x21f:\n\n        wrd = (insn >> 5) & 0xf;\n\n        rd0 = (insn >> 12) & 0xf;\n\n        rd1 = (insn >> 0) & 0xf;\n\n        if (rd0 == 0xf || rd1 == 0xf)\n\n            return 1;\n\n        gen_op_iwmmxt_movq_M0_wRn(wrd);\n\n        tmp = load_reg(s, rd0);\n\n        tmp2 = load_reg(s, rd1);\n\n        switch ((insn >> 16) & 0xf) {\n\n        case 0x0:\t\t\t\t\t/* TMIA */\n\n            gen_helper_iwmmxt_muladdsl(cpu_M0, cpu_M0, tmp, tmp2);\n\n            break;\n\n        case 0x8:\t\t\t\t\t/* TMIAPH */\n\n            gen_helper_iwmmxt_muladdsw(cpu_M0, cpu_M0, tmp, tmp2);\n\n            break;\n\n        case 0xc: case 0xd: case 0xe: case 0xf:\t\t/* TMIAxy */\n\n            if (insn & (1 << 16))\n\n                tcg_gen_shri_i32(tmp, tmp, 16);\n\n            if (insn & (1 << 17))\n\n                tcg_gen_shri_i32(tmp2, tmp2, 16);\n\n            gen_helper_iwmmxt_muladdswl(cpu_M0, cpu_M0, tmp, tmp2);\n\n            break;\n\n        default:\n\n            dead_tmp(tmp2);\n\n            dead_tmp(tmp);\n\n            return 1;\n\n        }\n\n        dead_tmp(tmp2);\n\n        dead_tmp(tmp);\n\n        gen_op_iwmmxt_movq_wRn_M0(wrd);\n\n        gen_op_iwmmxt_set_mup();\n\n        break;\n\n    default:\n\n        return 1;\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 22700}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void unterminated_dict_comma(void)\n\n{\n\n    QObject *obj = qobject_from_json(\"{'abc':32,\", NULL);\n\n    g_assert(obj == NULL);\n\n}\n", "idx": 22701}
{"project": "qemu", "commit_id": "4abf12f4ea866779b493ecf4606bd0b6d35f8348", "target": 1, "func": "static void rtl8139_io_writel(void *opaque, uint8_t addr, uint32_t val)\n\n{\n\n    RTL8139State *s = opaque;\n\n\n\n    addr &= 0xfc;\n\n\n\n    switch (addr)\n\n    {\n\n        case RxMissed:\n\n            DPRINTF(\"RxMissed clearing on write\\n\");\n\n            s->RxMissed = 0;\n\n            break;\n\n\n\n        case TxConfig:\n\n            rtl8139_TxConfig_write(s, val);\n\n            break;\n\n\n\n        case RxConfig:\n\n            rtl8139_RxConfig_write(s, val);\n\n            break;\n\n\n\n        case TxStatus0 ... TxStatus0+4*4-1:\n\n            rtl8139_TxStatus_write(s, addr-TxStatus0, val);\n\n            break;\n\n\n\n        case TxAddr0 ... TxAddr0+4*4-1:\n\n            rtl8139_TxAddr_write(s, addr-TxAddr0, val);\n\n            break;\n\n\n\n        case RxBuf:\n\n            rtl8139_RxBuf_write(s, val);\n\n            break;\n\n\n\n        case RxRingAddrLO:\n\n            DPRINTF(\"C+ RxRing low bits write val=0x%08x\\n\", val);\n\n            s->RxRingAddrLO = val;\n\n            break;\n\n\n\n        case RxRingAddrHI:\n\n            DPRINTF(\"C+ RxRing high bits write val=0x%08x\\n\", val);\n\n            s->RxRingAddrHI = val;\n\n            break;\n\n\n\n        case Timer:\n\n            DPRINTF(\"TCTR Timer reset on write\\n\");\n\n            s->TCTR_base = qemu_get_clock_ns(vm_clock);\n\n            rtl8139_set_next_tctr_time(s, s->TCTR_base);\n\n            break;\n\n\n\n        case FlashReg:\n\n            DPRINTF(\"FlashReg TimerInt write val=0x%08x\\n\", val);\n\n            if (s->TimerInt != val) {\n\n                s->TimerInt = val;\n\n                rtl8139_set_next_tctr_time(s, qemu_get_clock_ns(vm_clock));\n\n            }\n\n            break;\n\n\n\n        default:\n\n            DPRINTF(\"ioport write(l) addr=0x%x val=0x%08x via write(b)\\n\",\n\n                addr, val);\n\n            rtl8139_io_writeb(opaque, addr, val & 0xff);\n\n            rtl8139_io_writeb(opaque, addr + 1, (val >> 8) & 0xff);\n\n            rtl8139_io_writeb(opaque, addr + 2, (val >> 16) & 0xff);\n\n            rtl8139_io_writeb(opaque, addr + 3, (val >> 24) & 0xff);\n\n            break;\n\n    }\n\n}\n", "idx": 22703}
{"project": "qemu", "commit_id": "7faa8075d898ae56d2c533c530569bb25ab86eaf", "target": 1, "func": "static void piix4_update_hotplug(PIIX4PMState *s)\n\n{\n\n    PCIDevice *dev = &s->dev;\n\n    BusState *bus = qdev_get_parent_bus(&dev->qdev);\n\n    DeviceState *qdev, *next;\n\n\n\n    s->pci0_hotplug_enable = ~0;\n\n\n\n    QTAILQ_FOREACH_SAFE(qdev, &bus->children, sibling, next) {\n\n        PCIDevice *pdev = PCI_DEVICE(qdev);\n\n        PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(pdev);\n\n        int slot = PCI_SLOT(pdev->devfn);\n\n\n\n        if (pc->no_hotplug) {\n\n            s->pci0_hotplug_enable &= ~(1 << slot);\n\n        }\n\n    }\n\n}\n", "idx": 22705}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "udp_attach(struct socket *so)\n\n{\n\n  if((so->s = socket(AF_INET,SOCK_DGRAM,0)) != -1) {\n\n    so->so_expire = curtime + SO_EXPIRE;\n\n    insque(so, &so->slirp->udb);\n\n  }\n\n  return(so->s);\n\n}\n", "idx": 22706}
{"project": "qemu", "commit_id": "f3e4ce4af336f2ea306fa0f40ec1a5149864ca8c", "target": 1, "func": "static void stream_set_speed(BlockJob *job, int64_t speed, Error **errp)\n\n{\n\n    StreamBlockJob *s = container_of(job, StreamBlockJob, common);\n\n\n\n    if (speed < 0) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER, \"speed\");\n\n        return;\n\n    }\n\n    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);\n\n}\n", "idx": 22709}
{"project": "qemu", "commit_id": "c43567c12042cf401b039bfc94a5f85e1cc1e796", "target": 1, "func": "__org_qemu_x_Union1 *qmp___org_qemu_x_command(__org_qemu_x_EnumList *a,\n\n                                              __org_qemu_x_StructList *b,\n\n                                              __org_qemu_x_Union2 *c,\n\n                                              __org_qemu_x_Alt *d,\n\n                                              Error **errp)\n\n{\n\n    __org_qemu_x_Union1 *ret = g_new0(__org_qemu_x_Union1, 1);\n\n\n\n    ret->type = ORG_QEMU_X_UNION1_KIND___ORG_QEMU_X_BRANCH;\n\n    ret->u.__org_qemu_x_branch = strdup(\"blah1\");\n\n\n\n\n\n\n\n    return ret;\n", "idx": 22711}
{"project": "qemu", "commit_id": "a134d90f50806597c5da4fd191352fe62d40f71a", "target": 1, "func": "static int64_t realloc_refcount_block(BlockDriverState *bs, int reftable_index,\n\n                                      uint64_t offset)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t new_offset = 0;\n\n    void *refcount_block = NULL;\n\n    int ret;\n\n\n\n    /* allocate new refcount block */\n\n    new_offset = qcow2_alloc_clusters(bs, s->cluster_size);\n\n    if (new_offset < 0) {\n\n        fprintf(stderr, \"Could not allocate new cluster: %s\\n\",\n\n                strerror(-new_offset));\n\n        ret = new_offset;\n\n        goto fail;\n\n    }\n\n\n\n    /* fetch current refcount block content */\n\n    ret = qcow2_cache_get(bs, s->refcount_block_cache, offset, &refcount_block);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"Could not fetch refcount block: %s\\n\", strerror(-ret));\n\n        goto fail;\n\n    }\n\n\n\n    /* new block has not yet been entered into refcount table, therefore it is\n\n     * no refcount block yet (regarding this check) */\n\n    ret = qcow2_pre_write_overlap_check(bs, 0, new_offset, s->cluster_size);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"Could not write refcount block; metadata overlap \"\n\n                \"check failed: %s\\n\", strerror(-ret));\n\n        /* the image will be marked corrupt, so don't even attempt on freeing\n\n         * the cluster */\n\n        new_offset = 0;\n\n        goto fail;\n\n    }\n\n\n\n    /* write to new block */\n\n    ret = bdrv_write(bs->file, new_offset / BDRV_SECTOR_SIZE, refcount_block,\n\n            s->cluster_sectors);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"Could not write refcount block: %s\\n\", strerror(-ret));\n\n        goto fail;\n\n    }\n\n\n\n    /* update refcount table */\n\n    assert(!offset_into_cluster(s, new_offset));\n\n    s->refcount_table[reftable_index] = new_offset;\n\n    ret = write_reftable_entry(bs, reftable_index);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"Could not update refcount table: %s\\n\",\n\n                strerror(-ret));\n\n        goto fail;\n\n    }\n\n\n\nfail:\n\n    if (new_offset && (ret < 0)) {\n\n        qcow2_free_clusters(bs, new_offset, s->cluster_size,\n\n                QCOW2_DISCARD_ALWAYS);\n\n    }\n\n    if (refcount_block) {\n\n        if (ret < 0) {\n\n            qcow2_cache_put(bs, s->refcount_block_cache, &refcount_block);\n\n        } else {\n\n            ret = qcow2_cache_put(bs, s->refcount_block_cache, &refcount_block);\n\n        }\n\n    }\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    return new_offset;\n\n}\n", "idx": 22712}
{"project": "qemu", "commit_id": "b2b012afdd9c03ba8a1619f45301d34f358d367b", "target": 1, "func": "static ssize_t imx_enet_receive(NetClientState *nc, const uint8_t *buf,\n\n                                size_t len)\n\n{\n\n    IMXFECState *s = IMX_FEC(qemu_get_nic_opaque(nc));\n\n    IMXENETBufDesc bd;\n\n    uint32_t flags = 0;\n\n    uint32_t addr;\n\n    uint32_t crc;\n\n    uint32_t buf_addr;\n\n    uint8_t *crc_ptr;\n\n    unsigned int buf_len;\n\n    size_t size = len;\n\n\n\n    FEC_PRINTF(\"len %d\\n\", (int)size);\n\n\n\n    if (!s->regs[ENET_RDAR]) {\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"[%s]%s: Unexpected packet\\n\",\n\n                      TYPE_IMX_FEC, __func__);\n\n        return 0;\n\n    }\n\n\n\n    /* 4 bytes for the CRC.  */\n\n    size += 4;\n\n    crc = cpu_to_be32(crc32(~0, buf, size));\n\n    crc_ptr = (uint8_t *) &crc;\n\n\n\n    /* Huge frames are truncted.  */\n\n    if (size > ENET_MAX_FRAME_SIZE) {\n\n        size = ENET_MAX_FRAME_SIZE;\n\n        flags |= ENET_BD_TR | ENET_BD_LG;\n\n    }\n\n\n\n    /* Frames larger than the user limit just set error flags.  */\n\n    if (size > (s->regs[ENET_RCR] >> 16)) {\n\n        flags |= ENET_BD_LG;\n\n    }\n\n\n\n    addr = s->rx_descriptor;\n\n    while (size > 0) {\n\n        imx_enet_read_bd(&bd, addr);\n\n        if ((bd.flags & ENET_BD_E) == 0) {\n\n            /* No descriptors available.  Bail out.  */\n\n            /*\n\n             * FIXME: This is wrong. We should probably either\n\n             * save the remainder for when more RX buffers are\n\n             * available, or flag an error.\n\n             */\n\n            qemu_log_mask(LOG_GUEST_ERROR, \"[%s]%s: Lost end of frame\\n\",\n\n                          TYPE_IMX_FEC, __func__);\n\n            break;\n\n        }\n\n        buf_len = (size <= s->regs[ENET_MRBR]) ? size : s->regs[ENET_MRBR];\n\n        bd.length = buf_len;\n\n        size -= buf_len;\n\n\n\n        FEC_PRINTF(\"rx_bd 0x%x length %d\\n\", addr, bd.length);\n\n\n\n        /* The last 4 bytes are the CRC.  */\n\n        if (size < 4) {\n\n            buf_len += size - 4;\n\n        }\n\n        buf_addr = bd.data;\n\n        dma_memory_write(&address_space_memory, buf_addr, buf, buf_len);\n\n        buf += buf_len;\n\n        if (size < 4) {\n\n            dma_memory_write(&address_space_memory, buf_addr + buf_len,\n\n                             crc_ptr, 4 - size);\n\n            crc_ptr += 4 - size;\n\n        }\n\n        bd.flags &= ~ENET_BD_E;\n\n        if (size == 0) {\n\n            /* Last buffer in frame.  */\n\n            bd.flags |= flags | ENET_BD_L;\n\n            FEC_PRINTF(\"rx frame flags %04x\\n\", bd.flags);\n\n            if (bd.option & ENET_BD_RX_INT) {\n\n                s->regs[ENET_EIR] |= ENET_INT_RXF;\n\n            }\n\n        } else {\n\n            if (bd.option & ENET_BD_RX_INT) {\n\n                s->regs[ENET_EIR] |= ENET_INT_RXB;\n\n            }\n\n        }\n\n        imx_enet_write_bd(&bd, addr);\n\n        /* Advance to the next descriptor.  */\n\n        if ((bd.flags & ENET_BD_W) != 0) {\n\n            addr = s->regs[ENET_RDSR];\n\n        } else {\n\n            addr += sizeof(bd);\n\n        }\n\n    }\n\n    s->rx_descriptor = addr;\n\n    imx_eth_enable_rx(s);\n\n    imx_eth_update(s);\n\n    return len;\n\n}\n", "idx": 22713}
{"project": "qemu", "commit_id": "0380aef323154205a7d838fb9953423621290d41", "target": 1, "func": "static void test_machine(gconstpointer data)\n\n{\n\n    const char *machine = data;\n\n    char *args;\n\n    QDict *response;\n\n\n\n    args = g_strdup_printf(\"-machine %s\", machine);\n\n    qtest_start(args);\n\n\n\n    test_properties(\"/machine\");\n\n\n\n    response = qmp(\"{ 'execute': 'quit' }\");\n\n    g_assert(qdict_haskey(response, \"return\"));\n\n\n\n    qtest_end();\n\n    g_free(args);\n\n}\n", "idx": 22714}
{"project": "qemu", "commit_id": "e680cfa7e20f5049c475ac94f998a79c9997b48d", "target": 1, "func": "bool qemu_co_queue_next(CoQueue *queue)\n\n{\n\n    struct unlock_bh *unlock_bh;\n\n    Coroutine *next;\n\n\n\n    next = QTAILQ_FIRST(&queue->entries);\n\n    if (next) {\n\n        QTAILQ_REMOVE(&queue->entries, next, co_queue_next);\n\n        QTAILQ_INSERT_TAIL(&unlock_bh_queue, next, co_queue_next);\n\n        trace_qemu_co_queue_next(next);\n\n\n\n        unlock_bh = qemu_malloc(sizeof(*unlock_bh));\n\n        unlock_bh->bh = qemu_bh_new(qemu_co_queue_next_bh, unlock_bh);\n\n        qemu_bh_schedule(unlock_bh->bh);\n\n    }\n\n\n\n    return (next != NULL);\n\n}\n", "idx": 22716}
{"project": "qemu", "commit_id": "9e8e8c48653471fa5fed447e388fdef57d4f6998", "target": 0, "func": "static void virtio_vmstate_change(void *opaque, int running, RunState state)\n\n{\n\n    VirtIODevice *vdev = opaque;\n\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    bool backend_run = running && (vdev->status & VIRTIO_CONFIG_S_DRIVER_OK);\n\n\n\n    if (running) {\n\n        vdev->vm_running = running;\n\n    }\n\n\n\n    if (backend_run) {\n\n        virtio_set_status(vdev, vdev->status);\n\n    }\n\n\n\n    if (k->vmstate_change) {\n\n        k->vmstate_change(qbus->parent, backend_run);\n\n    }\n\n\n\n    if (!backend_run) {\n\n        virtio_set_status(vdev, vdev->status);\n\n    }\n\n\n\n    if (!running) {\n\n        vdev->vm_running = running;\n\n    }\n\n}\n", "idx": 22723}
{"project": "qemu", "commit_id": "32c813e6c2a857b93b897901b7e20281397528a3", "target": 0, "func": "size_t qcrypto_cipher_get_key_len(QCryptoCipherAlgorithm alg)\n\n{\n\n    if (alg >= G_N_ELEMENTS(alg_key_len)) {\n\n        return 0;\n\n    }\n\n    return alg_key_len[alg];\n\n}\n", "idx": 22724}
{"project": "qemu", "commit_id": "b25b387fa5928e516cb2c9e7fde68e958bd7e50a", "target": 0, "func": "static int qcow2_set_key(BlockDriverState *bs, const char *key)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint8_t keybuf[16];\n\n    int len, i;\n\n    Error *err = NULL;\n\n\n\n    memset(keybuf, 0, 16);\n\n    len = strlen(key);\n\n    if (len > 16)\n\n        len = 16;\n\n    /* XXX: we could compress the chars to 7 bits to increase\n\n       entropy */\n\n    for(i = 0;i < len;i++) {\n\n        keybuf[i] = key[i];\n\n    }\n\n    assert(bs->encrypted);\n\n\n\n    qcrypto_cipher_free(s->cipher);\n\n    s->cipher = qcrypto_cipher_new(\n\n        QCRYPTO_CIPHER_ALG_AES_128,\n\n        QCRYPTO_CIPHER_MODE_CBC,\n\n        keybuf, G_N_ELEMENTS(keybuf),\n\n        &err);\n\n\n\n    if (!s->cipher) {\n\n        /* XXX would be nice if errors in this method could\n\n         * be properly propagate to the caller. Would need\n\n         * the bdrv_set_key() API signature to be fixed. */\n\n        error_free(err);\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 22725}
{"project": "qemu", "commit_id": "405ee3ad573c35790500048d07d5c7ac93167e6a", "target": 0, "func": "void helper_set_cp15(CPUState *env, uint32_t insn, uint32_t val)\n\n{\n\n    uint32_t op2;\n\n    uint32_t crm;\n\n\n\n    op2 = (insn >> 5) & 7;\n\n    crm = insn & 0xf;\n\n    switch ((insn >> 16) & 0xf) {\n\n    case 0: /* ID codes.  */\n\n        if (arm_feature(env, ARM_FEATURE_XSCALE))\n\n            break;\n\n        if (arm_feature(env, ARM_FEATURE_OMAPCP))\n\n            break;\n\n        goto bad_reg;\n\n    case 1: /* System configuration.  */\n\n        if (arm_feature(env, ARM_FEATURE_OMAPCP))\n\n            op2 = 0;\n\n        switch (op2) {\n\n        case 0:\n\n            if (!arm_feature(env, ARM_FEATURE_XSCALE) || crm == 0)\n\n                env->cp15.c1_sys = val;\n\n            /* ??? Lots of these bits are not implemented.  */\n\n            /* This may enable/disable the MMU, so do a TLB flush.  */\n\n            tlb_flush(env, 1);\n\n            break;\n\n        case 1:\n\n            if (arm_feature(env, ARM_FEATURE_XSCALE)) {\n\n                env->cp15.c1_xscaleauxcr = val;\n\n                break;\n\n            }\n\n            goto bad_reg;\n\n        case 2:\n\n            if (arm_feature(env, ARM_FEATURE_XSCALE))\n\n                goto bad_reg;\n\n            env->cp15.c1_coproc = val;\n\n            /* ??? Is this safe when called from within a TB?  */\n\n            tb_flush(env);\n\n            break;\n\n        default:\n\n            goto bad_reg;\n\n        }\n\n        break;\n\n    case 2: /* MMU Page table control / MPU cache control.  */\n\n        if (arm_feature(env, ARM_FEATURE_MPU)) {\n\n            switch (op2) {\n\n            case 0:\n\n                env->cp15.c2_data = val;\n\n                break;\n\n            case 1:\n\n                env->cp15.c2_insn = val;\n\n                break;\n\n            default:\n\n                goto bad_reg;\n\n            }\n\n        } else {\n\n            env->cp15.c2_base = val;\n\n        }\n\n        break;\n\n    case 3: /* MMU Domain access control / MPU write buffer control.  */\n\n        env->cp15.c3 = val;\n\n        break;\n\n    case 4: /* Reserved.  */\n\n        goto bad_reg;\n\n    case 5: /* MMU Fault status / MPU access permission.  */\n\n        if (arm_feature(env, ARM_FEATURE_OMAPCP))\n\n            op2 = 0;\n\n        switch (op2) {\n\n        case 0:\n\n            if (arm_feature(env, ARM_FEATURE_MPU))\n\n                val = extended_mpu_ap_bits(val);\n\n            env->cp15.c5_data = val;\n\n            break;\n\n        case 1:\n\n            if (arm_feature(env, ARM_FEATURE_MPU))\n\n                val = extended_mpu_ap_bits(val);\n\n            env->cp15.c5_insn = val;\n\n            break;\n\n        case 2:\n\n            if (!arm_feature(env, ARM_FEATURE_MPU))\n\n                goto bad_reg;\n\n            env->cp15.c5_data = val;\n\n            break;\n\n        case 3:\n\n            if (!arm_feature(env, ARM_FEATURE_MPU))\n\n                goto bad_reg;\n\n            env->cp15.c5_insn = val;\n\n            break;\n\n        default:\n\n            goto bad_reg;\n\n        }\n\n        break;\n\n    case 6: /* MMU Fault address / MPU base/size.  */\n\n        if (arm_feature(env, ARM_FEATURE_MPU)) {\n\n            if (crm >= 8)\n\n                goto bad_reg;\n\n            env->cp15.c6_region[crm] = val;\n\n        } else {\n\n            if (arm_feature(env, ARM_FEATURE_OMAPCP))\n\n                op2 = 0;\n\n            switch (op2) {\n\n            case 0:\n\n                env->cp15.c6_data = val;\n\n                break;\n\n            case 1:\n\n                env->cp15.c6_insn = val;\n\n                break;\n\n            default:\n\n                goto bad_reg;\n\n            }\n\n        }\n\n        break;\n\n    case 7: /* Cache control.  */\n\n        env->cp15.c15_i_max = 0x000;\n\n        env->cp15.c15_i_min = 0xff0;\n\n        /* No cache, so nothing to do.  */\n\n        break;\n\n    case 8: /* MMU TLB control.  */\n\n        switch (op2) {\n\n        case 0: /* Invalidate all.  */\n\n            tlb_flush(env, 0);\n\n            break;\n\n        case 1: /* Invalidate single TLB entry.  */\n\n#if 0\n\n            /* ??? This is wrong for large pages and sections.  */\n\n            /* As an ugly hack to make linux work we always flush a 4K\n\n               pages.  */\n\n            val &= 0xfffff000;\n\n            tlb_flush_page(env, val);\n\n            tlb_flush_page(env, val + 0x400);\n\n            tlb_flush_page(env, val + 0x800);\n\n            tlb_flush_page(env, val + 0xc00);\n\n#else\n\n            tlb_flush(env, 1);\n\n#endif\n\n            break;\n\n        default:\n\n            goto bad_reg;\n\n        }\n\n        break;\n\n    case 9:\n\n        if (arm_feature(env, ARM_FEATURE_OMAPCP))\n\n            break;\n\n        switch (crm) {\n\n        case 0: /* Cache lockdown.  */\n\n            switch (op2) {\n\n            case 0:\n\n                env->cp15.c9_data = val;\n\n                break;\n\n            case 1:\n\n                env->cp15.c9_insn = val;\n\n                break;\n\n            default:\n\n                goto bad_reg;\n\n            }\n\n            break;\n\n        case 1: /* TCM memory region registers.  */\n\n            /* Not implemented.  */\n\n            goto bad_reg;\n\n        default:\n\n            goto bad_reg;\n\n        }\n\n        break;\n\n    case 10: /* MMU TLB lockdown.  */\n\n        /* ??? TLB lockdown not implemented.  */\n\n        break;\n\n    case 12: /* Reserved.  */\n\n        goto bad_reg;\n\n    case 13: /* Process ID.  */\n\n        switch (op2) {\n\n        case 0:\n\n            if (!arm_feature(env, ARM_FEATURE_MPU))\n\n                goto bad_reg;\n\n            /* Unlike real hardware the qemu TLB uses virtual addresses,\n\n               not modified virtual addresses, so this causes a TLB flush.\n\n             */\n\n            if (env->cp15.c13_fcse != val)\n\n              tlb_flush(env, 1);\n\n            env->cp15.c13_fcse = val;\n\n            break;\n\n        case 1:\n\n            /* This changes the ASID, so do a TLB flush.  */\n\n            if (env->cp15.c13_context != val\n\n                && !arm_feature(env, ARM_FEATURE_MPU))\n\n              tlb_flush(env, 0);\n\n            env->cp15.c13_context = val;\n\n            break;\n\n        default:\n\n            goto bad_reg;\n\n        }\n\n        break;\n\n    case 14: /* Reserved.  */\n\n        goto bad_reg;\n\n    case 15: /* Implementation specific.  */\n\n        if (arm_feature(env, ARM_FEATURE_XSCALE)) {\n\n            if (op2 == 0 && crm == 1) {\n\n                if (env->cp15.c15_cpar != (val & 0x3fff)) {\n\n                    /* Changes cp0 to cp13 behavior, so needs a TB flush.  */\n\n                    tb_flush(env);\n\n                    env->cp15.c15_cpar = val & 0x3fff;\n\n                }\n\n                break;\n\n            }\n\n            goto bad_reg;\n\n        }\n\n        if (arm_feature(env, ARM_FEATURE_OMAPCP)) {\n\n            switch (crm) {\n\n            case 0:\n\n                break;\n\n            case 1: /* Set TI925T configuration.  */\n\n                env->cp15.c15_ticonfig = val & 0xe7;\n\n                env->cp15.c0_cpuid = (val & (1 << 5)) ? /* OS_TYPE bit */\n\n                        ARM_CPUID_TI915T : ARM_CPUID_TI925T;\n\n                break;\n\n            case 2: /* Set I_max.  */\n\n                env->cp15.c15_i_max = val;\n\n                break;\n\n            case 3: /* Set I_min.  */\n\n                env->cp15.c15_i_min = val;\n\n                break;\n\n            case 4: /* Set thread-ID.  */\n\n                env->cp15.c15_threadid = val & 0xffff;\n\n                break;\n\n            case 8: /* Wait-for-interrupt (deprecated).  */\n\n                cpu_interrupt(env, CPU_INTERRUPT_HALT);\n\n                break;\n\n            default:\n\n                goto bad_reg;\n\n            }\n\n        }\n\n        break;\n\n    }\n\n    return;\n\nbad_reg:\n\n    /* ??? For debugging only.  Should raise illegal instruction exception.  */\n\n    cpu_abort(env, \"Unimplemented cp15 register write\\n\");\n\n}\n", "idx": 22726}
{"project": "qemu", "commit_id": "42bb9c9178ae7ac4c439172b1ae99cc29188a5c6", "target": 0, "func": "static size_t stream_process_s2mem(struct Stream *s, unsigned char *buf,\n\n                                   size_t len, uint32_t *app)\n\n{\n\n    uint32_t prev_d;\n\n    unsigned int rxlen;\n\n    size_t pos = 0;\n\n    int sof = 1;\n\n\n\n    if (!stream_running(s) || stream_idle(s)) {\n\n        return 0;\n\n    }\n\n\n\n    while (len) {\n\n        stream_desc_load(s, s->regs[R_CURDESC]);\n\n\n\n        if (s->desc.status & SDESC_STATUS_COMPLETE) {\n\n            s->regs[R_DMASR] |= DMASR_HALTED;\n\n            break;\n\n        }\n\n\n\n        rxlen = s->desc.control & SDESC_CTRL_LEN_MASK;\n\n        if (rxlen > len) {\n\n            /* It fits.  */\n\n            rxlen = len;\n\n        }\n\n\n\n        cpu_physical_memory_write(s->desc.buffer_address, buf + pos, rxlen);\n\n        len -= rxlen;\n\n        pos += rxlen;\n\n\n\n        /* Update the descriptor.  */\n\n        if (!len) {\n\n            int i;\n\n\n\n            stream_complete(s);\n\n            for (i = 0; i < 5; i++) {\n\n                s->desc.app[i] = app[i];\n\n            }\n\n            s->desc.status |= SDESC_STATUS_EOF;\n\n        }\n\n\n\n        s->desc.status |= sof << SDESC_STATUS_SOF_BIT;\n\n        s->desc.status |= SDESC_STATUS_COMPLETE;\n\n        stream_desc_store(s, s->regs[R_CURDESC]);\n\n        sof = 0;\n\n\n\n        /* Advance.  */\n\n        prev_d = s->regs[R_CURDESC];\n\n        s->regs[R_CURDESC] = s->desc.nxtdesc;\n\n        if (prev_d == s->regs[R_TAILDESC]) {\n\n            s->regs[R_DMASR] |= DMASR_IDLE;\n\n            break;\n\n        }\n\n    }\n\n\n\n    return pos;\n\n}\n", "idx": 22727}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_arith(DisasContext *ctx, uint32_t opc,\n\n                      int rd, int rs, int rt)\n\n{\n\n    const char *opn = \"arith\";\n\n\n\n    if (rd == 0 && opc != OPC_ADD && opc != OPC_SUB\n\n       && opc != OPC_DADD && opc != OPC_DSUB) {\n\n        /* If no destination, treat it as a NOP.\n\n           For add & sub, we must generate the overflow exception when needed. */\n\n        MIPS_DEBUG(\"NOP\");\n\n        return;\n\n    }\n\n\n\n    switch (opc) {\n\n    case OPC_ADD:\n\n        {\n\n            TCGv t0 = tcg_temp_local_new();\n\n            TCGv t1 = tcg_temp_new();\n\n            TCGv t2 = tcg_temp_new();\n\n            int l1 = gen_new_label();\n\n\n\n            gen_load_gpr(t1, rs);\n\n            gen_load_gpr(t2, rt);\n\n            tcg_gen_add_tl(t0, t1, t2);\n\n            tcg_gen_ext32s_tl(t0, t0);\n\n            tcg_gen_xor_tl(t1, t1, t2);\n\n            tcg_gen_xor_tl(t2, t0, t2);\n\n            tcg_gen_andc_tl(t1, t2, t1);\n\n            tcg_temp_free(t2);\n\n            tcg_gen_brcondi_tl(TCG_COND_GE, t1, 0, l1);\n\n            tcg_temp_free(t1);\n\n            /* operands of same sign, result different sign */\n\n            generate_exception(ctx, EXCP_OVERFLOW);\n\n            gen_set_label(l1);\n\n            gen_store_gpr(t0, rd);\n\n            tcg_temp_free(t0);\n\n        }\n\n        opn = \"add\";\n\n        break;\n\n    case OPC_ADDU:\n\n        if (rs != 0 && rt != 0) {\n\n            tcg_gen_add_tl(cpu_gpr[rd], cpu_gpr[rs], cpu_gpr[rt]);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n        } else if (rs == 0 && rt != 0) {\n\n            tcg_gen_mov_tl(cpu_gpr[rd], cpu_gpr[rt]);\n\n        } else if (rs != 0 && rt == 0) {\n\n            tcg_gen_mov_tl(cpu_gpr[rd], cpu_gpr[rs]);\n\n        } else {\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n        }\n\n        opn = \"addu\";\n\n        break;\n\n    case OPC_SUB:\n\n        {\n\n            TCGv t0 = tcg_temp_local_new();\n\n            TCGv t1 = tcg_temp_new();\n\n            TCGv t2 = tcg_temp_new();\n\n            int l1 = gen_new_label();\n\n\n\n            gen_load_gpr(t1, rs);\n\n            gen_load_gpr(t2, rt);\n\n            tcg_gen_sub_tl(t0, t1, t2);\n\n            tcg_gen_ext32s_tl(t0, t0);\n\n            tcg_gen_xor_tl(t2, t1, t2);\n\n            tcg_gen_xor_tl(t1, t0, t1);\n\n            tcg_gen_and_tl(t1, t1, t2);\n\n            tcg_temp_free(t2);\n\n            tcg_gen_brcondi_tl(TCG_COND_GE, t1, 0, l1);\n\n            tcg_temp_free(t1);\n\n            /* operands of different sign, first operand and result different sign */\n\n            generate_exception(ctx, EXCP_OVERFLOW);\n\n            gen_set_label(l1);\n\n            gen_store_gpr(t0, rd);\n\n            tcg_temp_free(t0);\n\n        }\n\n        opn = \"sub\";\n\n        break;\n\n    case OPC_SUBU:\n\n        if (rs != 0 && rt != 0) {\n\n            tcg_gen_sub_tl(cpu_gpr[rd], cpu_gpr[rs], cpu_gpr[rt]);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n        } else if (rs == 0 && rt != 0) {\n\n            tcg_gen_neg_tl(cpu_gpr[rd], cpu_gpr[rt]);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n        } else if (rs != 0 && rt == 0) {\n\n            tcg_gen_mov_tl(cpu_gpr[rd], cpu_gpr[rs]);\n\n        } else {\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n        }\n\n        opn = \"subu\";\n\n        break;\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_DADD:\n\n        {\n\n            TCGv t0 = tcg_temp_local_new();\n\n            TCGv t1 = tcg_temp_new();\n\n            TCGv t2 = tcg_temp_new();\n\n            int l1 = gen_new_label();\n\n\n\n            gen_load_gpr(t1, rs);\n\n            gen_load_gpr(t2, rt);\n\n            tcg_gen_add_tl(t0, t1, t2);\n\n            tcg_gen_xor_tl(t1, t1, t2);\n\n            tcg_gen_xor_tl(t2, t0, t2);\n\n            tcg_gen_andc_tl(t1, t2, t1);\n\n            tcg_temp_free(t2);\n\n            tcg_gen_brcondi_tl(TCG_COND_GE, t1, 0, l1);\n\n            tcg_temp_free(t1);\n\n            /* operands of same sign, result different sign */\n\n            generate_exception(ctx, EXCP_OVERFLOW);\n\n            gen_set_label(l1);\n\n            gen_store_gpr(t0, rd);\n\n            tcg_temp_free(t0);\n\n        }\n\n        opn = \"dadd\";\n\n        break;\n\n    case OPC_DADDU:\n\n        if (rs != 0 && rt != 0) {\n\n            tcg_gen_add_tl(cpu_gpr[rd], cpu_gpr[rs], cpu_gpr[rt]);\n\n        } else if (rs == 0 && rt != 0) {\n\n            tcg_gen_mov_tl(cpu_gpr[rd], cpu_gpr[rt]);\n\n        } else if (rs != 0 && rt == 0) {\n\n            tcg_gen_mov_tl(cpu_gpr[rd], cpu_gpr[rs]);\n\n        } else {\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n        }\n\n        opn = \"daddu\";\n\n        break;\n\n    case OPC_DSUB:\n\n        {\n\n            TCGv t0 = tcg_temp_local_new();\n\n            TCGv t1 = tcg_temp_new();\n\n            TCGv t2 = tcg_temp_new();\n\n            int l1 = gen_new_label();\n\n\n\n            gen_load_gpr(t1, rs);\n\n            gen_load_gpr(t2, rt);\n\n            tcg_gen_sub_tl(t0, t1, t2);\n\n            tcg_gen_xor_tl(t2, t1, t2);\n\n            tcg_gen_xor_tl(t1, t0, t1);\n\n            tcg_gen_and_tl(t1, t1, t2);\n\n            tcg_temp_free(t2);\n\n            tcg_gen_brcondi_tl(TCG_COND_GE, t1, 0, l1);\n\n            tcg_temp_free(t1);\n\n            /* operands of different sign, first operand and result different sign */\n\n            generate_exception(ctx, EXCP_OVERFLOW);\n\n            gen_set_label(l1);\n\n            gen_store_gpr(t0, rd);\n\n            tcg_temp_free(t0);\n\n        }\n\n        opn = \"dsub\";\n\n        break;\n\n    case OPC_DSUBU:\n\n        if (rs != 0 && rt != 0) {\n\n            tcg_gen_sub_tl(cpu_gpr[rd], cpu_gpr[rs], cpu_gpr[rt]);\n\n        } else if (rs == 0 && rt != 0) {\n\n            tcg_gen_neg_tl(cpu_gpr[rd], cpu_gpr[rt]);\n\n        } else if (rs != 0 && rt == 0) {\n\n            tcg_gen_mov_tl(cpu_gpr[rd], cpu_gpr[rs]);\n\n        } else {\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n        }\n\n        opn = \"dsubu\";\n\n        break;\n\n#endif\n\n    case OPC_MUL:\n\n        if (likely(rs != 0 && rt != 0)) {\n\n            tcg_gen_mul_tl(cpu_gpr[rd], cpu_gpr[rs], cpu_gpr[rt]);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n        } else {\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n        }\n\n        opn = \"mul\";\n\n        break;\n\n    }\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s %s, %s, %s\", opn, regnames[rd], regnames[rs], regnames[rt]);\n\n}\n", "idx": 22728}
{"project": "qemu", "commit_id": "de9e9d9f17a36ff76c1a02a5348835e5e0a081b0", "target": 0, "func": "static inline void gen_op_eval_fbl(TCGv dst, TCGv src,\n\n                                    unsigned int fcc_offset)\n\n{\n\n    gen_mov_reg_FCC0(dst, src, fcc_offset);\n\n    gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);\n\n    tcg_gen_xori_tl(cpu_tmp0, cpu_tmp0, 0x1);\n\n    tcg_gen_and_tl(dst, dst, cpu_tmp0);\n\n}\n", "idx": 22729}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void qemu_clock_register_reset_notifier(QEMUClockType type,\n\n                                        Notifier *notifier)\n\n{\n\n    QEMUClock *clock = qemu_clock_ptr(type);\n\n    notifier_list_add(&clock->reset_notifiers, notifier);\n\n}\n", "idx": 22730}
{"project": "qemu", "commit_id": "ee13ed1cbc5f7f848e417f587c93ca1f36d83eb0", "target": 0, "func": "DriveInfo *drive_init(QemuOpts *all_opts, BlockInterfaceType block_default_type)\n\n{\n\n    const char *value;\n\n    DriveInfo *dinfo = NULL;\n\n    QDict *bs_opts;\n\n    QemuOpts *legacy_opts;\n\n    DriveMediaType media = MEDIA_DISK;\n\n    BlockInterfaceType type;\n\n    int cyls, heads, secs, translation;\n\n    int max_devs, bus_id, unit_id, index;\n\n    const char *devaddr;\n\n    bool read_only = false;\n\n    bool copy_on_read;\n\n    const char *filename;\n\n    Error *local_err = NULL;\n\n\n\n    /* Change legacy command line options into QMP ones */\n\n    qemu_opt_rename(all_opts, \"iops\", \"throttling.iops-total\");\n\n    qemu_opt_rename(all_opts, \"iops_rd\", \"throttling.iops-read\");\n\n    qemu_opt_rename(all_opts, \"iops_wr\", \"throttling.iops-write\");\n\n\n\n    qemu_opt_rename(all_opts, \"bps\", \"throttling.bps-total\");\n\n    qemu_opt_rename(all_opts, \"bps_rd\", \"throttling.bps-read\");\n\n    qemu_opt_rename(all_opts, \"bps_wr\", \"throttling.bps-write\");\n\n\n\n    qemu_opt_rename(all_opts, \"iops_max\", \"throttling.iops-total-max\");\n\n    qemu_opt_rename(all_opts, \"iops_rd_max\", \"throttling.iops-read-max\");\n\n    qemu_opt_rename(all_opts, \"iops_wr_max\", \"throttling.iops-write-max\");\n\n\n\n    qemu_opt_rename(all_opts, \"bps_max\", \"throttling.bps-total-max\");\n\n    qemu_opt_rename(all_opts, \"bps_rd_max\", \"throttling.bps-read-max\");\n\n    qemu_opt_rename(all_opts, \"bps_wr_max\", \"throttling.bps-write-max\");\n\n\n\n    qemu_opt_rename(all_opts,\n\n                    \"iops_size\", \"throttling.iops-size\");\n\n\n\n    qemu_opt_rename(all_opts, \"readonly\", \"read-only\");\n\n\n\n    value = qemu_opt_get(all_opts, \"cache\");\n\n    if (value) {\n\n        int flags = 0;\n\n\n\n        if (bdrv_parse_cache_flags(value, &flags) != 0) {\n\n            error_report(\"invalid cache option\");\n\n            return NULL;\n\n        }\n\n\n\n        /* Specific options take precedence */\n\n        if (!qemu_opt_get(all_opts, \"cache.writeback\")) {\n\n            qemu_opt_set_bool(all_opts, \"cache.writeback\",\n\n                              !!(flags & BDRV_O_CACHE_WB));\n\n        }\n\n        if (!qemu_opt_get(all_opts, \"cache.direct\")) {\n\n            qemu_opt_set_bool(all_opts, \"cache.direct\",\n\n                              !!(flags & BDRV_O_NOCACHE));\n\n        }\n\n        if (!qemu_opt_get(all_opts, \"cache.no-flush\")) {\n\n            qemu_opt_set_bool(all_opts, \"cache.no-flush\",\n\n                              !!(flags & BDRV_O_NO_FLUSH));\n\n        }\n\n        qemu_opt_unset(all_opts, \"cache\");\n\n    }\n\n\n\n    /* Get a QDict for processing the options */\n\n    bs_opts = qdict_new();\n\n    qemu_opts_to_qdict(all_opts, bs_opts);\n\n\n\n    legacy_opts = qemu_opts_create(&qemu_legacy_drive_opts, NULL, 0,\n\n                                   &error_abort);\n\n    qemu_opts_absorb_qdict(legacy_opts, bs_opts, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        goto fail;\n\n    }\n\n\n\n    /* Deprecated option boot=[on|off] */\n\n    if (qemu_opt_get(legacy_opts, \"boot\") != NULL) {\n\n        fprintf(stderr, \"qemu-kvm: boot=on|off is deprecated and will be \"\n\n                \"ignored. Future versions will reject this parameter. Please \"\n\n                \"update your scripts.\\n\");\n\n    }\n\n\n\n    /* Media type */\n\n    value = qemu_opt_get(legacy_opts, \"media\");\n\n    if (value) {\n\n        if (!strcmp(value, \"disk\")) {\n\n            media = MEDIA_DISK;\n\n        } else if (!strcmp(value, \"cdrom\")) {\n\n            media = MEDIA_CDROM;\n\n            read_only = true;\n\n        } else {\n\n            error_report(\"'%s' invalid media\", value);\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    /* copy-on-read is disabled with a warning for read-only devices */\n\n    read_only |= qemu_opt_get_bool(legacy_opts, \"read-only\", false);\n\n    copy_on_read = qemu_opt_get_bool(legacy_opts, \"copy-on-read\", false);\n\n\n\n    if (read_only && copy_on_read) {\n\n        error_report(\"warning: disabling copy-on-read on read-only drive\");\n\n        copy_on_read = false;\n\n    }\n\n\n\n    qdict_put(bs_opts, \"read-only\",\n\n              qstring_from_str(read_only ? \"on\" : \"off\"));\n\n    qdict_put(bs_opts, \"copy-on-read\",\n\n              qstring_from_str(copy_on_read ? \"on\" :\"off\"));\n\n\n\n    /* Controller type */\n\n    value = qemu_opt_get(legacy_opts, \"if\");\n\n    if (value) {\n\n        for (type = 0;\n\n             type < IF_COUNT && strcmp(value, if_name[type]);\n\n             type++) {\n\n        }\n\n        if (type == IF_COUNT) {\n\n            error_report(\"unsupported bus type '%s'\", value);\n\n            goto fail;\n\n        }\n\n    } else {\n\n        type = block_default_type;\n\n    }\n\n\n\n    /* Geometry */\n\n    cyls  = qemu_opt_get_number(legacy_opts, \"cyls\", 0);\n\n    heads = qemu_opt_get_number(legacy_opts, \"heads\", 0);\n\n    secs  = qemu_opt_get_number(legacy_opts, \"secs\", 0);\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1) {\n\n            error_report(\"invalid physical cyls number\");\n\n            goto fail;\n\n        }\n\n        if (heads < 1) {\n\n            error_report(\"invalid physical heads number\");\n\n            goto fail;\n\n        }\n\n        if (secs < 1) {\n\n            error_report(\"invalid physical secs number\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    value = qemu_opt_get(legacy_opts, \"trans\");\n\n    if (value != NULL) {\n\n        if (!cyls) {\n\n            error_report(\"'%s' trans must be used with cyls, heads and secs\",\n\n                         value);\n\n            goto fail;\n\n        }\n\n        if (!strcmp(value, \"none\")) {\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        } else if (!strcmp(value, \"lba\")) {\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        } else if (!strcmp(value, \"auto\")) {\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n        } else {\n\n            error_report(\"'%s' invalid translation type\", value);\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    if (media == MEDIA_CDROM) {\n\n        if (cyls || secs || heads) {\n\n            error_report(\"CHS can't be set with media=cdrom\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    /* Device address specified by bus/unit or index.\n\n     * If none was specified, try to find the first free one. */\n\n    bus_id  = qemu_opt_get_number(legacy_opts, \"bus\", 0);\n\n    unit_id = qemu_opt_get_number(legacy_opts, \"unit\", -1);\n\n    index   = qemu_opt_get_number(legacy_opts, \"index\", -1);\n\n\n\n    max_devs = if_max_devs[type];\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            error_report(\"index cannot be used with bus and unit\");\n\n            goto fail;\n\n        }\n\n        bus_id = drive_index_to_bus_id(type, index);\n\n        unit_id = drive_index_to_unit_id(type, index);\n\n    }\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get(type, bus_id, unit_id) != NULL) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        error_report(\"unit %d too big (max is %d)\", unit_id, max_devs - 1);\n\n        goto fail;\n\n    }\n\n\n\n    if (drive_get(type, bus_id, unit_id) != NULL) {\n\n        error_report(\"drive with bus=%d, unit=%d (index=%d) exists\",\n\n                     bus_id, unit_id, index);\n\n        goto fail;\n\n    }\n\n\n\n    /* no id supplied -> create one */\n\n    if (qemu_opts_id(all_opts) == NULL) {\n\n        char *new_id;\n\n        const char *mediastr = \"\";\n\n        if (type == IF_IDE || type == IF_SCSI) {\n\n            mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n        }\n\n        if (max_devs) {\n\n            new_id = g_strdup_printf(\"%s%i%s%i\", if_name[type], bus_id,\n\n                                     mediastr, unit_id);\n\n        } else {\n\n            new_id = g_strdup_printf(\"%s%s%i\", if_name[type],\n\n                                     mediastr, unit_id);\n\n        }\n\n        qdict_put(bs_opts, \"id\", qstring_from_str(new_id));\n\n        g_free(new_id);\n\n    }\n\n\n\n    /* Add virtio block device */\n\n    devaddr = qemu_opt_get(legacy_opts, \"addr\");\n\n    if (devaddr && type != IF_VIRTIO) {\n\n        error_report(\"addr is not supported by this bus type\");\n\n        goto fail;\n\n    }\n\n\n\n    if (type == IF_VIRTIO) {\n\n        QemuOpts *devopts;\n\n        devopts = qemu_opts_create(qemu_find_opts(\"device\"), NULL, 0,\n\n                                   &error_abort);\n\n        if (arch_type == QEMU_ARCH_S390X) {\n\n            qemu_opt_set(devopts, \"driver\", \"virtio-blk-s390\");\n\n        } else {\n\n            qemu_opt_set(devopts, \"driver\", \"virtio-blk-pci\");\n\n        }\n\n        qemu_opt_set(devopts, \"drive\", qdict_get_str(bs_opts, \"id\"));\n\n        if (devaddr) {\n\n            qemu_opt_set(devopts, \"addr\", devaddr);\n\n        }\n\n    }\n\n\n\n    filename = qemu_opt_get(legacy_opts, \"file\");\n\n\n\n    /* Actual block device init: Functionality shared with blockdev-add */\n\n    dinfo = blockdev_init(filename, bs_opts, type, &local_err);\n\n    if (dinfo == NULL) {\n\n        if (error_is_set(&local_err)) {\n\n            qerror_report_err(local_err);\n\n            error_free(local_err);\n\n        }\n\n        goto fail;\n\n    } else {\n\n        assert(!error_is_set(&local_err));\n\n    }\n\n\n\n    /* Set legacy DriveInfo fields */\n\n    dinfo->enable_auto_del = true;\n\n    dinfo->opts = all_opts;\n\n\n\n    dinfo->cyls = cyls;\n\n    dinfo->heads = heads;\n\n    dinfo->secs = secs;\n\n    dinfo->trans = translation;\n\n\n\n    dinfo->bus = bus_id;\n\n    dinfo->unit = unit_id;\n\n    dinfo->devaddr = devaddr;\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n    case IF_NONE:\n\n        dinfo->media_cd = media == MEDIA_CDROM;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\nfail:\n\n    qemu_opts_del(legacy_opts);\n\n    return dinfo;\n\n}\n", "idx": 22731}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int cd_read_sector(IDEState *s, int lba, uint8_t *buf, int sector_size)\n\n{\n\n    int ret;\n\n\n\n    switch(sector_size) {\n\n    case 2048:\n\n        block_acct_start(bdrv_get_stats(s->bs), &s->acct,\n\n                         4 * BDRV_SECTOR_SIZE, BLOCK_ACCT_READ);\n\n        ret = bdrv_read(s->bs, (int64_t)lba << 2, buf, 4);\n\n        block_acct_done(bdrv_get_stats(s->bs), &s->acct);\n\n        break;\n\n    case 2352:\n\n        block_acct_start(bdrv_get_stats(s->bs), &s->acct,\n\n                         4 * BDRV_SECTOR_SIZE, BLOCK_ACCT_READ);\n\n        ret = bdrv_read(s->bs, (int64_t)lba << 2, buf + 16, 4);\n\n        block_acct_done(bdrv_get_stats(s->bs), &s->acct);\n\n        if (ret < 0)\n\n            return ret;\n\n        cd_data_to_raw(buf, lba);\n\n        break;\n\n    default:\n\n        ret = -EIO;\n\n        break;\n\n    }\n\n    return ret;\n\n}\n", "idx": 22732}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "e1000_can_receive(void *opaque)\n\n{\n\n    E1000State *s = opaque;\n\n\n\n    return (s->mac_reg[RCTL] & E1000_RCTL_EN);\n\n}\n", "idx": 22734}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t intel_hda_mmio_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    IntelHDAState *d = opaque;\n\n    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);\n\n\n\n    return intel_hda_reg_read(d, reg, 0xffffffff);\n\n}\n", "idx": 22735}
{"project": "qemu", "commit_id": "260fecf13b0d30621dc88da03dc1b502b7358c6b", "target": 0, "func": "void bdrv_set_backing_hd(BlockDriverState *bs, BlockDriverState *backing_hd)\n\n{\n\n    if (backing_hd) {\n\n        bdrv_ref(backing_hd);\n\n    }\n\n\n\n    if (bs->backing) {\n\n        assert(bs->backing_blocker);\n\n        bdrv_op_unblock_all(bs->backing->bs, bs->backing_blocker);\n\n        bdrv_unref_child(bs, bs->backing);\n\n    } else if (backing_hd) {\n\n        error_setg(&bs->backing_blocker,\n\n                   \"node is used as backing hd of '%s'\",\n\n                   bdrv_get_device_or_node_name(bs));\n\n    }\n\n\n\n    if (!backing_hd) {\n\n        error_free(bs->backing_blocker);\n\n        bs->backing_blocker = NULL;\n\n        bs->backing = NULL;\n\n        goto out;\n\n    }\n\n    bs->backing = bdrv_attach_child(bs, backing_hd, &child_backing);\n\n    bs->open_flags &= ~BDRV_O_NO_BACKING;\n\n    pstrcpy(bs->backing_file, sizeof(bs->backing_file), backing_hd->filename);\n\n    pstrcpy(bs->backing_format, sizeof(bs->backing_format),\n\n            backing_hd->drv ? backing_hd->drv->format_name : \"\");\n\n\n\n    bdrv_op_block_all(backing_hd, bs->backing_blocker);\n\n    /* Otherwise we won't be able to commit due to check in bdrv_commit */\n\n    bdrv_op_unblock(backing_hd, BLOCK_OP_TYPE_COMMIT_TARGET,\n\n                    bs->backing_blocker);\n\nout:\n\n    bdrv_refresh_limits(bs, NULL);\n\n}\n", "idx": 22736}
{"project": "qemu", "commit_id": "02d213009d571bcd7171e3ff9234722a11d30d1b", "target": 0, "func": "void bdrv_parent_drained_end(BlockDriverState *bs)\n\n{\n\n    BdrvChild *c;\n\n\n\n    QLIST_FOREACH(c, &bs->parents, next_parent) {\n\n        if (c->role->drained_end) {\n\n            c->role->drained_end(c);\n\n        }\n\n    }\n\n}\n", "idx": 22737}
{"project": "qemu", "commit_id": "aa8f057e74ae08014736a690ff41f76c756f75f1", "target": 0, "func": "static void virtio_ccw_crypto_instance_init(Object *obj)\n\n{\n\n    VirtIOCryptoCcw *dev = VIRTIO_CRYPTO_CCW(obj);\n\n    VirtioCcwDevice *ccw_dev = VIRTIO_CCW_DEVICE(obj);\n\n\n\n    ccw_dev->force_revision_1 = true;\n\n    virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),\n\n                                TYPE_VIRTIO_CRYPTO);\n\n\n\n    object_property_add_alias(obj, \"cryptodev\", OBJECT(&dev->vdev),\n\n                              \"cryptodev\", &error_abort);\n\n}\n", "idx": 22738}
{"project": "qemu", "commit_id": "dc523cd348c47372faa7271c9aab2030f94c290d", "target": 0, "func": "static int img_amend(int argc, char **argv)\n\n{\n\n    int c, ret = 0;\n\n    char *options = NULL;\n\n    QemuOptsList *create_opts = NULL;\n\n    QemuOpts *opts = NULL;\n\n    const char *fmt = NULL, *filename, *cache;\n\n    int flags;\n\n    bool quiet = false, progress = false;\n\n    BlockBackend *blk = NULL;\n\n    BlockDriverState *bs = NULL;\n\n\n\n    cache = BDRV_DEFAULT_CACHE;\n\n    for (;;) {\n\n        c = getopt(argc, argv, \"ho:f:t:pq\");\n\n        if (c == -1) {\n\n            break;\n\n        }\n\n\n\n        switch (c) {\n\n            case 'h':\n\n            case '?':\n\n                help();\n\n                break;\n\n            case 'o':\n\n                if (!is_valid_option_list(optarg)) {\n\n                    error_report(\"Invalid option list: %s\", optarg);\n\n                    ret = -1;\n\n                    goto out;\n\n                }\n\n                if (!options) {\n\n                    options = g_strdup(optarg);\n\n                } else {\n\n                    char *old_options = options;\n\n                    options = g_strdup_printf(\"%s,%s\", options, optarg);\n\n                    g_free(old_options);\n\n                }\n\n                break;\n\n            case 'f':\n\n                fmt = optarg;\n\n                break;\n\n            case 't':\n\n                cache = optarg;\n\n                break;\n\n            case 'p':\n\n                progress = true;\n\n                break;\n\n            case 'q':\n\n                quiet = true;\n\n                break;\n\n        }\n\n    }\n\n\n\n    if (!options) {\n\n        error_exit(\"Must specify options (-o)\");\n\n    }\n\n\n\n    if (quiet) {\n\n        progress = false;\n\n    }\n\n    qemu_progress_init(progress, 1.0);\n\n\n\n    filename = (optind == argc - 1) ? argv[argc - 1] : NULL;\n\n    if (fmt && has_help_option(options)) {\n\n        /* If a format is explicitly specified (and possibly no filename is\n\n         * given), print option help here */\n\n        ret = print_block_option_help(filename, fmt);\n\n        goto out;\n\n    }\n\n\n\n    if (optind != argc - 1) {\n\n        error_report(\"Expecting one image file name\");\n\n        ret = -1;\n\n        goto out;\n\n    }\n\n\n\n    flags = BDRV_O_FLAGS | BDRV_O_RDWR;\n\n    ret = bdrv_parse_cache_flags(cache, &flags);\n\n    if (ret < 0) {\n\n        error_report(\"Invalid cache option: %s\", cache);\n\n        goto out;\n\n    }\n\n\n\n    blk = img_open(\"image\", filename, fmt, flags, true, quiet);\n\n    if (!blk) {\n\n        ret = -1;\n\n        goto out;\n\n    }\n\n    bs = blk_bs(blk);\n\n\n\n    fmt = bs->drv->format_name;\n\n\n\n    if (has_help_option(options)) {\n\n        /* If the format was auto-detected, print option help here */\n\n        ret = print_block_option_help(filename, fmt);\n\n        goto out;\n\n    }\n\n\n\n    if (!bs->drv->create_opts) {\n\n        error_report(\"Format driver '%s' does not support any options to amend\",\n\n                     fmt);\n\n        ret = -1;\n\n        goto out;\n\n    }\n\n\n\n    create_opts = qemu_opts_append(create_opts, bs->drv->create_opts);\n\n    opts = qemu_opts_create(create_opts, NULL, 0, &error_abort);\n\n    if (options && qemu_opts_do_parse(opts, options, NULL)) {\n\n        error_report(\"Invalid options for file format '%s'\", fmt);\n\n        ret = -1;\n\n        goto out;\n\n    }\n\n\n\n    /* In case the driver does not call amend_status_cb() */\n\n    qemu_progress_print(0.f, 0);\n\n    ret = bdrv_amend_options(bs, opts, &amend_status_cb);\n\n    qemu_progress_print(100.f, 0);\n\n    if (ret < 0) {\n\n        error_report(\"Error while amending options: %s\", strerror(-ret));\n\n        goto out;\n\n    }\n\n\n\nout:\n\n    qemu_progress_end();\n\n\n\n    blk_unref(blk);\n\n    qemu_opts_del(opts);\n\n    qemu_opts_free(create_opts);\n\n    g_free(options);\n\n\n\n    if (ret) {\n\n        return 1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 22739}
{"project": "qemu", "commit_id": "4ae4b609ee2d5bcc9df6c03c21dc1fed527aada1", "target": 1, "func": "static void gen_bxx(DisasContext *dc, uint32_t code, uint32_t flags)\n\n{\n\n    I_TYPE(instr, code);\n\n\n\n    TCGLabel *l1 = gen_new_label();\n\n    tcg_gen_brcond_tl(flags, dc->cpu_R[instr.a], dc->cpu_R[instr.b], l1);\n\n    gen_goto_tb(dc, 0, dc->pc + 4);\n\n    gen_set_label(l1);\n\n    gen_goto_tb(dc, 1, dc->pc + 4 + (instr.imm16s & -4));\n\n    dc->is_jmp = DISAS_TB_JUMP;\n\n}\n", "idx": 22740}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "int unix_start_incoming_migration(const char *path)\n\n{\n\n    struct sockaddr_un un;\n\n    int sock;\n\n\n\n    dprintf(\"Attempting to start an incoming migration\\n\");\n\n\n\n    sock = socket(PF_UNIX, SOCK_STREAM, 0);\n\n    if (sock < 0) {\n\n        fprintf(stderr, \"Could not open unix socket: %s\\n\", strerror(errno));\n\n        return -EINVAL;\n\n    }\n\n\n\n    memset(&un, 0, sizeof(un));\n\n    un.sun_family = AF_UNIX;\n\n    snprintf(un.sun_path, sizeof(un.sun_path), \"%s\", path);\n\n\n\n    unlink(un.sun_path);\n\n    if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {\n\n        fprintf(stderr, \"bind(unix:%s): %s\\n\", un.sun_path, strerror(errno));\n\n        goto err;\n\n    }\n\n    if (listen(sock, 1) < 0) {\n\n        fprintf(stderr, \"listen(unix:%s): %s\\n\", un.sun_path, strerror(errno));\n\n        goto err;\n\n    }\n\n\n\n    qemu_set_fd_handler2(sock, NULL, unix_accept_incoming_migration, NULL,\n\n\t\t\t (void *)(unsigned long)sock);\n\n\n\n    return 0;\n\n\n\nerr:\n\n    close(sock);\n\n\n\n    return -EINVAL;\n\n}\n", "idx": 22741}
{"project": "qemu", "commit_id": "22951aaaebb6c4c314c58ad576960a9c57695bbc", "target": 1, "func": "static void print_type_size(Visitor *v, const char *name, uint64_t *obj,\n\n                            Error **errp)\n\n{\n\n    StringOutputVisitor *sov = to_sov(v);\n\n    static const char suffixes[] = { 'B', 'K', 'M', 'G', 'T', 'P', 'E' };\n\n    uint64_t div, val;\n\n    char *out;\n\n    int i;\n\n\n\n    if (!sov->human) {\n\n        out = g_strdup_printf(\"%\"PRIu64, *obj);\n\n        string_output_set(sov, out);\n\n        return;\n\n    }\n\n\n\n    val = *obj;\n\n\n\n    /* The exponent (returned in i) minus one gives us\n\n     * floor(log2(val * 1024 / 1000).  The correction makes us\n\n     * switch to the higher power when the integer part is >= 1000.\n\n     */\n\n    frexp(val / (1000.0 / 1024.0), &i);\n\n    i = (i - 1) / 10;\n\n    assert(i < ARRAY_SIZE(suffixes));\n\n    div = 1ULL << (i * 10);\n\n\n\n    out = g_strdup_printf(\"%\"PRIu64\" (%0.3g %c%s)\", val,\n\n                          (double)val/div, suffixes[i], i ? \"iB\" : \"\");\n\n    string_output_set(sov, out);\n\n}\n", "idx": 22743}
{"project": "qemu", "commit_id": "68716da745858ca86ac587d14ac553051e5f04eb", "target": 1, "func": "static void iommu_config_write(void *opaque, hwaddr addr,\n\n                               uint64_t val, unsigned size)\n\n{\n\n    IOMMUState *is = opaque;\n\n\n\n    IOMMU_DPRINTF(\"IOMMU config write: 0x%\" HWADDR_PRIx \" val: %\" PRIx64\n\n                  \" size: %d\\n\", addr, val, size);\n\n\n\n    switch (addr) {\n\n    case IOMMU_CTRL:\n\n        if (size == 4) {\n\n            is->regs[IOMMU_CTRL >> 3] &= 0xffffffffULL;\n\n            is->regs[IOMMU_CTRL >> 3] |= val << 32;\n\n        } else {\n\n            is->regs[IOMMU_CTRL] = val;\n\n        }\n\n        break;\n\n    case IOMMU_CTRL + 0x4:\n\n        is->regs[IOMMU_CTRL >> 3] &= 0xffffffff00000000ULL;\n\n        is->regs[IOMMU_CTRL >> 3] |= val & 0xffffffffULL;\n\n        break;\n\n    case IOMMU_BASE:\n\n        if (size == 4) {\n\n            is->regs[IOMMU_BASE >> 3] &= 0xffffffffULL;\n\n            is->regs[IOMMU_BASE >> 3] |= val << 32;\n\n        } else {\n\n            is->regs[IOMMU_BASE] = val;\n\n        }\n\n        break;\n\n    case IOMMU_BASE + 0x4:\n\n        is->regs[IOMMU_BASE >> 3] &= 0xffffffff00000000ULL;\n\n        is->regs[IOMMU_BASE >> 3] |= val & 0xffffffffULL;\n\n        break;\n\n    default:\n\n        qemu_log_mask(LOG_UNIMP,\n\n                  \"apb iommu: Unimplemented register write \"\n\n                  \"reg 0x%\" HWADDR_PRIx \" size 0x%x value 0x%\" PRIx64 \"\\n\",\n\n                  addr, size, val);\n\n        break;\n\n    }\n\n}\n", "idx": 22745}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void piix3_ide_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->no_hotplug = 1;\n\n    k->init = pci_piix_ide_initfn;\n\n    k->exit = pci_piix_ide_exitfn;\n\n    k->vendor_id = PCI_VENDOR_ID_INTEL;\n\n    k->device_id = PCI_DEVICE_ID_INTEL_82371SB_1;\n\n    k->class_id = PCI_CLASS_STORAGE_IDE;\n\n    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);\n\n    dc->no_user = 1;\n\n}\n", "idx": 22746}
{"project": "qemu", "commit_id": "7e01376daea75e888c370aab521a7d4aeaf2ffd1", "target": 0, "func": "void ioinst_handle_rsch(S390CPU *cpu, uint64_t reg1)\n\n{\n\n    int cssid, ssid, schid, m;\n\n    SubchDev *sch;\n\n    int ret = -ENODEV;\n\n    int cc;\n\n\n\n    if (ioinst_disassemble_sch_ident(reg1, &m, &cssid, &ssid, &schid)) {\n\n        program_interrupt(&cpu->env, PGM_OPERAND, 2);\n\n        return;\n\n    }\n\n    trace_ioinst_sch_id(\"rsch\", cssid, ssid, schid);\n\n    sch = css_find_subch(m, cssid, ssid, schid);\n\n    if (sch && css_subch_visible(sch)) {\n\n        ret = css_do_rsch(sch);\n\n    }\n\n    switch (ret) {\n\n    case -ENODEV:\n\n        cc = 3;\n\n        break;\n\n    case -EINVAL:\n\n        cc = 2;\n\n        break;\n\n    case 0:\n\n        cc = 0;\n\n        break;\n\n    default:\n\n        cc = 1;\n\n        break;\n\n    }\n\n    setcc(cpu, cc);\n\n}\n", "idx": 22749}
{"project": "qemu", "commit_id": "7a39fe588251ba042c91bf23d53b0ba820bf964c", "target": 0, "func": "int kvm_arch_process_irqchip_events(CPUState *env)\n\n{\n\n    return 0;\n\n}\n", "idx": 22750}
{"project": "qemu", "commit_id": "d9e0dfa2462e32cc5c6c49401ad7bff36453f75c", "target": 0, "func": "void bdrv_refresh_limits(BlockDriverState *bs, Error **errp)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    Error *local_err = NULL;\n\n\n\n    memset(&bs->bl, 0, sizeof(bs->bl));\n\n\n\n    if (!drv) {\n\n        return;\n\n    }\n\n\n\n    /* Default alignment based on whether driver has byte interface */\n\n    bs->request_alignment = drv->bdrv_co_preadv ? 1 : 512;\n\n\n\n    /* Take some limits from the children as a default */\n\n    if (bs->file) {\n\n        bdrv_refresh_limits(bs->file->bs, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n        bs->bl.opt_transfer = bs->file->bs->bl.opt_transfer;\n\n        bs->bl.max_transfer = bs->file->bs->bl.max_transfer;\n\n        bs->bl.min_mem_alignment = bs->file->bs->bl.min_mem_alignment;\n\n        bs->bl.opt_mem_alignment = bs->file->bs->bl.opt_mem_alignment;\n\n        bs->bl.max_iov = bs->file->bs->bl.max_iov;\n\n    } else {\n\n        bs->bl.min_mem_alignment = 512;\n\n        bs->bl.opt_mem_alignment = getpagesize();\n\n\n\n        /* Safe default since most protocols use readv()/writev()/etc */\n\n        bs->bl.max_iov = IOV_MAX;\n\n    }\n\n\n\n    if (bs->backing) {\n\n        bdrv_refresh_limits(bs->backing->bs, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n        bs->bl.opt_transfer = MAX(bs->bl.opt_transfer,\n\n                                  bs->backing->bs->bl.opt_transfer);\n\n        bs->bl.max_transfer = MIN_NON_ZERO(bs->bl.max_transfer,\n\n                                           bs->backing->bs->bl.max_transfer);\n\n        bs->bl.opt_mem_alignment =\n\n            MAX(bs->bl.opt_mem_alignment,\n\n                bs->backing->bs->bl.opt_mem_alignment);\n\n        bs->bl.min_mem_alignment =\n\n            MAX(bs->bl.min_mem_alignment,\n\n                bs->backing->bs->bl.min_mem_alignment);\n\n        bs->bl.max_iov =\n\n            MIN(bs->bl.max_iov,\n\n                bs->backing->bs->bl.max_iov);\n\n    }\n\n\n\n    /* Then let the driver override it */\n\n    if (drv->bdrv_refresh_limits) {\n\n        drv->bdrv_refresh_limits(bs, errp);\n\n    }\n\n}\n", "idx": 22752}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void channel_load_g(struct fs_dma_ctrl *ctrl, int c)\n\n{\n\n\ttarget_phys_addr_t addr = channel_reg(ctrl, c, RW_GROUP);\n\n\n\n\t/* Load and decode. FIXME: handle endianness.  */\n\n\tcpu_physical_memory_read (addr, \n\n\t\t\t\t  (void *) &ctrl->channels[c].current_g, \n\n\t\t\t\t  sizeof ctrl->channels[c].current_g);\n\n}\n", "idx": 22753}
{"project": "qemu", "commit_id": "95129d6fc9ead97155627a4ca0cfd37282883658", "target": 0, "func": "static int vhost_net_set_vnet_endian(VirtIODevice *dev, NetClientState *peer,\n\n                                     bool set)\n\n{\n\n    int r = 0;\n\n\n\n    if (virtio_has_feature(dev, VIRTIO_F_VERSION_1) ||\n\n        (virtio_legacy_is_cross_endian(dev) && !virtio_is_big_endian(dev))) {\n\n        r = qemu_set_vnet_le(peer, set);\n\n        if (r) {\n\n            error_report(\"backend does not support LE vnet headers\");\n\n        }\n\n    } else if (virtio_legacy_is_cross_endian(dev)) {\n\n        r = qemu_set_vnet_be(peer, set);\n\n        if (r) {\n\n            error_report(\"backend does not support BE vnet headers\");\n\n        }\n\n    }\n\n\n\n    return r;\n\n}\n", "idx": 22754}
{"project": "qemu", "commit_id": "9b02e1618cf26aa52cf786f215d757506dda14f8", "target": 0, "func": "static void virtio_net_add_queue(VirtIONet *n, int index)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n\n\n\n    n->vqs[index].rx_vq = virtio_add_queue(vdev, n->net_conf.rx_queue_size,\n\n                                           virtio_net_handle_rx);\n\n    if (n->net_conf.tx && !strcmp(n->net_conf.tx, \"timer\")) {\n\n        n->vqs[index].tx_vq =\n\n            virtio_add_queue(vdev, 256, virtio_net_handle_tx_timer);\n\n        n->vqs[index].tx_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n\n                                              virtio_net_tx_timer,\n\n                                              &n->vqs[index]);\n\n    } else {\n\n        n->vqs[index].tx_vq =\n\n            virtio_add_queue(vdev, 256, virtio_net_handle_tx_bh);\n\n        n->vqs[index].tx_bh = qemu_bh_new(virtio_net_tx_bh, &n->vqs[index]);\n\n    }\n\n\n\n    n->vqs[index].tx_waiting = 0;\n\n    n->vqs[index].n = n;\n\n}\n", "idx": 22755}
{"project": "qemu", "commit_id": "e1f7b4812eab992de46c98b3726745afb042a7f0", "target": 0, "func": "int virtqueue_avail_bytes(VirtQueue *vq, unsigned int in_bytes,\n\n                          unsigned int out_bytes)\n\n{\n\n    unsigned int in_total, out_total;\n\n\n\n    virtqueue_get_avail_bytes(vq, &in_total, &out_total);\n\n    if ((in_bytes && in_bytes < in_total)\n\n        || (out_bytes && out_bytes < out_total)) {\n\n        return 1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 22756}
{"project": "qemu", "commit_id": "5c55ff99fa88158871d5b9f619c485deae5f3d5b", "target": 0, "func": "static always_inline void gen_load_spr(TCGv t, int reg)\n\n{\n\n    tcg_gen_ld_tl(t, cpu_env, offsetof(CPUState, spr[reg]));\n\n}\n", "idx": 22757}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void *qemu_aio_get(const AIOCBInfo *aiocb_info, BlockDriverState *bs,\n\n                   BlockCompletionFunc *cb, void *opaque)\n\n{\n\n    BlockAIOCB *acb;\n\n\n\n    acb = g_slice_alloc(aiocb_info->aiocb_size);\n\n    acb->aiocb_info = aiocb_info;\n\n    acb->bs = bs;\n\n    acb->cb = cb;\n\n    acb->opaque = opaque;\n\n    acb->refcnt = 1;\n\n    return acb;\n\n}\n", "idx": 22758}
{"project": "qemu", "commit_id": "8a5bb1f114c5959cf6b247a737394afb0c518b40", "target": 0, "func": "static int check_refblocks(BlockDriverState *bs, BdrvCheckResult *res,\n\n                           BdrvCheckMode fix, bool *rebuild,\n\n                           void **refcount_table, int64_t *nb_clusters)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int64_t i, size;\n\n    int ret;\n\n\n\n    for(i = 0; i < s->refcount_table_size; i++) {\n\n        uint64_t offset, cluster;\n\n        offset = s->refcount_table[i];\n\n        cluster = offset >> s->cluster_bits;\n\n\n\n        /* Refcount blocks are cluster aligned */\n\n        if (offset_into_cluster(s, offset)) {\n\n            fprintf(stderr, \"ERROR refcount block %\" PRId64 \" is not \"\n\n                \"cluster aligned; refcount table entry corrupted\\n\", i);\n\n            res->corruptions++;\n\n            *rebuild = true;\n\n            continue;\n\n        }\n\n\n\n        if (cluster >= *nb_clusters) {\n\n            fprintf(stderr, \"%s refcount block %\" PRId64 \" is outside image\\n\",\n\n                    fix & BDRV_FIX_ERRORS ? \"Repairing\" : \"ERROR\", i);\n\n\n\n            if (fix & BDRV_FIX_ERRORS) {\n\n                int64_t new_nb_clusters;\n\n                Error *local_err = NULL;\n\n\n\n                if (offset > INT64_MAX - s->cluster_size) {\n\n                    ret = -EINVAL;\n\n                    goto resize_fail;\n\n                }\n\n\n\n                ret = bdrv_truncate(bs->file, offset + s->cluster_size,\n\n                                    &local_err);\n\n                if (ret < 0) {\n\n                    error_report_err(local_err);\n\n                    goto resize_fail;\n\n                }\n\n                size = bdrv_getlength(bs->file->bs);\n\n                if (size < 0) {\n\n                    ret = size;\n\n                    goto resize_fail;\n\n                }\n\n\n\n                new_nb_clusters = size_to_clusters(s, size);\n\n                assert(new_nb_clusters >= *nb_clusters);\n\n\n\n                ret = realloc_refcount_array(s, refcount_table,\n\n                                             nb_clusters, new_nb_clusters);\n\n                if (ret < 0) {\n\n                    res->check_errors++;\n\n                    return ret;\n\n                }\n\n\n\n                if (cluster >= *nb_clusters) {\n\n                    ret = -EINVAL;\n\n                    goto resize_fail;\n\n                }\n\n\n\n                res->corruptions_fixed++;\n\n                ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                                    offset, s->cluster_size);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                /* No need to check whether the refcount is now greater than 1:\n\n                 * This area was just allocated and zeroed, so it can only be\n\n                 * exactly 1 after inc_refcounts() */\n\n                continue;\n\n\n\nresize_fail:\n\n                res->corruptions++;\n\n                *rebuild = true;\n\n                fprintf(stderr, \"ERROR could not resize image: %s\\n\",\n\n                        strerror(-ret));\n\n            } else {\n\n                res->corruptions++;\n\n            }\n\n            continue;\n\n        }\n\n\n\n        if (offset != 0) {\n\n            ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                                offset, s->cluster_size);\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n            if (s->get_refcount(*refcount_table, cluster) != 1) {\n\n                fprintf(stderr, \"ERROR refcount block %\" PRId64\n\n                        \" refcount=%\" PRIu64 \"\\n\", i,\n\n                        s->get_refcount(*refcount_table, cluster));\n\n                res->corruptions++;\n\n                *rebuild = true;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 22759}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "char *socket_address_to_string(struct SocketAddress *addr, Error **errp)\n\n{\n\n    char *buf;\n\n    InetSocketAddress *inet;\n\n\n\n    switch (addr->type) {\n\n    case SOCKET_ADDRESS_KIND_INET:\n\n        inet = addr->u.inet.data;\n\n        if (strchr(inet->host, ':') == NULL) {\n\n            buf = g_strdup_printf(\"%s:%s\", inet->host, inet->port);\n\n        } else {\n\n            buf = g_strdup_printf(\"[%s]:%s\", inet->host, inet->port);\n\n        }\n\n        break;\n\n\n\n    case SOCKET_ADDRESS_KIND_UNIX:\n\n        buf = g_strdup(addr->u.q_unix.data->path);\n\n        break;\n\n\n\n    case SOCKET_ADDRESS_KIND_FD:\n\n        buf = g_strdup(addr->u.fd.data->str);\n\n        break;\n\n\n\n    case SOCKET_ADDRESS_KIND_VSOCK:\n\n        buf = g_strdup_printf(\"%s:%s\",\n\n                              addr->u.vsock.data->cid,\n\n                              addr->u.vsock.data->port);\n\n        break;\n\n\n\n    default:\n\n        abort();\n\n    }\n\n    return buf;\n\n}\n", "idx": 22760}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "func": "static int local_mkdir(FsContext *fs_ctx, V9fsPath *dir_path,\n\n                       const char *name, FsCred *credp)\n\n{\n\n    char *path;\n\n    int err = -1;\n\n    int serrno = 0;\n\n    V9fsString fullname;\n\n    char buffer[PATH_MAX];\n\n\n\n    v9fs_string_init(&fullname);\n\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);\n\n    path = fullname.data;\n\n\n\n    /* Determine the security model */\n\n    if (fs_ctx->export_flags & V9FS_SM_MAPPED) {\n\n        err = mkdir(rpath(fs_ctx, path, buffer), SM_LOCAL_DIR_MODE_BITS);\n\n        if (err == -1) {\n\n            goto out;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFDIR;\n\n        err = local_set_xattr(rpath(fs_ctx, path, buffer), credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n\n        err = mkdir(rpath(fs_ctx, path, buffer), SM_LOCAL_DIR_MODE_BITS);\n\n        if (err == -1) {\n\n            goto out;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFDIR;\n\n        err = local_set_mapped_file_attr(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if ((fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||\n\n               (fs_ctx->export_flags & V9FS_SM_NONE)) {\n\n        err = mkdir(rpath(fs_ctx, path, buffer), credp->fc_mode);\n\n        if (err == -1) {\n\n            goto out;\n\n        }\n\n        err = local_post_create_passthrough(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    }\n\n    goto out;\n\n\n\nerr_end:\n\n    remove(rpath(fs_ctx, path, buffer));\n\n    errno = serrno;\n\nout:\n\n    v9fs_string_free(&fullname);\n\n    return err;\n\n}\n", "idx": 22761}
{"project": "qemu", "commit_id": "539de1246d355d3b8aa33fb7cde732352d8827c7", "target": 0, "func": "static void blk_mig_cleanup(Monitor *mon)\n\n{\n\n    BlkMigDevState *bmds;\n\n    BlkMigBlock *blk;\n\n\n\n    set_dirty_tracking(0);\n\n\n\n    while ((bmds = QSIMPLEQ_FIRST(&block_mig_state.bmds_list)) != NULL) {\n\n        QSIMPLEQ_REMOVE_HEAD(&block_mig_state.bmds_list, entry);\n\n        bdrv_set_in_use(bmds->bs, 0);\n\n        drive_put_ref(drive_get_by_blockdev(bmds->bs));\n\n        g_free(bmds->aio_bitmap);\n\n        g_free(bmds);\n\n    }\n\n\n\n    while ((blk = QSIMPLEQ_FIRST(&block_mig_state.blk_list)) != NULL) {\n\n        QSIMPLEQ_REMOVE_HEAD(&block_mig_state.blk_list, entry);\n\n        g_free(blk->buf);\n\n        g_free(blk);\n\n    }\n\n\n\n    monitor_printf(mon, \"\\n\");\n\n}\n", "idx": 22763}
{"project": "qemu", "commit_id": "c77a5f2daa1ccbd825d59b95c70207c0a196bb94", "target": 0, "func": "void ram_control_load_hook(QEMUFile *f, uint64_t flags)\n\n{\n\n    int ret = 0;\n\n\n\n    if (f->ops->hook_ram_load) {\n\n        ret = f->ops->hook_ram_load(f, f->opaque, flags);\n\n        if (ret < 0) {\n\n            qemu_file_set_error(f, ret);\n\n        }\n\n    } else {\n\n        qemu_file_set_error(f, ret);\n\n    }\n\n}\n", "idx": 22764}
{"project": "qemu", "commit_id": "e058fa2dd599ccc780d334558be9c1d155222b80", "target": 0, "func": "static void usb_host_handle_destroy(USBDevice *udev)\n\n{\n\n    USBHostDevice *s = USB_HOST_DEVICE(udev);\n\n\n\n    qemu_remove_exit_notifier(&s->exit);\n\n    QTAILQ_REMOVE(&hostdevs, s, next);\n\n    usb_host_close(s);\n\n}\n", "idx": 22765}
{"project": "qemu", "commit_id": "6315633b2535dc82dc1b3403f884b81e26b4c72c", "target": 0, "func": "static void *qpa_thread_out (void *arg)\n\n{\n\n    PAVoiceOut *pa = arg;\n\n    HWVoiceOut *hw = &pa->hw;\n\n    int threshold;\n\n\n\n    threshold = conf.divisor ? hw->samples / conf.divisor : 0;\n\n\n\n    if (audio_pt_lock (&pa->pt, AUDIO_FUNC)) {\n\n        return NULL;\n\n    }\n\n\n\n    for (;;) {\n\n        int decr, to_mix, rpos;\n\n\n\n        for (;;) {\n\n            if (pa->done) {\n\n                goto exit;\n\n            }\n\n\n\n            if (pa->live > threshold) {\n\n                break;\n\n            }\n\n\n\n            if (audio_pt_wait (&pa->pt, AUDIO_FUNC)) {\n\n                goto exit;\n\n            }\n\n        }\n\n\n\n        decr = to_mix = pa->live;\n\n        rpos = hw->rpos;\n\n\n\n        if (audio_pt_unlock (&pa->pt, AUDIO_FUNC)) {\n\n            return NULL;\n\n        }\n\n\n\n        while (to_mix) {\n\n            int error;\n\n            int chunk = audio_MIN (to_mix, hw->samples - rpos);\n\n            struct st_sample *src = hw->mix_buf + rpos;\n\n\n\n            hw->clip (pa->pcm_buf, src, chunk);\n\n\n\n            if (pa_simple_write (pa->s, pa->pcm_buf,\n\n                                 chunk << hw->info.shift, &error) < 0) {\n\n                qpa_logerr (error, \"pa_simple_write failed\\n\");\n\n                return NULL;\n\n            }\n\n\n\n            rpos = (rpos + chunk) % hw->samples;\n\n            to_mix -= chunk;\n\n        }\n\n\n\n        if (audio_pt_lock (&pa->pt, AUDIO_FUNC)) {\n\n            return NULL;\n\n        }\n\n\n\n        pa->live = 0;\n\n        pa->rpos = rpos;\n\n        pa->decr += decr;\n\n    }\n\n\n\n exit:\n\n    audio_pt_unlock (&pa->pt, AUDIO_FUNC);\n\n    return NULL;\n\n}\n", "idx": 22766}
{"project": "qemu", "commit_id": "df3c286c53ac51e7267f2761c7a0c62e11b6e815", "target": 0, "func": "static void bench_undrained_flush_cb(void *opaque, int ret)\n\n{\n\n    if (ret < 0) {\n\n        error_report(\"Failed flush request: %s\\n\", strerror(-ret));\n\n        exit(EXIT_FAILURE);\n\n    }\n\n}\n", "idx": 22767}
{"project": "qemu", "commit_id": "10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b", "target": 0, "func": "static uint32_t nabm_readw (void *opaque, uint32_t addr)\n\n{\n\n    PCIAC97LinkState *d = opaque;\n\n    AC97LinkState *s = &d->ac97;\n\n    AC97BusMasterRegs *r = NULL;\n\n    uint32_t index = addr - s->base[1];\n\n    uint32_t val = ~0U;\n\n\n\n    switch (index) {\n\n    case PI_SR:\n\n    case PO_SR:\n\n    case MC_SR:\n\n        r = &s->bm_regs[GET_BM (index)];\n\n        val = r->sr;\n\n        dolog (\"SR[%d] -> %#x\\n\", GET_BM (index), val);\n\n        break;\n\n    case PI_PICB:\n\n    case PO_PICB:\n\n    case MC_PICB:\n\n        r = &s->bm_regs[GET_BM (index)];\n\n        val = r->picb;\n\n        dolog (\"PICB[%d] -> %#x\\n\", GET_BM (index), val);\n\n        break;\n\n    default:\n\n        dolog (\"U nabm readw %#x -> %#x\\n\", addr, val);\n\n        break;\n\n    }\n\n    return val;\n\n}\n", "idx": 22768}
{"project": "qemu", "commit_id": "553a6a59f6931bf3a034945e0c1585f4b05d6000", "target": 0, "func": "static int ehci_state_executing(EHCIQueue *q, int async)\n\n{\n\n    int again = 0;\n\n    int reload, nakcnt;\n\n\n\n    ehci_execute_complete(q);\n\n    if (q->usb_status == USB_RET_ASYNC) {\n\n        goto out;\n\n    }\n\n    if (q->usb_status == USB_RET_PROCERR) {\n\n        again = -1;\n\n        goto out;\n\n    }\n\n\n\n    // 4.10.3\n\n    if (!async) {\n\n        int transactCtr = get_field(q->qh.epcap, QH_EPCAP_MULT);\n\n        transactCtr--;\n\n        set_field(&q->qh.epcap, transactCtr, QH_EPCAP_MULT);\n\n        // 4.10.3, bottom of page 82, should exit this state when transaction\n\n        // counter decrements to 0\n\n    }\n\n\n\n    reload = get_field(q->qh.epchar, QH_EPCHAR_RL);\n\n    if (reload) {\n\n        nakcnt = get_field(q->qh.altnext_qtd, QH_ALTNEXT_NAKCNT);\n\n        if (q->usb_status == USB_RET_NAK) {\n\n            if (nakcnt) {\n\n                nakcnt--;\n\n            }\n\n        } else {\n\n            nakcnt = reload;\n\n        }\n\n        set_field(&q->qh.altnext_qtd, nakcnt, QH_ALTNEXT_NAKCNT);\n\n    }\n\n\n\n    /* 4.10.5 */\n\n    if ((q->usb_status == USB_RET_NAK) || (q->qh.token & QTD_TOKEN_ACTIVE)) {\n\n        ehci_set_state(q->ehci, async, EST_HORIZONTALQH);\n\n    } else {\n\n        ehci_set_state(q->ehci, async, EST_WRITEBACK);\n\n    }\n\n\n\n    again = 1;\n\n\n\nout:\n\n    ehci_flush_qh(q);\n\n    return again;\n\n}\n", "idx": 22769}
{"project": "qemu", "commit_id": "2884cf5b934808f547b5268a51be631805c25857", "target": 0, "func": "static void gd_change_page(GtkNotebook *nb, gpointer arg1, guint arg2,\n\n                           gpointer data)\n\n{\n\n    GtkDisplayState *s = data;\n\n    VirtualConsole *vc;\n\n    gboolean on_vga;\n\n\n\n    if (!gtk_widget_get_realized(s->notebook)) {\n\n        return;\n\n    }\n\n\n\n    vc = gd_vc_find_by_page(s, arg2);\n\n    if (!vc) {\n\n        return;\n\n    }\n\n    gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(vc->menu_item),\n\n                                   TRUE);\n\n\n\n    on_vga = (vc->type == GD_VC_GFX);\n\n    if (!on_vga) {\n\n        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->grab_item),\n\n                                       FALSE);\n\n    } else if (s->full_screen) {\n\n        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->grab_item),\n\n                                       TRUE);\n\n    }\n\n    gtk_widget_set_sensitive(s->grab_item, on_vga);\n\n\n\n    gd_update_cursor(vc);\n\n}\n", "idx": 22770}
{"project": "qemu", "commit_id": "856d72454f03aea26fd61c728762ef9cd1d71512", "target": 0, "func": "static void address_space_update_topology(AddressSpace *as)\n\n{\n\n    FlatView *old_view = as->current_map;\n\n    FlatView *new_view = generate_memory_topology(as->root);\n\n\n\n    address_space_update_topology_pass(as, old_view, new_view, false);\n\n    address_space_update_topology_pass(as, old_view, new_view, true);\n\n\n\n    as->current_map = new_view;\n\n    flatview_destroy(old_view);\n\n    address_space_update_ioeventfds(as);\n\n}\n", "idx": 22771}
{"project": "qemu", "commit_id": "e91171e30235ae99ab8060988aa3c9536692bba8", "target": 0, "func": "static void ptimer_reload(ptimer_state *s)\n\n{\n\n    if (s->delta == 0) {\n\n        ptimer_trigger(s);\n\n        s->delta = s->limit;\n\n    }\n\n    if (s->delta == 0 || s->period == 0) {\n\n        fprintf(stderr, \"Timer with period zero, disabling\\n\");\n\n        s->enabled = 0;\n\n        return;\n\n    }\n\n\n\n    s->last_event = s->next_event;\n\n    s->next_event = s->last_event + s->delta * s->period;\n\n    if (s->period_frac) {\n\n        s->next_event += ((int64_t)s->period_frac * s->delta) >> 32;\n\n    }\n\n    timer_mod(s->timer, s->next_event);\n\n}\n", "idx": 22772}
{"project": "qemu", "commit_id": "2c5b1d2a479273cec4c1be491745f48b0808b508", "target": 0, "func": "uint32_t HELPER(rer)(CPUXtensaState *env, uint32_t addr)\n\n{\n\n    return address_space_ldl(env->address_space_er, addr,\n\n                             (MemTxAttrs){0}, NULL);\n\n}\n", "idx": 22774}
{"project": "qemu", "commit_id": "3a5c76baf312d83cb77c8faa72c5f7a477effed0", "target": 0, "func": "static void sun4uv_init(MemoryRegion *address_space_mem,\n\n                        MachineState *machine,\n\n                        const struct hwdef *hwdef)\n\n{\n\n    SPARCCPU *cpu;\n\n    Nvram *nvram;\n\n    unsigned int i;\n\n    uint64_t initrd_addr, initrd_size, kernel_addr, kernel_size, kernel_entry;\n\n    PCIBus *pci_bus, *pci_bus2, *pci_bus3;\n\n    ISABus *isa_bus;\n\n    SysBusDevice *s;\n\n    qemu_irq *ivec_irqs, *pbm_irqs;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    DriveInfo *fd[MAX_FD];\n\n    FWCfgState *fw_cfg;\n\n\n\n    /* init CPUs */\n\n    cpu = cpu_devinit(machine->cpu_model, hwdef);\n\n\n\n    /* set up devices */\n\n    ram_init(0, machine->ram_size);\n\n\n\n    prom_init(hwdef->prom_addr, bios_name);\n\n\n\n    ivec_irqs = qemu_allocate_irqs(cpu_set_ivec_irq, cpu, IVEC_MAX);\n\n    pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, ivec_irqs, &pci_bus2,\n\n                           &pci_bus3, &pbm_irqs);\n\n    pci_vga_init(pci_bus);\n\n\n\n    // XXX Should be pci_bus3\n\n    isa_bus = pci_ebus_init(pci_bus, -1, pbm_irqs);\n\n\n\n    i = 0;\n\n    if (hwdef->console_serial_base) {\n\n        serial_mm_init(address_space_mem, hwdef->console_serial_base, 0,\n\n                       NULL, 115200, serial_hds[i], DEVICE_BIG_ENDIAN);\n\n        i++;\n\n    }\n\n\n\n    serial_hds_isa_init(isa_bus, MAX_SERIAL_PORTS);\n\n    parallel_hds_isa_init(isa_bus, MAX_PARALLEL_PORTS);\n\n\n\n    for(i = 0; i < nb_nics; i++)\n\n        pci_nic_init_nofail(&nd_table[i], pci_bus, \"ne2k_pci\", NULL);\n\n\n\n    ide_drive_get(hd, ARRAY_SIZE(hd));\n\n\n\n    pci_cmd646_ide_init(pci_bus, hd, 1);\n\n\n\n    isa_create_simple(isa_bus, \"i8042\");\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        fd[i] = drive_get(IF_FLOPPY, 0, i);\n\n    }\n\n    fdctrl_init_isa(isa_bus, fd);\n\n\n\n    /* Map NVRAM into I/O (ebus) space */\n\n    nvram = m48t59_init(NULL, 0, 0, NVRAM_SIZE, 1968, 59);\n\n    s = SYS_BUS_DEVICE(nvram);\n\n    memory_region_add_subregion(get_system_io(), 0x2000,\n\n                                sysbus_mmio_get_region(s, 0));\n\n \n\n    initrd_size = 0;\n\n    initrd_addr = 0;\n\n    kernel_size = sun4u_load_kernel(machine->kernel_filename,\n\n                                    machine->initrd_filename,\n\n                                    ram_size, &initrd_size, &initrd_addr,\n\n                                    &kernel_addr, &kernel_entry);\n\n\n\n    sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, \"Sun4u\", machine->ram_size,\n\n                           machine->boot_order,\n\n                           kernel_addr, kernel_size,\n\n                           machine->kernel_cmdline,\n\n                           initrd_addr, initrd_size,\n\n                           /* XXX: need an option to load a NVRAM image */\n\n                           0,\n\n                           graphic_width, graphic_height, graphic_depth,\n\n                           (uint8_t *)&nd_table[0].macaddr);\n\n\n\n    fw_cfg = fw_cfg_init_io(BIOS_CFG_IOPORT);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MAX_CPUS, (uint16_t)max_cpus);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_KERNEL_ADDR, kernel_entry);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\n\n    if (machine->kernel_cmdline) {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_CMDLINE_SIZE,\n\n                       strlen(machine->kernel_cmdline) + 1);\n\n        fw_cfg_add_string(fw_cfg, FW_CFG_CMDLINE_DATA, machine->kernel_cmdline);\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_CMDLINE_SIZE, 0);\n\n    }\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_INITRD_ADDR, initrd_addr);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, machine->boot_order[0]);\n\n\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_SPARC64_WIDTH, graphic_width);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_SPARC64_HEIGHT, graphic_height);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_SPARC64_DEPTH, graphic_depth);\n\n\n\n    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);\n\n}\n", "idx": 22775}
{"project": "qemu", "commit_id": "f41389ae3c54bd5e2040e3f95a2872981c3ed965", "target": 0, "func": "void kvm_arch_init_irq_routing(KVMState *s)\n\n{\n\n    if (!kvm_check_extension(s, KVM_CAP_IRQ_ROUTING)) {\n\n        /* If kernel can't do irq routing, interrupt source\n\n         * override 0->2 cannot be set up as required by HPET.\n\n         * So we have to disable it.\n\n         */\n\n        no_hpet = 1;\n\n    }\n\n    /* We know at this point that we're using the in-kernel\n\n     * irqchip, so we can use irqfds, and on x86 we know\n\n     * we can use msi via irqfd and GSI routing.\n\n     */\n\n    kvm_irqfds_allowed = true;\n\n    kvm_msi_via_irqfd_allowed = true;\n\n    kvm_gsi_routing_allowed = true;\n\n}\n", "idx": 22776}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void output_visitor_test_add(const char *testpath,\n\n                                    TestOutputVisitorData *data,\n\n                                    void (*test_func)(TestOutputVisitorData *data, const void *user_data))\n\n{\n\n    g_test_add(testpath, TestOutputVisitorData, data, visitor_output_setup,\n\n               test_func, visitor_output_teardown);\n\n}\n", "idx": 22777}
{"project": "qemu", "commit_id": "6049f4f831c6f409031dfa09282b38d0cbaecad8", "target": 0, "func": "void cpu_loop (CPUState *env)\n\n{\n\n    int trapnr;\n\n    target_siginfo_t info;\n\n\n\n    while (1) {\n\n        trapnr = cpu_alpha_exec (env);\n\n\n\n        switch (trapnr) {\n\n        case EXCP_RESET:\n\n            fprintf(stderr, \"Reset requested. Exit\\n\");\n\n            exit(1);\n\n            break;\n\n        case EXCP_MCHK:\n\n            fprintf(stderr, \"Machine check exception. Exit\\n\");\n\n            exit(1);\n\n            break;\n\n        case EXCP_ARITH:\n\n            fprintf(stderr, \"Arithmetic trap.\\n\");\n\n            exit(1);\n\n            break;\n\n        case EXCP_HW_INTERRUPT:\n\n            fprintf(stderr, \"External interrupt. Exit\\n\");\n\n            exit(1);\n\n            break;\n\n        case EXCP_DFAULT:\n\n            fprintf(stderr, \"MMU data fault\\n\");\n\n            exit(1);\n\n            break;\n\n        case EXCP_DTB_MISS_PAL:\n\n            fprintf(stderr, \"MMU data TLB miss in PALcode\\n\");\n\n            exit(1);\n\n            break;\n\n        case EXCP_ITB_MISS:\n\n            fprintf(stderr, \"MMU instruction TLB miss\\n\");\n\n            exit(1);\n\n            break;\n\n        case EXCP_ITB_ACV:\n\n            fprintf(stderr, \"MMU instruction access violation\\n\");\n\n            exit(1);\n\n            break;\n\n        case EXCP_DTB_MISS_NATIVE:\n\n            fprintf(stderr, \"MMU data TLB miss\\n\");\n\n            exit(1);\n\n            break;\n\n        case EXCP_UNALIGN:\n\n            fprintf(stderr, \"Unaligned access\\n\");\n\n            exit(1);\n\n            break;\n\n        case EXCP_OPCDEC:\n\n            fprintf(stderr, \"Invalid instruction\\n\");\n\n            exit(1);\n\n            break;\n\n        case EXCP_FEN:\n\n            fprintf(stderr, \"Floating-point not allowed\\n\");\n\n            exit(1);\n\n            break;\n\n        case EXCP_CALL_PAL ... (EXCP_CALL_PALP - 1):\n\n            call_pal(env, (trapnr >> 6) | 0x80);\n\n            break;\n\n        case EXCP_CALL_PALP ... (EXCP_CALL_PALE - 1):\n\n            fprintf(stderr, \"Privileged call to PALcode\\n\");\n\n            exit(1);\n\n            break;\n\n        case EXCP_DEBUG:\n\n            {\n\n                int sig;\n\n\n\n                sig = gdb_handlesig (env, TARGET_SIGTRAP);\n\n                if (sig)\n\n                  {\n\n                    info.si_signo = sig;\n\n                    info.si_errno = 0;\n\n                    info.si_code = TARGET_TRAP_BRKPT;\n\n                    queue_signal(env, info.si_signo, &info);\n\n                  }\n\n            }\n\n            break;\n\n        default:\n\n            printf (\"Unhandled trap: 0x%x\\n\", trapnr);\n\n            cpu_dump_state(env, stderr, fprintf, 0);\n\n            exit (1);\n\n        }\n\n        process_pending_signals (env);\n\n    }\n\n}\n", "idx": 22778}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "int rom_load_all(void)\n\n{\n\n    target_phys_addr_t addr = 0;\n\n    MemoryRegionSection section;\n\n    Rom *rom;\n\n\n\n    QTAILQ_FOREACH(rom, &roms, next) {\n\n        if (rom->fw_file) {\n\n            continue;\n\n        }\n\n        if (addr > rom->addr) {\n\n            fprintf(stderr, \"rom: requested regions overlap \"\n\n                    \"(rom %s. free=0x\" TARGET_FMT_plx\n\n                    \", addr=0x\" TARGET_FMT_plx \")\\n\",\n\n                    rom->name, addr, rom->addr);\n\n            return -1;\n\n        }\n\n        addr  = rom->addr;\n\n        addr += rom->romsize;\n\n        section = memory_region_find(get_system_memory(), rom->addr, 1);\n\n        rom->isrom = section.size && memory_region_is_rom(section.mr);\n\n    }\n\n    qemu_register_reset(rom_reset, NULL);\n\n    roms_loaded = 1;\n\n    return 0;\n\n}\n", "idx": 22779}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static int alsa_init_in (HWVoiceIn *hw, audsettings_t *as)\n\n{\n\n    ALSAVoiceIn *alsa = (ALSAVoiceIn *) hw;\n\n    struct alsa_params_req req;\n\n    struct alsa_params_obt obt;\n\n    snd_pcm_t *handle;\n\n    audsettings_t obt_as;\n\n\n\n    req.fmt = aud_to_alsafmt (as->fmt);\n\n    req.freq = as->freq;\n\n    req.nchannels = as->nchannels;\n\n    req.period_size = conf.period_size_in;\n\n    req.buffer_size = conf.buffer_size_in;\n\n    req.size_in_usec = conf.size_in_usec_in;\n\n    req.override_mask = !!conf.period_size_in_overridden\n\n        | (!!conf.buffer_size_in_overridden << 1);\n\n\n\n    if (alsa_open (1, &req, &obt, &handle)) {\n\n        return -1;\n\n    }\n\n\n\n    obt_as.freq = obt.freq;\n\n    obt_as.nchannels = obt.nchannels;\n\n    obt_as.fmt = obt.fmt;\n\n    obt_as.endianness = obt.endianness;\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n    hw->samples = obt.samples;\n\n\n\n    alsa->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);\n\n    if (!alsa->pcm_buf) {\n\n        dolog (\"Could not allocate ADC buffer (%d samples, each %d bytes)\\n\",\n\n               hw->samples, 1 << hw->info.shift);\n\n        alsa_anal_close (&handle);\n\n        return -1;\n\n    }\n\n\n\n    alsa->handle = handle;\n\n    return 0;\n\n}\n", "idx": 22780}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "static void rtas_power_off(sPAPREnvironment *spapr,\n\n                           uint32_t token, uint32_t nargs, target_ulong args,\n\n                           uint32_t nret, target_ulong rets)\n\n{\n\n    if (nargs != 2 || nret != 1) {\n\n        rtas_st(rets, 0, -3);\n\n        return;\n\n    }\n\n    qemu_system_shutdown_request();\n\n    rtas_st(rets, 0, 0);\n\n}\n", "idx": 22781}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_id_read(void *opaque, target_phys_addr_t addr,\n\n                             unsigned size)\n\n{\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *) opaque;\n\n\n\n    if (size != 4) {\n\n        return omap_badwidth_read32(opaque, addr);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0xfffe1800:\t/* DIE_ID_LSB */\n\n        return 0xc9581f0e;\n\n    case 0xfffe1804:\t/* DIE_ID_MSB */\n\n        return 0xa8858bfa;\n\n\n\n    case 0xfffe2000:\t/* PRODUCT_ID_LSB */\n\n        return 0x00aaaafc;\n\n    case 0xfffe2004:\t/* PRODUCT_ID_MSB */\n\n        return 0xcafeb574;\n\n\n\n    case 0xfffed400:\t/* JTAG_ID_LSB */\n\n        switch (s->mpu_model) {\n\n        case omap310:\n\n            return 0x03310315;\n\n        case omap1510:\n\n            return 0x03310115;\n\n        default:\n\n            hw_error(\"%s: bad mpu model\\n\", __FUNCTION__);\n\n        }\n\n        break;\n\n\n\n    case 0xfffed404:\t/* JTAG_ID_MSB */\n\n        switch (s->mpu_model) {\n\n        case omap310:\n\n            return 0xfb57402f;\n\n        case omap1510:\n\n            return 0xfb47002f;\n\n        default:\n\n            hw_error(\"%s: bad mpu model\\n\", __FUNCTION__);\n\n        }\n\n        break;\n\n    }\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 22782}
{"project": "qemu", "commit_id": "86a6a9bf551ffa183880480b37c5836d3916687a", "target": 0, "func": "ram_addr_t xen_ram_addr_from_mapcache(void *ptr)\n\n{\n\n    MapCacheEntry *entry = NULL;\n\n    MapCacheRev *reventry;\n\n    hwaddr paddr_index;\n\n    hwaddr size;\n\n    int found = 0;\n\n\n\n    QTAILQ_FOREACH(reventry, &mapcache->locked_entries, next) {\n\n        if (reventry->vaddr_req == ptr) {\n\n            paddr_index = reventry->paddr_index;\n\n            size = reventry->size;\n\n            found = 1;\n\n            break;\n\n        }\n\n    }\n\n    if (!found) {\n\n        fprintf(stderr, \"%s, could not find %p\\n\", __func__, ptr);\n\n        QTAILQ_FOREACH(reventry, &mapcache->locked_entries, next) {\n\n            DPRINTF(\"   \"TARGET_FMT_plx\" -> %p is present\\n\", reventry->paddr_index,\n\n                    reventry->vaddr_req);\n\n        }\n\n        abort();\n\n        return 0;\n\n    }\n\n\n\n    entry = &mapcache->entry[paddr_index % mapcache->nr_buckets];\n\n    while (entry && (entry->paddr_index != paddr_index || entry->size != size)) {\n\n        entry = entry->next;\n\n    }\n\n    if (!entry) {\n\n        DPRINTF(\"Trying to find address %p that is not in the mapcache!\\n\", ptr);\n\n        return 0;\n\n    }\n\n    return (reventry->paddr_index << MCACHE_BUCKET_SHIFT) +\n\n        ((unsigned long) ptr - (unsigned long) entry->vaddr_base);\n\n}\n", "idx": 22783}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void hpdmc_write(void *opaque, target_phys_addr_t addr, uint64_t value,\n\n                        unsigned size)\n\n{\n\n    MilkymistHpdmcState *s = opaque;\n\n\n\n    trace_milkymist_hpdmc_memory_write(addr, value);\n\n\n\n    addr >>= 2;\n\n    switch (addr) {\n\n    case R_SYSTEM:\n\n    case R_BYPASS:\n\n    case R_TIMING:\n\n        s->regs[addr] = value;\n\n        break;\n\n    case R_IODELAY:\n\n        /* ignore writes */\n\n        break;\n\n\n\n    default:\n\n        error_report(\"milkymist_hpdmc: write access to unknown register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    }\n\n}\n", "idx": 22784}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static int write_elf32_note(DumpState *s)\n\n{\n\n    target_phys_addr_t begin = s->memory_offset - s->note_size;\n\n    Elf32_Phdr phdr;\n\n    int endian = s->dump_info.d_endian;\n\n    int ret;\n\n\n\n    memset(&phdr, 0, sizeof(Elf32_Phdr));\n\n    phdr.p_type = cpu_convert_to_target32(PT_NOTE, endian);\n\n    phdr.p_offset = cpu_convert_to_target32(begin, endian);\n\n    phdr.p_paddr = 0;\n\n    phdr.p_filesz = cpu_convert_to_target32(s->note_size, endian);\n\n    phdr.p_memsz = cpu_convert_to_target32(s->note_size, endian);\n\n    phdr.p_vaddr = 0;\n\n\n\n    ret = fd_write_vmcore(&phdr, sizeof(Elf32_Phdr), s);\n\n    if (ret < 0) {\n\n        dump_error(s, \"dump: failed to write program header table.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 22785}
{"project": "qemu", "commit_id": "bdb5ee3064d5ae786b0bcb6cf6ff4e3554a72990", "target": 0, "func": "int rom_add_vga(const char *file)\n\n{\n\n    if (!rom_enable_driver_roms)\n\n        return 0;\n\n    return rom_add_file(file, \"vgaroms\", file, 0);\n\n}\n", "idx": 22786}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void fw_cfg_data_mem_write(void *opaque, target_phys_addr_t addr,\n\n                                  uint64_t value, unsigned size)\n\n{\n\n    fw_cfg_write(opaque, (uint8_t)value);\n\n}\n", "idx": 22787}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static void external_snapshot_prepare(BlkActionState *common,\n\n                                      Error **errp)\n\n{\n\n    int flags = 0, ret;\n\n    QDict *options = NULL;\n\n    Error *local_err = NULL;\n\n    /* Device and node name of the image to generate the snapshot from */\n\n    const char *device;\n\n    const char *node_name;\n\n    /* Reference to the new image (for 'blockdev-snapshot') */\n\n    const char *snapshot_ref;\n\n    /* File name of the new image (for 'blockdev-snapshot-sync') */\n\n    const char *new_image_file;\n\n    ExternalSnapshotState *state =\n\n                             DO_UPCAST(ExternalSnapshotState, common, common);\n\n    TransactionAction *action = common->action;\n\n\n\n    /* 'blockdev-snapshot' and 'blockdev-snapshot-sync' have similar\n\n     * purpose but a different set of parameters */\n\n    switch (action->type) {\n\n    case TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT:\n\n        {\n\n            BlockdevSnapshot *s = action->u.blockdev_snapshot;\n\n            device = s->node;\n\n            node_name = s->node;\n\n            new_image_file = NULL;\n\n            snapshot_ref = s->overlay;\n\n        }\n\n        break;\n\n    case TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT_SYNC:\n\n        {\n\n            BlockdevSnapshotSync *s = action->u.blockdev_snapshot_sync;\n\n            device = s->has_device ? s->device : NULL;\n\n            node_name = s->has_node_name ? s->node_name : NULL;\n\n            new_image_file = s->snapshot_file;\n\n            snapshot_ref = NULL;\n\n        }\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n\n\n    /* start processing */\n\n    if (action_check_completion_mode(common, errp) < 0) {\n\n        return;\n\n    }\n\n\n\n    state->old_bs = bdrv_lookup_bs(device, node_name, errp);\n\n    if (!state->old_bs) {\n\n        return;\n\n    }\n\n\n\n    /* Acquire AioContext now so any threads operating on old_bs stop */\n\n    state->aio_context = bdrv_get_aio_context(state->old_bs);\n\n    aio_context_acquire(state->aio_context);\n\n    bdrv_drained_begin(state->old_bs);\n\n\n\n    if (!bdrv_is_inserted(state->old_bs)) {\n\n        error_setg(errp, QERR_DEVICE_HAS_NO_MEDIUM, device);\n\n        return;\n\n    }\n\n\n\n    if (bdrv_op_is_blocked(state->old_bs,\n\n                           BLOCK_OP_TYPE_EXTERNAL_SNAPSHOT, errp)) {\n\n        return;\n\n    }\n\n\n\n    if (!bdrv_is_read_only(state->old_bs)) {\n\n        if (bdrv_flush(state->old_bs)) {\n\n            error_setg(errp, QERR_IO_ERROR);\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (!bdrv_is_first_non_filter(state->old_bs)) {\n\n        error_setg(errp, QERR_FEATURE_DISABLED, \"snapshot\");\n\n        return;\n\n    }\n\n\n\n    if (action->type == TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT_SYNC) {\n\n        BlockdevSnapshotSync *s = action->u.blockdev_snapshot_sync;\n\n        const char *format = s->has_format ? s->format : \"qcow2\";\n\n        enum NewImageMode mode;\n\n        const char *snapshot_node_name =\n\n            s->has_snapshot_node_name ? s->snapshot_node_name : NULL;\n\n\n\n        if (node_name && !snapshot_node_name) {\n\n            error_setg(errp, \"New snapshot node name missing\");\n\n            return;\n\n        }\n\n\n\n        if (snapshot_node_name &&\n\n            bdrv_lookup_bs(snapshot_node_name, snapshot_node_name, NULL)) {\n\n            error_setg(errp, \"New snapshot node name already in use\");\n\n            return;\n\n        }\n\n\n\n        flags = state->old_bs->open_flags;\n\n\n\n        /* create new image w/backing file */\n\n        mode = s->has_mode ? s->mode : NEW_IMAGE_MODE_ABSOLUTE_PATHS;\n\n        if (mode != NEW_IMAGE_MODE_EXISTING) {\n\n            int64_t size = bdrv_getlength(state->old_bs);\n\n            if (size < 0) {\n\n                error_setg_errno(errp, -size, \"bdrv_getlength failed\");\n\n                return;\n\n            }\n\n            bdrv_img_create(new_image_file, format,\n\n                            state->old_bs->filename,\n\n                            state->old_bs->drv->format_name,\n\n                            NULL, size, flags, &local_err, false);\n\n            if (local_err) {\n\n                error_propagate(errp, local_err);\n\n                return;\n\n            }\n\n        }\n\n\n\n        options = qdict_new();\n\n        if (s->has_snapshot_node_name) {\n\n            qdict_put(options, \"node-name\",\n\n                      qstring_from_str(snapshot_node_name));\n\n        }\n\n        qdict_put(options, \"driver\", qstring_from_str(format));\n\n\n\n        flags |= BDRV_O_NO_BACKING;\n\n    }\n\n\n\n    assert(state->new_bs == NULL);\n\n    ret = bdrv_open(&state->new_bs, new_image_file, snapshot_ref, options,\n\n                    flags, errp);\n\n    /* We will manually add the backing_hd field to the bs later */\n\n    if (ret != 0) {\n\n        return;\n\n    }\n\n\n\n    if (state->new_bs->blk != NULL) {\n\n        error_setg(errp, \"The snapshot is already in use by %s\",\n\n                   blk_name(state->new_bs->blk));\n\n        return;\n\n    }\n\n\n\n    if (bdrv_op_is_blocked(state->new_bs, BLOCK_OP_TYPE_EXTERNAL_SNAPSHOT,\n\n                           errp)) {\n\n        return;\n\n    }\n\n\n\n    if (state->new_bs->backing != NULL) {\n\n        error_setg(errp, \"The snapshot already has a backing image\");\n\n        return;\n\n    }\n\n\n\n    if (!state->new_bs->drv->supports_backing) {\n\n        error_setg(errp, \"The snapshot does not support backing images\");\n\n    }\n\n}\n", "idx": 22788}
{"project": "qemu", "commit_id": "2374e73edafff0586cbfb67c333c5a7588f81fd5", "target": 0, "func": "void helper_ldl_data(uint64_t t0, uint64_t t1)\n\n{\n\n    ldl_data(t1, t0);\n\n}\n", "idx": 22789}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "Visitor *qmp_input_visitor_new(QObject *obj, bool strict)\n\n{\n\n    QmpInputVisitor *v;\n\n\n\n    assert(obj);\n\n    v = g_malloc0(sizeof(*v));\n\n\n\n    v->visitor.type = VISITOR_INPUT;\n\n    v->visitor.start_struct = qmp_input_start_struct;\n\n    v->visitor.check_struct = qmp_input_check_struct;\n\n    v->visitor.end_struct = qmp_input_pop;\n\n    v->visitor.start_list = qmp_input_start_list;\n\n    v->visitor.next_list = qmp_input_next_list;\n\n    v->visitor.end_list = qmp_input_pop;\n\n    v->visitor.start_alternate = qmp_input_start_alternate;\n\n    v->visitor.type_int64 = qmp_input_type_int64;\n\n    v->visitor.type_uint64 = qmp_input_type_uint64;\n\n    v->visitor.type_bool = qmp_input_type_bool;\n\n    v->visitor.type_str = qmp_input_type_str;\n\n    v->visitor.type_number = qmp_input_type_number;\n\n    v->visitor.type_any = qmp_input_type_any;\n\n    v->visitor.type_null = qmp_input_type_null;\n\n    v->visitor.optional = qmp_input_optional;\n\n    v->visitor.free = qmp_input_free;\n\n    v->strict = strict;\n\n\n\n    v->root = obj;\n\n    qobject_incref(obj);\n\n\n\n    return &v->visitor;\n\n}\n", "idx": 22791}
{"project": "qemu", "commit_id": "f2001a7e0555b66d6db25a3ff1801540814045bb", "target": 0, "func": "static gboolean tcp_chr_accept(QIOChannel *channel,\n\n                               GIOCondition cond,\n\n                               void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    TCPCharDriver *s = chr->opaque;\n\n    QIOChannelSocket *sioc;\n\n\n\n    sioc = qio_channel_socket_accept(QIO_CHANNEL_SOCKET(channel),\n\n                                     NULL);\n\n    if (!sioc) {\n\n        return TRUE;\n\n    }\n\n\n\n    if (s->do_telnetopt) {\n\n        tcp_chr_telnet_init(QIO_CHANNEL(sioc));\n\n    }\n\n\n\n    tcp_chr_new_client(chr, sioc);\n\n\n\n    object_unref(OBJECT(sioc));\n\n\n\n    return TRUE;\n\n}\n", "idx": 22792}
{"project": "qemu", "commit_id": "6b8f0187a4d7c263e356302f8d308655372a4b5b", "target": 0, "func": "void qemu_timer_notify_cb(void *opaque, QEMUClockType type)\n\n{\n\n    qemu_notify_event();\n\n}\n", "idx": 22793}
{"project": "qemu", "commit_id": "4d9ebf751a5a98e5dc2e26baf2344e744f4fa7b9", "target": 0, "func": "static void do_cpu_reset(void *opaque)\n\n{\n\n    ARMCPU *cpu = opaque;\n\n    CPUARMState *env = &cpu->env;\n\n    const struct arm_boot_info *info = env->boot_info;\n\n\n\n    cpu_reset(CPU(cpu));\n\n    if (info) {\n\n        if (!info->is_linux) {\n\n            /* Jump to the entry point.  */\n\n            env->regs[15] = info->entry & 0xfffffffe;\n\n            env->thumb = info->entry & 1;\n\n        } else {\n\n            if (CPU(cpu) == first_cpu) {\n\n                env->regs[15] = info->loader_start;\n\n                if (!info->dtb_filename) {\n\n                    if (old_param) {\n\n                        set_kernel_args_old(info);\n\n                    } else {\n\n                        set_kernel_args(info);\n\n                    }\n\n                }\n\n            } else {\n\n                info->secondary_cpu_reset_hook(cpu, info);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 22794}
{"project": "qemu", "commit_id": "ad2d30f79d3b0812f02c741be2189796b788d6d7", "target": 1, "func": "static void scsi_generic_purge_requests(SCSIGenericState *s)\n\n{\n\n    SCSIGenericReq *r;\n\n\n\n    while (!QTAILQ_EMPTY(&s->qdev.requests)) {\n\n        r = DO_UPCAST(SCSIGenericReq, req, QTAILQ_FIRST(&s->qdev.requests));\n\n        if (r->req.aiocb) {\n\n            bdrv_aio_cancel(r->req.aiocb);\n\n        }\n\n        scsi_remove_request(r);\n\n    }\n\n}\n", "idx": 22799}
{"project": "qemu", "commit_id": "bb44619b06c0bef20b658ff532cf850c16362ae7", "target": 1, "func": "DriveInfo *drive_init(QemuOpts *opts, BlockInterfaceType block_default_type)\n\n{\n\n    const char *buf;\n\n    const char *file = NULL;\n\n    const char *serial;\n\n    const char *mediastr = \"\";\n\n    BlockInterfaceType type;\n\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n\n    int bus_id, unit_id;\n\n    int cyls, heads, secs, translation;\n\n    BlockDriver *drv = NULL;\n\n    int max_devs;\n\n    int index;\n\n    int ro = 0;\n\n    int bdrv_flags = 0;\n\n    int on_read_error, on_write_error;\n\n    const char *devaddr;\n\n    DriveInfo *dinfo;\n\n    BlockIOLimit io_limits;\n\n    int snapshot = 0;\n\n    bool copy_on_read;\n\n    int ret;\n\n    Error *error = NULL;\n\n\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    media = MEDIA_DISK;\n\n\n\n    /* extract parameters */\n\n    bus_id  = qemu_opt_get_number(opts, \"bus\", 0);\n\n    unit_id = qemu_opt_get_number(opts, \"unit\", -1);\n\n    index   = qemu_opt_get_number(opts, \"index\", -1);\n\n\n\n    cyls  = qemu_opt_get_number(opts, \"cyls\", 0);\n\n    heads = qemu_opt_get_number(opts, \"heads\", 0);\n\n    secs  = qemu_opt_get_number(opts, \"secs\", 0);\n\n\n\n    snapshot = qemu_opt_get_bool(opts, \"snapshot\", 0);\n\n    ro = qemu_opt_get_bool(opts, \"readonly\", 0);\n\n    copy_on_read = qemu_opt_get_bool(opts, \"copy-on-read\", false);\n\n\n\n    file = qemu_opt_get(opts, \"file\");\n\n    serial = qemu_opt_get(opts, \"serial\");\n\n\n\n    if ((buf = qemu_opt_get(opts, \"if\")) != NULL) {\n\n        for (type = 0; type < IF_COUNT && strcmp(buf, if_name[type]); type++)\n\n            ;\n\n        if (type == IF_COUNT) {\n\n            error_report(\"unsupported bus type '%s'\", buf);\n\n            return NULL;\n\n\t}\n\n    } else {\n\n        type = block_default_type;\n\n    }\n\n\n\n    max_devs = if_max_devs[type];\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1) {\n\n            error_report(\"invalid physical cyls number\");\n\n\t    return NULL;\n\n\t}\n\n        if (heads < 1) {\n\n            error_report(\"invalid physical heads number\");\n\n\t    return NULL;\n\n\t}\n\n        if (secs < 1) {\n\n            error_report(\"invalid physical secs number\");\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"trans\")) != NULL) {\n\n        if (!cyls) {\n\n            error_report(\"'%s' trans must be used with cyls, heads and secs\",\n\n                         buf);\n\n            return NULL;\n\n        }\n\n        if (!strcmp(buf, \"none\"))\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        else if (!strcmp(buf, \"lba\"))\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        else if (!strcmp(buf, \"auto\"))\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\telse {\n\n            error_report(\"'%s' invalid translation type\", buf);\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"media\")) != NULL) {\n\n        if (!strcmp(buf, \"disk\")) {\n\n\t    media = MEDIA_DISK;\n\n\t} else if (!strcmp(buf, \"cdrom\")) {\n\n            if (cyls || secs || heads) {\n\n                error_report(\"CHS can't be set with media=%s\", buf);\n\n\t        return NULL;\n\n            }\n\n\t    media = MEDIA_CDROM;\n\n\t} else {\n\n\t    error_report(\"'%s' invalid media\", buf);\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"discard\")) != NULL) {\n\n        if (bdrv_parse_discard_flags(buf, &bdrv_flags) != 0) {\n\n            error_report(\"invalid discard option\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    bdrv_flags |= BDRV_O_CACHE_WB;\n\n    if ((buf = qemu_opt_get(opts, \"cache\")) != NULL) {\n\n        if (bdrv_parse_cache_flags(buf, &bdrv_flags) != 0) {\n\n            error_report(\"invalid cache option\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n#ifdef CONFIG_LINUX_AIO\n\n    if ((buf = qemu_opt_get(opts, \"aio\")) != NULL) {\n\n        if (!strcmp(buf, \"native\")) {\n\n            bdrv_flags |= BDRV_O_NATIVE_AIO;\n\n        } else if (!strcmp(buf, \"threads\")) {\n\n            /* this is the default */\n\n        } else {\n\n           error_report(\"invalid aio option\");\n\n           return NULL;\n\n        }\n\n    }\n\n#endif\n\n\n\n    if ((buf = qemu_opt_get(opts, \"format\")) != NULL) {\n\n        if (is_help_option(buf)) {\n\n            error_printf(\"Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            error_printf(\"\\n\");\n\n            return NULL;\n\n        }\n\n        drv = bdrv_find_whitelisted_format(buf);\n\n        if (!drv) {\n\n            error_report(\"'%s' invalid format\", buf);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* disk I/O throttling */\n\n    io_limits.bps[BLOCK_IO_LIMIT_TOTAL]  =\n\n                           qemu_opt_get_number(opts, \"bps\", 0);\n\n    io_limits.bps[BLOCK_IO_LIMIT_READ]   =\n\n                           qemu_opt_get_number(opts, \"bps_rd\", 0);\n\n    io_limits.bps[BLOCK_IO_LIMIT_WRITE]  =\n\n                           qemu_opt_get_number(opts, \"bps_wr\", 0);\n\n    io_limits.iops[BLOCK_IO_LIMIT_TOTAL] =\n\n                           qemu_opt_get_number(opts, \"iops\", 0);\n\n    io_limits.iops[BLOCK_IO_LIMIT_READ]  =\n\n                           qemu_opt_get_number(opts, \"iops_rd\", 0);\n\n    io_limits.iops[BLOCK_IO_LIMIT_WRITE] =\n\n                           qemu_opt_get_number(opts, \"iops_wr\", 0);\n\n\n\n    if (!do_check_io_limits(&io_limits, &error)) {\n\n        error_report(\"%s\", error_get_pretty(error));\n\n        error_free(error);\n\n        return NULL;\n\n    }\n\n\n\n    if (qemu_opt_get(opts, \"boot\") != NULL) {\n\n        fprintf(stderr, \"qemu-kvm: boot=on|off is deprecated and will be \"\n\n                \"ignored. Future versions will reject this parameter. Please \"\n\n                \"update your scripts.\\n\");\n\n    }\n\n\n\n    on_write_error = BLOCKDEV_ON_ERROR_ENOSPC;\n\n    if ((buf = qemu_opt_get(opts, \"werror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO && type != IF_NONE) {\n\n            error_report(\"werror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_write_error = parse_block_error_action(buf, 0);\n\n        if (on_write_error < 0) {\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    on_read_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    if ((buf = qemu_opt_get(opts, \"rerror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_VIRTIO && type != IF_SCSI && type != IF_NONE) {\n\n            error_report(\"rerror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_read_error = parse_block_error_action(buf, 1);\n\n        if (on_read_error < 0) {\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if ((devaddr = qemu_opt_get(opts, \"addr\")) != NULL) {\n\n        if (type != IF_VIRTIO) {\n\n            error_report(\"addr is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* compute bus and unit according index */\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            error_report(\"index cannot be used with bus and unit\");\n\n            return NULL;\n\n        }\n\n        bus_id = drive_index_to_bus_id(type, index);\n\n        unit_id = drive_index_to_unit_id(type, index);\n\n    }\n\n\n\n    /* if user doesn't specify a unit_id,\n\n     * try to find the first free\n\n     */\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get(type, bus_id, unit_id) != NULL) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    /* check unit id */\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        error_report(\"unit %d too big (max is %d)\",\n\n                     unit_id, max_devs - 1);\n\n        return NULL;\n\n    }\n\n\n\n    /*\n\n     * catch multiple definitions\n\n     */\n\n\n\n    if (drive_get(type, bus_id, unit_id) != NULL) {\n\n        error_report(\"drive with bus=%d, unit=%d (index=%d) exists\",\n\n                     bus_id, unit_id, index);\n\n        return NULL;\n\n    }\n\n\n\n    /* init */\n\n\n\n    dinfo = g_malloc0(sizeof(*dinfo));\n\n    if ((buf = qemu_opts_id(opts)) != NULL) {\n\n        dinfo->id = g_strdup(buf);\n\n    } else {\n\n        /* no id supplied -> create one */\n\n        dinfo->id = g_malloc0(32);\n\n        if (type == IF_IDE || type == IF_SCSI)\n\n            mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n        if (max_devs)\n\n            snprintf(dinfo->id, 32, \"%s%i%s%i\",\n\n                     if_name[type], bus_id, mediastr, unit_id);\n\n        else\n\n            snprintf(dinfo->id, 32, \"%s%s%i\",\n\n                     if_name[type], mediastr, unit_id);\n\n    }\n\n    dinfo->bdrv = bdrv_new(dinfo->id);\n\n    dinfo->bdrv->open_flags = snapshot ? BDRV_O_SNAPSHOT : 0;\n\n    dinfo->bdrv->read_only = ro;\n\n    dinfo->devaddr = devaddr;\n\n    dinfo->type = type;\n\n    dinfo->bus = bus_id;\n\n    dinfo->unit = unit_id;\n\n    dinfo->cyls = cyls;\n\n    dinfo->heads = heads;\n\n    dinfo->secs = secs;\n\n    dinfo->trans = translation;\n\n    dinfo->opts = opts;\n\n    dinfo->refcount = 1;\n\n    dinfo->serial = serial;\n\n    QTAILQ_INSERT_TAIL(&drives, dinfo, next);\n\n\n\n    bdrv_set_on_error(dinfo->bdrv, on_read_error, on_write_error);\n\n\n\n    /* disk I/O throttling */\n\n    bdrv_set_io_limits(dinfo->bdrv, &io_limits);\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n    case IF_NONE:\n\n        dinfo->media_cd = media == MEDIA_CDROM;\n\n        break;\n\n    case IF_SD:\n\n    case IF_FLOPPY:\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n        break;\n\n    case IF_VIRTIO:\n\n        /* add virtio block device */\n\n        opts = qemu_opts_create_nofail(qemu_find_opts(\"device\"));\n\n        if (arch_type == QEMU_ARCH_S390X) {\n\n            qemu_opt_set(opts, \"driver\", \"virtio-blk-s390\");\n\n        } else {\n\n            qemu_opt_set(opts, \"driver\", \"virtio-blk-pci\");\n\n        }\n\n        qemu_opt_set(opts, \"drive\", dinfo->id);\n\n        if (devaddr)\n\n            qemu_opt_set(opts, \"addr\", devaddr);\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    if (!file || !*file) {\n\n        return dinfo;\n\n    }\n\n    if (snapshot) {\n\n        /* always use cache=unsafe with snapshot */\n\n        bdrv_flags &= ~BDRV_O_CACHE_MASK;\n\n        bdrv_flags |= (BDRV_O_SNAPSHOT|BDRV_O_CACHE_WB|BDRV_O_NO_FLUSH);\n\n    }\n\n\n\n    if (copy_on_read) {\n\n        bdrv_flags |= BDRV_O_COPY_ON_READ;\n\n    }\n\n\n\n    if (runstate_check(RUN_STATE_INMIGRATE)) {\n\n        bdrv_flags |= BDRV_O_INCOMING;\n\n    }\n\n\n\n    if (media == MEDIA_CDROM) {\n\n        /* CDROM is fine for any interface, don't check.  */\n\n        ro = 1;\n\n    } else if (ro == 1) {\n\n        if (type != IF_SCSI && type != IF_VIRTIO && type != IF_FLOPPY &&\n\n            type != IF_NONE && type != IF_PFLASH) {\n\n            error_report(\"readonly not supported by this bus type\");\n\n            goto err;\n\n        }\n\n    }\n\n\n\n    bdrv_flags |= ro ? 0 : BDRV_O_RDWR;\n\n\n\n    if (ro && copy_on_read) {\n\n        error_report(\"warning: disabling copy_on_read on readonly drive\");\n\n    }\n\n\n\n    ret = bdrv_open(dinfo->bdrv, file, NULL, bdrv_flags, drv);\n\n    if (ret < 0) {\n\n        if (ret == -EMEDIUMTYPE) {\n\n            error_report(\"could not open disk image %s: not in %s format\",\n\n                         file, drv->format_name);\n\n        } else {\n\n            error_report(\"could not open disk image %s: %s\",\n\n                         file, strerror(-ret));\n\n        }\n\n        goto err;\n\n    }\n\n\n\n    if (bdrv_key_required(dinfo->bdrv))\n\n        autostart = 0;\n\n    return dinfo;\n\n\n\nerr:\n\n    bdrv_delete(dinfo->bdrv);\n\n    g_free(dinfo->id);\n\n    QTAILQ_REMOVE(&drives, dinfo, next);\n\n    g_free(dinfo);\n\n    return NULL;\n\n}\n", "idx": 22801}
{"project": "qemu", "commit_id": "3e353773721596971db2d0abc7015e7ea3d3af07", "target": 1, "func": "int boot_sector_init(const char *fname)\n\n{\n\n    FILE *f = fopen(fname, \"w\");\n\n    size_t len = sizeof boot_sector;\n\n\n\n    if (!f) {\n\n        fprintf(stderr, \"Couldn't open \\\"%s\\\": %s\", fname, strerror(errno));\n\n        return 1;\n\n    }\n\n\n\n    /* For Open Firmware based system, we can use a Forth script instead */\n\n    if (strcmp(qtest_get_arch(), \"ppc64\") == 0) {\n\n        len = sprintf((char *)boot_sector, \"\\\\ Bootscript\\n%x %x c! %x %x c!\\n\",\n\n                LOW(SIGNATURE), BOOT_SECTOR_ADDRESS + SIGNATURE_OFFSET,\n\n                HIGH(SIGNATURE), BOOT_SECTOR_ADDRESS + SIGNATURE_OFFSET + 1);\n\n    }\n\n\n\n    fwrite(boot_sector, 1, len, f);\n\n    fclose(f);\n\n    return 0;\n\n}\n", "idx": 22802}
{"project": "qemu", "commit_id": "7798a8828a654ce438584bdfccaa3e8a120cf998", "target": 1, "func": "static void timer_enable(struct xlx_timer *xt)\n\n{\n\n    uint64_t count;\n\n\n\n    D(printf(\"%s timer=%d down=%d\\n\", __func__,\n\n              xt->nr, xt->regs[R_TCSR] & TCSR_UDT));\n\n\n\n    ptimer_stop(xt->ptimer);\n\n\n\n    if (xt->regs[R_TCSR] & TCSR_UDT)\n\n        count = xt->regs[R_TLR];\n\n    else\n\n        count = ~0 - xt->regs[R_TLR];\n\n    ptimer_set_count(xt->ptimer, count);\n\n    ptimer_run(xt->ptimer, 1);\n\n}\n", "idx": 22804}
{"project": "qemu", "commit_id": "d87aa138039a4be6d705793fd3e397c69c52405a", "target": 1, "func": "static int colo_packet_compare_tcp(Packet *spkt, Packet *ppkt)\n\n{\n\n    struct tcphdr *ptcp, *stcp;\n\n    int res;\n\n\n\n    trace_colo_compare_main(\"compare tcp\");\n\n\n\n    ptcp = (struct tcphdr *)ppkt->transport_header;\n\n    stcp = (struct tcphdr *)spkt->transport_header;\n\n\n\n    /*\n\n     * The 'identification' field in the IP header is *very* random\n\n     * it almost never matches.  Fudge this by ignoring differences in\n\n     * unfragmented packets; they'll normally sort themselves out if different\n\n     * anyway, and it should recover at the TCP level.\n\n     * An alternative would be to get both the primary and secondary to rewrite\n\n     * somehow; but that would need some sync traffic to sync the state\n\n     */\n\n    if (ntohs(ppkt->ip->ip_off) & IP_DF) {\n\n        spkt->ip->ip_id = ppkt->ip->ip_id;\n\n        /* and the sum will be different if the IDs were different */\n\n        spkt->ip->ip_sum = ppkt->ip->ip_sum;\n\n    }\n\n\n\n    /*\n\n     * Check tcp header length for tcp option field.\n\n     * th_off > 5 means this tcp packet have options field.\n\n     * The tcp options maybe always different.\n\n     * for example:\n\n     * From RFC 7323.\n\n     * TCP Timestamps option (TSopt):\n\n     * Kind: 8\n\n     *\n\n     * Length: 10 bytes\n\n     *\n\n     *    +-------+-------+---------------------+---------------------+\n\n     *    |Kind=8 |  10   |   TS Value (TSval)  |TS Echo Reply (TSecr)|\n\n     *    +-------+-------+---------------------+---------------------+\n\n     *       1       1              4                     4\n\n     *\n\n     * In this case the primary guest's timestamp always different with\n\n     * the secondary guest's timestamp. COLO just focus on payload,\n\n     * so we just need skip this field.\n\n     */\n\n    if (ptcp->th_off > 5) {\n\n        ptrdiff_t tcp_offset;\n\n\n\n        tcp_offset = ppkt->transport_header - (uint8_t *)ppkt->data\n\n                     + (ptcp->th_off * 4) - ppkt->vnet_hdr_len;\n\n        res = colo_packet_compare_common(ppkt, spkt, tcp_offset);\n\n    } else if (ptcp->th_sum == stcp->th_sum) {\n\n        res = colo_packet_compare_common(ppkt, spkt, ETH_HLEN);\n\n    } else {\n\n        res = -1;\n\n    }\n\n\n\n    if (res != 0 && trace_event_get_state(TRACE_COLO_COMPARE_MISCOMPARE)) {\n\n        char pri_ip_src[20], pri_ip_dst[20], sec_ip_src[20], sec_ip_dst[20];\n\n\n\n        strcpy(pri_ip_src, inet_ntoa(ppkt->ip->ip_src));\n\n        strcpy(pri_ip_dst, inet_ntoa(ppkt->ip->ip_dst));\n\n        strcpy(sec_ip_src, inet_ntoa(spkt->ip->ip_src));\n\n        strcpy(sec_ip_dst, inet_ntoa(spkt->ip->ip_dst));\n\n\n\n        trace_colo_compare_ip_info(ppkt->size, pri_ip_src,\n\n                                   pri_ip_dst, spkt->size,\n\n                                   sec_ip_src, sec_ip_dst);\n\n\n\n        trace_colo_compare_tcp_info(\"pri tcp packet\",\n\n                                    ntohl(ptcp->th_seq),\n\n                                    ntohl(ptcp->th_ack),\n\n                                    res, ptcp->th_flags,\n\n                                    ppkt->size);\n\n\n\n        trace_colo_compare_tcp_info(\"sec tcp packet\",\n\n                                    ntohl(stcp->th_seq),\n\n                                    ntohl(stcp->th_ack),\n\n                                    res, stcp->th_flags,\n\n                                    spkt->size);\n\n\n\n        qemu_hexdump((char *)ppkt->data, stderr,\n\n                     \"colo-compare ppkt\", ppkt->size);\n\n        qemu_hexdump((char *)spkt->data, stderr,\n\n                     \"colo-compare spkt\", spkt->size);\n\n    }\n\n\n\n    return res;\n\n}\n", "idx": 22805}
{"project": "qemu", "commit_id": "e7d81004e486b0e80a674d164d8aec0e83fa812f", "target": 1, "func": "static ssize_t handle_aiocb_ioctl(struct qemu_paiocb *aiocb)\n\n{\n\n    int ret;\n\n\n\n    ret = ioctl(aiocb->aio_fildes, aiocb->aio_ioctl_cmd, aiocb->aio_ioctl_buf);\n\n    if (ret == -1)\n\n        return -errno;\n\n\n\n    /*\n\n     * This looks weird, but the aio code only consideres a request\n\n     * successful if it has written the number full number of bytes.\n\n     *\n\n     * Now we overload aio_nbytes as aio_ioctl_cmd for the ioctl command,\n\n     * so in fact we return the ioctl command here to make posix_aio_read()\n\n     * happy..\n\n     */\n\n    return aiocb->aio_nbytes;\n\n}\n", "idx": 22809}
{"project": "qemu", "commit_id": "0142f88bff3dd5cb819c9900da1c1e0a4aae9c44", "target": 1, "func": "static void ide_test_quit(void)\n\n{\n\n\n\n    qtest_end();\n\n}", "idx": 22813}
{"project": "qemu", "commit_id": "0b2c1beea4358e40d1049b8ee019408ce96b37ce", "target": 1, "func": "static const char *keyval_parse_one(QDict *qdict, const char *params,\n\n                                    const char *implied_key,\n\n                                    Error **errp)\n\n{\n\n    const char *key, *key_end, *s;\n\n    size_t len;\n\n    char key_in_cur[128];\n\n    QDict *cur;\n\n    int ret;\n\n    QObject *next;\n\n    QString *val;\n\n\n\n    key = params;\n\n    len = strcspn(params, \"=,\");\n\n    if (implied_key && len && key[len] != '=') {\n\n        /* Desugar implied key */\n\n        key = implied_key;\n\n        len = strlen(implied_key);\n\n    }\n\n    key_end = key + len;\n\n\n\n    /*\n\n     * Loop over key fragments: @s points to current fragment, it\n\n     * applies to @cur.  @key_in_cur[] holds the previous fragment.\n\n     */\n\n    cur = qdict;\n\n    s = key;\n\n    for (;;) {\n\n        ret = parse_qapi_name(s, false);\n\n        len = ret < 0 ? 0 : ret;\n\n        assert(s + len <= key_end);\n\n        if (!len || (s + len < key_end && s[len] != '.')) {\n\n            assert(key != implied_key);\n\n            error_setg(errp, \"Invalid parameter '%.*s'\",\n\n                       (int)(key_end - key), key);\n\n            return NULL;\n\n        }\n\n        if (len >= sizeof(key_in_cur)) {\n\n            assert(key != implied_key);\n\n            error_setg(errp, \"Parameter%s '%.*s' is too long\",\n\n                       s != key || s + len != key_end ? \" fragment\" : \"\",\n\n                       (int)len, s);\n\n            return NULL;\n\n        }\n\n\n\n        if (s != key) {\n\n            next = keyval_parse_put(cur, key_in_cur, NULL,\n\n                                    key, s - 1, errp);\n\n            if (!next) {\n\n                return NULL;\n\n            }\n\n            cur = qobject_to_qdict(next);\n\n            assert(cur);\n\n        }\n\n\n\n        memcpy(key_in_cur, s, len);\n\n        key_in_cur[len] = 0;\n\n        s += len;\n\n\n\n        if (*s != '.') {\n\n            break;\n\n        }\n\n        s++;\n\n    }\n\n\n\n    if (key == implied_key) {\n\n        assert(!*s);\n\n        s = params;\n\n    } else {\n\n        if (*s != '=') {\n\n            error_setg(errp, \"Expected '=' after parameter '%.*s'\",\n\n                       (int)(s - key), key);\n\n            return NULL;\n\n        }\n\n        s++;\n\n    }\n\n\n\n    val = qstring_new();\n\n    for (;;) {\n\n        if (!*s) {\n\n            break;\n\n        } else if (*s == ',') {\n\n            s++;\n\n            if (*s != ',') {\n\n                break;\n\n            }\n\n        }\n\n        qstring_append_chr(val, *s++);\n\n    }\n\n\n\n    if (!keyval_parse_put(cur, key_in_cur, val, key, key_end, errp)) {\n\n        return NULL;\n\n    }\n\n    return s;\n\n}\n", "idx": 22815}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void mcf5208evb_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    M68kCPU *cpu;\n\n    CPUM68KState *env;\n\n    int kernel_size;\n\n    uint64_t elf_entry;\n\n    hwaddr entry;\n\n    qemu_irq *pic;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *sram = g_new(MemoryRegion, 1);\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"m5208\";\n\n    }\n\n    cpu = M68K_CPU(cpu_generic_init(TYPE_M68K_CPU, cpu_model));\n\n    if (!cpu) {\n\n        fprintf(stderr, \"Unable to find m68k CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    /* Initialize CPU registers.  */\n\n    env->vbr = 0;\n\n    /* TODO: Configure BARs.  */\n\n\n\n    /* DRAM at 0x40000000 */\n\n    memory_region_allocate_system_memory(ram, NULL, \"mcf5208.ram\", ram_size);\n\n    memory_region_add_subregion(address_space_mem, 0x40000000, ram);\n\n\n\n    /* Internal SRAM.  */\n\n    memory_region_init_ram(sram, NULL, \"mcf5208.sram\", 16384, &error_fatal);\n\n    memory_region_add_subregion(address_space_mem, 0x80000000, sram);\n\n\n\n    /* Internal peripherals.  */\n\n    pic = mcf_intc_init(address_space_mem, 0xfc048000, cpu);\n\n\n\n    mcf_uart_mm_init(0xfc060000, pic[26], serial_hds[0]);\n\n    mcf_uart_mm_init(0xfc064000, pic[27], serial_hds[1]);\n\n    mcf_uart_mm_init(0xfc068000, pic[28], serial_hds[2]);\n\n\n\n    mcf5208_sys_init(address_space_mem, pic);\n\n\n\n    if (nb_nics > 1) {\n\n        fprintf(stderr, \"Too many NICs\\n\");\n\n        exit(1);\n\n    }\n\n    if (nd_table[0].used) {\n\n        mcf_fec_init(address_space_mem, &nd_table[0],\n\n                     0xfc030000, pic + 36);\n\n    }\n\n\n\n    /*  0xfc000000 SCM.  */\n\n    /*  0xfc004000 XBS.  */\n\n    /*  0xfc008000 FlexBus CS.  */\n\n    /* 0xfc030000 FEC.  */\n\n    /*  0xfc040000 SCM + Power management.  */\n\n    /*  0xfc044000 eDMA.  */\n\n    /* 0xfc048000 INTC.  */\n\n    /*  0xfc058000 I2C.  */\n\n    /*  0xfc05c000 QSPI.  */\n\n    /* 0xfc060000 UART0.  */\n\n    /* 0xfc064000 UART0.  */\n\n    /* 0xfc068000 UART0.  */\n\n    /*  0xfc070000 DMA timers.  */\n\n    /* 0xfc080000 PIT0.  */\n\n    /* 0xfc084000 PIT1.  */\n\n    /*  0xfc088000 EPORT.  */\n\n    /*  0xfc08c000 Watchdog.  */\n\n    /*  0xfc090000 clock module.  */\n\n    /*  0xfc0a0000 CCM + reset.  */\n\n    /*  0xfc0a4000 GPIO.  */\n\n    /* 0xfc0a8000 SDRAM controller.  */\n\n\n\n    /* Load kernel.  */\n\n    if (!kernel_filename) {\n\n        if (qtest_enabled()) {\n\n            return;\n\n        }\n\n        fprintf(stderr, \"Kernel image must be specified\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n\n                           NULL, NULL, 1, EM_68K, 0, 0);\n\n    entry = elf_entry;\n\n    if (kernel_size < 0) {\n\n        kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL,\n\n                                  NULL, NULL);\n\n    }\n\n    if (kernel_size < 0) {\n\n        kernel_size = load_image_targphys(kernel_filename, 0x40000000,\n\n                                          ram_size);\n\n        entry = 0x40000000;\n\n    }\n\n    if (kernel_size < 0) {\n\n        fprintf(stderr, \"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n        exit(1);\n\n    }\n\n\n\n    env->pc = entry;\n\n}\n", "idx": 22816}
{"project": "qemu", "commit_id": "94ef4f337fb614f18b765a8e0e878a4c23cdedcd", "target": 1, "func": "static void vga_get_text_resolution(VGACommonState *s, int *pwidth, int *pheight,\n\n                                    int *pcwidth, int *pcheight)\n\n{\n\n    int width, cwidth, height, cheight;\n\n\n\n    /* total width & height */\n\n    cheight = (s->cr[VGA_CRTC_MAX_SCAN] & 0x1f) + 1;\n\n    cwidth = 8;\n\n    if (!(s->sr[VGA_SEQ_CLOCK_MODE] & VGA_SR01_CHAR_CLK_8DOTS)) {\n\n        cwidth = 9;\n\n    }\n\n    if (s->sr[VGA_SEQ_CLOCK_MODE] & 0x08) {\n\n        cwidth = 16; /* NOTE: no 18 pixel wide */\n\n    }\n\n    width = (s->cr[VGA_CRTC_H_DISP] + 1);\n\n    if (s->cr[VGA_CRTC_V_TOTAL] == 100) {\n\n        /* ugly hack for CGA 160x100x16 - explain me the logic */\n\n        height = 100;\n\n    } else {\n\n        height = s->cr[VGA_CRTC_V_DISP_END] |\n\n            ((s->cr[VGA_CRTC_OVERFLOW] & 0x02) << 7) |\n\n            ((s->cr[VGA_CRTC_OVERFLOW] & 0x40) << 3);\n\n        height = (height + 1) / cheight;\n\n    }\n\n\n\n    *pwidth = width;\n\n    *pheight = height;\n\n    *pcwidth = cwidth;\n\n    *pcheight = cheight;\n\n}\n", "idx": 22817}
{"project": "qemu", "commit_id": "47ad35f16ae4b6b93cbfa238d51d4edc7dea90b5", "target": 1, "func": "static inline void gen_op_clear_ieee_excp_and_FTT(void)\n\n{\n\n    tcg_gen_andi_tl(cpu_fsr, cpu_fsr, ~(FSR_FTT_MASK | FSR_CEXC_MASK));\n\n}\n", "idx": 22830}
{"project": "qemu", "commit_id": "8f770d39056c797a0a3de7a9a1a00befddfb088a", "target": 1, "func": "static void object_set_link_property(Object *obj, Visitor *v, void *opaque,\n\n                                     const char *name, Error **errp)\n\n{\n\n    Object **child = opaque;\n\n    bool ambiguous = false;\n\n    const char *type;\n\n    char *path;\n\n\n\n    type = object_property_get_type(obj, name, NULL);\n\n\n\n    visit_type_str(v, &path, name, errp);\n\n\n\n    if (*child) {\n\n        object_unref(*child);\n\n    }\n\n\n\n    if (strcmp(path, \"\") != 0) {\n\n        Object *target;\n\n\n\n        target = object_resolve_path(path, &ambiguous);\n\n        if (target) {\n\n            gchar *target_type;\n\n\n\n            target_type = g_strdup(&type[5]);\n\n            target_type[strlen(target_type) - 2] = 0;\n\n\n\n            if (object_dynamic_cast(target, target_type)) {\n\n                object_ref(target);\n\n                *child = target;\n\n            } else {\n\n                error_set(errp, QERR_INVALID_PARAMETER_TYPE, name, type);\n\n            }\n\n\n\n            g_free(target_type);\n\n        } else {\n\n            error_set(errp, QERR_DEVICE_NOT_FOUND, path);\n\n        }\n\n    } else {\n\n        *child = NULL;\n\n    }\n\n\n\n    g_free(path);\n\n}\n", "idx": 22832}
{"project": "qemu", "commit_id": "a879125b47c3ae554c01824f996a64a45a86556e", "target": 1, "func": "static uint32_t qpci_pc_config_readl(QPCIBus *bus, int devfn, uint8_t offset)\n\n{\n\n    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);\n\n    return inl(0xcfc);\n\n}\n", "idx": 22834}
{"project": "qemu", "commit_id": "a942d8fa01f65279cdc135f4294db611bbc088ef", "target": 1, "func": "static void json_message_process_token(JSONLexer *lexer, GString *input,\n\n                                       JSONTokenType type, int x, int y)\n\n{\n\n    JSONMessageParser *parser = container_of(lexer, JSONMessageParser, lexer);\n\n    JSONToken *token;\n\n\n\n    switch (type) {\n\n    case JSON_LCURLY:\n\n        parser->brace_count++;\n\n        break;\n\n    case JSON_RCURLY:\n\n        parser->brace_count--;\n\n        break;\n\n    case JSON_LSQUARE:\n\n        parser->bracket_count++;\n\n        break;\n\n    case JSON_RSQUARE:\n\n        parser->bracket_count--;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    token = g_malloc(sizeof(JSONToken) + input->len + 1);\n\n    token->type = type;\n\n    memcpy(token->str, input->str, input->len);\n\n    token->str[input->len] = 0;\n\n    token->x = x;\n\n    token->y = y;\n\n\n\n    parser->token_size += input->len;\n\n\n\n    g_queue_push_tail(parser->tokens, token);\n\n\n\n    if (type == JSON_ERROR) {\n\n        goto out_emit_bad;\n\n    } else if (parser->brace_count < 0 ||\n\n        parser->bracket_count < 0 ||\n\n        (parser->brace_count == 0 &&\n\n         parser->bracket_count == 0)) {\n\n        goto out_emit;\n\n    } else if (parser->token_size > MAX_TOKEN_SIZE ||\n\n               g_queue_get_length(parser->tokens) > MAX_TOKEN_COUNT ||\n\n               parser->bracket_count + parser->brace_count > MAX_NESTING) {\n\n        /* Security consideration, we limit total memory allocated per object\n\n         * and the maximum recursion depth that a message can force.\n\n         */\n\n        goto out_emit_bad;\n\n    }\n\n\n\n    return;\n\n\n\nout_emit_bad:\n\n    /*\n\n     * Clear out token list and tell the parser to emit an error\n\n     * indication by passing it a NULL list\n\n     */\n\n    json_message_free_tokens(parser);\n\nout_emit:\n\n    /* send current list of tokens to parser and reset tokenizer */\n\n    parser->brace_count = 0;\n\n    parser->bracket_count = 0;\n\n    /* parser->emit takes ownership of parser->tokens.  */\n\n    parser->emit(parser, parser->tokens);\n\n    parser->tokens = g_queue_new();\n\n    parser->token_size = 0;\n\n}\n", "idx": 22836}
{"project": "qemu", "commit_id": "cb5ef3fa1871522a0886627033459e94bd537fb7", "target": 1, "func": "static int tmp105_tx(I2CSlave *i2c, uint8_t data)\n\n{\n\n    TMP105State *s = (TMP105State *) i2c;\n\n\n\n    if (!s->len ++)\n\n        s->pointer = data;\n\n    else {\n\n        if (s->len <= 2)\n\n            s->buf[s->len - 1] = data;\n\n        tmp105_write(s);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 22837}
{"project": "qemu", "commit_id": "baf905e580ab9c8eaf228822c4a7b257493b4998", "target": 1, "func": "static void test_blk_write(BlockBackend *blk, long pattern, int64_t offset,\n\n                           int64_t count, bool expect_failed)\n\n{\n\n    void *pattern_buf = NULL;\n\n    QEMUIOVector qiov;\n\n    int async_ret = NOT_DONE;\n\n\n\n    pattern_buf = g_malloc(count);\n\n    if (pattern) {\n\n        memset(pattern_buf, pattern, count);\n\n    } else {\n\n        memset(pattern_buf, 0x00, count);\n\n    }\n\n\n\n    qemu_iovec_init(&qiov, 1);\n\n    qemu_iovec_add(&qiov, pattern_buf, count);\n\n\n\n    blk_aio_pwritev(blk, offset, &qiov, 0, blk_rw_done, &async_ret);\n\n    while (async_ret == NOT_DONE) {\n\n        main_loop_wait(false);\n\n    }\n\n\n\n    if (expect_failed) {\n\n        g_assert(async_ret != 0);\n\n    } else {\n\n        g_assert(async_ret == 0);\n\n    }\n\n\n\n    g_free(pattern_buf);\n\n\n}", "idx": 22838}
{"project": "qemu", "commit_id": "5ac2731cf821a7ecae90786d9052891afb09dfc2", "target": 1, "func": "void usb_packet_set_state(USBPacket *p, USBPacketState state)\n\n{\n\n    static const char *name[] = {\n\n        [USB_PACKET_UNDEFINED] = \"undef\",\n\n        [USB_PACKET_SETUP]     = \"setup\",\n\n        [USB_PACKET_QUEUED]    = \"queued\",\n\n        [USB_PACKET_ASYNC]     = \"async\",\n\n        [USB_PACKET_COMPLETE]  = \"complete\",\n\n        [USB_PACKET_CANCELED]  = \"canceled\",\n\n    };\n\n    USBDevice *dev = p->ep->dev;\n\n    USBBus *bus = usb_bus_from_device(dev);\n\n\n\n    trace_usb_packet_state_change(bus->busnr, dev->port->path, p->ep->nr,\n\n                                  p, name[p->state], name[state]);\n\n    p->state = state;\n\n}\n", "idx": 22839}
{"project": "qemu", "commit_id": "b952b5589a36114e06201c0d2e82c293dbad2b1f", "target": 1, "func": "void qmp_drive_mirror(const char *device, const char *target,\n\n                      bool has_format, const char *format,\n\n                      enum MirrorSyncMode sync,\n\n                      bool has_mode, enum NewImageMode mode,\n\n                      bool has_speed, int64_t speed, Error **errp)\n\n{\n\n    BlockDriverInfo bdi;\n\n    BlockDriverState *bs;\n\n    BlockDriverState *source, *target_bs;\n\n    BlockDriver *proto_drv;\n\n    BlockDriver *drv = NULL;\n\n    Error *local_err = NULL;\n\n    int flags;\n\n    uint64_t size;\n\n    int ret;\n\n\n\n    if (!has_speed) {\n\n        speed = 0;\n\n    }\n\n    if (!has_mode) {\n\n        mode = NEW_IMAGE_MODE_ABSOLUTE_PATHS;\n\n    }\n\n\n\n    bs = bdrv_find(device);\n\n    if (!bs) {\n\n        error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n\n        return;\n\n    }\n\n\n\n    if (!bdrv_is_inserted(bs)) {\n\n        error_set(errp, QERR_DEVICE_HAS_NO_MEDIUM, device);\n\n        return;\n\n    }\n\n\n\n    if (!has_format) {\n\n        format = mode == NEW_IMAGE_MODE_EXISTING ? NULL : bs->drv->format_name;\n\n    }\n\n    if (format) {\n\n        drv = bdrv_find_format(format);\n\n        if (!drv) {\n\n            error_set(errp, QERR_INVALID_BLOCK_FORMAT, format);\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (bdrv_in_use(bs)) {\n\n        error_set(errp, QERR_DEVICE_IN_USE, device);\n\n        return;\n\n    }\n\n\n\n    flags = bs->open_flags | BDRV_O_RDWR;\n\n    source = bs->backing_hd;\n\n    if (!source && sync == MIRROR_SYNC_MODE_TOP) {\n\n        sync = MIRROR_SYNC_MODE_FULL;\n\n    }\n\n\n\n    proto_drv = bdrv_find_protocol(target);\n\n    if (!proto_drv) {\n\n        error_set(errp, QERR_INVALID_BLOCK_FORMAT, format);\n\n        return;\n\n    }\n\n\n\n    if (sync == MIRROR_SYNC_MODE_FULL && mode != NEW_IMAGE_MODE_EXISTING) {\n\n        /* create new image w/o backing file */\n\n        assert(format && drv);\n\n        bdrv_get_geometry(bs, &size);\n\n        size *= 512;\n\n        ret = bdrv_img_create(target, format,\n\n                              NULL, NULL, NULL, size, flags);\n\n    } else {\n\n        switch (mode) {\n\n        case NEW_IMAGE_MODE_EXISTING:\n\n            ret = 0;\n\n            break;\n\n        case NEW_IMAGE_MODE_ABSOLUTE_PATHS:\n\n            /* create new image with backing file */\n\n            ret = bdrv_img_create(target, format,\n\n                                  source->filename,\n\n                                  source->drv->format_name,\n\n                                  NULL, -1, flags);\n\n            break;\n\n        default:\n\n            abort();\n\n        }\n\n    }\n\n\n\n    if (ret) {\n\n        error_set(errp, QERR_OPEN_FILE_FAILED, target);\n\n        return;\n\n    }\n\n\n\n    target_bs = bdrv_new(\"\");\n\n    ret = bdrv_open(target_bs, target, flags | BDRV_O_NO_BACKING, drv);\n\n\n\n    if (ret < 0) {\n\n        bdrv_delete(target_bs);\n\n        error_set(errp, QERR_OPEN_FILE_FAILED, target);\n\n        return;\n\n    }\n\n\n\n    /* We need a backing file if we will copy parts of a cluster.  */\n\n    if (bdrv_get_info(target_bs, &bdi) >= 0 && bdi.cluster_size != 0 &&\n\n        bdi.cluster_size >= BDRV_SECTORS_PER_DIRTY_CHUNK * 512) {\n\n        ret = bdrv_open_backing_file(target_bs);\n\n        if (ret < 0) {\n\n            bdrv_delete(target_bs);\n\n            error_set(errp, QERR_OPEN_FILE_FAILED, target);\n\n            return;\n\n        }\n\n    }\n\n\n\n    mirror_start(bs, target_bs, speed, sync, block_job_cb, bs, &local_err);\n\n    if (local_err != NULL) {\n\n        bdrv_delete(target_bs);\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    /* Grab a reference so hotplug does not delete the BlockDriverState from\n\n     * underneath us.\n\n     */\n\n    drive_get_ref(drive_get_by_blockdev(bs));\n\n}\n", "idx": 22841}
{"project": "qemu", "commit_id": "1d1be34d26b66069e20cbbcd798ea57763a0f152", "target": 1, "func": "static void spapr_cpu_init(sPAPRMachineState *spapr, PowerPCCPU *cpu,\n\n                           Error **errp)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    CPUState *cs = CPU(cpu);\n\n    int i;\n\n\n\n    /* Set time-base frequency to 512 MHz */\n\n    cpu_ppc_tb_init(env, SPAPR_TIMEBASE_FREQ);\n\n\n\n    /* Enable PAPR mode in TCG or KVM */\n\n\n    cpu_ppc_set_papr(cpu);\n\n\n\n    if (cpu->max_compat) {\n\n        Error *local_err = NULL;\n\n\n\n        ppc_set_compat(cpu, cpu->max_compat, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n    }\n\n\n\n    /* Set NUMA node for the added CPUs  */\n\n    i = numa_get_node_for_cpu(cs->cpu_index);\n\n    if (i < nb_numa_nodes) {\n\n            cs->numa_node = i;\n\n    }\n\n\n\n    xics_cpu_setup(spapr->xics, cpu);\n\n\n\n    qemu_register_reset(spapr_cpu_reset, cpu);\n\n    spapr_cpu_reset(cpu);\n\n}", "idx": 22843}
{"project": "qemu", "commit_id": "068abdc8a57023eeafe1025b964a50f8a39929b4", "target": 1, "func": "int ppc_find_by_name (const unsigned char *name, ppc_def_t **def)\n\n{\n\n    int i, ret;\n\n\n\n    ret = -1;\n\n    *def = NULL;\n\n    for (i = 0; strcmp(ppc_defs[i].name, \"default\") != 0; i++) {\n\n        if (strcasecmp(name, ppc_defs[i].name) == 0) {\n\n            *def = &ppc_defs[i];\n\n            ret = 0;\n\n            break;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 22845}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "static void spitz_gpio_setup(PXA2xxState *cpu, int slots)\n\n{\n\n    qemu_irq lcd_hsync;\n\n    /*\n\n     * Bad hack: We toggle the LCD hsync GPIO on every GPIO status\n\n     * read to satisfy broken guests that poll-wait for hsync.\n\n     * Simulating a real hsync event would be less practical and\n\n     * wouldn't guarantee that a guest ever exits the loop.\n\n     */\n\n    spitz_hsync = 0;\n\n    lcd_hsync = qemu_allocate_irqs(spitz_lcd_hsync_handler, cpu, 1)[0];\n\n    pxa2xx_gpio_read_notifier(cpu->gpio, lcd_hsync);\n\n    pxa2xx_lcd_vsync_notifier(cpu->lcd, lcd_hsync);\n\n\n\n    /* MMC/SD host */\n\n    pxa2xx_mmci_handlers(cpu->mmc,\n\n                    qdev_get_gpio_in(cpu->gpio, SPITZ_GPIO_SD_WP),\n\n                    qdev_get_gpio_in(cpu->gpio, SPITZ_GPIO_SD_DETECT));\n\n\n\n    /* Battery lock always closed */\n\n    qemu_irq_raise(qdev_get_gpio_in(cpu->gpio, SPITZ_GPIO_BAT_COVER));\n\n\n\n    /* Handle reset */\n\n    qdev_connect_gpio_out(cpu->gpio, SPITZ_GPIO_ON_RESET, cpu->reset);\n\n\n\n    /* PCMCIA signals: card's IRQ and Card-Detect */\n\n    if (slots >= 1)\n\n        pxa2xx_pcmcia_set_irq_cb(cpu->pcmcia[0],\n\n                        qdev_get_gpio_in(cpu->gpio, SPITZ_GPIO_CF1_IRQ),\n\n                        qdev_get_gpio_in(cpu->gpio, SPITZ_GPIO_CF1_CD));\n\n    if (slots >= 2)\n\n        pxa2xx_pcmcia_set_irq_cb(cpu->pcmcia[1],\n\n                        qdev_get_gpio_in(cpu->gpio, SPITZ_GPIO_CF2_IRQ),\n\n                        qdev_get_gpio_in(cpu->gpio, SPITZ_GPIO_CF2_CD));\n\n}\n", "idx": 22846}
{"project": "qemu", "commit_id": "1643f2b232628905e8f32965ff36a87bd53b93c5", "target": 1, "func": "int vnc_display_pw_expire(DisplayState *ds, time_t expires)\n{\n    VncDisplay *vs = ds ? (VncDisplay *)ds->opaque : vnc_display;\n    vs->expires = expires;\n    return 0;", "idx": 22847}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int usb_hub_handle_data(USBDevice *dev, USBPacket *p)\n\n{\n\n    USBHubState *s = (USBHubState *)dev;\n\n    int ret;\n\n\n\n    switch(p->pid) {\n\n    case USB_TOKEN_IN:\n\n        if (p->devep == 1) {\n\n            USBHubPort *port;\n\n            unsigned int status;\n\n            int i, n;\n\n            n = (NUM_PORTS + 1 + 7) / 8;\n\n            if (p->len == 1) { /* FreeBSD workaround */\n\n                n = 1;\n\n            } else if (n > p->len) {\n\n                return USB_RET_BABBLE;\n\n            }\n\n            status = 0;\n\n            for(i = 0; i < NUM_PORTS; i++) {\n\n                port = &s->ports[i];\n\n                if (port->wPortChange)\n\n                    status |= (1 << (i + 1));\n\n            }\n\n            if (status != 0) {\n\n                for(i = 0; i < n; i++) {\n\n                    p->data[i] = status >> (8 * i);\n\n                }\n\n                ret = n;\n\n            } else {\n\n                ret = USB_RET_NAK; /* usb11 11.13.1 */\n\n            }\n\n        } else {\n\n            goto fail;\n\n        }\n\n        break;\n\n    case USB_TOKEN_OUT:\n\n    default:\n\n    fail:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n    return ret;\n\n}\n", "idx": 22848}
{"project": "qemu", "commit_id": "0b06ef3bdd17742ae50c0662d3fe8ed944648890", "target": 1, "func": "void bdrv_drain_all(void)\n\n{\n\n    /* Always run first iteration so any pending completion BHs run */\n\n    bool busy = true;\n\n    BlockDriverState *bs;\n\n\n\n    while (busy) {\n\n        /* FIXME: We do not have timer support here, so this is effectively\n\n         * a busy wait.\n\n         */\n\n        QTAILQ_FOREACH(bs, &bdrv_states, list) {\n\n            if (bdrv_start_throttled_reqs(bs)) {\n\n                busy = true;\n\n            }\n\n        }\n\n\n\n        busy = bdrv_requests_pending_all();\n\n        busy |= aio_poll(qemu_get_aio_context(), busy);\n\n    }\n\n}\n", "idx": 22849}
{"project": "qemu", "commit_id": "548f66db33b91bf305c4e5228bb29585701ab58d", "target": 0, "func": "static void do_fbranch(DisasContext *dc, int32_t offset, uint32_t insn, int cc,\n\n                      TCGv r_cond)\n\n{\n\n    unsigned int cond = GET_FIELD(insn, 3, 6), a = (insn & (1 << 29));\n\n    target_ulong target = dc->pc + offset;\n\n\n\n    if (cond == 0x0) {\n\n        /* unconditional not taken */\n\n        if (a) {\n\n            dc->pc = dc->npc + 4;\n\n            dc->npc = dc->pc + 4;\n\n        } else {\n\n            dc->pc = dc->npc;\n\n            dc->npc = dc->pc + 4;\n\n        }\n\n    } else if (cond == 0x8) {\n\n        /* unconditional taken */\n\n        if (a) {\n\n            dc->pc = target;\n\n            dc->npc = dc->pc + 4;\n\n        } else {\n\n            dc->pc = dc->npc;\n\n            dc->npc = target;\n\n            tcg_gen_mov_tl(cpu_pc, cpu_npc);\n\n        }\n\n    } else {\n\n        flush_cond(dc, r_cond);\n\n        gen_fcond(r_cond, cc, cond);\n\n        if (a) {\n\n            gen_branch_a(dc, target, dc->npc, r_cond);\n\n            dc->is_br = 1;\n\n        } else {\n\n            dc->pc = dc->npc;\n\n            dc->jump_pc[0] = target;\n\n            dc->jump_pc[1] = dc->npc + 4;\n\n            dc->npc = JUMP_PC;\n\n        }\n\n    }\n\n}\n", "idx": 22851}
{"project": "qemu", "commit_id": "d66b969b0d9c8eefdcbff4b48535b0fe1501d139", "target": 0, "func": "static inline uint32_t vtd_slpt_level_shift(uint32_t level)\n\n{\n\n    return VTD_PAGE_SHIFT_4K + (level - 1) * VTD_SL_LEVEL_BITS;\n\n}\n", "idx": 22852}
{"project": "qemu", "commit_id": "f06a696dc958dd80f7eaf5be66fdefac77741ee0", "target": 0, "func": "static int vtd_iova_to_slpte(VTDContextEntry *ce, uint64_t iova, bool is_write,\n\n                             uint64_t *slptep, uint32_t *slpte_level,\n\n                             bool *reads, bool *writes)\n\n{\n\n    dma_addr_t addr = vtd_get_slpt_base_from_context(ce);\n\n    uint32_t level = vtd_get_level_from_context_entry(ce);\n\n    uint32_t offset;\n\n    uint64_t slpte;\n\n    uint32_t ce_agaw = vtd_get_agaw_from_context_entry(ce);\n\n    uint64_t access_right_check;\n\n\n\n    /* Check if @iova is above 2^X-1, where X is the minimum of MGAW\n\n     * in CAP_REG and AW in context-entry.\n\n     */\n\n    if (iova & ~((1ULL << MIN(ce_agaw, VTD_MGAW)) - 1)) {\n\n        VTD_DPRINTF(GENERAL, \"error: iova 0x%\"PRIx64 \" exceeds limits\", iova);\n\n        return -VTD_FR_ADDR_BEYOND_MGAW;\n\n    }\n\n\n\n    /* FIXME: what is the Atomics request here? */\n\n    access_right_check = is_write ? VTD_SL_W : VTD_SL_R;\n\n\n\n    while (true) {\n\n        offset = vtd_iova_level_offset(iova, level);\n\n        slpte = vtd_get_slpte(addr, offset);\n\n\n\n        if (slpte == (uint64_t)-1) {\n\n            VTD_DPRINTF(GENERAL, \"error: fail to access second-level paging \"\n\n                        \"entry at level %\"PRIu32 \" for iova 0x%\"PRIx64,\n\n                        level, iova);\n\n            if (level == vtd_get_level_from_context_entry(ce)) {\n\n                /* Invalid programming of context-entry */\n\n                return -VTD_FR_CONTEXT_ENTRY_INV;\n\n            } else {\n\n                return -VTD_FR_PAGING_ENTRY_INV;\n\n            }\n\n        }\n\n        *reads = (*reads) && (slpte & VTD_SL_R);\n\n        *writes = (*writes) && (slpte & VTD_SL_W);\n\n        if (!(slpte & access_right_check)) {\n\n            VTD_DPRINTF(GENERAL, \"error: lack of %s permission for \"\n\n                        \"iova 0x%\"PRIx64 \" slpte 0x%\"PRIx64,\n\n                        (is_write ? \"write\" : \"read\"), iova, slpte);\n\n            return is_write ? -VTD_FR_WRITE : -VTD_FR_READ;\n\n        }\n\n        if (vtd_slpte_nonzero_rsvd(slpte, level)) {\n\n            VTD_DPRINTF(GENERAL, \"error: non-zero reserved field in second \"\n\n                        \"level paging entry level %\"PRIu32 \" slpte 0x%\"PRIx64,\n\n                        level, slpte);\n\n            return -VTD_FR_PAGING_ENTRY_RSVD;\n\n        }\n\n\n\n        if (vtd_is_last_slpte(slpte, level)) {\n\n            *slptep = slpte;\n\n            *slpte_level = level;\n\n            return 0;\n\n        }\n\n        addr = vtd_get_slpte_addr(slpte);\n\n        level--;\n\n    }\n\n}\n", "idx": 22853}
{"project": "qemu", "commit_id": "4f5e19e6c570459cd524b29b24374f03860f5149", "target": 0, "func": "PCIBus *ppce500_pci_init(qemu_irq pci_irqs[4], target_phys_addr_t registers)\n\n{\n\n    PPCE500PCIState *controller;\n\n    PCIDevice *d;\n\n    int index;\n\n    static int ppce500_pci_id;\n\n\n\n    controller = qemu_mallocz(sizeof(PPCE500PCIState));\n\n\n\n    controller->pci_state.bus = pci_register_bus(NULL, \"pci\",\n\n                                                 mpc85xx_pci_set_irq,\n\n                                                 mpc85xx_pci_map_irq,\n\n                                                 pci_irqs, 0x88, 4);\n\n    d = pci_register_device(controller->pci_state.bus,\n\n                            \"host bridge\", sizeof(PCIDevice),\n\n                            0, NULL, NULL);\n\n\n\n    pci_config_set_vendor_id(d->config, PCI_VENDOR_ID_FREESCALE);\n\n    pci_config_set_device_id(d->config, PCI_DEVICE_ID_MPC8533E);\n\n    pci_config_set_class(d->config, PCI_CLASS_PROCESSOR_POWERPC);\n\n\n\n    controller->pci_dev = d;\n\n\n\n    /* CFGADDR */\n\n    index = cpu_register_io_memory(pcie500_cfgaddr_read,\n\n                                   pcie500_cfgaddr_write, controller);\n\n    if (index < 0)\n\n        goto free;\n\n    cpu_register_physical_memory(registers + PCIE500_CFGADDR, 4, index);\n\n\n\n    /* CFGDATA */\n\n    index = cpu_register_io_memory(pcie500_cfgdata_read,\n\n                                   pcie500_cfgdata_write,\n\n                                   &controller->pci_state);\n\n    if (index < 0)\n\n        goto free;\n\n    cpu_register_physical_memory(registers + PCIE500_CFGDATA, 4, index);\n\n\n\n    index = cpu_register_io_memory(e500_pci_reg_read,\n\n                                   e500_pci_reg_write, controller);\n\n    if (index < 0)\n\n        goto free;\n\n    cpu_register_physical_memory(registers + PCIE500_REG_BASE,\n\n                                   PCIE500_REG_SIZE, index);\n\n\n\n    /* XXX load/save code not tested. */\n\n    register_savevm(\"ppce500_pci\", ppce500_pci_id++, 1,\n\n                    ppce500_pci_save, ppce500_pci_load, controller);\n\n\n\n    return controller->pci_state.bus;\n\n\n\nfree:\n\n    printf(\"%s error\\n\", __func__);\n\n    qemu_free(controller);\n\n    return NULL;\n\n}\n", "idx": 22854}
{"project": "qemu", "commit_id": "215e79c01c4e6f766eb9add56c56453e9ea1d948", "target": 0, "func": "static bool cpu_thread_is_idle(CPUState *cpu)\n\n{\n\n    if (cpu->stop || cpu->queued_work_first) {\n\n        return false;\n\n    }\n\n    if (cpu->stopped || !runstate_is_running()) {\n\n        return true;\n\n    }\n\n    if (!cpu->halted || qemu_cpu_has_work(cpu) ||\n\n        kvm_async_interrupts_enabled()) {\n\n        return false;\n\n    }\n\n    return true;\n\n}\n", "idx": 22855}
{"project": "qemu", "commit_id": "b854bc196f5c4b4e3299c0b0ee63cf828ece9e77", "target": 0, "func": "int omap_validate_tipb_addr(struct omap_mpu_state_s *s,\n\n                target_phys_addr_t addr)\n\n{\n\n    return addr >= 0xfffb0000 && addr < 0xffff0000;\n\n}\n", "idx": 22856}
{"project": "qemu", "commit_id": "86f6ae67e157362f3b141649874213ce01dcc622", "target": 0, "func": "static int load_bitmap_data(BlockDriverState *bs,\n\n                            const uint64_t *bitmap_table,\n\n                            uint32_t bitmap_table_size,\n\n                            BdrvDirtyBitmap *bitmap)\n\n{\n\n    int ret = 0;\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t sector, sbc;\n\n    uint64_t bm_size = bdrv_dirty_bitmap_size(bitmap);\n\n    uint64_t bm_sectors = DIV_ROUND_UP(bm_size, BDRV_SECTOR_SIZE);\n\n    uint8_t *buf = NULL;\n\n    uint64_t i, tab_size =\n\n            size_to_clusters(s,\n\n                bdrv_dirty_bitmap_serialization_size(bitmap, 0, bm_sectors));\n\n\n\n    if (tab_size != bitmap_table_size || tab_size > BME_MAX_TABLE_SIZE) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    buf = g_malloc(s->cluster_size);\n\n    sbc = sectors_covered_by_bitmap_cluster(s, bitmap);\n\n    for (i = 0, sector = 0; i < tab_size; ++i, sector += sbc) {\n\n        uint64_t count = MIN(bm_sectors - sector, sbc);\n\n        uint64_t entry = bitmap_table[i];\n\n        uint64_t offset = entry & BME_TABLE_ENTRY_OFFSET_MASK;\n\n\n\n        assert(check_table_entry(entry, s->cluster_size) == 0);\n\n\n\n        if (offset == 0) {\n\n            if (entry & BME_TABLE_ENTRY_FLAG_ALL_ONES) {\n\n                bdrv_dirty_bitmap_deserialize_ones(bitmap, sector, count,\n\n                                                   false);\n\n            } else {\n\n                /* No need to deserialize zeros because the dirty bitmap is\n\n                 * already cleared */\n\n            }\n\n        } else {\n\n            ret = bdrv_pread(bs->file, offset, buf, s->cluster_size);\n\n            if (ret < 0) {\n\n                goto finish;\n\n            }\n\n            bdrv_dirty_bitmap_deserialize_part(bitmap, buf, sector, count,\n\n                                               false);\n\n        }\n\n    }\n\n    ret = 0;\n\n\n\n    bdrv_dirty_bitmap_deserialize_finish(bitmap);\n\n\n\nfinish:\n\n    g_free(buf);\n\n\n\n    return ret;\n\n}\n", "idx": 22857}
{"project": "qemu", "commit_id": "7423f417827146f956df820f172d0bf80a489495", "target": 0, "func": "static coroutine_fn int nbd_negotiate(NBDClientNewData *data)\n\n{\n\n    NBDClient *client = data->client;\n\n    char buf[8 + 8 + 8 + 128];\n\n    int rc;\n\n    const int myflags = (NBD_FLAG_HAS_FLAGS | NBD_FLAG_SEND_TRIM |\n\n                         NBD_FLAG_SEND_FLUSH | NBD_FLAG_SEND_FUA);\n\n    bool oldStyle;\n\n\n\n    /* Old style negotiation header without options\n\n        [ 0 ..   7]   passwd       (\"NBDMAGIC\")\n\n        [ 8 ..  15]   magic        (NBD_CLIENT_MAGIC)\n\n        [16 ..  23]   size\n\n        [24 ..  25]   server flags (0)\n\n        [26 ..  27]   export flags\n\n        [28 .. 151]   reserved     (0)\n\n\n\n       New style negotiation header with options\n\n        [ 0 ..   7]   passwd       (\"NBDMAGIC\")\n\n        [ 8 ..  15]   magic        (NBD_OPTS_MAGIC)\n\n        [16 ..  17]   server flags (0)\n\n        ....options sent....\n\n        [18 ..  25]   size\n\n        [26 ..  27]   export flags\n\n        [28 .. 151]   reserved     (0)\n\n     */\n\n\n\n    qio_channel_set_blocking(client->ioc, false, NULL);\n\n    rc = -EINVAL;\n\n\n\n    TRACE(\"Beginning negotiation.\");\n\n    memset(buf, 0, sizeof(buf));\n\n    memcpy(buf, \"NBDMAGIC\", 8);\n\n\n\n    oldStyle = client->exp != NULL && !client->tlscreds;\n\n    if (oldStyle) {\n\n        assert ((client->exp->nbdflags & ~65535) == 0);\n\n        TRACE(\"advertising size %\" PRIu64 \" and flags %x\",\n\n              client->exp->size, client->exp->nbdflags | myflags);\n\n        stq_be_p(buf + 8, NBD_CLIENT_MAGIC);\n\n        stq_be_p(buf + 16, client->exp->size);\n\n        stw_be_p(buf + 26, client->exp->nbdflags | myflags);\n\n    } else {\n\n        stq_be_p(buf + 8, NBD_OPTS_MAGIC);\n\n        stw_be_p(buf + 16, NBD_FLAG_FIXED_NEWSTYLE);\n\n    }\n\n\n\n    if (oldStyle) {\n\n        if (client->tlscreds) {\n\n            TRACE(\"TLS cannot be enabled with oldstyle protocol\");\n\n            goto fail;\n\n        }\n\n        if (nbd_negotiate_write(client->ioc, buf, sizeof(buf)) != sizeof(buf)) {\n\n            LOG(\"write failed\");\n\n            goto fail;\n\n        }\n\n    } else {\n\n        if (nbd_negotiate_write(client->ioc, buf, 18) != 18) {\n\n            LOG(\"write failed\");\n\n            goto fail;\n\n        }\n\n        rc = nbd_negotiate_options(client);\n\n        if (rc != 0) {\n\n            LOG(\"option negotiation failed\");\n\n            goto fail;\n\n        }\n\n\n\n        assert ((client->exp->nbdflags & ~65535) == 0);\n\n        TRACE(\"advertising size %\" PRIu64 \" and flags %x\",\n\n              client->exp->size, client->exp->nbdflags | myflags);\n\n        stq_be_p(buf + 18, client->exp->size);\n\n        stw_be_p(buf + 26, client->exp->nbdflags | myflags);\n\n        if (nbd_negotiate_write(client->ioc, buf + 18, sizeof(buf) - 18) !=\n\n            sizeof(buf) - 18) {\n\n            LOG(\"write failed\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    TRACE(\"Negotiation succeeded.\");\n\n    rc = 0;\n\nfail:\n\n    return rc;\n\n}\n", "idx": 22858}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void bdrv_io_plug(BlockDriverState *bs)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    if (drv && drv->bdrv_io_plug) {\n\n        drv->bdrv_io_plug(bs);\n\n    } else if (bs->file) {\n\n        bdrv_io_plug(bs->file);\n\n    }\n\n}\n", "idx": 22859}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void cpu_watchpoint_remove_all(CPUState *env, int mask)\n\n{\n\n    CPUWatchpoint *wp, *next;\n\n\n\n    TAILQ_FOREACH_SAFE(wp, &env->watchpoints, entry, next) {\n\n        if (wp->flags & mask)\n\n            cpu_watchpoint_remove_by_ref(env, wp);\n\n    }\n\n}\n", "idx": 22860}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static void tracked_request_begin(BdrvTrackedRequest *req,\n\n                                  BlockDriverState *bs,\n\n                                  int64_t offset,\n\n                                  unsigned int bytes, bool is_write)\n\n{\n\n    *req = (BdrvTrackedRequest){\n\n        .bs = bs,\n\n        .offset         = offset,\n\n        .bytes          = bytes,\n\n        .is_write       = is_write,\n\n        .co             = qemu_coroutine_self(),\n\n        .serialising    = false,\n\n        .overlap_offset = offset,\n\n        .overlap_bytes  = bytes,\n\n    };\n\n\n\n    qemu_co_queue_init(&req->wait_queue);\n\n\n\n    QLIST_INSERT_HEAD(&bs->tracked_requests, req, list);\n\n}\n", "idx": 22863}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static uint64_t omap_id_read(void *opaque, hwaddr addr,\n\n                             unsigned size)\n\n{\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *) opaque;\n\n\n\n    if (size != 4) {\n\n        return omap_badwidth_read32(opaque, addr);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0xfffe1800:\t/* DIE_ID_LSB */\n\n        return 0xc9581f0e;\n\n    case 0xfffe1804:\t/* DIE_ID_MSB */\n\n        return 0xa8858bfa;\n\n\n\n    case 0xfffe2000:\t/* PRODUCT_ID_LSB */\n\n        return 0x00aaaafc;\n\n    case 0xfffe2004:\t/* PRODUCT_ID_MSB */\n\n        return 0xcafeb574;\n\n\n\n    case 0xfffed400:\t/* JTAG_ID_LSB */\n\n        switch (s->mpu_model) {\n\n        case omap310:\n\n            return 0x03310315;\n\n        case omap1510:\n\n            return 0x03310115;\n\n        default:\n\n            hw_error(\"%s: bad mpu model\\n\", __FUNCTION__);\n\n        }\n\n        break;\n\n\n\n    case 0xfffed404:\t/* JTAG_ID_MSB */\n\n        switch (s->mpu_model) {\n\n        case omap310:\n\n            return 0xfb57402f;\n\n        case omap1510:\n\n            return 0xfb47002f;\n\n        default:\n\n            hw_error(\"%s: bad mpu model\\n\", __FUNCTION__);\n\n        }\n\n        break;\n\n    }\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 22864}
{"project": "qemu", "commit_id": "7102fa7073b2cefb33ab4012a11f15fbf297a74b", "target": 0, "func": "static void pc_compat_1_7(MachineState *machine)\n\n{\n\n    pc_compat_2_0(machine);\n\n    smbios_defaults = false;\n\n    gigabyte_align = false;\n\n    option_rom_has_mr = true;\n\n    x86_cpu_change_kvm_default(\"x2apic\", NULL);\n\n}\n", "idx": 22865}
{"project": "qemu", "commit_id": "63729c36924348e494d69adbbdec6fdda339b76b", "target": 0, "func": "static void v9fs_create_post_mksock(V9fsState *s, V9fsCreateState *vs,\n\n                                                                int err)\n\n{\n\n    if (err) {\n\n        err = -errno;\n\n        goto out;\n\n    }\n\n\n\n    err = v9fs_do_chmod(s, &vs->fullname, vs->perm & 0777);\n\n    v9fs_create_post_perms(s, vs, err);\n\n    return;\n\n\n\nout:\n\n    v9fs_post_create(s, vs, err);\n\n}\n", "idx": 22866}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static inline QEMUClock *qemu_clock_ptr(QEMUClockType type)\n\n{\n\n    return &qemu_clocks[type];\n\n}\n", "idx": 22867}
{"project": "qemu", "commit_id": "d6085e3ace20bc9b0fa625d8d79b22668710e217", "target": 0, "func": "void qemu_peer_set_vnet_hdr_len(NetClientState *nc, int len)\n\n{\n\n    if (!nc->peer || !nc->peer->info->set_vnet_hdr_len) {\n\n        return;\n\n    }\n\n\n\n    nc->peer->info->set_vnet_hdr_len(nc->peer, len);\n\n}\n", "idx": 22868}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "BusState *qdev_get_child_bus(DeviceState *dev, const char *name)\n\n{\n\n    BusState *bus;\n\n\n\n    LIST_FOREACH(bus, &dev->child_bus, sibling) {\n\n        if (strcmp(name, bus->name) == 0) {\n\n            return bus;\n\n        }\n\n    }\n\n    return NULL;\n\n}\n", "idx": 22869}
{"project": "qemu", "commit_id": "bc0f0674f037a01f2ce0870ad6270a356a7a8347", "target": 0, "func": "static bool e1000_mit_state_needed(void *opaque)\n\n{\n\n    E1000State *s = opaque;\n\n\n\n    return s->compat_flags & E1000_FLAG_MIT;\n\n}\n", "idx": 22870}
{"project": "qemu", "commit_id": "2374e73edafff0586cbfb67c333c5a7588f81fd5", "target": 0, "func": "void helper_ldq_l_raw(uint64_t t0, uint64_t t1)\n\n{\n\n    env->lock = t1;\n\n    ldl_raw(t1, t0);\n\n}\n", "idx": 22871}
{"project": "qemu", "commit_id": "ef1e1e0782e99c9dcf2b35e5310cdd8ca9211374", "target": 0, "func": "void xen_pt_config_delete(XenPCIPassthroughState *s)\n\n{\n\n    struct XenPTRegGroup *reg_group, *next_grp;\n\n    struct XenPTReg *reg, *next_reg;\n\n\n\n    /* free MSI/MSI-X info table */\n\n    if (s->msix) {\n\n        xen_pt_msix_delete(s);\n\n    }\n\n    if (s->msi) {\n\n        g_free(s->msi);\n\n    }\n\n\n\n    /* free all register group entry */\n\n    QLIST_FOREACH_SAFE(reg_group, &s->reg_grps, entries, next_grp) {\n\n        /* free all register entry */\n\n        QLIST_FOREACH_SAFE(reg, &reg_group->reg_tbl_list, entries, next_reg) {\n\n            QLIST_REMOVE(reg, entries);\n\n            g_free(reg);\n\n        }\n\n\n\n        QLIST_REMOVE(reg_group, entries);\n\n        g_free(reg_group);\n\n    }\n\n}\n", "idx": 22872}
{"project": "qemu", "commit_id": "d20a580bc0eac9d489884f6d2ed28105880532b6", "target": 0, "func": "static gboolean gd_scroll_event(GtkWidget *widget, GdkEventScroll *scroll,\n\n                                void *opaque)\n\n{\n\n    VirtualConsole *vc = opaque;\n\n    InputButton btn;\n\n\n\n    if (scroll->direction == GDK_SCROLL_UP) {\n\n        btn = INPUT_BUTTON_WHEEL_UP;\n\n    } else if (scroll->direction == GDK_SCROLL_DOWN) {\n\n        btn = INPUT_BUTTON_WHEEL_DOWN;\n\n    } else {\n\n        return TRUE;\n\n    }\n\n\n\n    qemu_input_queue_btn(vc->gfx.dcl.con, btn, true);\n\n    qemu_input_event_sync();\n\n    qemu_input_queue_btn(vc->gfx.dcl.con, btn, false);\n\n    qemu_input_event_sync();\n\n    return TRUE;\n\n}\n", "idx": 22874}
{"project": "qemu", "commit_id": "4cb88c3c378ae8c86c0ba53619caf6924f72239c", "target": 1, "func": "static int load_normal_reset(S390CPU *cpu)\n\n{\n\n    S390CPUClass *scc = S390_CPU_GET_CLASS(cpu);\n\n\n\n    pause_all_vcpus();\n\n    cpu_synchronize_all_states();\n\n    cpu_reset_all();\n\n\n    io_subsystem_reset();\n\n    scc->initial_cpu_reset(CPU(cpu));\n\n    scc->load_normal(CPU(cpu));\n\n    cpu_synchronize_all_post_reset();\n\n    resume_all_vcpus();\n\n    return 0;\n\n}", "idx": 22875}
{"project": "qemu", "commit_id": "ab03b63d7a9c7978d51e56c191f0b86888d121dc", "target": 1, "func": "static void v9fs_post_lcreate(V9fsState *s, V9fsLcreateState *vs, int err)\n\n{\n\n    if (err == 0) {\n\n        v9fs_string_copy(&vs->fidp->path, &vs->fullname);\n\n        stat_to_qid(&vs->stbuf, &vs->qid);\n\n        vs->offset += pdu_marshal(vs->pdu, vs->offset, \"Qd\", &vs->qid,\n\n                &vs->iounit);\n\n        err = vs->offset;\n\n    } else {\n\n        vs->fidp->fid_type = P9_FID_NONE;\n\n        close(vs->fidp->fs.fd);\n\n        err = -errno;\n\n    }\n\n\n\n    complete_pdu(s, vs->pdu, err);\n\n    v9fs_string_free(&vs->name);\n\n    v9fs_string_free(&vs->fullname);\n\n    qemu_free(vs);\n\n}\n", "idx": 22876}
{"project": "qemu", "commit_id": "8d20abe87afa735cd0ae6688bd105c7a27390343", "target": 1, "func": "static int nfs_parse_uri(const char *filename, QDict *options, Error **errp)\n\n{\n\n    URI *uri = NULL;\n\n    QueryParams *qp = NULL;\n\n    int ret = -EINVAL, i;\n\n\n\n    uri = uri_parse(filename);\n\n    if (!uri) {\n\n        error_setg(errp, \"Invalid URI specified\");\n\n        goto out;\n\n    }\n\n    if (strcmp(uri->scheme, \"nfs\") != 0) {\n\n        error_setg(errp, \"URI scheme must be 'nfs'\");\n\n        goto out;\n\n    }\n\n\n\n    if (!uri->server) {\n\n        error_setg(errp, \"missing hostname in URI\");\n\n        goto out;\n\n    }\n\n\n\n    if (!uri->path) {\n\n        error_setg(errp, \"missing file path in URI\");\n\n        goto out;\n\n    }\n\n\n\n    qp = query_params_parse(uri->query);\n\n    if (!qp) {\n\n        error_setg(errp, \"could not parse query parameters\");\n\n        goto out;\n\n    }\n\n\n\n    qdict_put(options, \"server.host\", qstring_from_str(uri->server));\n\n    qdict_put(options, \"server.type\", qstring_from_str(\"inet\"));\n\n    qdict_put(options, \"path\", qstring_from_str(uri->path));\n\n\n\n    for (i = 0; i < qp->n; i++) {\n\n        if (!qp->p[i].value) {\n\n            error_setg(errp, \"Value for NFS parameter expected: %s\",\n\n                       qp->p[i].name);\n\n            goto out;\n\n        }\n\n        if (parse_uint_full(qp->p[i].value, NULL, 0)) {\n\n            error_setg(errp, \"Illegal value for NFS parameter: %s\",\n\n                       qp->p[i].name);\n\n            goto out;\n\n        }\n\n        if (!strcmp(qp->p[i].name, \"uid\")) {\n\n            qdict_put(options, \"user\",\n\n                      qstring_from_str(qp->p[i].value));\n\n        } else if (!strcmp(qp->p[i].name, \"gid\")) {\n\n            qdict_put(options, \"group\",\n\n                      qstring_from_str(qp->p[i].value));\n\n        } else if (!strcmp(qp->p[i].name, \"tcp-syncnt\")) {\n\n            qdict_put(options, \"tcp-syn-count\",\n\n                      qstring_from_str(qp->p[i].value));\n\n        } else if (!strcmp(qp->p[i].name, \"readahead\")) {\n\n            qdict_put(options, \"readahead-size\",\n\n                      qstring_from_str(qp->p[i].value));\n\n        } else if (!strcmp(qp->p[i].name, \"pagecache\")) {\n\n            qdict_put(options, \"page-cache-size\",\n\n                      qstring_from_str(qp->p[i].value));\n\n        } else if (!strcmp(qp->p[i].name, \"debug\")) {\n\n            qdict_put(options, \"debug\",\n\n                      qstring_from_str(qp->p[i].value));\n\n        } else {\n\n            error_setg(errp, \"Unknown NFS parameter name: %s\",\n\n                       qp->p[i].name);\n\n            goto out;\n\n        }\n\n    }\n\n    ret = 0;\n\nout:\n\n    if (qp) {\n\n        query_params_free(qp);\n\n    }\n\n    if (uri) {\n\n        uri_free(uri);\n\n    }\n\n    return ret;\n\n}\n", "idx": 22877}
{"project": "qemu", "commit_id": "a1bb73849fbd7d992b6ac2cf30c034244fb2299d", "target": 1, "func": "void helper_rfi(CPUPPCState *env)\n\n{\n\n    do_rfi(env, env->spr[SPR_SRR0], env->spr[SPR_SRR1],\n\n           ~((target_ulong)0x783F0000), 1);\n\n}\n", "idx": 22878}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "QEMUFile *qemu_popen_cmd(const char *command, const char *mode)\n\n{\n\n    FILE *stdio_file;\n\n    QEMUFileStdio *s;\n\n\n\n    if (mode == NULL || (mode[0] != 'r' && mode[0] != 'w') || mode[1] != 0) {\n\n        fprintf(stderr, \"qemu_popen: Argument validity check failed\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    stdio_file = popen(command, mode);\n\n    if (stdio_file == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    s = g_malloc0(sizeof(QEMUFileStdio));\n\n\n\n    s->stdio_file = stdio_file;\n\n\n\n    if (mode[0] == 'r') {\n\n        s->file = qemu_fopen_ops(s, &stdio_pipe_read_ops);\n\n    } else {\n\n        s->file = qemu_fopen_ops(s, &stdio_pipe_write_ops);\n\n    }\n\n    return s->file;\n\n}\n", "idx": 22879}
{"project": "qemu", "commit_id": "a70dadc7f1a3e96a7179c6c3a6ccd1a0ea65760a", "target": 1, "func": "static inline void host_to_target_siginfo_noswap(target_siginfo_t *tinfo,\n\n                                                 const siginfo_t *info)\n\n{\n\n    int sig = host_to_target_signal(info->si_signo);\n\n    tinfo->si_signo = sig;\n\n    tinfo->si_errno = 0;\n\n    tinfo->si_code = info->si_code;\n\n\n\n    if (sig == TARGET_SIGILL || sig == TARGET_SIGFPE || sig == TARGET_SIGSEGV\n\n            || sig == TARGET_SIGBUS || sig == TARGET_SIGTRAP) {\n\n        /* Should never come here, but who knows. The information for\n\n           the target is irrelevant.  */\n\n        tinfo->_sifields._sigfault._addr = 0;\n\n    } else if (sig == TARGET_SIGIO) {\n\n        tinfo->_sifields._sigpoll._band = info->si_band;\n\n        tinfo->_sifields._sigpoll._fd = info->si_fd;\n\n    } else if (sig == TARGET_SIGCHLD) {\n\n        tinfo->_sifields._sigchld._pid = info->si_pid;\n\n        tinfo->_sifields._sigchld._uid = info->si_uid;\n\n        tinfo->_sifields._sigchld._status\n\n                = host_to_target_waitstatus(info->si_status);\n\n        tinfo->_sifields._sigchld._utime = info->si_utime;\n\n        tinfo->_sifields._sigchld._stime = info->si_stime;\n\n    } else if (sig >= TARGET_SIGRTMIN) {\n\n        tinfo->_sifields._rt._pid = info->si_pid;\n\n        tinfo->_sifields._rt._uid = info->si_uid;\n\n        /* XXX: potential problem if 64 bit */\n\n        tinfo->_sifields._rt._sigval.sival_ptr\n\n                = (abi_ulong)(unsigned long)info->si_value.sival_ptr;\n\n    }\n\n}\n", "idx": 22880}
{"project": "qemu", "commit_id": "ff4b91c2f7e51dab148aba4bf43c2f39f219e495", "target": 1, "func": "static int count_contiguous_clusters(uint64_t nb_clusters, int cluster_size,\n\n        uint64_t *l2_table, uint64_t mask)\n\n{\n\n    int i;\n\n    uint64_t offset = be64_to_cpu(l2_table[0]) & ~mask;\n\n\n\n    if (!offset)\n\n        return 0;\n\n\n\n    for (i = 0; i < nb_clusters; i++)\n\n        if (offset + i * cluster_size != (be64_to_cpu(l2_table[i]) & ~mask))\n\n            break;\n\n\n\n\treturn i;\n\n}\n", "idx": 22889}
{"project": "qemu", "commit_id": "f332e830e38b3ff3953ef02ac04e409ae53769c5", "target": 1, "func": "static void parse_type_str(Visitor *v, const char *name, char **obj,\n\n                           Error **errp)\n\n{\n\n    StringInputVisitor *siv = to_siv(v);\n\n    if (siv->string) {\n\n        *obj = g_strdup(siv->string);\n\n    } else {\n\n        *obj = NULL;\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"string\");\n\n    }\n\n}\n", "idx": 22892}
{"project": "qemu", "commit_id": "adb2a9b5d4d5170f0b58b9f92f816048f6b8932b", "target": 1, "func": "static void register_subpage(MemoryRegionSection *section)\n\n{\n\n    subpage_t *subpage;\n\n    target_phys_addr_t base = section->offset_within_address_space\n\n        & TARGET_PAGE_MASK;\n\n    MemoryRegionSection *existing = phys_page_find(base >> TARGET_PAGE_BITS);\n\n    MemoryRegionSection subsection = {\n\n        .offset_within_address_space = base,\n\n        .size = TARGET_PAGE_SIZE,\n\n    };\n\n    target_phys_addr_t start, end;\n\n\n\n    assert(existing->mr->subpage || existing->mr == &io_mem_unassigned);\n\n\n\n    if (!(existing->mr->subpage)) {\n\n        subpage = subpage_init(base);\n\n        subsection.mr = &subpage->iomem;\n\n        phys_page_set(base >> TARGET_PAGE_BITS, 1,\n\n                      phys_section_add(&subsection));\n\n    } else {\n\n        subpage = container_of(existing->mr, subpage_t, iomem);\n\n    }\n\n    start = section->offset_within_address_space & ~TARGET_PAGE_MASK;\n\n    end = start + section->size;\n\n    subpage_register(subpage, start, end, phys_section_add(section));\n\n}\n", "idx": 22893}
{"project": "qemu", "commit_id": "77cb0f5aafc8e6d0c6d3c339f381c9b7921648e0", "target": 1, "func": "static void adb_mouse_event(void *opaque,\n\n                            int dx1, int dy1, int dz1, int buttons_state)\n\n{\n\n    MouseState *s = opaque;\n\n\n\n    s->dx += dx1;\n\n    s->dy += dy1;\n\n    s->dz += dz1;\n\n    s->buttons_state = buttons_state;\n\n}\n", "idx": 22896}
{"project": "qemu", "commit_id": "32a1c08b60a8ac0e63b54a5793a26b5e32b36618", "target": 1, "func": "void cache_insert(PageCache *cache, uint64_t addr, uint8_t *pdata)\n{\n    CacheItem *it = NULL;\n    g_assert(cache);\n    g_assert(cache->page_cache);\n    /* actual update of entry */\n    it = cache_get_by_addr(cache, addr);\n    if (!it->it_data) {\n        cache->num_items++;\n    }\n    it->it_data = pdata;\n    it->it_age = ++cache->max_item_age;\n    it->it_addr = addr;\n}", "idx": 22897}
{"project": "qemu", "commit_id": "58a0067aa8bf1e3ccad4fc354b080502e63f9fb1", "target": 1, "func": "void replay_bh_schedule_event(QEMUBH *bh)\n\n{\n\n    if (replay_mode != REPLAY_MODE_NONE) {\n\n        uint64_t id = replay_get_current_step();\n\n        replay_add_event(REPLAY_ASYNC_EVENT_BH, bh, NULL, id);\n\n    } else {\n\n        qemu_bh_schedule(bh);\n\n    }\n\n}\n", "idx": 22898}
{"project": "qemu", "commit_id": "cedccf1381c2fd6592d6322f3cd9cc6bf6621967", "target": 1, "func": "static int blk_connect(struct XenDevice *xendev)\n\n{\n\n    struct XenBlkDev *blkdev = container_of(xendev, struct XenBlkDev, xendev);\n\n    int pers, index, qflags;\n\n    bool readonly = true;\n\n\n\n    /* read-only ? */\n\n    if (blkdev->directiosafe) {\n\n        qflags = BDRV_O_NOCACHE | BDRV_O_NATIVE_AIO;\n\n    } else {\n\n        qflags = BDRV_O_CACHE_WB;\n\n    }\n\n    if (strcmp(blkdev->mode, \"w\") == 0) {\n\n        qflags |= BDRV_O_RDWR;\n\n        readonly = false;\n\n    }\n\n    if (blkdev->feature_discard) {\n\n        qflags |= BDRV_O_UNMAP;\n\n    }\n\n\n\n    /* init qemu block driver */\n\n    index = (blkdev->xendev.dev - 202 * 256) / 16;\n\n    blkdev->dinfo = drive_get(IF_XEN, 0, index);\n\n    if (!blkdev->dinfo) {\n\n        Error *local_err = NULL;\n\n        /* setup via xenbus -> create new block driver instance */\n\n        xen_be_printf(&blkdev->xendev, 2, \"create new bdrv (xenbus setup)\\n\");\n\n        blkdev->bs = bdrv_new(blkdev->dev, &local_err);\n\n        if (local_err) {\n\n            blkdev->bs = NULL;\n\n        }\n\n        if (blkdev->bs) {\n\n            BlockDriver *drv = bdrv_find_whitelisted_format(blkdev->fileproto,\n\n                                                           readonly);\n\n            if (bdrv_open(&blkdev->bs, blkdev->filename, NULL, NULL, qflags,\n\n                          drv, &local_err) != 0)\n\n            {\n\n                xen_be_printf(&blkdev->xendev, 0, \"error: %s\\n\",\n\n                              error_get_pretty(local_err));\n\n                error_free(local_err);\n\n                bdrv_unref(blkdev->bs);\n\n                blkdev->bs = NULL;\n\n            }\n\n        }\n\n        if (!blkdev->bs) {\n\n            return -1;\n\n        }\n\n    } else {\n\n        /* setup via qemu cmdline -> already setup for us */\n\n        xen_be_printf(&blkdev->xendev, 2, \"get configured bdrv (cmdline setup)\\n\");\n\n        blkdev->bs = blkdev->dinfo->bdrv;\n\n        if (bdrv_is_read_only(blkdev->bs) && !readonly) {\n\n            xen_be_printf(&blkdev->xendev, 0, \"Unexpected read-only drive\");\n\n            blkdev->bs = NULL;\n\n            return -1;\n\n        }\n\n        /* blkdev->bs is not create by us, we get a reference\n\n         * so we can bdrv_unref() unconditionally */\n\n        bdrv_ref(blkdev->bs);\n\n    }\n\n    bdrv_attach_dev_nofail(blkdev->bs, blkdev);\n\n    blkdev->file_size = bdrv_getlength(blkdev->bs);\n\n    if (blkdev->file_size < 0) {\n\n        xen_be_printf(&blkdev->xendev, 1, \"bdrv_getlength: %d (%s) | drv %s\\n\",\n\n                      (int)blkdev->file_size, strerror(-blkdev->file_size),\n\n                      bdrv_get_format_name(blkdev->bs) ?: \"-\");\n\n        blkdev->file_size = 0;\n\n    }\n\n\n\n    xen_be_printf(xendev, 1, \"type \\\"%s\\\", fileproto \\\"%s\\\", filename \\\"%s\\\",\"\n\n                  \" size %\" PRId64 \" (%\" PRId64 \" MB)\\n\",\n\n                  blkdev->type, blkdev->fileproto, blkdev->filename,\n\n                  blkdev->file_size, blkdev->file_size >> 20);\n\n\n\n    /* Fill in number of sector size and number of sectors */\n\n    xenstore_write_be_int(&blkdev->xendev, \"sector-size\", blkdev->file_blk);\n\n    xenstore_write_be_int64(&blkdev->xendev, \"sectors\",\n\n                            blkdev->file_size / blkdev->file_blk);\n\n\n\n    if (xenstore_read_fe_int(&blkdev->xendev, \"ring-ref\", &blkdev->ring_ref) == -1) {\n\n        return -1;\n\n    }\n\n    if (xenstore_read_fe_int(&blkdev->xendev, \"event-channel\",\n\n                             &blkdev->xendev.remote_port) == -1) {\n\n        return -1;\n\n    }\n\n    if (xenstore_read_fe_int(&blkdev->xendev, \"feature-persistent\", &pers)) {\n\n        blkdev->feature_persistent = FALSE;\n\n    } else {\n\n        blkdev->feature_persistent = !!pers;\n\n    }\n\n\n\n    blkdev->protocol = BLKIF_PROTOCOL_NATIVE;\n\n    if (blkdev->xendev.protocol) {\n\n        if (strcmp(blkdev->xendev.protocol, XEN_IO_PROTO_ABI_X86_32) == 0) {\n\n            blkdev->protocol = BLKIF_PROTOCOL_X86_32;\n\n        }\n\n        if (strcmp(blkdev->xendev.protocol, XEN_IO_PROTO_ABI_X86_64) == 0) {\n\n            blkdev->protocol = BLKIF_PROTOCOL_X86_64;\n\n        }\n\n    }\n\n\n\n    blkdev->sring = xc_gnttab_map_grant_ref(blkdev->xendev.gnttabdev,\n\n                                            blkdev->xendev.dom,\n\n                                            blkdev->ring_ref,\n\n                                            PROT_READ | PROT_WRITE);\n\n    if (!blkdev->sring) {\n\n        return -1;\n\n    }\n\n    blkdev->cnt_map++;\n\n\n\n    switch (blkdev->protocol) {\n\n    case BLKIF_PROTOCOL_NATIVE:\n\n    {\n\n        blkif_sring_t *sring_native = blkdev->sring;\n\n        BACK_RING_INIT(&blkdev->rings.native, sring_native, XC_PAGE_SIZE);\n\n        break;\n\n    }\n\n    case BLKIF_PROTOCOL_X86_32:\n\n    {\n\n        blkif_x86_32_sring_t *sring_x86_32 = blkdev->sring;\n\n\n\n        BACK_RING_INIT(&blkdev->rings.x86_32_part, sring_x86_32, XC_PAGE_SIZE);\n\n        break;\n\n    }\n\n    case BLKIF_PROTOCOL_X86_64:\n\n    {\n\n        blkif_x86_64_sring_t *sring_x86_64 = blkdev->sring;\n\n\n\n        BACK_RING_INIT(&blkdev->rings.x86_64_part, sring_x86_64, XC_PAGE_SIZE);\n\n        break;\n\n    }\n\n    }\n\n\n\n    if (blkdev->feature_persistent) {\n\n        /* Init persistent grants */\n\n        blkdev->max_grants = max_requests * BLKIF_MAX_SEGMENTS_PER_REQUEST;\n\n        blkdev->persistent_gnts = g_tree_new_full((GCompareDataFunc)int_cmp,\n\n                                             NULL, NULL,\n\n                                             (GDestroyNotify)destroy_grant);\n\n        blkdev->persistent_gnt_count = 0;\n\n    }\n\n\n\n    xen_be_bind_evtchn(&blkdev->xendev);\n\n\n\n    xen_be_printf(&blkdev->xendev, 1, \"ok: proto %s, ring-ref %d, \"\n\n                  \"remote port %d, local port %d\\n\",\n\n                  blkdev->xendev.protocol, blkdev->ring_ref,\n\n                  blkdev->xendev.remote_port, blkdev->xendev.local_port);\n\n    return 0;\n\n}\n", "idx": 22901}
{"project": "qemu", "commit_id": "b946a1533209f61a93e34898aebb5b43154b99c3", "target": 1, "func": "static void usb_net_handle_destroy(USBDevice *dev)\n\n{\n\n    USBNetState *s = (USBNetState *) dev;\n\n\n\n    /* TODO: remove the nd_table[] entry */\n\n    qemu_del_vlan_client(s->vc);\n\n    rndis_clear_responsequeue(s);\n\n    qemu_free(s);\n\n}\n", "idx": 22904}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void get_xbzrle_cache_stats(MigrationInfo *info)\n\n{\n\n    if (migrate_use_xbzrle()) {\n\n        info->has_xbzrle_cache = true;\n\n        info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));\n\n        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();\n\n        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();\n\n        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();\n\n        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();\n\n        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();\n\n        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();\n\n    }\n\n}\n", "idx": 22906}
{"project": "qemu", "commit_id": "f454f49c42d4ec7bdbbb5a7d9c0c8bfb24b28ca4", "target": 1, "func": "int qemu_egl_rendernode_open(void)\n\n{\n\n    DIR *dir;\n\n    struct dirent *e;\n\n    int r, fd;\n\n    char *p;\n\n\n\n    dir = opendir(\"/dev/dri\");\n\n    if (!dir) {\n\n        return -1;\n\n    }\n\n\n\n    fd = -1;\n\n    while ((e = readdir(dir))) {\n\n        if (e->d_type != DT_CHR) {\n\n            continue;\n\n        }\n\n\n\n        if (strncmp(e->d_name, \"renderD\", 7)) {\n\n            continue;\n\n        }\n\n\n\n        r = asprintf(&p, \"/dev/dri/%s\", e->d_name);\n\n        if (r < 0) {\n\n            return -1;\n\n        }\n\n\n\n        r = open(p, O_RDWR | O_CLOEXEC | O_NOCTTY | O_NONBLOCK);\n\n        if (r < 0) {\n\n            free(p);\n\n            continue;\n\n        }\n\n        fd = r;\n\n        free(p);\n\n        break;\n\n    }\n\n\n\n    closedir(dir);\n\n    if (fd < 0) {\n\n        return -1;\n\n    }\n\n    return fd;\n\n}\n", "idx": 22909}
{"project": "qemu", "commit_id": "07caea315a85ebfe90851f9c2e4ef3fdd24117b5", "target": 1, "func": "void qemu_check_nic_model(NICInfo *nd, const char *model)\n\n{\n\n    const char *models[2];\n\n\n\n    models[0] = model;\n\n    models[1] = NULL;\n\n\n\n    qemu_check_nic_model_list(nd, models, model);\n\n}\n", "idx": 22910}
{"project": "qemu", "commit_id": "b7fcff01790d25f48d81ef6c8c3399577096a555", "target": 1, "func": "static void test_identify(void)\n\n{\n\n    uint8_t data;\n\n    uint16_t buf[256];\n\n    int i;\n\n    int ret;\n\n\n\n    ide_test_start(\n\n        \"-vnc none \"\n\n        \"-drive file=%s,if=ide,serial=%s,cache=writeback \"\n\n        \"-global ide-hd.ver=%s\",\n\n        tmp_path, \"testdisk\", \"version\");\n\n\n\n    /* IDENTIFY command on device 0*/\n\n    outb(IDE_BASE + reg_device, 0);\n\n    outb(IDE_BASE + reg_command, CMD_IDENTIFY);\n\n\n\n    /* Read in the IDENTIFY buffer and check registers */\n\n    data = inb(IDE_BASE + reg_device);\n\n    g_assert_cmpint(data & DEV, ==, 0);\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        data = inb(IDE_BASE + reg_status);\n\n        assert_bit_set(data, DRDY | DRQ);\n\n        assert_bit_clear(data, BSY | DF | ERR);\n\n\n\n        ((uint16_t*) buf)[i] = inw(IDE_BASE + reg_data);\n\n    }\n\n\n\n    data = inb(IDE_BASE + reg_status);\n\n    assert_bit_set(data, DRDY);\n\n    assert_bit_clear(data, BSY | DF | ERR | DRQ);\n\n\n\n    /* Check serial number/version in the buffer */\n\n    string_cpu_to_be16(&buf[10], 20);\n\n    ret = memcmp(&buf[10], \"testdisk            \", 20);\n\n    g_assert(ret == 0);\n\n\n\n    string_cpu_to_be16(&buf[23], 8);\n\n    ret = memcmp(&buf[23], \"version \", 8);\n\n    g_assert(ret == 0);\n\n\n\n    /* Write cache enabled bit */\n\n    assert_bit_set(buf[85], 0x20);\n\n\n\n    ide_test_quit();\n\n}\n", "idx": 22912}
{"project": "qemu", "commit_id": "97e89ee914411384dcda771d38bf89f13726d71e", "target": 1, "func": "static void gen_window_check2(DisasContext *dc, unsigned r1, unsigned r2)\n\n{\n\n    gen_window_check1(dc, r1 > r2 ? r1 : r2);\n\n}\n", "idx": 22913}
{"project": "qemu", "commit_id": "9fac18f03a9040b67ec38e14d3e1ed34db9c7e06", "target": 1, "func": "void *qemu_anon_ram_alloc(size_t size, uint64_t *alignment)\n\n{\n\n    size_t align = QEMU_VMALLOC_ALIGN;\n\n    size_t total = size + align - getpagesize();\n\n    void *ptr = mmap(0, total, PROT_NONE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n\n    size_t offset = QEMU_ALIGN_UP((uintptr_t)ptr, align) - (uintptr_t)ptr;\n\n    void *ptr1;\n\n\n\n    if (ptr == MAP_FAILED) {\n\n        return NULL;\n\n    }\n\n\n\n    if (alignment) {\n\n        *alignment = align;\n\n    }\n\n\n\n    ptr1 = mmap(ptr + offset, size, PROT_READ | PROT_WRITE,\n\n                MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n\n    if (ptr1 == MAP_FAILED) {\n\n        munmap(ptr, total);\n\n        return NULL;\n\n    }\n\n\n\n    ptr += offset;\n\n    total -= offset;\n\n\n\n    if (offset > 0) {\n\n        munmap(ptr - offset, offset);\n\n    }\n\n    if (total > size) {\n\n        munmap(ptr + size, total - size);\n\n    }\n\n\n\n    trace_qemu_anon_ram_alloc(size, ptr);\n\n    return ptr;\n\n}\n", "idx": 22918}
{"project": "qemu", "commit_id": "04097f7c5957273c578f72b9bd603ba6b1d69e33", "target": 1, "func": "void vhost_dev_stop(struct vhost_dev *hdev, VirtIODevice *vdev)\n\n{\n\n    int i, r;\n\n\n\n    for (i = 0; i < hdev->nvqs; ++i) {\n\n        vhost_virtqueue_cleanup(hdev,\n\n                                vdev,\n\n                                hdev->vqs + i,\n\n                                i);\n\n    }\n\n    vhost_client_sync_dirty_bitmap(&hdev->client, 0,\n\n                                   (target_phys_addr_t)~0x0ull);\n\n    r = vdev->binding->set_guest_notifiers(vdev->binding_opaque, false);\n\n    if (r < 0) {\n\n        fprintf(stderr, \"vhost guest notifier cleanup failed: %d\\n\", r);\n\n        fflush(stderr);\n\n    }\n\n    assert (r >= 0);\n\n\n\n    hdev->started = false;\n\n    g_free(hdev->log);\n\n    hdev->log = NULL;\n\n    hdev->log_size = 0;\n\n}\n", "idx": 22919}
{"project": "qemu", "commit_id": "21ef45d71221b4577330fe3aacfb06afad91ad46", "target": 1, "func": "static void vnc_dpy_copy(DisplayChangeListener *dcl,\n\n                         DisplayState *ds,\n\n                         int src_x, int src_y,\n\n                         int dst_x, int dst_y, int w, int h)\n\n{\n\n    VncDisplay *vd = ds->opaque;\n\n    VncState *vs, *vn;\n\n    uint8_t *src_row;\n\n    uint8_t *dst_row;\n\n    int i, x, y, pitch, inc, w_lim, s;\n\n    int cmp_bytes;\n\n\n\n    vnc_refresh_server_surface(vd);\n\n    QTAILQ_FOREACH_SAFE(vs, &vd->clients, next, vn) {\n\n        if (vnc_has_feature(vs, VNC_FEATURE_COPYRECT)) {\n\n            vs->force_update = 1;\n\n            vnc_update_client_sync(vs, 1);\n\n            /* vs might be free()ed here */\n\n        }\n\n    }\n\n\n\n    /* do bitblit op on the local surface too */\n\n    pitch = vnc_server_fb_stride(vd);\n\n    src_row = vnc_server_fb_ptr(vd, src_x, src_y);\n\n    dst_row = vnc_server_fb_ptr(vd, dst_x, dst_y);\n\n    y = dst_y;\n\n    inc = 1;\n\n    if (dst_y > src_y) {\n\n        /* copy backwards */\n\n        src_row += pitch * (h-1);\n\n        dst_row += pitch * (h-1);\n\n        pitch = -pitch;\n\n        y = dst_y + h - 1;\n\n        inc = -1;\n\n    }\n\n    w_lim = w - (16 - (dst_x % 16));\n\n    if (w_lim < 0)\n\n        w_lim = w;\n\n    else\n\n        w_lim = w - (w_lim % 16);\n\n    for (i = 0; i < h; i++) {\n\n        for (x = 0; x <= w_lim;\n\n                x += s, src_row += cmp_bytes, dst_row += cmp_bytes) {\n\n            if (x == w_lim) {\n\n                if ((s = w - w_lim) == 0)\n\n                    break;\n\n            } else if (!x) {\n\n                s = (16 - (dst_x % 16));\n\n                s = MIN(s, w_lim);\n\n            } else {\n\n                s = 16;\n\n            }\n\n            cmp_bytes = s * VNC_SERVER_FB_BYTES;\n\n            if (memcmp(src_row, dst_row, cmp_bytes) == 0)\n\n                continue;\n\n            memmove(dst_row, src_row, cmp_bytes);\n\n            QTAILQ_FOREACH(vs, &vd->clients, next) {\n\n                if (!vnc_has_feature(vs, VNC_FEATURE_COPYRECT)) {\n\n                    set_bit(((x + dst_x) / 16), vs->dirty[y]);\n\n                }\n\n            }\n\n        }\n\n        src_row += pitch - w * VNC_SERVER_FB_BYTES;\n\n        dst_row += pitch - w * VNC_SERVER_FB_BYTES;\n\n        y += inc;\n\n    }\n\n\n\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n\n        if (vnc_has_feature(vs, VNC_FEATURE_COPYRECT)) {\n\n            vnc_copy(vs, src_x, src_y, dst_x, dst_y, w, h);\n\n        }\n\n    }\n\n}\n", "idx": 22930}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static PowerPCCPU *ppc440_init_xilinx(ram_addr_t *ram_size,\n\n                                      int do_init,\n\n                                      const char *cpu_model,\n\n                                      uint32_t sysclk)\n\n{\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    qemu_irq *irqs;\n\n\n\n    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    ppc_booke_timers_init(cpu, sysclk, 0/* no flags */);\n\n\n\n    ppc_dcr_init(env, NULL, NULL);\n\n\n\n    /* interrupt controller */\n\n    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);\n\n    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];\n\n    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];\n\n    ppcuic_init(env, irqs, 0x0C0, 0, 1);\n\n    return cpu;\n\n}\n", "idx": 22931}
{"project": "qemu", "commit_id": "8954bae3ce1ae5b64218b8731da9a8d7f46db9a7", "target": 1, "func": "restore_fpu_state(CPUSPARCState *env, qemu_siginfo_fpu_t *fpu)\n\n{\n\n        int err;\n\n#if 0\n\n#ifdef CONFIG_SMP\n\n        if (current->flags & PF_USEDFPU)\n\n                regs->psr &= ~PSR_EF;\n\n#else\n\n        if (current == last_task_used_math) {\n\n                last_task_used_math = 0;\n\n                regs->psr &= ~PSR_EF;\n\n        }\n\n#endif\n\n        current->used_math = 1;\n\n        current->flags &= ~PF_USEDFPU;\n\n#endif\n\n#if 0\n\n        if (verify_area (VERIFY_READ, fpu, sizeof(*fpu)))\n\n                return -EFAULT;\n\n#endif\n\n\n\n#if 0\n\n        /* XXX: incorrect */\n\n        err = __copy_from_user(&env->fpr[0], &fpu->si_float_regs[0],\n\n\t                             (sizeof(unsigned long) * 32));\n\n#endif\n\n        err |= __get_user(env->fsr, &fpu->si_fsr);\n\n#if 0\n\n        err |= __get_user(current->thread.fpqdepth, &fpu->si_fpqdepth);\n\n        if (current->thread.fpqdepth != 0)\n\n                err |= __copy_from_user(&current->thread.fpqueue[0],\n\n                                        &fpu->si_fpqueue[0],\n\n                                        ((sizeof(unsigned long) +\n\n                                        (sizeof(unsigned long *)))*16));\n\n#endif\n\n        return err;\n\n}\n", "idx": 22935}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_vfp_msr(TCGv tmp)\n\n{\n\n    tcg_gen_mov_i32(cpu_F0s, tmp);\n\n    dead_tmp(tmp);\n\n}\n", "idx": 22936}
{"project": "qemu", "commit_id": "b946a1533209f61a93e34898aebb5b43154b99c3", "target": 1, "func": "void stellaris_enet_init(NICInfo *nd, uint32_t base, qemu_irq irq)\n\n{\n\n    stellaris_enet_state *s;\n\n    int iomemtype;\n\n\n\n    qemu_check_nic_model(nd, \"stellaris\");\n\n\n\n    s = (stellaris_enet_state *)qemu_mallocz(sizeof(stellaris_enet_state));\n\n    iomemtype = cpu_register_io_memory(0, stellaris_enet_readfn,\n\n                                       stellaris_enet_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00001000, iomemtype);\n\n    s->irq = irq;\n\n    memcpy(s->macaddr, nd->macaddr, 6);\n\n\n\n    if (nd->vlan) {\n\n        s->vc = qemu_new_vlan_client(nd->vlan, nd->model, nd->name,\n\n                                     stellaris_enet_receive, stellaris_enet_can_receive, s);\n\n        qemu_format_nic_info_str(s->vc, s->macaddr);\n\n    }\n\n\n\n    stellaris_enet_reset(s);\n\n    register_savevm(\"stellaris_enet\", -1, 1,\n\n                    stellaris_enet_save, stellaris_enet_load, s);\n\n}\n", "idx": 22940}
{"project": "qemu", "commit_id": "e0e2d644096c79a71099b176d08f465f6803a8b1", "target": 1, "func": "static inline void vring_set_avail_event(VirtQueue *vq, uint16_t val)\n\n{\n\n    VRingMemoryRegionCaches *caches;\n\n    hwaddr pa;\n\n    if (!vq->notification) {\n\n        return;\n\n    }\n\n\n\n    caches = atomic_rcu_read(&vq->vring.caches);\n\n    pa = offsetof(VRingUsed, ring[vq->vring.num]);\n\n    virtio_stw_phys_cached(vq->vdev, &caches->used, pa, val);\n\n    address_space_cache_invalidate(&caches->used, pa, sizeof(val));\n\n}\n", "idx": 22942}
{"project": "qemu", "commit_id": "faadf50e2962dd54175647a80bd6fc4319c91973", "target": 1, "func": "static void init_excp_601 (CPUPPCState *env)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;\n\n    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;\n\n    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;\n\n    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;\n\n    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;\n\n    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;\n\n    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;\n\n    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;\n\n    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;\n\n    env->excp_vectors[POWERPC_EXCP_IO]       = 0x00000A00;\n\n    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;\n\n    env->excp_vectors[POWERPC_EXCP_RUNM]     = 0x00002000;\n\n    env->excp_prefix = 0xFFF00000;\n\n    /* Hardware reset vector */\n\n    env->hreset_vector = 0x00000100UL;\n\n#endif\n\n}\n", "idx": 22945}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "static VncJobQueue *vnc_queue_init(void)\n\n{\n\n    VncJobQueue *queue = g_malloc0(sizeof(VncJobQueue));\n\n\n\n    qemu_cond_init(&queue->cond);\n\n    qemu_mutex_init(&queue->mutex);\n\n    QTAILQ_INIT(&queue->jobs);\n\n    return queue;\n\n}\n", "idx": 22954}
{"project": "qemu", "commit_id": "7b35030eedc26eff82210caa2b0fff2f9d0df453", "target": 1, "func": "void test_tls_write_cert_chain(const char *filename,\n\n                               gnutls_x509_crt_t *certs,\n\n                               size_t ncerts)\n\n{\n\n    size_t i;\n\n    size_t capacity = 1024, offset = 0;\n\n    char *buffer = g_new0(char, capacity);\n\n    int err;\n\n\n\n    for (i = 0; i < ncerts; i++) {\n\n        size_t len = capacity - offset;\n\n    retry:\n\n        err = gnutls_x509_crt_export(certs[i], GNUTLS_X509_FMT_PEM,\n\n                                     buffer + offset, &len);\n\n        if (err < 0) {\n\n            if (err == GNUTLS_E_SHORT_MEMORY_BUFFER) {\n\n                buffer = g_renew(char, buffer, offset + len);\n\n                capacity = offset + len;\n\n                goto retry;\n\n            }\n\n            g_critical(\"Failed to export certificate chain %s: %d\",\n\n                       gnutls_strerror(err), err);\n\n            abort();\n\n        }\n\n        offset += len;\n\n    }\n\n\n\n    if (!g_file_set_contents(filename, buffer, offset, NULL)) {\n\n        abort();\n\n    }\n\n\n}", "idx": 22957}
{"project": "qemu", "commit_id": "34d49937e480edfa173d71e8c17972ad866b56c6", "target": 1, "func": "static void *atomic_mmu_lookup(CPUArchState *env, target_ulong addr,\n\n                               TCGMemOpIdx oi, uintptr_t retaddr)\n\n{\n\n    size_t mmu_idx = get_mmuidx(oi);\n\n    size_t index = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    CPUTLBEntry *tlbe = &env->tlb_table[mmu_idx][index];\n\n    target_ulong tlb_addr = tlbe->addr_write;\n\n    TCGMemOp mop = get_memop(oi);\n\n    int a_bits = get_alignment_bits(mop);\n\n    int s_bits = mop & MO_SIZE;\n\n\n\n    /* Adjust the given return address.  */\n\n    retaddr -= GETPC_ADJ;\n\n\n\n    /* Enforce guest required alignment.  */\n\n    if (unlikely(a_bits > 0 && (addr & ((1 << a_bits) - 1)))) {\n\n        /* ??? Maybe indicate atomic op to cpu_unaligned_access */\n\n        cpu_unaligned_access(ENV_GET_CPU(env), addr, MMU_DATA_STORE,\n\n                             mmu_idx, retaddr);\n\n    }\n\n\n\n    /* Enforce qemu required alignment.  */\n\n    if (unlikely(addr & ((1 << s_bits) - 1))) {\n\n        /* We get here if guest alignment was not requested,\n\n           or was not enforced by cpu_unaligned_access above.\n\n           We might widen the access and emulate, but for now\n\n           mark an exception and exit the cpu loop.  */\n\n        goto stop_the_world;\n\n    }\n\n\n\n    /* Check TLB entry and enforce page permissions.  */\n\n    if ((addr & TARGET_PAGE_MASK)\n\n        != (tlb_addr & (TARGET_PAGE_MASK | TLB_INVALID_MASK))) {\n\n        if (!VICTIM_TLB_HIT(addr_write, addr)) {\n\n            tlb_fill(ENV_GET_CPU(env), addr, MMU_DATA_STORE, mmu_idx, retaddr);\n\n        }\n\n        tlb_addr = tlbe->addr_write & ~TLB_INVALID_MASK;\n\n    }\n\n\n\n    /* Check notdirty */\n\n    if (unlikely(tlb_addr & TLB_NOTDIRTY)) {\n\n        tlb_set_dirty(ENV_GET_CPU(env), addr);\n\n        tlb_addr = tlb_addr & ~TLB_NOTDIRTY;\n\n    }\n\n\n\n    /* Notice an IO access  */\n\n    if (unlikely(tlb_addr & ~TARGET_PAGE_MASK)) {\n\n        /* There's really nothing that can be done to\n\n           support this apart from stop-the-world.  */\n\n        goto stop_the_world;\n\n    }\n\n\n\n    /* Let the guest notice RMW on a write-only page.  */\n\n    if (unlikely(tlbe->addr_read != tlb_addr)) {\n\n        tlb_fill(ENV_GET_CPU(env), addr, MMU_DATA_LOAD, mmu_idx, retaddr);\n\n        /* Since we don't support reads and writes to different addresses,\n\n           and we do have the proper page loaded for write, this shouldn't\n\n           ever return.  But just in case, handle via stop-the-world.  */\n\n        goto stop_the_world;\n\n    }\n\n\n\n    return (void *)((uintptr_t)addr + tlbe->addend);\n\n\n\n stop_the_world:\n\n    cpu_loop_exit_atomic(ENV_GET_CPU(env), retaddr);\n\n}\n", "idx": 22960}
{"project": "qemu", "commit_id": "262169abe74b4c2d8b299b7499904cfc3c1902ea", "target": 1, "func": "static int v9fs_receive_status(V9fsProxy *proxy,\n\n                               struct iovec *reply, int *status)\n\n{\n\n    int retval;\n\n    ProxyHeader header;\n\n\n\n    *status = 0;\n\n    reply->iov_len = 0;\n\n    retval = socket_read(proxy->sockfd, reply->iov_base, PROXY_HDR_SZ);\n\n    if (retval < 0) {\n\n        return retval;\n\n    }\n\n    reply->iov_len = PROXY_HDR_SZ;\n\n    proxy_unmarshal(reply, 0, \"dd\", &header.type, &header.size);\n\n    if (header.size != sizeof(int)) {\n\n        *status = -ENOBUFS;\n\n        return 0;\n\n    }\n\n    retval = socket_read(proxy->sockfd,\n\n                         reply->iov_base + PROXY_HDR_SZ, header.size);\n\n    if (retval < 0) {\n\n        return retval;\n\n    }\n\n    reply->iov_len += header.size;\n\n    proxy_unmarshal(reply, PROXY_HDR_SZ, \"d\", status);\n\n    return 0;\n\n}\n", "idx": 22963}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static target_long monitor_get_xer (const struct MonitorDef *md, int val)\n\n{\n\n    CPUState *env = mon_get_cpu();\n\n    if (!env)\n\n        return 0;\n\n    return env->xer;\n\n}\n", "idx": 22964}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static ssize_t qemu_fill_buffer(QEMUFile *f)\n\n{\n\n    int len;\n\n    int pending;\n\n\n\n    assert(!qemu_file_is_writable(f));\n\n\n\n    pending = f->buf_size - f->buf_index;\n\n    if (pending > 0) {\n\n        memmove(f->buf, f->buf + f->buf_index, pending);\n\n    }\n\n    f->buf_index = 0;\n\n    f->buf_size = pending;\n\n\n\n    len = f->ops->get_buffer(f->opaque, f->buf + pending, f->pos,\n\n                        IO_BUF_SIZE - pending);\n\n    if (len > 0) {\n\n        f->buf_size += len;\n\n        f->pos += len;\n\n    } else if (len == 0) {\n\n        qemu_file_set_error(f, -EIO);\n\n    } else if (len != -EAGAIN) {\n\n        qemu_file_set_error(f, len);\n\n    }\n\n\n\n    return len;\n\n}\n", "idx": 22965}
{"project": "qemu", "commit_id": "7372c2b926200db295412efbb53f93773b7f1754", "target": 1, "func": "static TCGv gen_ea(CPUM68KState *env, DisasContext *s, uint16_t insn,\n\n                   int opsize, TCGv val, TCGv *addrp, ea_what what)\n\n{\n\n    TCGv reg;\n\n    TCGv result;\n\n    uint32_t offset;\n\n\n\n    switch ((insn >> 3) & 7) {\n\n    case 0: /* Data register direct.  */\n\n        reg = DREG(insn, 0);\n\n        if (what == EA_STORE) {\n\n            gen_partset_reg(opsize, reg, val);\n\n            return store_dummy;\n\n        } else {\n\n            return gen_extend(reg, opsize, what == EA_LOADS);\n\n        }\n\n    case 1: /* Address register direct.  */\n\n        reg = AREG(insn, 0);\n\n        if (what == EA_STORE) {\n\n            tcg_gen_mov_i32(reg, val);\n\n            return store_dummy;\n\n        } else {\n\n            return gen_extend(reg, opsize, what == EA_LOADS);\n\n        }\n\n    case 2: /* Indirect register */\n\n        reg = AREG(insn, 0);\n\n        return gen_ldst(s, opsize, reg, val, what);\n\n    case 3: /* Indirect postincrement.  */\n\n        reg = AREG(insn, 0);\n\n        result = gen_ldst(s, opsize, reg, val, what);\n\n        /* ??? This is not exception safe.  The instruction may still\n\n           fault after this point.  */\n\n        if (what == EA_STORE || !addrp)\n\n            tcg_gen_addi_i32(reg, reg, opsize_bytes(opsize));\n\n        return result;\n\n    case 4: /* Indirect predecrememnt.  */\n\n        {\n\n            TCGv tmp;\n\n            if (addrp && what == EA_STORE) {\n\n                tmp = *addrp;\n\n            } else {\n\n                tmp = gen_lea(env, s, insn, opsize);\n\n                if (IS_NULL_QREG(tmp))\n\n                    return tmp;\n\n                if (addrp)\n\n                    *addrp = tmp;\n\n            }\n\n            result = gen_ldst(s, opsize, tmp, val, what);\n\n            /* ??? This is not exception safe.  The instruction may still\n\n               fault after this point.  */\n\n            if (what == EA_STORE || !addrp) {\n\n                reg = AREG(insn, 0);\n\n                tcg_gen_mov_i32(reg, tmp);\n\n            }\n\n        }\n\n        return result;\n\n    case 5: /* Indirect displacement.  */\n\n    case 6: /* Indirect index + displacement.  */\n\n        return gen_ea_once(env, s, insn, opsize, val, addrp, what);\n\n    case 7: /* Other */\n\n        switch (insn & 7) {\n\n        case 0: /* Absolute short.  */\n\n        case 1: /* Absolute long.  */\n\n        case 2: /* pc displacement  */\n\n        case 3: /* pc index+displacement.  */\n\n            return gen_ea_once(env, s, insn, opsize, val, addrp, what);\n\n        case 4: /* Immediate.  */\n\n            /* Sign extend values for consistency.  */\n\n            switch (opsize) {\n\n            case OS_BYTE:\n\n                if (what == EA_LOADS) {\n\n                    offset = cpu_ldsb_code(env, s->pc + 1);\n\n                } else {\n\n                    offset = cpu_ldub_code(env, s->pc + 1);\n\n                }\n\n                s->pc += 2;\n\n                break;\n\n            case OS_WORD:\n\n                if (what == EA_LOADS) {\n\n                    offset = cpu_ldsw_code(env, s->pc);\n\n                } else {\n\n                    offset = cpu_lduw_code(env, s->pc);\n\n                }\n\n                s->pc += 2;\n\n                break;\n\n            case OS_LONG:\n\n                offset = read_im32(env, s);\n\n                break;\n\n            default:\n\n                qemu_assert(0, \"Bad immediate operand\");\n\n            }\n\n            return tcg_const_i32(offset);\n\n        default:\n\n            return NULL_QREG;\n\n        }\n\n    }\n\n    /* Should never happen.  */\n\n    return NULL_QREG;\n\n}\n", "idx": 22969}
{"project": "qemu", "commit_id": "2b1c2e8e5f1990f0a201a8cbf9d366fca60f4aa8", "target": 1, "func": "build_dsdt(GArray *table_data, GArray *linker,\n           AcpiPmInfo *pm, AcpiMiscInfo *misc,\n           PcPciInfo *pci, MachineState *machine)\n{\n    CrsRangeEntry *entry;\n    Aml *dsdt, *sb_scope, *scope, *dev, *method, *field, *pkg, *crs;\n    GPtrArray *mem_ranges = g_ptr_array_new_with_free_func(crs_range_free);\n    GPtrArray *io_ranges = g_ptr_array_new_with_free_func(crs_range_free);\n    PCMachineState *pcms = PC_MACHINE(machine);\n    uint32_t nr_mem = machine->ram_slots;\n    int root_bus_limit = 0xFF;\n    PCIBus *bus = NULL;\n    int i;\n    dsdt = init_aml_allocator();\n    /* Reserve space for header */\n    acpi_data_push(dsdt->buf, sizeof(AcpiTableHeader));\n    build_dbg_aml(dsdt);\n    if (misc->is_piix4) {\n        sb_scope = aml_scope(\"_SB\");\n        dev = aml_device(\"PCI0\");\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A03\")));\n        aml_append(dev, aml_name_decl(\"_ADR\", aml_int(0)));\n        aml_append(dev, aml_name_decl(\"_UID\", aml_int(1)));\n        aml_append(sb_scope, dev);\n        aml_append(dsdt, sb_scope);\n        build_hpet_aml(dsdt);\n        build_piix4_pm(dsdt);\n        build_piix4_isa_bridge(dsdt);\n        build_isa_devices_aml(dsdt);\n        build_piix4_pci_hotplug(dsdt);\n        build_piix4_pci0_int(dsdt);\n    } else {\n        sb_scope = aml_scope(\"_SB\");\n        aml_append(sb_scope,\n            aml_operation_region(\"PCST\", AML_SYSTEM_IO, aml_int(0xae00), 0x0c));\n        aml_append(sb_scope,\n            aml_operation_region(\"PCSB\", AML_SYSTEM_IO, aml_int(0xae0c), 0x01));\n        field = aml_field(\"PCSB\", AML_ANY_ACC, AML_NOLOCK, AML_WRITE_AS_ZEROS);\n        aml_append(field, aml_named_field(\"PCIB\", 8));\n        aml_append(sb_scope, field);\n        aml_append(dsdt, sb_scope);\n        sb_scope = aml_scope(\"_SB\");\n        dev = aml_device(\"PCI0\");\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A08\")));\n        aml_append(dev, aml_name_decl(\"_CID\", aml_eisaid(\"PNP0A03\")));\n        aml_append(dev, aml_name_decl(\"_ADR\", aml_int(0)));\n        aml_append(dev, aml_name_decl(\"_UID\", aml_int(1)));\n        aml_append(dev, aml_name_decl(\"SUPP\", aml_int(0)));\n        aml_append(dev, aml_name_decl(\"CTRL\", aml_int(0)));\n        aml_append(dev, build_q35_osc_method());\n        aml_append(sb_scope, dev);\n        aml_append(dsdt, sb_scope);\n        build_hpet_aml(dsdt);\n        build_q35_isa_bridge(dsdt);\n        build_isa_devices_aml(dsdt);\n        build_q35_pci0_int(dsdt);\n    build_cpu_hotplug_aml(dsdt);\n    build_memory_hotplug_aml(dsdt, nr_mem, pm->mem_hp_io_base,\n                             pm->mem_hp_io_len);\n    scope =  aml_scope(\"_GPE\");\n    {\n        aml_append(scope, aml_name_decl(\"_HID\", aml_string(\"ACPI0006\")));\n        aml_append(scope, aml_method(\"_L00\", 0, AML_NOTSERIALIZED));\n        if (misc->is_piix4) {\n            method = aml_method(\"_E01\", 0, AML_NOTSERIALIZED);\n            aml_append(method,\n                aml_acquire(aml_name(\"\\\\_SB.PCI0.BLCK\"), 0xFFFF));\n            aml_append(method, aml_call0(\"\\\\_SB.PCI0.PCNT\"));\n            aml_append(method, aml_release(aml_name(\"\\\\_SB.PCI0.BLCK\")));\n            aml_append(scope, method);\n        } else {\n            aml_append(scope, aml_method(\"_L01\", 0, AML_NOTSERIALIZED));\n        method = aml_method(\"_E02\", 0, AML_NOTSERIALIZED);\n        aml_append(method, aml_call0(\"\\\\_SB.\" CPU_SCAN_METHOD));\n        aml_append(scope, method);\n        method = aml_method(\"_E03\", 0, AML_NOTSERIALIZED);\n        aml_append(method, aml_call0(MEMORY_HOTPLUG_HANDLER_PATH));\n        aml_append(scope, method);\n        aml_append(scope, aml_method(\"_L04\", 0, AML_NOTSERIALIZED));\n        aml_append(scope, aml_method(\"_L05\", 0, AML_NOTSERIALIZED));\n        aml_append(scope, aml_method(\"_L06\", 0, AML_NOTSERIALIZED));\n        aml_append(scope, aml_method(\"_L07\", 0, AML_NOTSERIALIZED));\n        aml_append(scope, aml_method(\"_L08\", 0, AML_NOTSERIALIZED));\n        aml_append(scope, aml_method(\"_L09\", 0, AML_NOTSERIALIZED));\n        aml_append(scope, aml_method(\"_L0A\", 0, AML_NOTSERIALIZED));\n        aml_append(scope, aml_method(\"_L0B\", 0, AML_NOTSERIALIZED));\n        aml_append(scope, aml_method(\"_L0C\", 0, AML_NOTSERIALIZED));\n        aml_append(scope, aml_method(\"_L0D\", 0, AML_NOTSERIALIZED));\n        aml_append(scope, aml_method(\"_L0E\", 0, AML_NOTSERIALIZED));\n        aml_append(scope, aml_method(\"_L0F\", 0, AML_NOTSERIALIZED));\n    aml_append(dsdt, scope);\n    bus = PC_MACHINE(machine)->bus;\n    if (bus) {\n        QLIST_FOREACH(bus, &bus->child, sibling) {\n            uint8_t bus_num = pci_bus_num(bus);\n            uint8_t numa_node = pci_bus_numa_node(bus);\n            /* look only for expander root buses */\n            if (!pci_bus_is_root(bus)) {\n                continue;\n            if (bus_num < root_bus_limit) {\n                root_bus_limit = bus_num - 1;\n            scope = aml_scope(\"\\\\_SB\");\n            dev = aml_device(\"PC%.02X\", bus_num);\n            aml_append(dev, aml_name_decl(\"_UID\", aml_int(bus_num)));\n            aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A03\")));\n            aml_append(dev, aml_name_decl(\"_BBN\", aml_int(bus_num)));\n            if (numa_node != NUMA_NODE_UNASSIGNED) {\n                aml_append(dev, aml_name_decl(\"_PXM\", aml_int(numa_node)));\n            aml_append(dev, build_prt(false));\n            crs = build_crs(PCI_HOST_BRIDGE(BUS(bus)->parent),\n                            io_ranges, mem_ranges);\n            aml_append(dev, aml_name_decl(\"_CRS\", crs));\n            aml_append(scope, dev);\n            aml_append(dsdt, scope);\n    scope = aml_scope(\"\\\\_SB.PCI0\");\n    /* build PCI0._CRS */\n    crs = aml_resource_template();\n    aml_append(crs,\n        aml_word_bus_number(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE,\n                            0x0000, 0x0, root_bus_limit,\n                            0x0000, root_bus_limit + 1));\n    aml_append(crs, aml_io(AML_DECODE16, 0x0CF8, 0x0CF8, 0x01, 0x08));\n    aml_append(crs,\n        aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,\n                    AML_POS_DECODE, AML_ENTIRE_RANGE,\n                    0x0000, 0x0000, 0x0CF7, 0x0000, 0x0CF8));\n    crs_replace_with_free_ranges(io_ranges, 0x0D00, 0xFFFF);\n    for (i = 0; i < io_ranges->len; i++) {\n        entry = g_ptr_array_index(io_ranges, i);\n        aml_append(crs,\n            aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,\n                        AML_POS_DECODE, AML_ENTIRE_RANGE,\n                        0x0000, entry->base, entry->limit,\n                        0x0000, entry->limit - entry->base + 1));\n    aml_append(crs,\n        aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n                         AML_CACHEABLE, AML_READ_WRITE,\n                         0, 0x000A0000, 0x000BFFFF, 0, 0x00020000));\n    crs_replace_with_free_ranges(mem_ranges, pci->w32.begin, pci->w32.end - 1);\n    for (i = 0; i < mem_ranges->len; i++) {\n        entry = g_ptr_array_index(mem_ranges, i);\n        aml_append(crs,\n            aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n                             AML_NON_CACHEABLE, AML_READ_WRITE,\n                             0, entry->base, entry->limit,\n                             0, entry->limit - entry->base + 1));\n    if (pci->w64.begin) {\n        aml_append(crs,\n            aml_qword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n                             AML_CACHEABLE, AML_READ_WRITE,\n                             0, pci->w64.begin, pci->w64.end - 1, 0,\n                             pci->w64.end - pci->w64.begin));\n    aml_append(scope, aml_name_decl(\"_CRS\", crs));\n    /* reserve GPE0 block resources */\n    dev = aml_device(\"GPE0\");\n    aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"PNP0A06\")));\n    aml_append(dev, aml_name_decl(\"_UID\", aml_string(\"GPE0 resources\")));\n    /* device present, functioning, decoding, not shown in UI */\n    aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n    crs = aml_resource_template();\n    aml_append(crs,\n        aml_io(AML_DECODE16, pm->gpe0_blk, pm->gpe0_blk, 1, pm->gpe0_blk_len)\n    );\n    aml_append(dev, aml_name_decl(\"_CRS\", crs));\n    aml_append(scope, dev);\n    g_ptr_array_free(io_ranges, true);\n    g_ptr_array_free(mem_ranges, true);\n    /* reserve PCIHP resources */\n    if (pm->pcihp_io_len) {\n        dev = aml_device(\"PHPR\");\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"PNP0A06\")));\n        aml_append(dev,\n            aml_name_decl(\"_UID\", aml_string(\"PCI Hotplug resources\")));\n        /* device present, functioning, decoding, not shown in UI */\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n        crs = aml_resource_template();\n        aml_append(crs,\n            aml_io(AML_DECODE16, pm->pcihp_io_base, pm->pcihp_io_base, 1,\n                   pm->pcihp_io_len)\n        );\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n        aml_append(scope, dev);\n    aml_append(dsdt, scope);\n    /*  create S3_ / S4_ / S5_ packages if necessary */\n    scope = aml_scope(\"\\\\\");\n    if (!pm->s3_disabled) {\n        pkg = aml_package(4);\n        aml_append(pkg, aml_int(1)); /* PM1a_CNT.SLP_TYP */\n        aml_append(pkg, aml_int(1)); /* PM1b_CNT.SLP_TYP, FIXME: not impl. */\n        aml_append(pkg, aml_int(0)); /* reserved */\n        aml_append(pkg, aml_int(0)); /* reserved */\n        aml_append(scope, aml_name_decl(\"_S3\", pkg));\n    if (!pm->s4_disabled) {\n        pkg = aml_package(4);\n        aml_append(pkg, aml_int(pm->s4_val)); /* PM1a_CNT.SLP_TYP */\n        /* PM1b_CNT.SLP_TYP, FIXME: not impl. */\n        aml_append(pkg, aml_int(pm->s4_val));\n        aml_append(pkg, aml_int(0)); /* reserved */\n        aml_append(pkg, aml_int(0)); /* reserved */\n        aml_append(scope, aml_name_decl(\"_S4\", pkg));\n    pkg = aml_package(4);\n    aml_append(pkg, aml_int(0)); /* PM1a_CNT.SLP_TYP */\n    aml_append(pkg, aml_int(0)); /* PM1b_CNT.SLP_TYP not impl. */\n    aml_append(pkg, aml_int(0)); /* reserved */\n    aml_append(pkg, aml_int(0)); /* reserved */\n    aml_append(scope, aml_name_decl(\"_S5\", pkg));\n    aml_append(dsdt, scope);\n    /* create fw_cfg node, unconditionally */\n    {\n        /* when using port i/o, the 8-bit data register *always* overlaps\n         * with half of the 16-bit control register. Hence, the total size\n         * of the i/o region used is FW_CFG_CTL_SIZE; when using DMA, the\n         * DMA control register is located at FW_CFG_DMA_IO_BASE + 4 */\n        uint8_t io_size = object_property_get_bool(OBJECT(pcms->fw_cfg),\n                                                   \"dma_enabled\", NULL) ?\n                          ROUND_UP(FW_CFG_CTL_SIZE, 4) + sizeof(dma_addr_t) :\n                          FW_CFG_CTL_SIZE;\n        scope = aml_scope(\"\\\\_SB.PCI0\");\n        dev = aml_device(\"FWCF\");\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"QEMU0002\")));\n        /* device present, functioning, decoding, not shown in UI */\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n        crs = aml_resource_template();\n        aml_append(crs,\n            aml_io(AML_DECODE16, FW_CFG_IO_BASE, FW_CFG_IO_BASE, 0x01, io_size)\n        );\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n        aml_append(scope, dev);\n        aml_append(dsdt, scope);\n    if (misc->applesmc_io_base) {\n        scope = aml_scope(\"\\\\_SB.PCI0.ISA\");\n        dev = aml_device(\"SMC\");\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"APP0001\")));\n        /* device present, functioning, decoding, not shown in UI */\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n        crs = aml_resource_template();\n        aml_append(crs,\n            aml_io(AML_DECODE16, misc->applesmc_io_base, misc->applesmc_io_base,\n                   0x01, APPLESMC_MAX_DATA_LENGTH)\n        );\n        aml_append(crs, aml_irq_no_flags(6));\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n        aml_append(scope, dev);\n        aml_append(dsdt, scope);\n    if (misc->pvpanic_port) {\n        scope = aml_scope(\"\\\\_SB.PCI0.ISA\");\n        dev = aml_device(\"PEVT\");\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"QEMU0001\")));\n        crs = aml_resource_template();\n        aml_append(crs,\n            aml_io(AML_DECODE16, misc->pvpanic_port, misc->pvpanic_port, 1, 1)\n        );\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n        aml_append(dev, aml_operation_region(\"PEOR\", AML_SYSTEM_IO,\n                                              aml_int(misc->pvpanic_port), 1));\n        field = aml_field(\"PEOR\", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);\n        aml_append(field, aml_named_field(\"PEPT\", 8));\n        aml_append(dev, field);\n        /* device present, functioning, decoding, shown in UI */\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xF)));\n        method = aml_method(\"RDPT\", 0, AML_NOTSERIALIZED);\n        aml_append(method, aml_store(aml_name(\"PEPT\"), aml_local(0)));\n        aml_append(method, aml_return(aml_local(0)));\n        aml_append(dev, method);\n        method = aml_method(\"WRPT\", 1, AML_NOTSERIALIZED);\n        aml_append(method, aml_store(aml_arg(0), aml_name(\"PEPT\")));\n        aml_append(dev, method);\n        aml_append(scope, dev);\n        aml_append(dsdt, scope);\n    sb_scope = aml_scope(\"\\\\_SB\");\n    {\n        build_processor_devices(sb_scope, machine, pm);\n        build_memory_devices(sb_scope, nr_mem, pm->mem_hp_io_base,\n                             pm->mem_hp_io_len);\n        {\n            Object *pci_host;\n            PCIBus *bus = NULL;\n            pci_host = acpi_get_i386_pci_host();\n            if (pci_host) {\n                bus = PCI_HOST_BRIDGE(pci_host)->bus;\n            if (bus) {\n                Aml *scope = aml_scope(\"PCI0\");\n                /* Scan all PCI buses. Generate tables to support hotplug. */\n                build_append_pci_bus_devices(scope, bus, pm->pcihp_bridge_en);\n                    dev = aml_device(\"ISA.TPM\");\n                    aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0C31\")));\n                    aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xF)));\n                    crs = aml_resource_template();\n                    aml_append(crs, aml_irq_no_flags(TPM_TIS_IRQ));\n                    aml_append(dev, aml_name_decl(\"_CRS\", crs));\n                    aml_append(scope, dev);\n                aml_append(sb_scope, scope);\n        aml_append(dsdt, sb_scope);\n    /* copy AML table into ACPI tables blob and patch header there */\n    g_array_append_vals(table_data, dsdt->buf->data, dsdt->buf->len);\n    build_header(linker, table_data,\n        (void *)(table_data->data + table_data->len - dsdt->buf->len),\n        \"DSDT\", dsdt->buf->len, 1, NULL, NULL);\n    free_aml_allocator();", "idx": 22973}
{"project": "qemu", "commit_id": "3e48dd4a2d48aabafe22ce3611d65544d0234a69", "target": 1, "func": "static uint32_t rtl8139_io_readw(void *opaque, uint8_t addr)\n\n{\n\n    RTL8139State *s = opaque;\n\n    uint32_t ret;\n\n\n\n    switch (addr)\n\n    {\n\n        case TxAddr0 ... TxAddr0+4*4-1:\n\n            ret = rtl8139_TxStatus_read(s, addr, 2);\n\n            break;\n\n        case IntrMask:\n\n            ret = rtl8139_IntrMask_read(s);\n\n            break;\n\n\n\n        case IntrStatus:\n\n            ret = rtl8139_IntrStatus_read(s);\n\n            break;\n\n\n\n        case MultiIntr:\n\n            ret = rtl8139_MultiIntr_read(s);\n\n            break;\n\n\n\n        case RxBufPtr:\n\n            ret = rtl8139_RxBufPtr_read(s);\n\n            break;\n\n\n\n        case RxBufAddr:\n\n            ret = rtl8139_RxBufAddr_read(s);\n\n            break;\n\n\n\n        case BasicModeCtrl:\n\n            ret = rtl8139_BasicModeCtrl_read(s);\n\n            break;\n\n        case BasicModeStatus:\n\n            ret = rtl8139_BasicModeStatus_read(s);\n\n            break;\n\n        case NWayAdvert:\n\n            ret = s->NWayAdvert;\n\n            DPRINTF(\"NWayAdvert read(w) val=0x%04x\\n\", ret);\n\n            break;\n\n        case NWayLPAR:\n\n            ret = s->NWayLPAR;\n\n            DPRINTF(\"NWayLPAR read(w) val=0x%04x\\n\", ret);\n\n            break;\n\n        case NWayExpansion:\n\n            ret = s->NWayExpansion;\n\n            DPRINTF(\"NWayExpansion read(w) val=0x%04x\\n\", ret);\n\n            break;\n\n\n\n        case CpCmd:\n\n            ret = rtl8139_CpCmd_read(s);\n\n            break;\n\n\n\n        case IntrMitigate:\n\n            ret = rtl8139_IntrMitigate_read(s);\n\n            break;\n\n\n\n        case TxSummary:\n\n            ret = rtl8139_TSAD_read(s);\n\n            break;\n\n\n\n        case CSCR:\n\n            ret = rtl8139_CSCR_read(s);\n\n            break;\n\n\n\n        default:\n\n            DPRINTF(\"ioport read(w) addr=0x%x via read(b)\\n\", addr);\n\n\n\n            ret  = rtl8139_io_readb(opaque, addr);\n\n            ret |= rtl8139_io_readb(opaque, addr + 1) << 8;\n\n\n\n            DPRINTF(\"ioport read(w) addr=0x%x val=0x%04x\\n\", addr, ret);\n\n            break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 22975}
{"project": "qemu", "commit_id": "161c4f20bfbd54f0b77426adccb68ee831678af0", "target": 1, "func": "static void vnc_disconnect_finish(VncState *vs)\n{\n    vnc_qmp_event(vs, QEVENT_VNC_DISCONNECTED);\n    buffer_free(&vs->input);\n    buffer_free(&vs->output);\n    qobject_decref(vs->info);\n#ifdef CONFIG_VNC_TLS\n    vnc_tls_client_cleanup(vs);\n#endif /* CONFIG_VNC_TLS */\n#ifdef CONFIG_VNC_SASL\n    vnc_sasl_client_cleanup(vs);\n#endif /* CONFIG_VNC_SASL */\n    audio_del(vs);\n    QTAILQ_REMOVE(&vs->vd->clients, vs, next);\n    if (QTAILQ_EMPTY(&vs->vd->clients)) {\n        dcl->idle = 1;\n    }\n    qemu_remove_mouse_mode_change_notifier(&vs->mouse_mode_notifier);\n    vnc_remove_timer(vs->vd);\n    if (vs->vd->lock_key_sync)\n        qemu_remove_led_event_handler(vs->led);\n    qemu_free(vs);\n}", "idx": 22980}
{"project": "qemu", "commit_id": "dfd917a9c2bed578c31043126c9f558190bf21e4", "target": 1, "func": "static void *colo_compare_thread(void *opaque)\n\n{\n\n    GMainContext *worker_context;\n\n    GMainLoop *compare_loop;\n\n    CompareState *s = opaque;\n\n    GSource *timeout_source;\n\n\n\n    worker_context = g_main_context_new();\n\n\n\n    qemu_chr_fe_set_handlers(&s->chr_pri_in, compare_chr_can_read,\n\n                             compare_pri_chr_in, NULL, s, worker_context, true);\n\n    qemu_chr_fe_set_handlers(&s->chr_sec_in, compare_chr_can_read,\n\n                             compare_sec_chr_in, NULL, s, worker_context, true);\n\n\n\n    compare_loop = g_main_loop_new(worker_context, FALSE);\n\n\n\n    /* To kick any packets that the secondary doesn't match */\n\n    timeout_source = g_timeout_source_new(REGULAR_PACKET_CHECK_MS);\n\n    g_source_set_callback(timeout_source,\n\n                          (GSourceFunc)check_old_packet_regular, s, NULL);\n\n    g_source_attach(timeout_source, worker_context);\n\n\n\n    g_main_loop_run(compare_loop);\n\n\n\n    g_source_unref(timeout_source);\n\n    g_main_loop_unref(compare_loop);\n\n    g_main_context_unref(worker_context);\n\n    return NULL;\n\n}\n", "idx": 22981}
{"project": "qemu", "commit_id": "0522604b09b8cff54ba2450a7478da2a4d084817", "target": 1, "func": "static void x86_cpu_reset(CPUState *s)\n{\n    X86CPU *cpu = X86_CPU(s);\n    X86CPUClass *xcc = X86_CPU_GET_CLASS(cpu);\n    CPUX86State *env = &cpu->env;\n    int i;\n    xcc->parent_reset(s);\n    memset(env, 0, offsetof(CPUX86State, breakpoints));\n    tlb_flush(env, 1);\n    env->old_exception = -1;\n    /* init to reset state */\n#ifdef CONFIG_SOFTMMU\n    env->hflags |= HF_SOFTMMU_MASK;\n#endif\n    env->hflags2 |= HF2_GIF_MASK;\n    cpu_x86_update_cr0(env, 0x60000010);\n    env->a20_mask = ~0x0;\n    env->smbase = 0x30000;\n    env->idt.limit = 0xffff;\n    env->gdt.limit = 0xffff;\n    env->ldt.limit = 0xffff;\n    env->ldt.flags = DESC_P_MASK | (2 << DESC_TYPE_SHIFT);\n    env->tr.limit = 0xffff;\n    env->tr.flags = DESC_P_MASK | (11 << DESC_TYPE_SHIFT);\n    cpu_x86_load_seg_cache(env, R_CS, 0xf000, 0xffff0000, 0xffff,\n                           DESC_P_MASK | DESC_S_MASK | DESC_CS_MASK |\n                           DESC_R_MASK | DESC_A_MASK);\n    cpu_x86_load_seg_cache(env, R_DS, 0, 0, 0xffff,\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n                           DESC_A_MASK);\n    cpu_x86_load_seg_cache(env, R_ES, 0, 0, 0xffff,\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n                           DESC_A_MASK);\n    cpu_x86_load_seg_cache(env, R_SS, 0, 0, 0xffff,\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n                           DESC_A_MASK);\n    cpu_x86_load_seg_cache(env, R_FS, 0, 0, 0xffff,\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n                           DESC_A_MASK);\n    cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0xffff,\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n                           DESC_A_MASK);\n    env->eip = 0xfff0;\n    env->regs[R_EDX] = env->cpuid_version;\n    env->eflags = 0x2;\n    /* FPU init */\n    for (i = 0; i < 8; i++) {\n        env->fptags[i] = 1;\n    }\n    env->fpuc = 0x37f;\n    env->mxcsr = 0x1f80;\n    env->xstate_bv = XSTATE_FP | XSTATE_SSE;\n    env->pat = 0x0007040600070406ULL;\n    env->msr_ia32_misc_enable = MSR_IA32_MISC_ENABLE_DEFAULT;\n    memset(env->dr, 0, sizeof(env->dr));\n    env->dr[6] = DR6_FIXED_1;\n    env->dr[7] = DR7_FIXED_1;\n    cpu_breakpoint_remove_all(env, BP_CPU);\n    cpu_watchpoint_remove_all(env, BP_CPU);\n#if !defined(CONFIG_USER_ONLY)\n    /* We hard-wire the BSP to the first CPU. */\n    if (s->cpu_index == 0) {\n        apic_designate_bsp(env->apic_state);\n    }\n    s->halted = !cpu_is_bsp(cpu);\n#endif\n}", "idx": 22984}
{"project": "qemu", "commit_id": "7372c2b926200db295412efbb53f93773b7f1754", "target": 1, "func": "DISAS_INSN(frestore)\n\n{\n\n    /* TODO: Implement frestore.  */\n\n    qemu_assert(0, \"FRESTORE not implemented\");\n\n}\n", "idx": 22985}
{"project": "qemu", "commit_id": "69d4c703a549f0630793a67b16a8fc6bc14c8654", "target": 1, "func": "static inline abi_long target_to_host_semarray(int semid, unsigned short **host_array,\n\n                                               abi_ulong target_addr)\n\n{\n\n    int nsems;\n\n    unsigned short *array;\n\n    union semun semun;\n\n    struct semid_ds semid_ds;\n\n    int i, ret;\n\n\n\n    semun.buf = &semid_ds;\n\n\n\n    ret = semctl(semid, 0, IPC_STAT, semun);\n\n    if (ret == -1)\n\n        return get_errno(ret);\n\n\n\n    nsems = semid_ds.sem_nsems;\n\n\n\n    *host_array = malloc(nsems*sizeof(unsigned short));\n\n    array = lock_user(VERIFY_READ, target_addr,\n\n                      nsems*sizeof(unsigned short), 1);\n\n    if (!array)\n\n        return -TARGET_EFAULT;\n\n\n\n    for(i=0; i<nsems; i++) {\n\n        __get_user((*host_array)[i], &array[i]);\n\n    }\n\n    unlock_user(array, target_addr, 0);\n\n\n\n    return 0;\n\n}\n", "idx": 22987}
{"project": "qemu", "commit_id": "9586fefefe383a9aa25ad99bde9a6b240309ca33", "target": 1, "func": "static void vga_draw_text(VGAState *s, int full_update)\n\n{\n\n    int cx, cy, cheight, cw, ch, cattr, height, width, ch_attr;\n\n    int cx_min, cx_max, linesize, x_incr;\n\n    uint32_t offset, fgcol, bgcol, v, cursor_offset;\n\n    uint8_t *d1, *d, *src, *s1, *dest, *cursor_ptr;\n\n    const uint8_t *font_ptr, *font_base[2];\n\n    int dup9, line_offset, depth_index;\n\n    uint32_t *palette;\n\n    uint32_t *ch_attr_ptr;\n\n    vga_draw_glyph8_func *vga_draw_glyph8;\n\n    vga_draw_glyph9_func *vga_draw_glyph9;\n\n\n\n    vga_dirty_log_stop(s);\n\n\n\n    /* compute font data address (in plane 2) */\n\n    v = s->sr[3];\n\n    offset = (((v >> 4) & 1) | ((v << 1) & 6)) * 8192 * 4 + 2;\n\n    if (offset != s->font_offsets[0]) {\n\n        s->font_offsets[0] = offset;\n\n        full_update = 1;\n\n    }\n\n    font_base[0] = s->vram_ptr + offset;\n\n\n\n    offset = (((v >> 5) & 1) | ((v >> 1) & 6)) * 8192 * 4 + 2;\n\n    font_base[1] = s->vram_ptr + offset;\n\n    if (offset != s->font_offsets[1]) {\n\n        s->font_offsets[1] = offset;\n\n        full_update = 1;\n\n    }\n\n    if (s->plane_updated & (1 << 2)) {\n\n        /* if the plane 2 was modified since the last display, it\n\n           indicates the font may have been modified */\n\n        s->plane_updated = 0;\n\n        full_update = 1;\n\n    }\n\n    full_update |= update_basic_params(s);\n\n\n\n    line_offset = s->line_offset;\n\n    s1 = s->vram_ptr + (s->start_addr * 4);\n\n\n\n    vga_get_text_resolution(s, &width, &height, &cw, &cheight);\n\n    x_incr = cw * ((ds_get_bits_per_pixel(s->ds) + 7) >> 3);\n\n    if ((height * width) > CH_ATTR_SIZE) {\n\n        /* better than nothing: exit if transient size is too big */\n\n        return;\n\n    }\n\n\n\n    if (width != s->last_width || height != s->last_height ||\n\n        cw != s->last_cw || cheight != s->last_ch || s->last_depth) {\n\n        s->last_scr_width = width * cw;\n\n        s->last_scr_height = height * cheight;\n\n        qemu_console_resize(s->ds, s->last_scr_width, s->last_scr_height);\n\n        s->last_depth = 0;\n\n        s->last_width = width;\n\n        s->last_height = height;\n\n        s->last_ch = cheight;\n\n        s->last_cw = cw;\n\n        full_update = 1;\n\n    }\n\n    s->rgb_to_pixel =\n\n        rgb_to_pixel_dup_table[get_depth_index(s->ds)];\n\n    full_update |= update_palette16(s);\n\n    palette = s->last_palette;\n\n    x_incr = cw * ((ds_get_bits_per_pixel(s->ds) + 7) >> 3);\n\n\n\n    cursor_offset = ((s->cr[0x0e] << 8) | s->cr[0x0f]) - s->start_addr;\n\n    if (cursor_offset != s->cursor_offset ||\n\n        s->cr[0xa] != s->cursor_start ||\n\n        s->cr[0xb] != s->cursor_end) {\n\n      /* if the cursor position changed, we update the old and new\n\n         chars */\n\n        if (s->cursor_offset < CH_ATTR_SIZE)\n\n            s->last_ch_attr[s->cursor_offset] = -1;\n\n        if (cursor_offset < CH_ATTR_SIZE)\n\n            s->last_ch_attr[cursor_offset] = -1;\n\n        s->cursor_offset = cursor_offset;\n\n        s->cursor_start = s->cr[0xa];\n\n        s->cursor_end = s->cr[0xb];\n\n    }\n\n    cursor_ptr = s->vram_ptr + (s->start_addr + cursor_offset) * 4;\n\n\n\n    depth_index = get_depth_index(s->ds);\n\n    if (cw == 16)\n\n        vga_draw_glyph8 = vga_draw_glyph16_table[depth_index];\n\n    else\n\n        vga_draw_glyph8 = vga_draw_glyph8_table[depth_index];\n\n    vga_draw_glyph9 = vga_draw_glyph9_table[depth_index];\n\n\n\n    dest = ds_get_data(s->ds);\n\n    linesize = ds_get_linesize(s->ds);\n\n    ch_attr_ptr = s->last_ch_attr;\n\n    for(cy = 0; cy < height; cy++) {\n\n        d1 = dest;\n\n        src = s1;\n\n        cx_min = width;\n\n        cx_max = -1;\n\n        for(cx = 0; cx < width; cx++) {\n\n            ch_attr = *(uint16_t *)src;\n\n            if (full_update || ch_attr != *ch_attr_ptr) {\n\n                if (cx < cx_min)\n\n                    cx_min = cx;\n\n                if (cx > cx_max)\n\n                    cx_max = cx;\n\n                *ch_attr_ptr = ch_attr;\n\n#ifdef WORDS_BIGENDIAN\n\n                ch = ch_attr >> 8;\n\n                cattr = ch_attr & 0xff;\n\n#else\n\n                ch = ch_attr & 0xff;\n\n                cattr = ch_attr >> 8;\n\n#endif\n\n                font_ptr = font_base[(cattr >> 3) & 1];\n\n                font_ptr += 32 * 4 * ch;\n\n                bgcol = palette[cattr >> 4];\n\n                fgcol = palette[cattr & 0x0f];\n\n                if (cw != 9) {\n\n                    vga_draw_glyph8(d1, linesize,\n\n                                    font_ptr, cheight, fgcol, bgcol);\n\n                } else {\n\n                    dup9 = 0;\n\n                    if (ch >= 0xb0 && ch <= 0xdf && (s->ar[0x10] & 0x04))\n\n                        dup9 = 1;\n\n                    vga_draw_glyph9(d1, linesize,\n\n                                    font_ptr, cheight, fgcol, bgcol, dup9);\n\n                }\n\n                if (src == cursor_ptr &&\n\n                    !(s->cr[0x0a] & 0x20)) {\n\n                    int line_start, line_last, h;\n\n                    /* draw the cursor */\n\n                    line_start = s->cr[0x0a] & 0x1f;\n\n                    line_last = s->cr[0x0b] & 0x1f;\n\n                    /* XXX: check that */\n\n                    if (line_last > cheight - 1)\n\n                        line_last = cheight - 1;\n\n                    if (line_last >= line_start && line_start < cheight) {\n\n                        h = line_last - line_start + 1;\n\n                        d = d1 + linesize * line_start;\n\n                        if (cw != 9) {\n\n                            vga_draw_glyph8(d, linesize,\n\n                                            cursor_glyph, h, fgcol, bgcol);\n\n                        } else {\n\n                            vga_draw_glyph9(d, linesize,\n\n                                            cursor_glyph, h, fgcol, bgcol, 1);\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            d1 += x_incr;\n\n            src += 4;\n\n            ch_attr_ptr++;\n\n        }\n\n        if (cx_max != -1) {\n\n            dpy_update(s->ds, cx_min * cw, cy * cheight,\n\n                       (cx_max - cx_min + 1) * cw, cheight);\n\n        }\n\n        dest += linesize * cheight;\n\n        s1 += line_offset;\n\n    }\n\n}\n", "idx": 22988}
{"project": "qemu", "commit_id": "651060aba79dc9d0cc77ac3921948ea78dba7409", "target": 1, "func": "static hwaddr ppc_hash64_pteg_search(PowerPCCPU *cpu, hwaddr hash,\n\n                                     uint32_t slb_pshift, bool secondary,\n\n                                     target_ulong ptem, ppc_hash_pte64_t *pte)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    int i;\n\n    uint64_t token;\n\n    target_ulong pte0, pte1;\n\n    target_ulong pte_index;\n\n\n\n    pte_index = (hash & env->htab_mask) * HPTES_PER_GROUP;\n\n    token = ppc_hash64_start_access(cpu, pte_index);\n\n    if (!token) {\n\n        return -1;\n\n    }\n\n    for (i = 0; i < HPTES_PER_GROUP; i++) {\n\n        pte0 = ppc_hash64_load_hpte0(cpu, token, i);\n\n        pte1 = ppc_hash64_load_hpte1(cpu, token, i);\n\n\n\n        if ((pte0 & HPTE64_V_VALID)\n\n            && (secondary == !!(pte0 & HPTE64_V_SECONDARY))\n\n            && HPTE64_V_COMPARE(pte0, ptem)) {\n\n            uint32_t pshift = ppc_hash64_pte_size_decode(pte1, slb_pshift);\n\n            if (pshift == 0) {\n\n                continue;\n\n            }\n\n            /* We don't do anything with pshift yet as qemu TLB only deals\n\n             * with 4K pages anyway\n\n             */\n\n            pte->pte0 = pte0;\n\n            pte->pte1 = pte1;\n\n            ppc_hash64_stop_access(cpu, token);\n\n            return (pte_index + i) * HASH_PTE_SIZE_64;\n\n        }\n\n    }\n\n    ppc_hash64_stop_access(cpu, token);\n\n    /*\n\n     * We didn't find a valid entry.\n\n     */\n\n    return -1;\n\n}\n", "idx": 22989}
{"project": "qemu", "commit_id": "54fd1b0d260cf9615d3385c93702277e81f0b639", "target": 1, "func": "int bdrv_reopen_prepare(BDRVReopenState *reopen_state, BlockReopenQueue *queue,\n\n                        Error **errp)\n\n{\n\n    int ret = -1;\n\n    Error *local_err = NULL;\n\n    BlockDriver *drv;\n\n    QemuOpts *opts;\n\n    const char *value;\n\n    bool read_only;\n\n\n\n    assert(reopen_state != NULL);\n\n    assert(reopen_state->bs->drv != NULL);\n\n    drv = reopen_state->bs->drv;\n\n\n\n    /* Process generic block layer options */\n\n    opts = qemu_opts_create(&bdrv_runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, reopen_state->options, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto error;\n\n    }\n\n\n\n    update_flags_from_options(&reopen_state->flags, opts);\n\n\n\n    /* node-name and driver must be unchanged. Put them back into the QDict, so\n\n     * that they are checked at the end of this function. */\n\n    value = qemu_opt_get(opts, \"node-name\");\n\n    if (value) {\n\n        qdict_put_str(reopen_state->options, \"node-name\", value);\n\n    }\n\n\n\n    value = qemu_opt_get(opts, \"driver\");\n\n    if (value) {\n\n        qdict_put_str(reopen_state->options, \"driver\", value);\n\n    }\n\n\n\n    /* If we are to stay read-only, do not allow permission change\n\n     * to r/w. Attempting to set to r/w may fail if either BDRV_O_ALLOW_RDWR is\n\n     * not set, or if the BDS still has copy_on_read enabled */\n\n    read_only = !(reopen_state->flags & BDRV_O_RDWR);\n\n    ret = bdrv_can_set_read_only(reopen_state->bs, read_only, true, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    /* Calculate required permissions after reopening */\n\n    bdrv_reopen_perm(queue, reopen_state->bs,\n\n                     &reopen_state->perm, &reopen_state->shared_perm);\n\n\n\n    ret = bdrv_flush(reopen_state->bs);\n\n    if (ret) {\n\n        error_setg_errno(errp, -ret, \"Error flushing drive\");\n\n        goto error;\n\n    }\n\n\n\n    if (drv->bdrv_reopen_prepare) {\n\n        ret = drv->bdrv_reopen_prepare(reopen_state, queue, &local_err);\n\n        if (ret) {\n\n            if (local_err != NULL) {\n\n                error_propagate(errp, local_err);\n\n            } else {\n\n                error_setg(errp, \"failed while preparing to reopen image '%s'\",\n\n                           reopen_state->bs->filename);\n\n            }\n\n            goto error;\n\n        }\n\n    } else {\n\n        /* It is currently mandatory to have a bdrv_reopen_prepare()\n\n         * handler for each supported drv. */\n\n        error_setg(errp, \"Block format '%s' used by node '%s' \"\n\n                   \"does not support reopening files\", drv->format_name,\n\n                   bdrv_get_device_or_node_name(reopen_state->bs));\n\n        ret = -1;\n\n        goto error;\n\n    }\n\n\n\n    /* Options that are not handled are only okay if they are unchanged\n\n     * compared to the old state. It is expected that some options are only\n\n     * used for the initial open, but not reopen (e.g. filename) */\n\n    if (qdict_size(reopen_state->options)) {\n\n        const QDictEntry *entry = qdict_first(reopen_state->options);\n\n\n\n        do {\n\n            QString *new_obj = qobject_to_qstring(entry->value);\n\n            const char *new = qstring_get_str(new_obj);\n\n            /*\n\n             * Caution: while qdict_get_try_str() is fine, getting\n\n             * non-string types would require more care.  When\n\n             * bs->options come from -blockdev or blockdev_add, its\n\n             * members are typed according to the QAPI schema, but\n\n             * when they come from -drive, they're all QString.\n\n             */\n\n            const char *old = qdict_get_try_str(reopen_state->bs->options,\n\n                                                entry->key);\n\n\n\n            if (!old || strcmp(new, old)) {\n\n                error_setg(errp, \"Cannot change the option '%s'\", entry->key);\n\n                ret = -EINVAL;\n\n                goto error;\n\n            }\n\n        } while ((entry = qdict_next(reopen_state->options, entry)));\n\n    }\n\n\n\n    ret = bdrv_check_perm(reopen_state->bs, queue, reopen_state->perm,\n\n                          reopen_state->shared_perm, NULL, errp);\n\n    if (ret < 0) {\n\n        goto error;\n\n    }\n\n\n\n    ret = 0;\n\n\n\nerror:\n\n    qemu_opts_del(opts);\n\n    return ret;\n\n}\n", "idx": 22990}
{"project": "qemu", "commit_id": "43c5d8f8001eb467abf091c3e2a8aca3d1e5b522", "target": 0, "func": "void qemu_opts_print(QemuOpts *opts)\n\n{\n\n    QemuOpt *opt;\n\n    QemuOptDesc *desc = opts->list->desc;\n\n\n\n    if (desc[0].name == NULL) {\n\n        QTAILQ_FOREACH(opt, &opts->head, next) {\n\n            printf(\"%s=\\\"%s\\\" \", opt->name, opt->str);\n\n        }\n\n        return;\n\n    }\n\n    for (; desc && desc->name; desc++) {\n\n        const char *value;\n\n        QemuOpt *opt = qemu_opt_find(opts, desc->name);\n\n\n\n        value = opt ? opt->str : desc->def_value_str;\n\n        if (!value) {\n\n            continue;\n\n        }\n\n        if (desc->type == QEMU_OPT_STRING) {\n\n            printf(\"%s='%s' \", desc->name, value);\n\n        } else if ((desc->type == QEMU_OPT_SIZE ||\n\n                    desc->type == QEMU_OPT_NUMBER) && opt) {\n\n            printf(\"%s=%\" PRId64 \" \", desc->name, opt->value.uint);\n\n        } else {\n\n            printf(\"%s=%s \", desc->name, value);\n\n        }\n\n    }\n\n}\n", "idx": 22994}
{"project": "qemu", "commit_id": "4d5942332f42a17c9ebbf67ef335ec72fcd789ff", "target": 0, "func": "static GSList *gd_vc_vte_init(GtkDisplayState *s, VirtualConsole *vc,\n\n                              CharDriverState *chr, int idx,\n\n                              GSList *group, GtkWidget *view_menu)\n\n{\n\n    char buffer[32];\n\n    GtkWidget *box;\n\n    GtkWidget *scrollbar;\n\n    GtkAdjustment *vadjustment;\n\n    VirtualConsole *tmp_vc = chr->opaque;\n\n\n\n    vc->s = s;\n\n    vc->vte.echo = tmp_vc->vte.echo;\n\n\n\n    vc->vte.chr = chr;\n\n    chr->opaque = vc;\n\n    g_free(tmp_vc);\n\n\n\n    snprintf(buffer, sizeof(buffer), \"vc%d\", idx);\n\n    vc->label = g_strdup_printf(\"%s\", vc->vte.chr->label\n\n                                ? vc->vte.chr->label : buffer);\n\n    group = gd_vc_menu_init(s, vc, idx, group, view_menu);\n\n\n\n    vc->vte.terminal = vte_terminal_new();\n\n    g_signal_connect(vc->vte.terminal, \"commit\", G_CALLBACK(gd_vc_in), vc);\n\n\n\n    /* The documentation says that the default is UTF-8, but actually it is\n\n     * 7-bit ASCII at least in VTE 0.38.\n\n     */\n\n#if VTE_CHECK_VERSION(0, 40, 0)\n\n    vte_terminal_set_encoding(VTE_TERMINAL(vc->vte.terminal), \"UTF-8\", NULL);\n\n#else\n\n    vte_terminal_set_encoding(VTE_TERMINAL(vc->vte.terminal), \"UTF-8\");\n\n#endif\n\n\n\n    vte_terminal_set_scrollback_lines(VTE_TERMINAL(vc->vte.terminal), -1);\n\n    vte_terminal_set_size(VTE_TERMINAL(vc->vte.terminal),\n\n                          VC_TERM_X_MIN, VC_TERM_Y_MIN);\n\n\n\n#if VTE_CHECK_VERSION(0, 28, 0) && GTK_CHECK_VERSION(3, 0, 0)\n\n    vadjustment = gtk_scrollable_get_vadjustment\n\n        (GTK_SCROLLABLE(vc->vte.terminal));\n\n#else\n\n    vadjustment = vte_terminal_get_adjustment(VTE_TERMINAL(vc->vte.terminal));\n\n#endif\n\n\n\n#if GTK_CHECK_VERSION(3, 0, 0)\n\n    box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 2);\n\n    scrollbar = gtk_scrollbar_new(GTK_ORIENTATION_VERTICAL, vadjustment);\n\n#else\n\n    box = gtk_hbox_new(false, 2);\n\n    scrollbar = gtk_vscrollbar_new(vadjustment);\n\n#endif\n\n\n\n    gtk_box_pack_start(GTK_BOX(box), vc->vte.terminal, TRUE, TRUE, 0);\n\n    gtk_box_pack_start(GTK_BOX(box), scrollbar, FALSE, FALSE, 0);\n\n\n\n    vc->vte.box = box;\n\n    vc->vte.scrollbar = scrollbar;\n\n\n\n    g_signal_connect(vadjustment, \"changed\",\n\n                     G_CALLBACK(gd_vc_adjustment_changed), vc);\n\n\n\n    vc->type = GD_VC_VTE;\n\n    vc->tab_item = box;\n\n    vc->focus = vc->vte.terminal;\n\n    gtk_notebook_append_page(GTK_NOTEBOOK(s->notebook), vc->tab_item,\n\n                             gtk_label_new(vc->label));\n\n\n\n    qemu_chr_be_generic_open(vc->vte.chr);\n\n    if (vc->vte.chr->init) {\n\n        vc->vte.chr->init(vc->vte.chr);\n\n    }\n\n\n\n    return group;\n\n}\n", "idx": 22995}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_opt_foreach(QemuOpts *opts, qemu_opt_loopfunc func, void *opaque,\n\n                     int abort_on_failure)\n\n{\n\n    QemuOpt *opt;\n\n    int rc = 0;\n\n\n\n    TAILQ_FOREACH(opt, &opts->head, next) {\n\n        rc = func(opt->name, opt->str, opaque);\n\n        if (abort_on_failure  &&  rc != 0)\n\n            break;\n\n    }\n\n    return rc;\n\n}\n", "idx": 22996}
{"project": "qemu", "commit_id": "cb51ac2ffe3649eb8f5c65dccc2012f0ba2c6b12", "target": 0, "func": "static void build_fadt(GArray *table_data, BIOSLinker *linker,\n\n                       VirtMachineState *vms, unsigned dsdt_tbl_offset)\n\n{\n\n    AcpiFadtDescriptorRev5_1 *fadt = acpi_data_push(table_data, sizeof(*fadt));\n\n    unsigned dsdt_entry_offset = (char *)&fadt->dsdt - table_data->data;\n\n    uint16_t bootflags;\n\n\n\n    switch (vms->psci_conduit) {\n\n    case QEMU_PSCI_CONDUIT_DISABLED:\n\n        bootflags = 0;\n\n        break;\n\n    case QEMU_PSCI_CONDUIT_HVC:\n\n        bootflags = ACPI_FADT_ARM_PSCI_COMPLIANT | ACPI_FADT_ARM_PSCI_USE_HVC;\n\n        break;\n\n    case QEMU_PSCI_CONDUIT_SMC:\n\n        bootflags = ACPI_FADT_ARM_PSCI_COMPLIANT;\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n\n\n    /* Hardware Reduced = 1 and use PSCI 0.2+ */\n\n    fadt->flags = cpu_to_le32(1 << ACPI_FADT_F_HW_REDUCED_ACPI);\n\n    fadt->arm_boot_flags = cpu_to_le16(bootflags);\n\n\n\n    /* ACPI v5.1 (fadt->revision.fadt->minor_revision) */\n\n    fadt->minor_revision = 0x1;\n\n\n\n    /* DSDT address to be filled by Guest linker */\n\n    bios_linker_loader_add_pointer(linker,\n\n        ACPI_BUILD_TABLE_FILE, dsdt_entry_offset, sizeof(fadt->dsdt),\n\n        ACPI_BUILD_TABLE_FILE, dsdt_tbl_offset);\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)fadt, \"FACP\", sizeof(*fadt), 5, NULL, NULL);\n\n}\n", "idx": 22997}
{"project": "qemu", "commit_id": "7df9381b7aa56c897e344f3bfe43bf5848bbd3e0", "target": 0, "func": "static void vfio_pci_size_rom(VFIOPCIDevice *vdev)\n\n{\n\n    uint32_t orig, size = cpu_to_le32((uint32_t)PCI_ROM_ADDRESS_MASK);\n\n    off_t offset = vdev->config_offset + PCI_ROM_ADDRESS;\n\n    DeviceState *dev = DEVICE(vdev);\n\n    char name[32];\n\n    int fd = vdev->vbasedev.fd;\n\n\n\n    if (vdev->pdev.romfile || !vdev->pdev.rom_bar) {\n\n        /* Since pci handles romfile, just print a message and return */\n\n        if (vfio_blacklist_opt_rom(vdev) && vdev->pdev.romfile) {\n\n            error_printf(\"Warning : Device at %04x:%02x:%02x.%x \"\n\n                         \"is known to cause system instability issues during \"\n\n                         \"option rom execution. \"\n\n                         \"Proceeding anyway since user specified romfile\\n\",\n\n                         vdev->host.domain, vdev->host.bus, vdev->host.slot,\n\n                         vdev->host.function);\n\n        }\n\n        return;\n\n    }\n\n\n\n    /*\n\n     * Use the same size ROM BAR as the physical device.  The contents\n\n     * will get filled in later when the guest tries to read it.\n\n     */\n\n    if (pread(fd, &orig, 4, offset) != 4 ||\n\n        pwrite(fd, &size, 4, offset) != 4 ||\n\n        pread(fd, &size, 4, offset) != 4 ||\n\n        pwrite(fd, &orig, 4, offset) != 4) {\n\n        error_report(\"%s(%04x:%02x:%02x.%x) failed: %m\",\n\n                     __func__, vdev->host.domain, vdev->host.bus,\n\n                     vdev->host.slot, vdev->host.function);\n\n        return;\n\n    }\n\n\n\n    size = ~(le32_to_cpu(size) & PCI_ROM_ADDRESS_MASK) + 1;\n\n\n\n    if (!size) {\n\n        return;\n\n    }\n\n\n\n    if (vfio_blacklist_opt_rom(vdev)) {\n\n        if (dev->opts && qemu_opt_get(dev->opts, \"rombar\")) {\n\n            error_printf(\"Warning : Device at %04x:%02x:%02x.%x \"\n\n                         \"is known to cause system instability issues during \"\n\n                         \"option rom execution. \"\n\n                         \"Proceeding anyway since user specified non zero value for \"\n\n                         \"rombar\\n\",\n\n                         vdev->host.domain, vdev->host.bus, vdev->host.slot,\n\n                         vdev->host.function);\n\n        } else {\n\n            error_printf(\"Warning : Rom loading for device at \"\n\n                         \"%04x:%02x:%02x.%x has been disabled due to \"\n\n                         \"system instability issues. \"\n\n                         \"Specify rombar=1 or romfile to force\\n\",\n\n                         vdev->host.domain, vdev->host.bus, vdev->host.slot,\n\n                         vdev->host.function);\n\n            return;\n\n        }\n\n    }\n\n\n\n    trace_vfio_pci_size_rom(vdev->vbasedev.name, size);\n\n\n\n    snprintf(name, sizeof(name), \"vfio[%04x:%02x:%02x.%x].rom\",\n\n             vdev->host.domain, vdev->host.bus, vdev->host.slot,\n\n             vdev->host.function);\n\n\n\n    memory_region_init_io(&vdev->pdev.rom, OBJECT(vdev),\n\n                          &vfio_rom_ops, vdev, name, size);\n\n\n\n    pci_register_bar(&vdev->pdev, PCI_ROM_SLOT,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &vdev->pdev.rom);\n\n\n\n    vdev->pdev.has_rom = true;\n\n    vdev->rom_read_failed = false;\n\n}\n", "idx": 22998}
{"project": "qemu", "commit_id": "1cf0d2b8352a2df35919030b84dbfc713ee9b9be", "target": 0, "func": "static int vt82c686b_initfn(PCIDevice *d)\n\n{\n\n    uint8_t *pci_conf;\n\n    uint8_t *wmask;\n\n    int i;\n\n\n\n    isa_bus_new(&d->qdev);\n\n\n\n    pci_conf = d->config;\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_VIA);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_VIA_ISA_BRIDGE);\n\n    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);\n\n    pci_config_set_prog_interface(pci_conf, 0x0);\n\n    pci_config_set_revision(pci_conf,0x40); /* Revision 4.0 */\n\n\n\n    wmask = d->wmask;\n\n    for (i = 0x00; i < 0xff; i++) {\n\n       if (i<=0x03 || (i>=0x08 && i<=0x3f)) {\n\n           wmask[i] = 0x00;\n\n       }\n\n    }\n\n\n\n    qemu_register_reset(vt82c686b_reset, d);\n\n\n\n    return 0;\n\n}\n", "idx": 23000}
{"project": "qemu", "commit_id": "68540b1a1b505d9578699b03fe0b5da716a21dcc", "target": 0, "func": "static int handle_diag(S390CPU *cpu, struct kvm_run *run, uint32_t ipb)\n\n{\n\n    int r = 0;\n\n    uint16_t func_code;\n\n\n\n    /*\n\n     * For any diagnose call we support, bits 48-63 of the resulting\n\n     * address specify the function code; the remainder is ignored.\n\n     */\n\n    func_code = decode_basedisp_rs(&cpu->env, ipb) & DIAG_KVM_CODE_MASK;\n\n    switch (func_code) {\n\n    case DIAG_IPL:\n\n        kvm_handle_diag_308(cpu, run);\n\n        break;\n\n    case DIAG_KVM_HYPERCALL:\n\n        r = handle_hypercall(cpu, run);\n\n        break;\n\n    case DIAG_KVM_BREAKPOINT:\n\n        r = handle_sw_breakpoint(cpu, run);\n\n        break;\n\n    default:\n\n        DPRINTF(\"KVM: unknown DIAG: 0x%x\\n\", func_code);\n\n        r = -1;\n\n        break;\n\n    }\n\n\n\n    return r;\n\n}\n", "idx": 23001}
{"project": "qemu", "commit_id": "95129d6fc9ead97155627a4ca0cfd37282883658", "target": 0, "func": "static bool vring_notify(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    uint16_t old, new;\n\n    bool v;\n\n    /* We need to expose used array entries before checking used event. */\n\n    smp_mb();\n\n    /* Always notify when queue is empty (when feature acknowledge) */\n\n    if (virtio_has_feature(vdev, VIRTIO_F_NOTIFY_ON_EMPTY) &&\n\n        !vq->inuse && vring_avail_idx(vq) == vq->last_avail_idx) {\n\n        return true;\n\n    }\n\n\n\n    if (!virtio_has_feature(vdev, VIRTIO_RING_F_EVENT_IDX)) {\n\n        return !(vring_avail_flags(vq) & VRING_AVAIL_F_NO_INTERRUPT);\n\n    }\n\n\n\n    v = vq->signalled_used_valid;\n\n    vq->signalled_used_valid = true;\n\n    old = vq->signalled_used;\n\n    new = vq->signalled_used = vring_used_idx(vq);\n\n    return !v || vring_need_event(vring_get_used_event(vq), new, old);\n\n}\n", "idx": 23002}
{"project": "qemu", "commit_id": "6643e2f001f207bdb85646a4c48d1e13244d87c3", "target": 0, "func": "static void kvm_do_inject_x86_mce(void *_data)\n\n{\n\n    struct kvm_x86_mce_data *data = _data;\n\n    int r;\n\n\n\n    /* If there is an MCE exception being processed, ignore this SRAO MCE */\n\n    if ((data->env->mcg_cap & MCG_SER_P) &&\n\n        !(data->mce->status & MCI_STATUS_AR)) {\n\n        r = kvm_mce_in_exception(data->env);\n\n        if (r == -1) {\n\n            fprintf(stderr, \"Failed to get MCE status\\n\");\n\n        } else if (r) {\n\n            return;\n\n        }\n\n    }\n\n\n\n    r = kvm_set_mce(data->env, data->mce);\n\n    if (r < 0) {\n\n        perror(\"kvm_set_mce FAILED\");\n\n        if (data->abort_on_error) {\n\n            abort();\n\n        }\n\n    }\n\n}\n", "idx": 23003}
{"project": "qemu", "commit_id": "c1e1a491906bd1d769edb16f2b2be7ff6833d26f", "target": 0, "func": "void bareetraxfs_init (ram_addr_t ram_size, int vga_ram_size,\n\n                       const char *boot_device, DisplayState *ds,\n\n                       const char *kernel_filename, const char *kernel_cmdline,\n\n                       const char *initrd_filename, const char *cpu_model)\n\n{\n\n    CPUState *env;\n\n    struct etraxfs_pic *pic;\n\n    void *etraxfs_dmac;\n\n    struct etraxfs_dma_client *eth[2] = {NULL, NULL};\n\n    int kernel_size;\n\n    int i;\n\n    ram_addr_t phys_ram;\n\n    ram_addr_t phys_flash;\n\n    ram_addr_t phys_intmem;\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"crisv32\";\n\n    }\n\n    env = cpu_init(cpu_model);\n\n    qemu_register_reset(main_cpu_reset, env);\n\n\n\n    /* allocate RAM */\n\n    phys_ram = qemu_ram_alloc(ram_size);\n\n    cpu_register_physical_memory(0x40000000, ram_size, phys_ram | IO_MEM_RAM);\n\n\n\n    /* The ETRAX-FS has 128Kb on chip ram, the docs refer to it as the \n\n       internal memory.  */\n\n    phys_intmem = qemu_ram_alloc(INTMEM_SIZE);\n\n    cpu_register_physical_memory(0x38000000, INTMEM_SIZE,\n\n                                 phys_intmem | IO_MEM_RAM);\n\n\n\n\n\n    phys_flash = qemu_ram_alloc(FLASH_SIZE);\n\n    i = drive_get_index(IF_PFLASH, 0, 0);\n\n    pflash_cfi02_register(0x0, phys_flash,\n\n                          i != -1 ? drives_table[i].bdrv : NULL, (64 * 1024),\n\n                          FLASH_SIZE >> 16,\n\n                          1, 2, 0x0000, 0x0000, 0x0000, 0x0000,\n\n                          0x555, 0x2aa);\n\n    pic = etraxfs_pic_init(env, 0x3001c000);\n\n    etraxfs_dmac = etraxfs_dmac_init(env, 0x30000000, 10);\n\n    for (i = 0; i < 10; i++) {\n\n        /* On ETRAX, odd numbered channels are inputs.  */\n\n        etraxfs_dmac_connect(etraxfs_dmac, i, pic->irq + 7 + i, i & 1);\n\n    }\n\n\n\n    /* Add the two ethernet blocks.  */\n\n    eth[0] = etraxfs_eth_init(&nd_table[0], env, pic->irq + 25, 0x30034000);\n\n    if (nb_nics > 1)\n\n        eth[1] = etraxfs_eth_init(&nd_table[1], env, pic->irq + 26, 0x30036000);\n\n\n\n    /* The DMA Connector block is missing, hardwire things for now.  */\n\n    etraxfs_dmac_connect_client(etraxfs_dmac, 0, eth[0]);\n\n    etraxfs_dmac_connect_client(etraxfs_dmac, 1, eth[0] + 1);\n\n    if (eth[1]) {\n\n        etraxfs_dmac_connect_client(etraxfs_dmac, 6, eth[1]);\n\n        etraxfs_dmac_connect_client(etraxfs_dmac, 7, eth[1] + 1);\n\n    }\n\n\n\n    /* 2 timers.  */\n\n    etraxfs_timer_init(env, pic->irq + 0x1b, pic->nmi + 1, 0x3001e000);\n\n    etraxfs_timer_init(env, pic->irq + 0x1b, pic->nmi + 1, 0x3005e000);\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        if (serial_hds[i]) {\n\n            etraxfs_ser_init(env, pic->irq + 0x14 + i,\n\n                             serial_hds[i], 0x30026000 + i * 0x2000);\n\n        }\n\n    }\n\n\n\n    if (kernel_filename) {\n\n        uint64_t entry, high;\n\n        int kcmdline_len;\n\n\n\n        /* Boots a kernel elf binary, os/linux-2.6/vmlinux from the axis \n\n           devboard SDK.  */\n\n        kernel_size = load_elf(kernel_filename, -0x80000000LL,\n\n                               &entry, NULL, &high);\n\n        bootstrap_pc = entry;\n\n        if (kernel_size < 0) {\n\n            /* Takes a kimage from the axis devboard SDK.  */\n\n            kernel_size = load_image(kernel_filename, phys_ram_base + 0x4000);\n\n            bootstrap_pc = 0x40004000;\n\n            env->regs[9] = 0x40004000 + kernel_size;\n\n        }\n\n        env->regs[8] = 0x56902387; /* RAM init magic.  */\n\n\n\n        if (kernel_cmdline && (kcmdline_len = strlen(kernel_cmdline))) {\n\n            if (kcmdline_len > 256) {\n\n                fprintf(stderr, \"Too long CRIS kernel cmdline (max 256)\\n\");\n\n                exit(1);\n\n            }\n\n            pstrcpy_targphys(high, 256, kernel_cmdline);\n\n            /* Let the kernel know we are modifying the cmdline.  */\n\n            env->regs[10] = 0x87109563;\n\n            env->regs[11] = high;\n\n        }\n\n    }\n\n    env->pc = bootstrap_pc;\n\n\n\n    printf (\"pc =%x\\n\", env->pc);\n\n    printf (\"ram size =%ld\\n\", ram_size);\n\n}\n", "idx": 23004}
{"project": "qemu", "commit_id": "bec1631100323fac0900aea71043d5c4e22fc2fa", "target": 0, "func": "static void tcg_out_bpcc(TCGContext *s, int scond, int flags, int label)\n\n{\n\n    TCGLabel *l = &s->labels[label];\n\n    int off19;\n\n\n\n    if (l->has_value) {\n\n        off19 = INSN_OFF19(tcg_pcrel_diff(s, l->u.value_ptr));\n\n    } else {\n\n        /* Make sure to preserve destinations during retranslation.  */\n\n        off19 = *s->code_ptr & INSN_OFF19(-1);\n\n        tcg_out_reloc(s, s->code_ptr, R_SPARC_WDISP19, label, 0);\n\n    }\n\n    tcg_out_bpcc0(s, scond, flags, off19);\n\n}\n", "idx": 23005}
{"project": "qemu", "commit_id": "9042c0e20de166542b603621fd30dc8be95dfd4d", "target": 0, "func": "void load_kernel (CPUState *env, int ram_size, const char *kernel_filename,\n\n\t\t  const char *kernel_cmdline,\n\n\t\t  const char *initrd_filename)\n\n{\n\n    int64_t entry = 0;\n\n    long kernel_size, initrd_size;\n\n\n\n    kernel_size = load_elf(kernel_filename, VIRT_TO_PHYS_ADDEND, &entry);\n\n    if (kernel_size >= 0) {\n\n        if ((entry & ~0x7fffffffULL) == 0x80000000)\n\n            entry = (int32_t)entry;\n\n        env->PC = entry;\n\n    } else {\n\n        kernel_size = load_image(kernel_filename,\n\n                                 phys_ram_base + KERNEL_LOAD_ADDR + VIRT_TO_PHYS_ADDEND);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n        env->PC = KERNEL_LOAD_ADDR;\n\n    }\n\n\n\n    /* load initrd */\n\n    initrd_size = 0;\n\n    if (initrd_filename) {\n\n        initrd_size = load_image(initrd_filename,\n\n                                 phys_ram_base + INITRD_LOAD_ADDR + VIRT_TO_PHYS_ADDEND);\n\n        if (initrd_size == (target_ulong) -1) {\n\n            fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                    initrd_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Store command line.  */\n\n    if (initrd_size > 0) {\n\n        int ret;\n\n        ret = sprintf(phys_ram_base + (16 << 20) - 256,\n\n                      \"rd_start=0x\" TLSZ \" rd_size=%li \",\n\n                      INITRD_LOAD_ADDR,\n\n                      initrd_size);\n\n        strcpy (phys_ram_base + (16 << 20) - 256 + ret, kernel_cmdline);\n\n    }\n\n    else {\n\n        strcpy (phys_ram_base + (16 << 20) - 256, kernel_cmdline);\n\n    }\n\n\n\n    *(int *)(phys_ram_base + (16 << 20) - 260) = tswap32 (0x12345678);\n\n    *(int *)(phys_ram_base + (16 << 20) - 264) = tswap32 (ram_size);\n\n}\n", "idx": 23006}
{"project": "qemu", "commit_id": "9ef91a677110ec200d7b2904fc4bcae5a77329ad", "target": 0, "func": "static int posix_aio_init(void)\n\n{\n\n    struct sigaction act;\n\n    PosixAioState *s;\n\n    int fds[2];\n\n    struct qemu_paioinit ai;\n\n  \n\n    if (posix_aio_state)\n\n        return 0;\n\n\n\n    s = qemu_malloc(sizeof(PosixAioState));\n\n\n\n    sigfillset(&act.sa_mask);\n\n    act.sa_flags = 0; /* do not restart syscalls to interrupt select() */\n\n    act.sa_handler = aio_signal_handler;\n\n    sigaction(SIGUSR2, &act, NULL);\n\n\n\n    s->first_aio = NULL;\n\n    if (pipe(fds) == -1) {\n\n        fprintf(stderr, \"failed to create pipe\\n\");\n\n        return -errno;\n\n    }\n\n\n\n    s->rfd = fds[0];\n\n    s->wfd = fds[1];\n\n\n\n    fcntl(s->rfd, F_SETFL, O_NONBLOCK);\n\n    fcntl(s->wfd, F_SETFL, O_NONBLOCK);\n\n\n\n    qemu_aio_set_fd_handler(s->rfd, posix_aio_read, NULL, posix_aio_flush, s);\n\n\n\n    memset(&ai, 0, sizeof(ai));\n\n    ai.aio_threads = 64;\n\n    ai.aio_num = 64;\n\n    qemu_paio_init(&ai);\n\n\n\n    posix_aio_state = s;\n\n\n\n    return 0;\n\n}\n", "idx": 23007}
{"project": "qemu", "commit_id": "e5b8b0d4ba29fe1268ba049519a1b0cf8552a21a", "target": 0, "func": "e1000_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n\n{\n\n    E1000State *s = DO_UPCAST(NICState, nc, nc)->opaque;\n\n    struct e1000_rx_desc desc;\n\n    dma_addr_t base;\n\n    unsigned int n, rdt;\n\n    uint32_t rdh_start;\n\n    uint16_t vlan_special = 0;\n\n    uint8_t vlan_status = 0, vlan_offset = 0;\n\n    uint8_t min_buf[MIN_BUF_SIZE];\n\n    size_t desc_offset;\n\n    size_t desc_size;\n\n    size_t total_size;\n\n\n\n    if (!(s->mac_reg[RCTL] & E1000_RCTL_EN))\n\n        return -1;\n\n\n\n    /* Pad to minimum Ethernet frame length */\n\n    if (size < sizeof(min_buf)) {\n\n        memcpy(min_buf, buf, size);\n\n        memset(&min_buf[size], 0, sizeof(min_buf) - size);\n\n        buf = min_buf;\n\n        size = sizeof(min_buf);\n\n    }\n\n\n\n    if (!receive_filter(s, buf, size))\n\n        return size;\n\n\n\n    if (vlan_enabled(s) && is_vlan_packet(s, buf)) {\n\n        vlan_special = cpu_to_le16(be16_to_cpup((uint16_t *)(buf + 14)));\n\n        memmove((uint8_t *)buf + 4, buf, 12);\n\n        vlan_status = E1000_RXD_STAT_VP;\n\n        vlan_offset = 4;\n\n        size -= 4;\n\n    }\n\n\n\n    rdh_start = s->mac_reg[RDH];\n\n    desc_offset = 0;\n\n    total_size = size + fcs_len(s);\n\n    if (!e1000_has_rxbufs(s, total_size)) {\n\n            set_ics(s, 0, E1000_ICS_RXO);\n\n            return -1;\n\n    }\n\n    do {\n\n        desc_size = total_size - desc_offset;\n\n        if (desc_size > s->rxbuf_size) {\n\n            desc_size = s->rxbuf_size;\n\n        }\n\n        base = rx_desc_base(s) + sizeof(desc) * s->mac_reg[RDH];\n\n        pci_dma_read(&s->dev, base, &desc, sizeof(desc));\n\n        desc.special = vlan_special;\n\n        desc.status |= (vlan_status | E1000_RXD_STAT_DD);\n\n        if (desc.buffer_addr) {\n\n            if (desc_offset < size) {\n\n                size_t copy_size = size - desc_offset;\n\n                if (copy_size > s->rxbuf_size) {\n\n                    copy_size = s->rxbuf_size;\n\n                }\n\n                pci_dma_write(&s->dev, le64_to_cpu(desc.buffer_addr),\n\n                              buf + desc_offset + vlan_offset, copy_size);\n\n            }\n\n            desc_offset += desc_size;\n\n            desc.length = cpu_to_le16(desc_size);\n\n            if (desc_offset >= total_size) {\n\n                desc.status |= E1000_RXD_STAT_EOP | E1000_RXD_STAT_IXSM;\n\n            } else {\n\n                /* Guest zeroing out status is not a hardware requirement.\n\n                   Clear EOP in case guest didn't do it. */\n\n                desc.status &= ~E1000_RXD_STAT_EOP;\n\n            }\n\n        } else { // as per intel docs; skip descriptors with null buf addr\n\n            DBGOUT(RX, \"Null RX descriptor!!\\n\");\n\n        }\n\n        pci_dma_write(&s->dev, base, &desc, sizeof(desc));\n\n\n\n        if (++s->mac_reg[RDH] * sizeof(desc) >= s->mac_reg[RDLEN])\n\n            s->mac_reg[RDH] = 0;\n\n        s->check_rxov = 1;\n\n        /* see comment in start_xmit; same here */\n\n        if (s->mac_reg[RDH] == rdh_start) {\n\n            DBGOUT(RXERR, \"RDH wraparound @%x, RDT %x, RDLEN %x\\n\",\n\n                   rdh_start, s->mac_reg[RDT], s->mac_reg[RDLEN]);\n\n            set_ics(s, 0, E1000_ICS_RXO);\n\n            return -1;\n\n        }\n\n    } while (desc_offset < total_size);\n\n\n\n    s->mac_reg[GPRC]++;\n\n    s->mac_reg[TPR]++;\n\n    /* TOR - Total Octets Received:\n\n     * This register includes bytes received in a packet from the <Destination\n\n     * Address> field through the <CRC> field, inclusively.\n\n     */\n\n    n = s->mac_reg[TORL] + size + /* Always include FCS length. */ 4;\n\n    if (n < s->mac_reg[TORL])\n\n        s->mac_reg[TORH]++;\n\n    s->mac_reg[TORL] = n;\n\n\n\n    n = E1000_ICS_RXT0;\n\n    if ((rdt = s->mac_reg[RDT]) < s->mac_reg[RDH])\n\n        rdt += s->mac_reg[RDLEN] / sizeof(desc);\n\n    if (((rdt - s->mac_reg[RDH]) * sizeof(desc)) <= s->mac_reg[RDLEN] >>\n\n        s->rxbuf_min_shift)\n\n        n |= E1000_ICS_RXDMT0;\n\n\n\n    set_ics(s, 0, n);\n\n\n\n    return size;\n\n}\n", "idx": 23008}
{"project": "qemu", "commit_id": "1ae2757c6c4525c9b42f408c86818f843bad7418", "target": 0, "func": "void virtqueue_get_avail_bytes(VirtQueue *vq, unsigned int *in_bytes,\n\n                               unsigned int *out_bytes,\n\n                               unsigned max_in_bytes, unsigned max_out_bytes)\n\n{\n\n    unsigned int idx;\n\n    unsigned int total_bufs, in_total, out_total;\n\n\n\n    idx = vq->last_avail_idx;\n\n\n\n    total_bufs = in_total = out_total = 0;\n\n    while (virtqueue_num_heads(vq, idx)) {\n\n        unsigned int max, num_bufs, indirect = 0;\n\n        hwaddr desc_pa;\n\n        int i;\n\n\n\n        max = vq->vring.num;\n\n        num_bufs = total_bufs;\n\n        i = virtqueue_get_head(vq, idx++);\n\n        desc_pa = vq->vring.desc;\n\n\n\n        if (vring_desc_flags(desc_pa, i) & VRING_DESC_F_INDIRECT) {\n\n            if (vring_desc_len(desc_pa, i) % sizeof(VRingDesc)) {\n\n                error_report(\"Invalid size for indirect buffer table\");\n\n                exit(1);\n\n            }\n\n\n\n            /* If we've got too many, that implies a descriptor loop. */\n\n            if (num_bufs >= max) {\n\n                error_report(\"Looped descriptor\");\n\n                exit(1);\n\n            }\n\n\n\n            /* loop over the indirect descriptor table */\n\n            indirect = 1;\n\n            max = vring_desc_len(desc_pa, i) / sizeof(VRingDesc);\n\n            num_bufs = i = 0;\n\n            desc_pa = vring_desc_addr(desc_pa, i);\n\n        }\n\n\n\n        do {\n\n            /* If we've got too many, that implies a descriptor loop. */\n\n            if (++num_bufs > max) {\n\n                error_report(\"Looped descriptor\");\n\n                exit(1);\n\n            }\n\n\n\n            if (vring_desc_flags(desc_pa, i) & VRING_DESC_F_WRITE) {\n\n                in_total += vring_desc_len(desc_pa, i);\n\n            } else {\n\n                out_total += vring_desc_len(desc_pa, i);\n\n            }\n\n            if (in_total >= max_in_bytes && out_total >= max_out_bytes) {\n\n                goto done;\n\n            }\n\n        } while ((i = virtqueue_next_desc(desc_pa, i, max)) != max);\n\n\n\n        if (!indirect)\n\n            total_bufs = num_bufs;\n\n        else\n\n            total_bufs++;\n\n    }\n\ndone:\n\n    if (in_bytes) {\n\n        *in_bytes = in_total;\n\n    }\n\n    if (out_bytes) {\n\n        *out_bytes = out_total;\n\n    }\n\n}\n", "idx": 23009}
{"project": "qemu", "commit_id": "eba90e4efc80bc30c7d952ee6ea442207517a0da", "target": 0, "func": "int64_t strtosz_suffix_unit(const char *nptr, char **end,\n\n                            const char default_suffix, int64_t unit)\n\n{\n\n    int64_t retval = -1;\n\n    char *endptr;\n\n    unsigned char c, d;\n\n    int mul_required = 0;\n\n    double val, mul, integral, fraction;\n\n\n\n    errno = 0;\n\n    val = strtod(nptr, &endptr);\n\n    if (isnan(val) || endptr == nptr || errno != 0) {\n\n        goto fail;\n\n    }\n\n    fraction = modf(val, &integral);\n\n    if (fraction != 0) {\n\n        mul_required = 1;\n\n    }\n\n    /*\n\n     * Any whitespace character is fine for terminating the number,\n\n     * in addition we accept ',' to handle strings where the size is\n\n     * part of a multi token argument.\n\n     */\n\n    c = *endptr;\n\n    d = c;\n\n    if (qemu_isspace(c) || c == '\\0' || c == ',') {\n\n        c = 0;\n\n        d = default_suffix;\n\n    }\n\n    switch (qemu_toupper(d)) {\n\n    case STRTOSZ_DEFSUFFIX_B:\n\n        mul = 1;\n\n        if (mul_required) {\n\n            goto fail;\n\n        }\n\n        break;\n\n    case STRTOSZ_DEFSUFFIX_KB:\n\n        mul = unit;\n\n        break;\n\n    case STRTOSZ_DEFSUFFIX_MB:\n\n        mul = unit * unit;\n\n        break;\n\n    case STRTOSZ_DEFSUFFIX_GB:\n\n        mul = unit * unit * unit;\n\n        break;\n\n    case STRTOSZ_DEFSUFFIX_TB:\n\n        mul = unit * unit * unit * unit;\n\n        break;\n\n    default:\n\n        goto fail;\n\n    }\n\n    /*\n\n     * If not terminated by whitespace, ',', or \\0, increment endptr\n\n     * to point to next character, then check that we are terminated\n\n     * by an appropriate separating character, ie. whitespace, ',', or\n\n     * \\0. If not, we are seeing trailing garbage, thus fail.\n\n     */\n\n    if (c != 0) {\n\n        endptr++;\n\n        if (!qemu_isspace(*endptr) && *endptr != ',' && *endptr != 0) {\n\n            goto fail;\n\n        }\n\n    }\n\n    if ((val * mul >= INT64_MAX) || val < 0) {\n\n        goto fail;\n\n    }\n\n    retval = val * mul;\n\n\n\nfail:\n\n    if (end) {\n\n        *end = endptr;\n\n    }\n\n\n\n    return retval;\n\n}\n", "idx": 23011}
{"project": "qemu", "commit_id": "ec57db1630f9cdcd13c8c55acbc8daf5237aabf1", "target": 0, "func": "static void virtio_net_set_multiqueue(VirtIONet *n, int multiqueue, int ctrl)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n\n    int i, max = multiqueue ? n->max_queues : 1;\n\n\n\n    n->multiqueue = multiqueue;\n\n\n\n    for (i = 2; i <= n->max_queues * 2 + 1; i++) {\n\n        virtio_del_queue(vdev, i);\n\n    }\n\n\n\n    for (i = 1; i < max; i++) {\n\n        n->vqs[i].rx_vq = virtio_add_queue(vdev, 256, virtio_net_handle_rx);\n\n        if (n->vqs[i].tx_timer) {\n\n            n->vqs[i].tx_vq =\n\n                virtio_add_queue(vdev, 256, virtio_net_handle_tx_timer);\n\n            n->vqs[i].tx_timer = qemu_new_timer_ns(vm_clock,\n\n                                                   virtio_net_tx_timer,\n\n                                                   &n->vqs[i]);\n\n        } else {\n\n            n->vqs[i].tx_vq =\n\n                virtio_add_queue(vdev, 256, virtio_net_handle_tx_bh);\n\n            n->vqs[i].tx_bh = qemu_bh_new(virtio_net_tx_bh, &n->vqs[i]);\n\n        }\n\n\n\n        n->vqs[i].tx_waiting = 0;\n\n        n->vqs[i].n = n;\n\n    }\n\n\n\n    if (ctrl) {\n\n        n->ctrl_vq = virtio_add_queue(vdev, 64, virtio_net_handle_ctrl);\n\n    }\n\n\n\n    virtio_net_set_queues(n);\n\n}\n", "idx": 23012}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int register_savevm_live(const char *idstr,\n\n                         int instance_id,\n\n                         int version_id,\n\n                         SaveLiveStateHandler *save_live_state,\n\n                         SaveStateHandler *save_state,\n\n                         LoadStateHandler *load_state,\n\n                         void *opaque)\n\n{\n\n    SaveStateEntry *se;\n\n\n\n    se = qemu_malloc(sizeof(SaveStateEntry));\n\n    pstrcpy(se->idstr, sizeof(se->idstr), idstr);\n\n    se->version_id = version_id;\n\n    se->section_id = global_section_id++;\n\n    se->save_live_state = save_live_state;\n\n    se->save_state = save_state;\n\n    se->load_state = load_state;\n\n    se->opaque = opaque;\n\n    se->vmsd = NULL;\n\n\n\n    if (instance_id == -1) {\n\n        se->instance_id = calculate_new_instance_id(idstr);\n\n    } else {\n\n        se->instance_id = instance_id;\n\n    }\n\n    /* add at the end of list */\n\n    TAILQ_INSERT_TAIL(&savevm_handlers, se, entry);\n\n    return 0;\n\n}\n", "idx": 23013}
{"project": "qemu", "commit_id": "b3ceef24f4fee8d5ed96b8c4a5d3e80c0a651f0b", "target": 0, "func": "static void sun4m_hw_init(const struct hwdef *hwdef, int ram_size,\n\n                          DisplayState *ds, const char *cpu_model)\n\n\n\n{\n\n    CPUState *env, *envs[MAX_CPUS];\n\n    unsigned int i;\n\n    void *iommu, *espdma, *ledma, *main_esp;\n\n    const sparc_def_t *def;\n\n    qemu_irq *cpu_irqs[MAX_CPUS], *slavio_irq, *slavio_cpu_irq,\n\n        *espdma_irq, *ledma_irq;\n\n\n\n    /* init CPUs */\n\n    sparc_find_by_name(cpu_model, &def);\n\n    if (def == NULL) {\n\n        fprintf(stderr, \"Unable to find Sparc CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    for(i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init();\n\n        cpu_sparc_register(env, def);\n\n        envs[i] = env;\n\n        if (i == 0) {\n\n            qemu_register_reset(main_cpu_reset, env);\n\n        } else {\n\n            qemu_register_reset(secondary_cpu_reset, env);\n\n            env->halted = 1;\n\n        }\n\n        register_savevm(\"cpu\", i, 3, cpu_save, cpu_load, env);\n\n        cpu_irqs[i] = qemu_allocate_irqs(cpu_set_irq, envs[i], MAX_PILS);\n\n    }\n\n\n\n    for (i = smp_cpus; i < MAX_CPUS; i++)\n\n        cpu_irqs[i] = qemu_allocate_irqs(dummy_cpu_set_irq, NULL, MAX_PILS);\n\n\n\n    /* allocate RAM */\n\n    cpu_register_physical_memory(0, ram_size, 0);\n\n\n\n    iommu = iommu_init(hwdef->iommu_base);\n\n    slavio_intctl = slavio_intctl_init(hwdef->intctl_base,\n\n                                       hwdef->intctl_base + 0x10000ULL,\n\n                                       &hwdef->intbit_to_level[0],\n\n                                       &slavio_irq, &slavio_cpu_irq,\n\n                                       cpu_irqs,\n\n                                       hwdef->clock_irq);\n\n\n\n    espdma = sparc32_dma_init(hwdef->dma_base, slavio_irq[hwdef->esp_irq],\n\n                              iommu, &espdma_irq);\n\n    ledma = sparc32_dma_init(hwdef->dma_base + 16ULL,\n\n                             slavio_irq[hwdef->le_irq], iommu, &ledma_irq);\n\n\n\n    if (graphic_depth != 8 && graphic_depth != 24) {\n\n        fprintf(stderr, \"qemu: Unsupported depth: %d\\n\", graphic_depth);\n\n        exit (1);\n\n    }\n\n    tcx_init(ds, hwdef->tcx_base, phys_ram_base + ram_size, ram_size,\n\n             hwdef->vram_size, graphic_width, graphic_height, graphic_depth);\n\n\n\n    if (nd_table[0].model == NULL\n\n        || strcmp(nd_table[0].model, \"lance\") == 0) {\n\n        lance_init(&nd_table[0], hwdef->le_base, ledma, *ledma_irq);\n\n    } else if (strcmp(nd_table[0].model, \"?\") == 0) {\n\n        fprintf(stderr, \"qemu: Supported NICs: lance\\n\");\n\n        exit (1);\n\n    } else {\n\n        fprintf(stderr, \"qemu: Unsupported NIC: %s\\n\", nd_table[0].model);\n\n        exit (1);\n\n    }\n\n\n\n    nvram = m48t59_init(slavio_irq[0], hwdef->nvram_base, 0,\n\n                        hwdef->nvram_size, 8);\n\n    for (i = 0; i < MAX_CPUS; i++) {\n\n        slavio_timer_init(hwdef->counter_base +\n\n                          (target_phys_addr_t)(i * TARGET_PAGE_SIZE),\n\n                           slavio_cpu_irq[i], 0);\n\n    }\n\n    slavio_timer_init(hwdef->counter_base + 0x10000ULL,\n\n                      slavio_irq[hwdef->clock1_irq], 2);\n\n    slavio_serial_ms_kbd_init(hwdef->ms_kb_base, slavio_irq[hwdef->ms_kb_irq]);\n\n    // Slavio TTYA (base+4, Linux ttyS0) is the first Qemu serial device\n\n    // Slavio TTYB (base+0, Linux ttyS1) is the second Qemu serial device\n\n    slavio_serial_init(hwdef->serial_base, slavio_irq[hwdef->ser_irq],\n\n                       serial_hds[1], serial_hds[0]);\n\n    fdctrl_init(slavio_irq[hwdef->fd_irq], 0, 1, hwdef->fd_base, fd_table);\n\n    main_esp = esp_init(bs_table, hwdef->esp_base, espdma, *espdma_irq);\n\n\n\n    for (i = 0; i < MAX_DISKS; i++) {\n\n        if (bs_table[i]) {\n\n            esp_scsi_attach(main_esp, bs_table[i], i);\n\n        }\n\n    }\n\n\n\n    slavio_misc = slavio_misc_init(hwdef->slavio_base, hwdef->power_base,\n\n                                   slavio_irq[hwdef->me_irq]);\n\n    if (hwdef->cs_base != (target_phys_addr_t)-1)\n\n        cs_init(hwdef->cs_base, hwdef->cs_irq, slavio_intctl);\n\n}\n", "idx": 23014}
{"project": "qemu", "commit_id": "7d5e199ade76c53ec316ab6779800581bb47c50a", "target": 0, "func": "static void qmp_output_push_obj(QmpOutputVisitor *qov, QObject *value,\n\n                                void *qapi)\n\n{\n\n    QStackEntry *e = g_malloc0(sizeof(*e));\n\n\n\n    assert(qov->root);\n\n    assert(value);\n\n    e->value = value;\n\n    e->qapi = qapi;\n\n    QSLIST_INSERT_HEAD(&qov->stack, e, node);\n\n}\n", "idx": 23015}
{"project": "qemu", "commit_id": "e3da9921ebc554fad3224a9fdda9a7425ffd9ef7", "target": 0, "func": "static uint32_t nvic_readl(nvic_state *s, uint32_t offset)\n\n{\n\n    ARMCPU *cpu;\n\n    uint32_t val;\n\n    int irq;\n\n\n\n    switch (offset) {\n\n    case 4: /* Interrupt Control Type.  */\n\n        return (s->num_irq / 32) - 1;\n\n    case 0x10: /* SysTick Control and Status.  */\n\n        val = s->systick.control;\n\n        s->systick.control &= ~SYSTICK_COUNTFLAG;\n\n        return val;\n\n    case 0x14: /* SysTick Reload Value.  */\n\n        return s->systick.reload;\n\n    case 0x18: /* SysTick Current Value.  */\n\n        {\n\n            int64_t t;\n\n            if ((s->systick.control & SYSTICK_ENABLE) == 0)\n\n                return 0;\n\n            t = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n\n            if (t >= s->systick.tick)\n\n                return 0;\n\n            val = ((s->systick.tick - (t + 1)) / systick_scale(s)) + 1;\n\n            /* The interrupt in triggered when the timer reaches zero.\n\n               However the counter is not reloaded until the next clock\n\n               tick.  This is a hack to return zero during the first tick.  */\n\n            if (val > s->systick.reload)\n\n                val = 0;\n\n            return val;\n\n        }\n\n    case 0x1c: /* SysTick Calibration Value.  */\n\n        return 10000;\n\n    case 0xd00: /* CPUID Base.  */\n\n        cpu = ARM_CPU(current_cpu);\n\n        return cpu->env.cp15.c0_cpuid;\n\n    case 0xd04: /* Interrupt Control State.  */\n\n        /* VECTACTIVE */\n\n        val = s->gic.running_irq[0];\n\n        if (val == 1023) {\n\n            val = 0;\n\n        } else if (val >= 32) {\n\n            val -= 16;\n\n        }\n\n        /* RETTOBASE */\n\n        if (s->gic.running_irq[0] == 1023\n\n                || s->gic.last_active[s->gic.running_irq[0]][0] == 1023) {\n\n            val |= (1 << 11);\n\n        }\n\n        /* VECTPENDING */\n\n        if (s->gic.current_pending[0] != 1023)\n\n            val |= (s->gic.current_pending[0] << 12);\n\n        /* ISRPENDING */\n\n        for (irq = 32; irq < s->num_irq; irq++) {\n\n            if (s->gic.irq_state[irq].pending) {\n\n                val |= (1 << 22);\n\n                break;\n\n            }\n\n        }\n\n        /* PENDSTSET */\n\n        if (s->gic.irq_state[ARMV7M_EXCP_SYSTICK].pending)\n\n            val |= (1 << 26);\n\n        /* PENDSVSET */\n\n        if (s->gic.irq_state[ARMV7M_EXCP_PENDSV].pending)\n\n            val |= (1 << 28);\n\n        /* NMIPENDSET */\n\n        if (s->gic.irq_state[ARMV7M_EXCP_NMI].pending)\n\n            val |= (1 << 31);\n\n        return val;\n\n    case 0xd08: /* Vector Table Offset.  */\n\n        cpu = ARM_CPU(current_cpu);\n\n        return cpu->env.v7m.vecbase;\n\n    case 0xd0c: /* Application Interrupt/Reset Control.  */\n\n        return 0xfa05000;\n\n    case 0xd10: /* System Control.  */\n\n        /* TODO: Implement SLEEPONEXIT.  */\n\n        return 0;\n\n    case 0xd14: /* Configuration Control.  */\n\n        /* TODO: Implement Configuration Control bits.  */\n\n        return 0;\n\n    case 0xd24: /* System Handler Status.  */\n\n        val = 0;\n\n        if (s->gic.irq_state[ARMV7M_EXCP_MEM].active) val |= (1 << 0);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_BUS].active) val |= (1 << 1);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_USAGE].active) val |= (1 << 3);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_SVC].active) val |= (1 << 7);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_DEBUG].active) val |= (1 << 8);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_PENDSV].active) val |= (1 << 10);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_SYSTICK].active) val |= (1 << 11);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_USAGE].pending) val |= (1 << 12);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_MEM].pending) val |= (1 << 13);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_BUS].pending) val |= (1 << 14);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_SVC].pending) val |= (1 << 15);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_MEM].enabled) val |= (1 << 16);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_BUS].enabled) val |= (1 << 17);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_USAGE].enabled) val |= (1 << 18);\n\n        return val;\n\n    case 0xd28: /* Configurable Fault Status.  */\n\n        /* TODO: Implement Fault Status.  */\n\n        qemu_log_mask(LOG_UNIMP, \"Configurable Fault Status unimplemented\\n\");\n\n        return 0;\n\n    case 0xd2c: /* Hard Fault Status.  */\n\n    case 0xd30: /* Debug Fault Status.  */\n\n    case 0xd34: /* Mem Manage Address.  */\n\n    case 0xd38: /* Bus Fault Address.  */\n\n    case 0xd3c: /* Aux Fault Status.  */\n\n        /* TODO: Implement fault status registers.  */\n\n        qemu_log_mask(LOG_UNIMP, \"Fault status registers unimplemented\\n\");\n\n        return 0;\n\n    case 0xd40: /* PFR0.  */\n\n        return 0x00000030;\n\n    case 0xd44: /* PRF1.  */\n\n        return 0x00000200;\n\n    case 0xd48: /* DFR0.  */\n\n        return 0x00100000;\n\n    case 0xd4c: /* AFR0.  */\n\n        return 0x00000000;\n\n    case 0xd50: /* MMFR0.  */\n\n        return 0x00000030;\n\n    case 0xd54: /* MMFR1.  */\n\n        return 0x00000000;\n\n    case 0xd58: /* MMFR2.  */\n\n        return 0x00000000;\n\n    case 0xd5c: /* MMFR3.  */\n\n        return 0x00000000;\n\n    case 0xd60: /* ISAR0.  */\n\n        return 0x01141110;\n\n    case 0xd64: /* ISAR1.  */\n\n        return 0x02111000;\n\n    case 0xd68: /* ISAR2.  */\n\n        return 0x21112231;\n\n    case 0xd6c: /* ISAR3.  */\n\n        return 0x01111110;\n\n    case 0xd70: /* ISAR4.  */\n\n        return 0x01310102;\n\n    /* TODO: Implement debug registers.  */\n\n    default:\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"NVIC: Bad read offset 0x%x\\n\", offset);\n\n        return 0;\n\n    }\n\n}\n", "idx": 23016}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void simple_list(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        LiteralQObject decoded;\n\n    } test_cases[] = {\n\n        {\n\n            .encoded = \"[43,42]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \"[43]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \"[]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \"[{}]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n\n                                    {},\n\n                                        })),\n\n                        {},\n\n                            })),\n\n        },\n\n        { }\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_json(test_cases[i].encoded, NULL);\n\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n\n\n        str = qobject_to_json(obj);\n\n        qobject_decref(obj);\n\n\n\n        obj = qobject_from_json(qstring_get_str(str), NULL);\n\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n        qobject_decref(obj);\n\n        QDECREF(str);\n\n    }\n\n}\n", "idx": 23030}
{"project": "qemu", "commit_id": "233aa5c2d1cf4655ffe335025a68cf5454f87dad", "target": 1, "func": "static void tcp_wait_for_connect(void *opaque)\n\n{\n\n    MigrationState *s = opaque;\n\n    int val, ret;\n\n    socklen_t valsize = sizeof(val);\n\n\n\n    DPRINTF(\"connect completed\\n\");\n\n    do {\n\n        ret = getsockopt(s->fd, SOL_SOCKET, SO_ERROR, (void *) &val, &valsize);\n\n    } while (ret == -1 && (socket_error()) == EINTR);\n\n\n\n    if (ret < 0) {\n\n        migrate_fd_error(s);\n\n        return;\n\n    }\n\n\n\n    qemu_set_fd_handler2(s->fd, NULL, NULL, NULL, NULL);\n\n\n\n    if (val == 0)\n\n        migrate_fd_connect(s);\n\n    else {\n\n        DPRINTF(\"error connecting %d\\n\", val);\n\n        migrate_fd_error(s);\n\n    }\n\n}\n", "idx": 23032}
{"project": "qemu", "commit_id": "8be7e7e4c72c048b90e3482557954a24bba43ba7", "target": 1, "func": "int qemu_global_option(const char *str)\n\n{\n\n    char driver[64], property[64];\n\n    QemuOpts *opts;\n\n    int rc, offset;\n\n\n\n    rc = sscanf(str, \"%63[^.].%63[^=]%n\", driver, property, &offset);\n\n    if (rc < 2 || str[offset] != '=') {\n\n        error_report(\"can't parse: \\\"%s\\\"\", str);\n\n        return -1;\n\n    }\n\n\n\n    opts = qemu_opts_create(&qemu_global_opts, NULL, 0);\n\n    qemu_opt_set(opts, \"driver\", driver);\n\n    qemu_opt_set(opts, \"property\", property);\n\n    qemu_opt_set(opts, \"value\", str+offset+1);\n\n    return 0;\n\n}\n", "idx": 23033}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "QEMUFile *qemu_fdopen(int fd, const char *mode)\n\n{\n\n    QEMUFileSocket *s;\n\n\n\n    if (mode == NULL ||\n\n        (mode[0] != 'r' && mode[0] != 'w') ||\n\n        mode[1] != 'b' || mode[2] != 0) {\n\n        fprintf(stderr, \"qemu_fdopen: Argument validity check failed\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    s = g_malloc0(sizeof(QEMUFileSocket));\n\n    s->fd = fd;\n\n\n\n    if (mode[0] == 'r') {\n\n        s->file = qemu_fopen_ops(s, &unix_read_ops);\n\n    } else {\n\n        s->file = qemu_fopen_ops(s, &unix_write_ops);\n\n    }\n\n    return s->file;\n\n}\n", "idx": 23034}
{"project": "qemu", "commit_id": "cc943c36faa192cd4b32af8fe5edb31894017d35", "target": 0, "func": "void msix_notify(PCIDevice *dev, unsigned vector)\n\n{\n\n    MSIMessage msg;\n\n\n\n    if (vector >= dev->msix_entries_nr || !dev->msix_entry_used[vector])\n\n        return;\n\n    if (msix_is_masked(dev, vector)) {\n\n        msix_set_pending(dev, vector);\n\n        return;\n\n    }\n\n\n\n    msg = msix_get_message(dev, vector);\n\n\n\n    stl_le_phys(&address_space_memory, msg.address, msg.data);\n\n}\n", "idx": 23040}
{"project": "qemu", "commit_id": "7c9958b04333a79a1fdb11583aca48a6df2edeb9", "target": 0, "func": "void msi_write_config(PCIDevice *dev, uint32_t addr, uint32_t val, int len)\n\n{\n\n    uint16_t flags = pci_get_word(dev->config + msi_flags_off(dev));\n\n    bool msi64bit = flags & PCI_MSI_FLAGS_64BIT;\n\n    bool msi_per_vector_mask = flags & PCI_MSI_FLAGS_MASKBIT;\n\n    unsigned int nr_vectors;\n\n    uint8_t log_num_vecs;\n\n    uint8_t log_max_vecs;\n\n    unsigned int vector;\n\n    uint32_t pending;\n\n\n\n    if (!ranges_overlap(addr, len, dev->msi_cap, msi_cap_sizeof(flags))) {\n\n        return;\n\n    }\n\n\n\n#ifdef MSI_DEBUG\n\n    MSI_DEV_PRINTF(dev, \"addr 0x%\"PRIx32\" val 0x%\"PRIx32\" len %d\\n\",\n\n                   addr, val, len);\n\n    MSI_DEV_PRINTF(dev, \"ctrl: 0x%\"PRIx16\" address: 0x%\"PRIx32,\n\n                   flags,\n\n                   pci_get_long(dev->config + msi_address_lo_off(dev)));\n\n    if (msi64bit) {\n\n        fprintf(stderr, \" address-hi: 0x%\"PRIx32,\n\n                pci_get_long(dev->config + msi_address_hi_off(dev)));\n\n    }\n\n    fprintf(stderr, \" data: 0x%\"PRIx16,\n\n            pci_get_word(dev->config + msi_data_off(dev, msi64bit)));\n\n    if (flags & PCI_MSI_FLAGS_MASKBIT) {\n\n        fprintf(stderr, \" mask 0x%\"PRIx32\" pending 0x%\"PRIx32,\n\n                pci_get_long(dev->config + msi_mask_off(dev, msi64bit)),\n\n                pci_get_long(dev->config + msi_pending_off(dev, msi64bit)));\n\n    }\n\n    fprintf(stderr, \"\\n\");\n\n#endif\n\n\n\n    if (!(flags & PCI_MSI_FLAGS_ENABLE)) {\n\n        return;\n\n    }\n\n\n\n    /*\n\n     * Now MSI is enabled, clear INTx# interrupts.\n\n     * the driver is prohibited from writing enable bit to mask\n\n     * a service request. But the guest OS could do this.\n\n     * So we just discard the interrupts as moderate fallback.\n\n     *\n\n     * 6.8.3.3. Enabling Operation\n\n     *   While enabled for MSI or MSI-X operation, a function is prohibited\n\n     *   from using its INTx# pin (if implemented) to request\n\n     *   service (MSI, MSI-X, and INTx# are mutually exclusive).\n\n     */\n\n    pci_device_deassert_intx(dev);\n\n\n\n    /*\n\n     * nr_vectors might be set bigger than capable. So clamp it.\n\n     * This is not legal by spec, so we can do anything we like,\n\n     * just don't crash the host\n\n     */\n\n    log_num_vecs =\n\n        (flags & PCI_MSI_FLAGS_QSIZE) >> (ffs(PCI_MSI_FLAGS_QSIZE) - 1);\n\n    log_max_vecs =\n\n        (flags & PCI_MSI_FLAGS_QMASK) >> (ffs(PCI_MSI_FLAGS_QMASK) - 1);\n\n    if (log_num_vecs > log_max_vecs) {\n\n        flags &= ~PCI_MSI_FLAGS_QSIZE;\n\n        flags |= log_max_vecs << (ffs(PCI_MSI_FLAGS_QSIZE) - 1);\n\n        pci_set_word(dev->config + msi_flags_off(dev), flags);\n\n    }\n\n\n\n    if (!msi_per_vector_mask) {\n\n        /* if per vector masking isn't supported,\n\n           there is no pending interrupt. */\n\n        return;\n\n    }\n\n\n\n    nr_vectors = msi_nr_vectors(flags);\n\n\n\n    /* This will discard pending interrupts, if any. */\n\n    pending = pci_get_long(dev->config + msi_pending_off(dev, msi64bit));\n\n    pending &= 0xffffffff >> (PCI_MSI_VECTORS_MAX - nr_vectors);\n\n    pci_set_long(dev->config + msi_pending_off(dev, msi64bit), pending);\n\n\n\n    /* deliver pending interrupts which are unmasked */\n\n    for (vector = 0; vector < nr_vectors; ++vector) {\n\n        if (msi_is_masked(dev, vector) || !(pending & (1U << vector))) {\n\n            continue;\n\n        }\n\n\n\n        pci_long_test_and_clear_mask(\n\n            dev->config + msi_pending_off(dev, msi64bit), 1U << vector);\n\n        msi_notify(dev, vector);\n\n    }\n\n}\n", "idx": 23041}
{"project": "qemu", "commit_id": "5fe79386ba3cdc86fd808dde301bfc5bb7e9bded", "target": 0, "func": "static bool acpi_has_nvdimm(void)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(qdev_get_machine());\n\n\n\n    return pcms->nvdimm;\n\n}\n", "idx": 23042}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "void ide_flush_cache(IDEState *s)\n\n{\n\n    if (s->bs == NULL) {\n\n        ide_flush_cb(s, 0);\n\n        return;\n\n    }\n\n\n\n    s->status |= BUSY_STAT;\n\n    block_acct_start(bdrv_get_stats(s->bs), &s->acct, 0, BLOCK_ACCT_FLUSH);\n\n    s->pio_aiocb = bdrv_aio_flush(s->bs, ide_flush_cb, s);\n\n}\n", "idx": 23043}
{"project": "qemu", "commit_id": "bc0f0674f037a01f2ce0870ad6270a356a7a8347", "target": 0, "func": "have_autoneg(E1000State *s)\n\n{\n\n    return (s->compat_flags & E1000_FLAG_AUTONEG) &&\n\n           (s->phy_reg[PHY_CTRL] & MII_CR_AUTO_NEG_EN);\n\n}\n", "idx": 23044}
{"project": "qemu", "commit_id": "5bac0701113f4de4fee053a3939b0f569a04b88c", "target": 0, "func": "qemu_irq *mpic_init (MemoryRegion *address_space, hwaddr base,\n\n                     int nb_cpus, qemu_irq **irqs, qemu_irq irq_out)\n\n{\n\n    OpenPICState    *mpp;\n\n    int           i;\n\n    struct {\n\n        const char             *name;\n\n        MemoryRegionOps const  *ops;\n\n        hwaddr      start_addr;\n\n        ram_addr_t              size;\n\n    } const list[] = {\n\n        {\"glb\", &openpic_glb_ops_be, MPIC_GLB_REG_START, MPIC_GLB_REG_SIZE},\n\n        {\"tmr\", &openpic_tmr_ops_be, MPIC_TMR_REG_START, MPIC_TMR_REG_SIZE},\n\n        {\"src\", &openpic_src_ops_be, MPIC_SRC_REG_START, MPIC_SRC_REG_SIZE},\n\n        {\"cpu\", &openpic_cpu_ops_be, MPIC_CPU_REG_START, MPIC_CPU_REG_SIZE},\n\n    };\n\n\n\n    mpp = g_malloc0(sizeof(OpenPICState));\n\n\n\n    memory_region_init(&mpp->mem, \"mpic\", 0x40000);\n\n    memory_region_add_subregion(address_space, base, &mpp->mem);\n\n\n\n    for (i = 0; i < sizeof(list)/sizeof(list[0]); i++) {\n\n\n\n        memory_region_init_io(&mpp->sub_io_mem[i], list[i].ops, mpp,\n\n                              list[i].name, list[i].size);\n\n\n\n        memory_region_add_subregion(&mpp->mem, list[i].start_addr,\n\n                                    &mpp->sub_io_mem[i]);\n\n    }\n\n\n\n    mpp->nb_cpus = nb_cpus;\n\n    /* 12 external sources, 48 internal sources , 4 timer sources,\n\n       4 IPI sources, 4 messaging sources, and 8 Shared MSI sources */\n\n    mpp->nb_irqs = 80;\n\n    mpp->vid = VID_REVISION_1_2;\n\n    mpp->veni = VENI_GENERIC;\n\n    mpp->spve_mask = 0xFFFF;\n\n    mpp->tifr_reset = 0x00000000;\n\n    mpp->ipvp_reset = 0x80000000;\n\n    mpp->ide_reset = 0x00000001;\n\n    mpp->max_irq = MPIC_MAX_IRQ;\n\n    mpp->irq_ipi0 = MPIC_IPI_IRQ;\n\n    mpp->irq_tim0 = MPIC_TMR_IRQ;\n\n\n\n    for (i = 0; i < nb_cpus; i++)\n\n        mpp->dst[i].irqs = irqs[i];\n\n    mpp->irq_out = irq_out;\n\n\n\n    /* Enable critical interrupt support */\n\n    mpp->flags |= OPENPIC_FLAG_IDE_CRIT;\n\n\n\n    register_savevm(NULL, \"mpic\", 0, 2, openpic_save, openpic_load, mpp);\n\n    qemu_register_reset(openpic_reset, mpp);\n\n\n\n    return qemu_allocate_irqs(openpic_set_irq, mpp, mpp->max_irq);\n\n}\n", "idx": 23045}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qmp_output_end_list(Visitor *v, void **obj)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    QObject *value = qmp_output_pop(qov, obj);\n\n    assert(qobject_type(value) == QTYPE_QLIST);\n\n}\n", "idx": 23046}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "void blkconf_geometry(BlockConf *conf, int *ptrans,\n\n                      unsigned cyls_max, unsigned heads_max, unsigned secs_max,\n\n                      Error **errp)\n\n{\n\n    DriveInfo *dinfo;\n\n\n\n    if (!conf->cyls && !conf->heads && !conf->secs) {\n\n        /* try to fall back to value set with legacy -drive cyls=... */\n\n        dinfo = drive_get_by_blockdev(conf->bs);\n\n        conf->cyls  = dinfo->cyls;\n\n        conf->heads = dinfo->heads;\n\n        conf->secs  = dinfo->secs;\n\n        if (ptrans) {\n\n            *ptrans = dinfo->trans;\n\n        }\n\n    }\n\n    if (!conf->cyls && !conf->heads && !conf->secs) {\n\n        hd_geometry_guess(conf->bs,\n\n                          &conf->cyls, &conf->heads, &conf->secs,\n\n                          ptrans);\n\n    } else if (ptrans && *ptrans == BIOS_ATA_TRANSLATION_AUTO) {\n\n        *ptrans = hd_bios_chs_auto_trans(conf->cyls, conf->heads, conf->secs);\n\n    }\n\n    if (conf->cyls || conf->heads || conf->secs) {\n\n        if (conf->cyls < 1 || conf->cyls > cyls_max) {\n\n            error_setg(errp, \"cyls must be between 1 and %u\", cyls_max);\n\n            return;\n\n        }\n\n        if (conf->heads < 1 || conf->heads > heads_max) {\n\n            error_setg(errp, \"heads must be between 1 and %u\", heads_max);\n\n            return;\n\n        }\n\n        if (conf->secs < 1 || conf->secs > secs_max) {\n\n            error_setg(errp, \"secs must be between 1 and %u\", secs_max);\n\n            return;\n\n        }\n\n    }\n\n}\n", "idx": 23047}
{"project": "qemu", "commit_id": "786a4ea82ec9c87e3a895cf41081029b285a5fe5", "target": 0, "func": "static void strongarm_ppc_handler_update(StrongARMPPCInfo *s)\n\n{\n\n    uint32_t level, diff;\n\n    int bit;\n\n\n\n    level = s->olevel & s->dir;\n\n\n\n    for (diff = s->prev_level ^ level; diff; diff ^= 1 << bit) {\n\n        bit = ffs(diff) - 1;\n\n        qemu_set_irq(s->handler[bit], (level >> bit) & 1);\n\n    }\n\n\n\n    s->prev_level = level;\n\n}\n", "idx": 23048}
{"project": "qemu", "commit_id": "2f464b5a32b414adb545acc6d94b5c35c7d258ba", "target": 0, "func": "static void qxl_render_update_area_unlocked(PCIQXLDevice *qxl)\n\n{\n\n    VGACommonState *vga = &qxl->vga;\n\n    int i;\n\n\n\n    if (qxl->guest_primary.resized) {\n\n        qxl->guest_primary.resized = 0;\n\n        qxl->guest_primary.data = memory_region_get_ram_ptr(&qxl->vga.vram);\n\n        qxl_set_rect_to_surface(qxl, &qxl->dirty[0]);\n\n        qxl->num_dirty_rects = 1;\n\n        trace_qxl_render_guest_primary_resized(\n\n               qxl->guest_primary.surface.width,\n\n               qxl->guest_primary.surface.height,\n\n               qxl->guest_primary.qxl_stride,\n\n               qxl->guest_primary.bytes_pp,\n\n               qxl->guest_primary.bits_pp);\n\n        if (qxl->guest_primary.qxl_stride > 0) {\n\n            qemu_free_displaysurface(vga->ds);\n\n            qemu_create_displaysurface_from(qxl->guest_primary.surface.width,\n\n                                            qxl->guest_primary.surface.height,\n\n                                            qxl->guest_primary.bits_pp,\n\n                                            qxl->guest_primary.abs_stride,\n\n                                            qxl->guest_primary.data);\n\n        } else {\n\n            qemu_resize_displaysurface(vga->ds,\n\n                    qxl->guest_primary.surface.width,\n\n                    qxl->guest_primary.surface.height);\n\n        }\n\n        dpy_gfx_resize(vga->ds);\n\n    }\n\n    for (i = 0; i < qxl->num_dirty_rects; i++) {\n\n        if (qemu_spice_rect_is_empty(qxl->dirty+i)) {\n\n            break;\n\n        }\n\n        qxl_blit(qxl, qxl->dirty+i);\n\n        dpy_gfx_update(vga->ds,\n\n                       qxl->dirty[i].left, qxl->dirty[i].top,\n\n                       qxl->dirty[i].right - qxl->dirty[i].left,\n\n                       qxl->dirty[i].bottom - qxl->dirty[i].top);\n\n    }\n\n    qxl->num_dirty_rects = 0;\n\n}\n", "idx": 23050}
{"project": "qemu", "commit_id": "a83000f5e3fac30a7f213af1ba6a8f827622854d", "target": 0, "func": "sPAPRTCETable *spapr_tce_new_table(DeviceState *owner, uint32_t liobn, size_t window_size)\n\n{\n\n    sPAPRTCETable *tcet;\n\n\n\n    if (spapr_tce_find_by_liobn(liobn)) {\n\n        fprintf(stderr, \"Attempted to create TCE table with duplicate\"\n\n                \" LIOBN 0x%x\\n\", liobn);\n\n        return NULL;\n\n    }\n\n\n\n    if (!window_size) {\n\n        return NULL;\n\n    }\n\n\n\n    tcet = g_malloc0(sizeof(*tcet));\n\n    tcet->liobn = liobn;\n\n    tcet->window_size = window_size;\n\n\n\n    if (kvm_enabled()) {\n\n        tcet->table = kvmppc_create_spapr_tce(liobn,\n\n                                              window_size,\n\n                                              &tcet->fd);\n\n    }\n\n\n\n    if (!tcet->table) {\n\n        size_t table_size = (window_size >> SPAPR_TCE_PAGE_SHIFT)\n\n            * sizeof(sPAPRTCE);\n\n        tcet->table = g_malloc0(table_size);\n\n    }\n\n\n\n#ifdef DEBUG_TCE\n\n    fprintf(stderr, \"spapr_iommu: New TCE table @ %p, liobn=0x%x, \"\n\n            \"table @ %p, fd=%d\\n\", tcet, liobn, tcet->table, tcet->fd);\n\n#endif\n\n\n\n    memory_region_init_iommu(&tcet->iommu, OBJECT(owner), &spapr_iommu_ops,\n\n                             \"iommu-spapr\", UINT64_MAX);\n\n\n\n    QLIST_INSERT_HEAD(&spapr_tce_tables, tcet, list);\n\n\n\n    return tcet;\n\n}\n", "idx": 23051}
{"project": "qemu", "commit_id": "47c16ed56aa6bc4037bdb7b61f049097993cd244", "target": 0, "func": "static void page_init(void)\n\n{\n\n    /* NOTE: we can always suppose that qemu_host_page_size >=\n\n       TARGET_PAGE_SIZE */\n\n#ifdef _WIN32\n\n    {\n\n        SYSTEM_INFO system_info;\n\n\n\n        GetSystemInfo(&system_info);\n\n        qemu_real_host_page_size = system_info.dwPageSize;\n\n    }\n\n#else\n\n    qemu_real_host_page_size = getpagesize();\n\n#endif\n\n    if (qemu_host_page_size == 0) {\n\n        qemu_host_page_size = qemu_real_host_page_size;\n\n    }\n\n    if (qemu_host_page_size < TARGET_PAGE_SIZE) {\n\n        qemu_host_page_size = TARGET_PAGE_SIZE;\n\n    }\n\n    qemu_host_page_mask = ~(qemu_host_page_size - 1);\n\n\n\n#if defined(CONFIG_BSD) && defined(CONFIG_USER_ONLY)\n\n    {\n\n#ifdef HAVE_KINFO_GETVMMAP\n\n        struct kinfo_vmentry *freep;\n\n        int i, cnt;\n\n\n\n        freep = kinfo_getvmmap(getpid(), &cnt);\n\n        if (freep) {\n\n            mmap_lock();\n\n            for (i = 0; i < cnt; i++) {\n\n                unsigned long startaddr, endaddr;\n\n\n\n                startaddr = freep[i].kve_start;\n\n                endaddr = freep[i].kve_end;\n\n                if (h2g_valid(startaddr)) {\n\n                    startaddr = h2g(startaddr) & TARGET_PAGE_MASK;\n\n\n\n                    if (h2g_valid(endaddr)) {\n\n                        endaddr = h2g(endaddr);\n\n                        page_set_flags(startaddr, endaddr, PAGE_RESERVED);\n\n                    } else {\n\n#if TARGET_ABI_BITS <= L1_MAP_ADDR_SPACE_BITS\n\n                        endaddr = ~0ul;\n\n                        page_set_flags(startaddr, endaddr, PAGE_RESERVED);\n\n#endif\n\n                    }\n\n                }\n\n            }\n\n            free(freep);\n\n            mmap_unlock();\n\n        }\n\n#else\n\n        FILE *f;\n\n\n\n        last_brk = (unsigned long)sbrk(0);\n\n\n\n        f = fopen(\"/compat/linux/proc/self/maps\", \"r\");\n\n        if (f) {\n\n            mmap_lock();\n\n\n\n            do {\n\n                unsigned long startaddr, endaddr;\n\n                int n;\n\n\n\n                n = fscanf(f, \"%lx-%lx %*[^\\n]\\n\", &startaddr, &endaddr);\n\n\n\n                if (n == 2 && h2g_valid(startaddr)) {\n\n                    startaddr = h2g(startaddr) & TARGET_PAGE_MASK;\n\n\n\n                    if (h2g_valid(endaddr)) {\n\n                        endaddr = h2g(endaddr);\n\n                    } else {\n\n                        endaddr = ~0ul;\n\n                    }\n\n                    page_set_flags(startaddr, endaddr, PAGE_RESERVED);\n\n                }\n\n            } while (!feof(f));\n\n\n\n            fclose(f);\n\n            mmap_unlock();\n\n        }\n\n#endif\n\n    }\n\n#endif\n\n}\n", "idx": 23052}
{"project": "qemu", "commit_id": "2d1a35bef0ed96b3f23535e459c552414ccdbafd", "target": 0, "func": "static void vhost_set_memory(MemoryListener *listener,\n\n                             MemoryRegionSection *section,\n\n                             bool add)\n\n{\n\n    struct vhost_dev *dev = container_of(listener, struct vhost_dev,\n\n                                         memory_listener);\n\n    hwaddr start_addr = section->offset_within_address_space;\n\n    ram_addr_t size = int128_get64(section->size);\n\n    bool log_dirty = memory_region_is_logging(section->mr);\n\n    int s = offsetof(struct vhost_memory, regions) +\n\n        (dev->mem->nregions + 1) * sizeof dev->mem->regions[0];\n\n    void *ram;\n\n\n\n    dev->mem = g_realloc(dev->mem, s);\n\n\n\n    if (log_dirty) {\n\n        add = false;\n\n    }\n\n\n\n    assert(size);\n\n\n\n    /* Optimize no-change case. At least cirrus_vga does this a lot at this time. */\n\n    ram = memory_region_get_ram_ptr(section->mr) + section->offset_within_region;\n\n    if (add) {\n\n        if (!vhost_dev_cmp_memory(dev, start_addr, size, (uintptr_t)ram)) {\n\n            /* Region exists with same address. Nothing to do. */\n\n            return;\n\n        }\n\n    } else {\n\n        if (!vhost_dev_find_reg(dev, start_addr, size)) {\n\n            /* Removing region that we don't access. Nothing to do. */\n\n            return;\n\n        }\n\n    }\n\n\n\n    vhost_dev_unassign_memory(dev, start_addr, size);\n\n    if (add) {\n\n        /* Add given mapping, merging adjacent regions if any */\n\n        vhost_dev_assign_memory(dev, start_addr, size, (uintptr_t)ram);\n\n    } else {\n\n        /* Remove old mapping for this memory, if any. */\n\n        vhost_dev_unassign_memory(dev, start_addr, size);\n\n    }\n\n    dev->mem_changed_start_addr = MIN(dev->mem_changed_start_addr, start_addr);\n\n    dev->mem_changed_end_addr = MAX(dev->mem_changed_end_addr, start_addr + size - 1);\n\n    dev->memory_changed = true;\n\n}\n", "idx": 23053}
{"project": "qemu", "commit_id": "b0fd8d18683f0d77a8e6b482771ebea82234d727", "target": 0, "func": "static void setup_rt_frame(int sig, struct target_sigaction *ka,\n\n                           target_siginfo_t *info,\n\n                           target_sigset_t *set, CPUS390XState *env)\n\n{\n\n    int i;\n\n    rt_sigframe *frame;\n\n    abi_ulong frame_addr;\n\n\n\n    frame_addr = get_sigframe(ka, env, sizeof *frame);\n\n    qemu_log(\"%s: frame_addr 0x%llx\\n\", __FUNCTION__,\n\n             (unsigned long long)frame_addr);\n\n    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0)) {\n\n        goto give_sigsegv;\n\n    }\n\n\n\n    qemu_log(\"%s: 1\\n\", __FUNCTION__);\n\n    if (copy_siginfo_to_user(&frame->info, info)) {\n\n        goto give_sigsegv;\n\n    }\n\n\n\n    /* Create the ucontext.  */\n\n    __put_user(0, &frame->uc.tuc_flags);\n\n    __put_user((abi_ulong)0, (abi_ulong *)&frame->uc.tuc_link);\n\n    __put_user(target_sigaltstack_used.ss_sp, &frame->uc.tuc_stack.ss_sp);\n\n    __put_user(sas_ss_flags(get_sp_from_cpustate(env)),\n\n                      &frame->uc.tuc_stack.ss_flags);\n\n    __put_user(target_sigaltstack_used.ss_size, &frame->uc.tuc_stack.ss_size);\n\n    save_sigregs(env, &frame->uc.tuc_mcontext);\n\n    for (i = 0; i < TARGET_NSIG_WORDS; i++) {\n\n        __put_user((abi_ulong)set->sig[i],\n\n        (abi_ulong *)&frame->uc.tuc_sigmask.sig[i]);\n\n    }\n\n\n\n    /* Set up to return from userspace.  If provided, use a stub\n\n       already in userspace.  */\n\n    if (ka->sa_flags & TARGET_SA_RESTORER) {\n\n        env->regs[14] = (unsigned long) ka->sa_restorer | PSW_ADDR_AMODE;\n\n    } else {\n\n        env->regs[14] = (unsigned long) frame->retcode | PSW_ADDR_AMODE;\n\n        if (__put_user(S390_SYSCALL_OPCODE | TARGET_NR_rt_sigreturn,\n\n                       (uint16_t *)(frame->retcode))) {\n\n            goto give_sigsegv;\n\n        }\n\n    }\n\n\n\n    /* Set up backchain. */\n\n    if (__put_user(env->regs[15], (abi_ulong *) frame)) {\n\n        goto give_sigsegv;\n\n    }\n\n\n\n    /* Set up registers for signal handler */\n\n    env->regs[15] = frame_addr;\n\n    env->psw.addr = (target_ulong) ka->_sa_handler | PSW_ADDR_AMODE;\n\n\n\n    env->regs[2] = sig; //map_signal(sig);\n\n    env->regs[3] = frame_addr + offsetof(typeof(*frame), info);\n\n    env->regs[4] = frame_addr + offsetof(typeof(*frame), uc);\n\n    return;\n\n\n\ngive_sigsegv:\n\n    qemu_log(\"%s: give_sigsegv\\n\", __FUNCTION__);\n\n    unlock_user_struct(frame, frame_addr, 1);\n\n    force_sig(TARGET_SIGSEGV);\n\n}\n", "idx": 23054}
{"project": "qemu", "commit_id": "508e0893686794be55cfaa336fea584b16a471d9", "target": 0, "func": "static int64_t alloc_clusters_noref(BlockDriverState *bs, int64_t size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int i, nb_clusters;\n\n\n\n    nb_clusters = size_to_clusters(s, size);\n\nretry:\n\n    for(i = 0; i < nb_clusters; i++) {\n\n        int64_t i = s->free_cluster_index++;\n\n        if (get_refcount(bs, i) != 0)\n\n            goto retry;\n\n    }\n\n#ifdef DEBUG_ALLOC2\n\n    printf(\"alloc_clusters: size=%\" PRId64 \" -> %\" PRId64 \"\\n\",\n\n            size,\n\n            (s->free_cluster_index - nb_clusters) << s->cluster_bits);\n\n#endif\n\n    return (s->free_cluster_index - nb_clusters) << s->cluster_bits;\n\n}\n", "idx": 23055}
{"project": "qemu", "commit_id": "68d553587c0aa271c3eb2902921b503740d775b6", "target": 0, "func": "static inline int get_dwords(uint32_t addr, uint32_t *buf, int num)\n\n{\n\n    int i;\n\n\n\n    for(i = 0; i < num; i++, buf++, addr += sizeof(*buf)) {\n\n        cpu_physical_memory_rw(addr,(uint8_t *)buf, sizeof(*buf), 0);\n\n        *buf = le32_to_cpu(*buf);\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 23056}
{"project": "qemu", "commit_id": "abd696e4f74a9d30801c6ae2693efe4e5979c2f2", "target": 0, "func": "static long kvm_hypercall(unsigned long nr, unsigned long param1,\n\n                          unsigned long param2)\n\n{\n\n\tregister ulong r_nr asm(\"1\") = nr;\n\n\tregister ulong r_param1 asm(\"2\") = param1;\n\n\tregister ulong r_param2 asm(\"3\") = param2;\n\n\tregister long retval asm(\"2\");\n\n\n\n\tasm volatile (\"diag 2,4,0x500\"\n\n\t\t      : \"=d\" (retval)\n\n\t\t      : \"d\" (r_nr), \"0\" (r_param1), \"r\"(r_param2)\n\n\t\t      : \"memory\", \"cc\");\n\n\n\n\treturn retval;\n\n}\n", "idx": 23057}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "static void io_mem_init(void)\n\n{\n\n    int i;\n\n\n\n    cpu_register_io_memory_fixed(IO_MEM_ROM, error_mem_read, unassigned_mem_write, NULL);\n\n    cpu_register_io_memory_fixed(IO_MEM_UNASSIGNED, unassigned_mem_read, unassigned_mem_write, NULL);\n\n    cpu_register_io_memory_fixed(IO_MEM_NOTDIRTY, error_mem_read, notdirty_mem_write, NULL);\n\n    for (i=0; i<5; i++)\n\n        io_mem_used[i] = 1;\n\n\n\n    io_mem_watch = cpu_register_io_memory(watch_mem_read,\n\n                                          watch_mem_write, NULL);\n\n#ifdef CONFIG_KQEMU\n\n    if (kqemu_phys_ram_base) {\n\n        /* alloc dirty bits array */\n\n        phys_ram_dirty = qemu_vmalloc(kqemu_phys_ram_size >> TARGET_PAGE_BITS);\n\n        memset(phys_ram_dirty, 0xff, kqemu_phys_ram_size >> TARGET_PAGE_BITS);\n\n    }\n\n#endif\n\n}\n", "idx": 23058}
{"project": "qemu", "commit_id": "88571882516a7cb4291a329c537eb79fd126e1f2", "target": 0, "func": "static size_t qemu_rdma_save_page(QEMUFile *f, void *opaque,\n\n                                  ram_addr_t block_offset, ram_addr_t offset,\n\n                                  size_t size, int *bytes_sent)\n\n{\n\n    QEMUFileRDMA *rfile = opaque;\n\n    RDMAContext *rdma = rfile->rdma;\n\n    int ret;\n\n\n\n    CHECK_ERROR_STATE();\n\n\n\n    qemu_fflush(f);\n\n\n\n    if (size > 0) {\n\n        /*\n\n         * Add this page to the current 'chunk'. If the chunk\n\n         * is full, or the page doen't belong to the current chunk,\n\n         * an actual RDMA write will occur and a new chunk will be formed.\n\n         */\n\n        ret = qemu_rdma_write(f, rdma, block_offset, offset, size);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"rdma migration: write error! %d\\n\", ret);\n\n            goto err;\n\n        }\n\n\n\n        /*\n\n         * We always return 1 bytes because the RDMA\n\n         * protocol is completely asynchronous. We do not yet know\n\n         * whether an  identified chunk is zero or not because we're\n\n         * waiting for other pages to potentially be merged with\n\n         * the current chunk. So, we have to call qemu_update_position()\n\n         * later on when the actual write occurs.\n\n         */\n\n        if (bytes_sent) {\n\n            *bytes_sent = 1;\n\n        }\n\n    } else {\n\n        uint64_t index, chunk;\n\n\n\n        /* TODO: Change QEMUFileOps prototype to be signed: size_t => long\n\n        if (size < 0) {\n\n            ret = qemu_rdma_drain_cq(f, rdma);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"rdma: failed to synchronously drain\"\n\n                                \" completion queue before unregistration.\\n\");\n\n                goto err;\n\n            }\n\n        }\n\n        */\n\n\n\n        ret = qemu_rdma_search_ram_block(rdma, block_offset,\n\n                                         offset, size, &index, &chunk);\n\n\n\n        if (ret) {\n\n            fprintf(stderr, \"ram block search failed\\n\");\n\n            goto err;\n\n        }\n\n\n\n        qemu_rdma_signal_unregister(rdma, index, chunk, 0);\n\n\n\n        /*\n\n         * TODO: Synchronous, guaranteed unregistration (should not occur during\n\n         * fast-path). Otherwise, unregisters will process on the next call to\n\n         * qemu_rdma_drain_cq()\n\n        if (size < 0) {\n\n            qemu_rdma_unregister_waiting(rdma);\n\n        }\n\n        */\n\n    }\n\n\n\n    /*\n\n     * Drain the Completion Queue if possible, but do not block,\n\n     * just poll.\n\n     *\n\n     * If nothing to poll, the end of the iteration will do this\n\n     * again to make sure we don't overflow the request queue.\n\n     */\n\n    while (1) {\n\n        uint64_t wr_id, wr_id_in;\n\n        int ret = qemu_rdma_poll(rdma, &wr_id_in);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"rdma migration: polling error! %d\\n\", ret);\n\n            goto err;\n\n        }\n\n\n\n        wr_id = wr_id_in & RDMA_WRID_TYPE_MASK;\n\n\n\n        if (wr_id == RDMA_WRID_NONE) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    return RAM_SAVE_CONTROL_DELAYED;\n\nerr:\n\n    rdma->error_state = ret;\n\n    return ret;\n\n}\n", "idx": 23059}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_temp_free_internal(int idx)\n\n{\n\n    TCGContext *s = &tcg_ctx;\n\n    TCGTemp *ts;\n\n    int k;\n\n\n\n#if defined(CONFIG_DEBUG_TCG)\n\n    s->temps_in_use--;\n\n    if (s->temps_in_use < 0) {\n\n        fprintf(stderr, \"More temporaries freed than allocated!\\n\");\n\n    }\n\n#endif\n\n\n\n    assert(idx >= s->nb_globals && idx < s->nb_temps);\n\n    ts = &s->temps[idx];\n\n    assert(ts->temp_allocated != 0);\n\n    ts->temp_allocated = 0;\n\n\n\n    k = ts->base_type + (ts->temp_local ? TCG_TYPE_COUNT : 0);\n\n    set_bit(idx, s->free_temps[k].l);\n\n}\n", "idx": 23061}
{"project": "qemu", "commit_id": "aea390e4be652d5b5457771d25eded0dba14fe37", "target": 0, "func": "static bool pte64_match(target_ulong pte0, target_ulong pte1,\n\n                        bool secondary, target_ulong ptem)\n\n{\n\n    return (pte0 & HPTE64_V_VALID)\n\n        && (secondary == !!(pte0 & HPTE64_V_SECONDARY))\n\n        && HPTE64_V_COMPARE(pte0, ptem);\n\n}\n", "idx": 23062}
{"project": "qemu", "commit_id": "4f5e19e6c570459cd524b29b24374f03860f5149", "target": 0, "func": "PCIBus *ppc4xx_pci_init(CPUState *env, qemu_irq pci_irqs[4],\n\n                        target_phys_addr_t config_space,\n\n                        target_phys_addr_t int_ack,\n\n                        target_phys_addr_t special_cycle,\n\n                        target_phys_addr_t registers)\n\n{\n\n    PPC4xxPCIState *controller;\n\n    int index;\n\n    static int ppc4xx_pci_id;\n\n    uint8_t *pci_conf;\n\n\n\n    controller = qemu_mallocz(sizeof(PPC4xxPCIState));\n\n\n\n    controller->pci_state.bus = pci_register_bus(NULL, \"pci\",\n\n                                                 ppc4xx_pci_set_irq,\n\n                                                 ppc4xx_pci_map_irq,\n\n                                                 pci_irqs, 0, 4);\n\n\n\n    controller->pci_dev = pci_register_device(controller->pci_state.bus,\n\n                                              \"host bridge\", sizeof(PCIDevice),\n\n                                              0, NULL, NULL);\n\n    pci_conf = controller->pci_dev->config;\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_IBM);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_IBM_440GX);\n\n    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_OTHER);\n\n\n\n    /* CFGADDR */\n\n    index = cpu_register_io_memory(pci4xx_cfgaddr_read,\n\n                                   pci4xx_cfgaddr_write, controller);\n\n    if (index < 0)\n\n        goto free;\n\n    cpu_register_physical_memory(config_space + PCIC0_CFGADDR, 4, index);\n\n\n\n    /* CFGDATA */\n\n    index = cpu_register_io_memory(pci4xx_cfgdata_read,\n\n                                   pci4xx_cfgdata_write,\n\n                                   &controller->pci_state);\n\n    if (index < 0)\n\n        goto free;\n\n    cpu_register_physical_memory(config_space + PCIC0_CFGDATA, 4, index);\n\n\n\n    /* Internal registers */\n\n    index = cpu_register_io_memory(pci_reg_read, pci_reg_write, controller);\n\n    if (index < 0)\n\n        goto free;\n\n    cpu_register_physical_memory(registers, PCI_REG_SIZE, index);\n\n\n\n    qemu_register_reset(ppc4xx_pci_reset, controller);\n\n\n\n    /* XXX load/save code not tested. */\n\n    register_savevm(\"ppc4xx_pci\", ppc4xx_pci_id++, 1,\n\n                    ppc4xx_pci_save, ppc4xx_pci_load, controller);\n\n\n\n    return controller->pci_state.bus;\n\n\n\nfree:\n\n    printf(\"%s error\\n\", __func__);\n\n    qemu_free(controller);\n\n    return NULL;\n\n}\n", "idx": 23063}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void watch_mem_write(void *opaque, target_phys_addr_t addr,\n\n                            uint64_t val, unsigned size)\n\n{\n\n    check_watchpoint(addr & ~TARGET_PAGE_MASK, ~(size - 1), BP_MEM_WRITE);\n\n    switch (size) {\n\n    case 1:\n\n        stb_phys(addr, val);\n\n        break;\n\n    case 2:\n\n        stw_phys(addr, val);\n\n        break;\n\n    case 4:\n\n        stl_phys(addr, val);\n\n        break;\n\n    default: abort();\n\n    }\n\n}\n", "idx": 23064}
{"project": "qemu", "commit_id": "e046fb449947a48e013bf25d806ecb60e5a88319", "target": 0, "func": "static int io_channel_send_full(QIOChannel *ioc,\n\n                                const void *buf, size_t len,\n\n                                int *fds, size_t nfds)\n\n{\n\n    size_t offset = 0;\n\n\n\n    while (offset < len) {\n\n        ssize_t ret = 0;\n\n        struct iovec iov = { .iov_base = (char *)buf + offset,\n\n                             .iov_len = len - offset };\n\n\n\n        ret = qio_channel_writev_full(\n\n            ioc, &iov, 1,\n\n            fds, nfds, NULL);\n\n        if (ret == QIO_CHANNEL_ERR_BLOCK) {\n\n            errno = EAGAIN;\n\n            return -1;\n\n        } else if (ret < 0) {\n\n            if (offset) {\n\n                return offset;\n\n            }\n\n\n\n            errno = EINVAL;\n\n            return -1;\n\n        }\n\n\n\n        offset += ret;\n\n    }\n\n\n\n    return offset;\n\n}\n", "idx": 23065}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static SocketAddress *tcp_build_address(const char *host_port, Error **errp)\n\n{\n\n    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);\n\n    SocketAddress *saddr;\n\n\n\n    if (inet_parse(iaddr, host_port, errp)) {\n\n        qapi_free_InetSocketAddress(iaddr);\n\n        return NULL;\n\n    }\n\n\n\n    saddr = g_new0(SocketAddress, 1);\n\n    saddr->type = SOCKET_ADDRESS_KIND_INET;\n\n    saddr->u.inet.data = iaddr;\n\n\n\n    return saddr;\n\n}\n", "idx": 23066}
{"project": "qemu", "commit_id": "d5bfda334adf9af62df5709cdac38f523f815f47", "target": 0, "func": "qemu_inject_x86_mce(Monitor *mon, CPUState *cenv, int bank, uint64_t status,\n\n                    uint64_t mcg_status, uint64_t addr, uint64_t misc,\n\n                    int flags)\n\n{\n\n    uint64_t mcg_cap = cenv->mcg_cap;\n\n    uint64_t *banks = cenv->mce_banks + 4 * bank;\n\n\n\n    /*\n\n     * If there is an MCE exception being processed, ignore this SRAO MCE\n\n     * unless unconditional injection was requested.\n\n     */\n\n    if (!(flags & MCE_INJECT_UNCOND_AO) && !(status & MCI_STATUS_AR)\n\n        && (cenv->mcg_status & MCG_STATUS_MCIP)) {\n\n        return;\n\n    }\n\n    if (status & MCI_STATUS_UC) {\n\n        /*\n\n         * if MSR_MCG_CTL is not all 1s, the uncorrected error\n\n         * reporting is disabled\n\n         */\n\n        if ((mcg_cap & MCG_CTL_P) && cenv->mcg_ctl != ~(uint64_t)0) {\n\n            monitor_printf(mon,\n\n                           \"CPU %d: Uncorrected error reporting disabled\\n\",\n\n                           cenv->cpu_index);\n\n            return;\n\n        }\n\n\n\n        /*\n\n         * if MSR_MCi_CTL is not all 1s, the uncorrected error\n\n         * reporting is disabled for the bank\n\n         */\n\n        if (banks[0] != ~(uint64_t)0) {\n\n            monitor_printf(mon, \"CPU %d: Uncorrected error reporting disabled \"\n\n                           \"for bank %d\\n\", cenv->cpu_index, bank);\n\n            return;\n\n        }\n\n\n\n        if ((cenv->mcg_status & MCG_STATUS_MCIP) ||\n\n            !(cenv->cr[4] & CR4_MCE_MASK)) {\n\n            monitor_printf(mon, \"CPU %d: Previous MCE still in progress, \"\n\n                                \"raising triple fault\\n\", cenv->cpu_index);\n\n            qemu_log_mask(CPU_LOG_RESET, \"Triple fault\\n\");\n\n            qemu_system_reset_request();\n\n            return;\n\n        }\n\n        if (banks[1] & MCI_STATUS_VAL) {\n\n            status |= MCI_STATUS_OVER;\n\n        }\n\n        banks[2] = addr;\n\n        banks[3] = misc;\n\n        cenv->mcg_status = mcg_status;\n\n        banks[1] = status;\n\n        cpu_interrupt(cenv, CPU_INTERRUPT_MCE);\n\n    } else if (!(banks[1] & MCI_STATUS_VAL)\n\n               || !(banks[1] & MCI_STATUS_UC)) {\n\n        if (banks[1] & MCI_STATUS_VAL) {\n\n            status |= MCI_STATUS_OVER;\n\n        }\n\n        banks[2] = addr;\n\n        banks[3] = misc;\n\n        banks[1] = status;\n\n    } else {\n\n        banks[1] |= MCI_STATUS_OVER;\n\n    }\n\n}\n", "idx": 23067}
{"project": "qemu", "commit_id": "ab06ec43577177a442e8e5ca28d0154efe4ff60f", "target": 0, "func": "static void test_pxe_e1000(void)\n\n{\n\n    test_pxe_one(\"-device e1000,netdev=\" NETNAME, false);\n\n}\n", "idx": 23068}
{"project": "qemu", "commit_id": "ede9c94acf6cd1968de4188c0228b714ab871a86", "target": 0, "func": "static int vtd_interrupt_remap_msi(IntelIOMMUState *iommu,\n\n                                   MSIMessage *origin,\n\n                                   MSIMessage *translated)\n\n{\n\n    int ret = 0;\n\n    VTD_IR_MSIAddress addr;\n\n    uint16_t index;\n\n    VTDIrq irq = {};\n\n\n\n    assert(origin && translated);\n\n\n\n    if (!iommu || !iommu->intr_enabled) {\n\n        goto do_not_translate;\n\n    }\n\n\n\n    if (origin->address & VTD_MSI_ADDR_HI_MASK) {\n\n        VTD_DPRINTF(GENERAL, \"error: MSI addr high 32 bits nonzero\"\n\n                    \" during interrupt remapping: 0x%\"PRIx32,\n\n                    (uint32_t)((origin->address & VTD_MSI_ADDR_HI_MASK) >> \\\n\n                    VTD_MSI_ADDR_HI_SHIFT));\n\n        return -VTD_FR_IR_REQ_RSVD;\n\n    }\n\n\n\n    addr.data = origin->address & VTD_MSI_ADDR_LO_MASK;\n\n    if (le16_to_cpu(addr.__head) != 0xfee) {\n\n        VTD_DPRINTF(GENERAL, \"error: MSI addr low 32 bits invalid: \"\n\n                    \"0x%\"PRIx32, addr.data);\n\n        return -VTD_FR_IR_REQ_RSVD;\n\n    }\n\n\n\n    /* This is compatible mode. */\n\n    if (addr.int_mode != VTD_IR_INT_FORMAT_REMAP) {\n\n        goto do_not_translate;\n\n    }\n\n\n\n    index = addr.index_h << 15 | le16_to_cpu(addr.index_l);\n\n\n\n#define  VTD_IR_MSI_DATA_SUBHANDLE       (0x0000ffff)\n\n#define  VTD_IR_MSI_DATA_RESERVED        (0xffff0000)\n\n\n\n    if (addr.sub_valid) {\n\n        /* See VT-d spec 5.1.2.2 and 5.1.3 on subhandle */\n\n        index += origin->data & VTD_IR_MSI_DATA_SUBHANDLE;\n\n    }\n\n\n\n    ret = vtd_remap_irq_get(iommu, index, &irq);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    if (addr.sub_valid) {\n\n        VTD_DPRINTF(IR, \"received MSI interrupt\");\n\n        if (origin->data & VTD_IR_MSI_DATA_RESERVED) {\n\n            VTD_DPRINTF(GENERAL, \"error: MSI data bits non-zero for \"\n\n                        \"interrupt remappable entry: 0x%\"PRIx32,\n\n                        origin->data);\n\n            return -VTD_FR_IR_REQ_RSVD;\n\n        }\n\n    } else {\n\n        uint8_t vector = origin->data & 0xff;\n\n        VTD_DPRINTF(IR, \"received IOAPIC interrupt\");\n\n        /* IOAPIC entry vector should be aligned with IRTE vector\n\n         * (see vt-d spec 5.1.5.1). */\n\n        if (vector != irq.vector) {\n\n            VTD_DPRINTF(GENERAL, \"IOAPIC vector inconsistent: \"\n\n                        \"entry: %d, IRTE: %d, index: %d\",\n\n                        vector, irq.vector, index);\n\n        }\n\n    }\n\n\n\n    /*\n\n     * We'd better keep the last two bits, assuming that guest OS\n\n     * might modify it. Keep it does not hurt after all.\n\n     */\n\n    irq.msi_addr_last_bits = addr.__not_care;\n\n\n\n    /* Translate VTDIrq to MSI message */\n\n    vtd_generate_msi_message(&irq, translated);\n\n\n\n    VTD_DPRINTF(IR, \"mapping MSI 0x%\"PRIx64\":0x%\"PRIx32 \" -> \"\n\n                \"0x%\"PRIx64\":0x%\"PRIx32, origin->address, origin->data,\n\n                translated->address, translated->data);\n\n    return 0;\n\n\n\ndo_not_translate:\n\n    memcpy(translated, origin, sizeof(*origin));\n\n    return 0;\n\n}\n", "idx": 23070}
{"project": "qemu", "commit_id": "02a2cbc872df99205eeafd399f01c210e0b797c4", "target": 0, "func": "static bool vtd_process_inv_desc(IntelIOMMUState *s)\n\n{\n\n    VTDInvDesc inv_desc;\n\n    uint8_t desc_type;\n\n\n\n    VTD_DPRINTF(INV, \"iq head %\"PRIu16, s->iq_head);\n\n    if (!vtd_get_inv_desc(s->iq, s->iq_head, &inv_desc)) {\n\n        s->iq_last_desc_type = VTD_INV_DESC_NONE;\n\n        return false;\n\n    }\n\n    desc_type = inv_desc.lo & VTD_INV_DESC_TYPE;\n\n    /* FIXME: should update at first or at last? */\n\n    s->iq_last_desc_type = desc_type;\n\n\n\n    switch (desc_type) {\n\n    case VTD_INV_DESC_CC:\n\n        VTD_DPRINTF(INV, \"Context-cache Invalidate Descriptor hi 0x%\"PRIx64\n\n                    \" lo 0x%\"PRIx64, inv_desc.hi, inv_desc.lo);\n\n        if (!vtd_process_context_cache_desc(s, &inv_desc)) {\n\n            return false;\n\n        }\n\n        break;\n\n\n\n    case VTD_INV_DESC_IOTLB:\n\n        VTD_DPRINTF(INV, \"IOTLB Invalidate Descriptor hi 0x%\"PRIx64\n\n                    \" lo 0x%\"PRIx64, inv_desc.hi, inv_desc.lo);\n\n        if (!vtd_process_iotlb_desc(s, &inv_desc)) {\n\n            return false;\n\n        }\n\n        break;\n\n\n\n    case VTD_INV_DESC_WAIT:\n\n        VTD_DPRINTF(INV, \"Invalidation Wait Descriptor hi 0x%\"PRIx64\n\n                    \" lo 0x%\"PRIx64, inv_desc.hi, inv_desc.lo);\n\n        if (!vtd_process_wait_desc(s, &inv_desc)) {\n\n            return false;\n\n        }\n\n        break;\n\n\n\n    case VTD_INV_DESC_IEC:\n\n        VTD_DPRINTF(INV, \"Interrupt Entry Cache Invalidation \"\n\n                    \"not implemented yet\");\n\n        /*\n\n         * Since currently we do not cache interrupt entries, we can\n\n         * just mark this descriptor as \"good\" and move on.\n\n         */\n\n        break;\n\n\n\n    default:\n\n        VTD_DPRINTF(GENERAL, \"error: unkonw Invalidation Descriptor type \"\n\n                    \"hi 0x%\"PRIx64 \" lo 0x%\"PRIx64 \" type %\"PRIu8,\n\n                    inv_desc.hi, inv_desc.lo, desc_type);\n\n        return false;\n\n    }\n\n    s->iq_head++;\n\n    if (s->iq_head == s->iq_size) {\n\n        s->iq_head = 0;\n\n    }\n\n    return true;\n\n}\n", "idx": 23071}
{"project": "qemu", "commit_id": "f755dea79dc81b0d6a8f6414e0672e165e28d8ba", "target": 0, "func": "void visit_type_uint8(Visitor *v, uint8_t *obj, const char *name, Error **errp)\n\n{\n\n    int64_t value;\n\n\n\n    if (v->type_uint8) {\n\n        v->type_uint8(v, obj, name, errp);\n\n    } else {\n\n        value = *obj;\n\n        v->type_int64(v, &value, name, errp);\n\n        if (value < 0 || value > UINT8_MAX) {\n\n            /* FIXME questionable reuse of errp if callback changed\n\n               value on error */\n\n            error_setg(errp, QERR_INVALID_PARAMETER_VALUE,\n\n                       name ? name : \"null\", \"uint8_t\");\n\n            return;\n\n        }\n\n        *obj = value;\n\n    }\n\n}\n", "idx": 23072}
{"project": "qemu", "commit_id": "da98c8eb4c35225049cad8cf767647eb39788b5d", "target": 0, "func": "void xen_cmos_set_s3_resume(void *opaque, int irq, int level)\n\n{\n\n    pc_cmos_set_s3_resume(opaque, irq, level);\n\n    if (level) {\n\n        xc_set_hvm_param(xen_xc, xen_domid, HVM_PARAM_ACPI_S_STATE, 3);\n\n    }\n\n}\n", "idx": 23073}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "static void nbd_close(BlockDriverState *bs)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n\n\n    qemu_opts_del(s->socket_opts);\n\n    nbd_client_session_close(&s->client);\n\n}\n", "idx": 23074}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static bool cmd_read_pio(IDEState *s, uint8_t cmd)\n\n{\n\n    bool lba48 = (cmd == WIN_READ_EXT);\n\n\n\n    if (s->drive_kind == IDE_CD) {\n\n        ide_set_signature(s); /* odd, but ATA4 8.27.5.2 requires it */\n\n        ide_abort_command(s);\n\n        return true;\n\n    }\n\n\n\n    if (!s->bs) {\n\n        ide_abort_command(s);\n\n        return true;\n\n    }\n\n\n\n    ide_cmd_lba48_transform(s, lba48);\n\n    s->req_nb_sectors = 1;\n\n    ide_sector_read(s);\n\n\n\n    return false;\n\n}\n", "idx": 23075}
{"project": "qemu", "commit_id": "4f9242fc931ab5e5b1b753c8e5a76c50c0b0612e", "target": 0, "func": "static void reset(DeviceState *d)\n\n{\n\n    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);\n\n    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n\n\n    trace_spapr_drc_reset(spapr_drc_index(drc));\n\n\n\n    g_free(drc->ccs);\n\n    drc->ccs = NULL;\n\n\n\n    /* immediately upon reset we can safely assume DRCs whose devices\n\n     * are pending removal can be safely removed, and that they will\n\n     * subsequently be left in an ISOLATED state. move the DRC to this\n\n     * state in these cases (which will in turn complete any pending\n\n     * device removals)\n\n     */\n\n    if (drc->awaiting_release) {\n\n        drck->set_isolation_state(drc, SPAPR_DR_ISOLATION_STATE_ISOLATED);\n\n        /* generally this should also finalize the removal, but if the device\n\n         * hasn't yet been configured we normally defer removal under the\n\n         * assumption that this transition is taking place as part of device\n\n         * configuration. so check if we're still waiting after this, and\n\n         * force removal if we are\n\n         */\n\n        if (drc->awaiting_release) {\n\n            spapr_drc_detach(drc, DEVICE(drc->dev), NULL);\n\n        }\n\n\n\n        /* non-PCI devices may be awaiting a transition to UNUSABLE */\n\n        if (spapr_drc_type(drc) != SPAPR_DR_CONNECTOR_TYPE_PCI &&\n\n            drc->awaiting_release) {\n\n            drck->set_allocation_state(drc, SPAPR_DR_ALLOCATION_STATE_UNUSABLE);\n\n        }\n\n    }\n\n}\n", "idx": 23076}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "size_t v9fs_marshal(struct iovec *in_sg, int in_num, size_t offset,\n\n                    int bswap, const char *fmt, ...)\n\n{\n\n    int i;\n\n    va_list ap;\n\n    size_t old_offset = offset;\n\n\n\n    va_start(ap, fmt);\n\n    for (i = 0; fmt[i]; i++) {\n\n        switch (fmt[i]) {\n\n        case 'b': {\n\n            uint8_t val = va_arg(ap, int);\n\n            offset += v9fs_pack(in_sg, in_num, offset, &val, sizeof(val));\n\n            break;\n\n        }\n\n        case 'w': {\n\n            uint16_t val;\n\n            if (bswap) {\n\n                cpu_to_le16w(&val, va_arg(ap, int));\n\n            } else {\n\n                val =  va_arg(ap, int);\n\n            }\n\n            offset += v9fs_pack(in_sg, in_num, offset, &val, sizeof(val));\n\n            break;\n\n        }\n\n        case 'd': {\n\n            uint32_t val;\n\n            if (bswap) {\n\n                cpu_to_le32w(&val, va_arg(ap, uint32_t));\n\n            } else {\n\n                val =  va_arg(ap, uint32_t);\n\n            }\n\n            offset += v9fs_pack(in_sg, in_num, offset, &val, sizeof(val));\n\n            break;\n\n        }\n\n        case 'q': {\n\n            uint64_t val;\n\n            if (bswap) {\n\n                cpu_to_le64w(&val, va_arg(ap, uint64_t));\n\n            } else {\n\n                val =  va_arg(ap, uint64_t);\n\n            }\n\n            offset += v9fs_pack(in_sg, in_num, offset, &val, sizeof(val));\n\n            break;\n\n        }\n\n        case 's': {\n\n            V9fsString *str = va_arg(ap, V9fsString *);\n\n            offset += v9fs_marshal(in_sg, in_num, offset, bswap,\n\n                            \"w\", str->size);\n\n            offset += v9fs_pack(in_sg, in_num, offset, str->data, str->size);\n\n            break;\n\n        }\n\n        case 'Q': {\n\n            V9fsQID *qidp = va_arg(ap, V9fsQID *);\n\n            offset += v9fs_marshal(in_sg, in_num, offset, bswap, \"bdq\",\n\n                                   qidp->type, qidp->version, qidp->path);\n\n            break;\n\n        }\n\n        case 'S': {\n\n            V9fsStat *statp = va_arg(ap, V9fsStat *);\n\n            offset += v9fs_marshal(in_sg, in_num, offset, bswap,\n\n                                   \"wwdQdddqsssssddd\",\n\n                                   statp->size, statp->type, statp->dev,\n\n                                   &statp->qid, statp->mode, statp->atime,\n\n                                   statp->mtime, statp->length, &statp->name,\n\n                                   &statp->uid, &statp->gid, &statp->muid,\n\n                                   &statp->extension, statp->n_uid,\n\n                                   statp->n_gid, statp->n_muid);\n\n            break;\n\n        }\n\n        case 'A': {\n\n            V9fsStatDotl *statp = va_arg(ap, V9fsStatDotl *);\n\n            offset += v9fs_marshal(in_sg, in_num, offset, bswap,\n\n                                   \"qQdddqqqqqqqqqqqqqqq\",\n\n                                   statp->st_result_mask,\n\n                                   &statp->qid, statp->st_mode,\n\n                                   statp->st_uid, statp->st_gid,\n\n                                   statp->st_nlink, statp->st_rdev,\n\n                                   statp->st_size, statp->st_blksize,\n\n                                   statp->st_blocks, statp->st_atime_sec,\n\n                                   statp->st_atime_nsec, statp->st_mtime_sec,\n\n                                   statp->st_mtime_nsec, statp->st_ctime_sec,\n\n                                   statp->st_ctime_nsec, statp->st_btime_sec,\n\n                                   statp->st_btime_nsec, statp->st_gen,\n\n                                   statp->st_data_version);\n\n            break;\n\n        }\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    va_end(ap);\n\n\n\n    return offset - old_offset;\n\n}\n", "idx": 23077}
{"project": "qemu", "commit_id": "f682e9c244af7166225f4a50cc18ff296bb9d43e", "target": 0, "func": "void memory_region_iommu_replay(MemoryRegion *mr, Notifier *n,\n\n                                hwaddr granularity, bool is_write)\n\n{\n\n    hwaddr addr;\n\n    IOMMUTLBEntry iotlb;\n\n\n\n    for (addr = 0; addr < memory_region_size(mr); addr += granularity) {\n\n        iotlb = mr->iommu_ops->translate(mr, addr, is_write);\n\n        if (iotlb.perm != IOMMU_NONE) {\n\n            n->notify(n, &iotlb);\n\n        }\n\n\n\n        /* if (2^64 - MR size) < granularity, it's possible to get an\n\n         * infinite loop here.  This should catch such a wraparound */\n\n        if ((addr + granularity) < addr) {\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 23078}
{"project": "qemu", "commit_id": "11b0079cec6b1f46ba76cca634051bee4474d323", "target": 0, "func": "static void s390_init_cpus(MachineState *machine)\n\n{\n\n    MachineClass *mc = MACHINE_GET_CLASS(machine);\n\n    int i;\n\n\n\n    if (tcg_enabled() && max_cpus > 1) {\n\n        error_report(\"Number of SMP CPUs requested (%d) exceeds max CPUs \"\n\n                     \"supported by TCG (1) on s390x\", max_cpus);\n\n        exit(1);\n\n    }\n\n\n\n    /* initialize possible_cpus */\n\n    mc->possible_cpu_arch_ids(machine);\n\n\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        s390x_new_cpu(machine->cpu_type, i, &error_fatal);\n\n    }\n\n}\n", "idx": 23079}
{"project": "qemu", "commit_id": "7848c8d19f8556666df25044bbd5d8b29439c368", "target": 0, "func": "static inline void helper_ret_protected(CPUX86State *env, int shift,\n\n                                        int is_iret, int addend)\n\n{\n\n    uint32_t new_cs, new_eflags, new_ss;\n\n    uint32_t new_es, new_ds, new_fs, new_gs;\n\n    uint32_t e1, e2, ss_e1, ss_e2;\n\n    int cpl, dpl, rpl, eflags_mask, iopl;\n\n    target_ulong ssp, sp, new_eip, new_esp, sp_mask;\n\n\n\n#ifdef TARGET_X86_64\n\n    if (shift == 2) {\n\n        sp_mask = -1;\n\n    } else\n\n#endif\n\n    {\n\n        sp_mask = get_sp_mask(env->segs[R_SS].flags);\n\n    }\n\n    sp = env->regs[R_ESP];\n\n    ssp = env->segs[R_SS].base;\n\n    new_eflags = 0; /* avoid warning */\n\n#ifdef TARGET_X86_64\n\n    if (shift == 2) {\n\n        POPQ(sp, new_eip);\n\n        POPQ(sp, new_cs);\n\n        new_cs &= 0xffff;\n\n        if (is_iret) {\n\n            POPQ(sp, new_eflags);\n\n        }\n\n    } else\n\n#endif\n\n    {\n\n        if (shift == 1) {\n\n            /* 32 bits */\n\n            POPL(ssp, sp, sp_mask, new_eip);\n\n            POPL(ssp, sp, sp_mask, new_cs);\n\n            new_cs &= 0xffff;\n\n            if (is_iret) {\n\n                POPL(ssp, sp, sp_mask, new_eflags);\n\n                if (new_eflags & VM_MASK) {\n\n                    goto return_to_vm86;\n\n                }\n\n            }\n\n        } else {\n\n            /* 16 bits */\n\n            POPW(ssp, sp, sp_mask, new_eip);\n\n            POPW(ssp, sp, sp_mask, new_cs);\n\n            if (is_iret) {\n\n                POPW(ssp, sp, sp_mask, new_eflags);\n\n            }\n\n        }\n\n    }\n\n    LOG_PCALL(\"lret new %04x:\" TARGET_FMT_lx \" s=%d addend=0x%x\\n\",\n\n              new_cs, new_eip, shift, addend);\n\n    LOG_PCALL_STATE(CPU(x86_env_get_cpu(env)));\n\n    if ((new_cs & 0xfffc) == 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, new_cs & 0xfffc);\n\n    }\n\n    if (load_segment(env, &e1, &e2, new_cs) != 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, new_cs & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_S_MASK) ||\n\n        !(e2 & DESC_CS_MASK)) {\n\n        raise_exception_err(env, EXCP0D_GPF, new_cs & 0xfffc);\n\n    }\n\n    cpl = env->hflags & HF_CPL_MASK;\n\n    rpl = new_cs & 3;\n\n    if (rpl < cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, new_cs & 0xfffc);\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    if (e2 & DESC_C_MASK) {\n\n        if (dpl > rpl) {\n\n            raise_exception_err(env, EXCP0D_GPF, new_cs & 0xfffc);\n\n        }\n\n    } else {\n\n        if (dpl != rpl) {\n\n            raise_exception_err(env, EXCP0D_GPF, new_cs & 0xfffc);\n\n        }\n\n    }\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, new_cs & 0xfffc);\n\n    }\n\n\n\n    sp += addend;\n\n    if (rpl == cpl && (!(env->hflags & HF_CS64_MASK) ||\n\n                       ((env->hflags & HF_CS64_MASK) && !is_iret))) {\n\n        /* return to same privilege level */\n\n        cpu_x86_load_seg_cache(env, R_CS, new_cs,\n\n                       get_seg_base(e1, e2),\n\n                       get_seg_limit(e1, e2),\n\n                       e2);\n\n    } else {\n\n        /* return to different privilege level */\n\n#ifdef TARGET_X86_64\n\n        if (shift == 2) {\n\n            POPQ(sp, new_esp);\n\n            POPQ(sp, new_ss);\n\n            new_ss &= 0xffff;\n\n        } else\n\n#endif\n\n        {\n\n            if (shift == 1) {\n\n                /* 32 bits */\n\n                POPL(ssp, sp, sp_mask, new_esp);\n\n                POPL(ssp, sp, sp_mask, new_ss);\n\n                new_ss &= 0xffff;\n\n            } else {\n\n                /* 16 bits */\n\n                POPW(ssp, sp, sp_mask, new_esp);\n\n                POPW(ssp, sp, sp_mask, new_ss);\n\n            }\n\n        }\n\n        LOG_PCALL(\"new ss:esp=%04x:\" TARGET_FMT_lx \"\\n\",\n\n                  new_ss, new_esp);\n\n        if ((new_ss & 0xfffc) == 0) {\n\n#ifdef TARGET_X86_64\n\n            /* NULL ss is allowed in long mode if cpl != 3 */\n\n            /* XXX: test CS64? */\n\n            if ((env->hflags & HF_LMA_MASK) && rpl != 3) {\n\n                cpu_x86_load_seg_cache(env, R_SS, new_ss,\n\n                                       0, 0xffffffff,\n\n                                       DESC_G_MASK | DESC_B_MASK | DESC_P_MASK |\n\n                                       DESC_S_MASK | (rpl << DESC_DPL_SHIFT) |\n\n                                       DESC_W_MASK | DESC_A_MASK);\n\n                ss_e2 = DESC_B_MASK; /* XXX: should not be needed? */\n\n            } else\n\n#endif\n\n            {\n\n                raise_exception_err(env, EXCP0D_GPF, 0);\n\n            }\n\n        } else {\n\n            if ((new_ss & 3) != rpl) {\n\n                raise_exception_err(env, EXCP0D_GPF, new_ss & 0xfffc);\n\n            }\n\n            if (load_segment(env, &ss_e1, &ss_e2, new_ss) != 0) {\n\n                raise_exception_err(env, EXCP0D_GPF, new_ss & 0xfffc);\n\n            }\n\n            if (!(ss_e2 & DESC_S_MASK) ||\n\n                (ss_e2 & DESC_CS_MASK) ||\n\n                !(ss_e2 & DESC_W_MASK)) {\n\n                raise_exception_err(env, EXCP0D_GPF, new_ss & 0xfffc);\n\n            }\n\n            dpl = (ss_e2 >> DESC_DPL_SHIFT) & 3;\n\n            if (dpl != rpl) {\n\n                raise_exception_err(env, EXCP0D_GPF, new_ss & 0xfffc);\n\n            }\n\n            if (!(ss_e2 & DESC_P_MASK)) {\n\n                raise_exception_err(env, EXCP0B_NOSEG, new_ss & 0xfffc);\n\n            }\n\n            cpu_x86_load_seg_cache(env, R_SS, new_ss,\n\n                                   get_seg_base(ss_e1, ss_e2),\n\n                                   get_seg_limit(ss_e1, ss_e2),\n\n                                   ss_e2);\n\n        }\n\n\n\n        cpu_x86_load_seg_cache(env, R_CS, new_cs,\n\n                       get_seg_base(e1, e2),\n\n                       get_seg_limit(e1, e2),\n\n                       e2);\n\n        cpu_x86_set_cpl(env, rpl);\n\n        sp = new_esp;\n\n#ifdef TARGET_X86_64\n\n        if (env->hflags & HF_CS64_MASK) {\n\n            sp_mask = -1;\n\n        } else\n\n#endif\n\n        {\n\n            sp_mask = get_sp_mask(ss_e2);\n\n        }\n\n\n\n        /* validate data segments */\n\n        validate_seg(env, R_ES, rpl);\n\n        validate_seg(env, R_DS, rpl);\n\n        validate_seg(env, R_FS, rpl);\n\n        validate_seg(env, R_GS, rpl);\n\n\n\n        sp += addend;\n\n    }\n\n    SET_ESP(sp, sp_mask);\n\n    env->eip = new_eip;\n\n    if (is_iret) {\n\n        /* NOTE: 'cpl' is the _old_ CPL */\n\n        eflags_mask = TF_MASK | AC_MASK | ID_MASK | RF_MASK | NT_MASK;\n\n        if (cpl == 0) {\n\n            eflags_mask |= IOPL_MASK;\n\n        }\n\n        iopl = (env->eflags >> IOPL_SHIFT) & 3;\n\n        if (cpl <= iopl) {\n\n            eflags_mask |= IF_MASK;\n\n        }\n\n        if (shift == 0) {\n\n            eflags_mask &= 0xffff;\n\n        }\n\n        cpu_load_eflags(env, new_eflags, eflags_mask);\n\n    }\n\n    return;\n\n\n\n return_to_vm86:\n\n    POPL(ssp, sp, sp_mask, new_esp);\n\n    POPL(ssp, sp, sp_mask, new_ss);\n\n    POPL(ssp, sp, sp_mask, new_es);\n\n    POPL(ssp, sp, sp_mask, new_ds);\n\n    POPL(ssp, sp, sp_mask, new_fs);\n\n    POPL(ssp, sp, sp_mask, new_gs);\n\n\n\n    /* modify processor state */\n\n    cpu_load_eflags(env, new_eflags, TF_MASK | AC_MASK | ID_MASK |\n\n                    IF_MASK | IOPL_MASK | VM_MASK | NT_MASK | VIF_MASK |\n\n                    VIP_MASK);\n\n    load_seg_vm(env, R_CS, new_cs & 0xffff);\n\n    cpu_x86_set_cpl(env, 3);\n\n    load_seg_vm(env, R_SS, new_ss & 0xffff);\n\n    load_seg_vm(env, R_ES, new_es & 0xffff);\n\n    load_seg_vm(env, R_DS, new_ds & 0xffff);\n\n    load_seg_vm(env, R_FS, new_fs & 0xffff);\n\n    load_seg_vm(env, R_GS, new_gs & 0xffff);\n\n\n\n    env->eip = new_eip & 0xffff;\n\n    env->regs[R_ESP] = new_esp;\n\n}\n", "idx": 23081}
{"project": "qemu", "commit_id": "c53b1c5114bdf7fc945cbf11436da61789ca2267", "target": 0, "func": "static int qiov_is_aligned(BlockDriverState *bs, QEMUIOVector *qiov)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < qiov->niov; i++) {\n\n        if ((uintptr_t) qiov->iov[i].iov_base % bs->buffer_alignment) {\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 23082}
{"project": "qemu", "commit_id": "a2b257d6212ade772473f86bf0637480b2578a7e", "target": 0, "func": "void *qemu_anon_ram_alloc(size_t size)\n\n{\n\n    void *ptr;\n\n\n\n    /* FIXME: this is not exactly optimal solution since VirtualAlloc\n\n       has 64Kb granularity, but at least it guarantees us that the\n\n       memory is page aligned. */\n\n    ptr = VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE);\n\n    trace_qemu_anon_ram_alloc(size, ptr);\n\n    return ptr;\n\n}\n", "idx": 23083}
{"project": "qemu", "commit_id": "b25b387fa5928e516cb2c9e7fde68e958bd7e50a", "target": 0, "func": "static bool coroutine_fn do_perform_cow_encrypt(BlockDriverState *bs,\n\n                                                uint64_t src_cluster_offset,\n\n                                                unsigned offset_in_cluster,\n\n                                                uint8_t *buffer,\n\n                                                unsigned bytes)\n\n{\n\n    if (bytes && bs->encrypted) {\n\n        BDRVQcow2State *s = bs->opaque;\n\n        int64_t sector = (src_cluster_offset + offset_in_cluster)\n\n                         >> BDRV_SECTOR_BITS;\n\n        assert(s->cipher);\n\n        assert((offset_in_cluster & ~BDRV_SECTOR_MASK) == 0);\n\n        assert((bytes & ~BDRV_SECTOR_MASK) == 0);\n\n        if (qcow2_encrypt_sectors(s, sector, buffer,\n\n                                  bytes >> BDRV_SECTOR_BITS, true, NULL) < 0) {\n\n            return false;\n\n        }\n\n    }\n\n    return true;\n\n}\n", "idx": 23084}
{"project": "qemu", "commit_id": "10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b", "target": 0, "func": "static uint32_t nam_readl (void *opaque, uint32_t addr)\n\n{\n\n    PCIAC97LinkState *d = opaque;\n\n    AC97LinkState *s = &d->ac97;\n\n    dolog (\"U nam readl %#x\\n\", addr);\n\n    s->cas = 0;\n\n    return ~0U;\n\n}\n", "idx": 23085}
{"project": "qemu", "commit_id": "258d2edbcd4bb5d267c96163333820332e1c14fa", "target": 0, "func": "static int vpc_open(BlockDriverState *bs, int flags)\n\n{\n\n    BDRVVPCState *s = bs->opaque;\n\n    int i;\n\n    struct vhd_footer* footer;\n\n    struct vhd_dyndisk_header* dyndisk_header;\n\n    uint8_t buf[HEADER_SIZE];\n\n    uint32_t checksum;\n\n    int err = -1;\n\n    int disk_type = VHD_DYNAMIC;\n\n\n\n    if (bdrv_pread(bs->file, 0, s->footer_buf, HEADER_SIZE) != HEADER_SIZE)\n\n        goto fail;\n\n\n\n    footer = (struct vhd_footer*) s->footer_buf;\n\n    if (strncmp(footer->creator, \"conectix\", 8)) {\n\n        int64_t offset = bdrv_getlength(bs->file);\n\n        if (offset < HEADER_SIZE) {\n\n            goto fail;\n\n        }\n\n        /* If a fixed disk, the footer is found only at the end of the file */\n\n        if (bdrv_pread(bs->file, offset-HEADER_SIZE, s->footer_buf, HEADER_SIZE)\n\n                != HEADER_SIZE) {\n\n            goto fail;\n\n        }\n\n        if (strncmp(footer->creator, \"conectix\", 8)) {\n\n            goto fail;\n\n        }\n\n        disk_type = VHD_FIXED;\n\n    }\n\n\n\n    checksum = be32_to_cpu(footer->checksum);\n\n    footer->checksum = 0;\n\n    if (vpc_checksum(s->footer_buf, HEADER_SIZE) != checksum)\n\n        fprintf(stderr, \"block-vpc: The header checksum of '%s' is \"\n\n            \"incorrect.\\n\", bs->filename);\n\n\n\n    /* Write 'checksum' back to footer, or else will leave it with zero. */\n\n    footer->checksum = be32_to_cpu(checksum);\n\n\n\n    // The visible size of a image in Virtual PC depends on the geometry\n\n    // rather than on the size stored in the footer (the size in the footer\n\n    // is too large usually)\n\n    bs->total_sectors = (int64_t)\n\n        be16_to_cpu(footer->cyls) * footer->heads * footer->secs_per_cyl;\n\n\n\n    if (bs->total_sectors >= 65535 * 16 * 255) {\n\n        err = -EFBIG;\n\n        goto fail;\n\n    }\n\n\n\n    if (disk_type == VHD_DYNAMIC) {\n\n        if (bdrv_pread(bs->file, be64_to_cpu(footer->data_offset), buf,\n\n                HEADER_SIZE) != HEADER_SIZE) {\n\n            goto fail;\n\n        }\n\n\n\n        dyndisk_header = (struct vhd_dyndisk_header *) buf;\n\n\n\n        if (strncmp(dyndisk_header->magic, \"cxsparse\", 8)) {\n\n            goto fail;\n\n        }\n\n\n\n        s->block_size = be32_to_cpu(dyndisk_header->block_size);\n\n        s->bitmap_size = ((s->block_size / (8 * 512)) + 511) & ~511;\n\n\n\n        s->max_table_entries = be32_to_cpu(dyndisk_header->max_table_entries);\n\n        s->pagetable = g_malloc(s->max_table_entries * 4);\n\n\n\n        s->bat_offset = be64_to_cpu(dyndisk_header->table_offset);\n\n        if (bdrv_pread(bs->file, s->bat_offset, s->pagetable,\n\n                s->max_table_entries * 4) != s->max_table_entries * 4) {\n\n            goto fail;\n\n        }\n\n\n\n        s->free_data_block_offset =\n\n            (s->bat_offset + (s->max_table_entries * 4) + 511) & ~511;\n\n\n\n        for (i = 0; i < s->max_table_entries; i++) {\n\n            be32_to_cpus(&s->pagetable[i]);\n\n            if (s->pagetable[i] != 0xFFFFFFFF) {\n\n                int64_t next = (512 * (int64_t) s->pagetable[i]) +\n\n                    s->bitmap_size + s->block_size;\n\n\n\n                if (next > s->free_data_block_offset) {\n\n                    s->free_data_block_offset = next;\n\n                }\n\n            }\n\n        }\n\n\n\n        s->last_bitmap_offset = (int64_t) -1;\n\n\n\n#ifdef CACHE\n\n        s->pageentry_u8 = g_malloc(512);\n\n        s->pageentry_u32 = s->pageentry_u8;\n\n        s->pageentry_u16 = s->pageentry_u8;\n\n        s->last_pagetable = -1;\n\n#endif\n\n    }\n\n\n\n    qemu_co_mutex_init(&s->lock);\n\n\n\n    /* Disable migration when VHD images are used */\n\n    error_set(&s->migration_blocker,\n\n              QERR_BLOCK_FORMAT_FEATURE_NOT_SUPPORTED,\n\n              \"vpc\", bs->device_name, \"live migration\");\n\n    migrate_add_blocker(s->migration_blocker);\n\n\n\n    return 0;\n\n fail:\n\n    return err;\n\n}\n", "idx": 23086}
{"project": "qemu", "commit_id": "debaaa114a8877a939533ba846e64168fb287b7b", "target": 0, "func": "static void test_identify(void)\n\n{\n\n    AHCIQState *ahci;\n\n\n\n    ahci = ahci_boot_and_enable();\n\n    ahci_test_identify(ahci);\n\n    ahci_shutdown(ahci);\n\n}\n", "idx": 23087}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,\n\n                          target_ulong len, int type)\n\n{\n\n    struct kvm_sw_breakpoint *bp;\n\n    CPUState *env;\n\n    int err;\n\n\n\n    if (type == GDB_BREAKPOINT_SW) {\n\n        bp = kvm_find_sw_breakpoint(current_env, addr);\n\n        if (!bp)\n\n            return -ENOENT;\n\n\n\n        if (bp->use_count > 1) {\n\n            bp->use_count--;\n\n            return 0;\n\n        }\n\n\n\n        err = kvm_arch_remove_sw_breakpoint(current_env, bp);\n\n        if (err)\n\n            return err;\n\n\n\n        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);\n\n        qemu_free(bp);\n\n    } else {\n\n        err = kvm_arch_remove_hw_breakpoint(addr, len, type);\n\n        if (err)\n\n            return err;\n\n    }\n\n\n\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n\n        err = kvm_update_guest_debug(env, 0);\n\n        if (err)\n\n            return err;\n\n    }\n\n    return 0;\n\n}\n", "idx": 23088}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void apic_send_msi(target_phys_addr_t addr, uint32_t data)\n\n{\n\n    uint8_t dest = (addr & MSI_ADDR_DEST_ID_MASK) >> MSI_ADDR_DEST_ID_SHIFT;\n\n    uint8_t vector = (data & MSI_DATA_VECTOR_MASK) >> MSI_DATA_VECTOR_SHIFT;\n\n    uint8_t dest_mode = (addr >> MSI_ADDR_DEST_MODE_SHIFT) & 0x1;\n\n    uint8_t trigger_mode = (data >> MSI_DATA_TRIGGER_SHIFT) & 0x1;\n\n    uint8_t delivery = (data >> MSI_DATA_DELIVERY_MODE_SHIFT) & 0x7;\n\n    /* XXX: Ignore redirection hint. */\n\n    apic_deliver_irq(dest, dest_mode, delivery, vector, trigger_mode);\n\n}\n", "idx": 23089}
{"project": "qemu", "commit_id": "89dfd6e1b3c0b31ef700203808be2a9a71947d1d", "target": 0, "func": "PCIHostState *spapr_create_phb(sPAPREnvironment *spapr, int index,\n\n                               const char *busname)\n\n{\n\n    DeviceState *dev;\n\n\n\n    dev = qdev_create(NULL, TYPE_SPAPR_PCI_HOST_BRIDGE);\n\n    qdev_prop_set_uint32(dev, \"index\", index);\n\n    qdev_prop_set_string(dev, \"busname\", busname);\n\n    qdev_init_nofail(dev);\n\n\n\n    return PCI_HOST_BRIDGE(dev);\n\n}\n", "idx": 23090}
{"project": "qemu", "commit_id": "8c56c1a592b5092d91da8d8943c17777d6462a6f", "target": 1, "func": "void memory_region_add_eventfd(MemoryRegion *mr,\n                               hwaddr addr,\n                               unsigned size,\n                               bool match_data,\n                               uint64_t data,\n                               EventNotifier *e)\n{\n    MemoryRegionIoeventfd mrfd = {\n        .addr.start = int128_make64(addr),\n        .addr.size = int128_make64(size),\n        .match_data = match_data,\n        .data = data,\n        .e = e,\n    };\n    unsigned i;\n    if (size) {\n        adjust_endianness(mr, &mrfd.data, size);\n    memory_region_transaction_begin();\n    for (i = 0; i < mr->ioeventfd_nb; ++i) {\n        if (memory_region_ioeventfd_before(mrfd, mr->ioeventfds[i])) {\n            break;\n    ++mr->ioeventfd_nb;\n    mr->ioeventfds = g_realloc(mr->ioeventfds,\n                                  sizeof(*mr->ioeventfds) * mr->ioeventfd_nb);\n    memmove(&mr->ioeventfds[i+1], &mr->ioeventfds[i],\n            sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb-1 - i));\n    mr->ioeventfds[i] = mrfd;\n    ioeventfd_update_pending |= mr->enabled;\n    memory_region_transaction_commit();", "idx": 23092}
{"project": "qemu", "commit_id": "25cec2b896a977565ca04e5c649aab8c6e48bda8", "target": 1, "func": "void os_setup_post(void)\n\n{\n\n    int fd = 0;\n\n\n\n    if (daemonize) {\n\n        uint8_t status = 0;\n\n        ssize_t len;\n\n\n\n        do {        \n\n            len = write(daemon_pipe, &status, 1);\n\n        } while (len < 0 && errno == EINTR);\n\n        if (len != 1) {\n\n            exit(1);\n\n        }\n\n        if (chdir(\"/\")) {\n\n            perror(\"not able to chdir to /\");\n\n            exit(1);\n\n        }\n\n        TFR(fd = qemu_open(\"/dev/null\", O_RDWR));\n\n        if (fd == -1) {\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    change_root();\n\n    change_process_uid();\n\n\n\n    if (daemonize) {\n\n        dup2(fd, 0);\n\n        dup2(fd, 1);\n\n        dup2(fd, 2);\n\n\n\n        close(fd);\n\n    }\n\n}\n", "idx": 23093}
{"project": "qemu", "commit_id": "302a0d3ed721e4c30c6a2a37f64c60b50ffd33b9", "target": 1, "func": "static int pdu_copy_sg(V9fsPDU *pdu, size_t offset, int rx, struct iovec *sg)\n\n{\n\n    size_t pos = 0;\n\n    int i, j;\n\n    struct iovec *src_sg;\n\n    unsigned int num;\n\n\n\n    if (rx) {\n\n        src_sg = pdu->elem.in_sg;\n\n        num = pdu->elem.in_num;\n\n    } else {\n\n        src_sg = pdu->elem.out_sg;\n\n        num = pdu->elem.out_num;\n\n    }\n\n\n\n    j = 0;\n\n    for (i = 0; i < num; i++) {\n\n        if (offset <= pos) {\n\n            sg[j].iov_base = src_sg[i].iov_base;\n\n            sg[j].iov_len = src_sg[i].iov_len;\n\n            j++;\n\n        } else if (offset < (src_sg[i].iov_len + pos)) {\n\n            sg[j].iov_base = src_sg[i].iov_base;\n\n            sg[j].iov_len = src_sg[i].iov_len;\n\n            sg[j].iov_base += (offset - pos);\n\n            sg[j].iov_len -= (offset - pos);\n\n            j++;\n\n        }\n\n        pos += src_sg[i].iov_len;\n\n    }\n\n\n\n    return j;\n\n}\n", "idx": 23094}
{"project": "qemu", "commit_id": "3604a76fea6ff37738d4a8f596be38407be74a83", "target": 1, "func": "static void dec_sr(DisasContext *dc)\n\n{\n\n    if (dc->format == OP_FMT_RI) {\n\n        LOG_DIS(\"sri r%d, r%d, %d\\n\", dc->r1, dc->r0, dc->imm5);\n\n    } else {\n\n        LOG_DIS(\"sr r%d, r%d, r%d\\n\", dc->r2, dc->r0, dc->r1);\n\n    }\n\n\n\n    if (!(dc->env->features & LM32_FEATURE_SHIFT)) {\n\n        if (dc->format == OP_FMT_RI) {\n\n            /* TODO: check r1 == 1 during runtime */\n\n        } else {\n\n            if (dc->imm5 != 1) {\n\n                cpu_abort(dc->env, \"hardware shifter is not available\\n\");\n\n            }\n\n        }\n\n    }\n\n\n\n    if (dc->format == OP_FMT_RI) {\n\n        tcg_gen_sari_tl(cpu_R[dc->r1], cpu_R[dc->r0], dc->imm5);\n\n    } else {\n\n        TCGv t0 = tcg_temp_new();\n\n        tcg_gen_andi_tl(t0, cpu_R[dc->r1], 0x1f);\n\n        tcg_gen_sar_tl(cpu_R[dc->r2], cpu_R[dc->r0], t0);\n\n        tcg_temp_free(t0);\n\n    }\n\n}\n", "idx": 23096}
{"project": "qemu", "commit_id": "3c85e74fbf9e5a39d8d13ef91a5f3dd91f0bc8a8", "target": 1, "func": "int kvm_arch_on_sigbus(int code, void *addr)\n\n{\n\n#ifdef KVM_CAP_MCE\n\n    if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) {\n\n        ram_addr_t ram_addr;\n\n        target_phys_addr_t paddr;\n\n\n\n        /* Hope we are lucky for AO MCE */\n\n        if (qemu_ram_addr_from_host(addr, &ram_addr) ||\n\n            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr,\n\n                                               &paddr)) {\n\n            fprintf(stderr, \"Hardware memory error for memory used by \"\n\n                    \"QEMU itself instead of guest system!: %p\\n\", addr);\n\n            return 0;\n\n        }\n\n\n        kvm_mce_inject(first_cpu, paddr, code);\n\n    } else\n\n#endif /* KVM_CAP_MCE */\n\n    {\n\n        if (code == BUS_MCEERR_AO) {\n\n            return 0;\n\n        } else if (code == BUS_MCEERR_AR) {\n\n            hardware_memory_error();\n\n        } else {\n\n            return 1;\n\n        }\n\n    }\n\n    return 0;\n\n}", "idx": 23097}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void qemu_aio_complete(void *opaque, int ret)\n\n{\n\n    struct ioreq *ioreq = opaque;\n\n\n\n    if (ret != 0) {\n\n        xen_be_printf(&ioreq->blkdev->xendev, 0, \"%s I/O error\\n\",\n\n                      ioreq->req.operation == BLKIF_OP_READ ? \"read\" : \"write\");\n\n        ioreq->aio_errors++;\n\n    }\n\n\n\n    ioreq->aio_inflight--;\n\n    if (ioreq->presync) {\n\n        ioreq->presync = 0;\n\n        ioreq_runio_qemu_aio(ioreq);\n\n        return;\n\n    }\n\n    if (ioreq->aio_inflight > 0) {\n\n        return;\n\n    }\n\n    if (ioreq->postsync) {\n\n        ioreq->postsync = 0;\n\n        ioreq->aio_inflight++;\n\n        bdrv_aio_flush(ioreq->blkdev->bs, qemu_aio_complete, ioreq);\n\n        return;\n\n    }\n\n\n\n    ioreq->status = ioreq->aio_errors ? BLKIF_RSP_ERROR : BLKIF_RSP_OKAY;\n\n    ioreq_unmap(ioreq);\n\n    ioreq_finish(ioreq);\n\n    switch (ioreq->req.operation) {\n\n    case BLKIF_OP_WRITE:\n\n    case BLKIF_OP_FLUSH_DISKCACHE:\n\n        if (!ioreq->req.nr_segments) {\n\n            break;\n\n        }\n\n    case BLKIF_OP_READ:\n\n        block_acct_done(bdrv_get_stats(ioreq->blkdev->bs), &ioreq->acct);\n\n        break;\n\n    case BLKIF_OP_DISCARD:\n\n    default:\n\n        break;\n\n    }\n\n    qemu_bh_schedule(ioreq->blkdev->bh);\n\n}\n", "idx": 23099}
{"project": "qemu", "commit_id": "84a12e6648444f517055138a7d7f25a22d7e1029", "target": 0, "func": "static BlockDriver *find_hdev_driver(const char *filename)\n\n{\n\n    int score_max = 0, score;\n\n    BlockDriver *drv = NULL, *d;\n\n\n\n    QLIST_FOREACH(d, &bdrv_drivers, list) {\n\n        if (d->bdrv_probe_device) {\n\n            score = d->bdrv_probe_device(filename);\n\n            if (score > score_max) {\n\n                score_max = score;\n\n                drv = d;\n\n            }\n\n        }\n\n    }\n\n\n\n    return drv;\n\n}\n", "idx": 23101}
{"project": "qemu", "commit_id": "1e242b5544a48bc43eca9c637dc91ec06bcf3a31", "target": 0, "func": "int qcow2_check_metadata_overlap(BlockDriverState *bs, int chk, int64_t offset,\n\n                                 int64_t size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int i, j;\n\n\n\n    if (!size) {\n\n        return 0;\n\n    }\n\n\n\n    if (chk & QCOW2_OL_MAIN_HEADER) {\n\n        if (offset < s->cluster_size) {\n\n            return QCOW2_OL_MAIN_HEADER;\n\n        }\n\n    }\n\n\n\n    /* align range to test to cluster boundaries */\n\n    size = align_offset(offset_into_cluster(s, offset) + size, s->cluster_size);\n\n    offset = start_of_cluster(s, offset);\n\n\n\n    if ((chk & QCOW2_OL_ACTIVE_L1) && s->l1_size) {\n\n        if (overlaps_with(s->l1_table_offset, s->l1_size * sizeof(uint64_t))) {\n\n            return QCOW2_OL_ACTIVE_L1;\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_REFCOUNT_TABLE) && s->refcount_table_size) {\n\n        if (overlaps_with(s->refcount_table_offset,\n\n            s->refcount_table_size * sizeof(uint64_t))) {\n\n            return QCOW2_OL_REFCOUNT_TABLE;\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_SNAPSHOT_TABLE) && s->snapshots_size) {\n\n        if (overlaps_with(s->snapshots_offset, s->snapshots_size)) {\n\n            return QCOW2_OL_SNAPSHOT_TABLE;\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_INACTIVE_L1) && s->snapshots) {\n\n        for (i = 0; i < s->nb_snapshots; i++) {\n\n            if (s->snapshots[i].l1_size &&\n\n                overlaps_with(s->snapshots[i].l1_table_offset,\n\n                s->snapshots[i].l1_size * sizeof(uint64_t))) {\n\n                return QCOW2_OL_INACTIVE_L1;\n\n            }\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_ACTIVE_L2) && s->l1_table) {\n\n        for (i = 0; i < s->l1_size; i++) {\n\n            if ((s->l1_table[i] & L1E_OFFSET_MASK) &&\n\n                overlaps_with(s->l1_table[i] & L1E_OFFSET_MASK,\n\n                s->cluster_size)) {\n\n                return QCOW2_OL_ACTIVE_L2;\n\n            }\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_REFCOUNT_BLOCK) && s->refcount_table) {\n\n        for (i = 0; i < s->refcount_table_size; i++) {\n\n            if ((s->refcount_table[i] & REFT_OFFSET_MASK) &&\n\n                overlaps_with(s->refcount_table[i] & REFT_OFFSET_MASK,\n\n                s->cluster_size)) {\n\n                return QCOW2_OL_REFCOUNT_BLOCK;\n\n            }\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_INACTIVE_L2) && s->snapshots) {\n\n        for (i = 0; i < s->nb_snapshots; i++) {\n\n            uint64_t l1_ofs = s->snapshots[i].l1_table_offset;\n\n            uint32_t l1_sz  = s->snapshots[i].l1_size;\n\n            uint64_t *l1 = g_malloc(l1_sz * sizeof(uint64_t));\n\n            int ret;\n\n\n\n            ret = bdrv_read(bs->file, l1_ofs / BDRV_SECTOR_SIZE, (uint8_t *)l1,\n\n                            l1_sz * sizeof(uint64_t) / BDRV_SECTOR_SIZE);\n\n\n\n            if (ret < 0) {\n\n                g_free(l1);\n\n                return ret;\n\n            }\n\n\n\n            for (j = 0; j < l1_sz; j++) {\n\n                if ((l1[j] & L1E_OFFSET_MASK) &&\n\n                    overlaps_with(l1[j] & L1E_OFFSET_MASK, s->cluster_size)) {\n\n                    g_free(l1);\n\n                    return QCOW2_OL_INACTIVE_L2;\n\n                }\n\n            }\n\n\n\n            g_free(l1);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23102}
{"project": "qemu", "commit_id": "6eab3de16d36c48a983366b09d0a0029a5260bc3", "target": 0, "func": "static void apb_pci_bridge_init(PCIBus *b)\n\n{\n\n    PCIDevice *dev = pci_bridge_get_device(b);\n\n\n\n    /*\n\n     * command register:\n\n     * According to PCI bridge spec, after reset\n\n     *   bus master bit is off\n\n     *   memory space enable bit is off\n\n     * According to manual (805-1251.pdf).\n\n     *   the reset value should be zero unless the boot pin is tied high\n\n     *   (which is true) and thus it should be PCI_COMMAND_MEMORY.\n\n     */\n\n    pci_set_word(dev->config + PCI_COMMAND,\n\n                 PCI_COMMAND_MEMORY);\n\n    pci_set_word(dev->config + PCI_STATUS,\n\n                 PCI_STATUS_FAST_BACK | PCI_STATUS_66MHZ |\n\n                 PCI_STATUS_DEVSEL_MEDIUM);\n\n    pci_set_byte(dev->config + PCI_REVISION_ID, 0x11);\n\n    pci_set_byte(dev->config + PCI_HEADER_TYPE,\n\n                 pci_get_byte(dev->config + PCI_HEADER_TYPE) |\n\n                 PCI_HEADER_TYPE_MULTI_FUNCTION);\n\n}\n", "idx": 23103}
{"project": "qemu", "commit_id": "fea7d77d3ea287d3b1878648f3049fc6bb4fd57b", "target": 0, "func": "void helper_fcmp_gt_DT(CPUSH4State *env, float64 t0, float64 t1)\n\n{\n\n    int relation;\n\n\n\n    set_float_exception_flags(0, &env->fp_status);\n\n    relation = float64_compare(t0, t1, &env->fp_status);\n\n    if (unlikely(relation == float_relation_unordered)) {\n\n        update_fpscr(env, GETPC());\n\n    } else {\n\n        env->sr_t = (relation == float_relation_greater);\n\n    }\n\n}\n", "idx": 23104}
{"project": "qemu", "commit_id": "f0536bb848ad6eb2709a7dc675f261bd160c751b", "target": 0, "func": "static int img_info(int argc, char **argv)\n\n{\n\n    int c;\n\n    OutputFormat output_format = OFORMAT_HUMAN;\n\n    const char *filename, *fmt, *output;\n\n    BlockDriverState *bs;\n\n    ImageInfo *info;\n\n\n\n    fmt = NULL;\n\n    output = NULL;\n\n    for(;;) {\n\n        int option_index = 0;\n\n        static const struct option long_options[] = {\n\n            {\"help\", no_argument, 0, 'h'},\n\n            {\"format\", required_argument, 0, 'f'},\n\n            {\"output\", required_argument, 0, OPTION_OUTPUT},\n\n            {0, 0, 0, 0}\n\n        };\n\n        c = getopt_long(argc, argv, \"f:h\",\n\n                        long_options, &option_index);\n\n        if (c == -1) {\n\n            break;\n\n        }\n\n        switch(c) {\n\n        case '?':\n\n        case 'h':\n\n            help();\n\n            break;\n\n        case 'f':\n\n            fmt = optarg;\n\n            break;\n\n        case OPTION_OUTPUT:\n\n            output = optarg;\n\n            break;\n\n        }\n\n    }\n\n    if (optind >= argc) {\n\n        help();\n\n    }\n\n    filename = argv[optind++];\n\n\n\n    if (output && !strcmp(output, \"json\")) {\n\n        output_format = OFORMAT_JSON;\n\n    } else if (output && !strcmp(output, \"human\")) {\n\n        output_format = OFORMAT_HUMAN;\n\n    } else if (output) {\n\n        error_report(\"--output must be used with human or json as argument.\");\n\n        return 1;\n\n    }\n\n\n\n    bs = bdrv_new_open(filename, fmt, BDRV_O_FLAGS | BDRV_O_NO_BACKING);\n\n    if (!bs) {\n\n        return 1;\n\n    }\n\n\n\n    info = g_new0(ImageInfo, 1);\n\n    collect_image_info(bs, info, filename, fmt);\n\n\n\n    switch (output_format) {\n\n    case OFORMAT_HUMAN:\n\n        dump_human_image_info(info);\n\n        dump_snapshots(bs);\n\n        break;\n\n    case OFORMAT_JSON:\n\n        collect_snapshots(bs, info);\n\n        dump_json_image_info(info);\n\n        break;\n\n    }\n\n\n\n    qapi_free_ImageInfo(info);\n\n    bdrv_delete(bs);\n\n    return 0;\n\n}\n", "idx": 23105}
{"project": "qemu", "commit_id": "bec1631100323fac0900aea71043d5c4e22fc2fa", "target": 0, "func": "static void tcg_out_setcond2(TCGContext *s, const TCGArg *args,\n\n                             const int *const_args)\n\n{\n\n    TCGArg new_args[6];\n\n    int label_true, label_over;\n\n\n\n    memcpy(new_args, args+1, 5*sizeof(TCGArg));\n\n\n\n    if (args[0] == args[1] || args[0] == args[2]\n\n        || (!const_args[3] && args[0] == args[3])\n\n        || (!const_args[4] && args[0] == args[4])) {\n\n        /* When the destination overlaps with one of the argument\n\n           registers, don't do anything tricky.  */\n\n        label_true = label_arg(gen_new_label());\n\n        label_over = label_arg(gen_new_label());\n\n\n\n        new_args[5] = label_true;\n\n        tcg_out_brcond2(s, new_args, const_args+1, 1);\n\n\n\n        tcg_out_movi(s, TCG_TYPE_I32, args[0], 0);\n\n        tcg_out_jxx(s, JCC_JMP, label_over, 1);\n\n        tcg_out_label(s, label_true, s->code_ptr);\n\n\n\n        tcg_out_movi(s, TCG_TYPE_I32, args[0], 1);\n\n        tcg_out_label(s, label_over, s->code_ptr);\n\n    } else {\n\n        /* When the destination does not overlap one of the arguments,\n\n           clear the destination first, jump if cond false, and emit an\n\n           increment in the true case.  This results in smaller code.  */\n\n\n\n        tcg_out_movi(s, TCG_TYPE_I32, args[0], 0);\n\n\n\n        label_over = label_arg(gen_new_label());\n\n        new_args[4] = tcg_invert_cond(new_args[4]);\n\n        new_args[5] = label_over;\n\n        tcg_out_brcond2(s, new_args, const_args+1, 1);\n\n\n\n        tgen_arithi(s, ARITH_ADD, args[0], 1, 0);\n\n        tcg_out_label(s, label_over, s->code_ptr);\n\n    }\n\n}\n", "idx": 23106}
{"project": "qemu", "commit_id": "d9d74f4177af59bec23baa480d640709f56df0aa", "target": 0, "func": "static int handle_dependencies(BlockDriverState *bs, uint64_t guest_offset,\n\n    unsigned int *nb_clusters)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    QCowL2Meta *old_alloc;\n\n\n\n    QLIST_FOREACH(old_alloc, &s->cluster_allocs, next_in_flight) {\n\n\n\n        uint64_t start = guest_offset >> s->cluster_bits;\n\n        uint64_t end = start + *nb_clusters;\n\n        uint64_t old_start = old_alloc->offset >> s->cluster_bits;\n\n        uint64_t old_end = old_start + old_alloc->nb_clusters;\n\n\n\n        if (end < old_start || start > old_end) {\n\n            /* No intersection */\n\n        } else {\n\n            if (start < old_start) {\n\n                /* Stop at the start of a running allocation */\n\n                *nb_clusters = old_start - start;\n\n            } else {\n\n                *nb_clusters = 0;\n\n            }\n\n\n\n            if (*nb_clusters == 0) {\n\n                /* Wait for the dependency to complete. We need to recheck\n\n                 * the free/allocated clusters when we continue. */\n\n                qemu_co_mutex_unlock(&s->lock);\n\n                qemu_co_queue_wait(&old_alloc->dependent_requests);\n\n                qemu_co_mutex_lock(&s->lock);\n\n                return -EAGAIN;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!*nb_clusters) {\n\n        abort();\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23107}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "int qio_dns_resolver_lookup_sync(QIODNSResolver *resolver,\n\n                                 SocketAddressLegacy *addr,\n\n                                 size_t *naddrs,\n\n                                 SocketAddressLegacy ***addrs,\n\n                                 Error **errp)\n\n{\n\n    switch (addr->type) {\n\n    case SOCKET_ADDRESS_LEGACY_KIND_INET:\n\n        return qio_dns_resolver_lookup_sync_inet(resolver,\n\n                                                 addr,\n\n                                                 naddrs,\n\n                                                 addrs,\n\n                                                 errp);\n\n\n\n    case SOCKET_ADDRESS_LEGACY_KIND_UNIX:\n\n    case SOCKET_ADDRESS_LEGACY_KIND_VSOCK:\n\n    case SOCKET_ADDRESS_LEGACY_KIND_FD:\n\n        return qio_dns_resolver_lookup_sync_nop(resolver,\n\n                                                addr,\n\n                                                naddrs,\n\n                                                addrs,\n\n                                                errp);\n\n\n\n    default:\n\n        abort();\n\n    }\n\n}\n", "idx": 23108}
{"project": "qemu", "commit_id": "7c08db30e6a43f7083a881eb07bfbc878e001e08", "target": 0, "func": "static int cpu_x86_find_by_name(X86CPU *cpu, x86_def_t *x86_cpu_def,\n\n                                const char *name)\n\n{\n\n    x86_def_t *def;\n\n    int i;\n\n\n\n    if (name == NULL) {\n\n        return -1;\n\n    }\n\n    if (kvm_enabled() && strcmp(name, \"host\") == 0) {\n\n        kvm_cpu_fill_host(x86_cpu_def);\n\n        object_property_set_bool(OBJECT(cpu), true, \"pmu\", &error_abort);\n\n        return 0;\n\n    }\n\n\n\n    for (i = 0; i < ARRAY_SIZE(builtin_x86_defs); i++) {\n\n        def = &builtin_x86_defs[i];\n\n        if (strcmp(name, def->name) == 0) {\n\n            memcpy(x86_cpu_def, def, sizeof(*def));\n\n            /* sysenter isn't supported in compatibility mode on AMD,\n\n             * syscall isn't supported in compatibility mode on Intel.\n\n             * Normally we advertise the actual CPU vendor, but you can\n\n             * override this using the 'vendor' property if you want to use\n\n             * KVM's sysenter/syscall emulation in compatibility mode and\n\n             * when doing cross vendor migration\n\n             */\n\n            if (kvm_enabled()) {\n\n                uint32_t  ebx = 0, ecx = 0, edx = 0;\n\n                host_cpuid(0, 0, NULL, &ebx, &ecx, &edx);\n\n                x86_cpu_vendor_words2str(x86_cpu_def->vendor, ebx, edx, ecx);\n\n            }\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    return -1;\n\n}\n", "idx": 23109}
{"project": "qemu", "commit_id": "7ad4c7200111d20eb97eed4f46b6026e3f0b0eef", "target": 0, "func": "char *g_strdup(const char *s)\n\n{\n\n    char *dup;\n\n    size_t i;\n\n\n\n    if (!s) {\n\n        return NULL;\n\n    }\n\n\n\n    __coverity_string_null_sink__(s);\n\n    __coverity_string_size_sink__(s);\n\n    dup = __coverity_alloc_nosize__();\n\n    __coverity_mark_as_afm_allocated__(dup, AFM_free);\n\n    for (i = 0; (dup[i] = s[i]); i++) ;\n\n    return dup;\n\n}\n", "idx": 23110}
{"project": "qemu", "commit_id": "b931bfbf042983f311b3b09894d8030b2755a638", "target": 0, "func": "static int net_vhost_user_init(NetClientState *peer, const char *device,\n\n                               const char *name, CharDriverState *chr)\n\n{\n\n    NetClientState *nc;\n\n    VhostUserState *s;\n\n\n\n    nc = qemu_new_net_client(&net_vhost_user_info, peer, device, name);\n\n\n\n    snprintf(nc->info_str, sizeof(nc->info_str), \"vhost-user to %s\",\n\n             chr->label);\n\n\n\n    s = DO_UPCAST(VhostUserState, nc, nc);\n\n\n\n    /* We don't provide a receive callback */\n\n    s->nc.receive_disabled = 1;\n\n    s->chr = chr;\n\n\n\n    qemu_chr_add_handlers(s->chr, NULL, NULL, net_vhost_user_event, s);\n\n\n\n    return 0;\n\n}\n", "idx": 23113}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static int megasas_build_sense(MegasasCmd *cmd, uint8_t *sense_ptr,\n\n    uint8_t sense_len)\n\n{\n\n    uint32_t pa_hi = 0, pa_lo;\n\n    target_phys_addr_t pa;\n\n\n\n    if (sense_len > cmd->frame->header.sense_len) {\n\n        sense_len = cmd->frame->header.sense_len;\n\n    }\n\n    if (sense_len) {\n\n        pa_lo = le32_to_cpu(cmd->frame->pass.sense_addr_lo);\n\n        if (megasas_frame_is_sense64(cmd)) {\n\n            pa_hi = le32_to_cpu(cmd->frame->pass.sense_addr_hi);\n\n        }\n\n        pa = ((uint64_t) pa_hi << 32) | pa_lo;\n\n        cpu_physical_memory_write(pa, sense_ptr, sense_len);\n\n        cmd->frame->header.sense_len = sense_len;\n\n    }\n\n    return sense_len;\n\n}\n", "idx": 23114}
{"project": "qemu", "commit_id": "aa6c6ae843cbdc251224bc6170d2663ac929b04f", "target": 0, "func": "MemoryRegion *rom_add_blob(const char *name, const void *blob, size_t len,\n\n                   size_t max_len, hwaddr addr, const char *fw_file_name,\n\n                   FWCfgReadCallback fw_callback, void *callback_opaque)\n\n{\n\n    MachineClass *mc = MACHINE_GET_CLASS(qdev_get_machine());\n\n    Rom *rom;\n\n    MemoryRegion *mr = NULL;\n\n\n\n    rom           = g_malloc0(sizeof(*rom));\n\n    rom->name     = g_strdup(name);\n\n    rom->addr     = addr;\n\n    rom->romsize  = max_len ? max_len : len;\n\n    rom->datasize = len;\n\n    rom->data     = g_malloc0(rom->datasize);\n\n    memcpy(rom->data, blob, len);\n\n    rom_insert(rom);\n\n    if (fw_file_name && fw_cfg) {\n\n        char devpath[100];\n\n        void *data;\n\n\n\n        snprintf(devpath, sizeof(devpath), \"/rom@%s\", fw_file_name);\n\n\n\n        if (mc->rom_file_has_mr) {\n\n            data = rom_set_mr(rom, OBJECT(fw_cfg), devpath);\n\n            mr = rom->mr;\n\n        } else {\n\n            data = rom->data;\n\n        }\n\n\n\n        fw_cfg_add_file_callback(fw_cfg, fw_file_name,\n\n                                 fw_callback, callback_opaque,\n\n                                 data, rom->datasize);\n\n    }\n\n    return mr;\n\n}\n", "idx": 23115}
{"project": "qemu", "commit_id": "d85f4222b4681da7ebf8a90b26e085a68fa2c55a", "target": 0, "func": "static coroutine_fn int qcow_co_readv(BlockDriverState *bs, int64_t sector_num,\n\n                         int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    int ret = 0, n;\n\n    uint64_t cluster_offset;\n\n    struct iovec hd_iov;\n\n    QEMUIOVector hd_qiov;\n\n    uint8_t *buf;\n\n    void *orig_buf;\n\n    Error *err = NULL;\n\n\n\n    if (qiov->niov > 1) {\n\n        buf = orig_buf = qemu_try_blockalign(bs, qiov->size);\n\n        if (buf == NULL) {\n\n            return -ENOMEM;\n\n        }\n\n    } else {\n\n        orig_buf = NULL;\n\n        buf = (uint8_t *)qiov->iov->iov_base;\n\n    }\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (nb_sectors != 0) {\n\n        /* prepare next request */\n\n        cluster_offset = get_cluster_offset(bs, sector_num << 9,\n\n                                                 0, 0, 0, 0);\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        n = s->cluster_sectors - index_in_cluster;\n\n        if (n > nb_sectors) {\n\n            n = nb_sectors;\n\n        }\n\n\n\n        if (!cluster_offset) {\n\n            if (bs->backing) {\n\n                /* read from the base image */\n\n                hd_iov.iov_base = (void *)buf;\n\n                hd_iov.iov_len = n * 512;\n\n                qemu_iovec_init_external(&hd_qiov, &hd_iov, 1);\n\n                qemu_co_mutex_unlock(&s->lock);\n\n                ret = bdrv_co_readv(bs->backing, sector_num, n, &hd_qiov);\n\n                qemu_co_mutex_lock(&s->lock);\n\n                if (ret < 0) {\n\n                    goto fail;\n\n                }\n\n            } else {\n\n                /* Note: in this case, no need to wait */\n\n                memset(buf, 0, 512 * n);\n\n            }\n\n        } else if (cluster_offset & QCOW_OFLAG_COMPRESSED) {\n\n            /* add AIO support for compressed blocks ? */\n\n            if (decompress_cluster(bs, cluster_offset) < 0) {\n\n                goto fail;\n\n            }\n\n            memcpy(buf,\n\n                   s->cluster_cache + index_in_cluster * 512, 512 * n);\n\n        } else {\n\n            if ((cluster_offset & 511) != 0) {\n\n                goto fail;\n\n            }\n\n            hd_iov.iov_base = (void *)buf;\n\n            hd_iov.iov_len = n * 512;\n\n            qemu_iovec_init_external(&hd_qiov, &hd_iov, 1);\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            ret = bdrv_co_readv(bs->file,\n\n                                (cluster_offset >> 9) + index_in_cluster,\n\n                                n, &hd_qiov);\n\n            qemu_co_mutex_lock(&s->lock);\n\n            if (ret < 0) {\n\n                break;\n\n            }\n\n            if (bs->encrypted) {\n\n                assert(s->cipher);\n\n                if (encrypt_sectors(s, sector_num, buf,\n\n                                    n, false, &err) < 0) {\n\n                    goto fail;\n\n                }\n\n            }\n\n        }\n\n        ret = 0;\n\n\n\n        nb_sectors -= n;\n\n        sector_num += n;\n\n        buf += n * 512;\n\n    }\n\n\n\ndone:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    if (qiov->niov > 1) {\n\n        qemu_iovec_from_buf(qiov, 0, orig_buf, qiov->size);\n\n        qemu_vfree(orig_buf);\n\n    }\n\n\n\n    return ret;\n\n\n\nfail:\n\n    error_free(err);\n\n    ret = -EIO;\n\n    goto done;\n\n}\n", "idx": 23116}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t sysctl_read(void *opaque, target_phys_addr_t addr,\n\n                            unsigned size)\n\n{\n\n    MilkymistSysctlState *s = opaque;\n\n    uint32_t r = 0;\n\n\n\n    addr >>= 2;\n\n    switch (addr) {\n\n    case R_TIMER0_COUNTER:\n\n        r = (uint32_t)ptimer_get_count(s->ptimer0);\n\n        /* milkymist timer counts up */\n\n        r = s->regs[R_TIMER0_COMPARE] - r;\n\n        break;\n\n    case R_TIMER1_COUNTER:\n\n        r = (uint32_t)ptimer_get_count(s->ptimer1);\n\n        /* milkymist timer counts up */\n\n        r = s->regs[R_TIMER1_COMPARE] - r;\n\n        break;\n\n    case R_GPIO_IN:\n\n    case R_GPIO_OUT:\n\n    case R_GPIO_INTEN:\n\n    case R_TIMER0_CONTROL:\n\n    case R_TIMER0_COMPARE:\n\n    case R_TIMER1_CONTROL:\n\n    case R_TIMER1_COMPARE:\n\n    case R_ICAP:\n\n    case R_DBG_SCRATCHPAD:\n\n    case R_DBG_WRITE_LOCK:\n\n    case R_CLK_FREQUENCY:\n\n    case R_CAPABILITIES:\n\n    case R_SYSTEM_ID:\n\n        r = s->regs[addr];\n\n        break;\n\n\n\n    default:\n\n        error_report(\"milkymist_sysctl: read access to unknown register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    }\n\n\n\n    trace_milkymist_sysctl_memory_read(addr << 2, r);\n\n\n\n    return r;\n\n}\n", "idx": 23117}
{"project": "qemu", "commit_id": "f8a2e5e3ca6146d4cc66a4750daf44a0cf043319", "target": 0, "func": "static int vmdk_is_allocated(BlockDriverState *bs, int64_t sector_num,\n\n                             int nb_sectors, int *pnum)\n\n{\n\n    BDRVVmdkState *s = bs->opaque;\n\n    int64_t index_in_cluster, n, ret;\n\n    uint64_t offset;\n\n    VmdkExtent *extent;\n\n\n\n    extent = find_extent(s, sector_num, NULL);\n\n    if (!extent) {\n\n        return 0;\n\n    }\n\n    ret = get_cluster_offset(bs, extent, NULL,\n\n                            sector_num * 512, 0, &offset);\n\n    /* get_cluster_offset returning 0 means success */\n\n    ret = !ret;\n\n\n\n    index_in_cluster = sector_num % extent->cluster_sectors;\n\n    n = extent->cluster_sectors - index_in_cluster;\n\n    if (n > nb_sectors) {\n\n        n = nb_sectors;\n\n    }\n\n    *pnum = n;\n\n    return ret;\n\n}\n", "idx": 23118}
{"project": "qemu", "commit_id": "42d859001d180ea788aa2d34a7be021ac8c447f2", "target": 0, "func": "void acpi_setup(PcGuestInfo *guest_info)\n\n{\n\n    AcpiBuildTables tables;\n\n    AcpiBuildState *build_state;\n\n\n\n    if (!guest_info->fw_cfg) {\n\n        ACPI_BUILD_DPRINTF(\"No fw cfg. Bailing out.\\n\");\n\n        return;\n\n    }\n\n\n\n    if (!guest_info->has_acpi_build) {\n\n        ACPI_BUILD_DPRINTF(\"ACPI build disabled. Bailing out.\\n\");\n\n        return;\n\n    }\n\n\n\n    if (!acpi_enabled) {\n\n        ACPI_BUILD_DPRINTF(\"ACPI disabled. Bailing out.\\n\");\n\n        return;\n\n    }\n\n\n\n    build_state = g_malloc0(sizeof *build_state);\n\n\n\n    build_state->guest_info = guest_info;\n\n\n\n    acpi_set_pci_info();\n\n\n\n    acpi_build_tables_init(&tables);\n\n    acpi_build(build_state->guest_info, &tables);\n\n\n\n    /* Now expose it all to Guest */\n\n    build_state->table_ram = acpi_add_rom_blob(build_state, tables.table_data,\n\n                                               ACPI_BUILD_TABLE_FILE,\n\n                                               ACPI_BUILD_TABLE_MAX_SIZE);\n\n    assert(build_state->table_ram != RAM_ADDR_MAX);\n\n    build_state->table_size = acpi_data_len(tables.table_data);\n\n\n\n    build_state->linker_ram =\n\n        acpi_add_rom_blob(build_state, tables.linker, \"etc/table-loader\", 0);\n\n    build_state->linker_size = acpi_data_len(tables.linker);\n\n\n\n    fw_cfg_add_file(guest_info->fw_cfg, ACPI_BUILD_TPMLOG_FILE,\n\n                    tables.tcpalog->data, acpi_data_len(tables.tcpalog));\n\n\n\n    if (guest_info->has_immutable_rsdp) {\n\n        /*\n\n         * Keep for compatibility with old machine types.\n\n         * Though RSDP is small, its contents isn't immutable, so\n\n         * update it along with the rest of tables on guest access.\n\n         */\n\n        fw_cfg_add_file_callback(guest_info->fw_cfg, ACPI_BUILD_RSDP_FILE,\n\n                                 acpi_build_update, build_state,\n\n                                 tables.rsdp->data, acpi_data_len(tables.rsdp));\n\n        build_state->rsdp = tables.rsdp->data;\n\n    } else {\n\n        build_state->rsdp = qemu_get_ram_ptr(\n\n            acpi_add_rom_blob(build_state, tables.rsdp, ACPI_BUILD_RSDP_FILE, 0)\n\n        );\n\n    }\n\n\n\n    qemu_register_reset(acpi_build_reset, build_state);\n\n    acpi_build_reset(build_state);\n\n    vmstate_register(NULL, 0, &vmstate_acpi_build, build_state);\n\n\n\n    /* Cleanup tables but don't free the memory: we track it\n\n     * in build_state.\n\n     */\n\n    acpi_build_tables_cleanup(&tables, false);\n\n}\n", "idx": 23119}
{"project": "qemu", "commit_id": "7102fa7073b2cefb33ab4012a11f15fbf297a74b", "target": 0, "func": "static void pc_compat_2_0(MachineState *machine)\n\n{\n\n    pc_compat_2_1(machine);\n\n    smbios_legacy_mode = true;\n\n    has_reserved_memory = false;\n\n    pc_set_legacy_acpi_data_size();\n\n}\n", "idx": 23120}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void apic_mem_writew(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n}\n", "idx": 23121}
{"project": "qemu", "commit_id": "a368741bf2508b7ca29d9ade73ec1b0f29ae2286", "target": 0, "func": "static int cdrom_read_toc_raw(IDEState *s, uint8_t *buf, int msf, \n\n                              int session_num)\n\n{\n\n    uint8_t *q;\n\n    int nb_sectors, len;\n\n    \n\n    q = buf + 2;\n\n    *q++ = 1; /* first session */\n\n    *q++ = 1; /* last session */\n\n\n\n    *q++ = 1; /* session number */\n\n    *q++ = 0x14; /* data track */\n\n    *q++ = 0; /* track number */\n\n    *q++ = 0xa0; /* lead-in */\n\n    *q++ = 0; /* min */\n\n    *q++ = 0; /* sec */\n\n    *q++ = 0; /* frame */\n\n    *q++ = 0;\n\n    *q++ = 1; /* first track */\n\n    *q++ = 0x00; /* disk type */\n\n    *q++ = 0x00;\n\n    \n\n    *q++ = 1; /* session number */\n\n    *q++ = 0x14; /* data track */\n\n    *q++ = 0; /* track number */\n\n    *q++ = 0xa1;\n\n    *q++ = 0; /* min */\n\n    *q++ = 0; /* sec */\n\n    *q++ = 0; /* frame */\n\n    *q++ = 0;\n\n    *q++ = 1; /* last track */\n\n    *q++ = 0x00;\n\n    *q++ = 0x00;\n\n    \n\n    *q++ = 1; /* session number */\n\n    *q++ = 0x14; /* data track */\n\n    *q++ = 0; /* track number */\n\n    *q++ = 0xa2; /* lead-out */\n\n    *q++ = 0; /* min */\n\n    *q++ = 0; /* sec */\n\n    *q++ = 0; /* frame */\n\n    nb_sectors = s->nb_sectors >> 2;\n\n    if (msf) {\n\n        *q++ = 0; /* reserved */\n\n        lba_to_msf(q, nb_sectors);\n\n        q += 3;\n\n    } else {\n\n        cpu_to_ube32(q, nb_sectors);\n\n        q += 4;\n\n    }\n\n\n\n    *q++ = 1; /* session number */\n\n    *q++ = 0x14; /* ADR, control */\n\n    *q++ = 0;    /* track number */\n\n    *q++ = 1;    /* point */\n\n    *q++ = 0; /* min */\n\n    *q++ = 0; /* sec */\n\n    *q++ = 0; /* frame */\n\n    *q++ = 0; \n\n    *q++ = 0; \n\n    *q++ = 0; \n\n    *q++ = 0; \n\n\n\n    len = q - buf;\n\n    cpu_to_ube16(buf, len - 2);\n\n    return len;\n\n}\n", "idx": 23122}
{"project": "qemu", "commit_id": "9561fda8d90e176bef598ba87c42a1bd6ad03ef7", "target": 1, "func": "static void virtio_ccw_rng_instance_init(Object *obj)\n\n{\n\n    VirtIORNGCcw *dev = VIRTIO_RNG_CCW(obj);\n\n    object_initialize(&dev->vdev, sizeof(dev->vdev), TYPE_VIRTIO_RNG);\n\n    object_property_add_child(obj, \"virtio-backend\", OBJECT(&dev->vdev), NULL);\n\n    object_property_add_link(obj, \"rng\", TYPE_RNG_BACKEND,\n\n                             (Object **)&dev->vdev.conf.rng, NULL);\n\n}\n", "idx": 23124}
{"project": "qemu", "commit_id": "a9605e0317c7a6d5e68f3a3b6708c8ef1096f4bc", "target": 1, "func": "static int apic_init_common(SysBusDevice *dev)\n\n{\n\n    APICCommonState *s = APIC_COMMON(dev);\n\n    APICCommonClass *info;\n\n    static DeviceState *vapic;\n\n    static int apic_no;\n\n\n\n    if (apic_no >= MAX_APICS) {\n\n        return -1;\n\n    }\n\n    s->idx = apic_no++;\n\n\n\n    info = APIC_COMMON_GET_CLASS(s);\n\n    info->init(s);\n\n\n\n    sysbus_init_mmio(dev, &s->io_memory);\n\n\n\n    if (!vapic && s->vapic_control & VAPIC_ENABLE_MASK) {\n\n        vapic = sysbus_create_simple(\"kvmvapic\", -1, NULL);\n\n    }\n\n    s->vapic = vapic;\n\n    if (apic_report_tpr_access && info->enable_tpr_reporting) {\n\n        info->enable_tpr_reporting(s, true);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23125}
{"project": "qemu", "commit_id": "d470ad42acfc73c45d3e8ed5311a491160b4c100", "target": 1, "func": "static int coroutine_fn bdrv_co_do_pwrite_zeroes(BlockDriverState *bs,\n    int64_t offset, int bytes, BdrvRequestFlags flags)\n{\n    BlockDriver *drv = bs->drv;\n    QEMUIOVector qiov;\n    struct iovec iov = {0};\n    int ret = 0;\n    bool need_flush = false;\n    int head = 0;\n    int tail = 0;\n    int max_write_zeroes = MIN_NON_ZERO(bs->bl.max_pwrite_zeroes, INT_MAX);\n    int alignment = MAX(bs->bl.pwrite_zeroes_alignment,\n                        bs->bl.request_alignment);\n    int max_transfer = MIN_NON_ZERO(bs->bl.max_transfer, MAX_BOUNCE_BUFFER);\n    assert(alignment % bs->bl.request_alignment == 0);\n    head = offset % alignment;\n    tail = (offset + bytes) % alignment;\n    max_write_zeroes = QEMU_ALIGN_DOWN(max_write_zeroes, alignment);\n    assert(max_write_zeroes >= bs->bl.request_alignment);\n    while (bytes > 0 && !ret) {\n        int num = bytes;\n        /* Align request.  Block drivers can expect the \"bulk\" of the request\n         * to be aligned, and that unaligned requests do not cross cluster\n         * boundaries.\n         */\n        if (head) {\n            /* Make a small request up to the first aligned sector. For\n             * convenience, limit this request to max_transfer even if\n             * we don't need to fall back to writes.  */\n            num = MIN(MIN(bytes, max_transfer), alignment - head);\n            head = (head + num) % alignment;\n            assert(num < max_write_zeroes);\n        } else if (tail && num > alignment) {\n            /* Shorten the request to the last aligned sector.  */\n            num -= tail;\n        /* limit request size */\n        if (num > max_write_zeroes) {\n            num = max_write_zeroes;\n        ret = -ENOTSUP;\n        /* First try the efficient write zeroes operation */\n        if (drv->bdrv_co_pwrite_zeroes) {\n            ret = drv->bdrv_co_pwrite_zeroes(bs, offset, num,\n                                             flags & bs->supported_zero_flags);\n            if (ret != -ENOTSUP && (flags & BDRV_REQ_FUA) &&\n                !(bs->supported_zero_flags & BDRV_REQ_FUA)) {\n                need_flush = true;\n        } else {\n            assert(!bs->supported_zero_flags);\n        if (ret == -ENOTSUP) {\n            /* Fall back to bounce buffer if write zeroes is unsupported */\n            BdrvRequestFlags write_flags = flags & ~BDRV_REQ_ZERO_WRITE;\n            if ((flags & BDRV_REQ_FUA) &&\n                !(bs->supported_write_flags & BDRV_REQ_FUA)) {\n                /* No need for bdrv_driver_pwrite() to do a fallback\n                 * flush on each chunk; use just one at the end */\n                write_flags &= ~BDRV_REQ_FUA;\n                need_flush = true;\n            num = MIN(num, max_transfer);\n            iov.iov_len = num;\n            if (iov.iov_base == NULL) {\n                iov.iov_base = qemu_try_blockalign(bs, num);\n                if (iov.iov_base == NULL) {\n                    ret = -ENOMEM;\n                    goto fail;\n                memset(iov.iov_base, 0, num);\n            qemu_iovec_init_external(&qiov, &iov, 1);\n            ret = bdrv_driver_pwritev(bs, offset, num, &qiov, write_flags);\n            /* Keep bounce buffer around if it is big enough for all\n             * all future requests.\n             */\n            if (num < max_transfer) {\n                qemu_vfree(iov.iov_base);\n                iov.iov_base = NULL;\n        offset += num;\n        bytes -= num;\nfail:\n    if (ret == 0 && need_flush) {\n        ret = bdrv_co_flush(bs);\n    qemu_vfree(iov.iov_base);\n    return ret;", "idx": 23126}
{"project": "qemu", "commit_id": "282c6a2f292705f823554447ca0b7731b6f81a97", "target": 1, "func": "static void ioreq_release(struct ioreq *ioreq, bool finish)\n\n{\n\n    struct XenBlkDev *blkdev = ioreq->blkdev;\n\n\n\n    QLIST_REMOVE(ioreq, list);\n\n    memset(ioreq, 0, sizeof(*ioreq));\n\n    ioreq->blkdev = blkdev;\n\n    QLIST_INSERT_HEAD(&blkdev->freelist, ioreq, list);\n\n    if (finish) {\n\n        blkdev->requests_finished--;\n\n    } else {\n\n        blkdev->requests_inflight--;\n\n    }\n\n}\n", "idx": 23128}
{"project": "qemu", "commit_id": "31ca6d077c24b7aaa322d8930e3e5debbdb4a047", "target": 1, "func": "int bdrv_open_backing_file(BlockDriverState *bs)\n\n{\n\n    char backing_filename[PATH_MAX];\n\n    int back_flags, ret;\n\n    BlockDriver *back_drv = NULL;\n\n\n\n    if (bs->backing_hd != NULL) {\n\n        return 0;\n\n    }\n\n\n\n    bs->open_flags &= ~BDRV_O_NO_BACKING;\n\n    if (bs->backing_file[0] == '\\0') {\n\n        return 0;\n\n    }\n\n\n\n    bs->backing_hd = bdrv_new(\"\");\n\n    bdrv_get_full_backing_filename(bs, backing_filename,\n\n                                   sizeof(backing_filename));\n\n\n\n    if (bs->backing_format[0] != '\\0') {\n\n        back_drv = bdrv_find_format(bs->backing_format);\n\n    }\n\n\n\n    /* backing files always opened read-only */\n\n    back_flags = bs->open_flags & ~(BDRV_O_RDWR | BDRV_O_SNAPSHOT);\n\n\n\n    ret = bdrv_open(bs->backing_hd, backing_filename, NULL,\n\n                    back_flags, back_drv);\n\n    if (ret < 0) {\n\n        bdrv_delete(bs->backing_hd);\n\n        bs->backing_hd = NULL;\n\n        bs->open_flags |= BDRV_O_NO_BACKING;\n\n        return ret;\n\n    }\n\n    return 0;\n\n}\n", "idx": 23129}
{"project": "qemu", "commit_id": "56439e9d55626b65ecb887f1ac3714652555312e", "target": 1, "func": "static coroutine_fn int qcow_co_writev(BlockDriverState *bs, int64_t sector_num,\n\n                          int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    uint64_t cluster_offset;\n\n    int ret = 0, n;\n\n    struct iovec hd_iov;\n\n    QEMUIOVector hd_qiov;\n\n    uint8_t *buf;\n\n    void *orig_buf;\n\n\n\n    s->cluster_cache_offset = -1; /* disable compressed cache */\n\n\n\n    /* We must always copy the iov when encrypting, so we\n\n     * don't modify the original data buffer during encryption */\n\n    if (bs->encrypted || qiov->niov > 1) {\n\n        buf = orig_buf = qemu_try_blockalign(bs, qiov->size);\n\n        if (buf == NULL) {\n\n            return -ENOMEM;\n\n        }\n\n        qemu_iovec_to_buf(qiov, 0, buf, qiov->size);\n\n    } else {\n\n        orig_buf = NULL;\n\n        buf = (uint8_t *)qiov->iov->iov_base;\n\n    }\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (nb_sectors != 0) {\n\n\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        n = s->cluster_sectors - index_in_cluster;\n\n        if (n > nb_sectors) {\n\n            n = nb_sectors;\n\n        }\n\n        cluster_offset = get_cluster_offset(bs, sector_num << 9, 1, 0,\n\n                                            index_in_cluster,\n\n                                            index_in_cluster + n);\n\n        if (!cluster_offset || (cluster_offset & 511) != 0) {\n\n            ret = -EIO;\n\n            break;\n\n        }\n\n        if (bs->encrypted) {\n\n            assert(s->crypto);\n\n            if (qcrypto_block_encrypt(s->crypto, sector_num, buf,\n\n                                      n * BDRV_SECTOR_SIZE, NULL) < 0) {\n\n                ret = -EIO;\n\n                break;\n\n            }\n\n        }\n\n\n\n        hd_iov.iov_base = (void *)buf;\n\n        hd_iov.iov_len = n * 512;\n\n        qemu_iovec_init_external(&hd_qiov, &hd_iov, 1);\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        ret = bdrv_co_writev(bs->file,\n\n                             (cluster_offset >> 9) + index_in_cluster,\n\n                             n, &hd_qiov);\n\n        qemu_co_mutex_lock(&s->lock);\n\n        if (ret < 0) {\n\n            break;\n\n        }\n\n        ret = 0;\n\n\n\n        nb_sectors -= n;\n\n        sector_num += n;\n\n        buf += n * 512;\n\n    }\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    qemu_vfree(orig_buf);\n\n\n\n    return ret;\n\n}\n", "idx": 23130}
{"project": "qemu", "commit_id": "635db18f68ded6abec11cd4cf64ebc15c1c6b190", "target": 1, "func": "static void monitor_qapi_event_emit(QAPIEvent event, QDict *qdict)\n\n{\n\n    Monitor *mon;\n\n\n\n    trace_monitor_protocol_event_emit(event, qdict);\n\n    QLIST_FOREACH(mon, &mon_list, entry) {\n\n        if (monitor_is_qmp(mon) && mon->qmp.in_command_mode) {\n\n            monitor_json_emitter(mon, QOBJECT(qdict));\n\n        }\n\n    }\n\n}\n", "idx": 23131}
{"project": "qemu", "commit_id": "3558f8055f37a34762b7a2a0f02687e6eeab893d", "target": 0, "func": "static void gen_lea_v_seg(DisasContext *s, TCGMemOp aflag, TCGv a0,\n\n                          int def_seg, int ovr_seg)\n\n{\n\n    switch (aflag) {\n\n#ifdef TARGET_X86_64\n\n    case MO_64:\n\n        if (ovr_seg < 0) {\n\n            tcg_gen_mov_tl(cpu_A0, a0);\n\n            return;\n\n        }\n\n        break;\n\n#endif\n\n    case MO_32:\n\n        /* 32 bit address */\n\n        if (ovr_seg < 0) {\n\n            if (s->addseg) {\n\n                ovr_seg = def_seg;\n\n            } else {\n\n                tcg_gen_ext32u_tl(cpu_A0, a0);\n\n                return;\n\n            }\n\n        }\n\n        break;\n\n    case MO_16:\n\n        /* 16 bit address */\n\n        if (ovr_seg < 0) {\n\n            ovr_seg = def_seg;\n\n        }\n\n        tcg_gen_ext16u_tl(cpu_A0, a0);\n\n        /* ADDSEG will only be false in 16-bit mode for LEA.  */\n\n        if (!s->addseg) {\n\n            return;\n\n        }\n\n        a0 = cpu_A0;\n\n        break;\n\n    default:\n\n        tcg_abort();\n\n    }\n\n\n\n    if (ovr_seg >= 0) {\n\n        TCGv seg = tcg_temp_new();\n\n\n\n        tcg_gen_ld_tl(seg, cpu_env, offsetof(CPUX86State, segs[ovr_seg].base));\n\n\n\n        if (aflag == MO_64) {\n\n            tcg_gen_add_tl(cpu_A0, a0, seg);\n\n        } else if (CODE64(s)) {\n\n            tcg_gen_ext32u_tl(cpu_A0, a0);\n\n            tcg_gen_add_tl(cpu_A0, cpu_A0, seg);\n\n        } else {\n\n            tcg_gen_add_tl(cpu_A0, a0, seg);\n\n            tcg_gen_ext32u_tl(cpu_A0, cpu_A0);\n\n        }\n\n\n\n        tcg_temp_free(seg);\n\n    }\n\n}\n", "idx": 23133}
{"project": "qemu", "commit_id": "bae8196d9f97916de6323e70e3e374362ee16ec4", "target": 0, "func": "static void coroutine_fn mirror_run(void *opaque)\n\n{\n\n    MirrorBlockJob *s = opaque;\n\n    MirrorExitData *data;\n\n    BlockDriverState *bs = blk_bs(s->common.blk);\n\n    BlockDriverState *target_bs = blk_bs(s->target);\n\n    int64_t length;\n\n    BlockDriverInfo bdi;\n\n    char backing_filename[2]; /* we only need 2 characters because we are only\n\n                                 checking for a NULL string */\n\n    int ret = 0;\n\n    int target_cluster_size = BDRV_SECTOR_SIZE;\n\n\n\n    if (block_job_is_cancelled(&s->common)) {\n\n        goto immediate_exit;\n\n    }\n\n\n\n    s->bdev_length = bdrv_getlength(bs);\n\n    if (s->bdev_length < 0) {\n\n        ret = s->bdev_length;\n\n        goto immediate_exit;\n\n    } else if (s->bdev_length == 0) {\n\n        /* Report BLOCK_JOB_READY and wait for complete. */\n\n        block_job_event_ready(&s->common);\n\n        s->synced = true;\n\n        while (!block_job_is_cancelled(&s->common) && !s->should_complete) {\n\n            block_job_yield(&s->common);\n\n        }\n\n        s->common.cancelled = false;\n\n        goto immediate_exit;\n\n    }\n\n\n\n    length = DIV_ROUND_UP(s->bdev_length, s->granularity);\n\n    s->in_flight_bitmap = bitmap_new(length);\n\n\n\n    /* If we have no backing file yet in the destination, we cannot let\n\n     * the destination do COW.  Instead, we copy sectors around the\n\n     * dirty data if needed.  We need a bitmap to do that.\n\n     */\n\n    bdrv_get_backing_filename(target_bs, backing_filename,\n\n                              sizeof(backing_filename));\n\n    if (!bdrv_get_info(target_bs, &bdi) && bdi.cluster_size) {\n\n        target_cluster_size = bdi.cluster_size;\n\n    }\n\n    if (backing_filename[0] && !target_bs->backing\n\n        && s->granularity < target_cluster_size) {\n\n        s->buf_size = MAX(s->buf_size, target_cluster_size);\n\n        s->cow_bitmap = bitmap_new(length);\n\n    }\n\n    s->target_cluster_sectors = target_cluster_size >> BDRV_SECTOR_BITS;\n\n    s->max_iov = MIN(bs->bl.max_iov, target_bs->bl.max_iov);\n\n\n\n    s->buf = qemu_try_blockalign(bs, s->buf_size);\n\n    if (s->buf == NULL) {\n\n        ret = -ENOMEM;\n\n        goto immediate_exit;\n\n    }\n\n\n\n    mirror_free_init(s);\n\n\n\n    s->last_pause_ns = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n\n    if (!s->is_none_mode) {\n\n        ret = mirror_dirty_init(s);\n\n        if (ret < 0 || block_job_is_cancelled(&s->common)) {\n\n            goto immediate_exit;\n\n        }\n\n    }\n\n\n\n    assert(!s->dbi);\n\n    s->dbi = bdrv_dirty_iter_new(s->dirty_bitmap, 0);\n\n    for (;;) {\n\n        uint64_t delay_ns = 0;\n\n        int64_t cnt, delta;\n\n        bool should_complete;\n\n\n\n        if (s->ret < 0) {\n\n            ret = s->ret;\n\n            goto immediate_exit;\n\n        }\n\n\n\n        block_job_pause_point(&s->common);\n\n\n\n        cnt = bdrv_get_dirty_count(s->dirty_bitmap);\n\n        /* s->common.offset contains the number of bytes already processed so\n\n         * far, cnt is the number of dirty sectors remaining and\n\n         * s->sectors_in_flight is the number of sectors currently being\n\n         * processed; together those are the current total operation length */\n\n        s->common.len = s->common.offset +\n\n                        (cnt + s->sectors_in_flight) * BDRV_SECTOR_SIZE;\n\n\n\n        /* Note that even when no rate limit is applied we need to yield\n\n         * periodically with no pending I/O so that bdrv_drain_all() returns.\n\n         * We do so every SLICE_TIME nanoseconds, or when there is an error,\n\n         * or when the source is clean, whichever comes first.\n\n         */\n\n        delta = qemu_clock_get_ns(QEMU_CLOCK_REALTIME) - s->last_pause_ns;\n\n        if (delta < SLICE_TIME &&\n\n            s->common.iostatus == BLOCK_DEVICE_IO_STATUS_OK) {\n\n            if (s->in_flight >= MAX_IN_FLIGHT || s->buf_free_count == 0 ||\n\n                (cnt == 0 && s->in_flight > 0)) {\n\n                trace_mirror_yield(s, s->in_flight, s->buf_free_count, cnt);\n\n                mirror_wait_for_io(s);\n\n                continue;\n\n            } else if (cnt != 0) {\n\n                delay_ns = mirror_iteration(s);\n\n            }\n\n        }\n\n\n\n        should_complete = false;\n\n        if (s->in_flight == 0 && cnt == 0) {\n\n            trace_mirror_before_flush(s);\n\n            ret = blk_flush(s->target);\n\n            if (ret < 0) {\n\n                if (mirror_error_action(s, false, -ret) ==\n\n                    BLOCK_ERROR_ACTION_REPORT) {\n\n                    goto immediate_exit;\n\n                }\n\n            } else {\n\n                /* We're out of the streaming phase.  From now on, if the job\n\n                 * is cancelled we will actually complete all pending I/O and\n\n                 * report completion.  This way, block-job-cancel will leave\n\n                 * the target in a consistent state.\n\n                 */\n\n                if (!s->synced) {\n\n                    block_job_event_ready(&s->common);\n\n                    s->synced = true;\n\n                }\n\n\n\n                should_complete = s->should_complete ||\n\n                    block_job_is_cancelled(&s->common);\n\n                cnt = bdrv_get_dirty_count(s->dirty_bitmap);\n\n            }\n\n        }\n\n\n\n        if (cnt == 0 && should_complete) {\n\n            /* The dirty bitmap is not updated while operations are pending.\n\n             * If we're about to exit, wait for pending operations before\n\n             * calling bdrv_get_dirty_count(bs), or we may exit while the\n\n             * source has dirty data to copy!\n\n             *\n\n             * Note that I/O can be submitted by the guest while\n\n             * mirror_populate runs.\n\n             */\n\n            trace_mirror_before_drain(s, cnt);\n\n            bdrv_co_drain(bs);\n\n            cnt = bdrv_get_dirty_count(s->dirty_bitmap);\n\n        }\n\n\n\n        ret = 0;\n\n        trace_mirror_before_sleep(s, cnt, s->synced, delay_ns);\n\n        if (!s->synced) {\n\n            block_job_sleep_ns(&s->common, QEMU_CLOCK_REALTIME, delay_ns);\n\n            if (block_job_is_cancelled(&s->common)) {\n\n                break;\n\n            }\n\n        } else if (!should_complete) {\n\n            delay_ns = (s->in_flight == 0 && cnt == 0 ? SLICE_TIME : 0);\n\n            block_job_sleep_ns(&s->common, QEMU_CLOCK_REALTIME, delay_ns);\n\n        } else if (cnt == 0) {\n\n            /* The two disks are in sync.  Exit and report successful\n\n             * completion.\n\n             */\n\n            assert(QLIST_EMPTY(&bs->tracked_requests));\n\n            s->common.cancelled = false;\n\n            break;\n\n        }\n\n        s->last_pause_ns = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n\n    }\n\n\n\nimmediate_exit:\n\n    if (s->in_flight > 0) {\n\n        /* We get here only if something went wrong.  Either the job failed,\n\n         * or it was cancelled prematurely so that we do not guarantee that\n\n         * the target is a copy of the source.\n\n         */\n\n        assert(ret < 0 || (!s->synced && block_job_is_cancelled(&s->common)));\n\n        mirror_drain(s);\n\n    }\n\n\n\n    assert(s->in_flight == 0);\n\n    qemu_vfree(s->buf);\n\n    g_free(s->cow_bitmap);\n\n    g_free(s->in_flight_bitmap);\n\n    bdrv_dirty_iter_free(s->dbi);\n\n    bdrv_release_dirty_bitmap(bs, s->dirty_bitmap);\n\n\n\n    data = g_malloc(sizeof(*data));\n\n    data->ret = ret;\n\n    /* Before we switch to target in mirror_exit, make sure data doesn't\n\n     * change. */\n\n    bdrv_drained_begin(bs);\n\n    block_job_defer_to_main_loop(&s->common, mirror_exit, data);\n\n}\n", "idx": 23134}
{"project": "qemu", "commit_id": "9005b2a7589540a3733b3abdcfbccfe7746cd1a1", "target": 0, "func": "static int pty_chr_write(CharDriverState *chr, const uint8_t *buf, int len)\n\n{\n\n    PtyCharDriver *s = chr->opaque;\n\n\n\n    if (!s->connected) {\n\n        /* guest sends data, check for (re-)connect */\n\n        pty_chr_update_read_handler(chr);\n\n        return 0;\n\n    }\n\n    return io_channel_send(s->fd, buf, len);\n\n}\n", "idx": 23135}
{"project": "qemu", "commit_id": "0aa7a205c899c516d906673efbe9457f7af0dd3c", "target": 0, "func": "int check_params(const char * const *params, const char *str)\n\n{\n\n    int name_buf_size = 1;\n\n    const char *p;\n\n    char *name_buf;\n\n    int i, len;\n\n    int ret = 0;\n\n\n\n    for (i = 0; params[i] != NULL; i++) {\n\n        len = strlen(params[i]) + 1;\n\n        if (len > name_buf_size) {\n\n            name_buf_size = len;\n\n        }\n\n    }\n\n    name_buf = qemu_malloc(name_buf_size);\n\n\n\n    p = str;\n\n    while (*p != '\\0') {\n\n        p = get_opt_name(name_buf, name_buf_size, p, '=');\n\n        if (*p != '=') {\n\n            ret = -1;\n\n            break;\n\n        }\n\n        p++;\n\n        for(i = 0; params[i] != NULL; i++)\n\n            if (!strcmp(params[i], name_buf))\n\n                break;\n\n        if (params[i] == NULL) {\n\n            ret = -1;\n\n            break;\n\n        }\n\n        p = get_opt_value(NULL, 0, p);\n\n        if (*p != ',')\n\n            break;\n\n        p++;\n\n    }\n\n\n\n    qemu_free(name_buf);\n\n    return ret;\n\n}\n", "idx": 23137}
{"project": "qemu", "commit_id": "cfaadf0e89e7c2a47462d5f96390c9a9b4de037c", "target": 0, "func": "static void fw_cfg_data_mem_write(void *opaque, hwaddr addr,\n\n                                  uint64_t value, unsigned size)\n\n{\n\n    fw_cfg_write(opaque, (uint8_t)value);\n\n}\n", "idx": 23138}
{"project": "qemu", "commit_id": "9eaaf971683c99ed197fa1b7d1a3ca9baabfb3ee", "target": 0, "func": "static void simple_whitespace(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        LiteralQObject decoded;\n\n    } test_cases[] = {\n\n        {\n\n            .encoded = \" [ 43 , 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \" [ 43 , { 'h' : 'b' }, [ ], 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n\n                                    { \"h\", QLIT_QSTR(\"b\") },\n\n                                    { }})),\n\n                        QLIT_QLIST(((LiteralQObject[]){\n\n                                    { }})),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \" [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n\n                                    { \"h\", QLIT_QSTR(\"b\") },\n\n                                    { \"a\", QLIT_QINT(32) },\n\n                                    { }})),\n\n                        QLIT_QLIST(((LiteralQObject[]){\n\n                                    { }})),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        { }\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_json(test_cases[i].encoded);\n\n        g_assert(obj != NULL);\n\n        g_assert(qobject_type(obj) == QTYPE_QLIST);\n\n\n\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n\n\n        str = qobject_to_json(obj);\n\n        qobject_decref(obj);\n\n\n\n        obj = qobject_from_json(qstring_get_str(str));\n\n        g_assert(obj != NULL);\n\n        g_assert(qobject_type(obj) == QTYPE_QLIST);\n\n\n\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n\n\n        qobject_decref(obj);\n\n        QDECREF(str);\n\n    }\n\n}\n", "idx": 23139}
{"project": "qemu", "commit_id": "cb2e28780c7080af489e72227683fe374f05022d", "target": 0, "func": "static int coroutine_fn bdrv_co_do_copy_on_readv(BdrvChild *child,\n\n        int64_t offset, unsigned int bytes, QEMUIOVector *qiov)\n\n{\n\n    BlockDriverState *bs = child->bs;\n\n\n\n    /* Perform I/O through a temporary buffer so that users who scribble over\n\n     * their read buffer while the operation is in progress do not end up\n\n     * modifying the image file.  This is critical for zero-copy guest I/O\n\n     * where anything might happen inside guest memory.\n\n     */\n\n    void *bounce_buffer;\n\n\n\n    BlockDriver *drv = bs->drv;\n\n    struct iovec iov;\n\n    QEMUIOVector bounce_qiov;\n\n    int64_t cluster_offset;\n\n    unsigned int cluster_bytes;\n\n    size_t skip_bytes;\n\n    int ret;\n\n\n\n    /* FIXME We cannot require callers to have write permissions when all they\n\n     * are doing is a read request. If we did things right, write permissions\n\n     * would be obtained anyway, but internally by the copy-on-read code. As\n\n     * long as it is implemented here rather than in a separate filter driver,\n\n     * the copy-on-read code doesn't have its own BdrvChild, however, for which\n\n     * it could request permissions. Therefore we have to bypass the permission\n\n     * system for the moment. */\n\n    // assert(child->perm & (BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE));\n\n\n\n    /* Cover entire cluster so no additional backing file I/O is required when\n\n     * allocating cluster in the image file.\n\n     */\n\n    bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes);\n\n\n\n    trace_bdrv_co_do_copy_on_readv(bs, offset, bytes,\n\n                                   cluster_offset, cluster_bytes);\n\n\n\n    iov.iov_len = cluster_bytes;\n\n    iov.iov_base = bounce_buffer = qemu_try_blockalign(bs, iov.iov_len);\n\n    if (bounce_buffer == NULL) {\n\n        ret = -ENOMEM;\n\n        goto err;\n\n    }\n\n\n\n    qemu_iovec_init_external(&bounce_qiov, &iov, 1);\n\n\n\n    ret = bdrv_driver_preadv(bs, cluster_offset, cluster_bytes,\n\n                             &bounce_qiov, 0);\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    bdrv_debug_event(bs, BLKDBG_COR_WRITE);\n\n    if (drv->bdrv_co_pwrite_zeroes &&\n\n        buffer_is_zero(bounce_buffer, iov.iov_len)) {\n\n        /* FIXME: Should we (perhaps conditionally) be setting\n\n         * BDRV_REQ_MAY_UNMAP, if it will allow for a sparser copy\n\n         * that still correctly reads as zero? */\n\n        ret = bdrv_co_do_pwrite_zeroes(bs, cluster_offset, cluster_bytes, 0);\n\n    } else {\n\n        /* This does not change the data on the disk, it is not necessary\n\n         * to flush even in cache=writethrough mode.\n\n         */\n\n        ret = bdrv_driver_pwritev(bs, cluster_offset, cluster_bytes,\n\n                                  &bounce_qiov, 0);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        /* It might be okay to ignore write errors for guest requests.  If this\n\n         * is a deliberate copy-on-read then we don't want to ignore the error.\n\n         * Simply report it in all cases.\n\n         */\n\n        goto err;\n\n    }\n\n\n\n    skip_bytes = offset - cluster_offset;\n\n    qemu_iovec_from_buf(qiov, 0, bounce_buffer + skip_bytes, bytes);\n\n\n\nerr:\n\n    qemu_vfree(bounce_buffer);\n\n    return ret;\n\n}\n", "idx": 23140}
{"project": "qemu", "commit_id": "e4533c7a8cdcc79ccdf695f0aaa2e23a5b926ed0", "target": 0, "func": "void cpu_x86_fsave(CPUX86State *s, uint8_t *ptr, int data32)\n\n{\n\n    CPUX86State *saved_env;\n\n\n\n    saved_env = env;\n\n    env = s;\n\n    \n\n    helper_fsave(ptr, data32);\n\n\n\n    env = saved_env;\n\n}\n", "idx": 23141}
{"project": "qemu", "commit_id": "3d002df33eb034757d98e1ae529318f57df78f91", "target": 0, "func": "int do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    int64_t d;\n\n    FdMigrationState *s;\n\n\n\n    d = qdict_get_int(qdict, \"value\");\n\n    d = MAX(0, MIN(UINT32_MAX, d));\n\n    max_throttle = d;\n\n\n\n    s = migrate_to_fms(current_migration);\n\n    if (s && s->file) {\n\n        qemu_file_set_rate_limit(s->file, max_throttle);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23142}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int proxy_renameat(FsContext *ctx, V9fsPath *olddir,\n\n                          const char *old_name, V9fsPath *newdir,\n\n                          const char *new_name)\n\n{\n\n    int ret;\n\n    V9fsString old_full_name, new_full_name;\n\n\n\n    v9fs_string_init(&old_full_name);\n\n    v9fs_string_init(&new_full_name);\n\n\n\n    v9fs_string_sprintf(&old_full_name, \"%s/%s\", olddir->data, old_name);\n\n    v9fs_string_sprintf(&new_full_name, \"%s/%s\", newdir->data, new_name);\n\n\n\n    ret = proxy_rename(ctx, old_full_name.data, new_full_name.data);\n\n    v9fs_string_free(&old_full_name);\n\n    v9fs_string_free(&new_full_name);\n\n    return ret;\n\n}\n", "idx": 23143}
{"project": "qemu", "commit_id": "616cbc78a50c638b94cc4756a565f11bb10dbfeb", "target": 0, "func": "PCIBus *pci_register_bus(DeviceState *parent, const char *name,\n\n                         pci_set_irq_fn set_irq, pci_map_irq_fn map_irq,\n\n                         qemu_irq *pic, int devfn_min, int nirq)\n\n{\n\n    PCIBus *bus;\n\n    static int nbus = 0;\n\n\n\n    bus = FROM_QBUS(PCIBus, qbus_create(&pci_bus_info, parent, name));\n\n    bus->set_irq = set_irq;\n\n    bus->map_irq = map_irq;\n\n    bus->irq_opaque = pic;\n\n    bus->devfn_min = devfn_min;\n\n    bus->nirq = nirq;\n\n    bus->irq_count = qemu_malloc(nirq * sizeof(bus->irq_count[0]));\n\n    bus->next = first_bus;\n\n    first_bus = bus;\n\n    register_savevm(\"PCIBUS\", nbus++, 1, pcibus_save, pcibus_load, bus);\n\n    qemu_register_reset(pci_bus_reset, bus);\n\n    return bus;\n\n}\n", "idx": 23144}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "int kvm_ioctl(KVMState *s, int type, ...)\n\n{\n\n    int ret;\n\n    void *arg;\n\n    va_list ap;\n\n\n\n    va_start(ap, type);\n\n    arg = va_arg(ap, void *);\n\n    va_end(ap);\n\n\n\n    ret = ioctl(s->fd, type, arg);\n\n    if (ret == -1)\n\n        ret = -errno;\n\n\n\n    return ret;\n\n}\n", "idx": 23145}
{"project": "qemu", "commit_id": "63ae0915f8ec9746d17a25c27f64cf65550627ab", "target": 0, "func": "static void gen_rlwimi(DisasContext *ctx)\n\n{\n\n    uint32_t mb, me, sh;\n\n\n\n    mb = MB(ctx->opcode);\n\n    me = ME(ctx->opcode);\n\n    sh = SH(ctx->opcode);\n\n    if (likely(sh == (31-me) && mb <= me)) {\n\n        tcg_gen_deposit_tl(cpu_gpr[rA(ctx->opcode)], cpu_gpr[rA(ctx->opcode)],\n\n                           cpu_gpr[rS(ctx->opcode)], sh, me - mb + 1);\n\n    } else {\n\n        target_ulong mask;\n\n        TCGv t1;\n\n        TCGv t0 = tcg_temp_new();\n\n#if defined(TARGET_PPC64)\n\n        tcg_gen_deposit_i64(t0, cpu_gpr[rS(ctx->opcode)],\n\n            cpu_gpr[rS(ctx->opcode)], 32, 32);\n\n        tcg_gen_rotli_i64(t0, t0, sh);\n\n#else\n\n        tcg_gen_rotli_i32(t0, cpu_gpr[rS(ctx->opcode)], sh);\n\n#endif\n\n#if defined(TARGET_PPC64)\n\n        mb += 32;\n\n        me += 32;\n\n#endif\n\n        mask = MASK(mb, me);\n\n        t1 = tcg_temp_new();\n\n        tcg_gen_andi_tl(t0, t0, mask);\n\n        tcg_gen_andi_tl(t1, cpu_gpr[rA(ctx->opcode)], ~mask);\n\n        tcg_gen_or_tl(cpu_gpr[rA(ctx->opcode)], t0, t1);\n\n        tcg_temp_free(t0);\n\n        tcg_temp_free(t1);\n\n    }\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]);\n\n}\n", "idx": 23146}
{"project": "qemu", "commit_id": "95b134ea02a3e2c2508f907db4ab1379ffdb0bef", "target": 0, "func": "ssize_t migrate_fd_put_buffer(void *opaque, const void *data, size_t size)\n\n{\n\n    FdMigrationState *s = opaque;\n\n    ssize_t ret;\n\n\n\n    do {\n\n        ret = s->write(s, data, size);\n\n    } while (ret == -1 && ((s->get_error(s)) == EINTR || (s->get_error(s)) == EWOULDBLOCK));\n\n\n\n    if (ret == -1)\n\n        ret = -(s->get_error(s));\n\n\n\n    if (ret == -EAGAIN)\n\n        qemu_set_fd_handler2(s->fd, NULL, NULL, migrate_fd_put_notify, s);\n\n\n\n    return ret;\n\n}\n", "idx": 23148}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void apic_mem_writel(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    DeviceState *d;\n\n    APICCommonState *s;\n\n    int index = (addr >> 4) & 0xff;\n\n    if (addr > 0xfff || !index) {\n\n        /* MSI and MMIO APIC are at the same memory location,\n\n         * but actually not on the global bus: MSI is on PCI bus\n\n         * APIC is connected directly to the CPU.\n\n         * Mapping them on the global bus happens to work because\n\n         * MSI registers are reserved in APIC MMIO and vice versa. */\n\n        apic_send_msi(addr, val);\n\n        return;\n\n    }\n\n\n\n    d = cpu_get_current_apic();\n\n    if (!d) {\n\n        return;\n\n    }\n\n    s = DO_UPCAST(APICCommonState, busdev.qdev, d);\n\n\n\n    trace_apic_mem_writel(addr, val);\n\n\n\n    switch(index) {\n\n    case 0x02:\n\n        s->id = (val >> 24);\n\n        break;\n\n    case 0x03:\n\n        break;\n\n    case 0x08:\n\n        if (apic_report_tpr_access) {\n\n            cpu_report_tpr_access(s->cpu_env, TPR_ACCESS_WRITE);\n\n        }\n\n        s->tpr = val;\n\n        apic_sync_vapic(s, SYNC_TO_VAPIC);\n\n        apic_update_irq(s);\n\n        break;\n\n    case 0x09:\n\n    case 0x0a:\n\n        break;\n\n    case 0x0b: /* EOI */\n\n        apic_eoi(s);\n\n        break;\n\n    case 0x0d:\n\n        s->log_dest = val >> 24;\n\n        break;\n\n    case 0x0e:\n\n        s->dest_mode = val >> 28;\n\n        break;\n\n    case 0x0f:\n\n        s->spurious_vec = val & 0x1ff;\n\n        apic_update_irq(s);\n\n        break;\n\n    case 0x10 ... 0x17:\n\n    case 0x18 ... 0x1f:\n\n    case 0x20 ... 0x27:\n\n    case 0x28:\n\n        break;\n\n    case 0x30:\n\n        s->icr[0] = val;\n\n        apic_deliver(d, (s->icr[1] >> 24) & 0xff, (s->icr[0] >> 11) & 1,\n\n                     (s->icr[0] >> 8) & 7, (s->icr[0] & 0xff),\n\n                     (s->icr[0] >> 15) & 1);\n\n        break;\n\n    case 0x31:\n\n        s->icr[1] = val;\n\n        break;\n\n    case 0x32 ... 0x37:\n\n        {\n\n            int n = index - 0x32;\n\n            s->lvt[n] = val;\n\n            if (n == APIC_LVT_TIMER) {\n\n                apic_timer_update(s, qemu_get_clock_ns(vm_clock));\n\n            } else if (n == APIC_LVT_LINT0 && apic_check_pic(s)) {\n\n                apic_update_irq(s);\n\n            }\n\n        }\n\n        break;\n\n    case 0x38:\n\n        s->initial_count = val;\n\n        s->initial_count_load_time = qemu_get_clock_ns(vm_clock);\n\n        apic_timer_update(s, s->initial_count_load_time);\n\n        break;\n\n    case 0x39:\n\n        break;\n\n    case 0x3e:\n\n        {\n\n            int v;\n\n            s->divide_conf = val & 0xb;\n\n            v = (s->divide_conf & 3) | ((s->divide_conf >> 1) & 4);\n\n            s->count_shift = (v + 1) & 7;\n\n        }\n\n        break;\n\n    default:\n\n        s->esr |= ESR_ILLEGAL_ADDRESS;\n\n        break;\n\n    }\n\n}\n", "idx": 23149}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static void pxa2xx_gpio_set(void *opaque, int line, int level)\n\n{\n\n    PXA2xxGPIOInfo *s = (PXA2xxGPIOInfo *) opaque;\n\n    CPUState *cpu = CPU(s->cpu);\n\n    int bank;\n\n    uint32_t mask;\n\n\n\n    if (line >= s->lines) {\n\n        printf(\"%s: No GPIO pin %i\\n\", __FUNCTION__, line);\n\n        return;\n\n    }\n\n\n\n    bank = line >> 5;\n\n    mask = 1U << (line & 31);\n\n\n\n    if (level) {\n\n        s->status[bank] |= s->rising[bank] & mask &\n\n                ~s->ilevel[bank] & ~s->dir[bank];\n\n        s->ilevel[bank] |= mask;\n\n    } else {\n\n        s->status[bank] |= s->falling[bank] & mask &\n\n                s->ilevel[bank] & ~s->dir[bank];\n\n        s->ilevel[bank] &= ~mask;\n\n    }\n\n\n\n    if (s->status[bank] & mask)\n\n        pxa2xx_gpio_irq_update(s);\n\n\n\n    /* Wake-up GPIOs */\n\n    if (cpu->halted && (mask & ~s->dir[bank] & pxa2xx_gpio_wake[bank])) {\n\n        cpu_interrupt(cpu, CPU_INTERRUPT_EXITTB);\n\n    }\n\n}\n", "idx": 23150}
{"project": "qemu", "commit_id": "6b37c87c96a5b148685e8e6bf09d0aca953cb1a8", "target": 0, "func": "int vhost_net_start(struct vhost_net *net,\n\n                    VirtIODevice *dev)\n\n{\n\n    struct vhost_vring_file file = { };\n\n    int r;\n\n    if (net->dev.acked_features & (1 << VIRTIO_NET_F_MRG_RXBUF)) {\n\n        tap_set_vnet_hdr_len(net->vc,\n\n                             sizeof(struct virtio_net_hdr_mrg_rxbuf));\n\n    }\n\n\n\n    net->dev.nvqs = 2;\n\n    net->dev.vqs = net->vqs;\n\n    r = vhost_dev_start(&net->dev, dev);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    net->vc->info->poll(net->vc, false);\n\n    qemu_set_fd_handler(net->backend, NULL, NULL, NULL);\n\n    file.fd = net->backend;\n\n    for (file.index = 0; file.index < net->dev.nvqs; ++file.index) {\n\n        r = ioctl(net->dev.control, VHOST_NET_SET_BACKEND, &file);\n\n        if (r < 0) {\n\n            r = -errno;\n\n            goto fail;\n\n        }\n\n    }\n\n    return 0;\n\nfail:\n\n    file.fd = -1;\n\n    while (--file.index >= 0) {\n\n        int r = ioctl(net->dev.control, VHOST_NET_SET_BACKEND, &file);\n\n        assert(r >= 0);\n\n    }\n\n    net->vc->info->poll(net->vc, true);\n\n    vhost_dev_stop(&net->dev, dev);\n\n    if (net->dev.acked_features & (1 << VIRTIO_NET_F_MRG_RXBUF)) {\n\n        tap_set_vnet_hdr_len(net->vc, sizeof(struct virtio_net_hdr));\n\n    }\n\n    return r;\n\n}\n", "idx": 23151}
{"project": "qemu", "commit_id": "98522f63f40adaebc412481e1d2e9170160d4539", "target": 0, "func": "static int iscsi_create(const char *filename, QEMUOptionParameter *options,\n\n                        Error **errp)\n\n{\n\n    int ret = 0;\n\n    int64_t total_size = 0;\n\n    BlockDriverState *bs;\n\n    IscsiLun *iscsilun = NULL;\n\n    QDict *bs_options;\n\n\n\n    bs = bdrv_new(\"\");\n\n\n\n    /* Read out options */\n\n    while (options && options->name) {\n\n        if (!strcmp(options->name, \"size\")) {\n\n            total_size = options->value.n / BDRV_SECTOR_SIZE;\n\n        }\n\n        options++;\n\n    }\n\n\n\n    bs->opaque = g_malloc0(sizeof(struct IscsiLun));\n\n    iscsilun = bs->opaque;\n\n\n\n    bs_options = qdict_new();\n\n    qdict_put(bs_options, \"filename\", qstring_from_str(filename));\n\n    ret = iscsi_open(bs, bs_options, 0, NULL);\n\n    QDECREF(bs_options);\n\n\n\n    if (ret != 0) {\n\n        goto out;\n\n    }\n\n    if (iscsilun->nop_timer) {\n\n        timer_del(iscsilun->nop_timer);\n\n        timer_free(iscsilun->nop_timer);\n\n    }\n\n    if (iscsilun->type != TYPE_DISK) {\n\n        ret = -ENODEV;\n\n        goto out;\n\n    }\n\n    if (bs->total_sectors < total_size) {\n\n        ret = -ENOSPC;\n\n        goto out;\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    if (iscsilun->iscsi != NULL) {\n\n        iscsi_destroy_context(iscsilun->iscsi);\n\n    }\n\n    g_free(bs->opaque);\n\n    bs->opaque = NULL;\n\n    bdrv_unref(bs);\n\n    return ret;\n\n}\n", "idx": 23152}
{"project": "qemu", "commit_id": "e45da653223869849877ee8f4b86f511f891d4f8", "target": 0, "func": "static void virtio_init_region_cache(VirtIODevice *vdev, int n)\n\n{\n\n    VirtQueue *vq = &vdev->vq[n];\n\n    VRingMemoryRegionCaches *old = vq->vring.caches;\n\n    VRingMemoryRegionCaches *new;\n\n    hwaddr addr, size;\n\n    int event_size;\n\n\n\n    event_size = virtio_vdev_has_feature(vq->vdev, VIRTIO_RING_F_EVENT_IDX) ? 2 : 0;\n\n\n\n    addr = vq->vring.desc;\n\n    if (!addr) {\n\n        return;\n\n    }\n\n    new = g_new0(VRingMemoryRegionCaches, 1);\n\n    size = virtio_queue_get_desc_size(vdev, n);\n\n    address_space_cache_init(&new->desc, vdev->dma_as,\n\n                             addr, size, false);\n\n\n\n    size = virtio_queue_get_used_size(vdev, n) + event_size;\n\n    address_space_cache_init(&new->used, vdev->dma_as,\n\n                             vq->vring.used, size, true);\n\n\n\n    size = virtio_queue_get_avail_size(vdev, n) + event_size;\n\n    address_space_cache_init(&new->avail, vdev->dma_as,\n\n                             vq->vring.avail, size, false);\n\n\n\n    atomic_rcu_set(&vq->vring.caches, new);\n\n    if (old) {\n\n        call_rcu(old, virtio_free_region_cache, rcu);\n\n    }\n\n}\n", "idx": 23153}
{"project": "qemu", "commit_id": "b5cd9143e78da8ea9e17fa523aacbedd267aae54", "target": 0, "func": "static void xilinx_spips_realize(DeviceState *dev, Error **errp)\n\n{\n\n    XilinxSPIPS *s = XILINX_SPIPS(dev);\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);\n\n    XilinxSPIPSClass *xsc = XILINX_SPIPS_GET_CLASS(s);\n\n    int i;\n\n\n\n    DB_PRINT(\"realized spips\\n\");\n\n\n\n    s->spi = g_new(SSIBus *, s->num_busses);\n\n    for (i = 0; i < s->num_busses; ++i) {\n\n        char bus_name[16];\n\n        snprintf(bus_name, 16, \"spi%d\", i);\n\n        s->spi[i] = ssi_create_bus(dev, bus_name);\n\n    }\n\n\n\n    s->cs_lines = g_new0(qemu_irq, s->num_cs * s->num_busses);\n\n    ssi_auto_connect_slaves(DEVICE(s), s->cs_lines, s->spi[0]);\n\n    ssi_auto_connect_slaves(DEVICE(s), s->cs_lines, s->spi[1]);\n\n    sysbus_init_irq(sbd, &s->irq);\n\n    for (i = 0; i < s->num_cs * s->num_busses; ++i) {\n\n        sysbus_init_irq(sbd, &s->cs_lines[i]);\n\n    }\n\n\n\n    memory_region_init_io(&s->iomem, &spips_ops, s, \"spi\", R_MAX*4);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n\n\n\n    s->irqline = -1;\n\n\n\n    fifo8_create(&s->rx_fifo, xsc->rx_fifo_size);\n\n    fifo8_create(&s->tx_fifo, xsc->tx_fifo_size);\n\n}\n", "idx": 23154}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t exynos4210_mct_read(void *opaque, target_phys_addr_t offset,\n\n        unsigned size)\n\n{\n\n    Exynos4210MCTState *s = (Exynos4210MCTState *)opaque;\n\n    int index;\n\n    int shift;\n\n    uint64_t count;\n\n    uint32_t value;\n\n    int lt_i;\n\n\n\n    switch (offset) {\n\n\n\n    case MCT_CFG:\n\n        value = s->reg_mct_cfg;\n\n        break;\n\n\n\n    case G_CNT_L: case G_CNT_U:\n\n        shift = 8 * (offset & 0x4);\n\n        count = exynos4210_gfrc_get_count(&s->g_timer);\n\n        value = UINT32_MAX & (count >> shift);\n\n        DPRINTF(\"read FRC=0x%llx\\n\", count);\n\n        break;\n\n\n\n    case G_CNT_WSTAT:\n\n        value = s->g_timer.reg.cnt_wstat;\n\n        break;\n\n\n\n    case G_COMP_L(0): case G_COMP_L(1): case G_COMP_L(2): case G_COMP_L(3):\n\n    case G_COMP_U(0): case G_COMP_U(1): case G_COMP_U(2): case G_COMP_U(3):\n\n    index = GET_G_COMP_IDX(offset);\n\n    shift = 8 * (offset & 0x4);\n\n    value = UINT32_MAX & (s->g_timer.reg.comp[index] >> shift);\n\n    break;\n\n\n\n    case G_TCON:\n\n        value = s->g_timer.reg.tcon;\n\n        break;\n\n\n\n    case G_INT_CSTAT:\n\n        value = s->g_timer.reg.int_cstat;\n\n        break;\n\n\n\n    case G_INT_ENB:\n\n        value = s->g_timer.reg.int_enb;\n\n        break;\n\n        break;\n\n    case G_WSTAT:\n\n        value = s->g_timer.reg.wstat;\n\n        break;\n\n\n\n    case G_COMP0_ADD_INCR: case G_COMP1_ADD_INCR:\n\n    case G_COMP2_ADD_INCR: case G_COMP3_ADD_INCR:\n\n        value = s->g_timer.reg.comp_add_incr[GET_G_COMP_ADD_INCR_IDX(offset)];\n\n        break;\n\n\n\n        /* Local timers */\n\n    case L0_TCNTB: case L0_ICNTB: case L0_FRCNTB:\n\n    case L1_TCNTB: case L1_ICNTB: case L1_FRCNTB:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n        index = GET_L_TIMER_CNT_REG_IDX(offset, lt_i);\n\n        value = s->l_timer[lt_i].reg.cnt[index];\n\n        break;\n\n\n\n    case L0_TCNTO: case L1_TCNTO:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n\n\n        value = exynos4210_ltick_cnt_get_cnto(&s->l_timer[lt_i].tick_timer);\n\n        DPRINTF(\"local timer[%d] read TCNTO %x\\n\", lt_i, value);\n\n        break;\n\n\n\n    case L0_ICNTO: case L1_ICNTO:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n\n\n        value = exynos4210_ltick_int_get_cnto(&s->l_timer[lt_i].tick_timer);\n\n        DPRINTF(\"local timer[%d] read ICNTO %x\\n\", lt_i, value);\n\n        break;\n\n\n\n    case L0_FRCNTO: case L1_FRCNTO:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n\n\n        value = exynos4210_lfrc_get_count(&s->l_timer[lt_i]);\n\n\n\n        break;\n\n\n\n    case L0_TCON: case L1_TCON:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.tcon;\n\n        break;\n\n\n\n    case L0_INT_CSTAT: case L1_INT_CSTAT:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.int_cstat;\n\n        break;\n\n\n\n    case L0_INT_ENB: case L1_INT_ENB:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.int_enb;\n\n        break;\n\n\n\n    case L0_WSTAT: case L1_WSTAT:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.wstat;\n\n        break;\n\n\n\n    default:\n\n        hw_error(\"exynos4210.mct: bad read offset \"\n\n                TARGET_FMT_plx \"\\n\", offset);\n\n        break;\n\n    }\n\n    return value;\n\n}\n", "idx": 23155}
{"project": "qemu", "commit_id": "71407786054cad26de7ef66718b2a57a4bcb49b5", "target": 1, "func": "static bool virtio_scsi_data_plane_handle_event(VirtIODevice *vdev,\n\n                                                VirtQueue *vq)\n\n{\n\n    VirtIOSCSI *s = VIRTIO_SCSI(vdev);\n\n\n\n    assert(s->ctx && s->dataplane_started);\n\n    return virtio_scsi_handle_event_vq(s, vq);\n\n}\n", "idx": 23158}
{"project": "qemu", "commit_id": "d9f62dde1303286b24ac8ce88be27e2b9b9c5f46", "target": 0, "func": "opts_next_list(Visitor *v, GenericList **list, size_t size)\n\n{\n\n    OptsVisitor *ov = to_ov(v);\n\n    GenericList **link;\n\n\n\n    switch (ov->list_mode) {\n\n    case LM_STARTED:\n\n        ov->list_mode = LM_IN_PROGRESS;\n\n        link = list;\n\n        break;\n\n\n\n    case LM_SIGNED_INTERVAL:\n\n    case LM_UNSIGNED_INTERVAL:\n\n        link = &(*list)->next;\n\n\n\n        if (ov->list_mode == LM_SIGNED_INTERVAL) {\n\n            if (ov->range_next.s < ov->range_limit.s) {\n\n                ++ov->range_next.s;\n\n                break;\n\n            }\n\n        } else if (ov->range_next.u < ov->range_limit.u) {\n\n            ++ov->range_next.u;\n\n            break;\n\n        }\n\n        ov->list_mode = LM_IN_PROGRESS;\n\n        /* range has been completed, fall through in order to pop option */\n\n\n\n    case LM_IN_PROGRESS: {\n\n        const QemuOpt *opt;\n\n\n\n        opt = g_queue_pop_head(ov->repeated_opts);\n\n        if (g_queue_is_empty(ov->repeated_opts)) {\n\n            g_hash_table_remove(ov->unprocessed_opts, opt->name);\n\n            return NULL;\n\n        }\n\n        link = &(*list)->next;\n\n        break;\n\n    }\n\n\n\n    default:\n\n        abort();\n\n    }\n\n\n\n    *link = g_malloc0(size);\n\n    return *link;\n\n}\n", "idx": 23162}
{"project": "qemu", "commit_id": "3a5c76baf312d83cb77c8faa72c5f7a477effed0", "target": 0, "func": "static FWCfgState *bochs_bios_init(void)\n\n{\n\n    FWCfgState *fw_cfg;\n\n    uint8_t *smbios_tables, *smbios_anchor;\n\n    size_t smbios_tables_len, smbios_anchor_len;\n\n    uint64_t *numa_fw_cfg;\n\n    int i, j;\n\n    unsigned int apic_id_limit = pc_apic_id_limit(max_cpus);\n\n\n\n    fw_cfg = fw_cfg_init_io(BIOS_CFG_IOPORT);\n\n    /* FW_CFG_MAX_CPUS is a bit confusing/problematic on x86:\n\n     *\n\n     * SeaBIOS needs FW_CFG_MAX_CPUS for CPU hotplug, but the CPU hotplug\n\n     * QEMU<->SeaBIOS interface is not based on the \"CPU index\", but on the APIC\n\n     * ID of hotplugged CPUs[1]. This means that FW_CFG_MAX_CPUS is not the\n\n     * \"maximum number of CPUs\", but the \"limit to the APIC ID values SeaBIOS\n\n     * may see\".\n\n     *\n\n     * So, this means we must not use max_cpus, here, but the maximum possible\n\n     * APIC ID value, plus one.\n\n     *\n\n     * [1] The only kind of \"CPU identifier\" used between SeaBIOS and QEMU is\n\n     *     the APIC ID, not the \"CPU index\"\n\n     */\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MAX_CPUS, (uint16_t)apic_id_limit);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_ACPI_TABLES,\n\n                     acpi_tables, acpi_tables_len);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_IRQ0_OVERRIDE, kvm_allows_irq0_override());\n\n\n\n    smbios_tables = smbios_get_table_legacy(&smbios_tables_len);\n\n    if (smbios_tables) {\n\n        fw_cfg_add_bytes(fw_cfg, FW_CFG_SMBIOS_ENTRIES,\n\n                         smbios_tables, smbios_tables_len);\n\n    }\n\n\n\n    smbios_get_tables(&smbios_tables, &smbios_tables_len,\n\n                      &smbios_anchor, &smbios_anchor_len);\n\n    if (smbios_anchor) {\n\n        fw_cfg_add_file(fw_cfg, \"etc/smbios/smbios-tables\",\n\n                        smbios_tables, smbios_tables_len);\n\n        fw_cfg_add_file(fw_cfg, \"etc/smbios/smbios-anchor\",\n\n                        smbios_anchor, smbios_anchor_len);\n\n    }\n\n\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_E820_TABLE,\n\n                     &e820_reserve, sizeof(e820_reserve));\n\n    fw_cfg_add_file(fw_cfg, \"etc/e820\", e820_table,\n\n                    sizeof(struct e820_entry) * e820_entries);\n\n\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_HPET, &hpet_cfg, sizeof(hpet_cfg));\n\n    /* allocate memory for the NUMA channel: one (64bit) word for the number\n\n     * of nodes, one word for each VCPU->node and one word for each node to\n\n     * hold the amount of memory.\n\n     */\n\n    numa_fw_cfg = g_new0(uint64_t, 1 + apic_id_limit + nb_numa_nodes);\n\n    numa_fw_cfg[0] = cpu_to_le64(nb_numa_nodes);\n\n    for (i = 0; i < max_cpus; i++) {\n\n        unsigned int apic_id = x86_cpu_apic_id_from_index(i);\n\n        assert(apic_id < apic_id_limit);\n\n        for (j = 0; j < nb_numa_nodes; j++) {\n\n            if (test_bit(i, numa_info[j].node_cpu)) {\n\n                numa_fw_cfg[apic_id + 1] = cpu_to_le64(j);\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    for (i = 0; i < nb_numa_nodes; i++) {\n\n        numa_fw_cfg[apic_id_limit + 1 + i] = cpu_to_le64(numa_info[i].node_mem);\n\n    }\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_NUMA, numa_fw_cfg,\n\n                     (1 + apic_id_limit + nb_numa_nodes) *\n\n                     sizeof(*numa_fw_cfg));\n\n\n\n    return fw_cfg;\n\n}\n", "idx": 23163}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static int vnc_display_get_addresses(QemuOpts *opts,\n\n                                     bool reverse,\n\n                                     SocketAddress ***retsaddr,\n\n                                     size_t *retnsaddr,\n\n                                     SocketAddress ***retwsaddr,\n\n                                     size_t *retnwsaddr,\n\n                                     Error **errp)\n\n{\n\n    SocketAddress *saddr = NULL;\n\n    SocketAddress *wsaddr = NULL;\n\n    QemuOptsIter addriter;\n\n    const char *addr;\n\n    int to = qemu_opt_get_number(opts, \"to\", 0);\n\n    bool has_ipv4 = qemu_opt_get(opts, \"ipv4\");\n\n    bool has_ipv6 = qemu_opt_get(opts, \"ipv6\");\n\n    bool ipv4 = qemu_opt_get_bool(opts, \"ipv4\", false);\n\n    bool ipv6 = qemu_opt_get_bool(opts, \"ipv6\", false);\n\n    size_t i;\n\n    int displaynum = -1;\n\n    int ret = -1;\n\n\n\n    *retsaddr = NULL;\n\n    *retnsaddr = 0;\n\n    *retwsaddr = NULL;\n\n    *retnwsaddr = 0;\n\n\n\n    addr = qemu_opt_get(opts, \"vnc\");\n\n    if (addr == NULL || g_str_equal(addr, \"none\")) {\n\n        ret = 0;\n\n        goto cleanup;\n\n    }\n\n    if (qemu_opt_get(opts, \"websocket\") &&\n\n        !qcrypto_hash_supports(QCRYPTO_HASH_ALG_SHA1)) {\n\n        error_setg(errp,\n\n                   \"SHA1 hash support is required for websockets\");\n\n        goto cleanup;\n\n    }\n\n\n\n    qemu_opt_iter_init(&addriter, opts, \"vnc\");\n\n    while ((addr = qemu_opt_iter_next(&addriter)) != NULL) {\n\n        int rv;\n\n        rv = vnc_display_get_address(addr, false, reverse, 0, to,\n\n                                     has_ipv4, has_ipv6,\n\n                                     ipv4, ipv6,\n\n                                     &saddr, errp);\n\n        if (rv < 0) {\n\n            goto cleanup;\n\n        }\n\n        /* Historical compat - first listen address can be used\n\n         * to set the default websocket port\n\n         */\n\n        if (displaynum == -1) {\n\n            displaynum = rv;\n\n        }\n\n        *retsaddr = g_renew(SocketAddress *, *retsaddr, *retnsaddr + 1);\n\n        (*retsaddr)[(*retnsaddr)++] = saddr;\n\n    }\n\n\n\n    /* If we had multiple primary displays, we don't do defaults\n\n     * for websocket, and require explicit config instead. */\n\n    if (*retnsaddr > 1) {\n\n        displaynum = -1;\n\n    }\n\n\n\n    qemu_opt_iter_init(&addriter, opts, \"websocket\");\n\n    while ((addr = qemu_opt_iter_next(&addriter)) != NULL) {\n\n        if (vnc_display_get_address(addr, true, reverse, displaynum, to,\n\n                                    has_ipv4, has_ipv6,\n\n                                    ipv4, ipv6,\n\n                                    &wsaddr, errp) < 0) {\n\n            goto cleanup;\n\n        }\n\n\n\n        /* Historical compat - if only a single listen address was\n\n         * provided, then this is used to set the default listen\n\n         * address for websocket too\n\n         */\n\n        if (*retnsaddr == 1 &&\n\n            (*retsaddr)[0]->type == SOCKET_ADDRESS_KIND_INET &&\n\n            wsaddr->type == SOCKET_ADDRESS_KIND_INET &&\n\n            g_str_equal(wsaddr->u.inet.data->host, \"\") &&\n\n            !g_str_equal((*retsaddr)[0]->u.inet.data->host, \"\")) {\n\n            g_free(wsaddr->u.inet.data->host);\n\n            wsaddr->u.inet.data->host =\n\n                g_strdup((*retsaddr)[0]->u.inet.data->host);\n\n        }\n\n\n\n        *retwsaddr = g_renew(SocketAddress *, *retwsaddr, *retnwsaddr + 1);\n\n        (*retwsaddr)[(*retnwsaddr)++] = wsaddr;\n\n    }\n\n\n\n    ret = 0;\n\n cleanup:\n\n    if (ret < 0) {\n\n        for (i = 0; i < *retnsaddr; i++) {\n\n            qapi_free_SocketAddress((*retsaddr)[i]);\n\n        }\n\n        g_free(*retsaddr);\n\n        for (i = 0; i < *retnwsaddr; i++) {\n\n            qapi_free_SocketAddress((*retwsaddr)[i]);\n\n        }\n\n        g_free(*retwsaddr);\n\n        *retsaddr = *retwsaddr = NULL;\n\n        *retnsaddr = *retnwsaddr = 0;\n\n    }\n\n    return ret;\n\n}\n", "idx": 23164}
{"project": "qemu", "commit_id": "549ce59e2b9ed7f41d2f88524bd5e01b0d7db2e9", "target": 0, "func": "static int spapr_create_pci_child_dt(sPAPRPHBState *phb, PCIDevice *dev,\n\n                                     void *fdt, int node_offset)\n\n{\n\n    int offset, ret;\n\n    char nodename[FDT_NAME_MAX];\n\n\n\n    pci_get_node_name(nodename, FDT_NAME_MAX, dev);\n\n    offset = fdt_add_subnode(fdt, node_offset, nodename);\n\n    ret = spapr_populate_pci_child_dt(dev, fdt, offset, phb);\n\n\n\n    g_assert(!ret);\n\n    if (ret) {\n\n        return 0;\n\n    }\n\n    return offset;\n\n}\n", "idx": 23165}
{"project": "qemu", "commit_id": "68fb89a2c07b6ad1e69a9a45f664d533f2662ec6", "target": 0, "func": "static void slavio_timer_irq(void *opaque)\n\n{\n\n    TimerContext *tc = opaque;\n\n    SLAVIO_TIMERState *s = tc->s;\n\n    CPUTimerState *t = &s->cputimer[tc->timer_index];\n\n\n\n    slavio_timer_get_out(t);\n\n    DPRINTF(\"callback: count %x%08x\\n\", t->counthigh, t->count);\n\n    t->reached = TIMER_REACHED;\n\n    /* there is no interrupt if user timer or free-run */\n\n    if (!slavio_timer_is_user(tc) && t->limit != 0) {\n\n        qemu_irq_raise(t->irq);\n\n    }\n\n}\n", "idx": 23166}
{"project": "qemu", "commit_id": "e4a3507e86a1ef1453d603031bca27d5ac4cff3c", "target": 0, "func": "static ssize_t test_block_write_func(QCryptoBlock *block,\n\n                                     void *opaque,\n\n                                     size_t offset,\n\n                                     const uint8_t *buf,\n\n                                     size_t buflen,\n\n                                     Error **errp)\n\n{\n\n    Buffer *header = opaque;\n\n\n\n    g_assert_cmpint(buflen + offset, <=, header->capacity);\n\n\n\n    memcpy(header->buffer + offset, buf, buflen);\n\n    header->offset = offset + buflen;\n\n\n\n    return buflen;\n\n}\n", "idx": 23167}
{"project": "qemu", "commit_id": "6c01bf6c7ba7539460fcaeb99fbe1776ba137aa8", "target": 0, "func": "uint64_t helper_fre (uint64_t arg)\n\n{\n\n    CPU_DoubleU fone, farg;\n\n    fone.ll = 0x3FF0000000000000ULL; /* 1.0 */\n\n    farg.ll = arg;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg.d))) {\n\n        /* sNaN reciprocal */\n\n        farg.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN);\n\n    } else if (unlikely(float64_is_zero(farg.d))) {\n\n        /* Zero reciprocal */\n\n        farg.ll = float_zero_divide_excp(fone.d, farg.d);\n\n    } else if (likely(isnormal(farg.d))) {\n\n        farg.d = float64_div(fone.d, farg.d, &env->fp_status);\n\n    } else {\n\n        if (farg.ll == 0x8000000000000000ULL) {\n\n            farg.ll = 0xFFF0000000000000ULL;\n\n        } else if (farg.ll == 0x0000000000000000ULL) {\n\n            farg.ll = 0x7FF0000000000000ULL;\n\n        } else if (float64_is_nan(farg.d)) {\n\n            farg.ll = 0x7FF8000000000000ULL;\n\n        } else if (float64_is_neg(farg.d)) {\n\n            farg.ll = 0x8000000000000000ULL;\n\n        } else {\n\n            farg.ll = 0x0000000000000000ULL;\n\n        }\n\n    }\n\n    return farg.d;\n\n}\n", "idx": 23168}
{"project": "qemu", "commit_id": "263a6f4c3aa9b6cd9f58d1368b318d948156a4e8", "target": 0, "func": "static int convert_iteration_sectors(ImgConvertState *s, int64_t sector_num)\n\n{\n\n    int64_t ret;\n\n    int n;\n\n\n\n    convert_select_part(s, sector_num);\n\n\n\n    assert(s->total_sectors > sector_num);\n\n    n = MIN(s->total_sectors - sector_num, BDRV_REQUEST_MAX_SECTORS);\n\n\n\n    if (s->sector_next_status <= sector_num) {\n\n        BlockDriverState *file;\n\n        ret = bdrv_get_block_status(blk_bs(s->src[s->src_cur]),\n\n                                    sector_num - s->src_cur_offset,\n\n                                    n, &n, &file);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        if (ret & BDRV_BLOCK_ZERO) {\n\n            s->status = BLK_ZERO;\n\n        } else if (ret & BDRV_BLOCK_DATA) {\n\n            s->status = BLK_DATA;\n\n        } else if (!s->target_has_backing) {\n\n            /* Without a target backing file we must copy over the contents of\n\n             * the backing file as well. */\n\n            /* TODO Check block status of the backing file chain to avoid\n\n             * needlessly reading zeroes and limiting the iteration to the\n\n             * buffer size */\n\n            s->status = BLK_DATA;\n\n        } else {\n\n            s->status = BLK_BACKING_FILE;\n\n        }\n\n\n\n        s->sector_next_status = sector_num + n;\n\n    }\n\n\n\n    n = MIN(n, s->sector_next_status - sector_num);\n\n    if (s->status == BLK_DATA) {\n\n        n = MIN(n, s->buf_sectors);\n\n    }\n\n\n\n    /* We need to write complete clusters for compressed images, so if an\n\n     * unallocated area is shorter than that, we must consider the whole\n\n     * cluster allocated. */\n\n    if (s->compressed) {\n\n        if (n < s->cluster_sectors) {\n\n            n = MIN(s->cluster_sectors, s->total_sectors - sector_num);\n\n            s->status = BLK_DATA;\n\n        } else {\n\n            n = QEMU_ALIGN_DOWN(n, s->cluster_sectors);\n\n        }\n\n    }\n\n\n\n    return n;\n\n}\n", "idx": 23169}
{"project": "qemu", "commit_id": "a3084e8055067b3fe8ed653a609021d2ab368564", "target": 0, "func": "uint32_t HELPER(mvcs)(CPUS390XState *env, uint64_t l, uint64_t a1, uint64_t a2)\n\n{\n\n    HELPER_LOG(\"%s: %16\" PRIx64 \" %16\" PRIx64 \" %16\" PRIx64 \"\\n\",\n\n               __func__, l, a1, a2);\n\n\n\n    return mvc_asc(env, l, a1, PSW_ASC_SECONDARY, a2, PSW_ASC_PRIMARY);\n\n}\n", "idx": 23170}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static int oss_run_out (HWVoiceOut *hw)\n\n{\n\n    OSSVoiceOut *oss = (OSSVoiceOut *) hw;\n\n    int err, rpos, live, decr;\n\n    int samples;\n\n    uint8_t *dst;\n\n    st_sample_t *src;\n\n    struct audio_buf_info abinfo;\n\n    struct count_info cntinfo;\n\n    int bufsize;\n\n\n\n    live = audio_pcm_hw_get_live_out (hw);\n\n    if (!live) {\n\n        return 0;\n\n    }\n\n\n\n    bufsize = hw->samples << hw->info.shift;\n\n\n\n    if (oss->mmapped) {\n\n        int bytes;\n\n\n\n        err = ioctl (oss->fd, SNDCTL_DSP_GETOPTR, &cntinfo);\n\n        if (err < 0) {\n\n            oss_logerr (errno, \"SNDCTL_DSP_GETOPTR failed\\n\");\n\n            return 0;\n\n        }\n\n\n\n        if (cntinfo.ptr == oss->old_optr) {\n\n            if (abs (hw->samples - live) < 64) {\n\n                dolog (\"warning: Overrun\\n\");\n\n            }\n\n            return 0;\n\n        }\n\n\n\n        if (cntinfo.ptr > oss->old_optr) {\n\n            bytes = cntinfo.ptr - oss->old_optr;\n\n        }\n\n        else {\n\n            bytes = bufsize + cntinfo.ptr - oss->old_optr;\n\n        }\n\n\n\n        decr = audio_MIN (bytes >> hw->info.shift, live);\n\n    }\n\n    else {\n\n        err = ioctl (oss->fd, SNDCTL_DSP_GETOSPACE, &abinfo);\n\n        if (err < 0) {\n\n            oss_logerr (errno, \"SNDCTL_DSP_GETOPTR failed\\n\");\n\n            return 0;\n\n        }\n\n\n\n        if (abinfo.bytes > bufsize) {\n\n            if (conf.debug) {\n\n                dolog (\"warning: Invalid available size, size=%d bufsize=%d\\n\"\n\n                       \"please report your OS/audio hw to malc@pulsesoft.com\\n\",\n\n                       abinfo.bytes, bufsize);\n\n            }\n\n            abinfo.bytes = bufsize;\n\n        }\n\n\n\n        if (abinfo.bytes < 0) {\n\n            if (conf.debug) {\n\n                dolog (\"warning: Invalid available size, size=%d bufsize=%d\\n\",\n\n                       abinfo.bytes, bufsize);\n\n            }\n\n            return 0;\n\n        }\n\n\n\n        decr = audio_MIN (abinfo.bytes >> hw->info.shift, live);\n\n        if (!decr) {\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    samples = decr;\n\n    rpos = hw->rpos;\n\n    while (samples) {\n\n        int left_till_end_samples = hw->samples - rpos;\n\n        int convert_samples = audio_MIN (samples, left_till_end_samples);\n\n\n\n        src = hw->mix_buf + rpos;\n\n        dst = advance (oss->pcm_buf, rpos << hw->info.shift);\n\n\n\n        hw->clip (dst, src, convert_samples);\n\n        if (!oss->mmapped) {\n\n            int written;\n\n\n\n            written = write (oss->fd, dst, convert_samples << hw->info.shift);\n\n            /* XXX: follow errno recommendations ? */\n\n            if (written == -1) {\n\n                oss_logerr (\n\n                    errno,\n\n                    \"Failed to write %d bytes of audio data from %p\\n\",\n\n                    convert_samples << hw->info.shift,\n\n                    dst\n\n                    );\n\n                continue;\n\n            }\n\n\n\n            if (written != convert_samples << hw->info.shift) {\n\n                int wsamples = written >> hw->info.shift;\n\n                int wbytes = wsamples << hw->info.shift;\n\n                if (wbytes != written) {\n\n                    dolog (\"warning: Misaligned write %d (requested %d), \"\n\n                           \"alignment %d\\n\",\n\n                           wbytes, written, hw->info.align + 1);\n\n                }\n\n                decr -= wsamples;\n\n                rpos = (rpos + wsamples) % hw->samples;\n\n                break;\n\n            }\n\n        }\n\n\n\n        rpos = (rpos + convert_samples) % hw->samples;\n\n        samples -= convert_samples;\n\n    }\n\n    if (oss->mmapped) {\n\n        oss->old_optr = cntinfo.ptr;\n\n    }\n\n\n\n    hw->rpos = rpos;\n\n    return decr;\n\n}\n", "idx": 23171}
{"project": "qemu", "commit_id": "375092332eeaa6e47561ce47fd36144cdaf964d0", "target": 0, "func": "static ssize_t block_crypto_read_func(QCryptoBlock *block,\n\n                                      size_t offset,\n\n                                      uint8_t *buf,\n\n                                      size_t buflen,\n\n                                      Error **errp,\n\n                                      void *opaque)\n\n{\n\n    BlockDriverState *bs = opaque;\n\n    ssize_t ret;\n\n\n\n    ret = bdrv_pread(bs->file, offset, buf, buflen);\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"Could not read encryption header\");\n\n        return ret;\n\n    }\n\n    return ret;\n\n}\n", "idx": 23173}
{"project": "qemu", "commit_id": "e3e09d87c6e69c2da684d5aacabe3124ebcb6f8e", "target": 0, "func": "int mmu_translate(CPUS390XState *env, target_ulong vaddr, int rw, uint64_t asc,\n\n                  target_ulong *raddr, int *flags)\n\n{\n\n    int r = -1;\n\n    uint8_t *sk;\n\n\n\n    *flags = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n    vaddr &= TARGET_PAGE_MASK;\n\n\n\n    if (!(env->psw.mask & PSW_MASK_DAT)) {\n\n        *raddr = vaddr;\n\n        r = 0;\n\n        goto out;\n\n    }\n\n\n\n    switch (asc) {\n\n    case PSW_ASC_PRIMARY:\n\n    case PSW_ASC_HOME:\n\n        r = mmu_translate_asc(env, vaddr, asc, raddr, flags, rw);\n\n        break;\n\n    case PSW_ASC_SECONDARY:\n\n        /*\n\n         * Instruction: Primary\n\n         * Data: Secondary\n\n         */\n\n        if (rw == 2) {\n\n            r = mmu_translate_asc(env, vaddr, PSW_ASC_PRIMARY, raddr, flags,\n\n                                  rw);\n\n            *flags &= ~(PAGE_READ | PAGE_WRITE);\n\n        } else {\n\n            r = mmu_translate_asc(env, vaddr, PSW_ASC_SECONDARY, raddr, flags,\n\n                                  rw);\n\n            *flags &= ~(PAGE_EXEC);\n\n        }\n\n        break;\n\n    case PSW_ASC_ACCREG:\n\n    default:\n\n        hw_error(\"guest switched to unknown asc mode\\n\");\n\n        break;\n\n    }\n\n\n\n out:\n\n    /* Convert real address -> absolute address */\n\n    *raddr = mmu_real2abs(env, *raddr);\n\n\n\n    if (*raddr <= ram_size) {\n\n        sk = &env->storage_keys[*raddr / TARGET_PAGE_SIZE];\n\n        if (*flags & PAGE_READ) {\n\n            *sk |= SK_R;\n\n        }\n\n\n\n        if (*flags & PAGE_WRITE) {\n\n            *sk |= SK_C;\n\n        }\n\n    }\n\n\n\n    return r;\n\n}\n", "idx": 23174}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "IDEDevice *ide_create_drive(IDEBus *bus, int unit, DriveInfo *drive)\n\n{\n\n    DeviceState *dev;\n\n\n\n    dev = qdev_create(&bus->qbus, drive->media_cd ? \"ide-cd\" : \"ide-hd\");\n\n    qdev_prop_set_uint32(dev, \"unit\", unit);\n\n    qdev_prop_set_drive_nofail(dev, \"drive\",\n\n                               blk_bs(blk_by_legacy_dinfo(drive)));\n\n    qdev_init_nofail(dev);\n\n    return DO_UPCAST(IDEDevice, qdev, dev);\n\n}\n", "idx": 23175}
{"project": "qemu", "commit_id": "c546194f260fb3e391193cb8cc33505618077ecb", "target": 0, "func": "void qmp_block_set_io_throttle(const char *device, int64_t bps, int64_t bps_rd,\n\n                               int64_t bps_wr, int64_t iops, int64_t iops_rd,\n\n                               int64_t iops_wr, Error **errp)\n\n{\n\n    BlockIOLimit io_limits;\n\n    BlockDriverState *bs;\n\n\n\n    bs = bdrv_find(device);\n\n    if (!bs) {\n\n        error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n\n        return;\n\n    }\n\n\n\n    io_limits.bps[BLOCK_IO_LIMIT_TOTAL] = bps;\n\n    io_limits.bps[BLOCK_IO_LIMIT_READ]  = bps_rd;\n\n    io_limits.bps[BLOCK_IO_LIMIT_WRITE] = bps_wr;\n\n    io_limits.iops[BLOCK_IO_LIMIT_TOTAL]= iops;\n\n    io_limits.iops[BLOCK_IO_LIMIT_READ] = iops_rd;\n\n    io_limits.iops[BLOCK_IO_LIMIT_WRITE]= iops_wr;\n\n\n\n    if (!do_check_io_limits(&io_limits)) {\n\n        error_set(errp, QERR_INVALID_PARAMETER_COMBINATION);\n\n        return;\n\n    }\n\n\n\n    bs->io_limits = io_limits;\n\n    bs->slice_time = BLOCK_IO_SLICE_TIME;\n\n\n\n    if (!bs->io_limits_enabled && bdrv_io_limits_enabled(bs)) {\n\n        bdrv_io_limits_enable(bs);\n\n    } else if (bs->io_limits_enabled && !bdrv_io_limits_enabled(bs)) {\n\n        bdrv_io_limits_disable(bs);\n\n    } else {\n\n        if (bs->block_timer) {\n\n            qemu_mod_timer(bs->block_timer, qemu_get_clock_ns(vm_clock));\n\n        }\n\n    }\n\n}\n", "idx": 23176}
{"project": "qemu", "commit_id": "d3b12f5dec4b27ebab58fb5797cb67bacced773b", "target": 0, "func": "void os_host_main_loop_wait(int *timeout)\n\n{\n\n    int ret, ret2, i;\n\n    PollingEntry *pe;\n\n\n\n    /* XXX: need to suppress polling by better using win32 events */\n\n    ret = 0;\n\n    for(pe = first_polling_entry; pe != NULL; pe = pe->next) {\n\n        ret |= pe->func(pe->opaque);\n\n    }\n\n    if (ret == 0) {\n\n        int err;\n\n        WaitObjects *w = &wait_objects;\n\n\n\n        qemu_mutex_unlock_iothread();\n\n        ret = WaitForMultipleObjects(w->num, w->events, FALSE, *timeout);\n\n        qemu_mutex_lock_iothread();\n\n        if (WAIT_OBJECT_0 + 0 <= ret && ret <= WAIT_OBJECT_0 + w->num - 1) {\n\n            if (w->func[ret - WAIT_OBJECT_0])\n\n                w->func[ret - WAIT_OBJECT_0](w->opaque[ret - WAIT_OBJECT_0]);\n\n\n\n            /* Check for additional signaled events */\n\n            for(i = (ret - WAIT_OBJECT_0 + 1); i < w->num; i++) {\n\n\n\n                /* Check if event is signaled */\n\n                ret2 = WaitForSingleObject(w->events[i], 0);\n\n                if(ret2 == WAIT_OBJECT_0) {\n\n                    if (w->func[i])\n\n                        w->func[i](w->opaque[i]);\n\n                } else if (ret2 == WAIT_TIMEOUT) {\n\n                } else {\n\n                    err = GetLastError();\n\n                    fprintf(stderr, \"WaitForSingleObject error %d %d\\n\", i, err);\n\n                }\n\n            }\n\n        } else if (ret == WAIT_TIMEOUT) {\n\n        } else {\n\n            err = GetLastError();\n\n            fprintf(stderr, \"WaitForMultipleObjects error %d %d\\n\", ret, err);\n\n        }\n\n    }\n\n\n\n    *timeout = 0;\n\n}\n", "idx": 23177}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void thread_pool_completion_bh(void *opaque)\n\n{\n\n    ThreadPool *pool = opaque;\n\n    ThreadPoolElement *elem, *next;\n\n\n\nrestart:\n\n    QLIST_FOREACH_SAFE(elem, &pool->head, all, next) {\n\n        if (elem->state != THREAD_DONE) {\n\n            continue;\n\n        }\n\n\n\n        trace_thread_pool_complete(pool, elem, elem->common.opaque,\n\n                                   elem->ret);\n\n        QLIST_REMOVE(elem, all);\n\n\n\n        if (elem->common.cb) {\n\n            /* Read state before ret.  */\n\n            smp_rmb();\n\n\n\n            /* Schedule ourselves in case elem->common.cb() calls aio_poll() to\n\n             * wait for another request that completed at the same time.\n\n             */\n\n            qemu_bh_schedule(pool->completion_bh);\n\n\n\n            elem->common.cb(elem->common.opaque, elem->ret);\n\n            qemu_aio_unref(elem);\n\n            goto restart;\n\n        } else {\n\n            qemu_aio_unref(elem);\n\n        }\n\n    }\n\n}\n", "idx": 23178}
{"project": "qemu", "commit_id": "7b899f4dd596dbb7d271f7fab36fbfffec84868e", "target": 0, "func": "static void test_commands(void)\n\n{\n\n    char *response;\n\n    int i;\n\n\n\n    for (i = 0; hmp_cmds[i] != NULL; i++) {\n\n        if (verbose) {\n\n            fprintf(stderr, \"\\t%s\\n\", hmp_cmds[i]);\n\n        }\n\n        response = hmp(hmp_cmds[i]);\n\n        g_free(response);\n\n    }\n\n\n\n}\n", "idx": 23179}
{"project": "qemu", "commit_id": "dfeb5fe7700d5e29a276f571aee7f6fc4267ee96", "target": 0, "func": "static void tcg_out_movi(TCGContext *s, TCGType type, TCGReg rd,\n\n                         tcg_target_long value)\n\n{\n\n    AArch64Insn insn;\n\n\n\n    if (type == TCG_TYPE_I32) {\n\n        value = (uint32_t)value;\n\n    }\n\n\n\n    /* count trailing zeros in 16 bit steps, mapping 64 to 0. Emit the\n\n       first MOVZ with the half-word immediate skipping the zeros, with a shift\n\n       (LSL) equal to this number. Then all next instructions use MOVKs.\n\n       Zero the processed half-word in the value, continue until empty.\n\n       We build the final result 16bits at a time with up to 4 instructions,\n\n       but do not emit instructions for 16bit zero holes. */\n\n    insn = I3405_MOVZ;\n\n    do {\n\n        unsigned shift = ctz64(value) & (63 & -16);\n\n        tcg_out_insn_3405(s, insn, shift >= 32, rd, value >> shift, shift);\n\n        value &= ~(0xffffUL << shift);\n\n        insn = I3405_MOVK;\n\n    } while (value);\n\n}\n", "idx": 23180}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void exynos4210_uart_write(void *opaque, target_phys_addr_t offset,\n\n                               uint64_t val, unsigned size)\n\n{\n\n    Exynos4210UartState *s = (Exynos4210UartState *)opaque;\n\n    uint8_t ch;\n\n\n\n    PRINT_DEBUG_EXTEND(\"UART%d: <0x%04x> %s <- 0x%08llx\\n\", s->channel,\n\n        offset, exynos4210_uart_regname(offset), (long long unsigned int)val);\n\n\n\n    switch (offset) {\n\n    case ULCON:\n\n    case UBRDIV:\n\n    case UFRACVAL:\n\n        s->reg[I_(offset)] = val;\n\n        exynos4210_uart_update_parameters(s);\n\n        break;\n\n    case UFCON:\n\n        s->reg[I_(UFCON)] = val;\n\n        if (val & UFCON_Rx_FIFO_RESET) {\n\n            fifo_reset(&s->rx);\n\n            s->reg[I_(UFCON)] &= ~UFCON_Rx_FIFO_RESET;\n\n            PRINT_DEBUG(\"UART%d: Rx FIFO Reset\\n\", s->channel);\n\n        }\n\n        if (val & UFCON_Tx_FIFO_RESET) {\n\n            fifo_reset(&s->tx);\n\n            s->reg[I_(UFCON)] &= ~UFCON_Tx_FIFO_RESET;\n\n            PRINT_DEBUG(\"UART%d: Tx FIFO Reset\\n\", s->channel);\n\n        }\n\n        break;\n\n\n\n    case UTXH:\n\n        if (s->chr) {\n\n            s->reg[I_(UTRSTAT)] &= ~(UTRSTAT_TRANSMITTER_EMPTY |\n\n                    UTRSTAT_Tx_BUFFER_EMPTY);\n\n            ch = (uint8_t)val;\n\n            qemu_chr_fe_write(s->chr, &ch, 1);\n\n#if DEBUG_Tx_DATA\n\n            fprintf(stderr, \"%c\", ch);\n\n#endif\n\n            s->reg[I_(UTRSTAT)] |= UTRSTAT_TRANSMITTER_EMPTY |\n\n                    UTRSTAT_Tx_BUFFER_EMPTY;\n\n            s->reg[I_(UINTSP)]  |= UINTSP_TXD;\n\n            exynos4210_uart_update_irq(s);\n\n        }\n\n        break;\n\n\n\n    case UINTP:\n\n        s->reg[I_(UINTP)] &= ~val;\n\n        s->reg[I_(UINTSP)] &= ~val;\n\n        PRINT_DEBUG(\"UART%d: UINTP [%04x] have been cleared: %08x\\n\",\n\n                    s->channel, offset, s->reg[I_(UINTP)]);\n\n        exynos4210_uart_update_irq(s);\n\n        break;\n\n    case UTRSTAT:\n\n    case UERSTAT:\n\n    case UFSTAT:\n\n    case UMSTAT:\n\n    case URXH:\n\n        PRINT_DEBUG(\"UART%d: Trying to write into RO register: %s [%04x]\\n\",\n\n                    s->channel, exynos4210_uart_regname(offset), offset);\n\n        break;\n\n    case UINTSP:\n\n        s->reg[I_(UINTSP)]  &= ~val;\n\n        break;\n\n    case UINTM:\n\n        s->reg[I_(UINTM)] = val;\n\n        exynos4210_uart_update_irq(s);\n\n        break;\n\n    case UCON:\n\n    case UMCON:\n\n    default:\n\n        s->reg[I_(offset)] = val;\n\n        break;\n\n    }\n\n}\n", "idx": 23181}
{"project": "qemu", "commit_id": "faab207f115cf9738f110cb088ab35a4b7aef73a", "target": 1, "func": "static int local_opendir(FsContext *ctx,\n\n                         V9fsPath *fs_path, V9fsFidOpenState *fs)\n\n{\n\n    int dirfd;\n\n    DIR *stream;\n\n\n\n    dirfd = local_opendir_nofollow(ctx, fs_path->data);\n\n    if (dirfd == -1) {\n\n        return -1;\n\n    }\n\n\n\n    stream = fdopendir(dirfd);\n\n    if (!stream) {\n\n\n        return -1;\n\n    }\n\n    fs->dir.stream = stream;\n\n    return 0;\n\n}", "idx": 23186}
{"project": "qemu", "commit_id": "c24a8a0b6dad5a33d84f5fb846edb28c43312c71", "target": 1, "func": "uint64_t helper_cvttq_svic(CPUAlphaState *env, uint64_t a)\n\n{\n\n    return inline_cvttq(env, a, float_round_to_zero, 1);\n\n}\n", "idx": 23189}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void rdma_start_incoming_migration(const char *host_port, Error **errp)\n\n{\n\n    int ret;\n\n    RDMAContext *rdma;\n\n    Error *local_err = NULL;\n\n\n\n    DPRINTF(\"Starting RDMA-based incoming migration\\n\");\n\n    rdma = qemu_rdma_data_init(host_port, &local_err);\n\n\n\n    if (rdma == NULL) {\n\n        goto err;\n\n    }\n\n\n\n    ret = qemu_rdma_dest_init(rdma, &local_err);\n\n\n\n    if (ret) {\n\n        goto err;\n\n    }\n\n\n\n    DPRINTF(\"qemu_rdma_dest_init success\\n\");\n\n\n\n    ret = rdma_listen(rdma->listen_id, 5);\n\n\n\n    if (ret) {\n\n        ERROR(errp, \"listening on socket!\");\n\n        goto err;\n\n    }\n\n\n\n    DPRINTF(\"rdma_listen success\\n\");\n\n\n\n    qemu_set_fd_handler2(rdma->channel->fd, NULL,\n\n                         rdma_accept_incoming_migration, NULL,\n\n                            (void *)(intptr_t) rdma);\n\n    return;\n\nerr:\n\n    error_propagate(errp, local_err);\n\n    g_free(rdma);\n\n}\n", "idx": 23190}
{"project": "qemu", "commit_id": "04e00c92ef75629a241ebc50537f75de0867928d", "target": 1, "func": "int hmp_pcie_aer_inject_error(Monitor *mon,\n\n                             const QDict *qdict, QObject **ret_data)\n\n{\n\n    const char *id = qdict_get_str(qdict, \"id\");\n\n    const char *error_name;\n\n    uint32_t error_status;\n\n    bool correctable;\n\n    PCIDevice *dev;\n\n    PCIEAERErr err;\n\n    int ret;\n\n\n\n    ret = pci_qdev_find_device(id, &dev);\n\n    if (ret < 0) {\n\n        monitor_printf(mon,\n\n                       \"id or pci device path is invalid or device not \"\n\n                       \"found. %s\\n\", id);\n\n        return ret;\n\n    }\n\n    if (!pci_is_express(dev)) {\n\n        monitor_printf(mon, \"the device doesn't support pci express. %s\\n\",\n\n                       id);\n\n        return -ENOSYS;\n\n    }\n\n\n\n    error_name = qdict_get_str(qdict, \"error_status\");\n\n    if (pcie_aer_parse_error_string(error_name, &error_status, &correctable)) {\n\n        char *e = NULL;\n\n        error_status = strtoul(error_name, &e, 0);\n\n        correctable = qdict_get_try_bool(qdict, \"correctable\", 0);\n\n        if (!e || *e != '\\0') {\n\n            monitor_printf(mon, \"invalid error status value. \\\"%s\\\"\",\n\n                           error_name);\n\n            return -EINVAL;\n\n        }\n\n    }\n\n    err.status = error_status;\n\n    err.source_id = (pci_bus_num(dev->bus) << 8) | dev->devfn;\n\n\n\n    err.flags = 0;\n\n    if (correctable) {\n\n        err.flags |= PCIE_AER_ERR_IS_CORRECTABLE;\n\n    }\n\n    if (qdict_get_try_bool(qdict, \"advisory_non_fatal\", 0)) {\n\n        err.flags |= PCIE_AER_ERR_MAYBE_ADVISORY;\n\n    }\n\n    if (qdict_haskey(qdict, \"header0\")) {\n\n        err.flags |= PCIE_AER_ERR_HEADER_VALID;\n\n    }\n\n    if (qdict_haskey(qdict, \"prefix0\")) {\n\n        err.flags |= PCIE_AER_ERR_TLP_PREFIX_PRESENT;\n\n    }\n\n\n\n    err.header[0] = qdict_get_try_int(qdict, \"header0\", 0);\n\n    err.header[1] = qdict_get_try_int(qdict, \"header1\", 0);\n\n    err.header[2] = qdict_get_try_int(qdict, \"header2\", 0);\n\n    err.header[3] = qdict_get_try_int(qdict, \"header3\", 0);\n\n\n\n    err.prefix[0] = qdict_get_try_int(qdict, \"prefix0\", 0);\n\n    err.prefix[1] = qdict_get_try_int(qdict, \"prefix1\", 0);\n\n    err.prefix[2] = qdict_get_try_int(qdict, \"prefix2\", 0);\n\n    err.prefix[3] = qdict_get_try_int(qdict, \"prefix3\", 0);\n\n\n\n    ret = pcie_aer_inject_error(dev, &err);\n\n    *ret_data = qobject_from_jsonf(\"{'id': %s, \"\n\n                                   \"'root_bus': %s, 'bus': %d, 'devfn': %d, \"\n\n                                   \"'ret': %d}\",\n\n                                   id, pci_root_bus_path(dev),\n\n                                   pci_bus_num(dev->bus), dev->devfn,\n\n                                   ret);\n\n    assert(*ret_data);\n\n\n\n    return 0;\n\n}\n", "idx": 23191}
{"project": "qemu", "commit_id": "3403e5eb884f3a74c40fe7cccc103f848c040215", "target": 1, "func": "static void test_opts_parse_number(void)\n\n{\n\n    Error *err = NULL;\n\n    QemuOpts *opts;\n\n\n\n    /* Lower limit zero */\n\n    opts = qemu_opts_parse(&opts_list_01, \"number1=0\", false, &error_abort);\n\n    g_assert_cmpuint(opts_count(opts), ==, 1);\n\n    g_assert_cmpuint(qemu_opt_get_number(opts, \"number1\", 1), ==, 0);\n\n\n\n    /* Upper limit 2^64-1 */\n\n    opts = qemu_opts_parse(&opts_list_01,\n\n                           \"number1=18446744073709551615,number2=-1\",\n\n                           false, &error_abort);\n\n    g_assert_cmpuint(opts_count(opts), ==, 2);\n\n    g_assert_cmphex(qemu_opt_get_number(opts, \"number1\", 1), ==, UINT64_MAX);\n\n    g_assert_cmphex(qemu_opt_get_number(opts, \"number2\", 0), ==, UINT64_MAX);\n\n\n\n    /* Above upper limit */\n\n    opts = qemu_opts_parse(&opts_list_01, \"number1=18446744073709551616\",\n\n                           false, &error_abort);\n\n    /* BUG: should reject */\n\n    g_assert_cmpuint(opts_count(opts), ==, 1);\n\n    g_assert_cmpuint(qemu_opt_get_number(opts, \"number1\", 1), ==, UINT64_MAX);\n\n\n\n    /* Below lower limit */\n\n    opts = qemu_opts_parse(&opts_list_01, \"number1=-18446744073709551616\",\n\n                           false, &error_abort);\n\n    /* BUG: should reject */\n\n    g_assert_cmpuint(opts_count(opts), ==, 1);\n\n    g_assert_cmpuint(qemu_opt_get_number(opts, \"number1\", 1), ==, UINT64_MAX);\n\n\n\n    /* Hex and octal */\n\n    opts = qemu_opts_parse(&opts_list_01, \"number1=0x2a,number2=052\",\n\n                           false, &error_abort);\n\n    g_assert_cmpuint(opts_count(opts), ==, 2);\n\n    g_assert_cmpuint(qemu_opt_get_number(opts, \"number1\", 1), ==, 42);\n\n    g_assert_cmpuint(qemu_opt_get_number(opts, \"number2\", 0), ==, 42);\n\n\n\n    /* Invalid */\n\n    opts = qemu_opts_parse(&opts_list_01, \"number1=\", false, &err);\n\n    /* BUG: should reject */\n\n    g_assert_cmpuint(opts_count(opts), ==, 1);\n\n    g_assert_cmpuint(qemu_opt_get_number(opts, \"number1\", 1), ==, 0);\n\n    opts = qemu_opts_parse(&opts_list_01, \"number1=eins\", false, &err);\n\n    error_free_or_abort(&err);\n\n    g_assert(!opts);\n\n\n\n    /* Leading whitespace */\n\n    opts = qemu_opts_parse(&opts_list_01, \"number1= \\t42\",\n\n                           false, &error_abort);\n\n    g_assert_cmpuint(opts_count(opts), ==, 1);\n\n    g_assert_cmpuint(qemu_opt_get_number(opts, \"number1\", 1), ==, 42);\n\n\n\n    /* Trailing crap */\n\n    opts = qemu_opts_parse(&opts_list_01, \"number1=3.14\", false, &err);\n\n    error_free_or_abort(&err);\n\n    g_assert(!opts);\n\n    opts = qemu_opts_parse(&opts_list_01, \"number1=08\", false, &err);\n\n    error_free_or_abort(&err);\n\n    g_assert(!opts);\n\n    opts = qemu_opts_parse(&opts_list_01, \"number1=0 \", false, &err);\n\n    error_free_or_abort(&err);\n\n    g_assert(!opts);\n\n\n\n    qemu_opts_reset(&opts_list_01);\n\n}\n", "idx": 23192}
{"project": "qemu", "commit_id": "69d09245d19765fd461cc3d3a7d79686007c4474", "target": 1, "func": "static void load_asl(GArray *sdts, AcpiSdtTable *sdt)\n\n{\n\n    AcpiSdtTable *temp;\n\n    GError *error = NULL;\n\n    GString *command_line = g_string_new(iasl);\n\n    gint fd;\n\n    gchar *out, *out_err;\n\n    gboolean ret;\n\n    int i;\n\n\n\n    fd = g_file_open_tmp(\"asl-XXXXXX.dsl\", &sdt->asl_file, &error);\n\n    g_assert_no_error(error);\n\n    close(fd);\n\n\n\n    /* build command line */\n\n    g_string_append_printf(command_line, \" -p %s \", sdt->asl_file);\n\n    for (i = 0; i < 2; ++i) { /* reference DSDT and SSDT */\n\n        temp = &g_array_index(sdts, AcpiSdtTable, i);\n\n        g_string_append_printf(command_line, \"-e %s \", temp->aml_file);\n\n    }\n\n    g_string_append_printf(command_line, \"-d %s\", sdt->aml_file);\n\n\n\n    /* pass 'out' and 'out_err' in order to be redirected */\n\n    g_spawn_command_line_sync(command_line->str, &out, &out_err, NULL, &error);\n\n    g_assert_no_error(error);\n\n\n\n    ret = g_file_get_contents(sdt->asl_file, (gchar **)&sdt->asl,\n\n                              &sdt->asl_len, &error);\n\n    g_assert(ret);\n\n    g_assert_no_error(error);\n\n    g_assert(sdt->asl_len);\n\n\n\n    g_free(out);\n\n    g_free(out_err);\n\n    g_string_free(command_line, true);\n\n}\n", "idx": 23194}
{"project": "qemu", "commit_id": "a2c5eaf7a9f6172e8dc5cfeb283e086f592cf50a", "target": 1, "func": "static int timebase_post_load(void *opaque, int version_id)\n\n{\n\n    PPCTimebase *tb_remote = opaque;\n\n    CPUState *cpu;\n\n    PowerPCCPU *first_ppc_cpu = POWERPC_CPU(first_cpu);\n\n    int64_t tb_off_adj, tb_off, ns_diff;\n\n    int64_t migration_duration_ns, migration_duration_tb, guest_tb, host_ns;\n\n    unsigned long freq;\n\n\n\n    if (!first_ppc_cpu->env.tb_env) {\n\n        error_report(\"No timebase object\");\n\n        return -1;\n\n    }\n\n\n\n    freq = first_ppc_cpu->env.tb_env->tb_freq;\n\n    /*\n\n     * Calculate timebase on the destination side of migration.\n\n     * The destination timebase must be not less than the source timebase.\n\n     * We try to adjust timebase by downtime if host clocks are not\n\n     * too much out of sync (1 second for now).\n\n     */\n\n    host_ns = qemu_clock_get_ns(QEMU_CLOCK_HOST);\n\n    ns_diff = MAX(0, host_ns - tb_remote->time_of_the_day_ns);\n\n    migration_duration_ns = MIN(NANOSECONDS_PER_SECOND, ns_diff);\n\n    migration_duration_tb = muldiv64(migration_duration_ns, freq,\n\n                                     NANOSECONDS_PER_SECOND);\n\n    guest_tb = tb_remote->guest_timebase + MIN(0, migration_duration_tb);\n\n\n\n    tb_off_adj = guest_tb - cpu_get_host_ticks();\n\n\n\n    tb_off = first_ppc_cpu->env.tb_env->tb_offset;\n\n    trace_ppc_tb_adjust(tb_off, tb_off_adj, tb_off_adj - tb_off,\n\n                        (tb_off_adj - tb_off) / freq);\n\n\n\n    /* Set new offset to all CPUs */\n\n    CPU_FOREACH(cpu) {\n\n        PowerPCCPU *pcpu = POWERPC_CPU(cpu);\n\n        pcpu->env.tb_env->tb_offset = tb_off_adj;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23195}
{"project": "qemu", "commit_id": "76f5159d7fc4cdea9574dfbb54307735b280bc66", "target": 1, "func": "static void msix_mmio_writel(void *opaque, target_phys_addr_t addr,\n\n                             uint32_t val)\n\n{\n\n    PCIDevice *dev = opaque;\n\n    unsigned int offset = addr & (MSIX_PAGE_SIZE - 1);\n\n    int vector = offset / MSIX_ENTRY_SIZE;\n\n    memcpy(dev->msix_table_page + offset, &val, 4);\n\n    if (!msix_is_masked(dev, vector) && msix_is_pending(dev, vector)) {\n\n        msix_clr_pending(dev, vector);\n\n        msix_notify(dev, vector);\n\n    }\n\n}\n", "idx": 23198}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "QEMUFile *qemu_fopen_ops(void *opaque, const QEMUFileOps *ops)\n\n{\n\n    QEMUFile *f;\n\n\n\n    f = g_malloc0(sizeof(QEMUFile));\n\n\n\n    f->opaque = opaque;\n\n    f->ops = ops;\n\n    return f;\n\n}\n", "idx": 23199}
{"project": "qemu", "commit_id": "f293709c6af7a65a9bcec09cdba7a60183657a3e", "target": 1, "func": "void tcg_exec_init(unsigned long tb_size)\n\n{\n\n    cpu_gen_init();\n\n    code_gen_alloc(tb_size);\n\n    page_init();\n\n#if defined(CONFIG_SOFTMMU)\n\n    /* There's no guest base to take into account, so go ahead and\n\n       initialize the prologue now.  */\n\n    tcg_prologue_init(&tcg_ctx);\n\n#endif\n\n}\n", "idx": 23200}
{"project": "qemu", "commit_id": "b2d1fe67d09d2b6c7da647fbcea6ca0148c206d3", "target": 1, "func": "static void bufp_free(USBRedirDevice *dev, struct buf_packet *bufp,\n\n    uint8_t ep)\n\n{\n\n    QTAILQ_REMOVE(&dev->endpoint[EP2I(ep)].bufpq, bufp, next);\n\n    dev->endpoint[EP2I(ep)].bufpq_size--;\n\n    free(bufp->data);\n\n    g_free(bufp);\n\n}\n", "idx": 23201}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int usb_msd_handle_data(USBDevice *dev, USBPacket *p)\n\n{\n\n    MSDState *s = (MSDState *)dev;\n\n    int ret = 0;\n\n    struct usb_msd_cbw cbw;\n\n    uint8_t devep = p->devep;\n\n    uint8_t *data = p->data;\n\n    int len = p->len;\n\n\n\n    switch (p->pid) {\n\n    case USB_TOKEN_OUT:\n\n        if (devep != 2)\n\n            goto fail;\n\n\n\n        switch (s->mode) {\n\n        case USB_MSDM_CBW:\n\n            if (len != 31) {\n\n                fprintf(stderr, \"usb-msd: Bad CBW size\");\n\n                goto fail;\n\n            }\n\n            memcpy(&cbw, data, 31);\n\n            if (le32_to_cpu(cbw.sig) != 0x43425355) {\n\n                fprintf(stderr, \"usb-msd: Bad signature %08x\\n\",\n\n                        le32_to_cpu(cbw.sig));\n\n                goto fail;\n\n            }\n\n            DPRINTF(\"Command on LUN %d\\n\", cbw.lun);\n\n            if (cbw.lun != 0) {\n\n                fprintf(stderr, \"usb-msd: Bad LUN %d\\n\", cbw.lun);\n\n                goto fail;\n\n            }\n\n            s->tag = le32_to_cpu(cbw.tag);\n\n            s->data_len = le32_to_cpu(cbw.data_len);\n\n            if (s->data_len == 0) {\n\n                s->mode = USB_MSDM_CSW;\n\n            } else if (cbw.flags & 0x80) {\n\n                s->mode = USB_MSDM_DATAIN;\n\n            } else {\n\n                s->mode = USB_MSDM_DATAOUT;\n\n            }\n\n            DPRINTF(\"Command tag 0x%x flags %08x len %d data %d\\n\",\n\n                    s->tag, cbw.flags, cbw.cmd_len, s->data_len);\n\n            s->residue = 0;\n\n            s->scsi_len = 0;\n\n            s->req = scsi_req_new(s->scsi_dev, s->tag, 0, NULL);\n\n            scsi_req_enqueue(s->req, cbw.cmd);\n\n            /* ??? Should check that USB and SCSI data transfer\n\n               directions match.  */\n\n            if (s->mode != USB_MSDM_CSW && s->residue == 0) {\n\n                scsi_req_continue(s->req);\n\n            }\n\n            ret = len;\n\n            break;\n\n\n\n        case USB_MSDM_DATAOUT:\n\n            DPRINTF(\"Data out %d/%d\\n\", len, s->data_len);\n\n            if (len > s->data_len)\n\n                goto fail;\n\n\n\n            s->usb_buf = data;\n\n            s->usb_len = len;\n\n            if (s->scsi_len) {\n\n                usb_msd_copy_data(s);\n\n            }\n\n            if (s->residue && s->usb_len) {\n\n                s->data_len -= s->usb_len;\n\n                if (s->data_len == 0)\n\n                    s->mode = USB_MSDM_CSW;\n\n                s->usb_len = 0;\n\n            }\n\n            if (s->usb_len) {\n\n                DPRINTF(\"Deferring packet %p\\n\", p);\n\n                s->packet = p;\n\n                ret = USB_RET_ASYNC;\n\n            } else {\n\n                ret = len;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            DPRINTF(\"Unexpected write (len %d)\\n\", len);\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    case USB_TOKEN_IN:\n\n        if (devep != 1)\n\n            goto fail;\n\n\n\n        switch (s->mode) {\n\n        case USB_MSDM_DATAOUT:\n\n            if (s->data_len != 0 || len < 13)\n\n                goto fail;\n\n            /* Waiting for SCSI write to complete.  */\n\n            s->packet = p;\n\n            ret = USB_RET_ASYNC;\n\n            break;\n\n\n\n        case USB_MSDM_CSW:\n\n            DPRINTF(\"Command status %d tag 0x%x, len %d\\n\",\n\n                    s->result, s->tag, len);\n\n            if (len < 13)\n\n                goto fail;\n\n\n\n            usb_msd_send_status(s, p);\n\n            s->mode = USB_MSDM_CBW;\n\n            ret = 13;\n\n            break;\n\n\n\n        case USB_MSDM_DATAIN:\n\n            DPRINTF(\"Data in %d/%d, scsi_len %d\\n\", len, s->data_len, s->scsi_len);\n\n            if (len > s->data_len)\n\n                len = s->data_len;\n\n            s->usb_buf = data;\n\n            s->usb_len = len;\n\n            if (s->scsi_len) {\n\n                usb_msd_copy_data(s);\n\n            }\n\n            if (s->residue && s->usb_len) {\n\n                s->data_len -= s->usb_len;\n\n                memset(s->usb_buf, 0, s->usb_len);\n\n                if (s->data_len == 0)\n\n                    s->mode = USB_MSDM_CSW;\n\n                s->usb_len = 0;\n\n            }\n\n            if (s->usb_len) {\n\n                DPRINTF(\"Deferring packet %p\\n\", p);\n\n                s->packet = p;\n\n                ret = USB_RET_ASYNC;\n\n            } else {\n\n                ret = len;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            DPRINTF(\"Unexpected read (len %d)\\n\", len);\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        DPRINTF(\"Bad token\\n\");\n\n    fail:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 23202}
{"project": "qemu", "commit_id": "b18f1141d0afa00de11a8e079f4f5305c9e36893", "target": 1, "func": "static Visitor *validate_test_init_internal(TestInputVisitorData *data,\n                                            const char *json_string,\n                                            va_list *ap)\n{\n    Visitor *v;\n    data->obj = qobject_from_jsonv(json_string, ap);\n    g_assert(data->obj);\n    data->qiv = qmp_input_visitor_new_strict(data->obj);\n    g_assert(data->qiv);\n    v = qmp_input_get_visitor(data->qiv);\n    g_assert(v);\n    return v;\n}", "idx": 23203}
{"project": "qemu", "commit_id": "ed4f86e8b6eff8e600c69adee68c7cd34dd2cccb", "target": 1, "func": "int load_multiboot(FWCfgState *fw_cfg,\n                   FILE *f,\n                   const char *kernel_filename,\n                   const char *initrd_filename,\n                   const char *kernel_cmdline,\n                   int kernel_file_size,\n                   uint8_t *header)\n{\n    int i, is_multiboot = 0;\n    uint32_t flags = 0;\n    uint32_t mh_entry_addr;\n    uint32_t mh_load_addr;\n    uint32_t mb_kernel_size;\n    MultibootState mbs;\n    uint8_t bootinfo[MBI_SIZE];\n    uint8_t *mb_bootinfo_data;\n    uint32_t cmdline_len;\n    /* Ok, let's see if it is a multiboot image.\n       The header is 12x32bit long, so the latest entry may be 8192 - 48. */\n    for (i = 0; i < (8192 - 48); i += 4) {\n        if (ldl_p(header+i) == 0x1BADB002) {\n            uint32_t checksum = ldl_p(header+i+8);\n            flags = ldl_p(header+i+4);\n            checksum += flags;\n            checksum += (uint32_t)0x1BADB002;\n            if (!checksum) {\n                is_multiboot = 1;\n                break;\n    if (!is_multiboot)\n        return 0; /* no multiboot */\n    mb_debug(\"qemu: I believe we found a multiboot image!\\n\");\n    memset(bootinfo, 0, sizeof(bootinfo));\n    memset(&mbs, 0, sizeof(mbs));\n    if (flags & 0x00000004) { /* MULTIBOOT_HEADER_HAS_VBE */\n        fprintf(stderr, \"qemu: multiboot knows VBE. we don't.\\n\");\n    if (!(flags & 0x00010000)) { /* MULTIBOOT_HEADER_HAS_ADDR */\n        uint64_t elf_entry;\n        uint64_t elf_low, elf_high;\n        int kernel_size;\n        fclose(f);\n        if (((struct elf64_hdr*)header)->e_machine == EM_X86_64) {\n            fprintf(stderr, \"Cannot load x86-64 image, give a 32bit one.\\n\");\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n                               &elf_low, &elf_high, 0, I386_ELF_MACHINE,\n                               0, 0);\n        if (kernel_size < 0) {\n            fprintf(stderr, \"Error while loading elf kernel\\n\");\n        mh_load_addr = elf_low;\n        mb_kernel_size = elf_high - elf_low;\n        mh_entry_addr = elf_entry;\n        mbs.mb_buf = g_malloc(mb_kernel_size);\n        if (rom_copy(mbs.mb_buf, mh_load_addr, mb_kernel_size) != mb_kernel_size) {\n            fprintf(stderr, \"Error while fetching elf kernel from rom\\n\");\n        mb_debug(\"qemu: loading multiboot-elf kernel (%#x bytes) with entry %#zx\\n\",\n                  mb_kernel_size, (size_t)mh_entry_addr);\n    } else {\n        /* Valid if mh_flags sets MULTIBOOT_HEADER_HAS_ADDR. */\n        uint32_t mh_header_addr = ldl_p(header+i+12);\n        uint32_t mh_load_end_addr = ldl_p(header+i+20);\n        uint32_t mh_bss_end_addr = ldl_p(header+i+24);\n        mh_load_addr = ldl_p(header+i+16);\n        uint32_t mb_kernel_text_offset = i - (mh_header_addr - mh_load_addr);\n        uint32_t mb_load_size = 0;\n        mh_entry_addr = ldl_p(header+i+28);\n        if (mh_load_end_addr) {\n            mb_kernel_size = mh_bss_end_addr - mh_load_addr;\n            mb_load_size = mh_load_end_addr - mh_load_addr;\n        } else {\n            mb_kernel_size = kernel_file_size - mb_kernel_text_offset;\n            mb_load_size = mb_kernel_size;\n        /* Valid if mh_flags sets MULTIBOOT_HEADER_HAS_VBE.\n        uint32_t mh_mode_type = ldl_p(header+i+32);\n        uint32_t mh_width = ldl_p(header+i+36);\n        uint32_t mh_height = ldl_p(header+i+40);\n        uint32_t mh_depth = ldl_p(header+i+44); */\n        mb_debug(\"multiboot: mh_header_addr = %#x\\n\", mh_header_addr);\n        mb_debug(\"multiboot: mh_load_addr = %#x\\n\", mh_load_addr);\n        mb_debug(\"multiboot: mh_load_end_addr = %#x\\n\", mh_load_end_addr);\n        mb_debug(\"multiboot: mh_bss_end_addr = %#x\\n\", mh_bss_end_addr);\n        mb_debug(\"qemu: loading multiboot kernel (%#x bytes) at %#x\\n\",\n                 mb_load_size, mh_load_addr);\n        mbs.mb_buf = g_malloc(mb_kernel_size);\n        fseek(f, mb_kernel_text_offset, SEEK_SET);\n        if (fread(mbs.mb_buf, 1, mb_load_size, f) != mb_load_size) {\n            fprintf(stderr, \"fread() failed\\n\");\n        memset(mbs.mb_buf + mb_load_size, 0, mb_kernel_size - mb_load_size);\n        fclose(f);\n    mbs.mb_buf_phys = mh_load_addr;\n    mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_kernel_size);\n    mbs.offset_mbinfo = mbs.mb_buf_size;\n    /* Calculate space for cmdlines, bootloader name, and mb_mods */\n    cmdline_len = strlen(kernel_filename) + 1;\n    cmdline_len += strlen(kernel_cmdline) + 1;\n    if (initrd_filename) {\n        const char *r = initrd_filename;\n        cmdline_len += strlen(r) + 1;\n        mbs.mb_mods_avail = 1;\n        while (*(r = get_opt_value(NULL, 0, r))) {\n           mbs.mb_mods_avail++;\n           r++;\n    mbs.mb_buf_size += cmdline_len;\n    mbs.mb_buf_size += MB_MOD_SIZE * mbs.mb_mods_avail;\n    mbs.mb_buf_size += strlen(bootloader_name) + 1;\n    mbs.mb_buf_size = TARGET_PAGE_ALIGN(mbs.mb_buf_size);\n    /* enlarge mb_buf to hold cmdlines, bootloader, mb-info structs */\n    mbs.mb_buf            = g_realloc(mbs.mb_buf, mbs.mb_buf_size);\n    mbs.offset_cmdlines   = mbs.offset_mbinfo + mbs.mb_mods_avail * MB_MOD_SIZE;\n    mbs.offset_bootloader = mbs.offset_cmdlines + cmdline_len;\n    if (initrd_filename) {\n        const char *next_initrd;\n        char not_last, tmpbuf[strlen(initrd_filename) + 1];\n        mbs.offset_mods = mbs.mb_buf_size;\n        do {\n            char *next_space;\n            int mb_mod_length;\n            uint32_t offs = mbs.mb_buf_size;\n            next_initrd = get_opt_value(tmpbuf, sizeof(tmpbuf), initrd_filename);\n            not_last = *next_initrd;\n            /* if a space comes after the module filename, treat everything\n               after that as parameters */\n            hwaddr c = mb_add_cmdline(&mbs, tmpbuf);\n            if ((next_space = strchr(tmpbuf, ' ')))\n                *next_space = '\\0';\n            mb_debug(\"multiboot loading module: %s\\n\", tmpbuf);\n            mb_mod_length = get_image_size(tmpbuf);\n            if (mb_mod_length < 0) {\n                fprintf(stderr, \"Failed to open file '%s'\\n\", tmpbuf);\n            mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_mod_length + mbs.mb_buf_size);\n            mbs.mb_buf = g_realloc(mbs.mb_buf, mbs.mb_buf_size);\n            load_image(tmpbuf, (unsigned char *)mbs.mb_buf + offs);\n            mb_add_mod(&mbs, mbs.mb_buf_phys + offs,\n                       mbs.mb_buf_phys + offs + mb_mod_length, c);\n            mb_debug(\"mod_start: %p\\nmod_end:   %p\\n  cmdline: \"TARGET_FMT_plx\"\\n\",\n                     (char *)mbs.mb_buf + offs,\n                     (char *)mbs.mb_buf + offs + mb_mod_length, c);\n            initrd_filename = next_initrd+1;\n        } while (not_last);\n    /* Commandline support */\n    char kcmdline[strlen(kernel_filename) + strlen(kernel_cmdline) + 2];\n    snprintf(kcmdline, sizeof(kcmdline), \"%s %s\",\n             kernel_filename, kernel_cmdline);\n    stl_p(bootinfo + MBI_CMDLINE, mb_add_cmdline(&mbs, kcmdline));\n    stl_p(bootinfo + MBI_BOOTLOADER, mb_add_bootloader(&mbs, bootloader_name));\n    stl_p(bootinfo + MBI_MODS_ADDR,  mbs.mb_buf_phys + mbs.offset_mbinfo);\n    stl_p(bootinfo + MBI_MODS_COUNT, mbs.mb_mods_count); /* mods_count */\n    /* the kernel is where we want it to be now */\n    stl_p(bootinfo + MBI_FLAGS, MULTIBOOT_FLAGS_MEMORY\n                                | MULTIBOOT_FLAGS_BOOT_DEVICE\n                                | MULTIBOOT_FLAGS_CMDLINE\n                                | MULTIBOOT_FLAGS_MODULES\n                                | MULTIBOOT_FLAGS_MMAP\n                                | MULTIBOOT_FLAGS_BOOTLOADER);\n    stl_p(bootinfo + MBI_BOOT_DEVICE, 0x8000ffff); /* XXX: use the -boot switch? */\n    stl_p(bootinfo + MBI_MMAP_ADDR,   ADDR_E820_MAP);\n    mb_debug(\"multiboot: mh_entry_addr = %#x\\n\", mh_entry_addr);\n    mb_debug(\"           mb_buf_phys   = \"TARGET_FMT_plx\"\\n\", mbs.mb_buf_phys);\n    mb_debug(\"           mod_start     = \"TARGET_FMT_plx\"\\n\", mbs.mb_buf_phys + mbs.offset_mods);\n    mb_debug(\"           mb_mods_count = %d\\n\", mbs.mb_mods_count);\n    /* save bootinfo off the stack */\n    mb_bootinfo_data = g_memdup(bootinfo, sizeof(bootinfo));\n    /* Pass variables to option rom */\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ENTRY, mh_entry_addr);\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, mh_load_addr);\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, mbs.mb_buf_size);\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_KERNEL_DATA,\n                     mbs.mb_buf, mbs.mb_buf_size);\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, ADDR_MBI);\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, sizeof(bootinfo));\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_INITRD_DATA, mb_bootinfo_data,\n                     sizeof(bootinfo));\n    option_rom[nb_option_roms].name = \"multiboot.bin\";\n    option_rom[nb_option_roms].bootindex = 0;\n    nb_option_roms++;\n    return 1; /* yes, we are multiboot */", "idx": 23204}
{"project": "qemu", "commit_id": "df8658de43db242ea82183d75cc957c2b0fa013a", "target": 1, "func": "static void spapr_core_pre_plug(HotplugHandler *hotplug_dev, DeviceState *dev,\n\n                                Error **errp)\n\n{\n\n    MachineState *machine = MACHINE(OBJECT(hotplug_dev));\n\n    MachineClass *mc = MACHINE_GET_CLASS(hotplug_dev);\n\n    Error *local_err = NULL;\n\n    CPUCore *cc = CPU_CORE(dev);\n\n    char *base_core_type = spapr_get_cpu_core_type(machine->cpu_model);\n\n    const char *type = object_get_typename(OBJECT(dev));\n\n    CPUArchId *core_slot;\n\n    int index;\n\n\n\n    if (dev->hotplugged && !mc->has_hotpluggable_cpus) {\n\n        error_setg(&local_err, \"CPU hotplug not supported for this machine\");\n\n        goto out;\n\n    }\n\n\n\n    if (strcmp(base_core_type, type)) {\n\n        error_setg(&local_err, \"CPU core type should be %s\", base_core_type);\n\n        goto out;\n\n    }\n\n\n\n    if (cc->core_id % smp_threads) {\n\n        error_setg(&local_err, \"invalid core id %d\", cc->core_id);\n\n        goto out;\n\n    }\n\n\n\n    /*\n\n     * In general we should have homogeneous threads-per-core, but old\n\n     * (pre hotplug support) machine types allow the last core to have\n\n     * reduced threads as a compatibility hack for when we allowed\n\n     * total vcpus not a multiple of threads-per-core.\n\n     */\n\n    if (mc->has_hotpluggable_cpus && (cc->nr_threads != smp_threads)) {\n\n        error_setg(errp, \"invalid nr-threads %d, must be %d\",\n\n                   cc->nr_threads, smp_threads);\n\n        return;\n\n    }\n\n\n\n    core_slot = spapr_find_cpu_slot(MACHINE(hotplug_dev), cc->core_id, &index);\n\n    if (!core_slot) {\n\n        error_setg(&local_err, \"core id %d out of range\", cc->core_id);\n\n        goto out;\n\n    }\n\n\n\n    if (core_slot->cpu) {\n\n        error_setg(&local_err, \"core %d already populated\", cc->core_id);\n\n        goto out;\n\n    }\n\n\n\n    numa_cpu_pre_plug(core_slot, dev, &local_err);\n\n\n\nout:\n\n    g_free(base_core_type);\n\n    error_propagate(errp, local_err);\n\n}\n", "idx": 23207}
{"project": "qemu", "commit_id": "25d943b95703ae45567395db4156b25052ee54c4", "target": 1, "func": "get_net_error_message(gint error)\n\n{\n\n    HMODULE module = NULL;\n\n    gchar *retval = NULL;\n\n    wchar_t *msg = NULL;\n\n    int flags;\n\n    size_t nchars;\n\n\n\n    flags = FORMAT_MESSAGE_ALLOCATE_BUFFER |\n\n        FORMAT_MESSAGE_IGNORE_INSERTS |\n\n        FORMAT_MESSAGE_FROM_SYSTEM;\n\n\n\n    if (error >= NERR_BASE && error <= MAX_NERR) {\n\n        module = LoadLibraryExW(L\"netmsg.dll\", NULL, LOAD_LIBRARY_AS_DATAFILE);\n\n\n\n        if (module != NULL) {\n\n            flags |= FORMAT_MESSAGE_FROM_HMODULE;\n\n        }\n\n    }\n\n\n\n    FormatMessageW(flags, module, error, 0, (LPWSTR)&msg, 0, NULL);\n\n\n\n    if (msg != NULL) {\n\n        nchars = wcslen(msg);\n\n\n\n        if (nchars > 2 &&\n\n            msg[nchars - 1] == L'\\n' &&\n\n            msg[nchars - 2] == L'\\r') {\n\n            msg[nchars - 2] = L'\\0';\n\n        }\n\n\n\n        retval = g_utf16_to_utf8(msg, -1, NULL, NULL, NULL);\n\n\n\n        LocalFree(msg);\n\n    }\n\n\n\n    if (module != NULL) {\n\n        FreeLibrary(module);\n\n    }\n\n\n\n    return retval;\n\n}\n", "idx": 23213}
{"project": "qemu", "commit_id": "1984745ea8ad309a06690a83e91d031d21d709ff", "target": 1, "func": "void nand_setpins(DeviceState *dev, uint8_t cle, uint8_t ale,\n\n                  uint8_t ce, uint8_t wp, uint8_t gnd)\n\n{\n\n    NANDFlashState *s = (NANDFlashState *) dev;\n\n    s->cle = cle;\n\n    s->ale = ale;\n\n    s->ce = ce;\n\n    s->wp = wp;\n\n    s->gnd = gnd;\n\n    if (wp)\n\n        s->status |= NAND_IOSTATUS_UNPROTCT;\n\n    else\n\n        s->status &= ~NAND_IOSTATUS_UNPROTCT;\n\n}\n", "idx": 23215}
{"project": "qemu", "commit_id": "aedbe19297907143f17b733a7ff0e0534377bed1", "target": 1, "func": "void qemu_system_killed(int signal, pid_t pid)\n\n{\n\n    shutdown_signal = signal;\n\n    shutdown_pid = pid;\n\n    no_shutdown = 0;\n\n\n\n    /* Cannot call qemu_system_shutdown_request directly because\n\n     * we are in a signal handler.\n\n     */\n\n    shutdown_requested = 1;\n\n    qemu_notify_event();\n\n}\n", "idx": 23219}
{"project": "qemu", "commit_id": "1f51470d044852592922f91000e741c381582cdc", "target": 1, "func": "static int qemu_chr_open_tty(QemuOpts *opts, CharDriverState **_chr)\n\n{\n\n    const char *filename = qemu_opt_get(opts, \"path\");\n\n    CharDriverState *chr;\n\n    int fd;\n\n\n\n    TFR(fd = qemu_open(filename, O_RDWR | O_NONBLOCK));\n\n    if (fd < 0) {\n\n        return -errno;\n\n    }\n\n    tty_serial_init(fd, 115200, 'N', 8, 1);\n\n    chr = qemu_chr_open_fd(fd, fd);\n\n    chr->chr_ioctl = tty_serial_ioctl;\n\n    chr->chr_close = qemu_chr_close_tty;\n\n\n\n    *_chr = chr;\n\n    return 0;\n\n}\n", "idx": 23220}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int usb_hub_handle_data(USBDevice *dev, USBPacket *p)\n\n{\n\n    USBHubState *s = (USBHubState *)dev;\n\n    int ret;\n\n\n\n    switch(p->pid) {\n\n    case USB_TOKEN_IN:\n\n        if (p->devep == 1) {\n\n            USBHubPort *port;\n\n            unsigned int status;\n\n            uint8_t buf[4];\n\n            int i, n;\n\n            n = (NUM_PORTS + 1 + 7) / 8;\n\n            if (p->iov.size == 1) { /* FreeBSD workaround */\n\n                n = 1;\n\n            } else if (n > p->iov.size) {\n\n                return USB_RET_BABBLE;\n\n            }\n\n            status = 0;\n\n            for(i = 0; i < NUM_PORTS; i++) {\n\n                port = &s->ports[i];\n\n                if (port->wPortChange)\n\n                    status |= (1 << (i + 1));\n\n            }\n\n            if (status != 0) {\n\n                for(i = 0; i < n; i++) {\n\n                    buf[i] = status >> (8 * i);\n\n                }\n\n                usb_packet_copy(p, buf, n);\n\n                ret = n;\n\n            } else {\n\n                ret = USB_RET_NAK; /* usb11 11.13.1 */\n\n            }\n\n        } else {\n\n            goto fail;\n\n        }\n\n        break;\n\n    case USB_TOKEN_OUT:\n\n    default:\n\n    fail:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n    return ret;\n\n}\n", "idx": 23221}
{"project": "qemu", "commit_id": "3954d33ab7f82f5a5fa0ced231849920265a5fec", "target": 0, "func": "static char *vio_format_dev_name(VIOsPAPRDevice *dev)\n\n{\n\n    VIOsPAPRDeviceInfo *info = (VIOsPAPRDeviceInfo *)qdev_get_info(&dev->qdev);\n\n    char *name;\n\n\n\n    /* Device tree style name device@reg */\n\n    if (asprintf(&name, \"%s@%x\", info->dt_name, dev->reg) < 0) {\n\n        return NULL;\n\n    }\n\n\n\n    return name;\n\n}\n", "idx": 23222}
{"project": "qemu", "commit_id": "45a50b1668822c23afc2a89f724654e176518bc4", "target": 0, "func": "static int load_option_rom(const char *oprom, target_phys_addr_t start,\n\n                           target_phys_addr_t end)\n\n{\n\n    int size;\n\n    char *filename;\n\n\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, oprom);\n\n    if (filename) {\n\n        size = get_image_size(filename);\n\n        if (size > 0 && start + size > end) {\n\n            fprintf(stderr, \"Not enough space to load option rom '%s'\\n\",\n\n                    oprom);\n\n            exit(1);\n\n        }\n\n        size = load_image_targphys(filename, start, end - start);\n\n        qemu_free(filename);\n\n    } else {\n\n        size = -1;\n\n    }\n\n    if (size < 0) {\n\n        fprintf(stderr, \"Could not load option rom '%s'\\n\", oprom);\n\n        exit(1);\n\n    }\n\n    /* Round up optiom rom size to the next 2k boundary */\n\n    size = (size + 2047) & ~2047;\n\n    option_rom_setup_reset(start, size);\n\n    return size;\n\n}\n", "idx": 23223}
{"project": "qemu", "commit_id": "5b7ba05fe7313b03712e129a86fa70c2c215e908", "target": 0, "func": "static BlockReopenQueue *bdrv_reopen_queue_child(BlockReopenQueue *bs_queue,\n\n                                                 BlockDriverState *bs,\n\n                                                 QDict *options,\n\n                                                 int flags,\n\n                                                 const BdrvChildRole *role,\n\n                                                 QDict *parent_options,\n\n                                                 int parent_flags)\n\n{\n\n    assert(bs != NULL);\n\n\n\n    BlockReopenQueueEntry *bs_entry;\n\n    BdrvChild *child;\n\n    QDict *old_options, *explicit_options;\n\n\n\n    if (bs_queue == NULL) {\n\n        bs_queue = g_new0(BlockReopenQueue, 1);\n\n        QSIMPLEQ_INIT(bs_queue);\n\n    }\n\n\n\n    if (!options) {\n\n        options = qdict_new();\n\n    }\n\n\n\n    /*\n\n     * Precedence of options:\n\n     * 1. Explicitly passed in options (highest)\n\n     * 2. Set in flags (only for top level)\n\n     * 3. Retained from explicitly set options of bs\n\n     * 4. Inherited from parent node\n\n     * 5. Retained from effective options of bs\n\n     */\n\n\n\n    if (!parent_options) {\n\n        /*\n\n         * Any setting represented by flags is always updated. If the\n\n         * corresponding QDict option is set, it takes precedence. Otherwise\n\n         * the flag is translated into a QDict option. The old setting of bs is\n\n         * not considered.\n\n         */\n\n        update_options_from_flags(options, flags);\n\n    }\n\n\n\n    /* Old explicitly set values (don't overwrite by inherited value) */\n\n    old_options = qdict_clone_shallow(bs->explicit_options);\n\n    bdrv_join_options(bs, options, old_options);\n\n    QDECREF(old_options);\n\n\n\n    explicit_options = qdict_clone_shallow(options);\n\n\n\n    /* Inherit from parent node */\n\n    if (parent_options) {\n\n        assert(!flags);\n\n        role->inherit_options(&flags, options, parent_flags, parent_options);\n\n    }\n\n\n\n    /* Old values are used for options that aren't set yet */\n\n    old_options = qdict_clone_shallow(bs->options);\n\n    bdrv_join_options(bs, options, old_options);\n\n    QDECREF(old_options);\n\n\n\n    /* bdrv_open() masks this flag out */\n\n    flags &= ~BDRV_O_PROTOCOL;\n\n\n\n    QLIST_FOREACH(child, &bs->children, next) {\n\n        QDict *new_child_options;\n\n        char *child_key_dot;\n\n\n\n        /* reopen can only change the options of block devices that were\n\n         * implicitly created and inherited options. For other (referenced)\n\n         * block devices, a syntax like \"backing.foo\" results in an error. */\n\n        if (child->bs->inherits_from != bs) {\n\n            continue;\n\n        }\n\n\n\n        child_key_dot = g_strdup_printf(\"%s.\", child->name);\n\n        qdict_extract_subqdict(options, &new_child_options, child_key_dot);\n\n        g_free(child_key_dot);\n\n\n\n        bdrv_reopen_queue_child(bs_queue, child->bs, new_child_options, 0,\n\n                                child->role, options, flags);\n\n    }\n\n\n\n    bs_entry = g_new0(BlockReopenQueueEntry, 1);\n\n    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);\n\n\n\n    bs_entry->state.bs = bs;\n\n    bs_entry->state.options = options;\n\n    bs_entry->state.explicit_options = explicit_options;\n\n    bs_entry->state.flags = flags;\n\n\n\n    return bs_queue;\n\n}\n", "idx": 23224}
{"project": "qemu", "commit_id": "42bb9c9178ae7ac4c439172b1ae99cc29188a5c6", "target": 0, "func": "static void xilinx_axidma_init(Object *obj)\n\n{\n\n    XilinxAXIDMA *s = XILINX_AXI_DMA(obj);\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);\n\n    Error *errp = NULL;\n\n\n\n    object_property_add_link(obj, \"axistream-connected\", TYPE_STREAM_SLAVE,\n\n                             (Object **) &s->tx_dev, NULL);\n\n\n\n    object_initialize(&s->rx_data_dev, TYPE_XILINX_AXI_DMA_DATA_STREAM);\n\n    object_property_add_child(OBJECT(s), \"axistream-connected-target\",\n\n                              (Object *)&s->rx_data_dev, &errp);\n\n    assert_no_error(errp);\n\n\n\n    sysbus_init_irq(sbd, &s->streams[0].irq);\n\n    sysbus_init_irq(sbd, &s->streams[1].irq);\n\n\n\n    memory_region_init_io(&s->iomem, &axidma_ops, s,\n\n                          \"xlnx.axi-dma\", R_MAX * 4 * 2);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n\n}\n", "idx": 23225}
{"project": "qemu", "commit_id": "bccd9ec5f098668576342c83d90d6d6833d61d33", "target": 0, "func": "void tlb_fill (target_ulong addr, int is_write, int mmu_idx, void *retaddr)\n\n{\n\n    TranslationBlock *tb;\n\n    CPUState *saved_env;\n\n    unsigned long pc;\n\n    int ret;\n\n\n\n    /* XXX: hack to restore env in all cases, even if not called from\n\n       generated code */\n\n    saved_env = env;\n\n    env = cpu_single_env;\n\n\n\n    D_LOG(\"%s pc=%x tpc=%x ra=%x\\n\", __func__, \n\n\t     env->pc, env->debug1, retaddr);\n\n    ret = cpu_cris_handle_mmu_fault(env, addr, is_write, mmu_idx);\n\n    if (unlikely(ret)) {\n\n        if (retaddr) {\n\n            /* now we have a real cpu fault */\n\n            pc = (unsigned long)retaddr;\n\n            tb = tb_find_pc(pc);\n\n            if (tb) {\n\n                /* the PC is inside the translated code. It means that we have\n\n                   a virtual CPU fault */\n\n                cpu_restore_state(tb, env, pc);\n\n\n\n\t\t/* Evaluate flags after retranslation.  */\n\n                helper_top_evaluate_flags();\n\n            }\n\n        }\n\n        cpu_loop_exit(env);\n\n    }\n\n    env = saved_env;\n\n}\n", "idx": 23226}
{"project": "qemu", "commit_id": "a5b0f6d5c0f6678c078354c432a1f0943374f087", "target": 0, "func": "static void lm32_cpu_reset(CPUState *s)\n\n{\n\n    LM32CPU *cpu = LM32_CPU(s);\n\n    LM32CPUClass *lcc = LM32_CPU_GET_CLASS(cpu);\n\n    CPULM32State *env = &cpu->env;\n\n\n\n    if (qemu_loglevel_mask(CPU_LOG_RESET)) {\n\n        qemu_log(\"CPU Reset (CPU %d)\\n\", s->cpu_index);\n\n        log_cpu_state(env, 0);\n\n    }\n\n\n\n    lcc->parent_reset(s);\n\n\n\n    tlb_flush(env, 1);\n\n\n\n    /* reset cpu state */\n\n    memset(env, 0, offsetof(CPULM32State, breakpoints));\n\n}\n", "idx": 23227}
{"project": "qemu", "commit_id": "e100161b69f8cf56dae866912dfffe7dcd7140af", "target": 0, "func": "int vfio_spapr_create_window(VFIOContainer *container,\n\n                             MemoryRegionSection *section,\n\n                             hwaddr *pgsize)\n\n{\n\n    int ret;\n\n    IOMMUMemoryRegion *iommu_mr = IOMMU_MEMORY_REGION(section->mr);\n\n    unsigned pagesize = memory_region_iommu_get_min_page_size(iommu_mr);\n\n    unsigned entries, pages;\n\n    struct vfio_iommu_spapr_tce_create create = { .argsz = sizeof(create) };\n\n\n\n    /*\n\n     * FIXME: For VFIO iommu types which have KVM acceleration to\n\n     * avoid bouncing all map/unmaps through qemu this way, this\n\n     * would be the right place to wire that up (tell the KVM\n\n     * device emulation the VFIO iommu handles to use).\n\n     */\n\n    create.window_size = int128_get64(section->size);\n\n    create.page_shift = ctz64(pagesize);\n\n    /*\n\n     * SPAPR host supports multilevel TCE tables, there is some\n\n     * heuristic to decide how many levels we want for our table:\n\n     * 0..64 = 1; 65..4096 = 2; 4097..262144 = 3; 262145.. = 4\n\n     */\n\n    entries = create.window_size >> create.page_shift;\n\n    pages = MAX((entries * sizeof(uint64_t)) / getpagesize(), 1);\n\n    pages = MAX(pow2ceil(pages) - 1, 1); /* Round up */\n\n    create.levels = ctz64(pages) / 6 + 1;\n\n\n\n    ret = ioctl(container->fd, VFIO_IOMMU_SPAPR_TCE_CREATE, &create);\n\n    if (ret) {\n\n        error_report(\"Failed to create a window, ret = %d (%m)\", ret);\n\n        return -errno;\n\n    }\n\n\n\n    if (create.start_addr != section->offset_within_address_space) {\n\n        vfio_spapr_remove_window(container, create.start_addr);\n\n\n\n        error_report(\"Host doesn't support DMA window at %\"HWADDR_PRIx\", must be %\"PRIx64,\n\n                     section->offset_within_address_space,\n\n                     (uint64_t)create.start_addr);\n\n        return -EINVAL;\n\n    }\n\n    trace_vfio_spapr_create_window(create.page_shift,\n\n                                   create.window_size,\n\n                                   create.start_addr);\n\n    *pgsize = pagesize;\n\n\n\n    return 0;\n\n}\n", "idx": 23229}
{"project": "qemu", "commit_id": "2a0c46da967e5dc8cfe73b1b6fe7a1600c04f461", "target": 0, "func": "main(\n\n    int argc,\n\n    char *argv[]\n\n) {\n\n    GMainLoop *loop;\n\n    GIOChannel *channel_stdin;\n\n    char *qemu_host;\n\n    char *qemu_port;\n\n\n\n    VCardEmulOptions *command_line_options = NULL;\n\n\n\n    char *cert_names[MAX_CERTS];\n\n    char *emul_args = NULL;\n\n    int cert_count = 0;\n\n    int c, sock;\n\n\n\n    if (socket_init() != 0)\n\n        return 1;\n\n\n\n    while ((c = getopt(argc, argv, \"c:e:pd:\")) != -1) {\n\n        switch (c) {\n\n        case 'c':\n\n            if (cert_count >= MAX_CERTS) {\n\n                printf(\"too many certificates (max = %d)\\n\", MAX_CERTS);\n\n                exit(5);\n\n            }\n\n            cert_names[cert_count++] = optarg;\n\n            break;\n\n        case 'e':\n\n            emul_args = optarg;\n\n            break;\n\n        case 'p':\n\n            print_usage();\n\n            exit(4);\n\n            break;\n\n        case 'd':\n\n            verbose = get_id_from_string(optarg, 1);\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (argc - optind != 2) {\n\n        print_usage();\n\n        exit(4);\n\n    }\n\n\n\n    if (cert_count > 0) {\n\n        char *new_args;\n\n        int len, i;\n\n        /* if we've given some -c options, we clearly we want do so some\n\n         * software emulation.  add that emulation now. this is NSS Emulator\n\n         * specific */\n\n        if (emul_args == NULL) {\n\n            emul_args = (char *)\"db=\\\"/etc/pki/nssdb\\\"\";\n\n        }\n\n#define SOFT_STRING \",soft=(,Virtual Reader,CAC,,\"\n\n             /* 2 == close paren & null */\n\n        len = strlen(emul_args) + strlen(SOFT_STRING) + 2;\n\n        for (i = 0; i < cert_count; i++) {\n\n            len += strlen(cert_names[i])+1; /* 1 == comma */\n\n        }\n\n        new_args = g_malloc(len);\n\n        strcpy(new_args, emul_args);\n\n        strcat(new_args, SOFT_STRING);\n\n        for (i = 0; i < cert_count; i++) {\n\n            strcat(new_args, cert_names[i]);\n\n            strcat(new_args, \",\");\n\n        }\n\n        strcat(new_args, \")\");\n\n        emul_args = new_args;\n\n    }\n\n    if (emul_args) {\n\n        command_line_options = vcard_emul_options(emul_args);\n\n    }\n\n\n\n    qemu_host = g_strdup(argv[argc - 2]);\n\n    qemu_port = g_strdup(argv[argc - 1]);\n\n    sock = connect_to_qemu(qemu_host, qemu_port);\n\n    if (sock == -1) {\n\n        fprintf(stderr, \"error opening socket, exiting.\\n\");\n\n        exit(5);\n\n    }\n\n\n\n    socket_to_send = g_byte_array_new();\n\n    qemu_mutex_init(&socket_to_send_lock);\n\n    qemu_mutex_init(&pending_reader_lock);\n\n    qemu_cond_init(&pending_reader_condition);\n\n\n\n    vcard_emul_init(command_line_options);\n\n\n\n    loop = g_main_loop_new(NULL, true);\n\n\n\n    printf(\"> \");\n\n    fflush(stdout);\n\n\n\n#ifdef _WIN32\n\n    channel_stdin = g_io_channel_win32_new_fd(STDIN_FILENO);\n\n#else\n\n    channel_stdin = g_io_channel_unix_new(STDIN_FILENO);\n\n#endif\n\n    g_io_add_watch(channel_stdin, G_IO_IN, do_command, NULL);\n\n#ifdef _WIN32\n\n    channel_socket = g_io_channel_win32_new_socket(sock);\n\n#else\n\n    channel_socket = g_io_channel_unix_new(sock);\n\n#endif\n\n    g_io_channel_set_encoding(channel_socket, NULL, NULL);\n\n    /* we buffer ourself for thread safety reasons */\n\n    g_io_channel_set_buffered(channel_socket, FALSE);\n\n\n\n    /* Send init message, Host responds (and then we send reader attachments) */\n\n    VSCMsgInit init = {\n\n        .version = htonl(VSCARD_VERSION),\n\n        .magic = VSCARD_MAGIC,\n\n        .capabilities = {0}\n\n    };\n\n    send_msg(VSC_Init, 0, &init, sizeof(init));\n\n\n\n    g_main_loop_run(loop);\n\n    g_main_loop_unref(loop);\n\n\n\n    g_io_channel_unref(channel_stdin);\n\n    g_io_channel_unref(channel_socket);\n\n    g_byte_array_free(socket_to_send, TRUE);\n\n\n\n    closesocket(sock);\n\n    return 0;\n\n}\n", "idx": 23230}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_in_wrong_type(TestInputVisitorData *data,\n\n                                       const void *unused)\n\n{\n\n    TestStruct *p = NULL;\n\n    Visitor *v;\n\n    strList *q = NULL;\n\n    int64_t i;\n\n    Error *err = NULL;\n\n\n\n    /* Make sure arrays and structs cannot be confused */\n\n\n\n    v = visitor_input_test_init(data, \"[]\");\n\n    visit_type_TestStruct(v, NULL, &p, &err);\n\n    error_free_or_abort(&err);\n\n    g_assert(!p);\n\n\n\n    v = visitor_input_test_init(data, \"{}\");\n\n    visit_type_strList(v, NULL, &q, &err);\n\n    error_free_or_abort(&err);\n\n    assert(!q);\n\n\n\n    /* Make sure primitives and struct cannot be confused */\n\n\n\n    v = visitor_input_test_init(data, \"1\");\n\n    visit_type_TestStruct(v, NULL, &p, &err);\n\n    error_free_or_abort(&err);\n\n    g_assert(!p);\n\n\n\n    v = visitor_input_test_init(data, \"{}\");\n\n    visit_type_int(v, NULL, &i, &err);\n\n    error_free_or_abort(&err);\n\n\n\n    /* Make sure primitives and arrays cannot be confused */\n\n\n\n    v = visitor_input_test_init(data, \"1\");\n\n    visit_type_strList(v, NULL, &q, &err);\n\n    error_free_or_abort(&err);\n\n    assert(!q);\n\n\n\n    v = visitor_input_test_init(data, \"[]\");\n\n    visit_type_int(v, NULL, &i, &err);\n\n    error_free_or_abort(&err);\n\n}\n", "idx": 23231}
{"project": "qemu", "commit_id": "a3fa1d78cbae2259491b17689812edcb643a3b30", "target": 0, "func": "static int buffered_close(void *opaque)\n\n{\n\n    MigrationState *s = opaque;\n\n\n\n    DPRINTF(\"closing\\n\");\n\n\n\n    s->xfer_limit = INT_MAX;\n\n    while (!qemu_file_get_error(s->file) && s->buffer_size) {\n\n        buffered_flush(s);\n\n    }\n\n    return migrate_fd_close(s);\n\n}\n", "idx": 23232}
{"project": "qemu", "commit_id": "539de1246d355d3b8aa33fb7cde732352d8827c7", "target": 0, "func": "static int blk_mig_save_bulked_block(Monitor *mon, QEMUFile *f)\n\n{\n\n    int64_t completed_sector_sum = 0;\n\n    BlkMigDevState *bmds;\n\n    int progress;\n\n    int ret = 0;\n\n\n\n    QSIMPLEQ_FOREACH(bmds, &block_mig_state.bmds_list, entry) {\n\n        if (bmds->bulk_completed == 0) {\n\n            if (mig_save_device_bulk(mon, f, bmds) == 1) {\n\n                /* completed bulk section for this device */\n\n                bmds->bulk_completed = 1;\n\n            }\n\n            completed_sector_sum += bmds->completed_sectors;\n\n            ret = 1;\n\n            break;\n\n        } else {\n\n            completed_sector_sum += bmds->completed_sectors;\n\n        }\n\n    }\n\n\n\n    if (block_mig_state.total_sector_sum != 0) {\n\n        progress = completed_sector_sum * 100 /\n\n                   block_mig_state.total_sector_sum;\n\n    } else {\n\n        progress = 100;\n\n    }\n\n    if (progress != block_mig_state.prev_progress) {\n\n        block_mig_state.prev_progress = progress;\n\n        qemu_put_be64(f, (progress << BDRV_SECTOR_BITS)\n\n                         | BLK_MIG_FLAG_PROGRESS);\n\n        monitor_printf(mon, \"Completed %d %%\\r\", progress);\n\n        monitor_flush(mon);\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 23233}
{"project": "qemu", "commit_id": "46746dbaa8c2c421b9bda78193caad57d7fb1136", "target": 0, "func": "static void vfio_msi_enable(VFIOPCIDevice *vdev)\n\n{\n\n    int ret, i;\n\n\n\n    vfio_disable_interrupts(vdev);\n\n\n\n    vdev->nr_vectors = msi_nr_vectors_allocated(&vdev->pdev);\n\nretry:\n\n    vdev->msi_vectors = g_malloc0(vdev->nr_vectors * sizeof(VFIOMSIVector));\n\n\n\n    for (i = 0; i < vdev->nr_vectors; i++) {\n\n        VFIOMSIVector *vector = &vdev->msi_vectors[i];\n\n        MSIMessage msg = msi_get_message(&vdev->pdev, i);\n\n\n\n        vector->vdev = vdev;\n\n        vector->virq = -1;\n\n        vector->use = true;\n\n\n\n        if (event_notifier_init(&vector->interrupt, 0)) {\n\n            error_report(\"vfio: Error: event_notifier_init failed\");\n\n        }\n\n\n\n        qemu_set_fd_handler(event_notifier_get_fd(&vector->interrupt),\n\n                            vfio_msi_interrupt, NULL, vector);\n\n\n\n        /*\n\n         * Attempt to enable route through KVM irqchip,\n\n         * default to userspace handling if unavailable.\n\n         */\n\n        vfio_add_kvm_msi_virq(vector, &msg, false);\n\n    }\n\n\n\n    /* Set interrupt type prior to possible interrupts */\n\n    vdev->interrupt = VFIO_INT_MSI;\n\n\n\n    ret = vfio_enable_vectors(vdev, false);\n\n    if (ret) {\n\n        if (ret < 0) {\n\n            error_report(\"vfio: Error: Failed to setup MSI fds: %m\");\n\n        } else if (ret != vdev->nr_vectors) {\n\n            error_report(\"vfio: Error: Failed to enable %d \"\n\n                         \"MSI vectors, retry with %d\", vdev->nr_vectors, ret);\n\n        }\n\n\n\n        for (i = 0; i < vdev->nr_vectors; i++) {\n\n            VFIOMSIVector *vector = &vdev->msi_vectors[i];\n\n            if (vector->virq >= 0) {\n\n                vfio_remove_kvm_msi_virq(vector);\n\n            }\n\n            qemu_set_fd_handler(event_notifier_get_fd(&vector->interrupt),\n\n                                NULL, NULL, NULL);\n\n            event_notifier_cleanup(&vector->interrupt);\n\n        }\n\n\n\n        g_free(vdev->msi_vectors);\n\n\n\n        if (ret > 0 && ret != vdev->nr_vectors) {\n\n            vdev->nr_vectors = ret;\n\n            goto retry;\n\n        }\n\n        vdev->nr_vectors = 0;\n\n\n\n        /*\n\n         * Failing to setup MSI doesn't really fall within any specification.\n\n         * Let's try leaving interrupts disabled and hope the guest figures\n\n         * out to fall back to INTx for this device.\n\n         */\n\n        error_report(\"vfio: Error: Failed to enable MSI\");\n\n        vdev->interrupt = VFIO_INT_NONE;\n\n\n\n        return;\n\n    }\n\n\n\n    trace_vfio_msi_enable(vdev->vbasedev.name, vdev->nr_vectors);\n\n}\n", "idx": 23234}
{"project": "qemu", "commit_id": "0e9b9edae7bebfd31fdbead4ccbbce03876a7edd", "target": 0, "func": "build_madt(GArray *table_data, GArray *linker, VirtGuestInfo *guest_info)\n\n{\n\n    int madt_start = table_data->len;\n\n    const MemMapEntry *memmap = guest_info->memmap;\n\n    const int *irqmap = guest_info->irqmap;\n\n    AcpiMultipleApicTable *madt;\n\n    AcpiMadtGenericDistributor *gicd;\n\n    AcpiMadtGenericMsiFrame *gic_msi;\n\n    int i;\n\n\n\n    madt = acpi_data_push(table_data, sizeof *madt);\n\n\n\n    gicd = acpi_data_push(table_data, sizeof *gicd);\n\n    gicd->type = ACPI_APIC_GENERIC_DISTRIBUTOR;\n\n    gicd->length = sizeof(*gicd);\n\n    gicd->base_address = memmap[VIRT_GIC_DIST].base;\n\n\n\n    for (i = 0; i < guest_info->smp_cpus; i++) {\n\n        AcpiMadtGenericInterrupt *gicc = acpi_data_push(table_data,\n\n                                                     sizeof *gicc);\n\n        ARMCPU *armcpu = ARM_CPU(qemu_get_cpu(i));\n\n\n\n        gicc->type = ACPI_APIC_GENERIC_INTERRUPT;\n\n        gicc->length = sizeof(*gicc);\n\n        if (guest_info->gic_version == 2) {\n\n            gicc->base_address = memmap[VIRT_GIC_CPU].base;\n\n        }\n\n        gicc->cpu_interface_number = i;\n\n        gicc->arm_mpidr = armcpu->mp_affinity;\n\n        gicc->uid = i;\n\n        gicc->flags = cpu_to_le32(ACPI_GICC_ENABLED);\n\n    }\n\n\n\n    if (guest_info->gic_version == 3) {\n\n        AcpiMadtGenericRedistributor *gicr = acpi_data_push(table_data,\n\n                                                         sizeof *gicr);\n\n\n\n        gicr->type = ACPI_APIC_GENERIC_REDISTRIBUTOR;\n\n        gicr->length = sizeof(*gicr);\n\n        gicr->base_address = cpu_to_le64(memmap[VIRT_GIC_REDIST].base);\n\n        gicr->range_length = cpu_to_le32(memmap[VIRT_GIC_REDIST].size);\n\n    } else {\n\n        gic_msi = acpi_data_push(table_data, sizeof *gic_msi);\n\n        gic_msi->type = ACPI_APIC_GENERIC_MSI_FRAME;\n\n        gic_msi->length = sizeof(*gic_msi);\n\n        gic_msi->gic_msi_frame_id = 0;\n\n        gic_msi->base_address = cpu_to_le64(memmap[VIRT_GIC_V2M].base);\n\n        gic_msi->flags = cpu_to_le32(1);\n\n        gic_msi->spi_count = cpu_to_le16(NUM_GICV2M_SPIS);\n\n        gic_msi->spi_base = cpu_to_le16(irqmap[VIRT_GIC_V2M] + ARM_SPI_BASE);\n\n    }\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)(table_data->data + madt_start), \"APIC\",\n\n                 table_data->len - madt_start, 3, NULL, NULL);\n\n}\n", "idx": 23235}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void stl_phys_notdirty(target_phys_addr_t addr, uint32_t val)\n\n{\n\n    uint8_t *ptr;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);\n\n\n\n    if (!memory_region_is_ram(section->mr) || section->readonly) {\n\n        addr = memory_region_section_addr(section, addr);\n\n        if (memory_region_is_ram(section->mr)) {\n\n            section = &phys_sections[phys_section_rom];\n\n        }\n\n        io_mem_write(section->mr, addr, val, 4);\n\n    } else {\n\n        unsigned long addr1 = (memory_region_get_ram_addr(section->mr)\n\n                               & TARGET_PAGE_MASK)\n\n            + memory_region_section_addr(section, addr);\n\n        ptr = qemu_get_ram_ptr(addr1);\n\n        stl_p(ptr, val);\n\n\n\n        if (unlikely(in_migration)) {\n\n            if (!cpu_physical_memory_is_dirty(addr1)) {\n\n                /* invalidate code */\n\n                tb_invalidate_phys_page_range(addr1, addr1 + 4, 0);\n\n                /* set dirty bit */\n\n                cpu_physical_memory_set_dirty_flags(\n\n                    addr1, (0xff & ~CODE_DIRTY_FLAG));\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 23236}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "static void kqemu_record_flush(void)\n\n{\n\n    PCRecord *r, *r_next;\n\n    int h;\n\n\n\n    for(h = 0; h < PC_REC_HASH_SIZE; h++) {\n\n        for(r = pc_rec_hash[h]; r != NULL; r = r_next) {\n\n            r_next = r->next;\n\n            free(r);\n\n        }\n\n        pc_rec_hash[h] = NULL;\n\n    }\n\n    nb_pc_records = 0;\n\n}\n", "idx": 23237}
{"project": "qemu", "commit_id": "8ec14402029d783720f4312ed8a925548e1dad61", "target": 0, "func": "static void compare_pri_rs_finalize(SocketReadState *pri_rs)\n\n{\n\n    CompareState *s = container_of(pri_rs, CompareState, pri_rs);\n\n\n\n    if (packet_enqueue(s, PRIMARY_IN)) {\n\n        trace_colo_compare_main(\"primary: unsupported packet in\");\n\n        compare_chr_send(s,\n\n                         pri_rs->buf,\n\n                         pri_rs->packet_len,\n\n                         pri_rs->vnet_hdr_len);\n\n    } else {\n\n        /* compare connection */\n\n        g_queue_foreach(&s->conn_list, colo_compare_connection, s);\n\n    }\n\n}\n", "idx": 23238}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoul_overflow(void)\n\n{\n\n    const char *str = \"99999999999999999999999999999999999999999999\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoul(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, -ERANGE);\n\n    g_assert_cmpint(res, ==, ULONG_MAX);\n\n    g_assert(endptr == str + strlen(str));\n\n}\n", "idx": 23240}
{"project": "qemu", "commit_id": "036f7166c73a9e0cc1b2f10c03763e61894a1033", "target": 0, "func": "int qdev_prop_parse(DeviceState *dev, const char *name, const char *value)\n\n{\n\n    Property *prop;\n\n    int ret;\n\n\n\n    prop = qdev_prop_find(dev, name);\n\n    if (!prop) {\n\n        fprintf(stderr, \"property \\\"%s.%s\\\" not found\\n\",\n\n                dev->info->name, name);\n\n        return -1;\n\n    }\n\n    if (!prop->info->parse) {\n\n        fprintf(stderr, \"property \\\"%s.%s\\\" has no parser\\n\",\n\n                dev->info->name, name);\n\n        return -1;\n\n    }\n\n    ret = prop->info->parse(dev, prop, value);\n\n    if (ret < 0) {\n\n        switch (ret) {\n\n        case -EEXIST:\n\n            fprintf(stderr, \"property \\\"%s.%s\\\": \\\"%s\\\" is already in use\\n\",\n\n                    dev->info->name, name, value);\n\n            break;\n\n        default:\n\n        case -EINVAL:\n\n            fprintf(stderr, \"property \\\"%s.%s\\\": failed to parse \\\"%s\\\"\\n\",\n\n                    dev->info->name, name, value);\n\n            break;\n\n        case -ENOENT:\n\n            fprintf(stderr, \"property \\\"%s.%s\\\": could not find \\\"%s\\\"\\n\",\n\n                    dev->info->name, name, value);\n\n            break;\n\n        }\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 23241}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "uint32_t ldub_phys(target_phys_addr_t addr)\n\n{\n\n    uint8_t val;\n\n    cpu_physical_memory_read(addr, &val, 1);\n\n    return val;\n\n}\n", "idx": 23242}
{"project": "qemu", "commit_id": "b8e9fc0625c49404d63b4391f6dc5cf27be8b45b", "target": 0, "func": "static int get_physical_address_data(CPUState *env,\n\n                                     target_phys_addr_t *physical, int *prot,\n\n                                     target_ulong address, int rw, int mmu_idx)\n\n{\n\n    unsigned int i;\n\n    uint64_t context;\n\n\n\n    int is_user = (mmu_idx == MMU_USER_IDX ||\n\n                   mmu_idx == MMU_USER_SECONDARY_IDX);\n\n\n\n    if ((env->lsu & DMMU_E) == 0) { /* DMMU disabled */\n\n        *physical = ultrasparc_truncate_physical(address);\n\n        *prot = PAGE_READ | PAGE_WRITE;\n\n        return 0;\n\n    }\n\n\n\n    switch(mmu_idx) {\n\n    case MMU_USER_IDX:\n\n    case MMU_KERNEL_IDX:\n\n        context = env->dmmu.mmu_primary_context & 0x1fff;\n\n        break;\n\n    case MMU_USER_SECONDARY_IDX:\n\n    case MMU_KERNEL_SECONDARY_IDX:\n\n        context = env->dmmu.mmu_secondary_context & 0x1fff;\n\n        break;\n\n    case MMU_NUCLEUS_IDX:\n\n    default:\n\n        context = 0;\n\n        break;\n\n    }\n\n\n\n    for (i = 0; i < 64; i++) {\n\n        // ctx match, vaddr match, valid?\n\n        if (ultrasparc_tag_match(&env->dtlb[i],\n\n                                 address, context, physical)) {\n\n            // access ok?\n\n            if (((env->dtlb[i].tte & 0x4) && is_user) ||\n\n                (!(env->dtlb[i].tte & 0x2) && (rw == 1))) {\n\n                uint8_t fault_type = 0;\n\n\n\n                if ((env->dtlb[i].tte & 0x4) && is_user) {\n\n                    fault_type |= 1; /* privilege violation */\n\n                }\n\n\n\n                if (env->dmmu.sfsr & 1) /* Fault status register */\n\n                    env->dmmu.sfsr = 2; /* overflow (not read before\n\n                                             another fault) */\n\n\n\n                env->dmmu.sfsr |= (is_user << 3) | ((rw == 1) << 2) | 1;\n\n\n\n                env->dmmu.sfsr |= (fault_type << 7);\n\n\n\n                env->dmmu.sfar = address; /* Fault address register */\n\n                env->exception_index = TT_DFAULT;\n\n#ifdef DEBUG_MMU\n\n                printf(\"DFAULT at 0x%\" PRIx64 \"\\n\", address);\n\n#endif\n\n                return 1;\n\n            }\n\n            *prot = PAGE_READ;\n\n            if (env->dtlb[i].tte & 0x2)\n\n                *prot |= PAGE_WRITE;\n\n            TTE_SET_USED(env->dtlb[i].tte);\n\n            return 0;\n\n        }\n\n    }\n\n#ifdef DEBUG_MMU\n\n    printf(\"DMISS at 0x%\" PRIx64 \"\\n\", address);\n\n#endif\n\n    env->dmmu.tag_access = (address & ~0x1fffULL) | context;\n\n    env->exception_index = TT_DMISS;\n\n    return 1;\n\n}\n", "idx": 23243}
{"project": "qemu", "commit_id": "e1123a3b40a1a9a625a29c8ed4debb7e206ea690", "target": 0, "func": "static void iscsi_allocationmap_set(IscsiLun *iscsilun, int64_t sector_num,\n\n                                    int nb_sectors)\n\n{\n\n    int64_t cluster_num, nb_clusters;\n\n    if (iscsilun->allocationmap == NULL) {\n\n        return;\n\n    }\n\n    cluster_num = sector_num / iscsilun->cluster_sectors;\n\n    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,\n\n                               iscsilun->cluster_sectors) - cluster_num;\n\n    bitmap_set(iscsilun->allocationmap, cluster_num, nb_clusters);\n\n}\n", "idx": 23244}
{"project": "qemu", "commit_id": "e511b4d783c47a32420da802104cfb0eb974b22f", "target": 0, "func": "int cpu_exec(CPUArchState *env)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(env);\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n#ifdef TARGET_I386\n\n    X86CPU *x86_cpu = X86_CPU(cpu);\n\n#endif\n\n    int ret, interrupt_request;\n\n    TranslationBlock *tb;\n\n    uint8_t *tc_ptr;\n\n    uintptr_t next_tb;\n\n    SyncClocks sc;\n\n\n\n    /* This must be volatile so it is not trashed by longjmp() */\n\n    volatile bool have_tb_lock = false;\n\n\n\n    if (cpu->halted) {\n\n        if (!cpu_has_work(cpu)) {\n\n            return EXCP_HALTED;\n\n        }\n\n\n\n        cpu->halted = 0;\n\n    }\n\n\n\n    current_cpu = cpu;\n\n\n\n    /* As long as current_cpu is null, up to the assignment just above,\n\n     * requests by other threads to exit the execution loop are expected to\n\n     * be issued using the exit_request global. We must make sure that our\n\n     * evaluation of the global value is performed past the current_cpu\n\n     * value transition point, which requires a memory barrier as well as\n\n     * an instruction scheduling constraint on modern architectures.  */\n\n    smp_mb();\n\n\n\n    if (unlikely(exit_request)) {\n\n        cpu->exit_request = 1;\n\n    }\n\n\n\n    cc->cpu_exec_enter(cpu);\n\n    cpu->exception_index = -1;\n\n\n\n    /* Calculate difference between guest clock and host clock.\n\n     * This delay includes the delay of the last cycle, so\n\n     * what we have to do is sleep until it is 0. As for the\n\n     * advance/delay we gain here, we try to fix it next time.\n\n     */\n\n    init_delay_params(&sc, cpu);\n\n\n\n    /* prepare setjmp context for exception handling */\n\n    for(;;) {\n\n        if (sigsetjmp(cpu->jmp_env, 0) == 0) {\n\n            /* if an exception is pending, we execute it here */\n\n            if (cpu->exception_index >= 0) {\n\n                if (cpu->exception_index >= EXCP_INTERRUPT) {\n\n                    /* exit request from the cpu execution loop */\n\n                    ret = cpu->exception_index;\n\n                    if (ret == EXCP_DEBUG) {\n\n                        cpu_handle_debug_exception(env);\n\n                    }\n\n                    break;\n\n                } else {\n\n#if defined(CONFIG_USER_ONLY)\n\n                    /* if user mode only, we simulate a fake exception\n\n                       which will be handled outside the cpu execution\n\n                       loop */\n\n#if defined(TARGET_I386)\n\n                    cc->do_interrupt(cpu);\n\n#endif\n\n                    ret = cpu->exception_index;\n\n                    break;\n\n#else\n\n                    cc->do_interrupt(cpu);\n\n                    cpu->exception_index = -1;\n\n#endif\n\n                }\n\n            }\n\n\n\n            next_tb = 0; /* force lookup of first TB */\n\n            for(;;) {\n\n                interrupt_request = cpu->interrupt_request;\n\n                if (unlikely(interrupt_request)) {\n\n                    if (unlikely(cpu->singlestep_enabled & SSTEP_NOIRQ)) {\n\n                        /* Mask out external interrupts for this step. */\n\n                        interrupt_request &= ~CPU_INTERRUPT_SSTEP_MASK;\n\n                    }\n\n                    if (interrupt_request & CPU_INTERRUPT_DEBUG) {\n\n                        cpu->interrupt_request &= ~CPU_INTERRUPT_DEBUG;\n\n                        cpu->exception_index = EXCP_DEBUG;\n\n                        cpu_loop_exit(cpu);\n\n                    }\n\n                    if (interrupt_request & CPU_INTERRUPT_HALT) {\n\n                        cpu->interrupt_request &= ~CPU_INTERRUPT_HALT;\n\n                        cpu->halted = 1;\n\n                        cpu->exception_index = EXCP_HLT;\n\n                        cpu_loop_exit(cpu);\n\n                    }\n\n#if defined(TARGET_I386)\n\n                    if (interrupt_request & CPU_INTERRUPT_INIT) {\n\n                        cpu_svm_check_intercept_param(env, SVM_EXIT_INIT, 0);\n\n                        do_cpu_init(x86_cpu);\n\n                        cpu->exception_index = EXCP_HALTED;\n\n                        cpu_loop_exit(cpu);\n\n                    }\n\n#else\n\n                    if (interrupt_request & CPU_INTERRUPT_RESET) {\n\n                        cpu_reset(cpu);\n\n                    }\n\n#endif\n\n                    /* The target hook has 3 exit conditions:\n\n                       False when the interrupt isn't processed,\n\n                       True when it is, and we should restart on a new TB,\n\n                       and via longjmp via cpu_loop_exit.  */\n\n                    if (cc->cpu_exec_interrupt(cpu, interrupt_request)) {\n\n                        next_tb = 0;\n\n                    }\n\n                    /* Don't use the cached interrupt_request value,\n\n                       do_interrupt may have updated the EXITTB flag. */\n\n                    if (cpu->interrupt_request & CPU_INTERRUPT_EXITTB) {\n\n                        cpu->interrupt_request &= ~CPU_INTERRUPT_EXITTB;\n\n                        /* ensure that no TB jump will be modified as\n\n                           the program flow was changed */\n\n                        next_tb = 0;\n\n                    }\n\n                }\n\n                if (unlikely(cpu->exit_request)) {\n\n                    cpu->exit_request = 0;\n\n                    cpu->exception_index = EXCP_INTERRUPT;\n\n                    cpu_loop_exit(cpu);\n\n                }\n\n                spin_lock(&tcg_ctx.tb_ctx.tb_lock);\n\n                have_tb_lock = true;\n\n                tb = tb_find_fast(env);\n\n                /* Note: we do it here to avoid a gcc bug on Mac OS X when\n\n                   doing it in tb_find_slow */\n\n                if (tcg_ctx.tb_ctx.tb_invalidated_flag) {\n\n                    /* as some TB could have been invalidated because\n\n                       of memory exceptions while generating the code, we\n\n                       must recompute the hash index here */\n\n                    next_tb = 0;\n\n                    tcg_ctx.tb_ctx.tb_invalidated_flag = 0;\n\n                }\n\n                if (qemu_loglevel_mask(CPU_LOG_EXEC)) {\n\n                    qemu_log(\"Trace %p [\" TARGET_FMT_lx \"] %s\\n\",\n\n                             tb->tc_ptr, tb->pc, lookup_symbol(tb->pc));\n\n                }\n\n                /* see if we can patch the calling TB. When the TB\n\n                   spans two pages, we cannot safely do a direct\n\n                   jump. */\n\n                if (next_tb != 0 && tb->page_addr[1] == -1) {\n\n                    tb_add_jump((TranslationBlock *)(next_tb & ~TB_EXIT_MASK),\n\n                                next_tb & TB_EXIT_MASK, tb);\n\n                }\n\n                have_tb_lock = false;\n\n                spin_unlock(&tcg_ctx.tb_ctx.tb_lock);\n\n\n\n                /* cpu_interrupt might be called while translating the\n\n                   TB, but before it is linked into a potentially\n\n                   infinite loop and becomes env->current_tb. Avoid\n\n                   starting execution if there is a pending interrupt. */\n\n                cpu->current_tb = tb;\n\n                barrier();\n\n                if (likely(!cpu->exit_request)) {\n\n                    trace_exec_tb(tb, tb->pc);\n\n                    tc_ptr = tb->tc_ptr;\n\n                    /* execute the generated code */\n\n                    next_tb = cpu_tb_exec(cpu, tc_ptr);\n\n                    switch (next_tb & TB_EXIT_MASK) {\n\n                    case TB_EXIT_REQUESTED:\n\n                        /* Something asked us to stop executing\n\n                         * chained TBs; just continue round the main\n\n                         * loop. Whatever requested the exit will also\n\n                         * have set something else (eg exit_request or\n\n                         * interrupt_request) which we will handle\n\n                         * next time around the loop.\n\n                         */\n\n                        tb = (TranslationBlock *)(next_tb & ~TB_EXIT_MASK);\n\n                        next_tb = 0;\n\n                        break;\n\n                    case TB_EXIT_ICOUNT_EXPIRED:\n\n                    {\n\n                        /* Instruction counter expired.  */\n\n                        int insns_left;\n\n                        tb = (TranslationBlock *)(next_tb & ~TB_EXIT_MASK);\n\n                        insns_left = cpu->icount_decr.u32;\n\n                        if (cpu->icount_extra && insns_left >= 0) {\n\n                            /* Refill decrementer and continue execution.  */\n\n                            cpu->icount_extra += insns_left;\n\n                            if (cpu->icount_extra > 0xffff) {\n\n                                insns_left = 0xffff;\n\n                            } else {\n\n                                insns_left = cpu->icount_extra;\n\n                            }\n\n                            cpu->icount_extra -= insns_left;\n\n                            cpu->icount_decr.u16.low = insns_left;\n\n                        } else {\n\n                            if (insns_left > 0) {\n\n                                /* Execute remaining instructions.  */\n\n                                cpu_exec_nocache(env, insns_left, tb);\n\n                                align_clocks(&sc, cpu);\n\n                            }\n\n                            cpu->exception_index = EXCP_INTERRUPT;\n\n                            next_tb = 0;\n\n                            cpu_loop_exit(cpu);\n\n                        }\n\n                        break;\n\n                    }\n\n                    default:\n\n                        break;\n\n                    }\n\n                }\n\n                cpu->current_tb = NULL;\n\n                /* Try to align the host and virtual clocks\n\n                   if the guest is in advance */\n\n                align_clocks(&sc, cpu);\n\n                /* reset soft MMU for next block (it can currently\n\n                   only be set by a memory fault) */\n\n            } /* for(;;) */\n\n        } else {\n\n            /* Reload env after longjmp - the compiler may have smashed all\n\n             * local variables as longjmp is marked 'noreturn'. */\n\n            cpu = current_cpu;\n\n            env = cpu->env_ptr;\n\n            cc = CPU_GET_CLASS(cpu);\n\n#ifdef TARGET_I386\n\n            x86_cpu = X86_CPU(cpu);\n\n#endif\n\n            if (have_tb_lock) {\n\n                spin_unlock(&tcg_ctx.tb_ctx.tb_lock);\n\n                have_tb_lock = false;\n\n            }\n\n        }\n\n    } /* for(;;) */\n\n\n\n    cc->cpu_exec_exit(cpu);\n\n\n\n    /* fail safe : never use current_cpu outside cpu_exec() */\n\n    current_cpu = NULL;\n\n    return ret;\n\n}\n", "idx": 23245}
{"project": "qemu", "commit_id": "5834a83f4803de88949162346e6dfa2060d3fca6", "target": 0, "func": "static void vfio_pci_reset(DeviceState *dev)\n\n{\n\n    PCIDevice *pdev = DO_UPCAST(PCIDevice, qdev, dev);\n\n    VFIODevice *vdev = DO_UPCAST(VFIODevice, pdev, pdev);\n\n\n\n    if (!vdev->reset_works) {\n\n        return;\n\n    }\n\n\n\n    if (ioctl(vdev->fd, VFIO_DEVICE_RESET)) {\n\n        error_report(\"vfio: Error unable to reset physical device \"\n\n                     \"(%04x:%02x:%02x.%x): %m\\n\", vdev->host.domain,\n\n                     vdev->host.bus, vdev->host.slot, vdev->host.function);\n\n    }\n\n}\n", "idx": 23246}
{"project": "qemu", "commit_id": "f17fd4fdf0df3d2f3444399d04c38d22b9a3e1b7", "target": 0, "func": "static void test_qemu_strtosz_metric(void)\n\n{\n\n    const char *str = \"12345k\";\n\n    char *endptr = NULL;\n\n    int64_t res;\n\n\n\n    res = qemu_strtosz_metric(str, &endptr);\n\n    g_assert_cmpint(res, ==, 12345000);\n\n    g_assert(endptr == str + 6);\n\n}\n", "idx": 23247}
{"project": "qemu", "commit_id": "3468b59e18b179bc63c7ce934de912dfa9596122", "target": 0, "func": "void tcg_profile_snapshot(TCGProfile *prof, bool counters, bool table)\n\n{\n\n    unsigned int i;\n\n\n\n    for (i = 0; i < n_tcg_ctxs; i++) {\n\n        const TCGProfile *orig = &tcg_ctxs[i]->prof;\n\n\n\n        if (counters) {\n\n            PROF_ADD(prof, orig, tb_count1);\n\n            PROF_ADD(prof, orig, tb_count);\n\n            PROF_ADD(prof, orig, op_count);\n\n            PROF_MAX(prof, orig, op_count_max);\n\n            PROF_ADD(prof, orig, temp_count);\n\n            PROF_MAX(prof, orig, temp_count_max);\n\n            PROF_ADD(prof, orig, del_op_count);\n\n            PROF_ADD(prof, orig, code_in_len);\n\n            PROF_ADD(prof, orig, code_out_len);\n\n            PROF_ADD(prof, orig, search_out_len);\n\n            PROF_ADD(prof, orig, interm_time);\n\n            PROF_ADD(prof, orig, code_time);\n\n            PROF_ADD(prof, orig, la_time);\n\n            PROF_ADD(prof, orig, opt_time);\n\n            PROF_ADD(prof, orig, restore_count);\n\n            PROF_ADD(prof, orig, restore_time);\n\n        }\n\n        if (table) {\n\n            int i;\n\n\n\n            for (i = 0; i < NB_OPS; i++) {\n\n                PROF_ADD(prof, orig, table_op_count[i]);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 23248}
{"project": "qemu", "commit_id": "77a10d04d033484a913a5ee76eed31a9acc57bae", "target": 1, "func": "static void vfio_exitfn(PCIDevice *pdev)\n\n{\n\n    VFIOPCIDevice *vdev = DO_UPCAST(VFIOPCIDevice, pdev, pdev);\n\n    VFIOGroup *group = vdev->vbasedev.group;\n\n\n\n    vfio_unregister_err_notifier(vdev);\n\n    pci_device_set_intx_routing_notifier(&vdev->pdev, NULL);\n\n    vfio_disable_interrupts(vdev);\n\n    if (vdev->intx.mmap_timer) {\n\n        timer_free(vdev->intx.mmap_timer);\n\n    }\n\n    vfio_teardown_msi(vdev);\n\n    vfio_unmap_bars(vdev);\n\n    g_free(vdev->emulated_config_bits);\n\n    g_free(vdev->rom);\n\n    vfio_put_device(vdev);\n\n    vfio_put_group(group);\n\n}\n", "idx": 23253}
{"project": "qemu", "commit_id": "9366f4186025e1d8fc3bebd41fb714521c170b6f", "target": 1, "func": "int register_savevm(const char *idstr,\n\n                    int instance_id,\n\n                    int version_id,\n\n                    SaveStateHandler *save_state,\n\n                    LoadStateHandler *load_state,\n\n                    void *opaque)\n\n{\n\n    SaveStateEntry *se, **pse;\n\n\n\n    se = qemu_malloc(sizeof(SaveStateEntry));\n\n    if (!se)\n\n        return -1;\n\n    pstrcpy(se->idstr, sizeof(se->idstr), idstr);\n\n    se->instance_id = (instance_id == -1) ? 0 : instance_id;\n\n    se->version_id = version_id;\n\n    se->save_state = save_state;\n\n    se->load_state = load_state;\n\n    se->opaque = opaque;\n\n    se->next = NULL;\n\n\n\n    /* add at the end of list */\n\n    pse = &first_se;\n\n    while (*pse != NULL) {\n\n        if (instance_id == -1\n\n                && strcmp(se->idstr, (*pse)->idstr) == 0\n\n                && se->instance_id <= (*pse)->instance_id)\n\n            se->instance_id = (*pse)->instance_id + 1;\n\n        pse = &(*pse)->next;\n\n    }\n\n    *pse = se;\n\n    return 0;\n\n}\n", "idx": 23274}
{"project": "qemu", "commit_id": "d0bce760e04b1658a3b4ac95be2839ae20fd86db", "target": 1, "func": "I2CAdapter *omap_i2c_create(uint64_t addr)\n\n{\n\n    OMAPI2C *s = g_malloc0(sizeof(*s));\n\n    I2CAdapter *i2c = (I2CAdapter *)s;\n\n    uint16_t data;\n\n\n\n    s->addr = addr;\n\n\n\n    i2c->send = omap_i2c_send;\n\n    i2c->recv = omap_i2c_recv;\n\n\n\n    /* verify the mmio address by looking for a known signature */\n\n    memread(addr + OMAP_I2C_REV, &data, 2);\n\n    g_assert_cmphex(data, ==, 0x34);\n\n\n\n    return i2c;\n\n}\n", "idx": 23275}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void arm_mptimer_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = arm_mptimer_realize;\n\n    dc->vmsd = &vmstate_arm_mptimer;\n\n    dc->reset = arm_mptimer_reset;\n\n    dc->no_user = 1;\n\n    dc->props = arm_mptimer_properties;\n\n}\n", "idx": 23277}
{"project": "qemu", "commit_id": "9745807191a81c45970f780166f44a7f93b18653", "target": 1, "func": "static void gen_ove_cyov(DisasContext *dc, TCGv cy, TCGv ov)\n\n{\n\n    if (dc->tb_flags & SR_OVE) {\n\n        TCGv t0 = tcg_temp_new();\n\n        tcg_gen_or_tl(t0, cy, ov);\n\n        gen_helper_ove(cpu_env, t0);\n\n        tcg_temp_free(t0);\n\n    }\n\n}\n", "idx": 23278}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void put_uint16(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint16_t *v = pv;\n\n    qemu_put_be16s(f, v);\n\n}\n", "idx": 23280}
{"project": "qemu", "commit_id": "071d4054770205ddb8a58a9e2735069d8fe52af1", "target": 1, "func": "void qdist_init(struct qdist *dist)\n\n{\n\n    dist->entries = g_malloc(sizeof(*dist->entries));\n\n    dist->size = 1;\n\n    dist->n = 0;\n\n}\n", "idx": 23288}
{"project": "qemu", "commit_id": "d3392718e1fcf0859fb7c0774a8e946bacb8419c", "target": 1, "func": "void arm_v7m_cpu_do_interrupt(CPUState *cs)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(cs);\n\n    CPUARMState *env = &cpu->env;\n\n    uint32_t lr;\n\n\n\n    arm_log_exception(cs->exception_index);\n\n\n\n    /* For exceptions we just mark as pending on the NVIC, and let that\n\n       handle it.  */\n\n    switch (cs->exception_index) {\n\n    case EXCP_UDEF:\n\n        armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_USAGE, env->v7m.secure);\n\n        env->v7m.cfsr[env->v7m.secure] |= R_V7M_CFSR_UNDEFINSTR_MASK;\n\n        break;\n\n    case EXCP_NOCP:\n\n        armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_USAGE, env->v7m.secure);\n\n        env->v7m.cfsr[env->v7m.secure] |= R_V7M_CFSR_NOCP_MASK;\n\n        break;\n\n    case EXCP_INVSTATE:\n\n        armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_USAGE, env->v7m.secure);\n\n        env->v7m.cfsr[env->v7m.secure] |= R_V7M_CFSR_INVSTATE_MASK;\n\n        break;\n\n    case EXCP_SWI:\n\n        /* The PC already points to the next instruction.  */\n\n        armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_SVC, env->v7m.secure);\n\n        break;\n\n    case EXCP_PREFETCH_ABORT:\n\n    case EXCP_DATA_ABORT:\n\n        /* Note that for M profile we don't have a guest facing FSR, but\n\n         * the env->exception.fsr will be populated by the code that\n\n         * raises the fault, in the A profile short-descriptor format.\n\n         */\n\n        switch (env->exception.fsr & 0xf) {\n\n        case 0x8: /* External Abort */\n\n            switch (cs->exception_index) {\n\n            case EXCP_PREFETCH_ABORT:\n\n                env->v7m.cfsr[M_REG_NS] |= R_V7M_CFSR_IBUSERR_MASK;\n\n                qemu_log_mask(CPU_LOG_INT, \"...with CFSR.IBUSERR\\n\");\n\n                break;\n\n            case EXCP_DATA_ABORT:\n\n                env->v7m.cfsr[M_REG_NS] |=\n\n                    (R_V7M_CFSR_PRECISERR_MASK | R_V7M_CFSR_BFARVALID_MASK);\n\n                env->v7m.bfar = env->exception.vaddress;\n\n                qemu_log_mask(CPU_LOG_INT,\n\n                              \"...with CFSR.PRECISERR and BFAR 0x%x\\n\",\n\n                              env->v7m.bfar);\n\n                break;\n\n            }\n\n            armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_BUS, false);\n\n            break;\n\n        default:\n\n            /* All other FSR values are either MPU faults or \"can't happen\n\n             * for M profile\" cases.\n\n             */\n\n            switch (cs->exception_index) {\n\n            case EXCP_PREFETCH_ABORT:\n\n                env->v7m.cfsr[env->v7m.secure] |= R_V7M_CFSR_IACCVIOL_MASK;\n\n                qemu_log_mask(CPU_LOG_INT, \"...with CFSR.IACCVIOL\\n\");\n\n                break;\n\n            case EXCP_DATA_ABORT:\n\n                env->v7m.cfsr[env->v7m.secure] |=\n\n                    (R_V7M_CFSR_DACCVIOL_MASK | R_V7M_CFSR_MMARVALID_MASK);\n\n                env->v7m.mmfar[env->v7m.secure] = env->exception.vaddress;\n\n                qemu_log_mask(CPU_LOG_INT,\n\n                              \"...with CFSR.DACCVIOL and MMFAR 0x%x\\n\",\n\n                              env->v7m.mmfar[env->v7m.secure]);\n\n                break;\n\n            }\n\n            armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_MEM,\n\n                                    env->v7m.secure);\n\n            break;\n\n        }\n\n        break;\n\n    case EXCP_BKPT:\n\n        if (semihosting_enabled()) {\n\n            int nr;\n\n            nr = arm_lduw_code(env, env->regs[15], arm_sctlr_b(env)) & 0xff;\n\n            if (nr == 0xab) {\n\n                env->regs[15] += 2;\n\n                qemu_log_mask(CPU_LOG_INT,\n\n                              \"...handling as semihosting call 0x%x\\n\",\n\n                              env->regs[0]);\n\n                env->regs[0] = do_arm_semihosting(env);\n\n                return;\n\n            }\n\n        }\n\n        armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_DEBUG, false);\n\n        break;\n\n    case EXCP_IRQ:\n\n        break;\n\n    case EXCP_EXCEPTION_EXIT:\n\n        do_v7m_exception_exit(cpu);\n\n        return;\n\n    default:\n\n        cpu_abort(cs, \"Unhandled exception 0x%x\\n\", cs->exception_index);\n\n        return; /* Never happens.  Keep compiler happy.  */\n\n    }\n\n\n\n    lr = R_V7M_EXCRET_RES1_MASK |\n\n        R_V7M_EXCRET_S_MASK |\n\n        R_V7M_EXCRET_DCRS_MASK |\n\n        R_V7M_EXCRET_FTYPE_MASK |\n\n        R_V7M_EXCRET_ES_MASK;\n\n    if (env->v7m.control[env->v7m.secure] & R_V7M_CONTROL_SPSEL_MASK) {\n\n        lr |= R_V7M_EXCRET_SPSEL_MASK;\n\n    }\n\n    if (!arm_v7m_is_handler_mode(env)) {\n\n        lr |= R_V7M_EXCRET_MODE_MASK;\n\n    }\n\n\n\n    v7m_push_stack(cpu);\n\n    v7m_exception_taken(cpu, lr);\n\n    qemu_log_mask(CPU_LOG_INT, \"... as %d\\n\", env->v7m.exception);\n\n}\n", "idx": 23289}
{"project": "qemu", "commit_id": "563890c7c7e977842e2a35afe7a24d06d2103242", "target": 1, "func": "static void socket_sendf(int fd, const char *fmt, va_list ap)\n\n{\n\n    gchar *str;\n\n    size_t size, offset;\n\n\n\n    str = g_strdup_vprintf(fmt, ap);\n\n    size = strlen(str);\n\n\n\n    offset = 0;\n\n    while (offset < size) {\n\n        ssize_t len;\n\n\n\n        len = write(fd, str + offset, size - offset);\n\n        if (len == -1 && errno == EINTR) {\n\n            continue;\n\n        }\n\n\n\n        g_assert_no_errno(len);\n\n        g_assert_cmpint(len, >, 0);\n\n\n\n        offset += len;\n\n    }\n\n}\n", "idx": 23290}
{"project": "qemu", "commit_id": "04097f7c5957273c578f72b9bd603ba6b1d69e33", "target": 1, "func": "int vhost_dev_init(struct vhost_dev *hdev, int devfd, bool force)\n\n{\n\n    uint64_t features;\n\n    int r;\n\n    if (devfd >= 0) {\n\n        hdev->control = devfd;\n\n    } else {\n\n        hdev->control = open(\"/dev/vhost-net\", O_RDWR);\n\n        if (hdev->control < 0) {\n\n            return -errno;\n\n        }\n\n    }\n\n    r = ioctl(hdev->control, VHOST_SET_OWNER, NULL);\n\n    if (r < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    r = ioctl(hdev->control, VHOST_GET_FEATURES, &features);\n\n    if (r < 0) {\n\n        goto fail;\n\n    }\n\n    hdev->features = features;\n\n\n\n    hdev->client.set_memory = vhost_client_set_memory;\n\n    hdev->client.sync_dirty_bitmap = vhost_client_sync_dirty_bitmap;\n\n    hdev->client.migration_log = vhost_client_migration_log;\n\n    hdev->client.log_start = NULL;\n\n    hdev->client.log_stop = NULL;\n\n    hdev->mem = g_malloc0(offsetof(struct vhost_memory, regions));\n\n    hdev->log = NULL;\n\n    hdev->log_size = 0;\n\n    hdev->log_enabled = false;\n\n    hdev->started = false;\n\n    cpu_register_phys_memory_client(&hdev->client);\n\n    hdev->force = force;\n\n    return 0;\n\nfail:\n\n    r = -errno;\n\n    close(hdev->control);\n\n    return r;\n\n}\n", "idx": 23291}
{"project": "qemu", "commit_id": "b5e85329026115b5a679849f45e7c19c2714e4fd", "target": 1, "func": "uint32_t HELPER(tprot)(CPUS390XState *env, uint64_t a1, uint64_t a2)\n\n{\n\n    S390CPU *cpu = s390_env_get_cpu(env);\n\n    CPUState *cs = CPU(cpu);\n\n\n\n    /*\n\n     * TODO: we currently don't handle all access protection types\n\n     * (including access-list and key-controlled) as well as AR mode.\n\n     */\n\n    if (!s390_cpu_virt_mem_check_write(cpu, a1, 0, 1)) {\n\n        /* Fetching permitted; storing permitted */\n\n        return 0;\n\n    }\n\n    switch (env->int_pgm_code) {\n\n    case PGM_PROTECTION:\n\n        /* Fetching permitted; storing not permitted */\n\n        cs->exception_index = 0;\n\n        return 1;\n\n    case PGM_ADDRESSING:\n\n        /* Fetching not permitted; storing not permitted */\n\n        cs->exception_index = 0;\n\n        return 2;\n\n    case PGM_ASCE_TYPE:\n\n    case PGM_REG_FIRST_TRANS:\n\n    case PGM_REG_SEC_TRANS:\n\n    case PGM_REG_THIRD_TRANS:\n\n    case PGM_SEGMENT_TRANS:\n\n    case PGM_PAGE_TRANS:\n\n    case PGM_ALET_SPEC:\n\n    case PGM_ALEN_SPEC:\n\n    case PGM_ALE_SEQ:\n\n    case PGM_ASTE_VALID:\n\n    case PGM_ASTE_SEQ:\n\n    case PGM_EXT_AUTH:\n\n        /* Translation not available */\n\n        cs->exception_index = 0;\n\n        return 3;\n\n    }\n\n    /* any other exception is forwarded to the guest */\n\n    s390_cpu_virt_mem_handle_exc(cpu, GETPC());\n\n    return 0;\n\n}\n", "idx": 23292}
{"project": "qemu", "commit_id": "70976a7926b42d87e0c575412b85a8f5c1e48fad", "target": 1, "func": "static int gdb_get_spe_reg(CPUState *env, uint8_t *mem_buf, int n)\n\n{\n\n    if (n < 32) {\n\n#if defined(TARGET_PPC64)\n\n        stl_p(mem_buf, env->gpr[n] >> 32);\n\n#else\n\n        stl_p(mem_buf, env->gprh[n]);\n\n#endif\n\n        return 4;\n\n    }\n\n    if (n == 33) {\n\n        stq_p(mem_buf, env->spe_acc);\n\n        return 8;\n\n    }\n\n    if (n == 34) {\n\n        /* SPEFSCR not implemented */\n\n        memset(mem_buf, 0, 4);\n\n        return 4;\n\n    }\n\n    return 0;\n\n}\n", "idx": 23296}
{"project": "qemu", "commit_id": "8b81bb3b069d4007bc44c8d5888d630b7f0b42ff", "target": 1, "func": "static void virtio_pci_device_unplugged(DeviceState *d)\n\n{\n\n    PCIDevice *pci_dev = PCI_DEVICE(d);\n\n    VirtIOPCIProxy *proxy = VIRTIO_PCI(d);\n\n\n\n    virtio_pci_stop_ioeventfd(proxy);\n\n    msix_uninit_exclusive_bar(pci_dev);\n\n}\n", "idx": 23297}
{"project": "qemu", "commit_id": "77cb0f5aafc8e6d0c6d3c339f381c9b7921648e0", "target": 1, "func": "static int adb_kbd_poll(ADBDevice *d, uint8_t *obuf)\n\n{\n\n    KBDState *s = ADB_KEYBOARD(d);\n\n    int keycode;\n\n    int olen;\n\n\n\n    olen = 0;\n\n    if (s->count == 0) {\n\n        return 0;\n\n    }\n\n    keycode = s->data[s->rptr];\n\n    s->rptr++;\n\n    if (s->rptr == sizeof(s->data)) {\n\n        s->rptr = 0;\n\n    }\n\n    s->count--;\n\n    /*\n\n     * The power key is the only two byte value key, so it is a special case.\n\n     * Since 0x7f is not a used keycode for ADB we overload it to indicate the\n\n     * power button when we're storing keycodes in our internal buffer, and\n\n     * expand it out to two bytes when we send to the guest.\n\n     */\n\n    if (keycode == 0x7f) {\n\n        obuf[0] = 0x7f;\n\n        obuf[1] = 0x7f;\n\n        olen = 2;\n\n    } else {\n\n        obuf[0] = keycode;\n\n        /* NOTE: the power key key-up is the two byte sequence 0xff 0xff;\n\n         * otherwise we could in theory send a second keycode in the second\n\n         * byte, but choose not to bother.\n\n         */\n\n        obuf[1] = 0xff;\n\n        olen = 2;\n\n    }\n\n\n\n    return olen;\n\n}\n", "idx": 23298}
{"project": "qemu", "commit_id": "b36e391441906c36ed0856b69de84001860402bf", "target": 1, "func": "static int virtio_pci_stop_ioeventfd(VirtIOPCIProxy *proxy)\n\n{\n\n    int n;\n\n\n\n    if (!proxy->ioeventfd_started) {\n\n        return 0;\n\n    }\n\n\n\n    for (n = 0; n < VIRTIO_PCI_QUEUE_MAX; n++) {\n\n        if (!virtio_queue_get_num(proxy->vdev, n)) {\n\n            continue;\n\n        }\n\n\n\n        virtio_pci_set_host_notifier_fd_handler(proxy, n, false);\n\n        virtio_pci_set_host_notifier_internal(proxy, n, false);\n\n    }\n\n    proxy->ioeventfd_started = false;\n\n    return 0;\n\n}\n", "idx": 23300}
{"project": "qemu", "commit_id": "94fb0909645de18481cc726ee0ec9b5afa861394", "target": 1, "func": "static int ram_decompress_buf(RamDecompressState *s, uint8_t *buf, int len)\n\n{\n\n    int ret, clen;\n\n\n\n    s->zstream.avail_out = len;\n\n    s->zstream.next_out = buf;\n\n    while (s->zstream.avail_out > 0) {\n\n        if (s->zstream.avail_in == 0) {\n\n            if (qemu_get_be16(s->f) != RAM_CBLOCK_MAGIC)\n\n                return -1;\n\n            clen = qemu_get_be16(s->f);\n\n            if (clen > IOBUF_SIZE)\n\n                return -1;\n\n            qemu_get_buffer(s->f, s->buf, clen);\n\n            s->zstream.avail_in = clen;\n\n            s->zstream.next_in = s->buf;\n\n        }\n\n        ret = inflate(&s->zstream, Z_PARTIAL_FLUSH);\n\n        if (ret != Z_OK && ret != Z_STREAM_END) {\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 23301}
{"project": "qemu", "commit_id": "21ef45d71221b4577330fe3aacfb06afad91ad46", "target": 1, "func": "void gtk_display_init(DisplayState *ds)\n\n{\n\n    GtkDisplayState *s = g_malloc0(sizeof(*s));\n\n\n\n    gtk_init(NULL, NULL);\n\n\n\n    ds->opaque = s;\n\n    s->ds = ds;\n\n    s->dcl.ops = &dcl_ops;\n\n\n\n    s->window = gtk_window_new(GTK_WINDOW_TOPLEVEL);\n\n#if GTK_CHECK_VERSION(3, 2, 0)\n\n    s->vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);\n\n#else\n\n    s->vbox = gtk_vbox_new(FALSE, 0);\n\n#endif\n\n    s->notebook = gtk_notebook_new();\n\n    s->drawing_area = gtk_drawing_area_new();\n\n    s->menu_bar = gtk_menu_bar_new();\n\n\n\n    s->scale_x = 1.0;\n\n    s->scale_y = 1.0;\n\n    s->free_scale = FALSE;\n\n\n\n    setlocale(LC_ALL, \"\");\n\n    bindtextdomain(\"qemu\", CONFIG_QEMU_LOCALEDIR);\n\n    textdomain(\"qemu\");\n\n\n\n    s->null_cursor = gdk_cursor_new(GDK_BLANK_CURSOR);\n\n\n\n    s->mouse_mode_notifier.notify = gd_mouse_mode_change;\n\n    qemu_add_mouse_mode_change_notifier(&s->mouse_mode_notifier);\n\n    qemu_add_vm_change_state_handler(gd_change_runstate, s);\n\n\n\n    gtk_notebook_append_page(GTK_NOTEBOOK(s->notebook), s->drawing_area, gtk_label_new(\"VGA\"));\n\n\n\n    gd_create_menus(s);\n\n\n\n    gd_connect_signals(s);\n\n\n\n    gtk_widget_add_events(s->drawing_area,\n\n                          GDK_POINTER_MOTION_MASK |\n\n                          GDK_BUTTON_PRESS_MASK |\n\n                          GDK_BUTTON_RELEASE_MASK |\n\n                          GDK_BUTTON_MOTION_MASK |\n\n                          GDK_ENTER_NOTIFY_MASK |\n\n                          GDK_LEAVE_NOTIFY_MASK |\n\n                          GDK_SCROLL_MASK |\n\n                          GDK_KEY_PRESS_MASK);\n\n    gtk_widget_set_double_buffered(s->drawing_area, FALSE);\n\n    gtk_widget_set_can_focus(s->drawing_area, TRUE);\n\n\n\n    gtk_notebook_set_show_tabs(GTK_NOTEBOOK(s->notebook), FALSE);\n\n    gtk_notebook_set_show_border(GTK_NOTEBOOK(s->notebook), FALSE);\n\n\n\n    gd_update_caption(s);\n\n\n\n    gtk_box_pack_start(GTK_BOX(s->vbox), s->menu_bar, FALSE, TRUE, 0);\n\n    gtk_box_pack_start(GTK_BOX(s->vbox), s->notebook, TRUE, TRUE, 0);\n\n\n\n    gtk_container_add(GTK_CONTAINER(s->window), s->vbox);\n\n\n\n    gtk_widget_show_all(s->window);\n\n\n\n    register_displaychangelistener(ds, &s->dcl);\n\n\n\n    global_state = s;\n\n}\n", "idx": 23303}
{"project": "qemu", "commit_id": "21ef45d71221b4577330fe3aacfb06afad91ad46", "target": 1, "func": "void vnc_display_init(DisplayState *ds)\n\n{\n\n    VncDisplay *vs = g_malloc0(sizeof(*vs));\n\n\n\n    dcl = g_malloc0(sizeof(DisplayChangeListener));\n\n\n\n    ds->opaque = vs;\n\n    dcl->idle = 1;\n\n    vnc_display = vs;\n\n\n\n    vs->lsock = -1;\n\n#ifdef CONFIG_VNC_WS\n\n    vs->lwebsock = -1;\n\n#endif\n\n\n\n    vs->ds = ds;\n\n    QTAILQ_INIT(&vs->clients);\n\n    vs->expires = TIME_MAX;\n\n\n\n    if (keyboard_layout)\n\n        vs->kbd_layout = init_keyboard_layout(name2keysym, keyboard_layout);\n\n    else\n\n        vs->kbd_layout = init_keyboard_layout(name2keysym, \"en-us\");\n\n\n\n    if (!vs->kbd_layout)\n\n        exit(1);\n\n\n\n    qemu_mutex_init(&vs->mutex);\n\n    vnc_start_worker_thread();\n\n\n\n    dcl->ops = &dcl_ops;\n\n    register_displaychangelistener(ds, dcl);\n\n}\n", "idx": 23304}
{"project": "qemu", "commit_id": "b3dd1b8c295636e64ceb14cdc4db6420d7319e38", "target": 1, "func": "static int monitor_fdset_dup_fd_find_remove(int dup_fd, bool remove)\n\n{\n\n    MonFdset *mon_fdset;\n\n    MonFdsetFd *mon_fdset_fd_dup;\n\n\n\n    QLIST_FOREACH(mon_fdset, &mon_fdsets, next) {\n\n        QLIST_FOREACH(mon_fdset_fd_dup, &mon_fdset->dup_fds, next) {\n\n            if (mon_fdset_fd_dup->fd == dup_fd) {\n\n                if (remove) {\n\n                    QLIST_REMOVE(mon_fdset_fd_dup, next);\n\n                    if (QLIST_EMPTY(&mon_fdset->dup_fds)) {\n\n                        monitor_fdset_cleanup(mon_fdset);\n\n                    }\n\n                }\n\n                return mon_fdset->id;\n\n            }\n\n        }\n\n    }\n\n    return -1;\n\n}\n", "idx": 23306}
{"project": "qemu", "commit_id": "a2d4e44b485222a8972ea9e555b148148c655bb9", "target": 1, "func": "void pci_default_write_config(PCIDevice *d, \n\n                              uint32_t address, uint32_t val, int len)\n\n{\n\n    int can_write, i;\n\n    uint32_t end, addr;\n\n\n\n    if (len == 4 && ((address >= 0x10 && address < 0x10 + 4 * 6) || \n\n                     (address >= 0x30 && address < 0x34))) {\n\n        PCIIORegion *r;\n\n        int reg;\n\n\n\n        if ( address >= 0x30 ) {\n\n            reg = PCI_ROM_SLOT;\n\n        }else{\n\n            reg = (address - 0x10) >> 2;\n\n        }\n\n        r = &d->io_regions[reg];\n\n        if (r->size == 0)\n\n            goto default_config;\n\n        /* compute the stored value */\n\n        if (reg == PCI_ROM_SLOT) {\n\n            /* keep ROM enable bit */\n\n            val &= (~(r->size - 1)) | 1;\n\n        } else {\n\n            val &= ~(r->size - 1);\n\n            val |= r->type;\n\n        }\n\n        *(uint32_t *)(d->config + address) = cpu_to_le32(val);\n\n        pci_update_mappings(d);\n\n        return;\n\n    }\n\n default_config:\n\n    /* not efficient, but simple */\n\n    addr = address;\n\n    for(i = 0; i < len; i++) {\n\n        /* default read/write accesses */\n\n        switch(d->config[0x0e]) {\n\n        case 0x00:\n\n        case 0x80:\n\n            switch(addr) {\n\n            case 0x00:\n\n            case 0x01:\n\n            case 0x02:\n\n            case 0x03:\n\n            case 0x08:\n\n            case 0x09:\n\n            case 0x0a:\n\n            case 0x0b:\n\n            case 0x0e:\n\n            case 0x10 ... 0x27: /* base */\n\n            case 0x30 ... 0x33: /* rom */\n\n            case 0x3d:\n\n                can_write = 0;\n\n                break;\n\n            default:\n\n                can_write = 1;\n\n                break;\n\n            }\n\n            break;\n\n        default:\n\n        case 0x01:\n\n            switch(addr) {\n\n            case 0x00:\n\n            case 0x01:\n\n            case 0x02:\n\n            case 0x03:\n\n            case 0x08:\n\n            case 0x09:\n\n            case 0x0a:\n\n            case 0x0b:\n\n            case 0x0e:\n\n            case 0x38 ... 0x3b: /* rom */\n\n            case 0x3d:\n\n                can_write = 0;\n\n                break;\n\n            default:\n\n                can_write = 1;\n\n                break;\n\n            }\n\n            break;\n\n        }\n\n        if (can_write) {\n\n            d->config[addr] = val;\n\n        }\n\n        addr++;\n\n        val >>= 8;\n\n    }\n\n\n\n    end = address + len;\n\n    if (end > PCI_COMMAND && address < (PCI_COMMAND + 2)) {\n\n        /* if the command register is modified, we must modify the mappings */\n\n        pci_update_mappings(d);\n\n    }\n\n}\n", "idx": 23307}
{"project": "qemu", "commit_id": "6f2d8978728c48ca46f5c01835438508aace5c64", "target": 1, "func": "static always_inline void powerpc_excp (CPUState *env,\n\n                                        int excp_model, int excp)\n\n{\n\n    target_ulong msr, new_msr, vector;\n\n    int srr0, srr1, asrr0, asrr1;\n\n#if defined(TARGET_PPC64H)\n\n    int lpes0, lpes1, lev;\n\n\n\n    lpes0 = (env->spr[SPR_LPCR] >> 1) & 1;\n\n    lpes1 = (env->spr[SPR_LPCR] >> 2) & 1;\n\n#endif\n\n\n\n    if (loglevel & CPU_LOG_INT) {\n\n        fprintf(logfile, \"Raise exception at 0x\" ADDRX \" => 0x%08x (%02x)\\n\",\n\n                env->nip, excp, env->error_code);\n\n    }\n\n    msr = env->msr;\n\n    new_msr = msr;\n\n    srr0 = SPR_SRR0;\n\n    srr1 = SPR_SRR1;\n\n    asrr0 = -1;\n\n    asrr1 = -1;\n\n    msr &= ~((target_ulong)0x783F0000);\n\n    switch (excp) {\n\n    case POWERPC_EXCP_NONE:\n\n        /* Should never happen */\n\n        return;\n\n    case POWERPC_EXCP_CRITICAL:    /* Critical input                         */\n\n        new_msr &= ~((target_ulong)1 << MSR_RI); /* XXX: check this */\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_40x:\n\n            srr0 = SPR_40x_SRR2;\n\n            srr1 = SPR_40x_SRR3;\n\n            break;\n\n        case POWERPC_EXCP_BOOKE:\n\n            srr0 = SPR_BOOKE_CSRR0;\n\n            srr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        case POWERPC_EXCP_G2:\n\n            break;\n\n        default:\n\n            goto excp_invalid;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_MCHECK:    /* Machine check exception                  */\n\n        if (msr_me == 0) {\n\n            /* Machine check exception is not enabled.\n\n             * Enter checkstop state.\n\n             */\n\n            if (loglevel != 0) {\n\n                fprintf(logfile, \"Machine check while not allowed. \"\n\n                        \"Entering checkstop state\\n\");\n\n            } else {\n\n                fprintf(stderr, \"Machine check while not allowed. \"\n\n                        \"Entering checkstop state\\n\");\n\n            }\n\n            env->halted = 1;\n\n            env->interrupt_request |= CPU_INTERRUPT_EXITTB;\n\n        }\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n        new_msr &= ~((target_ulong)1 << MSR_ME);\n\n#if defined(TARGET_PPC64H)\n\n        new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        /* XXX: should also have something loaded in DAR / DSISR */\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_40x:\n\n            srr0 = SPR_40x_SRR2;\n\n            srr1 = SPR_40x_SRR3;\n\n            break;\n\n        case POWERPC_EXCP_BOOKE:\n\n            srr0 = SPR_BOOKE_MCSRR0;\n\n            srr1 = SPR_BOOKE_MCSRR1;\n\n            asrr0 = SPR_BOOKE_CSRR0;\n\n            asrr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_DSI:       /* Data storage exception                   */\n\n#if defined (DEBUG_EXCEPTIONS)\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"DSI exception: DSISR=0x\" ADDRX\" DAR=0x\" ADDRX\n\n                    \"\\n\", env->spr[SPR_DSISR], env->spr[SPR_DAR]);\n\n        }\n\n#endif\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        goto store_next;\n\n    case POWERPC_EXCP_ISI:       /* Instruction storage exception            */\n\n#if defined (DEBUG_EXCEPTIONS)\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"ISI exception: msr=0x\" ADDRX \", nip=0x\" ADDRX\n\n                    \"\\n\", msr, env->nip);\n\n        }\n\n#endif\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        msr |= env->error_code;\n\n        goto store_next;\n\n    case POWERPC_EXCP_EXTERNAL:  /* External input                           */\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n        if (lpes0 == 1)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        goto store_next;\n\n    case POWERPC_EXCP_ALIGN:     /* Alignment exception                      */\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        /* XXX: this is false */\n\n        /* Get rS/rD and rA from faulting opcode */\n\n        env->spr[SPR_DSISR] |= (ldl_code((env->nip - 4)) & 0x03FF0000) >> 16;\n\n        goto store_current;\n\n    case POWERPC_EXCP_PROGRAM:   /* Program exception                        */\n\n        switch (env->error_code & ~0xF) {\n\n        case POWERPC_EXCP_FP:\n\n            if ((msr_fe0 == 0 && msr_fe1 == 0) || msr_fp == 0) {\n\n#if defined (DEBUG_EXCEPTIONS)\n\n                if (loglevel != 0) {\n\n                    fprintf(logfile, \"Ignore floating point exception\\n\");\n\n                }\n\n#endif\n\n                env->exception_index = POWERPC_EXCP_NONE;\n\n                env->error_code = 0;\n\n                return;\n\n            }\n\n            new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n            if (lpes1 == 0)\n\n                new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n            msr |= 0x00100000;\n\n            if (msr_fe0 == msr_fe1)\n\n                goto store_next;\n\n            msr |= 0x00010000;\n\n            break;\n\n        case POWERPC_EXCP_INVAL:\n\n#if defined (DEBUG_EXCEPTIONS)\n\n            if (loglevel != 0) {\n\n                fprintf(logfile, \"Invalid instruction at 0x\" ADDRX \"\\n\",\n\n                        env->nip);\n\n            }\n\n#endif\n\n            new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n            if (lpes1 == 0)\n\n                new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n            msr |= 0x00080000;\n\n            break;\n\n        case POWERPC_EXCP_PRIV:\n\n            new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n            if (lpes1 == 0)\n\n                new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n            msr |= 0x00040000;\n\n            break;\n\n        case POWERPC_EXCP_TRAP:\n\n            new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n            if (lpes1 == 0)\n\n                new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n            msr |= 0x00020000;\n\n            break;\n\n        default:\n\n            /* Should never occur */\n\n            cpu_abort(env, \"Invalid program exception %d. Aborting\\n\",\n\n                      env->error_code);\n\n            break;\n\n        }\n\n        goto store_current;\n\n    case POWERPC_EXCP_FPU:       /* Floating-point unavailable exception     */\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        goto store_current;\n\n    case POWERPC_EXCP_SYSCALL:   /* System call exception                    */\n\n        /* NOTE: this is a temporary hack to support graphics OSI\n\n           calls from the MOL driver */\n\n        /* XXX: To be removed */\n\n        if (env->gpr[3] == 0x113724fa && env->gpr[4] == 0x77810f9b &&\n\n            env->osi_call) {\n\n            if (env->osi_call(env) != 0) {\n\n                env->exception_index = POWERPC_EXCP_NONE;\n\n                env->error_code = 0;\n\n                return;\n\n            }\n\n        }\n\n        if (loglevel & CPU_LOG_INT) {\n\n            dump_syscall(env);\n\n        }\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n        lev = env->error_code;\n\n        if (lev == 1 || (lpes0 == 0 && lpes1 == 0))\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        goto store_next;\n\n    case POWERPC_EXCP_APU:       /* Auxiliary processor unavailable          */\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n        goto store_current;\n\n    case POWERPC_EXCP_DECR:      /* Decrementer exception                    */\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        goto store_next;\n\n    case POWERPC_EXCP_FIT:       /* Fixed-interval timer interrupt           */\n\n        /* FIT on 4xx */\n\n#if defined (DEBUG_EXCEPTIONS)\n\n        if (loglevel != 0)\n\n            fprintf(logfile, \"FIT exception\\n\");\n\n#endif\n\n        new_msr &= ~((target_ulong)1 << MSR_RI); /* XXX: check this */\n\n        goto store_next;\n\n    case POWERPC_EXCP_WDT:       /* Watchdog timer interrupt                 */\n\n#if defined (DEBUG_EXCEPTIONS)\n\n        if (loglevel != 0)\n\n            fprintf(logfile, \"WDT exception\\n\");\n\n#endif\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_BOOKE:\n\n            srr0 = SPR_BOOKE_CSRR0;\n\n            srr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        new_msr &= ~((target_ulong)1 << MSR_RI); /* XXX: check this */\n\n        goto store_next;\n\n    case POWERPC_EXCP_DTLB:      /* Data TLB error                           */\n\n        new_msr &= ~((target_ulong)1 << MSR_RI); /* XXX: check this */\n\n        goto store_next;\n\n    case POWERPC_EXCP_ITLB:      /* Instruction TLB error                    */\n\n        new_msr &= ~((target_ulong)1 << MSR_RI); /* XXX: check this */\n\n        goto store_next;\n\n    case POWERPC_EXCP_DEBUG:     /* Debug interrupt                          */\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_BOOKE:\n\n            srr0 = SPR_BOOKE_DSRR0;\n\n            srr1 = SPR_BOOKE_DSRR1;\n\n            asrr0 = SPR_BOOKE_CSRR0;\n\n            asrr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Debug exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n#if defined(TARGET_PPCEMB)\n\n    case POWERPC_EXCP_SPEU:      /* SPE/embedded floating-point unavailable  */\n\n        new_msr &= ~((target_ulong)1 << MSR_RI); /* XXX: check this */\n\n        goto store_current;\n\n    case POWERPC_EXCP_EFPDI:     /* Embedded floating-point data interrupt   */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Embedded floating point data exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_EFPRI:     /* Embedded floating-point round interrupt  */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Embedded floating point round exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_EPERFM:    /* Embedded performance monitor interrupt   */\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n        /* XXX: TODO */\n\n        cpu_abort(env,\n\n                  \"Performance counter exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_DOORI:     /* Embedded doorbell interrupt              */\n\n        /* XXX: TODO */\n\n        cpu_abort(env,\n\n                  \"Embedded doorbell interrupt is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_DOORCI:    /* Embedded doorbell critical interrupt     */\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_BOOKE:\n\n            srr0 = SPR_BOOKE_CSRR0;\n\n            srr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Embedded doorbell critical interrupt \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n#endif /* defined(TARGET_PPCEMB) */\n\n    case POWERPC_EXCP_RESET:     /* System reset exception                   */\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n        new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        goto store_next;\n\n#if defined(TARGET_PPC64)\n\n    case POWERPC_EXCP_DSEG:      /* Data segment exception                   */\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        goto store_next;\n\n    case POWERPC_EXCP_ISEG:      /* Instruction segment exception            */\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        goto store_next;\n\n#endif /* defined(TARGET_PPC64) */\n\n#if defined(TARGET_PPC64H)\n\n    case POWERPC_EXCP_HDECR:     /* Hypervisor decrementer exception         */\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)1 << MSR_HV;\n\n        goto store_next;\n\n#endif\n\n    case POWERPC_EXCP_TRACE:     /* Trace exception                          */\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        goto store_next;\n\n#if defined(TARGET_PPC64H)\n\n    case POWERPC_EXCP_HDSI:      /* Hypervisor data storage exception        */\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)1 << MSR_HV;\n\n        goto store_next;\n\n    case POWERPC_EXCP_HISI:      /* Hypervisor instruction storage exception */\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)1 << MSR_HV;\n\n        goto store_next;\n\n    case POWERPC_EXCP_HDSEG:     /* Hypervisor data segment exception        */\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)1 << MSR_HV;\n\n        goto store_next;\n\n    case POWERPC_EXCP_HISEG:     /* Hypervisor instruction segment exception */\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)1 << MSR_HV;\n\n        goto store_next;\n\n#endif /* defined(TARGET_PPC64H) */\n\n    case POWERPC_EXCP_VPU:       /* Vector unavailable exception             */\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        goto store_current;\n\n    case POWERPC_EXCP_PIT:       /* Programmable interval timer interrupt    */\n\n#if defined (DEBUG_EXCEPTIONS)\n\n        if (loglevel != 0)\n\n            fprintf(logfile, \"PIT exception\\n\");\n\n#endif\n\n        new_msr &= ~((target_ulong)1 << MSR_RI); /* XXX: check this */\n\n        goto store_next;\n\n    case POWERPC_EXCP_IO:        /* IO error exception                       */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"601 IO error exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_RUNM:      /* Run mode exception                       */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"601 run mode exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_EMUL:      /* Emulation trap exception                 */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"602 emulation trap exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_IFTLB:     /* Instruction fetch TLB error              */\n\n        new_msr &= ~((target_ulong)1 << MSR_RI); /* XXX: check this */\n\n#if defined(TARGET_PPC64H) /* XXX: check this */\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_602:\n\n        case POWERPC_EXCP_603:\n\n        case POWERPC_EXCP_603E:\n\n        case POWERPC_EXCP_G2:\n\n            goto tlb_miss_tgpr;\n\n        case POWERPC_EXCP_7x5:\n\n            goto tlb_miss;\n\n        case POWERPC_EXCP_74xx:\n\n            goto tlb_miss_74xx;\n\n        default:\n\n            cpu_abort(env, \"Invalid instruction TLB miss exception\\n\");\n\n            break;\n\n        }\n\n        break;\n\n    case POWERPC_EXCP_DLTLB:     /* Data load TLB miss                       */\n\n        new_msr &= ~((target_ulong)1 << MSR_RI); /* XXX: check this */\n\n#if defined(TARGET_PPC64H) /* XXX: check this */\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_602:\n\n        case POWERPC_EXCP_603:\n\n        case POWERPC_EXCP_603E:\n\n        case POWERPC_EXCP_G2:\n\n            goto tlb_miss_tgpr;\n\n        case POWERPC_EXCP_7x5:\n\n            goto tlb_miss;\n\n        case POWERPC_EXCP_74xx:\n\n            goto tlb_miss_74xx;\n\n        default:\n\n            cpu_abort(env, \"Invalid data load TLB miss exception\\n\");\n\n            break;\n\n        }\n\n        break;\n\n    case POWERPC_EXCP_DSTLB:     /* Data store TLB miss                      */\n\n        new_msr &= ~((target_ulong)1 << MSR_RI); /* XXX: check this */\n\n#if defined(TARGET_PPC64H) /* XXX: check this */\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_602:\n\n        case POWERPC_EXCP_603:\n\n        case POWERPC_EXCP_603E:\n\n        case POWERPC_EXCP_G2:\n\n        tlb_miss_tgpr:\n\n            /* Swap temporary saved registers with GPRs */\n\n            if (!(new_msr & ((target_ulong)1 << MSR_TGPR))) {\n\n                new_msr |= (target_ulong)1 << MSR_TGPR;\n\n                hreg_swap_gpr_tgpr(env);\n\n            }\n\n            goto tlb_miss;\n\n        case POWERPC_EXCP_7x5:\n\n        tlb_miss:\n\n#if defined (DEBUG_SOFTWARE_TLB)\n\n            if (loglevel != 0) {\n\n                const unsigned char *es;\n\n                target_ulong *miss, *cmp;\n\n                int en;\n\n                if (excp == POWERPC_EXCP_IFTLB) {\n\n                    es = \"I\";\n\n                    en = 'I';\n\n                    miss = &env->spr[SPR_IMISS];\n\n                    cmp = &env->spr[SPR_ICMP];\n\n                } else {\n\n                    if (excp == POWERPC_EXCP_DLTLB)\n\n                        es = \"DL\";\n\n                    else\n\n                        es = \"DS\";\n\n                    en = 'D';\n\n                    miss = &env->spr[SPR_DMISS];\n\n                    cmp = &env->spr[SPR_DCMP];\n\n                }\n\n                fprintf(logfile, \"6xx %sTLB miss: %cM \" ADDRX \" %cC \" ADDRX\n\n                        \" H1 \" ADDRX \" H2 \" ADDRX \" %08x\\n\",\n\n                        es, en, *miss, en, *cmp,\n\n                        env->spr[SPR_HASH1], env->spr[SPR_HASH2],\n\n                        env->error_code);\n\n            }\n\n#endif\n\n            msr |= env->crf[0] << 28;\n\n            msr |= env->error_code; /* key, D/I, S/L bits */\n\n            /* Set way using a LRU mechanism */\n\n            msr |= ((env->last_way + 1) & (env->nb_ways - 1)) << 17;\n\n            break;\n\n        case POWERPC_EXCP_74xx:\n\n        tlb_miss_74xx:\n\n#if defined (DEBUG_SOFTWARE_TLB)\n\n            if (loglevel != 0) {\n\n                const unsigned char *es;\n\n                target_ulong *miss, *cmp;\n\n                int en;\n\n                if (excp == POWERPC_EXCP_IFTLB) {\n\n                    es = \"I\";\n\n                    en = 'I';\n\n                    miss = &env->spr[SPR_TLBMISS];\n\n                    cmp = &env->spr[SPR_PTEHI];\n\n                } else {\n\n                    if (excp == POWERPC_EXCP_DLTLB)\n\n                        es = \"DL\";\n\n                    else\n\n                        es = \"DS\";\n\n                    en = 'D';\n\n                    miss = &env->spr[SPR_TLBMISS];\n\n                    cmp = &env->spr[SPR_PTEHI];\n\n                }\n\n                fprintf(logfile, \"74xx %sTLB miss: %cM \" ADDRX \" %cC \" ADDRX\n\n                        \" %08x\\n\",\n\n                        es, en, *miss, en, *cmp, env->error_code);\n\n            }\n\n#endif\n\n            msr |= env->error_code; /* key bit */\n\n            break;\n\n        default:\n\n            cpu_abort(env, \"Invalid data store TLB miss exception\\n\");\n\n            break;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_FPA:       /* Floating-point assist exception          */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Floating point assist exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_IABR:      /* Instruction address breakpoint           */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"IABR exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_SMI:       /* System management interrupt              */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"SMI exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_THERM:     /* Thermal interrupt                        */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Thermal management exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_PERFM:     /* Embedded performance monitor interrupt   */\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        /* XXX: TODO */\n\n        cpu_abort(env,\n\n                  \"Performance counter exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_VPUA:      /* Vector assist exception                  */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"VPU assist exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_SOFTP:     /* Soft patch exception                     */\n\n        /* XXX: TODO */\n\n        cpu_abort(env,\n\n                  \"970 soft-patch exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_MAINT:     /* Maintenance exception                    */\n\n        /* XXX: TODO */\n\n        cpu_abort(env,\n\n                  \"970 maintenance exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    default:\n\n    excp_invalid:\n\n        cpu_abort(env, \"Invalid PowerPC exception %d. Aborting\\n\", excp);\n\n        break;\n\n    store_current:\n\n        /* save current instruction location */\n\n        env->spr[srr0] = env->nip - 4;\n\n        break;\n\n    store_next:\n\n        /* save next instruction location */\n\n        env->spr[srr0] = env->nip;\n\n        break;\n\n    }\n\n    /* Save MSR */\n\n    env->spr[srr1] = msr;\n\n    /* If any alternate SRR register are defined, duplicate saved values */\n\n    if (asrr0 != -1)\n\n        env->spr[asrr0] = env->spr[srr0];\n\n    if (asrr1 != -1)\n\n        env->spr[asrr1] = env->spr[srr1];\n\n    /* If we disactivated any translation, flush TLBs */\n\n    if (new_msr & ((1 << MSR_IR) | (1 << MSR_DR)))\n\n        tlb_flush(env, 1);\n\n    /* reload MSR with correct bits */\n\n    new_msr &= ~((target_ulong)1 << MSR_EE);\n\n    new_msr &= ~((target_ulong)1 << MSR_PR);\n\n    new_msr &= ~((target_ulong)1 << MSR_FP);\n\n    new_msr &= ~((target_ulong)1 << MSR_FE0);\n\n    new_msr &= ~((target_ulong)1 << MSR_SE);\n\n    new_msr &= ~((target_ulong)1 << MSR_BE);\n\n    new_msr &= ~((target_ulong)1 << MSR_FE1);\n\n    new_msr &= ~((target_ulong)1 << MSR_IR);\n\n    new_msr &= ~((target_ulong)1 << MSR_DR);\n\n#if 0 /* Fix this: not on all targets */\n\n    new_msr &= ~((target_ulong)1 << MSR_PMM);\n\n#endif\n\n    new_msr &= ~((target_ulong)1 << MSR_LE);\n\n    if (msr_ile)\n\n        new_msr |= (target_ulong)1 << MSR_LE;\n\n    else\n\n        new_msr &= ~((target_ulong)1 << MSR_LE);\n\n    /* Jump to handler */\n\n    vector = env->excp_vectors[excp];\n\n    if (vector == (target_ulong)-1) {\n\n        cpu_abort(env, \"Raised an exception without defined vector %d\\n\",\n\n                  excp);\n\n    }\n\n    vector |= env->excp_prefix;\n\n#if defined(TARGET_PPC64)\n\n    if (excp_model == POWERPC_EXCP_BOOKE) {\n\n        if (!msr_icm) {\n\n            new_msr &= ~((target_ulong)1 << MSR_CM);\n\n            vector = (uint32_t)vector;\n\n        } else {\n\n            new_msr |= (target_ulong)1 << MSR_CM;\n\n        }\n\n    } else {\n\n        if (!msr_isf) {\n\n            new_msr &= ~((target_ulong)1 << MSR_SF);\n\n            vector = (uint32_t)vector;\n\n        } else {\n\n            new_msr |= (target_ulong)1 << MSR_SF;\n\n        }\n\n    }\n\n#endif\n\n    /* XXX: we don't use hreg_store_msr here as already have treated\n\n     *      any special case that could occur. Just store MSR and update hflags\n\n     */\n\n    env->msr = new_msr;\n\n    env->hflags_nmsr = 0x00000000;\n\n    hreg_compute_hflags(env);\n\n    env->nip = vector;\n\n    /* Reset exception state */\n\n    env->exception_index = POWERPC_EXCP_NONE;\n\n    env->error_code = 0;\n\n}\n", "idx": 23310}
{"project": "qemu", "commit_id": "0df93305f21712e975ab5df260cc5a91e5daafca", "target": 1, "func": "static void qcow_close(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n\n\n    g_free(s->l1_table);\n\n    g_free(s->l2_cache);\n\n    g_free(s->cluster_cache);\n\n    g_free(s->cluster_data);\n\n\n\n    migrate_del_blocker(s->migration_blocker);\n\n    error_free(s->migration_blocker);\n\n}\n", "idx": 23312}
{"project": "qemu", "commit_id": "3761abb167847e9d848588bf15c5d7476845f7e8", "target": 1, "func": "static void qxl_create_guest_primary(PCIQXLDevice *qxl, int loadvm,\n\n                                     qxl_async_io async)\n\n{\n\n    QXLDevSurfaceCreate surface;\n\n    QXLSurfaceCreate *sc = &qxl->guest_primary.surface;\n\n    int size;\n\n    int requested_height = le32_to_cpu(sc->height);\n\n    int requested_stride = le32_to_cpu(sc->stride);\n\n\n\n    size = abs(requested_stride) * requested_height;\n\n    if (size > qxl->vgamem_size) {\n\n        qxl_set_guest_bug(qxl, \"%s: requested primary larger then framebuffer\"\n\n                               \" size\", __func__);\n\n        return;\n\n    }\n\n\n\n    if (qxl->mode == QXL_MODE_NATIVE) {\n\n        qxl_set_guest_bug(qxl, \"%s: nop since already in QXL_MODE_NATIVE\",\n\n                      __func__);\n\n    }\n\n    qxl_exit_vga_mode(qxl);\n\n\n\n    surface.format     = le32_to_cpu(sc->format);\n\n    surface.height     = le32_to_cpu(sc->height);\n\n    surface.mem        = le64_to_cpu(sc->mem);\n\n    surface.position   = le32_to_cpu(sc->position);\n\n    surface.stride     = le32_to_cpu(sc->stride);\n\n    surface.width      = le32_to_cpu(sc->width);\n\n    surface.type       = le32_to_cpu(sc->type);\n\n    surface.flags      = le32_to_cpu(sc->flags);\n\n    trace_qxl_create_guest_primary(qxl->id, sc->width, sc->height, sc->mem,\n\n                                   sc->format, sc->position);\n\n    trace_qxl_create_guest_primary_rest(qxl->id, sc->stride, sc->type,\n\n                                        sc->flags);\n\n\n\n    if ((surface.stride & 0x3) != 0) {\n\n        qxl_set_guest_bug(qxl, \"primary surface stride = %d %% 4 != 0\",\n\n                          surface.stride);\n\n        return;\n\n    }\n\n\n\n    surface.mouse_mode = true;\n\n    surface.group_id   = MEMSLOT_GROUP_GUEST;\n\n    if (loadvm) {\n\n        surface.flags |= QXL_SURF_FLAG_KEEP_DATA;\n\n    }\n\n\n\n    qxl->mode = QXL_MODE_NATIVE;\n\n    qxl->cmdflags = 0;\n\n    qemu_spice_create_primary_surface(&qxl->ssd, 0, &surface, async);\n\n\n\n    if (async == QXL_SYNC) {\n\n        qxl_create_guest_primary_complete(qxl);\n\n    }\n\n}\n", "idx": 23314}
{"project": "qemu", "commit_id": "b20909195745c34a819aed14ae996b60ab0f591f", "target": 1, "func": "iscsi_readv_writev_bh_cb(void *p)\n\n{\n\n    IscsiAIOCB *acb = p;\n\n\n\n    qemu_bh_delete(acb->bh);\n\n\n\n    if (!acb->canceled) {\n\n        acb->common.cb(acb->common.opaque, acb->status);\n\n    }\n\n\n\n    qemu_aio_release(acb);\n\n\n\n    if (acb->canceled) {\n\n        return;\n\n    }\n\n\n\n    scsi_free_scsi_task(acb->task);\n\n    acb->task = NULL;\n\n}\n", "idx": 23315}
{"project": "qemu", "commit_id": "069ab0eb8a46bc4ff6f4d4d81bf037d3441347da", "target": 1, "func": "static void vmmouse_reset(DeviceState *d)\n{\n    VMMouseState *s = container_of(d, VMMouseState, dev.qdev);\n    s->status = 0xffff;\n    s->queue_size = VMMOUSE_QUEUE_SIZE;\n}", "idx": 23317}
{"project": "qemu", "commit_id": "560f19f162529d691619ac69ed032321c7f5f1fb", "target": 1, "func": "char *object_property_get_str(Object *obj, const char *name,\n\n                              Error **errp)\n\n{\n\n    QObject *ret = object_property_get_qobject(obj, name, errp);\n\n    QString *qstring;\n\n    char *retval;\n\n\n\n    if (!ret) {\n\n        return NULL;\n\n    }\n\n    qstring = qobject_to_qstring(ret);\n\n    if (!qstring) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name, \"string\");\n\n        retval = NULL;\n\n    } else {\n\n        retval = g_strdup(qstring_get_str(qstring));\n\n    }\n\n\n\n    QDECREF(qstring);\n\n    return retval;\n\n}\n", "idx": 23319}
{"project": "qemu", "commit_id": "99787f69cdd8147d0be67d71ec3058cce21e2444", "target": 1, "func": "ip_input(struct mbuf *m)\n\n{\n\n\tSlirp *slirp = m->slirp;\n\n\tregister struct ip *ip;\n\n\tint hlen;\n\n\n\n\tDEBUG_CALL(\"ip_input\");\n\n\tDEBUG_ARG(\"m = %p\", m);\n\n\tDEBUG_ARG(\"m_len = %d\", m->m_len);\n\n\n\n\tif (m->m_len < sizeof (struct ip)) {\n\n\t\treturn;\n\n\t}\n\n\n\n\tip = mtod(m, struct ip *);\n\n\n\n\tif (ip->ip_v != IPVERSION) {\n\n\t\tgoto bad;\n\n\t}\n\n\n\n\thlen = ip->ip_hl << 2;\n\n\tif (hlen<sizeof(struct ip ) || hlen>m->m_len) {/* min header length */\n\n\t  goto bad;                                  /* or packet too short */\n\n\t}\n\n\n\n        /* keep ip header intact for ICMP reply\n\n\t * ip->ip_sum = cksum(m, hlen);\n\n\t * if (ip->ip_sum) {\n\n\t */\n\n\tif(cksum(m,hlen)) {\n\n\t  goto bad;\n\n\t}\n\n\n\n\t/*\n\n\t * Convert fields to host representation.\n\n\t */\n\n\tNTOHS(ip->ip_len);\n\n\tif (ip->ip_len < hlen) {\n\n\t\tgoto bad;\n\n\t}\n\n\tNTOHS(ip->ip_id);\n\n\tNTOHS(ip->ip_off);\n\n\n\n\t/*\n\n\t * Check that the amount of data in the buffers\n\n\t * is as at least much as the IP header would have us expect.\n\n\t * Trim mbufs if longer than we expect.\n\n\t * Drop packet if shorter than we expect.\n\n\t */\n\n\tif (m->m_len < ip->ip_len) {\n\n\t\tgoto bad;\n\n\t}\n\n\n\n\t/* Should drop packet if mbuf too long? hmmm... */\n\n\tif (m->m_len > ip->ip_len)\n\n\t   m_adj(m, ip->ip_len - m->m_len);\n\n\n\n\t/* check ip_ttl for a correct ICMP reply */\n\n\tif (ip->ip_ttl == 0) {\n\n\t    icmp_send_error(m, ICMP_TIMXCEED, ICMP_TIMXCEED_INTRANS, 0, \"ttl\");\n\n\t    goto bad;\n\n\t}\n\n\n\n\t/*\n\n\t * If offset or IP_MF are set, must reassemble.\n\n\t * Otherwise, nothing need be done.\n\n\t * (We could look in the reassembly queue to see\n\n\t * if the packet was previously fragmented,\n\n\t * but it's not worth the time; just let them time out.)\n\n\t *\n\n\t * XXX This should fail, don't fragment yet\n\n\t */\n\n\tif (ip->ip_off &~ IP_DF) {\n\n\t  register struct ipq *fp;\n\n      struct qlink *l;\n\n\t\t/*\n\n\t\t * Look for queue of fragments\n\n\t\t * of this datagram.\n\n\t\t */\n\n\t\tfor (l = slirp->ipq.ip_link.next; l != &slirp->ipq.ip_link;\n\n\t\t     l = l->next) {\n\n            fp = container_of(l, struct ipq, ip_link);\n\n            if (ip->ip_id == fp->ipq_id &&\n\n                    ip->ip_src.s_addr == fp->ipq_src.s_addr &&\n\n                    ip->ip_dst.s_addr == fp->ipq_dst.s_addr &&\n\n                    ip->ip_p == fp->ipq_p)\n\n\t\t    goto found;\n\n        }\n\n        fp = NULL;\n\n\tfound:\n\n\n\n\t\t/*\n\n\t\t * Adjust ip_len to not reflect header,\n\n\t\t * set ip_mff if more fragments are expected,\n\n\t\t * convert offset of this to bytes.\n\n\t\t */\n\n\t\tip->ip_len -= hlen;\n\n\t\tif (ip->ip_off & IP_MF)\n\n\t\t  ip->ip_tos |= 1;\n\n\t\telse\n\n\t\t  ip->ip_tos &= ~1;\n\n\n\n\t\tip->ip_off <<= 3;\n\n\n\n\t\t/*\n\n\t\t * If datagram marked as having more fragments\n\n\t\t * or if this is not the first fragment,\n\n\t\t * attempt reassembly; if it succeeds, proceed.\n\n\t\t */\n\n\t\tif (ip->ip_tos & 1 || ip->ip_off) {\n\n\t\t\tip = ip_reass(slirp, ip, fp);\n\n                        if (ip == NULL)\n\n\t\t\t\treturn;\n\n\t\t\tm = dtom(slirp, ip);\n\n\t\t} else\n\n\t\t\tif (fp)\n\n\t\t   \t   ip_freef(slirp, fp);\n\n\n\n\t} else\n\n\t\tip->ip_len -= hlen;\n\n\n\n\t/*\n\n\t * Switch out to protocol's input routine.\n\n\t */\n\n\tswitch (ip->ip_p) {\n\n\t case IPPROTO_TCP:\n\n\t\ttcp_input(m, hlen, (struct socket *)NULL, AF_INET);\n\n\t\tbreak;\n\n\t case IPPROTO_UDP:\n\n\t\tudp_input(m, hlen);\n\n\t\tbreak;\n\n\t case IPPROTO_ICMP:\n\n\t\ticmp_input(m, hlen);\n\n\t\tbreak;\n\n\t default:\n\n\t\tm_free(m);\n\n\t}\n\n\treturn;\n\nbad:\n\n\tm_free(m);\n\n}\n", "idx": 23320}
{"project": "qemu", "commit_id": "a4e26048526d8d5b181f9a0a7d4f82b8441c5dfd", "target": 1, "func": "static int qemu_chr_open_pty(QemuOpts *opts, CharDriverState **_chr)\n\n{\n\n    CharDriverState *chr;\n\n    PtyCharDriver *s;\n\n    struct termios tty;\n\n    int slave_fd, len;\n\n#if defined(__OpenBSD__) || defined(__DragonFly__)\n\n    char pty_name[PATH_MAX];\n\n#define q_ptsname(x) pty_name\n\n#else\n\n    char *pty_name = NULL;\n\n#define q_ptsname(x) ptsname(x)\n\n#endif\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n    s = g_malloc0(sizeof(PtyCharDriver));\n\n\n\n    if (openpty(&s->fd, &slave_fd, pty_name, NULL, NULL) < 0) {\n\n        return -errno;\n\n    }\n\n\n\n    /* Set raw attributes on the pty. */\n\n    tcgetattr(slave_fd, &tty);\n\n    cfmakeraw(&tty);\n\n    tcsetattr(slave_fd, TCSAFLUSH, &tty);\n\n    close(slave_fd);\n\n\n\n    len = strlen(q_ptsname(s->fd)) + 5;\n\n    chr->filename = g_malloc(len);\n\n    snprintf(chr->filename, len, \"pty:%s\", q_ptsname(s->fd));\n\n    qemu_opt_set(opts, \"path\", q_ptsname(s->fd));\n\n    fprintf(stderr, \"char device redirected to %s\\n\", q_ptsname(s->fd));\n\n\n\n    chr->opaque = s;\n\n    chr->chr_write = pty_chr_write;\n\n    chr->chr_update_read_handler = pty_chr_update_read_handler;\n\n    chr->chr_close = pty_chr_close;\n\n\n\n    s->timer = qemu_new_timer_ms(rt_clock, pty_chr_timer, chr);\n\n\n\n    *_chr = chr;\n\n    return 0;\n\n}\n", "idx": 23326}
{"project": "qemu", "commit_id": "a9a72aeefbd3ef8bcbbeeccaf174ee10db2978ac", "target": 1, "func": "static void tpm_display_backend_drivers(void)\n\n{\n\n    int i;\n\n\n\n    fprintf(stderr, \"Supported TPM types (choose only one):\\n\");\n\n\n\n    for (i = 0; i < TPM_MAX_DRIVERS && be_drivers[i] != NULL; i++) {\n\n        fprintf(stderr, \"%12s   %s\\n\",\n\n                TpmType_lookup[be_drivers[i]->type], be_drivers[i]->desc());\n\n    }\n\n    fprintf(stderr, \"\\n\");\n\n}\n", "idx": 23328}
{"project": "qemu", "commit_id": "b308c82cbda44e138ef990af64d44a5613c16092", "target": 1, "func": "static void pci_bridge_region_init(PCIBridge *br)\n\n{\n\n    PCIBus *parent = br->dev.bus;\n\n    uint16_t cmd = pci_get_word(br->dev.config + PCI_COMMAND);\n\n\n\n    pci_bridge_init_alias(br, &br->alias_pref_mem,\n\n                          PCI_BASE_ADDRESS_MEM_PREFETCH,\n\n                          \"pci_bridge_pref_mem\",\n\n                          &br->address_space_mem,\n\n                          parent->address_space_mem,\n\n                          cmd & PCI_COMMAND_MEMORY);\n\n    pci_bridge_init_alias(br, &br->alias_mem,\n\n                          PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                          \"pci_bridge_mem\",\n\n                          &br->address_space_mem,\n\n                          parent->address_space_mem,\n\n                          cmd & PCI_COMMAND_MEMORY);\n\n    pci_bridge_init_alias(br, &br->alias_io,\n\n                          PCI_BASE_ADDRESS_SPACE_IO,\n\n                          \"pci_bridge_io\",\n\n                          &br->address_space_io,\n\n                          parent->address_space_io,\n\n                          cmd & PCI_COMMAND_IO);\n\n   /* TODO: optinal VGA and VGA palette snooping support. */\n\n}\n", "idx": 23335}
{"project": "qemu", "commit_id": "8f2ad0a3fc5e3569183d44bf1c7fcb95294be4c0", "target": 1, "func": "static void ecc_reset(void *opaque)\n\n{\n\n    ECCState *s = opaque;\n\n    int i;\n\n\n\n    s->regs[ECC_MER] &= (ECC_MER_VER | ECC_MER_IMPL);\n\n    s->regs[ECC_MER] |= ECC_MER_MRR;\n\n    s->regs[ECC_MDR] = 0x20;\n\n    s->regs[ECC_MFSR] = 0;\n\n    s->regs[ECC_VCR] = 0;\n\n    s->regs[ECC_MFAR0] = 0x07c00000;\n\n    s->regs[ECC_MFAR1] = 0;\n\n    s->regs[ECC_DR] = 0;\n\n    s->regs[ECC_ECR0] = 0;\n\n    s->regs[ECC_ECR1] = 0;\n\n\n\n    for (i = 1; i < ECC_NREGS; i++)\n\n        s->regs[i] = 0;\n\n}\n", "idx": 23336}
{"project": "qemu", "commit_id": "20c334a797bf46a4ee59a6e42be6d5e7c3cda585", "target": 1, "func": "static inline int16_t mipsdsp_add_i16(int16_t a, int16_t b, CPUMIPSState *env)\n\n{\n\n    int16_t tempI;\n\n\n\n    tempI = a + b;\n\n\n\n    if (MIPSDSP_OVERFLOW(a, b, tempI, 0x8000)) {\n\n        set_DSPControl_overflow_flag(1, 20, env);\n\n    }\n\n\n\n    return tempI;\n\n}\n", "idx": 23337}
{"project": "qemu", "commit_id": "d7dce494769e47c9a1eec6f55578d3acdfab888b", "target": 1, "func": "void cpu_loop(CPUMBState *env)\n\n{\n\n    int trapnr, ret;\n\n    target_siginfo_t info;\n\n    \n\n    while (1) {\n\n        trapnr = cpu_mb_exec (env);\n\n        switch (trapnr) {\n\n        case 0xaa:\n\n            {\n\n                info.si_signo = SIGSEGV;\n\n                info.si_errno = 0;\n\n                /* XXX: check env->error_code */\n\n                info.si_code = TARGET_SEGV_MAPERR;\n\n                info._sifields._sigfault._addr = 0;\n\n                queue_signal(env, info.si_signo, &info);\n\n            }\n\n            break;\n\n\tcase EXCP_INTERRUPT:\n\n\t  /* just indicate that signals should be handled asap */\n\n\t  break;\n\n        case EXCP_BREAK:\n\n            /* Return address is 4 bytes after the call.  */\n\n            env->regs[14] += 4;\n\n            ret = do_syscall(env, \n\n                             env->regs[12], \n\n                             env->regs[5], \n\n                             env->regs[6], \n\n                             env->regs[7], \n\n                             env->regs[8], \n\n                             env->regs[9], \n\n                             env->regs[10],\n\n                             0, 0);\n\n            env->regs[3] = ret;\n\n            env->sregs[SR_PC] = env->regs[14];\n\n            break;\n\n        case EXCP_HW_EXCP:\n\n            env->regs[17] = env->sregs[SR_PC] + 4;\n\n            if (env->iflags & D_FLAG) {\n\n                env->sregs[SR_ESR] |= 1 << 12;\n\n                env->sregs[SR_PC] -= 4;\n\n                /* FIXME: if branch was immed, replay the imm as well.  */\n\n            }\n\n\n\n            env->iflags &= ~(IMM_FLAG | D_FLAG);\n\n\n\n            switch (env->sregs[SR_ESR] & 31) {\n\n                case ESR_EC_DIVZERO:\n\n                    info.si_signo = SIGFPE;\n\n                    info.si_errno = 0;\n\n                    info.si_code = TARGET_FPE_FLTDIV;\n\n                    info._sifields._sigfault._addr = 0;\n\n                    queue_signal(env, info.si_signo, &info);\n\n                    break;\n\n                case ESR_EC_FPU:\n\n                    info.si_signo = SIGFPE;\n\n                    info.si_errno = 0;\n\n                    if (env->sregs[SR_FSR] & FSR_IO) {\n\n                        info.si_code = TARGET_FPE_FLTINV;\n\n                    }\n\n                    if (env->sregs[SR_FSR] & FSR_DZ) {\n\n                        info.si_code = TARGET_FPE_FLTDIV;\n\n                    }\n\n                    info._sifields._sigfault._addr = 0;\n\n                    queue_signal(env, info.si_signo, &info);\n\n                    break;\n\n                default:\n\n                    printf (\"Unhandled hw-exception: 0x%x\\n\",\n\n                            env->sregs[SR_ESR] & ESR_EC_MASK);\n\n                    cpu_dump_state(env, stderr, fprintf, 0);\n\n                    exit (1);\n\n                    break;\n\n            }\n\n            break;\n\n        case EXCP_DEBUG:\n\n            {\n\n                int sig;\n\n\n\n                sig = gdb_handlesig (env, TARGET_SIGTRAP);\n\n                if (sig)\n\n                  {\n\n                    info.si_signo = sig;\n\n                    info.si_errno = 0;\n\n                    info.si_code = TARGET_TRAP_BRKPT;\n\n                    queue_signal(env, info.si_signo, &info);\n\n                  }\n\n            }\n\n            break;\n\n        default:\n\n            printf (\"Unhandled trap: 0x%x\\n\", trapnr);\n\n            cpu_dump_state(env, stderr, fprintf, 0);\n\n            exit (1);\n\n        }\n\n        process_pending_signals (env);\n\n    }\n\n}\n", "idx": 23338}
{"project": "qemu", "commit_id": "fc40787abcf8452b8f50d92b7a13243a12972c7a", "target": 1, "func": "target_ulong helper_ldl(CPUMIPSState *env, target_ulong arg1,\n\n                        target_ulong arg2, int mem_idx)\n\n{\n\n    uint64_t tmp;\n\n\n\n    tmp = do_lbu(env, arg2, mem_idx);\n\n    arg1 = (arg1 & 0x00FFFFFFFFFFFFFFULL) | (tmp << 56);\n\n\n\n    if (GET_LMASK64(arg2) <= 6) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 1), mem_idx);\n\n        arg1 = (arg1 & 0xFF00FFFFFFFFFFFFULL) | (tmp << 48);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 5) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 2), mem_idx);\n\n        arg1 = (arg1 & 0xFFFF00FFFFFFFFFFULL) | (tmp << 40);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 4) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 3), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFF00FFFFFFFFULL) | (tmp << 32);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 3) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 4), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFF00FFFFFFULL) | (tmp << 24);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 2) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 5), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFFFF00FFFFULL) | (tmp << 16);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 1) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 6), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFFFFFF00FFULL) | (tmp << 8);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) == 0) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 7), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFFFFFFFF00ULL) | tmp;\n\n    }\n\n\n\n    return arg1;\n\n}\n", "idx": 23339}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int usb_bt_handle_control(USBDevice *dev, USBPacket *p,\n\n               int request, int value, int index, int length, uint8_t *data)\n\n{\n\n    struct USBBtState *s = (struct USBBtState *) dev->opaque;\n\n    int ret;\n\n\n\n    ret = usb_desc_handle_control(dev, p, request, value, index, length, data);\n\n    if (ret >= 0) {\n\n        switch (request) {\n\n        case DeviceRequest | USB_REQ_GET_CONFIGURATION:\n\n            s->config = 0;\n\n            break;\n\n        case DeviceOutRequest | USB_REQ_SET_CONFIGURATION:\n\n            s->config = 1;\n\n            usb_bt_fifo_reset(&s->evt);\n\n            usb_bt_fifo_reset(&s->acl);\n\n            usb_bt_fifo_reset(&s->sco);\n\n            break;\n\n        }\n\n        return ret;\n\n    }\n\n\n\n    ret = 0;\n\n    switch (request) {\n\n    case InterfaceRequest | USB_REQ_GET_STATUS:\n\n    case EndpointRequest | USB_REQ_GET_STATUS:\n\n        data[0] = 0x00;\n\n        data[1] = 0x00;\n\n        ret = 2;\n\n        break;\n\n    case InterfaceOutRequest | USB_REQ_CLEAR_FEATURE:\n\n    case EndpointOutRequest | USB_REQ_CLEAR_FEATURE:\n\n        goto fail;\n\n    case InterfaceOutRequest | USB_REQ_SET_FEATURE:\n\n    case EndpointOutRequest | USB_REQ_SET_FEATURE:\n\n        goto fail;\n\n        break;\n\n    case InterfaceRequest | USB_REQ_GET_INTERFACE:\n\n        if (value != 0 || (index & ~1) || length != 1)\n\n            goto fail;\n\n        if (index == 1)\n\n            data[0] = s->altsetting;\n\n        else\n\n            data[0] = 0;\n\n        ret = 1;\n\n        break;\n\n    case InterfaceOutRequest | USB_REQ_SET_INTERFACE:\n\n        if ((index & ~1) || length != 0 ||\n\n                        (index == 1 && (value < 0 || value > 4)) ||\n\n                        (index == 0 && value != 0)) {\n\n            printf(\"%s: Wrong SET_INTERFACE request (%i, %i)\\n\",\n\n                            __FUNCTION__, index, value);\n\n            goto fail;\n\n        }\n\n        s->altsetting = value;\n\n        ret = 0;\n\n        break;\n\n    case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_DEVICE) << 8):\n\n        if (s->config)\n\n            usb_bt_fifo_out_enqueue(s, &s->outcmd, s->hci->cmd_send,\n\n                            usb_bt_hci_cmd_complete, data, length);\n\n        break;\n\n    default:\n\n    fail:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n    return ret;\n\n}\n", "idx": 23347}
{"project": "qemu", "commit_id": "3c99afc779c2c78718a565ad8c5e98de7c2c7484", "target": 1, "func": "static int vmxnet3_post_load(void *opaque, int version_id)\n{\n    VMXNET3State *s = opaque;\n    PCIDevice *d = PCI_DEVICE(s);\n    vmxnet_tx_pkt_init(&s->tx_pkt, s->max_tx_frags, s->peer_has_vhdr);\n    vmxnet_rx_pkt_init(&s->rx_pkt, s->peer_has_vhdr);\n    if (s->msix_used) {\n        if  (!vmxnet3_use_msix_vectors(s, VMXNET3_MAX_INTRS)) {\n            VMW_WRPRN(\"Failed to re-use MSI-X vectors\");\n            msix_uninit(d, &s->msix_bar, &s->msix_bar);\n            s->msix_used = false;\n            return -1;\n        }\n    }\n    return 0;\n}", "idx": 23349}
{"project": "qemu", "commit_id": "f35e44e7645edbb08e35b111c10c2fc57e2905c7", "target": 1, "func": "address_space_translate_for_iotlb(CPUState *cpu, int asidx, hwaddr addr,\n\n                                  hwaddr *xlat, hwaddr *plen)\n\n{\n\n    MemoryRegionSection *section;\n\n    AddressSpaceDispatch *d = cpu->cpu_ases[asidx].memory_dispatch;\n\n\n\n    section = address_space_translate_internal(d, addr, xlat, plen, false);\n\n\n\n    assert(!section->mr->iommu_ops);\n\n    return section;\n\n}\n", "idx": 23352}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "static struct pxa2xx_fir_s *pxa2xx_fir_init(target_phys_addr_t base,\n\n                qemu_irq irq, struct pxa2xx_dma_state_s *dma,\n\n                CharDriverState *chr)\n\n{\n\n    int iomemtype;\n\n    struct pxa2xx_fir_s *s = (struct pxa2xx_fir_s *)\n\n            qemu_mallocz(sizeof(struct pxa2xx_fir_s));\n\n\n\n    s->base = base;\n\n    s->irq = irq;\n\n    s->dma = dma;\n\n    s->chr = chr;\n\n\n\n    pxa2xx_fir_reset(s);\n\n\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_fir_readfn,\n\n                    pxa2xx_fir_writefn, s);\n\n    cpu_register_physical_memory(s->base, 0xfff, iomemtype);\n\n\n\n    if (chr)\n\n        qemu_chr_add_handlers(chr, pxa2xx_fir_is_empty,\n\n                        pxa2xx_fir_rx, pxa2xx_fir_event, s);\n\n\n\n    register_savevm(\"pxa2xx_fir\", 0, 0, pxa2xx_fir_save, pxa2xx_fir_load, s);\n\n\n\n    return s;\n\n}\n", "idx": 23353}
{"project": "qemu", "commit_id": "dc8764f06155a7b3e635e02281b747a9e292127e", "target": 1, "func": "static void child_handler(int sig)\n\n{\n\n    int status;\n\n    while (waitpid(-1, &status, WNOHANG) > 0) /* NOTHING */;\n\n}\n", "idx": 23354}
{"project": "qemu", "commit_id": "7fe7b68b32ba609faeeee03556aac0eb1b187c91", "target": 1, "func": "static ssize_t nbd_co_receive_request(NBDRequest *req, struct nbd_request *request)\n\n{\n\n    NBDClient *client = req->client;\n\n    int csock = client->sock;\n\n    ssize_t rc;\n\n\n\n    client->recv_coroutine = qemu_coroutine_self();\n\n    if (nbd_receive_request(csock, request) < 0) {\n\n        rc = -EIO;\n\n        goto out;\n\n    }\n\n\n\n    if (request->len > NBD_BUFFER_SIZE) {\n\n        LOG(\"len (%u) is larger than max len (%u)\",\n\n            request->len, NBD_BUFFER_SIZE);\n\n        rc = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    if ((request->from + request->len) < request->from) {\n\n        LOG(\"integer overflow detected! \"\n\n            \"you're probably being attacked\");\n\n        rc = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    TRACE(\"Decoding type\");\n\n\n\n    if ((request->type & NBD_CMD_MASK_COMMAND) == NBD_CMD_WRITE) {\n\n        TRACE(\"Reading %u byte(s)\", request->len);\n\n\n\n        if (qemu_co_recv(csock, req->data, request->len) != request->len) {\n\n            LOG(\"reading from socket failed\");\n\n            rc = -EIO;\n\n            goto out;\n\n        }\n\n    }\n\n    rc = 0;\n\n\n\nout:\n\n    client->recv_coroutine = NULL;\n\n    return rc;\n\n}\n", "idx": 23355}
{"project": "qemu", "commit_id": "06b106889a09277617fc8c542397a9f595ee605a", "target": 1, "func": "ram_addr_t migration_bitmap_find_dirty(RAMState *rs, RAMBlock *rb,\n\n                                       ram_addr_t start,\n\n                                       ram_addr_t *ram_addr_abs)\n\n{\n\n    unsigned long base = rb->offset >> TARGET_PAGE_BITS;\n\n    unsigned long nr = base + (start >> TARGET_PAGE_BITS);\n\n    uint64_t rb_size = rb->used_length;\n\n    unsigned long size = base + (rb_size >> TARGET_PAGE_BITS);\n\n    unsigned long *bitmap;\n\n\n\n    unsigned long next;\n\n\n\n    bitmap = atomic_rcu_read(&rs->ram_bitmap)->bmap;\n\n    if (rs->ram_bulk_stage && nr > base) {\n\n        next = nr + 1;\n\n    } else {\n\n        next = find_next_bit(bitmap, size, nr);\n\n    }\n\n\n\n    *ram_addr_abs = next << TARGET_PAGE_BITS;\n\n    return (next - base) << TARGET_PAGE_BITS;\n\n}\n", "idx": 23356}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void ide_atapi_cmd_read_dma(IDEState *s, int lba, int nb_sectors,\n\n                                   int sector_size)\n\n{\n\n    s->lba = lba;\n\n    s->packet_transfer_size = nb_sectors * sector_size;\n\n    s->io_buffer_index = 0;\n\n    s->io_buffer_size = 0;\n\n    s->cd_sector_size = sector_size;\n\n\n\n    block_acct_start(bdrv_get_stats(s->bs), &s->acct, s->packet_transfer_size,\n\n                     BLOCK_ACCT_READ);\n\n\n\n    /* XXX: check if BUSY_STAT should be set */\n\n    s->status = READY_STAT | SEEK_STAT | DRQ_STAT | BUSY_STAT;\n\n    ide_start_dma(s, ide_atapi_cmd_read_dma_cb);\n\n}\n", "idx": 23358}
{"project": "qemu", "commit_id": "1f01e50b8330c24714ddca5841fdbb703076b121", "target": 0, "func": "void qed_acquire(BDRVQEDState *s)\n\n{\n\n    aio_context_acquire(bdrv_get_aio_context(s->bs));\n\n}\n", "idx": 23359}
{"project": "qemu", "commit_id": "88571882516a7cb4291a329c537eb79fd126e1f2", "target": 0, "func": "static int qemu_rdma_post_send_control(RDMAContext *rdma, uint8_t *buf,\n\n                                       RDMAControlHeader *head)\n\n{\n\n    int ret = 0;\n\n    RDMAWorkRequestData *wr = &rdma->wr_data[RDMA_WRID_CONTROL];\n\n    struct ibv_send_wr *bad_wr;\n\n    struct ibv_sge sge = {\n\n                           .addr = (uint64_t)(wr->control),\n\n                           .length = head->len + sizeof(RDMAControlHeader),\n\n                           .lkey = wr->control_mr->lkey,\n\n                         };\n\n    struct ibv_send_wr send_wr = {\n\n                                   .wr_id = RDMA_WRID_SEND_CONTROL,\n\n                                   .opcode = IBV_WR_SEND,\n\n                                   .send_flags = IBV_SEND_SIGNALED,\n\n                                   .sg_list = &sge,\n\n                                   .num_sge = 1,\n\n                                };\n\n\n\n    DDDPRINTF(\"CONTROL: sending %s..\\n\", control_desc[head->type]);\n\n\n\n    /*\n\n     * We don't actually need to do a memcpy() in here if we used\n\n     * the \"sge\" properly, but since we're only sending control messages\n\n     * (not RAM in a performance-critical path), then its OK for now.\n\n     *\n\n     * The copy makes the RDMAControlHeader simpler to manipulate\n\n     * for the time being.\n\n     */\n\n    assert(head->len <= RDMA_CONTROL_MAX_BUFFER - sizeof(*head));\n\n    memcpy(wr->control, head, sizeof(RDMAControlHeader));\n\n    control_to_network((void *) wr->control);\n\n\n\n    if (buf) {\n\n        memcpy(wr->control + sizeof(RDMAControlHeader), buf, head->len);\n\n    }\n\n\n\n\n\n    if (ibv_post_send(rdma->qp, &send_wr, &bad_wr)) {\n\n        return -1;\n\n    }\n\n\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"Failed to use post IB SEND for control!\\n\");\n\n        return ret;\n\n    }\n\n\n\n    ret = qemu_rdma_block_for_wrid(rdma, RDMA_WRID_SEND_CONTROL);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"rdma migration: send polling control error!\\n\");\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 23360}
{"project": "qemu", "commit_id": "d0855f1235ed203700a3a24fc7e138490c272117", "target": 0, "func": "static int hdev_open(BlockDriverState *bs, QDict *options, int flags,\n\n                     Error **errp)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n#if defined(__APPLE__) && defined(__MACH__)\n\n    const char *filename = qdict_get_str(options, \"filename\");\n\n\n\n    if (strstart(filename, \"/dev/cdrom\", NULL)) {\n\n        kern_return_t kernResult;\n\n        io_iterator_t mediaIterator;\n\n        char bsdPath[ MAXPATHLEN ];\n\n        int fd;\n\n\n\n        kernResult = FindEjectableCDMedia( &mediaIterator );\n\n        kernResult = GetBSDPath(mediaIterator, bsdPath, sizeof(bsdPath),\n\n                                flags);\n\n        if ( bsdPath[ 0 ] != '\\0' ) {\n\n            strcat(bsdPath,\"s0\");\n\n            /* some CDs don't have a partition 0 */\n\n            fd = qemu_open(bsdPath, O_RDONLY | O_BINARY | O_LARGEFILE);\n\n            if (fd < 0) {\n\n                bsdPath[strlen(bsdPath)-1] = '1';\n\n            } else {\n\n                qemu_close(fd);\n\n            }\n\n            filename = bsdPath;\n\n            qdict_put(options, \"filename\", qstring_from_str(filename));\n\n        }\n\n\n\n        if ( mediaIterator )\n\n            IOObjectRelease( mediaIterator );\n\n    }\n\n#endif\n\n\n\n    s->type = FTYPE_FILE;\n\n\n\n    ret = raw_open_common(bs, options, flags, 0, &local_err);\n\n    if (ret < 0) {\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n        }\n\n        return ret;\n\n    }\n\n\n\n    /* Since this does ioctl the device must be already opened */\n\n    bs->sg = hdev_is_sg(bs);\n\n\n\n    if (flags & BDRV_O_RDWR) {\n\n        ret = check_hdev_writable(s);\n\n        if (ret < 0) {\n\n            raw_close(bs);\n\n            error_setg_errno(errp, -ret, \"The device is not writable\");\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 23362}
{"project": "qemu", "commit_id": "c87b1520726f7ae1e698a41f07043d1b539ac88c", "target": 0, "func": "static void pc_init1(MachineState *machine,\n\n                     int pci_enabled,\n\n                     int kvmclock_enabled)\n\n{\n\n    PCMachineState *pc_machine = PC_MACHINE(machine);\n\n    MemoryRegion *system_memory = get_system_memory();\n\n    MemoryRegion *system_io = get_system_io();\n\n    int i;\n\n    ram_addr_t below_4g_mem_size, above_4g_mem_size;\n\n    PCIBus *pci_bus;\n\n    ISABus *isa_bus;\n\n    PCII440FXState *i440fx_state;\n\n    int piix3_devfn = -1;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq *gsi;\n\n    qemu_irq *i8259;\n\n    qemu_irq *smi_irq;\n\n    GSIState *gsi_state;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    BusState *idebus[MAX_IDE_BUS];\n\n    ISADevice *rtc_state;\n\n    ISADevice *floppy;\n\n    MemoryRegion *ram_memory;\n\n    MemoryRegion *pci_memory;\n\n    MemoryRegion *rom_memory;\n\n    DeviceState *icc_bridge;\n\n    FWCfgState *fw_cfg = NULL;\n\n    PcGuestInfo *guest_info;\n\n\n\n    /* Check whether RAM fits below 4G (leaving 1/2 GByte for IO memory).\n\n     * If it doesn't, we need to split it in chunks below and above 4G.\n\n     * In any case, try to make sure that guest addresses aligned at\n\n     * 1G boundaries get mapped to host addresses aligned at 1G boundaries.\n\n     * For old machine types, use whatever split we used historically to avoid\n\n     * breaking migration.\n\n     */\n\n    if (machine->ram_size >= 0xe0000000) {\n\n        ram_addr_t lowmem = gigabyte_align ? 0xc0000000 : 0xe0000000;\n\n        above_4g_mem_size = machine->ram_size - lowmem;\n\n        below_4g_mem_size = lowmem;\n\n    } else {\n\n        above_4g_mem_size = 0;\n\n        below_4g_mem_size = machine->ram_size;\n\n    }\n\n\n\n    if (xen_enabled() && xen_hvm_init(&below_4g_mem_size, &above_4g_mem_size,\n\n                                      &ram_memory) != 0) {\n\n        fprintf(stderr, \"xen hardware virtual machine initialisation failed\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    icc_bridge = qdev_create(NULL, TYPE_ICC_BRIDGE);\n\n    object_property_add_child(qdev_get_machine(), \"icc-bridge\",\n\n                              OBJECT(icc_bridge), NULL);\n\n\n\n    pc_cpus_init(machine->cpu_model, icc_bridge);\n\n\n\n    if (kvm_enabled() && kvmclock_enabled) {\n\n        kvmclock_create();\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pci_memory = g_new(MemoryRegion, 1);\n\n        memory_region_init(pci_memory, NULL, \"pci\", UINT64_MAX);\n\n        rom_memory = pci_memory;\n\n    } else {\n\n        pci_memory = NULL;\n\n        rom_memory = system_memory;\n\n    }\n\n\n\n    guest_info = pc_guest_info_init(below_4g_mem_size, above_4g_mem_size);\n\n\n\n    guest_info->has_acpi_build = has_acpi_build;\n\n\n\n    guest_info->has_pci_info = has_pci_info;\n\n    guest_info->isapc_ram_fw = !pci_enabled;\n\n    guest_info->has_reserved_memory = has_reserved_memory;\n\n\n\n    if (smbios_defaults) {\n\n        MachineClass *mc = MACHINE_GET_CLASS(machine);\n\n        /* These values are guest ABI, do not change */\n\n        smbios_set_defaults(\"QEMU\", \"Standard PC (i440FX + PIIX, 1996)\",\n\n                            mc->name, smbios_legacy_mode);\n\n    }\n\n\n\n    /* allocate ram and load rom/bios */\n\n    if (!xen_enabled()) {\n\n        fw_cfg = pc_memory_init(machine, system_memory,\n\n                                below_4g_mem_size, above_4g_mem_size,\n\n                                rom_memory, &ram_memory, guest_info);\n\n    }\n\n\n\n    gsi_state = g_malloc0(sizeof(*gsi_state));\n\n    if (kvm_irqchip_in_kernel()) {\n\n        kvm_pc_setup_irq_routing(pci_enabled);\n\n        gsi = qemu_allocate_irqs(kvm_pc_gsi_handler, gsi_state,\n\n                                 GSI_NUM_PINS);\n\n    } else {\n\n        gsi = qemu_allocate_irqs(gsi_handler, gsi_state, GSI_NUM_PINS);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pci_bus = i440fx_init(&i440fx_state, &piix3_devfn, &isa_bus, gsi,\n\n                              system_memory, system_io, machine->ram_size,\n\n                              below_4g_mem_size,\n\n                              above_4g_mem_size,\n\n                              pci_memory, ram_memory);\n\n    } else {\n\n        pci_bus = NULL;\n\n        i440fx_state = NULL;\n\n        isa_bus = isa_bus_new(NULL, system_io);\n\n        no_hpet = 1;\n\n    }\n\n    isa_bus_irqs(isa_bus, gsi);\n\n\n\n    if (kvm_irqchip_in_kernel()) {\n\n        i8259 = kvm_i8259_init(isa_bus);\n\n    } else if (xen_enabled()) {\n\n        i8259 = xen_interrupt_controller_init();\n\n    } else {\n\n        cpu_irq = pc_allocate_cpu_irq();\n\n        i8259 = i8259_init(isa_bus, cpu_irq[0]);\n\n    }\n\n\n\n    for (i = 0; i < ISA_NUM_IRQS; i++) {\n\n        gsi_state->i8259_irq[i] = i8259[i];\n\n    }\n\n    if (pci_enabled) {\n\n        ioapic_init_gsi(gsi_state, \"i440fx\");\n\n    }\n\n    qdev_init_nofail(icc_bridge);\n\n\n\n    pc_register_ferr_irq(gsi[13]);\n\n\n\n    pc_vga_init(isa_bus, pci_enabled ? pci_bus : NULL);\n\n\n\n    /* init basic PC hardware */\n\n    pc_basic_device_init(isa_bus, gsi, &rtc_state, &floppy, xen_enabled(),\n\n        0x4);\n\n\n\n    pc_nic_init(isa_bus, pci_bus);\n\n\n\n    ide_drive_get(hd, MAX_IDE_BUS);\n\n    if (pci_enabled) {\n\n        PCIDevice *dev;\n\n        if (xen_enabled()) {\n\n            dev = pci_piix3_xen_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        } else {\n\n            dev = pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        }\n\n        idebus[0] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        idebus[1] = qdev_get_child_bus(&dev->qdev, \"ide.1\");\n\n    } else {\n\n        for(i = 0; i < MAX_IDE_BUS; i++) {\n\n            ISADevice *dev;\n\n            char busname[] = \"ide.0\";\n\n            dev = isa_ide_init(isa_bus, ide_iobase[i], ide_iobase2[i],\n\n                               ide_irq[i],\n\n                               hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);\n\n            /*\n\n             * The ide bus name is ide.0 for the first bus and ide.1 for the\n\n             * second one.\n\n             */\n\n            busname[4] = '0' + i;\n\n            idebus[i] = qdev_get_child_bus(DEVICE(dev), busname);\n\n        }\n\n    }\n\n\n\n    pc_cmos_init(below_4g_mem_size, above_4g_mem_size, machine->boot_order,\n\n                 floppy, idebus[0], idebus[1], rtc_state);\n\n\n\n    if (pci_enabled && usb_enabled(false)) {\n\n        pci_create_simple(pci_bus, piix3_devfn + 2, \"piix3-usb-uhci\");\n\n    }\n\n\n\n    if (pci_enabled && acpi_enabled) {\n\n        DeviceState *piix4_pm;\n\n        I2CBus *smbus;\n\n\n\n        smi_irq = qemu_allocate_irqs(pc_acpi_smi_interrupt, first_cpu, 1);\n\n        /* TODO: Populate SPD eeprom data.  */\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100,\n\n                              gsi[9], *smi_irq,\n\n                              kvm_enabled(), fw_cfg, &piix4_pm);\n\n        smbus_eeprom_init(smbus, 8, NULL, 0);\n\n\n\n        object_property_add_link(OBJECT(machine), PC_MACHINE_ACPI_DEVICE_PROP,\n\n                                 TYPE_HOTPLUG_HANDLER,\n\n                                 (Object **)&pc_machine->acpi_dev,\n\n                                 object_property_allow_set_link,\n\n                                 OBJ_PROP_LINK_UNREF_ON_RELEASE, &error_abort);\n\n        object_property_set_link(OBJECT(machine), OBJECT(piix4_pm),\n\n                                 PC_MACHINE_ACPI_DEVICE_PROP, &error_abort);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pc_pci_device_init(pci_bus);\n\n    }\n\n}\n", "idx": 23363}
{"project": "qemu", "commit_id": "8360544a6d3a54df1fce80f55ba4ad075a8ded54", "target": 0, "func": "static void qpci_spapr_io_writel(QPCIBus *bus, void *addr, uint32_t value)\n\n{\n\n    QPCIBusSPAPR *s = container_of(bus, QPCIBusSPAPR, bus);\n\n    uint64_t port = (uintptr_t)addr;\n\n    value = bswap32(value);\n\n    if (port < s->pio.size) {\n\n        writel(s->pio_cpu_base + port, value);\n\n    } else {\n\n        writel(s->mmio_cpu_base + port, value);\n\n    }\n\n}\n", "idx": 23364}
{"project": "qemu", "commit_id": "1bc04a8880374407c4b12d82ceb8752e12ff5336", "target": 0, "func": "static void pmsav7_write(CPUARMState *env, const ARMCPRegInfo *ri,\n\n                         uint64_t value)\n\n{\n\n    ARMCPU *cpu = arm_env_get_cpu(env);\n\n    uint32_t *u32p = *(uint32_t **)raw_ptr(env, ri);\n\n\n\n    if (!u32p) {\n\n        return;\n\n    }\n\n\n\n    u32p += env->pmsav7.rnr;\n\n    tlb_flush(CPU(cpu)); /* Mappings may have changed - purge! */\n\n    *u32p = value;\n\n}\n", "idx": 23365}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void qemu_opts_del(QemuOpts *opts)\n\n{\n\n    QemuOpt *opt;\n\n\n\n    for (;;) {\n\n        opt = TAILQ_FIRST(&opts->head);\n\n        if (opt == NULL)\n\n            break;\n\n        qemu_opt_del(opt);\n\n    }\n\n    TAILQ_REMOVE(&opts->list->head, opts, next);\n\n    qemu_free(opts);\n\n}\n", "idx": 23366}
{"project": "qemu", "commit_id": "5819e3e072f41cbf81ad80d822a5c468a91f54e0", "target": 0, "func": "static int get_char(GDBState *s)\n\n{\n\n    uint8_t ch;\n\n    int ret;\n\n\n\n    for(;;) {\n\n        ret = qemu_recv(s->fd, &ch, 1, 0);\n\n        if (ret < 0) {\n\n            if (errno == ECONNRESET)\n\n                s->fd = -1;\n\n            if (errno != EINTR && errno != EAGAIN)\n\n                return -1;\n\n        } else if (ret == 0) {\n\n            close(s->fd);\n\n            s->fd = -1;\n\n            return -1;\n\n        } else {\n\n            break;\n\n        }\n\n    }\n\n    return ch;\n\n}\n", "idx": 23367}
{"project": "qemu", "commit_id": "581b9e29f36eec5de0779c3dbade980e4405d92e", "target": 0, "func": "static int raw_pwrite(BlockDriverState *bs, int64_t offset,\n\n                      const uint8_t *buf, int count)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    int size, ret, shift, sum;\n\n\n\n    sum = 0;\n\n\n\n    if (s->aligned_buf != NULL) {\n\n\n\n        if (offset & 0x1ff) {\n\n            /* align offset on a 512 bytes boundary */\n\n            shift = offset & 0x1ff;\n\n            ret = raw_pread_aligned(bs, offset - shift, s->aligned_buf, 512);\n\n            if (ret < 0)\n\n                return ret;\n\n\n\n            size = 512 - shift;\n\n            if (size > count)\n\n                size = count;\n\n            memcpy(s->aligned_buf + shift, buf, size);\n\n\n\n            ret = raw_pwrite_aligned(bs, offset - shift, s->aligned_buf, 512);\n\n            if (ret < 0)\n\n                return ret;\n\n\n\n            buf += size;\n\n            offset += size;\n\n            count -= size;\n\n            sum += size;\n\n\n\n            if (count == 0)\n\n                return sum;\n\n        }\n\n        if (count & 0x1ff || (uintptr_t) buf & 0x1ff) {\n\n\n\n            while ((size = (count & ~0x1ff)) != 0) {\n\n\n\n                if (size > ALIGNED_BUFFER_SIZE)\n\n                    size = ALIGNED_BUFFER_SIZE;\n\n\n\n                memcpy(s->aligned_buf, buf, size);\n\n\n\n                ret = raw_pwrite_aligned(bs, offset, s->aligned_buf, size);\n\n                if (ret < 0)\n\n                    return ret;\n\n\n\n                buf += ret;\n\n                offset += ret;\n\n                count -= ret;\n\n                sum += ret;\n\n            }\n\n            /* here, count < 512 because (count & ~0x1ff) == 0 */\n\n            if (count) {\n\n                ret = raw_pread_aligned(bs, offset, s->aligned_buf, 512);\n\n                if (ret < 0)\n\n                    return ret;\n\n                 memcpy(s->aligned_buf, buf, count);\n\n\n\n                 ret = raw_pwrite_aligned(bs, offset, s->aligned_buf, 512);\n\n                 if (ret < 0)\n\n                     return ret;\n\n                 if (count < ret)\n\n                     ret = count;\n\n\n\n                 sum += ret;\n\n            }\n\n            return sum;\n\n        }\n\n    }\n\n    return raw_pwrite_aligned(bs, offset, buf, count) + sum;\n\n}\n", "idx": 23368}
{"project": "qemu", "commit_id": "7ec1e5ea4bd0700fa48da86bffa2fcc6146c410a", "target": 0, "func": "static void gen_ldda_asi(DisasContext *dc, TCGv hi, TCGv addr,\n\n                         int insn, int rd)\n\n{\n\n    TCGv_i32 r_asi, r_rd;\n\n\n\n    r_asi = gen_get_asi(dc, insn);\n\n    r_rd = tcg_const_i32(rd);\n\n    gen_helper_ldda_asi(cpu_env, addr, r_asi, r_rd);\n\n    tcg_temp_free_i32(r_rd);\n\n    tcg_temp_free_i32(r_asi);\n\n}\n", "idx": 23369}
{"project": "qemu", "commit_id": "9abf567d95a4e840df868ca993219175fbef8c22", "target": 0, "func": "static int kvm_sclp_service_call(CPUS390XState *env, struct kvm_run *run,\n\n                                 uint16_t ipbh0)\n\n{\n\n    uint32_t sccb;\n\n    uint64_t code;\n\n    int r = 0;\n\n\n\n    cpu_synchronize_state(env);\n\n    sccb = env->regs[ipbh0 & 0xf];\n\n    code = env->regs[(ipbh0 & 0xf0) >> 4];\n\n\n\n    r = sclp_service_call(env, sccb, code);\n\n    if (r) {\n\n        setcc(env, 3);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23370}
{"project": "qemu", "commit_id": "203d65a4706be345c209f3408d3a011a3e48f0c9", "target": 0, "func": "static void imx_epit_reset(DeviceState *dev)\n\n{\n\n    IMXEPITState *s = IMX_EPIT(dev);\n\n\n\n    /*\n\n     * Soft reset doesn't touch some bits; hard reset clears them\n\n     */\n\n    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);\n\n    s->sr = 0;\n\n    s->lr = TIMER_MAX;\n\n    s->cmp = 0;\n\n    s->cnt = 0;\n\n    /* stop both timers */\n\n    ptimer_stop(s->timer_cmp);\n\n    ptimer_stop(s->timer_reload);\n\n    /* compute new frequency */\n\n    imx_epit_set_freq(s);\n\n    /* init both timers to TIMER_MAX */\n\n    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);\n\n    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);\n\n    if (s->freq && (s->cr & CR_EN)) {\n\n        /* if the timer is still enabled, restart it */\n\n        ptimer_run(s->timer_reload, 0);\n\n    }\n\n}\n", "idx": 23371}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "void acpi_pcihp_device_unplug_cb(HotplugHandler *hotplug_dev, AcpiPciHpState *s,\n\n                                 DeviceState *dev, Error **errp)\n\n{\n\n    PCIDevice *pdev = PCI_DEVICE(dev);\n\n    int slot = PCI_SLOT(pdev->devfn);\n\n    int bsel = acpi_pcihp_get_bsel(pdev->bus);\n\n    if (bsel < 0) {\n\n        error_setg(errp, \"Unsupported bus. Bus doesn't have property '\"\n\n                   ACPI_PCIHP_PROP_BSEL \"' set\");\n\n        return;\n\n    }\n\n\n\n    s->acpi_pcihp_pci_status[bsel].down |= (1U << slot);\n\n    acpi_send_event(DEVICE(hotplug_dev), ACPI_PCI_HOTPLUG_STATUS);\n\n}\n", "idx": 23373}
{"project": "qemu", "commit_id": "1828be316f6637d43dd4c4f5f32925b17fb8107f", "target": 0, "func": "static void quit_timers(void)\n\n{\n\n    alarm_timer->stop(alarm_timer);\n\n    alarm_timer = NULL;\n\n}\n", "idx": 23374}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "void do_raise_exception_err (uint32_t exception, int error_code)\n\n{\n\n#if 0\n\n    printf(\"Raise exception %3x code : %d\\n\", exception, error_code);\n\n#endif\n\n    switch (exception) {\n\n    case EXCP_PROGRAM:\n\n        if (error_code == EXCP_FP && msr_fe0 == 0 && msr_fe1 == 0)\n\n            return;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n    env->exception_index = exception;\n\n    env->error_code = error_code;\n\n    cpu_loop_exit();\n\n}\n", "idx": 23375}
{"project": "qemu", "commit_id": "96a8821d21411f10d77ea994af369c6e5c35a2cc", "target": 0, "func": "static AddressSpace *virtio_pci_get_dma_as(DeviceState *d)\n\n{\n\n    VirtIOPCIProxy *proxy = VIRTIO_PCI(d);\n\n    PCIDevice *dev = &proxy->pci_dev;\n\n\n\n    return pci_get_address_space(dev);\n\n}\n", "idx": 23376}
{"project": "qemu", "commit_id": "b227a8e9aa5f27d29f77ba90d5eb9d0662a1175e", "target": 0, "func": "static int pte32_check (mmu_ctx_t *ctx,\n\n                        target_ulong pte0, target_ulong pte1, int h, int rw)\n\n{\n\n    return _pte_check(ctx, 0, pte0, pte1, h, rw);\n\n}\n", "idx": 23377}
{"project": "qemu", "commit_id": "b8d834a00fa3ed4dad7d371e1a00938a126a54a0", "target": 0, "func": "static void x86_cpu_class_check_missing_features(X86CPUClass *xcc,\n\n                                                 strList **missing_feats)\n\n{\n\n    X86CPU *xc;\n\n    FeatureWord w;\n\n    Error *err = NULL;\n\n    strList **next = missing_feats;\n\n\n\n    if (xcc->kvm_required && !kvm_enabled()) {\n\n        strList *new = g_new0(strList, 1);\n\n        new->value = g_strdup(\"kvm\");;\n\n        *missing_feats = new;\n\n        return;\n\n    }\n\n\n\n    xc = X86_CPU(object_new(object_class_get_name(OBJECT_CLASS(xcc))));\n\n\n\n    x86_cpu_load_features(xc, &err);\n\n    if (err) {\n\n        /* Errors at x86_cpu_load_features should never happen,\n\n         * but in case it does, just report the model as not\n\n         * runnable at all using the \"type\" property.\n\n         */\n\n        strList *new = g_new0(strList, 1);\n\n        new->value = g_strdup(\"type\");\n\n        *next = new;\n\n        next = &new->next;\n\n    }\n\n\n\n    x86_cpu_filter_features(xc);\n\n\n\n    for (w = 0; w < FEATURE_WORDS; w++) {\n\n        uint32_t filtered = xc->filtered_features[w];\n\n        int i;\n\n        for (i = 0; i < 32; i++) {\n\n            if (filtered & (1UL << i)) {\n\n                strList *new = g_new0(strList, 1);\n\n                new->value = g_strdup(x86_cpu_feature_name(w, i));\n\n                *next = new;\n\n                next = &new->next;\n\n            }\n\n        }\n\n    }\n\n\n\n    object_unref(OBJECT(xc));\n\n}\n", "idx": 23378}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_debug_resume(BlockDriverState *bs, const char *tag)\n\n{\n\n    while (bs && (!bs->drv || !bs->drv->bdrv_debug_resume)) {\n\n        bs = bs->file;\n\n    }\n\n\n\n    if (bs && bs->drv && bs->drv->bdrv_debug_resume) {\n\n        return bs->drv->bdrv_debug_resume(bs, tag);\n\n    }\n\n\n\n    return -ENOTSUP;\n\n}\n", "idx": 23379}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_flush(BlockDriverState *bs)\n\n{\n\n    Coroutine *co;\n\n    RwCo rwco = {\n\n        .bs = bs,\n\n        .ret = NOT_DONE,\n\n    };\n\n\n\n    if (qemu_in_coroutine()) {\n\n        /* Fast-path if already in coroutine context */\n\n        bdrv_flush_co_entry(&rwco);\n\n    } else {\n\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n\n\n        co = qemu_coroutine_create(bdrv_flush_co_entry);\n\n        qemu_coroutine_enter(co, &rwco);\n\n        while (rwco.ret == NOT_DONE) {\n\n            aio_poll(aio_context, true);\n\n        }\n\n    }\n\n\n\n    return rwco.ret;\n\n}\n", "idx": 23380}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "void qmp_nbd_server_start(SocketAddressLegacy *addr,\n\n                          bool has_tls_creds, const char *tls_creds,\n\n                          Error **errp)\n\n{\n\n    if (nbd_server) {\n\n        error_setg(errp, \"NBD server already running\");\n\n        return;\n\n    }\n\n\n\n    nbd_server = g_new0(NBDServerData, 1);\n\n    nbd_server->watch = -1;\n\n    nbd_server->listen_ioc = qio_channel_socket_new();\n\n    qio_channel_set_name(QIO_CHANNEL(nbd_server->listen_ioc),\n\n                         \"nbd-listener\");\n\n    if (qio_channel_socket_listen_sync(\n\n            nbd_server->listen_ioc, addr, errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n    if (has_tls_creds) {\n\n        nbd_server->tlscreds = nbd_get_tls_creds(tls_creds, errp);\n\n        if (!nbd_server->tlscreds) {\n\n            goto error;\n\n        }\n\n\n\n        /* TODO SOCKET_ADDRESS_LEGACY_KIND_FD where fd has AF_INET or AF_INET6 */\n\n        if (addr->type != SOCKET_ADDRESS_LEGACY_KIND_INET) {\n\n            error_setg(errp, \"TLS is only supported with IPv4/IPv6\");\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    nbd_server->watch = qio_channel_add_watch(\n\n        QIO_CHANNEL(nbd_server->listen_ioc),\n\n        G_IO_IN,\n\n        nbd_accept,\n\n        NULL,\n\n        NULL);\n\n\n\n    return;\n\n\n\n error:\n\n    nbd_server_free(nbd_server);\n\n    nbd_server = NULL;\n\n}\n", "idx": 23381}
{"project": "qemu", "commit_id": "241187c11818e5223c4bdfac79f28fdf63731733", "target": 0, "func": "vubr_backend_recv_cb(int sock, void *ctx)\n\n{\n\n    VubrDev *vubr = (VubrDev *) ctx;\n\n    VuDev *dev = &vubr->vudev;\n\n    VuVirtq *vq = vu_get_queue(dev, 0);\n\n    VuVirtqElement *elem = NULL;\n\n    struct iovec mhdr_sg[VIRTQUEUE_MAX_SIZE];\n\n    struct virtio_net_hdr_mrg_rxbuf mhdr;\n\n    unsigned mhdr_cnt = 0;\n\n    int hdrlen = vubr->hdrlen;\n\n    int i = 0;\n\n    struct virtio_net_hdr hdr = {\n\n        .flags = 0,\n\n        .gso_type = VIRTIO_NET_HDR_GSO_NONE\n\n    };\n\n\n\n    DPRINT(\"\\n\\n   ***   IN UDP RECEIVE CALLBACK    ***\\n\\n\");\n\n    DPRINT(\"    hdrlen = %d\\n\", hdrlen);\n\n\n\n    if (!vu_queue_enabled(dev, vq) ||\n\n        !vu_queue_started(dev, vq) ||\n\n        !vu_queue_avail_bytes(dev, vq, hdrlen, 0)) {\n\n        DPRINT(\"Got UDP packet, but no available descriptors on RX virtq.\\n\");\n\n        return;\n\n    }\n\n\n\n    do {\n\n        struct iovec *sg;\n\n        ssize_t ret, total = 0;\n\n        unsigned int num;\n\n\n\n        elem = vu_queue_pop(dev, vq, sizeof(VuVirtqElement));\n\n        if (!elem) {\n\n            break;\n\n        }\n\n\n\n        if (elem->in_num < 1) {\n\n            fprintf(stderr, \"virtio-net contains no in buffers\\n\");\n\n            break;\n\n        }\n\n\n\n        sg = elem->in_sg;\n\n        num = elem->in_num;\n\n        if (i == 0) {\n\n            if (hdrlen == 12) {\n\n                mhdr_cnt = iov_copy(mhdr_sg, ARRAY_SIZE(mhdr_sg),\n\n                                    sg, elem->in_num,\n\n                                    offsetof(typeof(mhdr), num_buffers),\n\n                                    sizeof(mhdr.num_buffers));\n\n            }\n\n            iov_from_buf(sg, elem->in_num, 0, &hdr, sizeof hdr);\n\n            total += hdrlen;\n\n            ret = iov_discard_front(&sg, &num, hdrlen);\n\n            assert(ret == hdrlen);\n\n        }\n\n\n\n        struct msghdr msg = {\n\n            .msg_name = (struct sockaddr *) &vubr->backend_udp_dest,\n\n            .msg_namelen = sizeof(struct sockaddr_in),\n\n            .msg_iov = sg,\n\n            .msg_iovlen = elem->in_num,\n\n            .msg_flags = MSG_DONTWAIT,\n\n        };\n\n        do {\n\n            ret = recvmsg(vubr->backend_udp_sock, &msg, 0);\n\n        } while (ret == -1 && (errno == EINTR));\n\n\n\n        if (i == 0) {\n\n            iov_restore_front(elem->in_sg, sg, hdrlen);\n\n        }\n\n\n\n        if (ret == -1) {\n\n            if (errno == EWOULDBLOCK) {\n\n                vu_queue_rewind(dev, vq, 1);\n\n                break;\n\n            }\n\n\n\n            vubr_die(\"recvmsg()\");\n\n        }\n\n\n\n        total += ret;\n\n        iov_truncate(elem->in_sg, elem->in_num, total);\n\n        vu_queue_fill(dev, vq, elem, total, i++);\n\n\n\n        free(elem);\n\n        elem = NULL;\n\n    } while (false); /* could loop if DONTWAIT worked? */\n\n\n\n    if (mhdr_cnt) {\n\n        mhdr.num_buffers = i;\n\n        iov_from_buf(mhdr_sg, mhdr_cnt,\n\n                     0,\n\n                     &mhdr.num_buffers, sizeof mhdr.num_buffers);\n\n    }\n\n\n\n    vu_queue_flush(dev, vq, i);\n\n    vu_queue_notify(dev, vq);\n\n\n\n    free(elem);\n\n}\n", "idx": 23382}
{"project": "qemu", "commit_id": "d470ad42acfc73c45d3e8ed5311a491160b4c100", "target": 1, "func": "static int coroutine_fn bdrv_aligned_pwritev(BdrvChild *child,\n    BdrvTrackedRequest *req, int64_t offset, unsigned int bytes,\n    int64_t align, QEMUIOVector *qiov, int flags)\n{\n    BlockDriverState *bs = child->bs;\n    BlockDriver *drv = bs->drv;\n    bool waited;\n    int ret;\n    int64_t end_sector = DIV_ROUND_UP(offset + bytes, BDRV_SECTOR_SIZE);\n    uint64_t bytes_remaining = bytes;\n    int max_transfer;\n    if (bdrv_has_readonly_bitmaps(bs)) {\n        return -EPERM;\n    assert(is_power_of_2(align));\n    assert((offset & (align - 1)) == 0);\n    assert((bytes & (align - 1)) == 0);\n    assert(!qiov || bytes == qiov->size);\n    assert((bs->open_flags & BDRV_O_NO_IO) == 0);\n    assert(!(flags & ~BDRV_REQ_MASK));\n    max_transfer = QEMU_ALIGN_DOWN(MIN_NON_ZERO(bs->bl.max_transfer, INT_MAX),\n                                   align);\n    waited = wait_serialising_requests(req);\n    assert(!waited || !req->serialising);\n    assert(req->overlap_offset <= offset);\n    assert(offset + bytes <= req->overlap_offset + req->overlap_bytes);\n    assert(child->perm & BLK_PERM_WRITE);\n    assert(end_sector <= bs->total_sectors || child->perm & BLK_PERM_RESIZE);\n    ret = notifier_with_return_list_notify(&bs->before_write_notifiers, req);\n    if (!ret && bs->detect_zeroes != BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF &&\n        !(flags & BDRV_REQ_ZERO_WRITE) && drv->bdrv_co_pwrite_zeroes &&\n        qemu_iovec_is_zero(qiov)) {\n        flags |= BDRV_REQ_ZERO_WRITE;\n        if (bs->detect_zeroes == BLOCKDEV_DETECT_ZEROES_OPTIONS_UNMAP) {\n            flags |= BDRV_REQ_MAY_UNMAP;\n    if (ret < 0) {\n        /* Do nothing, write notifier decided to fail this request */\n    } else if (flags & BDRV_REQ_ZERO_WRITE) {\n        bdrv_debug_event(bs, BLKDBG_PWRITEV_ZERO);\n        ret = bdrv_co_do_pwrite_zeroes(bs, offset, bytes, flags);\n    } else if (flags & BDRV_REQ_WRITE_COMPRESSED) {\n        ret = bdrv_driver_pwritev_compressed(bs, offset, bytes, qiov);\n    } else if (bytes <= max_transfer) {\n        bdrv_debug_event(bs, BLKDBG_PWRITEV);\n        ret = bdrv_driver_pwritev(bs, offset, bytes, qiov, flags);\n    } else {\n        bdrv_debug_event(bs, BLKDBG_PWRITEV);\n        while (bytes_remaining) {\n            int num = MIN(bytes_remaining, max_transfer);\n            QEMUIOVector local_qiov;\n            int local_flags = flags;\n            assert(num);\n            if (num < bytes_remaining && (flags & BDRV_REQ_FUA) &&\n                !(bs->supported_write_flags & BDRV_REQ_FUA)) {\n                /* If FUA is going to be emulated by flush, we only\n                 * need to flush on the last iteration */\n                local_flags &= ~BDRV_REQ_FUA;\n            qemu_iovec_init(&local_qiov, qiov->niov);\n            qemu_iovec_concat(&local_qiov, qiov, bytes - bytes_remaining, num);\n            ret = bdrv_driver_pwritev(bs, offset + bytes - bytes_remaining,\n                                      num, &local_qiov, local_flags);\n            qemu_iovec_destroy(&local_qiov);\n            if (ret < 0) {\n                break;\n            bytes_remaining -= num;\n    bdrv_debug_event(bs, BLKDBG_PWRITEV_DONE);\n    atomic_inc(&bs->write_gen);\n    bdrv_set_dirty(bs, offset, bytes);\n    stat64_max(&bs->wr_highest_offset, offset + bytes);\n    if (ret >= 0) {\n        bs->total_sectors = MAX(bs->total_sectors, end_sector);\n        ret = 0;\n    return ret;", "idx": 23386}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int qemu_rdma_exchange_send(RDMAContext *rdma, RDMAControlHeader *head,\n\n                                   uint8_t *data, RDMAControlHeader *resp,\n\n                                   int *resp_idx,\n\n                                   int (*callback)(RDMAContext *rdma))\n\n{\n\n    int ret = 0;\n\n\n\n    /*\n\n     * Wait until the dest is ready before attempting to deliver the message\n\n     * by waiting for a READY message.\n\n     */\n\n    if (rdma->control_ready_expected) {\n\n        RDMAControlHeader resp;\n\n        ret = qemu_rdma_exchange_get_response(rdma,\n\n                                    &resp, RDMA_CONTROL_READY, RDMA_WRID_READY);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /*\n\n     * If the user is expecting a response, post a WR in anticipation of it.\n\n     */\n\n    if (resp) {\n\n        ret = qemu_rdma_post_recv_control(rdma, RDMA_WRID_DATA);\n\n        if (ret) {\n\n            fprintf(stderr, \"rdma migration: error posting\"\n\n                    \" extra control recv for anticipated result!\");\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /*\n\n     * Post a WR to replace the one we just consumed for the READY message.\n\n     */\n\n    ret = qemu_rdma_post_recv_control(rdma, RDMA_WRID_READY);\n\n    if (ret) {\n\n        fprintf(stderr, \"rdma migration: error posting first control recv!\");\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * Deliver the control message that was requested.\n\n     */\n\n    ret = qemu_rdma_post_send_control(rdma, data, head);\n\n\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"Failed to send control buffer!\\n\");\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * If we're expecting a response, block and wait for it.\n\n     */\n\n    if (resp) {\n\n        if (callback) {\n\n            DDPRINTF(\"Issuing callback before receiving response...\\n\");\n\n            ret = callback(rdma);\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n        }\n\n\n\n        DDPRINTF(\"Waiting for response %s\\n\", control_desc[resp->type]);\n\n        ret = qemu_rdma_exchange_get_response(rdma, resp,\n\n                                              resp->type, RDMA_WRID_DATA);\n\n\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        qemu_rdma_move_header(rdma, RDMA_WRID_DATA, resp);\n\n        if (resp_idx) {\n\n            *resp_idx = RDMA_WRID_DATA;\n\n        }\n\n        DDPRINTF(\"Response %s received.\\n\", control_desc[resp->type]);\n\n    }\n\n\n\n    rdma->control_ready_expected = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 23387}
{"project": "qemu", "commit_id": "36ad0e948e15d8d86c8dec1c17a8588d87b0107d", "target": 1, "func": "static int configure_accelerator(void)\n\n{\n\n    const char *p = NULL;\n\n    char buf[10];\n\n    int i, ret;\n\n    bool accel_initialised = false;\n\n    bool init_failed = false;\n\n\n\n    QemuOptsList *list = qemu_find_opts(\"machine\");\n\n    if (!QTAILQ_EMPTY(&list->head)) {\n\n        p = qemu_opt_get(QTAILQ_FIRST(&list->head), \"accel\");\n\n    }\n\n\n\n    if (p == NULL) {\n\n        /* Use the default \"accelerator\", tcg */\n\n        p = \"tcg\";\n\n    }\n\n\n\n    while (!accel_initialised && *p != '\\0') {\n\n        if (*p == ':') {\n\n            p++;\n\n        }\n\n        p = get_opt_name(buf, sizeof (buf), p, ':');\n\n        for (i = 0; i < ARRAY_SIZE(accel_list); i++) {\n\n            if (strcmp(accel_list[i].opt_name, buf) == 0) {\n\n                if (!accel_list[i].available()) {\n\n                    printf(\"%s not supported for this target\\n\",\n\n                           accel_list[i].name);\n\n                    continue;\n\n                }\n\n                *(accel_list[i].allowed) = true;\n\n                ret = accel_list[i].init();\n\n                if (ret < 0) {\n\n                    init_failed = true;\n\n                    fprintf(stderr, \"failed to initialize %s: %s\\n\",\n\n                            accel_list[i].name,\n\n                            strerror(-ret));\n\n                    *(accel_list[i].allowed) = false;\n\n                } else {\n\n                    accel_initialised = true;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n        if (i == ARRAY_SIZE(accel_list)) {\n\n            fprintf(stderr, \"\\\"%s\\\" accelerator does not exist.\\n\", buf);\n\n        }\n\n    }\n\n\n\n    if (!accel_initialised) {\n\n        if (!init_failed) {\n\n            fprintf(stderr, \"No accelerator found!\\n\");\n\n        }\n\n        exit(1);\n\n    }\n\n\n\n    if (init_failed) {\n\n        fprintf(stderr, \"Back to %s accelerator.\\n\", accel_list[i].name);\n\n    }\n\n\n\n    return !accel_initialised;\n\n}\n", "idx": 23388}
{"project": "qemu", "commit_id": "d5b27167e17e0d9393d6364703cc68e7f018023c", "target": 1, "func": "void qemu_chr_add_handlers(CharDriverState *s,\n\n                           IOCanReadHandler *fd_can_read,\n\n                           IOReadHandler *fd_read,\n\n                           IOEventHandler *fd_event,\n\n                           void *opaque)\n\n{\n\n    if (!opaque) {\n\n        /* chr driver being released. */\n\n        s->assigned = 0;\n\n    }\n\n    s->chr_can_read = fd_can_read;\n\n    s->chr_read = fd_read;\n\n    s->chr_event = fd_event;\n\n    s->handler_opaque = opaque;\n\n    if (s->chr_update_read_handler)\n\n        s->chr_update_read_handler(s);\n\n\n\n    /* We're connecting to an already opened device, so let's make sure we\n\n       also get the open event */\n\n    if (s->opened) {\n\n        qemu_chr_generic_open(s);\n\n    }\n\n}\n", "idx": 23389}
{"project": "qemu", "commit_id": "e4f4fb1eca795e36f363b4647724221e774523c1", "target": 1, "func": "static void ohci_sysbus_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = ohci_realize_pxa;\n\n    set_bit(DEVICE_CATEGORY_USB, dc->categories);\n\n    dc->desc = \"OHCI USB Controller\";\n\n    dc->props = ohci_sysbus_properties;\n\n    dc->reset = usb_ohci_reset_sysbus;\n\n\n\n\n\n\n}", "idx": 23392}
{"project": "qemu", "commit_id": "3c529d935923a70519557d420db1d5a09a65086a", "target": 0, "func": "static BlockDriverAIOCB *raw_aio_read(BlockDriverState *bs,\n\n        int64_t sector_num, uint8_t *buf, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    RawAIOCB *acb;\n\n\n\n    /*\n\n     * If O_DIRECT is used and the buffer is not aligned fall back\n\n     * to synchronous IO.\n\n     */\n\n    BDRVRawState *s = bs->opaque;\n\n\n\n    if (unlikely(s->aligned_buf != NULL && ((uintptr_t) buf % 512))) {\n\n        QEMUBH *bh;\n\n        acb = qemu_aio_get(bs, cb, opaque);\n\n        acb->ret = raw_pread(bs, 512 * sector_num, buf, 512 * nb_sectors);\n\n        bh = qemu_bh_new(raw_aio_em_cb, acb);\n\n        qemu_bh_schedule(bh);\n\n        return &acb->common;\n\n    }\n\n\n\n    acb = raw_aio_setup(bs, sector_num, buf, nb_sectors, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    if (aio_read(&acb->aiocb) < 0) {\n\n        qemu_aio_release(acb);\n\n        return NULL;\n\n    }\n\n    return &acb->common;\n\n}\n", "idx": 23393}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t mpc8544_guts_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    uint32_t value = 0;\n\n    CPUPPCState *env = cpu_single_env;\n\n\n\n    addr &= MPC8544_GUTS_MMIO_SIZE - 1;\n\n    switch (addr) {\n\n    case MPC8544_GUTS_ADDR_PVR:\n\n        value = env->spr[SPR_PVR];\n\n        break;\n\n    case MPC8544_GUTS_ADDR_SVR:\n\n        value = env->spr[SPR_E500_SVR];\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"guts: Unknown register read: %x\\n\", (int)addr);\n\n        break;\n\n    }\n\n\n\n    return value;\n\n}\n", "idx": 23394}
{"project": "qemu", "commit_id": "45803a039670cbee914dcb54cf3952f9b2d64d1f", "target": 0, "func": "int bdrv_set_read_only(BlockDriverState *bs, bool read_only, Error **errp)\n\n{\n\n    /* Do not set read_only if copy_on_read is enabled */\n\n    if (bs->copy_on_read && read_only) {\n\n        error_setg(errp, \"Can't set node '%s' to r/o with copy-on-read enabled\",\n\n                   bdrv_get_device_or_node_name(bs));\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* Do not clear read_only if it is prohibited */\n\n    if (!read_only && !(bs->open_flags & BDRV_O_ALLOW_RDWR)) {\n\n        error_setg(errp, \"Node '%s' is read only\",\n\n                   bdrv_get_device_or_node_name(bs));\n\n        return -EPERM;\n\n    }\n\n\n\n    bs->read_only = read_only;\n\n    return 0;\n\n}\n", "idx": 23396}
{"project": "qemu", "commit_id": "2cdfcf272d1a38e22879aecae83e95be51369b2d", "target": 0, "func": "void memory_region_init(MemoryRegion *mr,\n\n                        const char *name,\n\n                        uint64_t size)\n\n{\n\n    mr->ops = NULL;\n\n    mr->parent = NULL;\n\n    mr->size = int128_make64(size);\n\n    if (size == UINT64_MAX) {\n\n        mr->size = int128_2_64();\n\n    }\n\n    mr->addr = 0;\n\n    mr->subpage = false;\n\n    mr->enabled = true;\n\n    mr->terminates = false;\n\n    mr->ram = false;\n\n    mr->romd_mode = true;\n\n    mr->readonly = false;\n\n    mr->rom_device = false;\n\n    mr->destructor = memory_region_destructor_none;\n\n    mr->priority = 0;\n\n    mr->may_overlap = false;\n\n    mr->alias = NULL;\n\n    QTAILQ_INIT(&mr->subregions);\n\n    memset(&mr->subregions_link, 0, sizeof mr->subregions_link);\n\n    QTAILQ_INIT(&mr->coalesced);\n\n    mr->name = g_strdup(name);\n\n    mr->dirty_log_mask = 0;\n\n    mr->ioeventfd_nb = 0;\n\n    mr->ioeventfds = NULL;\n\n    mr->flush_coalesced_mmio = false;\n\n}\n", "idx": 23397}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "float64 helper_sub_cmpf64(CPUM68KState *env, float64 src0, float64 src1)\n\n{\n\n    /* ??? This may incorrectly raise exceptions.  */\n\n    /* ??? Should flush denormals to zero.  */\n\n    float64 res;\n\n    res = float64_sub(src0, src1, &env->fp_status);\n\n    if (float64_is_nan(res)) {\n\n        /* +/-inf compares equal against itself, but sub returns nan.  */\n\n        if (!float64_is_nan(src0)\n\n            && !float64_is_nan(src1)) {\n\n            res = 0;\n\n            if (float64_lt_quiet(src0, res, &env->fp_status))\n\n                res = float64_chs(res);\n\n        }\n\n    }\n\n    return res;\n\n}\n", "idx": 23398}
{"project": "qemu", "commit_id": "4b7a6bf402bd064605c287eecadc493ccf2d4897", "target": 0, "func": "bool write_list_to_kvmstate(ARMCPU *cpu)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    int i;\n\n    bool ok = true;\n\n\n\n    for (i = 0; i < cpu->cpreg_array_len; i++) {\n\n        struct kvm_one_reg r;\n\n        uint64_t regidx = cpu->cpreg_indexes[i];\n\n        uint32_t v32;\n\n        int ret;\n\n\n\n        r.id = regidx;\n\n        switch (regidx & KVM_REG_SIZE_MASK) {\n\n        case KVM_REG_SIZE_U32:\n\n            v32 = cpu->cpreg_values[i];\n\n            r.addr = (uintptr_t)&v32;\n\n            break;\n\n        case KVM_REG_SIZE_U64:\n\n            r.addr = (uintptr_t)(cpu->cpreg_values + i);\n\n            break;\n\n        default:\n\n            abort();\n\n        }\n\n        ret = kvm_vcpu_ioctl(cs, KVM_SET_ONE_REG, &r);\n\n        if (ret) {\n\n            /* We might fail for \"unknown register\" and also for\n\n             * \"you tried to set a register which is constant with\n\n             * a different value from what it actually contains\".\n\n             */\n\n            ok = false;\n\n        }\n\n    }\n\n    return ok;\n\n}\n", "idx": 23399}
{"project": "qemu", "commit_id": "b8d55db07089493da8cc264ab5991253e1102822", "target": 0, "func": "static void do_mchk_interrupt(CPUS390XState *env)\n\n{\n\n    S390CPU *cpu = s390_env_get_cpu(env);\n\n    uint64_t mask, addr;\n\n    LowCore *lowcore;\n\n    MchkQueue *q;\n\n    int i;\n\n\n\n    if (!(env->psw.mask & PSW_MASK_MCHECK)) {\n\n        cpu_abort(CPU(cpu), \"Machine check w/o mchk mask\\n\");\n\n    }\n\n\n\n    if (env->mchk_index < 0 || env->mchk_index >= MAX_MCHK_QUEUE) {\n\n        cpu_abort(CPU(cpu), \"Mchk queue overrun: %d\\n\", env->mchk_index);\n\n    }\n\n\n\n    q = &env->mchk_queue[env->mchk_index];\n\n\n\n    if (q->type != 1) {\n\n        /* Don't know how to handle this... */\n\n        cpu_abort(CPU(cpu), \"Unknown machine check type %d\\n\", q->type);\n\n    }\n\n    if (!(env->cregs[14] & (1 << 28))) {\n\n        /* CRW machine checks disabled */\n\n        return;\n\n    }\n\n\n\n    lowcore = cpu_map_lowcore(env);\n\n\n\n    for (i = 0; i < 16; i++) {\n\n        lowcore->floating_pt_save_area[i] = cpu_to_be64(get_freg(env, i)->ll);\n\n        lowcore->gpregs_save_area[i] = cpu_to_be64(env->regs[i]);\n\n        lowcore->access_regs_save_area[i] = cpu_to_be32(env->aregs[i]);\n\n        lowcore->cregs_save_area[i] = cpu_to_be64(env->cregs[i]);\n\n    }\n\n    lowcore->prefixreg_save_area = cpu_to_be32(env->psa);\n\n    lowcore->fpt_creg_save_area = cpu_to_be32(env->fpc);\n\n    lowcore->tod_progreg_save_area = cpu_to_be32(env->todpr);\n\n    lowcore->cpu_timer_save_area[0] = cpu_to_be32(env->cputm >> 32);\n\n    lowcore->cpu_timer_save_area[1] = cpu_to_be32((uint32_t)env->cputm);\n\n    lowcore->clock_comp_save_area[0] = cpu_to_be32(env->ckc >> 32);\n\n    lowcore->clock_comp_save_area[1] = cpu_to_be32((uint32_t)env->ckc);\n\n\n\n    lowcore->mcck_interruption_code[0] = cpu_to_be32(0x00400f1d);\n\n    lowcore->mcck_interruption_code[1] = cpu_to_be32(0x40330000);\n\n    lowcore->mcck_old_psw.mask = cpu_to_be64(get_psw_mask(env));\n\n    lowcore->mcck_old_psw.addr = cpu_to_be64(env->psw.addr);\n\n    mask = be64_to_cpu(lowcore->mcck_new_psw.mask);\n\n    addr = be64_to_cpu(lowcore->mcck_new_psw.addr);\n\n\n\n    cpu_unmap_lowcore(lowcore);\n\n\n\n    env->mchk_index--;\n\n    if (env->mchk_index == -1) {\n\n        env->pending_int &= ~INTERRUPT_MCHK;\n\n    }\n\n\n\n    DPRINTF(\"%s: %\" PRIx64 \" %\" PRIx64 \"\\n\", __func__,\n\n            env->psw.mask, env->psw.addr);\n\n\n\n    load_psw(env, mask, addr);\n\n}\n", "idx": 23400}
{"project": "qemu", "commit_id": "bf483392e6806225a7a7e03c57bad35530522cb9", "target": 0, "func": "static void bochs_bios_init(void)\n\n{\n\n    void *fw_cfg;\n\n    uint8_t *smbios_table;\n\n    size_t smbios_len;\n\n    uint64_t *numa_fw_cfg;\n\n    int i, j;\n\n\n\n    register_ioport_write(0x400, 1, 2, bochs_bios_write, NULL);\n\n    register_ioport_write(0x401, 1, 2, bochs_bios_write, NULL);\n\n    register_ioport_write(0x402, 1, 1, bochs_bios_write, NULL);\n\n    register_ioport_write(0x403, 1, 1, bochs_bios_write, NULL);\n\n    register_ioport_write(0x8900, 1, 1, bochs_bios_write, NULL);\n\n\n\n    register_ioport_write(0x501, 1, 2, bochs_bios_write, NULL);\n\n    register_ioport_write(0x502, 1, 2, bochs_bios_write, NULL);\n\n    register_ioport_write(0x500, 1, 1, bochs_bios_write, NULL);\n\n    register_ioport_write(0x503, 1, 1, bochs_bios_write, NULL);\n\n\n\n    fw_cfg = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_ACPI_TABLES, (uint8_t *)acpi_tables,\n\n                     acpi_tables_len);\n\n\n\n    smbios_table = smbios_get_table(&smbios_len);\n\n    if (smbios_table)\n\n        fw_cfg_add_bytes(fw_cfg, FW_CFG_SMBIOS_ENTRIES,\n\n                         smbios_table, smbios_len);\n\n\n\n    /* allocate memory for the NUMA channel: one (64bit) word for the number\n\n     * of nodes, one word for each VCPU->node and one word for each node to\n\n     * hold the amount of memory.\n\n     */\n\n    numa_fw_cfg = qemu_mallocz((1 + smp_cpus + nb_numa_nodes) * 8);\n\n    numa_fw_cfg[0] = cpu_to_le64(nb_numa_nodes);\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        for (j = 0; j < nb_numa_nodes; j++) {\n\n            if (node_cpumask[j] & (1 << i)) {\n\n                numa_fw_cfg[i + 1] = cpu_to_le64(j);\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    for (i = 0; i < nb_numa_nodes; i++) {\n\n        numa_fw_cfg[smp_cpus + 1 + i] = cpu_to_le64(node_mem[i]);\n\n    }\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_NUMA, (uint8_t *)numa_fw_cfg,\n\n                     (1 + smp_cpus + nb_numa_nodes) * 8);\n\n}\n", "idx": 23401}
{"project": "qemu", "commit_id": "01c2b265fce921d6460e06f5af4dfb405119cbab", "target": 0, "func": "check_host_key_hash(BDRVSSHState *s, const char *hash,\n\n                    int hash_type, size_t fingerprint_len)\n\n{\n\n    const char *fingerprint;\n\n\n\n    fingerprint = libssh2_hostkey_hash(s->session, hash_type);\n\n    if (!fingerprint) {\n\n        session_error_report(s, \"failed to read remote host key\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    if(compare_fingerprint((unsigned char *) fingerprint, fingerprint_len,\n\n                           hash) != 0) {\n\n        error_report(\"remote host key does not match host_key_check '%s'\",\n\n                     hash);\n\n        return -EPERM;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23402}
{"project": "qemu", "commit_id": "d85f4222b4681da7ebf8a90b26e085a68fa2c55a", "target": 0, "func": "static uint64_t get_cluster_offset(BlockDriverState *bs,\n\n                                   uint64_t offset, int allocate,\n\n                                   int compressed_size,\n\n                                   int n_start, int n_end)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int min_index, i, j, l1_index, l2_index;\n\n    uint64_t l2_offset, *l2_table, cluster_offset, tmp;\n\n    uint32_t min_count;\n\n    int new_l2_table;\n\n\n\n    l1_index = offset >> (s->l2_bits + s->cluster_bits);\n\n    l2_offset = s->l1_table[l1_index];\n\n    new_l2_table = 0;\n\n    if (!l2_offset) {\n\n        if (!allocate)\n\n            return 0;\n\n        /* allocate a new l2 entry */\n\n        l2_offset = bdrv_getlength(bs->file->bs);\n\n        /* round to cluster size */\n\n        l2_offset = (l2_offset + s->cluster_size - 1) & ~(s->cluster_size - 1);\n\n        /* update the L1 entry */\n\n        s->l1_table[l1_index] = l2_offset;\n\n        tmp = cpu_to_be64(l2_offset);\n\n        if (bdrv_pwrite_sync(bs->file,\n\n                s->l1_table_offset + l1_index * sizeof(tmp),\n\n                &tmp, sizeof(tmp)) < 0)\n\n            return 0;\n\n        new_l2_table = 1;\n\n    }\n\n    for(i = 0; i < L2_CACHE_SIZE; i++) {\n\n        if (l2_offset == s->l2_cache_offsets[i]) {\n\n            /* increment the hit count */\n\n            if (++s->l2_cache_counts[i] == 0xffffffff) {\n\n                for(j = 0; j < L2_CACHE_SIZE; j++) {\n\n                    s->l2_cache_counts[j] >>= 1;\n\n                }\n\n            }\n\n            l2_table = s->l2_cache + (i << s->l2_bits);\n\n            goto found;\n\n        }\n\n    }\n\n    /* not found: load a new entry in the least used one */\n\n    min_index = 0;\n\n    min_count = 0xffffffff;\n\n    for(i = 0; i < L2_CACHE_SIZE; i++) {\n\n        if (s->l2_cache_counts[i] < min_count) {\n\n            min_count = s->l2_cache_counts[i];\n\n            min_index = i;\n\n        }\n\n    }\n\n    l2_table = s->l2_cache + (min_index << s->l2_bits);\n\n    if (new_l2_table) {\n\n        memset(l2_table, 0, s->l2_size * sizeof(uint64_t));\n\n        if (bdrv_pwrite_sync(bs->file, l2_offset, l2_table,\n\n                s->l2_size * sizeof(uint64_t)) < 0)\n\n            return 0;\n\n    } else {\n\n        if (bdrv_pread(bs->file, l2_offset, l2_table,\n\n                       s->l2_size * sizeof(uint64_t)) !=\n\n            s->l2_size * sizeof(uint64_t))\n\n            return 0;\n\n    }\n\n    s->l2_cache_offsets[min_index] = l2_offset;\n\n    s->l2_cache_counts[min_index] = 1;\n\n found:\n\n    l2_index = (offset >> s->cluster_bits) & (s->l2_size - 1);\n\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n    if (!cluster_offset ||\n\n        ((cluster_offset & QCOW_OFLAG_COMPRESSED) && allocate == 1)) {\n\n        if (!allocate)\n\n            return 0;\n\n        /* allocate a new cluster */\n\n        if ((cluster_offset & QCOW_OFLAG_COMPRESSED) &&\n\n            (n_end - n_start) < s->cluster_sectors) {\n\n            /* if the cluster is already compressed, we must\n\n               decompress it in the case it is not completely\n\n               overwritten */\n\n            if (decompress_cluster(bs, cluster_offset) < 0)\n\n                return 0;\n\n            cluster_offset = bdrv_getlength(bs->file->bs);\n\n            cluster_offset = (cluster_offset + s->cluster_size - 1) &\n\n                ~(s->cluster_size - 1);\n\n            /* write the cluster content */\n\n            if (bdrv_pwrite(bs->file, cluster_offset, s->cluster_cache,\n\n                            s->cluster_size) !=\n\n                s->cluster_size)\n\n                return -1;\n\n        } else {\n\n            cluster_offset = bdrv_getlength(bs->file->bs);\n\n            if (allocate == 1) {\n\n                /* round to cluster size */\n\n                cluster_offset = (cluster_offset + s->cluster_size - 1) &\n\n                    ~(s->cluster_size - 1);\n\n                bdrv_truncate(bs->file, cluster_offset + s->cluster_size, NULL);\n\n                /* if encrypted, we must initialize the cluster\n\n                   content which won't be written */\n\n                if (bs->encrypted &&\n\n                    (n_end - n_start) < s->cluster_sectors) {\n\n                    uint64_t start_sect;\n\n                    assert(s->cipher);\n\n                    start_sect = (offset & ~(s->cluster_size - 1)) >> 9;\n\n                    for(i = 0; i < s->cluster_sectors; i++) {\n\n                        if (i < n_start || i >= n_end) {\n\n                            Error *err = NULL;\n\n                            memset(s->cluster_data, 0x00, 512);\n\n                            if (encrypt_sectors(s, start_sect + i,\n\n                                                s->cluster_data, 1,\n\n                                                true, &err) < 0) {\n\n                                error_free(err);\n\n                                errno = EIO;\n\n                                return -1;\n\n                            }\n\n                            if (bdrv_pwrite(bs->file,\n\n                                            cluster_offset + i * 512,\n\n                                            s->cluster_data, 512) != 512)\n\n                                return -1;\n\n                        }\n\n                    }\n\n                }\n\n            } else if (allocate == 2) {\n\n                cluster_offset |= QCOW_OFLAG_COMPRESSED |\n\n                    (uint64_t)compressed_size << (63 - s->cluster_bits);\n\n            }\n\n        }\n\n        /* update L2 table */\n\n        tmp = cpu_to_be64(cluster_offset);\n\n        l2_table[l2_index] = tmp;\n\n        if (bdrv_pwrite_sync(bs->file, l2_offset + l2_index * sizeof(tmp),\n\n                &tmp, sizeof(tmp)) < 0)\n\n            return 0;\n\n    }\n\n    return cluster_offset;\n\n}\n", "idx": 23403}
{"project": "qemu", "commit_id": "539de1246d355d3b8aa33fb7cde732352d8827c7", "target": 0, "func": "int qemu_savevm_state_begin(Monitor *mon, QEMUFile *f, int blk_enable,\n\n                            int shared)\n\n{\n\n    SaveStateEntry *se;\n\n    int ret;\n\n\n\n    QTAILQ_FOREACH(se, &savevm_handlers, entry) {\n\n        if(se->set_params == NULL) {\n\n            continue;\n\n\t}\n\n\tse->set_params(blk_enable, shared, se->opaque);\n\n    }\n\n    \n\n    qemu_put_be32(f, QEMU_VM_FILE_MAGIC);\n\n    qemu_put_be32(f, QEMU_VM_FILE_VERSION);\n\n\n\n    QTAILQ_FOREACH(se, &savevm_handlers, entry) {\n\n        int len;\n\n\n\n        if (se->save_live_state == NULL)\n\n            continue;\n\n\n\n        /* Section type */\n\n        qemu_put_byte(f, QEMU_VM_SECTION_START);\n\n        qemu_put_be32(f, se->section_id);\n\n\n\n        /* ID string */\n\n        len = strlen(se->idstr);\n\n        qemu_put_byte(f, len);\n\n        qemu_put_buffer(f, (uint8_t *)se->idstr, len);\n\n\n\n        qemu_put_be32(f, se->instance_id);\n\n        qemu_put_be32(f, se->version_id);\n\n\n\n        ret = se->save_live_state(mon, f, QEMU_VM_SECTION_START, se->opaque);\n\n        if (ret < 0) {\n\n            qemu_savevm_state_cancel(mon, f);\n\n            return ret;\n\n        }\n\n    }\n\n    ret = qemu_file_get_error(f);\n\n    if (ret != 0) {\n\n        qemu_savevm_state_cancel(mon, f);\n\n    }\n\n\n\n    return ret;\n\n\n\n}\n", "idx": 23404}
{"project": "qemu", "commit_id": "a03ef88f77af045a2eb9629b5ce774a3fb973c5e", "target": 0, "func": "static int coroutine_fn bdrv_co_do_readv(BdrvChild *child,\n\n    int64_t sector_num, int nb_sectors, QEMUIOVector *qiov,\n\n    BdrvRequestFlags flags)\n\n{\n\n    if (nb_sectors < 0 || nb_sectors > BDRV_REQUEST_MAX_SECTORS) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    return bdrv_co_preadv(child->bs, sector_num << BDRV_SECTOR_BITS,\n\n                          nb_sectors << BDRV_SECTOR_BITS, qiov, flags);\n\n}\n", "idx": 23405}
{"project": "qemu", "commit_id": "d20423788e3a3d5f6a2aad8315779bf3f952ca36", "target": 0, "func": "static int handle_utimensat(FsContext *ctx, V9fsPath *fs_path,\n\n                            const struct timespec *buf)\n\n{\n\n    int fd, ret;\n\n    struct handle_data *data = (struct handle_data *)ctx->private;\n\n\n\n    fd = open_by_handle(data->mountfd, fs_path->data, O_NONBLOCK);\n\n    if (fd < 0) {\n\n        return fd;\n\n    }\n\n    ret = futimens(fd, buf);\n\n    close(fd);\n\n    return ret;\n\n}\n", "idx": 23407}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "int kqemu_cpu_exec(CPUState *env)\n\n{\n\n    struct kqemu_cpu_state kcpu_state, *kenv = &kcpu_state;\n\n    int ret, cpl, i;\n\n#ifdef CONFIG_PROFILER\n\n    int64_t ti;\n\n#endif\n\n#ifdef _WIN32\n\n    DWORD temp;\n\n#endif\n\n\n\n#ifdef CONFIG_PROFILER\n\n    ti = profile_getclock();\n\n#endif\n\n    LOG_INT(\"kqemu: cpu_exec: enter\\n\");\n\n    LOG_INT_STATE(env);\n\n    for(i = 0; i < CPU_NB_REGS; i++)\n\n        kenv->regs[i] = env->regs[i];\n\n    kenv->eip = env->eip;\n\n    kenv->eflags = env->eflags;\n\n    for(i = 0; i < 6; i++)\n\n        kqemu_load_seg(&kenv->segs[i], &env->segs[i]);\n\n    kqemu_load_seg(&kenv->ldt, &env->ldt);\n\n    kqemu_load_seg(&kenv->tr, &env->tr);\n\n    kqemu_load_seg(&kenv->gdt, &env->gdt);\n\n    kqemu_load_seg(&kenv->idt, &env->idt);\n\n    kenv->cr0 = env->cr[0];\n\n    kenv->cr2 = env->cr[2];\n\n    kenv->cr3 = env->cr[3];\n\n    kenv->cr4 = env->cr[4];\n\n    kenv->a20_mask = env->a20_mask;\n\n    kenv->efer = env->efer;\n\n    kenv->tsc_offset = 0;\n\n    kenv->star = env->star;\n\n    kenv->sysenter_cs = env->sysenter_cs;\n\n    kenv->sysenter_esp = env->sysenter_esp;\n\n    kenv->sysenter_eip = env->sysenter_eip;\n\n#ifdef TARGET_X86_64\n\n    kenv->lstar = env->lstar;\n\n    kenv->cstar = env->cstar;\n\n    kenv->fmask = env->fmask;\n\n    kenv->kernelgsbase = env->kernelgsbase;\n\n#endif\n\n    if (env->dr[7] & 0xff) {\n\n        kenv->dr7 = env->dr[7];\n\n        kenv->dr0 = env->dr[0];\n\n        kenv->dr1 = env->dr[1];\n\n        kenv->dr2 = env->dr[2];\n\n        kenv->dr3 = env->dr[3];\n\n    } else {\n\n        kenv->dr7 = 0;\n\n    }\n\n    kenv->dr6 = env->dr[6];\n\n    cpl = (env->hflags & HF_CPL_MASK);\n\n    kenv->cpl = cpl;\n\n    kenv->nb_pages_to_flush = nb_pages_to_flush;\n\n    kenv->user_only = (env->kqemu_enabled == 1);\n\n    kenv->nb_ram_pages_to_update = nb_ram_pages_to_update;\n\n    nb_ram_pages_to_update = 0;\n\n    kenv->nb_modified_ram_pages = nb_modified_ram_pages;\n\n\n\n    kqemu_reset_modified_ram_pages();\n\n\n\n    if (env->cpuid_features & CPUID_FXSR)\n\n        restore_native_fp_fxrstor(env);\n\n    else\n\n        restore_native_fp_frstor(env);\n\n\n\n#ifdef _WIN32\n\n    if (DeviceIoControl(kqemu_fd, KQEMU_EXEC,\n\n                        kenv, sizeof(struct kqemu_cpu_state),\n\n                        kenv, sizeof(struct kqemu_cpu_state),\n\n                        &temp, NULL)) {\n\n        ret = kenv->retval;\n\n    } else {\n\n        ret = -1;\n\n    }\n\n#else\n\n    ioctl(kqemu_fd, KQEMU_EXEC, kenv);\n\n    ret = kenv->retval;\n\n#endif\n\n    if (env->cpuid_features & CPUID_FXSR)\n\n        save_native_fp_fxsave(env);\n\n    else\n\n        save_native_fp_fsave(env);\n\n\n\n    for(i = 0; i < CPU_NB_REGS; i++)\n\n        env->regs[i] = kenv->regs[i];\n\n    env->eip = kenv->eip;\n\n    env->eflags = kenv->eflags;\n\n    for(i = 0; i < 6; i++)\n\n        kqemu_save_seg(&env->segs[i], &kenv->segs[i]);\n\n    cpu_x86_set_cpl(env, kenv->cpl);\n\n    kqemu_save_seg(&env->ldt, &kenv->ldt);\n\n    env->cr[0] = kenv->cr0;\n\n    env->cr[4] = kenv->cr4;\n\n    env->cr[3] = kenv->cr3;\n\n    env->cr[2] = kenv->cr2;\n\n    env->dr[6] = kenv->dr6;\n\n#ifdef TARGET_X86_64\n\n    env->kernelgsbase = kenv->kernelgsbase;\n\n#endif\n\n\n\n    /* flush pages as indicated by kqemu */\n\n    if (kenv->nb_pages_to_flush >= KQEMU_FLUSH_ALL) {\n\n        tlb_flush(env, 1);\n\n    } else {\n\n        for(i = 0; i < kenv->nb_pages_to_flush; i++) {\n\n            tlb_flush_page(env, pages_to_flush[i]);\n\n        }\n\n    }\n\n    nb_pages_to_flush = 0;\n\n\n\n#ifdef CONFIG_PROFILER\n\n    kqemu_time += profile_getclock() - ti;\n\n    kqemu_exec_count++;\n\n#endif\n\n\n\n    if (kenv->nb_ram_pages_to_update > 0) {\n\n        cpu_tlb_update_dirty(env);\n\n    }\n\n\n\n    if (kenv->nb_modified_ram_pages > 0) {\n\n        for(i = 0; i < kenv->nb_modified_ram_pages; i++) {\n\n            unsigned long addr;\n\n            addr = modified_ram_pages[i];\n\n            tb_invalidate_phys_page_range(addr, addr + TARGET_PAGE_SIZE, 0);\n\n        }\n\n    }\n\n\n\n    /* restore the hidden flags */\n\n    {\n\n        unsigned int new_hflags;\n\n#ifdef TARGET_X86_64\n\n        if ((env->hflags & HF_LMA_MASK) &&\n\n            (env->segs[R_CS].flags & DESC_L_MASK)) {\n\n            /* long mode */\n\n            new_hflags = HF_CS32_MASK | HF_SS32_MASK | HF_CS64_MASK;\n\n        } else\n\n#endif\n\n        {\n\n            /* legacy / compatibility case */\n\n            new_hflags = (env->segs[R_CS].flags & DESC_B_MASK)\n\n                >> (DESC_B_SHIFT - HF_CS32_SHIFT);\n\n            new_hflags |= (env->segs[R_SS].flags & DESC_B_MASK)\n\n                >> (DESC_B_SHIFT - HF_SS32_SHIFT);\n\n            if (!(env->cr[0] & CR0_PE_MASK) ||\n\n                   (env->eflags & VM_MASK) ||\n\n                   !(env->hflags & HF_CS32_MASK)) {\n\n                /* XXX: try to avoid this test. The problem comes from the\n\n                   fact that is real mode or vm86 mode we only modify the\n\n                   'base' and 'selector' fields of the segment cache to go\n\n                   faster. A solution may be to force addseg to one in\n\n                   translate-i386.c. */\n\n                new_hflags |= HF_ADDSEG_MASK;\n\n            } else {\n\n                new_hflags |= ((env->segs[R_DS].base |\n\n                                env->segs[R_ES].base |\n\n                                env->segs[R_SS].base) != 0) <<\n\n                    HF_ADDSEG_SHIFT;\n\n            }\n\n        }\n\n        env->hflags = (env->hflags &\n\n           ~(HF_CS32_MASK | HF_SS32_MASK | HF_CS64_MASK | HF_ADDSEG_MASK)) |\n\n            new_hflags;\n\n    }\n\n    /* update FPU flags */\n\n    env->hflags = (env->hflags & ~(HF_MP_MASK | HF_EM_MASK | HF_TS_MASK)) |\n\n        ((env->cr[0] << (HF_MP_SHIFT - 1)) & (HF_MP_MASK | HF_EM_MASK | HF_TS_MASK));\n\n    if (env->cr[4] & CR4_OSFXSR_MASK)\n\n        env->hflags |= HF_OSFXSR_MASK;\n\n    else\n\n        env->hflags &= ~HF_OSFXSR_MASK;\n\n\n\n    LOG_INT(\"kqemu: kqemu_cpu_exec: ret=0x%x\\n\", ret);\n\n    if (ret == KQEMU_RET_SYSCALL) {\n\n        /* syscall instruction */\n\n        return do_syscall(env, kenv);\n\n    } else\n\n    if ((ret & 0xff00) == KQEMU_RET_INT) {\n\n        env->exception_index = ret & 0xff;\n\n        env->error_code = 0;\n\n        env->exception_is_int = 1;\n\n        env->exception_next_eip = kenv->next_eip;\n\n#ifdef CONFIG_PROFILER\n\n        kqemu_ret_int_count++;\n\n#endif\n\n        LOG_INT(\"kqemu: interrupt v=%02x:\\n\", env->exception_index);\n\n        LOG_INT_STATE(env);\n\n        return 1;\n\n    } else if ((ret & 0xff00) == KQEMU_RET_EXCEPTION) {\n\n        env->exception_index = ret & 0xff;\n\n        env->error_code = kenv->error_code;\n\n        env->exception_is_int = 0;\n\n        env->exception_next_eip = 0;\n\n#ifdef CONFIG_PROFILER\n\n        kqemu_ret_excp_count++;\n\n#endif\n\n        LOG_INT(\"kqemu: exception v=%02x e=%04x:\\n\",\n\n                    env->exception_index, env->error_code);\n\n        LOG_INT_STATE(env);\n\n        return 1;\n\n    } else if (ret == KQEMU_RET_INTR) {\n\n#ifdef CONFIG_PROFILER\n\n        kqemu_ret_intr_count++;\n\n#endif\n\n        LOG_INT_STATE(env);\n\n        return 0;\n\n    } else if (ret == KQEMU_RET_SOFTMMU) {\n\n#ifdef CONFIG_PROFILER\n\n        {\n\n            unsigned long pc = env->eip + env->segs[R_CS].base;\n\n            kqemu_record_pc(pc);\n\n        }\n\n#endif\n\n        LOG_INT_STATE(env);\n\n        return 2;\n\n    } else {\n\n        cpu_dump_state(env, stderr, fprintf, 0);\n\n        fprintf(stderr, \"Unsupported return value: 0x%x\\n\", ret);\n\n        exit(1);\n\n    }\n\n    return 0;\n\n}\n", "idx": 23408}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_conditional_jump(DisasContext * ctx,\n\n\t\t\t\t target_ulong ift, target_ulong ifnott)\n\n{\n\n    int l1;\n\n    TCGv sr;\n\n\n\n    l1 = gen_new_label();\n\n    sr = tcg_temp_new();\n\n    tcg_gen_andi_i32(sr, cpu_sr, SR_T);\n\n    tcg_gen_brcondi_i32(TCG_COND_NE, sr, 0, l1);\n\n    gen_goto_tb(ctx, 0, ifnott);\n\n    gen_set_label(l1);\n\n    gen_goto_tb(ctx, 1, ift);\n\n}\n", "idx": 23409}
{"project": "qemu", "commit_id": "a2db2a1edd06a50b8a862c654cf993368cf9f1d9", "target": 0, "func": "static void cpu_handle_ioreq(void *opaque)\n\n{\n\n    XenIOState *state = opaque;\n\n    ioreq_t *req = cpu_get_ioreq(state);\n\n\n\n    handle_buffered_iopage(state);\n\n    if (req) {\n\n        handle_ioreq(state, req);\n\n\n\n        if (req->state != STATE_IOREQ_INPROCESS) {\n\n            fprintf(stderr, \"Badness in I/O request ... not in service?!: \"\n\n                    \"%x, ptr: %x, port: %\"PRIx64\", \"\n\n                    \"data: %\"PRIx64\", count: %\" FMT_ioreq_size\n\n                    \", size: %\" FMT_ioreq_size\n\n                    \", type: %\"FMT_ioreq_size\"\\n\",\n\n                    req->state, req->data_is_ptr, req->addr,\n\n                    req->data, req->count, req->size, req->type);\n\n            destroy_hvm_domain(false);\n\n            return;\n\n        }\n\n\n\n        xen_wmb(); /* Update ioreq contents /then/ update state. */\n\n\n\n        /*\n\n         * We do this before we send the response so that the tools\n\n         * have the opportunity to pick up on the reset before the\n\n         * guest resumes and does a hlt with interrupts disabled which\n\n         * causes Xen to powerdown the domain.\n\n         */\n\n        if (runstate_is_running()) {\n\n            if (qemu_shutdown_requested_get()) {\n\n                destroy_hvm_domain(false);\n\n            }\n\n            if (qemu_reset_requested_get()) {\n\n                qemu_system_reset(VMRESET_REPORT);\n\n                destroy_hvm_domain(true);\n\n            }\n\n        }\n\n\n\n        req->state = STATE_IORESP_READY;\n\n        xc_evtchn_notify(state->xce_handle, state->ioreq_local_port[state->send_vcpu]);\n\n    }\n\n}\n", "idx": 23410}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void sigchld_handler(int signal)\n\n{\n\n    qemu_bh_schedule(sigchld_bh);\n\n}\n", "idx": 23411}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "int float64_is_nan( float64 a1 )\n\n{\n\n    float64u u;\n\n    uint64_t a;\n\n    u.f = a1;\n\n    a = u.i;\n\n\n\n    return ( LIT64( 0xFFF0000000000000 ) < (bits64) ( a<<1 ) );\n\n\n\n}\n", "idx": 23412}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint32_t helper_efdctsf (uint64_t val)\n\n{\n\n    CPU_DoubleU u;\n\n    float64 tmp;\n\n\n\n    u.ll = val;\n\n    /* NaN are not treated the same way IEEE 754 does */\n\n    if (unlikely(float64_is_nan(u.d)))\n\n        return 0;\n\n    tmp = uint64_to_float64(1ULL << 32, &env->vec_status);\n\n    u.d = float64_mul(u.d, tmp, &env->vec_status);\n\n\n\n    return float64_to_int32(u.d, &env->vec_status);\n\n}\n", "idx": 23413}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static void char_socket_class_init(ObjectClass *oc, void *data)\n\n{\n\n    ChardevClass *cc = CHARDEV_CLASS(oc);\n\n\n\n    cc->parse = qemu_chr_parse_socket;\n\n    cc->open = qmp_chardev_open_socket;\n\n    cc->chr_wait_connected = tcp_chr_wait_connected;\n\n    cc->chr_write = tcp_chr_write;\n\n    cc->chr_sync_read = tcp_chr_sync_read;\n\n    cc->chr_disconnect = tcp_chr_disconnect;\n\n    cc->get_msgfds = tcp_get_msgfds;\n\n    cc->set_msgfds = tcp_set_msgfds;\n\n    cc->chr_add_client = tcp_chr_add_client;\n\n    cc->chr_add_watch = tcp_chr_add_watch;\n\n    cc->chr_update_read_handler = tcp_chr_update_read_handler;\n\n\n\n    object_class_property_add(oc, \"addr\", \"SocketAddressLegacy\",\n\n                              char_socket_get_addr, NULL,\n\n                              NULL, NULL, &error_abort);\n\n\n\n    object_class_property_add_bool(oc, \"connected\", char_socket_get_connected,\n\n                                   NULL, &error_abort);\n\n}\n", "idx": 23414}
{"project": "qemu", "commit_id": "c5c752af8cddad3e4e51acef40a46db998638144", "target": 0, "func": "static void hb_regs_write(void *opaque, hwaddr offset,\n\n                          uint64_t value, unsigned size)\n\n{\n\n    uint32_t *regs = opaque;\n\n\n\n    if (offset == 0xf00) {\n\n        if (value == 1 || value == 2) {\n\n            qemu_system_reset_request(SHUTDOWN_CAUSE_GUEST_RESET);\n\n        } else if (value == 3) {\n\n            qemu_system_shutdown_request(SHUTDOWN_CAUSE_GUEST_SHUTDOWN);\n\n        }\n\n    }\n\n\n\n    regs[offset/4] = value;\n\n}\n", "idx": 23415}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static bool fw_cfg_ctl_mem_valid(void *opaque, target_phys_addr_t addr,\n\n                                 unsigned size, bool is_write)\n\n{\n\n    return is_write && size == 2;\n\n}\n", "idx": 23416}
{"project": "qemu", "commit_id": "45a7f54a8bb3928ffa58d522e0d61acaee8277bb", "target": 0, "func": "static ssize_t net_socket_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n\n{\n\n    NetSocketState *s = DO_UPCAST(NetSocketState, nc, nc);\n\n    uint32_t len;\n\n    len = htonl(size);\n\n\n\n    send_all(s->fd, (const uint8_t *)&len, sizeof(len));\n\n    return send_all(s->fd, buf, size);\n\n}\n", "idx": 23418}
{"project": "qemu", "commit_id": "9445673ea67c272616b9f718396e267caa6446b7", "target": 0, "func": "static SocketAddress *nbd_config(BDRVNBDState *s, QDict *options, Error **errp)\n\n{\n\n    SocketAddress *saddr = NULL;\n\n    QDict *addr = NULL;\n\n    QObject *crumpled_addr = NULL;\n\n    Visitor *iv = NULL;\n\n    Error *local_err = NULL;\n\n\n\n    qdict_extract_subqdict(options, &addr, \"server.\");\n\n    if (!qdict_size(addr)) {\n\n        error_setg(errp, \"NBD server address missing\");\n\n        goto done;\n\n    }\n\n\n\n    crumpled_addr = qdict_crumple(addr, errp);\n\n    if (!crumpled_addr) {\n\n        goto done;\n\n    }\n\n\n\n    /*\n\n     * FIXME .numeric, .to, .ipv4 or .ipv6 don't work with -drive\n\n     * server.type=inet.  .to doesn't matter, it's ignored anyway.\n\n     * That's because when @options come from -blockdev or\n\n     * blockdev_add, members are typed according to the QAPI schema,\n\n     * but when they come from -drive, they're all QString.  The\n\n     * visitor expects the former.\n\n     */\n\n    iv = qobject_input_visitor_new(crumpled_addr);\n\n    visit_type_SocketAddress(iv, NULL, &saddr, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto done;\n\n    }\n\n\n\ndone:\n\n    QDECREF(addr);\n\n    qobject_decref(crumpled_addr);\n\n    visit_free(iv);\n\n    return saddr;\n\n}\n", "idx": 23419}
{"project": "qemu", "commit_id": "00ec5c37601accb2b85b089d72fc7ddff2f4222e", "target": 0, "func": "static int local_mkdir(FsContext *ctx, const char *path, mode_t mode)\n\n{\n\n    return mkdir(rpath(ctx, path), mode);\n\n}\n", "idx": 23420}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static int vnc_client_io_error(VncState *vs, int ret, int last_errno)\n\n{\n\n    if (ret == 0 || ret == -1) {\n\n        if (ret == -1) {\n\n            switch (last_errno) {\n\n                case EINTR:\n\n                case EAGAIN:\n\n#ifdef _WIN32\n\n                case WSAEWOULDBLOCK:\n\n#endif\n\n                    return 0;\n\n                default:\n\n                    break;\n\n            }\n\n        }\n\n\n\n\tVNC_DEBUG(\"Closing down client sock %d %d\\n\", ret, ret < 0 ? last_errno : 0);\n\n\tqemu_set_fd_handler2(vs->csock, NULL, NULL, NULL, NULL);\n\n\tclosesocket(vs->csock);\n\n        qemu_del_timer(vs->timer);\n\n        qemu_free_timer(vs->timer);\n\n        if (vs->input.buffer) qemu_free(vs->input.buffer);\n\n        if (vs->output.buffer) qemu_free(vs->output.buffer);\n\n#ifdef CONFIG_VNC_TLS\n\n\tif (vs->tls_session) {\n\n\t    gnutls_deinit(vs->tls_session);\n\n\t    vs->tls_session = NULL;\n\n\t}\n\n#endif /* CONFIG_VNC_TLS */\n\n        audio_del(vs);\n\n\n\n        VncState *p, *parent = NULL;\n\n        for (p = vs->vd->clients; p != NULL; p = p->next) {\n\n            if (p == vs) {\n\n                if (parent)\n\n                    parent->next = p->next;\n\n                else\n\n                    vs->vd->clients = p->next;\n\n                break;\n\n            }\n\n            parent = p;\n\n        }\n\n        if (!vs->vd->clients)\n\n            dcl->idle = 1;\n\n\n\n        qemu_free(vs->old_data);\n\n        qemu_free(vs);\n\n  \n\n\treturn 0;\n\n    }\n\n    return ret;\n\n}\n", "idx": 23421}
{"project": "qemu", "commit_id": "0ab07c623c629acfbc792e5a174129c19faefbb7", "target": 0, "func": "static void qemu_event_increment(void)\n\n{\n\n    /* Write 8 bytes to be compatible with eventfd.  */\n\n    static const uint64_t val = 1;\n\n    ssize_t ret;\n\n\n\n    if (io_thread_fd == -1)\n\n        return;\n\n\n\n    do {\n\n        ret = write(io_thread_fd, &val, sizeof(val));\n\n    } while (ret < 0 && errno == EINTR);\n\n\n\n    /* EAGAIN is fine, a read must be pending.  */\n\n    if (ret < 0 && errno != EAGAIN) {\n\n        fprintf(stderr, \"qemu_event_increment: write() filed: %s\\n\",\n\n                strerror(errno));\n\n        exit (1);\n\n    }\n\n}\n", "idx": 23422}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t mv88w8618_wlan_read(void *opaque, target_phys_addr_t offset,\n\n                                    unsigned size)\n\n{\n\n    switch (offset) {\n\n    /* Workaround to allow loading the binary-only wlandrv.ko crap\n\n     * from the original Freecom firmware. */\n\n    case MP_WLAN_MAGIC1:\n\n        return ~3;\n\n    case MP_WLAN_MAGIC2:\n\n        return -1;\n\n\n\n    default:\n\n        return 0;\n\n    }\n\n}\n", "idx": 23423}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_icread(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    /* interpreted as no-op */\n\n#endif\n\n}\n", "idx": 23428}
{"project": "qemu", "commit_id": "57d84cf35302fe51789c18354bf09a521bb603df", "target": 1, "func": "static void remove_port(VirtIOSerial *vser, uint32_t port_id)\n\n{\n\n    VirtIOSerialPort *port;\n\n    unsigned int i;\n\n\n\n    i = port_id / 32;\n\n    vser->ports_map[i] &= ~(1U << (port_id % 32));\n\n\n\n    port = find_port_by_id(vser, port_id);\n\n    /*\n\n     * This function is only called from qdev's unplug callback; if we\n\n     * get a NULL port here, we're in trouble.\n\n     */\n\n    assert(port);\n\n\n\n    /* Flush out any unconsumed buffers first */\n\n    discard_vq_data(port->ovq, VIRTIO_DEVICE(port->vser));\n\n\n\n    send_control_event(vser, port->id, VIRTIO_CONSOLE_PORT_REMOVE, 1);\n\n}\n", "idx": 23430}
{"project": "qemu", "commit_id": "5e2fb7c598c6ae2481ca65d3a730b7fc29fdefbb", "target": 1, "func": "static void imx6_defer_clear_reset_bit(int cpuid,\n\n                                       IMX6SRCState *s,\n\n                                       unsigned long reset_shift)\n\n{\n\n    struct SRCSCRResetInfo *ri;\n\n\n\n    ri = g_malloc(sizeof(struct SRCSCRResetInfo));\n\n    ri->s = s;\n\n    ri->reset_bit = reset_shift;\n\n\n\n    async_run_on_cpu(arm_get_cpu_by_id(cpuid), imx6_clear_reset_bit,\n\n                     RUN_ON_CPU_HOST_PTR(ri));\n\n}\n", "idx": 23436}
{"project": "qemu", "commit_id": "eda40cc1686162dcd92a97debcbb0df74269651f", "target": 1, "func": "static void fsl_imx6_realize(DeviceState *dev, Error **errp)\n\n{\n\n    FslIMX6State *s = FSL_IMX6(dev);\n\n    uint16_t i;\n\n    Error *err = NULL;\n\n\n\n    for (i = 0; i < smp_cpus; i++) {\n\n\n\n        /* On uniprocessor, the CBAR is set to 0 */\n\n        if (smp_cpus > 1) {\n\n            object_property_set_int(OBJECT(&s->cpu[i]), FSL_IMX6_A9MPCORE_ADDR,\n\n                                    \"reset-cbar\", &error_abort);\n\n        }\n\n\n\n        /* All CPU but CPU 0 start in power off mode */\n\n        if (i) {\n\n            object_property_set_bool(OBJECT(&s->cpu[i]), true,\n\n                                     \"start-powered-off\", &error_abort);\n\n        }\n\n\n\n        object_property_set_bool(OBJECT(&s->cpu[i]), true, \"realized\", &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return;\n\n        }\n\n    }\n\n\n\n    object_property_set_int(OBJECT(&s->a9mpcore), smp_cpus, \"num-cpu\",\n\n                            &error_abort);\n\n\n\n    object_property_set_int(OBJECT(&s->a9mpcore),\n\n                            FSL_IMX6_MAX_IRQ + GIC_INTERNAL, \"num-irq\",\n\n                            &error_abort);\n\n\n\n    object_property_set_bool(OBJECT(&s->a9mpcore), true, \"realized\", &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(&s->a9mpcore), 0, FSL_IMX6_A9MPCORE_ADDR);\n\n\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(&s->a9mpcore), i,\n\n                           qdev_get_gpio_in(DEVICE(&s->cpu[i]), ARM_CPU_IRQ));\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(&s->a9mpcore), i + smp_cpus,\n\n                           qdev_get_gpio_in(DEVICE(&s->cpu[i]), ARM_CPU_FIQ));\n\n    }\n\n\n\n    object_property_set_bool(OBJECT(&s->ccm), true, \"realized\", &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(&s->ccm), 0, FSL_IMX6_CCM_ADDR);\n\n\n\n    object_property_set_bool(OBJECT(&s->src), true, \"realized\", &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(&s->src), 0, FSL_IMX6_SRC_ADDR);\n\n\n\n    /* Initialize all UARTs */\n\n    for (i = 0; i < FSL_IMX6_NUM_UARTS; i++) {\n\n        static const struct {\n\n            hwaddr addr;\n\n            unsigned int irq;\n\n        } serial_table[FSL_IMX6_NUM_UARTS] = {\n\n            { FSL_IMX6_UART1_ADDR, FSL_IMX6_UART1_IRQ },\n\n            { FSL_IMX6_UART2_ADDR, FSL_IMX6_UART2_IRQ },\n\n            { FSL_IMX6_UART3_ADDR, FSL_IMX6_UART3_IRQ },\n\n            { FSL_IMX6_UART4_ADDR, FSL_IMX6_UART4_IRQ },\n\n            { FSL_IMX6_UART5_ADDR, FSL_IMX6_UART5_IRQ },\n\n        };\n\n\n\n        if (i < MAX_SERIAL_PORTS) {\n\n            Chardev *chr;\n\n\n\n            chr = serial_hds[i];\n\n\n\n            if (!chr) {\n\n                char *label = g_strdup_printf(\"imx6.uart%d\", i + 1);\n\n                chr = qemu_chr_new(label, \"null\");\n\n                g_free(label);\n\n                serial_hds[i] = chr;\n\n            }\n\n\n\n            qdev_prop_set_chr(DEVICE(&s->uart[i]), \"chardev\", chr);\n\n        }\n\n\n\n        object_property_set_bool(OBJECT(&s->uart[i]), true, \"realized\", &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return;\n\n        }\n\n\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(&s->uart[i]), 0, serial_table[i].addr);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(&s->uart[i]), 0,\n\n                           qdev_get_gpio_in(DEVICE(&s->a9mpcore),\n\n                                            serial_table[i].irq));\n\n    }\n\n\n\n    s->gpt.ccm = IMX_CCM(&s->ccm);\n\n\n\n    object_property_set_bool(OBJECT(&s->gpt), true, \"realized\", &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(&s->gpt), 0, FSL_IMX6_GPT_ADDR);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(&s->gpt), 0,\n\n                       qdev_get_gpio_in(DEVICE(&s->a9mpcore),\n\n                                        FSL_IMX6_GPT_IRQ));\n\n\n\n    /* Initialize all EPIT timers */\n\n    for (i = 0; i < FSL_IMX6_NUM_EPITS; i++) {\n\n        static const struct {\n\n            hwaddr addr;\n\n            unsigned int irq;\n\n        } epit_table[FSL_IMX6_NUM_EPITS] = {\n\n            { FSL_IMX6_EPIT1_ADDR, FSL_IMX6_EPIT1_IRQ },\n\n            { FSL_IMX6_EPIT2_ADDR, FSL_IMX6_EPIT2_IRQ },\n\n        };\n\n\n\n        s->epit[i].ccm = IMX_CCM(&s->ccm);\n\n\n\n        object_property_set_bool(OBJECT(&s->epit[i]), true, \"realized\", &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return;\n\n        }\n\n\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(&s->epit[i]), 0, epit_table[i].addr);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(&s->epit[i]), 0,\n\n                           qdev_get_gpio_in(DEVICE(&s->a9mpcore),\n\n                                            epit_table[i].irq));\n\n    }\n\n\n\n    /* Initialize all I2C */\n\n    for (i = 0; i < FSL_IMX6_NUM_I2CS; i++) {\n\n        static const struct {\n\n            hwaddr addr;\n\n            unsigned int irq;\n\n        } i2c_table[FSL_IMX6_NUM_I2CS] = {\n\n            { FSL_IMX6_I2C1_ADDR, FSL_IMX6_I2C1_IRQ },\n\n            { FSL_IMX6_I2C2_ADDR, FSL_IMX6_I2C2_IRQ },\n\n            { FSL_IMX6_I2C3_ADDR, FSL_IMX6_I2C3_IRQ }\n\n        };\n\n\n\n        object_property_set_bool(OBJECT(&s->i2c[i]), true, \"realized\", &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return;\n\n        }\n\n\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(&s->i2c[i]), 0, i2c_table[i].addr);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(&s->i2c[i]), 0,\n\n                           qdev_get_gpio_in(DEVICE(&s->a9mpcore),\n\n                                            i2c_table[i].irq));\n\n    }\n\n\n\n    /* Initialize all GPIOs */\n\n    for (i = 0; i < FSL_IMX6_NUM_GPIOS; i++) {\n\n        static const struct {\n\n            hwaddr addr;\n\n            unsigned int irq_low;\n\n            unsigned int irq_high;\n\n        } gpio_table[FSL_IMX6_NUM_GPIOS] = {\n\n            {\n\n                FSL_IMX6_GPIO1_ADDR,\n\n                FSL_IMX6_GPIO1_LOW_IRQ,\n\n                FSL_IMX6_GPIO1_HIGH_IRQ\n\n            },\n\n            {\n\n                FSL_IMX6_GPIO2_ADDR,\n\n                FSL_IMX6_GPIO2_LOW_IRQ,\n\n                FSL_IMX6_GPIO2_HIGH_IRQ\n\n            },\n\n            {\n\n                FSL_IMX6_GPIO3_ADDR,\n\n                FSL_IMX6_GPIO3_LOW_IRQ,\n\n                FSL_IMX6_GPIO3_HIGH_IRQ\n\n            },\n\n            {\n\n                FSL_IMX6_GPIO4_ADDR,\n\n                FSL_IMX6_GPIO4_LOW_IRQ,\n\n                FSL_IMX6_GPIO4_HIGH_IRQ\n\n            },\n\n            {\n\n                FSL_IMX6_GPIO5_ADDR,\n\n                FSL_IMX6_GPIO5_LOW_IRQ,\n\n                FSL_IMX6_GPIO5_HIGH_IRQ\n\n            },\n\n            {\n\n                FSL_IMX6_GPIO6_ADDR,\n\n                FSL_IMX6_GPIO6_LOW_IRQ,\n\n                FSL_IMX6_GPIO6_HIGH_IRQ\n\n            },\n\n            {\n\n                FSL_IMX6_GPIO7_ADDR,\n\n                FSL_IMX6_GPIO7_LOW_IRQ,\n\n                FSL_IMX6_GPIO7_HIGH_IRQ\n\n            },\n\n        };\n\n\n\n        object_property_set_bool(OBJECT(&s->gpio[i]), true, \"has-edge-sel\",\n\n                                 &error_abort);\n\n        object_property_set_bool(OBJECT(&s->gpio[i]), true, \"has-upper-pin-irq\",\n\n                                 &error_abort);\n\n        object_property_set_bool(OBJECT(&s->gpio[i]), true, \"realized\", &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return;\n\n        }\n\n\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(&s->gpio[i]), 0, gpio_table[i].addr);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(&s->gpio[i]), 0,\n\n                           qdev_get_gpio_in(DEVICE(&s->a9mpcore),\n\n                                            gpio_table[i].irq_low));\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(&s->gpio[i]), 1,\n\n                           qdev_get_gpio_in(DEVICE(&s->a9mpcore),\n\n                                            gpio_table[i].irq_high));\n\n    }\n\n\n\n    /* Initialize all SDHC */\n\n    for (i = 0; i < FSL_IMX6_NUM_ESDHCS; i++) {\n\n        static const struct {\n\n            hwaddr addr;\n\n            unsigned int irq;\n\n        } esdhc_table[FSL_IMX6_NUM_ESDHCS] = {\n\n            { FSL_IMX6_uSDHC1_ADDR, FSL_IMX6_uSDHC1_IRQ },\n\n            { FSL_IMX6_uSDHC2_ADDR, FSL_IMX6_uSDHC2_IRQ },\n\n            { FSL_IMX6_uSDHC3_ADDR, FSL_IMX6_uSDHC3_IRQ },\n\n            { FSL_IMX6_uSDHC4_ADDR, FSL_IMX6_uSDHC4_IRQ },\n\n        };\n\n\n\n        object_property_set_bool(OBJECT(&s->esdhc[i]), true, \"realized\", &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return;\n\n        }\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(&s->esdhc[i]), 0, esdhc_table[i].addr);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(&s->esdhc[i]), 0,\n\n                           qdev_get_gpio_in(DEVICE(&s->a9mpcore),\n\n                                            esdhc_table[i].irq));\n\n    }\n\n\n\n    /* Initialize all ECSPI */\n\n    for (i = 0; i < FSL_IMX6_NUM_ECSPIS; i++) {\n\n        static const struct {\n\n            hwaddr addr;\n\n            unsigned int irq;\n\n        } spi_table[FSL_IMX6_NUM_ECSPIS] = {\n\n            { FSL_IMX6_eCSPI1_ADDR, FSL_IMX6_ECSPI1_IRQ },\n\n            { FSL_IMX6_eCSPI2_ADDR, FSL_IMX6_ECSPI2_IRQ },\n\n            { FSL_IMX6_eCSPI3_ADDR, FSL_IMX6_ECSPI3_IRQ },\n\n            { FSL_IMX6_eCSPI4_ADDR, FSL_IMX6_ECSPI4_IRQ },\n\n            { FSL_IMX6_eCSPI5_ADDR, FSL_IMX6_ECSPI5_IRQ },\n\n        };\n\n\n\n        /* Initialize the SPI */\n\n        object_property_set_bool(OBJECT(&s->spi[i]), true, \"realized\", &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return;\n\n        }\n\n\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(&s->spi[i]), 0, spi_table[i].addr);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(&s->spi[i]), 0,\n\n                           qdev_get_gpio_in(DEVICE(&s->a9mpcore),\n\n                                            spi_table[i].irq));\n\n    }\n\n\n\n    object_property_set_bool(OBJECT(&s->eth), true, \"realized\", &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(&s->eth), 0, FSL_IMX6_ENET_ADDR);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(&s->eth), 0,\n\n                       qdev_get_gpio_in(DEVICE(&s->a9mpcore),\n\n                                        FSL_IMX6_ENET_MAC_IRQ));\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(&s->eth), 1,\n\n                       qdev_get_gpio_in(DEVICE(&s->a9mpcore),\n\n                                        FSL_IMX6_ENET_MAC_1588_IRQ));\n\n\n\n    /* ROM memory */\n\n    memory_region_init_rom_nomigrate(&s->rom, NULL, \"imx6.rom\",\n\n                           FSL_IMX6_ROM_SIZE, &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n    memory_region_add_subregion(get_system_memory(), FSL_IMX6_ROM_ADDR,\n\n                                &s->rom);\n\n\n\n    /* CAAM memory */\n\n    memory_region_init_rom_nomigrate(&s->caam, NULL, \"imx6.caam\",\n\n                           FSL_IMX6_CAAM_MEM_SIZE, &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n    memory_region_add_subregion(get_system_memory(), FSL_IMX6_CAAM_MEM_ADDR,\n\n                                &s->caam);\n\n\n\n    /* OCRAM memory */\n\n    memory_region_init_ram(&s->ocram, NULL, \"imx6.ocram\", FSL_IMX6_OCRAM_SIZE,\n\n                           &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n    memory_region_add_subregion(get_system_memory(), FSL_IMX6_OCRAM_ADDR,\n\n                                &s->ocram);\n\n\n\n    /* internal OCRAM (256 KB) is aliased over 1 MB */\n\n    memory_region_init_alias(&s->ocram_alias, NULL, \"imx6.ocram_alias\",\n\n                             &s->ocram, 0, FSL_IMX6_OCRAM_ALIAS_SIZE);\n\n    memory_region_add_subregion(get_system_memory(), FSL_IMX6_OCRAM_ALIAS_ADDR,\n\n                                &s->ocram_alias);\n\n}\n", "idx": 23437}
{"project": "qemu", "commit_id": "ba42ebb863ab7d40adc79298422ed9596df8f73a", "target": 1, "func": "ssize_t v9fs_iov_vunmarshal(struct iovec *out_sg, int out_num, size_t offset,\n\n                            int bswap, const char *fmt, va_list ap)\n\n{\n\n    int i;\n\n    ssize_t copied = 0;\n\n    size_t old_offset = offset;\n\n\n\n    for (i = 0; fmt[i]; i++) {\n\n        switch (fmt[i]) {\n\n        case 'b': {\n\n            uint8_t *valp = va_arg(ap, uint8_t *);\n\n            copied = v9fs_unpack(valp, out_sg, out_num, offset, sizeof(*valp));\n\n            break;\n\n        }\n\n        case 'w': {\n\n            uint16_t val, *valp;\n\n            valp = va_arg(ap, uint16_t *);\n\n            copied = v9fs_unpack(&val, out_sg, out_num, offset, sizeof(val));\n\n            if (bswap) {\n\n                *valp = le16_to_cpu(val);\n\n            } else {\n\n                *valp = val;\n\n            }\n\n            break;\n\n        }\n\n        case 'd': {\n\n            uint32_t val, *valp;\n\n            valp = va_arg(ap, uint32_t *);\n\n            copied = v9fs_unpack(&val, out_sg, out_num, offset, sizeof(val));\n\n            if (bswap) {\n\n                *valp = le32_to_cpu(val);\n\n            } else {\n\n                *valp = val;\n\n            }\n\n            break;\n\n        }\n\n        case 'q': {\n\n            uint64_t val, *valp;\n\n            valp = va_arg(ap, uint64_t *);\n\n            copied = v9fs_unpack(&val, out_sg, out_num, offset, sizeof(val));\n\n            if (bswap) {\n\n                *valp = le64_to_cpu(val);\n\n            } else {\n\n                *valp = val;\n\n            }\n\n            break;\n\n        }\n\n        case 's': {\n\n            V9fsString *str = va_arg(ap, V9fsString *);\n\n            copied = v9fs_iov_unmarshal(out_sg, out_num, offset, bswap,\n\n                                        \"w\", &str->size);\n\n            if (copied > 0) {\n\n                offset += copied;\n\n                str->data = g_malloc(str->size + 1);\n\n                copied = v9fs_unpack(str->data, out_sg, out_num, offset,\n\n                                     str->size);\n\n                if (copied > 0) {\n\n                    str->data[str->size] = 0;\n\n                } else {\n\n                    v9fs_string_free(str);\n\n                }\n\n            }\n\n            break;\n\n        }\n\n        case 'Q': {\n\n            V9fsQID *qidp = va_arg(ap, V9fsQID *);\n\n            copied = v9fs_iov_unmarshal(out_sg, out_num, offset, bswap,\n\n                                        \"bdq\", &qidp->type, &qidp->version,\n\n                                        &qidp->path);\n\n            break;\n\n        }\n\n        case 'S': {\n\n            V9fsStat *statp = va_arg(ap, V9fsStat *);\n\n            copied = v9fs_iov_unmarshal(out_sg, out_num, offset, bswap,\n\n                                        \"wwdQdddqsssssddd\",\n\n                                        &statp->size, &statp->type,\n\n                                        &statp->dev, &statp->qid,\n\n                                        &statp->mode, &statp->atime,\n\n                                        &statp->mtime, &statp->length,\n\n                                        &statp->name, &statp->uid,\n\n                                        &statp->gid, &statp->muid,\n\n                                        &statp->extension,\n\n                                        &statp->n_uid, &statp->n_gid,\n\n                                        &statp->n_muid);\n\n            break;\n\n        }\n\n        case 'I': {\n\n            V9fsIattr *iattr = va_arg(ap, V9fsIattr *);\n\n            copied = v9fs_iov_unmarshal(out_sg, out_num, offset, bswap,\n\n                                        \"ddddqqqqq\",\n\n                                        &iattr->valid, &iattr->mode,\n\n                                        &iattr->uid, &iattr->gid,\n\n                                        &iattr->size, &iattr->atime_sec,\n\n                                        &iattr->atime_nsec,\n\n                                        &iattr->mtime_sec,\n\n                                        &iattr->mtime_nsec);\n\n            break;\n\n        }\n\n        default:\n\n            break;\n\n        }\n\n        if (copied < 0) {\n\n            return copied;\n\n        }\n\n        offset += copied;\n\n    }\n\n\n\n    return offset - old_offset;\n\n}\n", "idx": 23439}
{"project": "qemu", "commit_id": "da124e62de2109a312e21d85d6a3419774c58948", "target": 0, "func": "static void usb_serial_event(void *opaque, int event)\n\n{\n\n    USBSerialState *s = opaque;\n\n\n\n    switch (event) {\n\n        case CHR_EVENT_BREAK:\n\n            s->event_trigger |= FTDI_BI;\n\n            break;\n\n        case CHR_EVENT_FOCUS:\n\n            break;\n\n        case CHR_EVENT_OPENED:\n\n            usb_serial_reset(s);\n\n            /* TODO: Reset USB port */\n\n            break;\n\n    }\n\n}\n", "idx": 23443}
{"project": "qemu", "commit_id": "63ae0915f8ec9746d17a25c27f64cf65550627ab", "target": 0, "func": "static void gen_rlwinm(DisasContext *ctx)\n\n{\n\n    uint32_t mb, me, sh;\n\n\n\n    sh = SH(ctx->opcode);\n\n    mb = MB(ctx->opcode);\n\n    me = ME(ctx->opcode);\n\n\n\n    if (likely(mb == 0 && me == (31 - sh))) {\n\n        if (likely(sh == 0)) {\n\n            tcg_gen_ext32u_tl(cpu_gpr[rA(ctx->opcode)], cpu_gpr[rS(ctx->opcode)]);\n\n        } else {\n\n            TCGv t0 = tcg_temp_new();\n\n            tcg_gen_ext32u_tl(t0, cpu_gpr[rS(ctx->opcode)]);\n\n            tcg_gen_shli_tl(t0, t0, sh);\n\n            tcg_gen_ext32u_tl(cpu_gpr[rA(ctx->opcode)], t0);\n\n            tcg_temp_free(t0);\n\n        }\n\n    } else if (likely(sh != 0 && me == 31 && sh == (32 - mb))) {\n\n        TCGv t0 = tcg_temp_new();\n\n        tcg_gen_ext32u_tl(t0, cpu_gpr[rS(ctx->opcode)]);\n\n        tcg_gen_shri_tl(t0, t0, mb);\n\n        tcg_gen_ext32u_tl(cpu_gpr[rA(ctx->opcode)], t0);\n\n        tcg_temp_free(t0);\n\n    } else if (likely(mb == 0 && me == 31)) {\n\n        TCGv_i32 t0 = tcg_temp_new_i32();\n\n        tcg_gen_trunc_tl_i32(t0, cpu_gpr[rS(ctx->opcode)]);\n\n        tcg_gen_rotli_i32(t0, t0, sh);\n\n        tcg_gen_extu_i32_tl(cpu_gpr[rA(ctx->opcode)], t0);\n\n        tcg_temp_free_i32(t0);\n\n    } else {\n\n        TCGv t0 = tcg_temp_new();\n\n#if defined(TARGET_PPC64)\n\n        tcg_gen_deposit_i64(t0, cpu_gpr[rS(ctx->opcode)],\n\n            cpu_gpr[rS(ctx->opcode)], 32, 32);\n\n        tcg_gen_rotli_i64(t0, t0, sh);\n\n#else\n\n        tcg_gen_rotli_i32(t0, cpu_gpr[rS(ctx->opcode)], sh);\n\n#endif\n\n#if defined(TARGET_PPC64)\n\n        mb += 32;\n\n        me += 32;\n\n#endif\n\n        tcg_gen_andi_tl(cpu_gpr[rA(ctx->opcode)], t0, MASK(mb, me));\n\n        tcg_temp_free(t0);\n\n    }\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]);\n\n}\n", "idx": 23444}
{"project": "qemu", "commit_id": "1e39d97af086d525cd0408eaa5d19783ea165906", "target": 0, "func": "static void gen_exception(DisasContext *s, int trapno, target_ulong cur_eip)\n\n{\n\n    gen_update_cc_op(s);\n\n    gen_jmp_im(cur_eip);\n\n    gen_helper_raise_exception(cpu_env, tcg_const_i32(trapno));\n\n    s->is_jmp = DISAS_TB_JUMP;\n\n}\n", "idx": 23445}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint32_t helper_efdctsiz (uint64_t val)\n\n{\n\n    CPU_DoubleU u;\n\n\n\n    u.ll = val;\n\n    /* NaN are not treated the same way IEEE 754 does */\n\n    if (unlikely(float64_is_nan(u.d)))\n\n        return 0;\n\n\n\n    return float64_to_int32_round_to_zero(u.d, &env->vec_status);\n\n}\n", "idx": 23446}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static inline uint32_t reloc_pc16_val(tcg_insn_unit *pc, tcg_insn_unit *target)\n\n{\n\n    /* Let the compiler perform the right-shift as part of the arithmetic.  */\n\n    ptrdiff_t disp = target - (pc + 1);\n\n    assert(disp == (int16_t)disp);\n\n    return disp & 0xffff;\n\n}\n", "idx": 23447}
{"project": "qemu", "commit_id": "02b07434bed8360715198b4cbfdfebd17f7cac32", "target": 0, "func": "static uint16_t pxb_bus_numa_node(PCIBus *bus)\n\n{\n\n    PXBDev *pxb = PXB_DEV(bus->parent_dev);\n\n\n\n    return pxb->numa_node;\n\n}\n", "idx": 23449}
{"project": "qemu", "commit_id": "2a8b58703e2144c136f6d26f609c6a338a03a3ca", "target": 0, "func": "void ptimer_run(ptimer_state *s, int oneshot)\n\n{\n\n    bool was_disabled = !s->enabled;\n\n\n\n    if (was_disabled && s->period == 0) {\n\n        fprintf(stderr, \"Timer with period zero, disabling\\n\");\n\n        return;\n\n    }\n\n    s->enabled = oneshot ? 2 : 1;\n\n    if (was_disabled) {\n\n        s->next_event = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n\n        ptimer_reload(s);\n\n    }\n\n}\n", "idx": 23450}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static uint16_t reloc_pc14_val(tcg_insn_unit *pc, tcg_insn_unit *target)\n\n{\n\n    ptrdiff_t disp = tcg_ptr_byte_diff(target, pc);\n\n    assert(disp == (int16_t) disp);\n\n    return disp & 0xfffc;\n\n}\n", "idx": 23451}
{"project": "qemu", "commit_id": "36b15c79aa1bef5fe7543f9f2629b6413720bbfb", "target": 0, "func": "static void qemu_sgl_init_external(VirtIOSCSIReq *req, struct iovec *sg,\n\n                                   hwaddr *addr, int num)\n\n{\n\n    QEMUSGList *qsgl = &req->qsgl;\n\n\n\n    qemu_sglist_init(qsgl, DEVICE(req->dev), num, &address_space_memory);\n\n    while (num--) {\n\n        qemu_sglist_add(qsgl, *(addr++), (sg++)->iov_len);\n\n    }\n\n}\n", "idx": 23452}
{"project": "qemu", "commit_id": "9154b02c53bb6685797c973fcdbec51c4714777d", "target": 0, "func": "bool vring_setup(Vring *vring, VirtIODevice *vdev, int n)\n\n{\n\n    hwaddr vring_addr = virtio_queue_get_ring_addr(vdev, n);\n\n    hwaddr vring_size = virtio_queue_get_ring_size(vdev, n);\n\n    void *vring_ptr;\n\n\n\n    vring->broken = false;\n\n\n\n    hostmem_init(&vring->hostmem);\n\n    vring_ptr = hostmem_lookup(&vring->hostmem, vring_addr, vring_size, true);\n\n    if (!vring_ptr) {\n\n        error_report(\"Failed to map vring \"\n\n                     \"addr %#\" HWADDR_PRIx \" size %\" HWADDR_PRIu,\n\n                     vring_addr, vring_size);\n\n        vring->broken = true;\n\n        return false;\n\n    }\n\n\n\n    vring_init(&vring->vr, virtio_queue_get_num(vdev, n), vring_ptr, 4096);\n\n\n\n    vring->last_avail_idx = 0;\n\n    vring->last_used_idx = 0;\n\n    vring->signalled_used = 0;\n\n    vring->signalled_used_valid = false;\n\n\n\n    trace_vring_setup(virtio_queue_get_ring_addr(vdev, n),\n\n                      vring->vr.desc, vring->vr.avail, vring->vr.used);\n\n    return true;\n\n}\n", "idx": 23453}
{"project": "qemu", "commit_id": "f1c52354e5bdab6983d13a4c174759c585e834b3", "target": 0, "func": "static uint32_t drc_set_usable(sPAPRDRConnector *drc)\n\n{\n\n    /* if there's no resource/device associated with the DRC, there's\n\n     * no way for us to put it in an allocation state consistent with\n\n     * being 'USABLE'. PAPR 2.7, 13.5.3.4 documents that this should\n\n     * result in an RTAS return code of -3 / \"no such indicator\"\n\n     */\n\n    if (!drc->dev) {\n\n        return RTAS_OUT_NO_SUCH_INDICATOR;\n\n    }\n\n    if (drc->awaiting_release) {\n\n        /* Don't allow the guest to move a device away from UNUSABLE\n\n         * state when we want to unplug it */\n\n        return RTAS_OUT_NO_SUCH_INDICATOR;\n\n    }\n\n\n\n    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_USABLE;\n\n\n\n    return RTAS_OUT_SUCCESS;\n\n}\n", "idx": 23454}
{"project": "qemu", "commit_id": "79afc36d91be7550affbe7db227b4552451da41d", "target": 0, "func": "static void s390_virtio_irq(S390CPU *cpu, int config_change, uint64_t token)\n\n{\n\n    if (kvm_enabled()) {\n\n        kvm_s390_virtio_irq(cpu, config_change, token);\n\n    } else {\n\n        cpu_inject_ext(cpu, VIRTIO_EXT_CODE, config_change, token);\n\n    }\n\n}\n", "idx": 23455}
{"project": "qemu", "commit_id": "1931e26054fdf2b1b84091f0b9662979eb6931ec", "target": 0, "func": "static uint32_t gt64120_readl (void *opaque,\n\n                               target_phys_addr_t addr)\n\n{\n\n    GT64120State *s = opaque;\n\n    uint32_t val;\n\n    uint32_t saddr;\n\n\n\n    val = 0;\n\n    saddr = (addr & 0xfff) >> 2;\n\n\n\n    switch (saddr) {\n\n\n\n    /* CPU Configuration */\n\n    case GT_MULTI:\n\n        /* Only one GT64xxx is present on the CPU bus, return\n\n           the initial value */\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* CPU Error Report */\n\n    case GT_CPUERR_ADDRLO:\n\n    case GT_CPUERR_ADDRHI:\n\n    case GT_CPUERR_DATALO:\n\n    case GT_CPUERR_DATAHI:\n\n    case GT_CPUERR_PARITY:\n\n        /* Emulated memory has no error, always return the initial\n\n           values */\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* CPU Sync Barrier */\n\n    case GT_PCI0SYNC:\n\n    case GT_PCI1SYNC:\n\n        /* Reading those register should empty all FIFO on the PCI\n\n           bus, which are not emulated. The return value should be\n\n           a random value that should be ignored. */\n\n        val = 0xc000ffee;\n\n        break;\n\n\n\n    /* ECC */\n\n    case GT_ECC_ERRDATALO:\n\n    case GT_ECC_ERRDATAHI:\n\n    case GT_ECC_MEM:\n\n    case GT_ECC_CALC:\n\n    case GT_ECC_ERRADDR:\n\n        /* Emulated memory has no error, always return the initial\n\n           values */\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    case GT_CPU:\n\n    case GT_SCS10LD:\n\n    case GT_SCS10HD:\n\n    case GT_SCS32LD:\n\n    case GT_SCS32HD:\n\n    case GT_CS20LD:\n\n    case GT_CS20HD:\n\n    case GT_CS3BOOTLD:\n\n    case GT_CS3BOOTHD:\n\n    case GT_SCS10AR:\n\n    case GT_SCS32AR:\n\n    case GT_CS20R:\n\n    case GT_CS3BOOTR:\n\n    case GT_PCI0IOLD:\n\n    case GT_PCI0M0LD:\n\n    case GT_PCI0M1LD:\n\n    case GT_PCI1IOLD:\n\n    case GT_PCI1M0LD:\n\n    case GT_PCI1M1LD:\n\n    case GT_PCI0IOHD:\n\n    case GT_PCI0M0HD:\n\n    case GT_PCI0M1HD:\n\n    case GT_PCI1IOHD:\n\n    case GT_PCI1M0HD:\n\n    case GT_PCI1M1HD:\n\n    case GT_PCI0IOREMAP:\n\n    case GT_PCI0M0REMAP:\n\n    case GT_PCI0M1REMAP:\n\n    case GT_PCI1IOREMAP:\n\n    case GT_PCI1M0REMAP:\n\n    case GT_PCI1M1REMAP:\n\n    case GT_ISD:\n\n        val = s->regs[saddr];\n\n        break;\n\n    case GT_PCI0_IACK:\n\n        /* Read the IRQ number */\n\n        val = pic_read_irq(isa_pic);\n\n        break;\n\n\n\n    /* SDRAM and Device Address Decode */\n\n    case GT_SCS0LD:\n\n    case GT_SCS0HD:\n\n    case GT_SCS1LD:\n\n    case GT_SCS1HD:\n\n    case GT_SCS2LD:\n\n    case GT_SCS2HD:\n\n    case GT_SCS3LD:\n\n    case GT_SCS3HD:\n\n    case GT_CS0LD:\n\n    case GT_CS0HD:\n\n    case GT_CS1LD:\n\n    case GT_CS1HD:\n\n    case GT_CS2LD:\n\n    case GT_CS2HD:\n\n    case GT_CS3LD:\n\n    case GT_CS3HD:\n\n    case GT_BOOTLD:\n\n    case GT_BOOTHD:\n\n    case GT_ADERR:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* SDRAM Configuration */\n\n    case GT_SDRAM_CFG:\n\n    case GT_SDRAM_OPMODE:\n\n    case GT_SDRAM_BM:\n\n    case GT_SDRAM_ADDRDECODE:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* SDRAM Parameters */\n\n    case GT_SDRAM_B0:\n\n    case GT_SDRAM_B1:\n\n    case GT_SDRAM_B2:\n\n    case GT_SDRAM_B3:\n\n        /* We don't simulate electrical parameters of the SDRAM.\n\n           Just return the last written value. */\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* Device Parameters */\n\n    case GT_DEV_B0:\n\n    case GT_DEV_B1:\n\n    case GT_DEV_B2:\n\n    case GT_DEV_B3:\n\n    case GT_DEV_BOOT:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* DMA Record */\n\n    case GT_DMA0_CNT:\n\n    case GT_DMA1_CNT:\n\n    case GT_DMA2_CNT:\n\n    case GT_DMA3_CNT:\n\n    case GT_DMA0_SA:\n\n    case GT_DMA1_SA:\n\n    case GT_DMA2_SA:\n\n    case GT_DMA3_SA:\n\n    case GT_DMA0_DA:\n\n    case GT_DMA1_DA:\n\n    case GT_DMA2_DA:\n\n    case GT_DMA3_DA:\n\n    case GT_DMA0_NEXT:\n\n    case GT_DMA1_NEXT:\n\n    case GT_DMA2_NEXT:\n\n    case GT_DMA3_NEXT:\n\n    case GT_DMA0_CUR:\n\n    case GT_DMA1_CUR:\n\n    case GT_DMA2_CUR:\n\n    case GT_DMA3_CUR:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* DMA Channel Control */\n\n    case GT_DMA0_CTRL:\n\n    case GT_DMA1_CTRL:\n\n    case GT_DMA2_CTRL:\n\n    case GT_DMA3_CTRL:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* DMA Arbiter */\n\n    case GT_DMA_ARB:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* Timer/Counter */\n\n    case GT_TC0:\n\n    case GT_TC1:\n\n    case GT_TC2:\n\n    case GT_TC3:\n\n    case GT_TC_CONTROL:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* PCI Internal */\n\n    case GT_PCI0_CFGADDR:\n\n        val = s->pci->config_reg;\n\n        break;\n\n    case GT_PCI0_CFGDATA:\n\n        if (!(s->pci->config_reg & (1u << 31)))\n\n            val = 0xffffffff;\n\n        else\n\n            val = pci_host_data_readl(s->pci, 0);\n\n        break;\n\n\n\n    case GT_PCI0_CMD:\n\n    case GT_PCI0_TOR:\n\n    case GT_PCI0_BS_SCS10:\n\n    case GT_PCI0_BS_SCS32:\n\n    case GT_PCI0_BS_CS20:\n\n    case GT_PCI0_BS_CS3BT:\n\n    case GT_PCI1_IACK:\n\n    case GT_PCI0_BARE:\n\n    case GT_PCI0_PREFMBR:\n\n    case GT_PCI0_SCS10_BAR:\n\n    case GT_PCI0_SCS32_BAR:\n\n    case GT_PCI0_CS20_BAR:\n\n    case GT_PCI0_CS3BT_BAR:\n\n    case GT_PCI0_SSCS10_BAR:\n\n    case GT_PCI0_SSCS32_BAR:\n\n    case GT_PCI0_SCS3BT_BAR:\n\n    case GT_PCI1_CMD:\n\n    case GT_PCI1_TOR:\n\n    case GT_PCI1_BS_SCS10:\n\n    case GT_PCI1_BS_SCS32:\n\n    case GT_PCI1_BS_CS20:\n\n    case GT_PCI1_BS_CS3BT:\n\n    case GT_PCI1_BARE:\n\n    case GT_PCI1_PREFMBR:\n\n    case GT_PCI1_SCS10_BAR:\n\n    case GT_PCI1_SCS32_BAR:\n\n    case GT_PCI1_CS20_BAR:\n\n    case GT_PCI1_CS3BT_BAR:\n\n    case GT_PCI1_SSCS10_BAR:\n\n    case GT_PCI1_SSCS32_BAR:\n\n    case GT_PCI1_SCS3BT_BAR:\n\n    case GT_PCI1_CFGADDR:\n\n    case GT_PCI1_CFGDATA:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* Interrupts */\n\n    case GT_INTRCAUSE:\n\n        val = s->regs[saddr];\n\n        dprintf(\"INTRCAUSE %x\\n\", val);\n\n        break;\n\n    case GT_INTRMASK:\n\n        val = s->regs[saddr];\n\n        dprintf(\"INTRMASK %x\\n\", val);\n\n        break;\n\n    case GT_PCI0_ICMASK:\n\n        val = s->regs[saddr];\n\n        dprintf(\"ICMASK %x\\n\", val);\n\n        break;\n\n    case GT_PCI0_SERR0MASK:\n\n        val = s->regs[saddr];\n\n        dprintf(\"SERR0MASK %x\\n\", val);\n\n        break;\n\n\n\n    /* Reserved when only PCI_0 is configured. */\n\n    case GT_HINTRCAUSE:\n\n    case GT_CPU_INTSEL:\n\n    case GT_PCI0_INTSEL:\n\n    case GT_HINTRMASK:\n\n    case GT_PCI0_HICMASK:\n\n    case GT_PCI1_SERR1MASK:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    default:\n\n        val = s->regs[saddr];\n\n        dprintf (\"Bad register offset 0x%x\\n\", (int)addr);\n\n        break;\n\n    }\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    val = bswap32(val);\n\n#endif\n\n    return val;\n\n}\n", "idx": 23456}
{"project": "qemu", "commit_id": "d4a606b38b5d4b3689b86cc1575908e82179ecfb", "target": 0, "func": "static void x86_cpu_expand_features(X86CPU *cpu, Error **errp)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    FeatureWord w;\n\n    GList *l;\n\n    Error *local_err = NULL;\n\n\n\n    /*TODO: cpu->max_features incorrectly overwrites features\n\n     * set using \"feat=on|off\". Once we fix this, we can convert\n\n     * plus_features & minus_features to global properties\n\n     * inside x86_cpu_parse_featurestr() too.\n\n     */\n\n    if (cpu->max_features) {\n\n        for (w = 0; w < FEATURE_WORDS; w++) {\n\n            env->features[w] =\n\n                x86_cpu_get_supported_feature_word(w, cpu->migratable);\n\n        }\n\n    }\n\n\n\n    for (l = plus_features; l; l = l->next) {\n\n        const char *prop = l->data;\n\n        object_property_set_bool(OBJECT(cpu), true, prop, &local_err);\n\n        if (local_err) {\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    for (l = minus_features; l; l = l->next) {\n\n        const char *prop = l->data;\n\n        object_property_set_bool(OBJECT(cpu), false, prop, &local_err);\n\n        if (local_err) {\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    if (!kvm_enabled() || !cpu->expose_kvm) {\n\n        env->features[FEAT_KVM] = 0;\n\n    }\n\n\n\n    x86_cpu_enable_xsave_components(cpu);\n\n\n\n    /* CPUID[EAX=7,ECX=0].EBX always increased level automatically: */\n\n    x86_cpu_adjust_feat_level(cpu, FEAT_7_0_EBX);\n\n    if (cpu->full_cpuid_auto_level) {\n\n        x86_cpu_adjust_feat_level(cpu, FEAT_1_EDX);\n\n        x86_cpu_adjust_feat_level(cpu, FEAT_1_ECX);\n\n        x86_cpu_adjust_feat_level(cpu, FEAT_6_EAX);\n\n        x86_cpu_adjust_feat_level(cpu, FEAT_7_0_ECX);\n\n        x86_cpu_adjust_feat_level(cpu, FEAT_8000_0001_EDX);\n\n        x86_cpu_adjust_feat_level(cpu, FEAT_8000_0001_ECX);\n\n        x86_cpu_adjust_feat_level(cpu, FEAT_8000_0007_EDX);\n\n        x86_cpu_adjust_feat_level(cpu, FEAT_C000_0001_EDX);\n\n        x86_cpu_adjust_feat_level(cpu, FEAT_SVM);\n\n        x86_cpu_adjust_feat_level(cpu, FEAT_XSAVE);\n\n        /* SVM requires CPUID[0x8000000A] */\n\n        if (env->features[FEAT_8000_0001_ECX] & CPUID_EXT3_SVM) {\n\n            x86_cpu_adjust_level(cpu, &env->cpuid_min_xlevel, 0x8000000A);\n\n        }\n\n    }\n\n\n\n    /* Set cpuid_*level* based on cpuid_min_*level, if not explicitly set */\n\n    if (env->cpuid_level == UINT32_MAX) {\n\n        env->cpuid_level = env->cpuid_min_level;\n\n    }\n\n    if (env->cpuid_xlevel == UINT32_MAX) {\n\n        env->cpuid_xlevel = env->cpuid_min_xlevel;\n\n    }\n\n    if (env->cpuid_xlevel2 == UINT32_MAX) {\n\n        env->cpuid_xlevel2 = env->cpuid_min_xlevel2;\n\n    }\n\n\n\nout:\n\n    if (local_err != NULL) {\n\n        error_propagate(errp, local_err);\n\n    }\n\n}\n", "idx": 23457}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static BusState *qbus_find_bus(DeviceState *dev, char *elem)\n\n{\n\n    BusState *child;\n\n\n\n    LIST_FOREACH(child, &dev->child_bus, sibling) {\n\n        if (strcmp(child->name, elem) == 0) {\n\n            return child;\n\n        }\n\n    }\n\n    return NULL;\n\n}\n", "idx": 23458}
{"project": "qemu", "commit_id": "0f40444cc4fc6526a9a544b11475f1086113f9ba", "target": 0, "func": "static int open_f(BlockBackend *blk, int argc, char **argv)\n\n{\n\n    int flags = BDRV_O_UNMAP;\n\n    int readonly = 0;\n\n    bool writethrough = true;\n\n    int c;\n\n    QemuOpts *qopts;\n\n    QDict *opts;\n\n    bool force_share = false;\n\n\n\n    while ((c = getopt(argc, argv, \"snro:kt:d:U\")) != -1) {\n\n        switch (c) {\n\n        case 's':\n\n            flags |= BDRV_O_SNAPSHOT;\n\n            break;\n\n        case 'n':\n\n            flags |= BDRV_O_NOCACHE;\n\n            writethrough = false;\n\n            break;\n\n        case 'r':\n\n            readonly = 1;\n\n            break;\n\n        case 'k':\n\n            flags |= BDRV_O_NATIVE_AIO;\n\n            break;\n\n        case 't':\n\n            if (bdrv_parse_cache_mode(optarg, &flags, &writethrough) < 0) {\n\n                error_report(\"Invalid cache option: %s\", optarg);\n\n                qemu_opts_reset(&empty_opts);\n\n                return 0;\n\n            }\n\n            break;\n\n        case 'd':\n\n            if (bdrv_parse_discard_flags(optarg, &flags) < 0) {\n\n                error_report(\"Invalid discard option: %s\", optarg);\n\n                qemu_opts_reset(&empty_opts);\n\n                return 0;\n\n            }\n\n            break;\n\n        case 'o':\n\n            if (imageOpts) {\n\n                printf(\"--image-opts and 'open -o' are mutually exclusive\\n\");\n\n                qemu_opts_reset(&empty_opts);\n\n                return 0;\n\n            }\n\n            if (!qemu_opts_parse_noisily(&empty_opts, optarg, false)) {\n\n                qemu_opts_reset(&empty_opts);\n\n                return 0;\n\n            }\n\n            break;\n\n        case 'U':\n\n            force_share = true;\n\n            break;\n\n        default:\n\n            qemu_opts_reset(&empty_opts);\n\n            return qemuio_command_usage(&open_cmd);\n\n        }\n\n    }\n\n\n\n    if (!readonly) {\n\n        flags |= BDRV_O_RDWR;\n\n    }\n\n\n\n    if (imageOpts && (optind == argc - 1)) {\n\n        if (!qemu_opts_parse_noisily(&empty_opts, argv[optind], false)) {\n\n            qemu_opts_reset(&empty_opts);\n\n            return 0;\n\n        }\n\n        optind++;\n\n    }\n\n\n\n    qopts = qemu_opts_find(&empty_opts, NULL);\n\n    opts = qopts ? qemu_opts_to_qdict(qopts, NULL) : NULL;\n\n    qemu_opts_reset(&empty_opts);\n\n\n\n    if (optind == argc - 1) {\n\n        openfile(argv[optind], flags, writethrough, force_share, opts);\n\n    } else if (optind == argc) {\n\n        openfile(NULL, flags, writethrough, force_share, opts);\n\n    } else {\n\n        QDECREF(opts);\n\n        qemuio_command_usage(&open_cmd);\n\n    }\n\n    return 0;\n\n}\n", "idx": 23460}
{"project": "qemu", "commit_id": "e1123a3b40a1a9a625a29c8ed4debb7e206ea690", "target": 0, "func": "static bool iscsi_allocationmap_is_allocated(IscsiLun *iscsilun,\n\n                                             int64_t sector_num, int nb_sectors)\n\n{\n\n    unsigned long size;\n\n    if (iscsilun->allocationmap == NULL) {\n\n        return true;\n\n    }\n\n    size = DIV_ROUND_UP(sector_num + nb_sectors, iscsilun->cluster_sectors);\n\n    return !(find_next_bit(iscsilun->allocationmap, size,\n\n                           sector_num / iscsilun->cluster_sectors) == size);\n\n}\n", "idx": 23461}
{"project": "qemu", "commit_id": "c2ebd862a54b7e12175d65c03ba259926cb2237a", "target": 0, "func": "static void disas_ldst_pair(DisasContext *s, uint32_t insn)\n\n{\n\n    int rt = extract32(insn, 0, 5);\n\n    int rn = extract32(insn, 5, 5);\n\n    int rt2 = extract32(insn, 10, 5);\n\n    int64_t offset = sextract32(insn, 15, 7);\n\n    int index = extract32(insn, 23, 2);\n\n    bool is_vector = extract32(insn, 26, 1);\n\n    bool is_load = extract32(insn, 22, 1);\n\n    int opc = extract32(insn, 30, 2);\n\n\n\n    bool is_signed = false;\n\n    bool postindex = false;\n\n    bool wback = false;\n\n\n\n    TCGv_i64 tcg_addr; /* calculated address */\n\n    int size;\n\n\n\n    if (opc == 3) {\n\n        unallocated_encoding(s);\n\n        return;\n\n    }\n\n\n\n    if (is_vector) {\n\n        size = 2 + opc;\n\n    } else {\n\n        size = 2 + extract32(opc, 1, 1);\n\n        is_signed = extract32(opc, 0, 1);\n\n        if (!is_load && is_signed) {\n\n            unallocated_encoding(s);\n\n            return;\n\n        }\n\n    }\n\n\n\n    switch (index) {\n\n    case 1: /* post-index */\n\n        postindex = true;\n\n        wback = true;\n\n        break;\n\n    case 0:\n\n        /* signed offset with \"non-temporal\" hint. Since we don't emulate\n\n         * caches we don't care about hints to the cache system about\n\n         * data access patterns, and handle this identically to plain\n\n         * signed offset.\n\n         */\n\n        if (is_signed) {\n\n            /* There is no non-temporal-hint version of LDPSW */\n\n            unallocated_encoding(s);\n\n            return;\n\n        }\n\n        postindex = false;\n\n        break;\n\n    case 2: /* signed offset, rn not updated */\n\n        postindex = false;\n\n        break;\n\n    case 3: /* pre-index */\n\n        postindex = false;\n\n        wback = true;\n\n        break;\n\n    }\n\n\n\n    if (is_vector && !fp_access_check(s)) {\n\n        return;\n\n    }\n\n\n\n    offset <<= size;\n\n\n\n    if (rn == 31) {\n\n        gen_check_sp_alignment(s);\n\n    }\n\n\n\n    tcg_addr = read_cpu_reg_sp(s, rn, 1);\n\n\n\n    if (!postindex) {\n\n        tcg_gen_addi_i64(tcg_addr, tcg_addr, offset);\n\n    }\n\n\n\n    if (is_vector) {\n\n        if (is_load) {\n\n            do_fp_ld(s, rt, tcg_addr, size);\n\n        } else {\n\n            do_fp_st(s, rt, tcg_addr, size);\n\n        }\n\n    } else {\n\n        TCGv_i64 tcg_rt = cpu_reg(s, rt);\n\n        if (is_load) {\n\n            do_gpr_ld(s, tcg_rt, tcg_addr, size, is_signed, false);\n\n        } else {\n\n            do_gpr_st(s, tcg_rt, tcg_addr, size);\n\n        }\n\n    }\n\n    tcg_gen_addi_i64(tcg_addr, tcg_addr, 1 << size);\n\n    if (is_vector) {\n\n        if (is_load) {\n\n            do_fp_ld(s, rt2, tcg_addr, size);\n\n        } else {\n\n            do_fp_st(s, rt2, tcg_addr, size);\n\n        }\n\n    } else {\n\n        TCGv_i64 tcg_rt2 = cpu_reg(s, rt2);\n\n        if (is_load) {\n\n            do_gpr_ld(s, tcg_rt2, tcg_addr, size, is_signed, false);\n\n        } else {\n\n            do_gpr_st(s, tcg_rt2, tcg_addr, size);\n\n        }\n\n    }\n\n\n\n    if (wback) {\n\n        if (postindex) {\n\n            tcg_gen_addi_i64(tcg_addr, tcg_addr, offset - (1 << size));\n\n        } else {\n\n            tcg_gen_subi_i64(tcg_addr, tcg_addr, 1 << size);\n\n        }\n\n        tcg_gen_mov_i64(cpu_reg_sp(s, rn), tcg_addr);\n\n    }\n\n}\n", "idx": 23462}
{"project": "qemu", "commit_id": "7bd427d801e1e3293a634d3c83beadaa90ffb911", "target": 0, "func": "static struct omap_rtc_s *omap_rtc_init(target_phys_addr_t base,\n\n                qemu_irq *irq, omap_clk clk)\n\n{\n\n    int iomemtype;\n\n    struct omap_rtc_s *s = (struct omap_rtc_s *)\n\n            qemu_mallocz(sizeof(struct omap_rtc_s));\n\n\n\n    s->irq = irq[0];\n\n    s->alarm = irq[1];\n\n    s->clk = qemu_new_timer(rt_clock, omap_rtc_tick, s);\n\n\n\n    omap_rtc_reset(s);\n\n\n\n    iomemtype = cpu_register_io_memory(omap_rtc_readfn,\n\n                    omap_rtc_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(base, 0x800, iomemtype);\n\n\n\n    return s;\n\n}\n", "idx": 23463}
{"project": "qemu", "commit_id": "58d479786b11a7e982419c1e0905b8490ef9a787", "target": 1, "func": "static uint64_t bonito_ldma_readl(void *opaque, hwaddr addr,\n                                  unsigned size)\n{\n    uint32_t val;\n    PCIBonitoState *s = opaque;\n    val = ((uint32_t *)(&s->bonldma))[addr/sizeof(uint32_t)];\n    return val;", "idx": 23472}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static void integratorcp_init(ram_addr_t ram_size,\n\n                     const char *boot_device,\n\n                     const char *kernel_filename, const char *kernel_cmdline,\n\n                     const char *initrd_filename, const char *cpu_model)\n\n{\n\n    CPUState *env;\n\n    ram_addr_t ram_offset;\n\n    qemu_irq pic[32];\n\n    qemu_irq *cpu_pic;\n\n    DeviceState *dev;\n\n    int i;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"arm926\";\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    ram_offset = qemu_ram_alloc(ram_size);\n\n    /* ??? On a real system the first 1Mb is mapped as SSRAM or boot flash.  */\n\n    /* ??? RAM should repeat to fill physical memory space.  */\n\n    /* SDRAM at address zero*/\n\n    cpu_register_physical_memory(0, ram_size, ram_offset | IO_MEM_RAM);\n\n    /* And again at address 0x80000000 */\n\n    cpu_register_physical_memory(0x80000000, ram_size, ram_offset | IO_MEM_RAM);\n\n\n\n    dev = qdev_create(NULL, \"integrator_core\");\n\n    qdev_prop_set_uint32(dev, \"memsz\", ram_size >> 20);\n\n    qdev_init(dev);\n\n    sysbus_mmio_map((SysBusDevice *)dev, 0, 0x10000000);\n\n\n\n    cpu_pic = arm_pic_init_cpu(env);\n\n    dev = sysbus_create_varargs(\"integrator_pic\", 0x14000000,\n\n                                cpu_pic[ARM_PIC_CPU_IRQ],\n\n                                cpu_pic[ARM_PIC_CPU_FIQ], NULL);\n\n    for (i = 0; i < 32; i++) {\n\n        pic[i] = qdev_get_gpio_in(dev, i);\n\n    }\n\n    sysbus_create_simple(\"integrator_pic\", 0xca000000, pic[26]);\n\n    sysbus_create_varargs(\"integrator_pit\", 0x13000000,\n\n                          pic[5], pic[6], pic[7], NULL);\n\n    sysbus_create_simple(\"pl031\", 0x15000000, pic[8]);\n\n    sysbus_create_simple(\"pl011\", 0x16000000, pic[1]);\n\n    sysbus_create_simple(\"pl011\", 0x17000000, pic[2]);\n\n    icp_control_init(0xcb000000);\n\n    sysbus_create_simple(\"pl050_keyboard\", 0x18000000, pic[3]);\n\n    sysbus_create_simple(\"pl050_mouse\", 0x19000000, pic[4]);\n\n    sysbus_create_varargs(\"pl181\", 0x1c000000, pic[23], pic[24], NULL);\n\n    if (nd_table[0].vlan)\n\n        smc91c111_init(&nd_table[0], 0xc8000000, pic[27]);\n\n\n\n    sysbus_create_simple(\"pl110\", 0xc0000000, pic[22]);\n\n\n\n    integrator_binfo.ram_size = ram_size;\n\n    integrator_binfo.kernel_filename = kernel_filename;\n\n    integrator_binfo.kernel_cmdline = kernel_cmdline;\n\n    integrator_binfo.initrd_filename = initrd_filename;\n\n    arm_load_kernel(env, &integrator_binfo);\n\n}\n", "idx": 23473}
{"project": "qemu", "commit_id": "5ce45c7a2b15cda0a4d8f6c38c4036df25dc9c42", "target": 1, "func": "static void ich9_apm_ctrl_changed(uint32_t val, void *arg)\n\n{\n\n    ICH9LPCState *lpc = arg;\n\n\n\n    /* ACPI specs 3.0, 4.7.2.5 */\n\n    acpi_pm1_cnt_update(&lpc->pm.acpi_regs,\n\n                        val == ICH9_APM_ACPI_ENABLE,\n\n                        val == ICH9_APM_ACPI_DISABLE);\n\n    if (val == ICH9_APM_ACPI_ENABLE || val == ICH9_APM_ACPI_DISABLE) {\n\n        return;\n\n    }\n\n\n\n    /* SMI_EN = PMBASE + 30. SMI control and enable register */\n\n    if (lpc->pm.smi_en & ICH9_PMIO_SMI_EN_APMC_EN) {\n\n        cpu_interrupt(current_cpu, CPU_INTERRUPT_SMI);\n\n    }\n\n}\n", "idx": 23474}
{"project": "qemu", "commit_id": "6265eb26a375179f193f792e4f0d49036d2cf052", "target": 1, "func": "static uint32_t get_cluster_count_for_direntry(BDRVVVFATState* s,\n\n\tdirentry_t* direntry, const char* path)\n\n{\n\n    /*\n\n     * This is a little bit tricky:\n\n     * IF the guest OS just inserts a cluster into the file chain,\n\n     * and leaves the rest alone, (i.e. the original file had clusters\n\n     * 15 -> 16, but now has 15 -> 32 -> 16), then the following happens:\n\n     *\n\n     * - do_commit will write the cluster into the file at the given\n\n     *   offset, but\n\n     *\n\n     * - the cluster which is overwritten should be moved to a later\n\n     *   position in the file.\n\n     *\n\n     * I am not aware that any OS does something as braindead, but this\n\n     * situation could happen anyway when not committing for a long time.\n\n     * Just to be sure that this does not bite us, detect it, and copy the\n\n     * contents of the clusters to-be-overwritten into the qcow.\n\n     */\n\n    int copy_it = 0;\n\n    int was_modified = 0;\n\n    int32_t ret = 0;\n\n\n\n    uint32_t cluster_num = begin_of_direntry(direntry);\n\n    uint32_t offset = 0;\n\n    int first_mapping_index = -1;\n\n    mapping_t* mapping = NULL;\n\n    const char* basename2 = NULL;\n\n\n\n    vvfat_close_current_file(s);\n\n\n\n    /* the root directory */\n\n    if (cluster_num == 0)\n\n\treturn 0;\n\n\n\n    /* write support */\n\n    if (s->qcow) {\n\n\tbasename2 = get_basename(path);\n\n\n\n\tmapping = find_mapping_for_cluster(s, cluster_num);\n\n\n\n\tif (mapping) {\n\n\t    const char* basename;\n\n\n\n\t    assert(mapping->mode & MODE_DELETED);\n\n\t    mapping->mode &= ~MODE_DELETED;\n\n\n\n\t    basename = get_basename(mapping->path);\n\n\n\n\t    assert(mapping->mode & MODE_NORMAL);\n\n\n\n\t    /* rename */\n\n\t    if (strcmp(basename, basename2))\n\n\t\tschedule_rename(s, cluster_num, strdup(path));\n\n\t} else if (is_file(direntry))\n\n\t    /* new file */\n\n\t    schedule_new_file(s, strdup(path), cluster_num);\n\n\telse {\n\n\t    assert(0);\n\n\t    return 0;\n\n\t}\n\n    }\n\n\n\n    while(1) {\n\n\tif (s->qcow) {\n\n\t    if (!copy_it && cluster_was_modified(s, cluster_num)) {\n\n\t\tif (mapping == NULL ||\n\n\t\t\tmapping->begin > cluster_num ||\n\n\t\t\tmapping->end <= cluster_num)\n\n\t\tmapping = find_mapping_for_cluster(s, cluster_num);\n\n\n\n\n\n\t\tif (mapping &&\n\n\t\t\t(mapping->mode & MODE_DIRECTORY) == 0) {\n\n\n\n\t\t    /* was modified in qcow */\n\n\t\t    if (offset != mapping->info.file.offset + s->cluster_size\n\n\t\t\t    * (cluster_num - mapping->begin)) {\n\n\t\t\t/* offset of this cluster in file chain has changed */\n\n\t\t\tassert(0);\n\n\t\t\tcopy_it = 1;\n\n\t\t    } else if (offset == 0) {\n\n\t\t\tconst char* basename = get_basename(mapping->path);\n\n\n\n\t\t\tif (strcmp(basename, basename2))\n\n\t\t\t    copy_it = 1;\n\n\t\t\tfirst_mapping_index = array_index(&(s->mapping), mapping);\n\n\t\t    }\n\n\n\n\t\t    if (mapping->first_mapping_index != first_mapping_index\n\n\t\t\t    && mapping->info.file.offset > 0) {\n\n\t\t\tassert(0);\n\n\t\t\tcopy_it = 1;\n\n\t\t    }\n\n\n\n\t\t    /* need to write out? */\n\n\t\t    if (!was_modified && is_file(direntry)) {\n\n\t\t\twas_modified = 1;\n\n\t\t\tschedule_writeout(s, mapping->dir_index, offset);\n\n\t\t    }\n\n\t\t}\n\n\t    }\n\n\n\n\t    if (copy_it) {\n\n\t\tint i, dummy;\n\n\t\t/*\n\n\t\t * This is horribly inefficient, but that is okay, since\n\n\t\t * it is rarely executed, if at all.\n\n\t\t */\n\n\t\tint64_t offset = cluster2sector(s, cluster_num);\n\n\n\n\t\tvvfat_close_current_file(s);\n\n\t\tfor (i = 0; i < s->sectors_per_cluster; i++)\n\n\t\t    if (!s->qcow->drv->bdrv_is_allocated(s->qcow,\n\n\t\t\t\toffset + i, 1, &dummy)) {\n\n\t\t\tif (vvfat_read(s->bs,\n\n\t\t\t\t    offset, s->cluster_buffer, 1))\n\n\t\t\t    return -1;\n\n\t\t\tif (s->qcow->drv->bdrv_write(s->qcow,\n\n\t\t\t\t    offset, s->cluster_buffer, 1))\n\n\t\t\t    return -2;\n\n\t\t    }\n\n\t    }\n\n\t}\n\n\n\n\tret++;\n\n\tif (s->used_clusters[cluster_num] & USED_ANY)\n\n\t    return 0;\n\n\ts->used_clusters[cluster_num] = USED_FILE;\n\n\n\n\tcluster_num = modified_fat_get(s, cluster_num);\n\n\n\n\tif (fat_eof(s, cluster_num))\n\n\t    return ret;\n\n\telse if (cluster_num < 2 || cluster_num > s->max_fat_value - 16)\n\n\t    return -1;\n\n\n\n\toffset += s->cluster_size;\n\n    }\n\n}\n", "idx": 23475}
{"project": "qemu", "commit_id": "e58d695e6c3a5cfa0aa2fc91b87ade017ef28b05", "target": 1, "func": "void visit_type_str(Visitor *v, const char *name, char **obj, Error **errp)\n\n{\n\n    v->type_str(v, name, obj, errp);\n\n}\n", "idx": 23476}
{"project": "qemu", "commit_id": "635db18f68ded6abec11cd4cf64ebc15c1c6b190", "target": 1, "func": "static bool invalid_qmp_mode(const Monitor *mon, const char *cmd,\n\n                             Error **errp)\n\n{\n\n    bool is_cap = g_str_equal(cmd, \"qmp_capabilities\");\n\n\n\n    if (is_cap && mon->qmp.in_command_mode) {\n\n        error_set(errp, ERROR_CLASS_COMMAND_NOT_FOUND,\n\n                  \"Capabilities negotiation is already complete, command \"\n\n                  \"'%s' ignored\", cmd);\n\n        return true;\n\n    }\n\n    if (!is_cap && !mon->qmp.in_command_mode) {\n\n        error_set(errp, ERROR_CLASS_COMMAND_NOT_FOUND,\n\n                  \"Expecting capabilities negotiation with \"\n\n                  \"'qmp_capabilities' before command '%s'\", cmd);\n\n        return true;\n\n    }\n\n    return false;\n\n}\n", "idx": 23478}
{"project": "qemu", "commit_id": "fe904ea8242cbae2d7e69c052c754b8f5f1ba1d6", "target": 1, "func": "static void migration_completion(MigrationState *s, int current_active_state,\n\n                                 bool *old_vm_running,\n\n                                 int64_t *start_time)\n\n{\n\n    int ret;\n\n\n\n    if (s->state == MIGRATION_STATUS_ACTIVE) {\n\n        qemu_mutex_lock_iothread();\n\n        *start_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);\n\n        qemu_system_wakeup_request(QEMU_WAKEUP_REASON_OTHER);\n\n        *old_vm_running = runstate_is_running();\n\n        ret = global_state_store();\n\n\n\n        if (!ret) {\n\n            ret = vm_stop_force_state(RUN_STATE_FINISH_MIGRATE);\n\n            if (ret >= 0) {\n\n                ret = bdrv_inactivate_all();\n\n            }\n\n            if (ret >= 0) {\n\n                qemu_file_set_rate_limit(s->to_dst_file, INT64_MAX);\n\n                qemu_savevm_state_complete_precopy(s->to_dst_file, false);\n\n            }\n\n        }\n\n        qemu_mutex_unlock_iothread();\n\n\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n    } else if (s->state == MIGRATION_STATUS_POSTCOPY_ACTIVE) {\n\n        trace_migration_completion_postcopy_end();\n\n\n\n        qemu_savevm_state_complete_postcopy(s->to_dst_file);\n\n        trace_migration_completion_postcopy_end_after_complete();\n\n    }\n\n\n\n    /*\n\n     * If rp was opened we must clean up the thread before\n\n     * cleaning everything else up (since if there are no failures\n\n     * it will wait for the destination to send it's status in\n\n     * a SHUT command).\n\n     * Postcopy opens rp if enabled (even if it's not avtivated)\n\n     */\n\n    if (migrate_postcopy_ram()) {\n\n        int rp_error;\n\n        trace_migration_completion_postcopy_end_before_rp();\n\n        rp_error = await_return_path_close_on_source(s);\n\n        trace_migration_completion_postcopy_end_after_rp(rp_error);\n\n        if (rp_error) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    if (qemu_file_get_error(s->to_dst_file)) {\n\n        trace_migration_completion_file_err();\n\n        goto fail;\n\n    }\n\n\n\n    migrate_set_state(&s->state, current_active_state,\n\n                      MIGRATION_STATUS_COMPLETED);\n\n    return;\n\n\n\nfail:\n\n    migrate_set_state(&s->state, current_active_state,\n\n                      MIGRATION_STATUS_FAILED);\n\n}\n", "idx": 23479}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "static int qemu_event_init(void)\n\n{\n\n    int err;\n\n    int fds[2];\n\n\n\n    err = pipe(fds);\n\n    if (err == -1)\n\n        return -errno;\n\n\n\n    err = fcntl_setfl(fds[0], O_NONBLOCK);\n\n    if (err < 0)\n\n        goto fail;\n\n\n\n    err = fcntl_setfl(fds[1], O_NONBLOCK);\n\n    if (err < 0)\n\n        goto fail;\n\n\n\n    qemu_set_fd_handler2(fds[0], NULL, qemu_event_read, NULL,\n\n                         (void *)(unsigned long)fds[0]);\n\n\n\n    io_thread_fd = fds[1];\n\n    return 0;\n\n\n\nfail:\n\n    close(fds[0]);\n\n    close(fds[1]);\n\n    return err;\n\n}\n", "idx": 23481}
{"project": "qemu", "commit_id": "08844473820c93541fc47bdfeae0f2cc88cfab59", "target": 0, "func": "void bdrv_setup_io_funcs(BlockDriver *bdrv)\n\n{\n\n    /* Block drivers without coroutine functions need emulation */\n\n    if (!bdrv->bdrv_co_readv) {\n\n        bdrv->bdrv_co_readv = bdrv_co_readv_em;\n\n        bdrv->bdrv_co_writev = bdrv_co_writev_em;\n\n\n\n        /* bdrv_co_readv_em()/brdv_co_writev_em() work in terms of aio, so if\n\n         * the block driver lacks aio we need to emulate that too.\n\n         */\n\n        if (!bdrv->bdrv_aio_readv) {\n\n            /* add AIO emulation layer */\n\n            bdrv->bdrv_aio_readv = bdrv_aio_readv_em;\n\n            bdrv->bdrv_aio_writev = bdrv_aio_writev_em;\n\n        }\n\n    }\n\n}\n", "idx": 23483}
{"project": "qemu", "commit_id": "7ec1e5ea4bd0700fa48da86bffa2fcc6146c410a", "target": 0, "func": "static void gen_casx_asi(DisasContext *dc, TCGv addr, TCGv val2,\n\n                         int insn, int rd)\n\n{\n\n    TCGv val1 = gen_load_gpr(dc, rd);\n\n    TCGv dst = gen_dest_gpr(dc, rd);\n\n    TCGv_i32 r_asi = gen_get_asi(dc, insn);\n\n\n\n    gen_helper_casx_asi(dst, cpu_env, addr, val1, val2, r_asi);\n\n    tcg_temp_free_i32(r_asi);\n\n    gen_store_gpr(dc, rd, dst);\n\n}\n", "idx": 23484}
{"project": "qemu", "commit_id": "f61eddcb2bb5cbbdd1d911b7e937db9affc29028", "target": 0, "func": "static void bt_vhci_add(int vlan_id)\n\n{\n\n    struct bt_scatternet_s *vlan = qemu_find_bt_vlan(vlan_id);\n\n\n\n    if (!vlan->slave)\n\n        fprintf(stderr, \"qemu: warning: adding a VHCI to \"\n\n                        \"an empty scatternet %i\\n\", vlan_id);\n\n\n\n    bt_vhci_init(bt_new_hci(vlan));\n\n}\n", "idx": 23485}
{"project": "qemu", "commit_id": "6a2acedb19221ddf5e6fd3fb3590ba636aa21007", "target": 0, "func": "e1000_autoneg_timer(void *opaque)\n\n{\n\n    E1000State *s = opaque;\n\n    if (!qemu_get_queue(s->nic)->link_down) {\n\n        e1000_link_up(s);\n\n    }\n\n    s->phy_reg[PHY_STATUS] |= MII_SR_AUTONEG_COMPLETE;\n\n    DBGOUT(PHY, \"Auto negotiation is completed\\n\");\n\n}\n", "idx": 23486}
{"project": "qemu", "commit_id": "6205086558955402983f1c2ff9e4c3ebe9f1c678", "target": 0, "func": "void cpu_loop(CPUCRISState *env)\n\n{\n\n    CPUState *cs = CPU(cris_env_get_cpu(env));\n\n    int trapnr, ret;\n\n    target_siginfo_t info;\n\n    \n\n    while (1) {\n\n        cpu_exec_start(cs);\n\n        trapnr = cpu_cris_exec(cs);\n\n        cpu_exec_end(cs);\n\n        switch (trapnr) {\n\n        case 0xaa:\n\n            {\n\n                info.si_signo = TARGET_SIGSEGV;\n\n                info.si_errno = 0;\n\n                /* XXX: check env->error_code */\n\n                info.si_code = TARGET_SEGV_MAPERR;\n\n                info._sifields._sigfault._addr = env->pregs[PR_EDA];\n\n                queue_signal(env, info.si_signo, &info);\n\n            }\n\n            break;\n\n\tcase EXCP_INTERRUPT:\n\n\t  /* just indicate that signals should be handled asap */\n\n\t  break;\n\n        case EXCP_BREAK:\n\n            ret = do_syscall(env, \n\n                             env->regs[9], \n\n                             env->regs[10], \n\n                             env->regs[11], \n\n                             env->regs[12], \n\n                             env->regs[13], \n\n                             env->pregs[7], \n\n                             env->pregs[11],\n\n                             0, 0);\n\n            env->regs[10] = ret;\n\n            break;\n\n        case EXCP_DEBUG:\n\n            {\n\n                int sig;\n\n\n\n                sig = gdb_handlesig(cs, TARGET_SIGTRAP);\n\n                if (sig)\n\n                  {\n\n                    info.si_signo = sig;\n\n                    info.si_errno = 0;\n\n                    info.si_code = TARGET_TRAP_BRKPT;\n\n                    queue_signal(env, info.si_signo, &info);\n\n                  }\n\n            }\n\n            break;\n\n        default:\n\n            printf (\"Unhandled trap: 0x%x\\n\", trapnr);\n\n            cpu_dump_state(cs, stderr, fprintf, 0);\n\n            exit(EXIT_FAILURE);\n\n        }\n\n        process_pending_signals (env);\n\n    }\n\n}\n", "idx": 23489}
{"project": "qemu", "commit_id": "94ac5cd20c6e441e0ed3aec5c98d6cbefb7f503f", "target": 0, "func": "static void tlb_info_32(Monitor *mon, CPUState *env)\n\n{\n\n    int l1, l2;\n\n    uint32_t pgd, pde, pte;\n\n\n\n    pgd = env->cr[3] & ~0xfff;\n\n    for(l1 = 0; l1 < 1024; l1++) {\n\n        cpu_physical_memory_read(pgd + l1 * 4, &pde, 4);\n\n        pde = le32_to_cpu(pde);\n\n        if (pde & PG_PRESENT_MASK) {\n\n            if ((pde & PG_PSE_MASK) && (env->cr[4] & CR4_PSE_MASK)) {\n\n                /* 4M pages */\n\n                print_pte(mon, (l1 << 22), pde, ~((1 << 21) - 1));\n\n            } else {\n\n                for(l2 = 0; l2 < 1024; l2++) {\n\n                    cpu_physical_memory_read((pde & ~0xfff) + l2 * 4, &pte, 4);\n\n                    pte = le32_to_cpu(pte);\n\n                    if (pte & PG_PRESENT_MASK) {\n\n                        print_pte(mon, (l1 << 22) + (l2 << 12),\n\n                                  pte & ~PG_PSE_MASK,\n\n                                  ~0xfff);\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 23490}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "BlockDriverState *bdrv_next(BlockDriverState *bs)\n\n{\n\n    if (!bs) {\n\n        return QTAILQ_FIRST(&bdrv_states);\n\n    }\n\n    return QTAILQ_NEXT(bs, device_list);\n\n}\n", "idx": 23491}
{"project": "qemu", "commit_id": "9e19ad4e49c8dc7f776bf770f52ad6ea1ec28edc", "target": 0, "func": "void parse_option_size(const char *name, const char *value,\n\n                       uint64_t *ret, Error **errp)\n\n{\n\n    uint64_t size;\n\n    int err;\n\n\n\n    err = qemu_strtosz(value, NULL, &size);\n\n    if (err == -ERANGE) {\n\n        error_setg(errp, \"Value '%s' is too large for parameter '%s'\",\n\n                   value, name);\n\n        return;\n\n    }\n\n    if (err) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, name,\n\n                   \"a non-negative number below 2^64\");\n\n        error_append_hint(errp, \"Optional suffix k, M, G, T, P or E means\"\n\n                          \" kilo-, mega-, giga-, tera-, peta-\\n\"\n\n                          \"and exabytes, respectively.\\n\");\n\n        return;\n\n    }\n\n    *ret = size;\n\n}\n", "idx": 23492}
{"project": "qemu", "commit_id": "659f807c0a700317a7a0fae7a6e6ebfe68bfbbc4", "target": 0, "func": "static int get_physical_addr_mmu(CPUXtensaState *env, bool update_tlb,\n\n        uint32_t vaddr, int is_write, int mmu_idx,\n\n        uint32_t *paddr, uint32_t *page_size, unsigned *access,\n\n        bool may_lookup_pt)\n\n{\n\n    bool dtlb = is_write != 2;\n\n    uint32_t wi;\n\n    uint32_t ei;\n\n    uint8_t ring;\n\n    uint32_t vpn;\n\n    uint32_t pte;\n\n    const xtensa_tlb_entry *entry = NULL;\n\n    xtensa_tlb_entry tmp_entry;\n\n    int ret = xtensa_tlb_lookup(env, vaddr, dtlb, &wi, &ei, &ring);\n\n\n\n    if ((ret == INST_TLB_MISS_CAUSE || ret == LOAD_STORE_TLB_MISS_CAUSE) &&\n\n            may_lookup_pt && get_pte(env, vaddr, &pte) == 0) {\n\n        ring = (pte >> 4) & 0x3;\n\n        wi = 0;\n\n        split_tlb_entry_spec_way(env, vaddr, dtlb, &vpn, wi, &ei);\n\n\n\n        if (update_tlb) {\n\n            wi = ++env->autorefill_idx & 0x3;\n\n            xtensa_tlb_set_entry(env, dtlb, wi, ei, vpn, pte);\n\n            env->sregs[EXCVADDR] = vaddr;\n\n            qemu_log(\"%s: autorefill(%08x): %08x -> %08x\\n\",\n\n                    __func__, vaddr, vpn, pte);\n\n        } else {\n\n            xtensa_tlb_set_entry_mmu(env, &tmp_entry, dtlb, wi, ei, vpn, pte);\n\n            entry = &tmp_entry;\n\n        }\n\n        ret = 0;\n\n    }\n\n    if (ret != 0) {\n\n        return ret;\n\n    }\n\n\n\n    if (entry == NULL) {\n\n        entry = xtensa_tlb_get_entry(env, dtlb, wi, ei);\n\n    }\n\n\n\n    if (ring < mmu_idx) {\n\n        return dtlb ?\n\n            LOAD_STORE_PRIVILEGE_CAUSE :\n\n            INST_FETCH_PRIVILEGE_CAUSE;\n\n    }\n\n\n\n    *access = mmu_attr_to_access(entry->attr);\n\n    if (!is_access_granted(*access, is_write)) {\n\n        return dtlb ?\n\n            (is_write ?\n\n             STORE_PROHIBITED_CAUSE :\n\n             LOAD_PROHIBITED_CAUSE) :\n\n            INST_FETCH_PROHIBITED_CAUSE;\n\n    }\n\n\n\n    *paddr = entry->paddr | (vaddr & ~xtensa_tlb_get_addr_mask(env, dtlb, wi));\n\n    *page_size = ~xtensa_tlb_get_addr_mask(env, dtlb, wi) + 1;\n\n\n\n    return 0;\n\n}\n", "idx": 23493}
{"project": "qemu", "commit_id": "1ac6c07f4288b0a563310fad0cdabb3a47c85607", "target": 0, "func": "e1000e_intrmgr_delay_rx_causes(E1000ECore *core, uint32_t *causes)\n\n{\n\n    uint32_t delayable_causes;\n\n    uint32_t rdtr = core->mac[RDTR];\n\n    uint32_t radv = core->mac[RADV];\n\n    uint32_t raid = core->mac[RAID];\n\n\n\n    if (msix_enabled(core->owner)) {\n\n        return false;\n\n    }\n\n\n\n    delayable_causes = E1000_ICR_RXQ0 |\n\n                       E1000_ICR_RXQ1 |\n\n                       E1000_ICR_RXT0;\n\n\n\n    if (!(core->mac[RFCTL] & E1000_RFCTL_ACK_DIS)) {\n\n        delayable_causes |= E1000_ICR_ACK;\n\n    }\n\n\n\n    /* Clean up all causes that may be delayed */\n\n    core->delayed_causes |= *causes & delayable_causes;\n\n    *causes &= ~delayable_causes;\n\n\n\n    /* Check if delayed RX interrupts disabled by client\n\n       or if there are causes that cannot be delayed */\n\n    if ((rdtr == 0) || (causes != 0)) {\n\n        return false;\n\n    }\n\n\n\n    /* Check if delayed RX ACK interrupts disabled by client\n\n       and there is an ACK packet received */\n\n    if ((raid == 0) && (core->delayed_causes & E1000_ICR_ACK)) {\n\n        return false;\n\n    }\n\n\n\n    /* All causes delayed */\n\n    e1000e_intrmgr_rearm_timer(&core->rdtr);\n\n\n\n    if (!core->radv.running && (radv != 0)) {\n\n        e1000e_intrmgr_rearm_timer(&core->radv);\n\n    }\n\n\n\n    if (!core->raid.running && (core->delayed_causes & E1000_ICR_ACK)) {\n\n        e1000e_intrmgr_rearm_timer(&core->raid);\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 23494}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void mcf_uart_write(void *opaque, target_phys_addr_t addr,\n\n                    uint64_t val, unsigned size)\n\n{\n\n    mcf_uart_state *s = (mcf_uart_state *)opaque;\n\n    switch (addr & 0x3f) {\n\n    case 0x00:\n\n        s->mr[s->current_mr] = val;\n\n        s->current_mr = 1;\n\n        break;\n\n    case 0x04:\n\n        /* CSR is ignored.  */\n\n        break;\n\n    case 0x08: /* Command Register.  */\n\n        mcf_do_command(s, val);\n\n        break;\n\n    case 0x0c: /* Transmit Buffer.  */\n\n        s->sr &= ~MCF_UART_TxEMP;\n\n        s->tb = val;\n\n        mcf_uart_do_tx(s);\n\n        break;\n\n    case 0x10:\n\n        /* ACR is ignored.  */\n\n        break;\n\n    case 0x14:\n\n        s->imr = val;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n    mcf_uart_update(s);\n\n}\n", "idx": 23495}
{"project": "qemu", "commit_id": "f57ba05823b7c444133f0862077b45824a6a89b5", "target": 0, "func": "static int virtio_ccw_cb(SubchDev *sch, CCW1 ccw)\n\n{\n\n    int ret;\n\n    VirtioRevInfo revinfo;\n\n    uint8_t status;\n\n    VirtioFeatDesc features;\n\n    void *config;\n\n    hwaddr indicators;\n\n    VqConfigBlock vq_config;\n\n    VirtioCcwDevice *dev = sch->driver_data;\n\n    VirtIODevice *vdev = virtio_ccw_get_vdev(sch);\n\n    bool check_len;\n\n    int len;\n\n    hwaddr hw_len;\n\n    VirtioThinintInfo *thinint;\n\n\n\n    if (!dev) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    trace_virtio_ccw_interpret_ccw(sch->cssid, sch->ssid, sch->schid,\n\n                                   ccw.cmd_code);\n\n    check_len = !((ccw.flags & CCW_FLAG_SLI) && !(ccw.flags & CCW_FLAG_DC));\n\n\n\n    if (dev->force_revision_1 && dev->revision < 0 &&\n\n        ccw.cmd_code != CCW_CMD_SET_VIRTIO_REV) {\n\n        /*\n\n         * virtio-1 drivers must start with negotiating to a revision >= 1,\n\n         * so post a command reject for all other commands\n\n         */\n\n        return -ENOSYS;\n\n    }\n\n\n\n    /* Look at the command. */\n\n    switch (ccw.cmd_code) {\n\n    case CCW_CMD_SET_VQ:\n\n        ret = virtio_ccw_handle_set_vq(sch, ccw, check_len, dev->revision < 1);\n\n        break;\n\n    case CCW_CMD_VDEV_RESET:\n\n        virtio_ccw_reset_virtio(dev, vdev);\n\n        ret = 0;\n\n        break;\n\n    case CCW_CMD_READ_FEAT:\n\n        if (check_len) {\n\n            if (ccw.count != sizeof(features)) {\n\n                ret = -EINVAL;\n\n                break;\n\n            }\n\n        } else if (ccw.count < sizeof(features)) {\n\n            /* Can't execute command. */\n\n            ret = -EINVAL;\n\n            break;\n\n        }\n\n        if (!ccw.cda) {\n\n            ret = -EFAULT;\n\n        } else {\n\n            VirtioDeviceClass *vdc = VIRTIO_DEVICE_GET_CLASS(vdev);\n\n\n\n            features.index = address_space_ldub(&address_space_memory,\n\n                                                ccw.cda\n\n                                                + sizeof(features.features),\n\n                                                MEMTXATTRS_UNSPECIFIED,\n\n                                                NULL);\n\n            if (features.index == 0) {\n\n                if (dev->revision >= 1) {\n\n                    /* Don't offer legacy features for modern devices. */\n\n                    features.features = (uint32_t)\n\n                        (vdev->host_features & ~vdc->legacy_features);\n\n                } else {\n\n                    features.features = (uint32_t)vdev->host_features;\n\n                }\n\n            } else if ((features.index == 1) && (dev->revision >= 1)) {\n\n                /*\n\n                 * Only offer feature bits beyond 31 if the guest has\n\n                 * negotiated at least revision 1.\n\n                 */\n\n                features.features = (uint32_t)(vdev->host_features >> 32);\n\n            } else {\n\n                /* Return zeroes if the guest supports more feature bits. */\n\n                features.features = 0;\n\n            }\n\n            address_space_stl_le(&address_space_memory, ccw.cda,\n\n                                 features.features, MEMTXATTRS_UNSPECIFIED,\n\n                                 NULL);\n\n            sch->curr_status.scsw.count = ccw.count - sizeof(features);\n\n            ret = 0;\n\n        }\n\n        break;\n\n    case CCW_CMD_WRITE_FEAT:\n\n        if (check_len) {\n\n            if (ccw.count != sizeof(features)) {\n\n                ret = -EINVAL;\n\n                break;\n\n            }\n\n        } else if (ccw.count < sizeof(features)) {\n\n            /* Can't execute command. */\n\n            ret = -EINVAL;\n\n            break;\n\n        }\n\n        if (!ccw.cda) {\n\n            ret = -EFAULT;\n\n        } else {\n\n            features.index = address_space_ldub(&address_space_memory,\n\n                                                ccw.cda\n\n                                                + sizeof(features.features),\n\n                                                MEMTXATTRS_UNSPECIFIED,\n\n                                                NULL);\n\n            features.features = address_space_ldl_le(&address_space_memory,\n\n                                                     ccw.cda,\n\n                                                     MEMTXATTRS_UNSPECIFIED,\n\n                                                     NULL);\n\n            if (features.index == 0) {\n\n                virtio_set_features(vdev,\n\n                                    (vdev->guest_features & 0xffffffff00000000ULL) |\n\n                                    features.features);\n\n            } else if ((features.index == 1) && (dev->revision >= 1)) {\n\n                /*\n\n                 * If the guest did not negotiate at least revision 1,\n\n                 * we did not offer it any feature bits beyond 31. Such a\n\n                 * guest passing us any bit here is therefore buggy.\n\n                 */\n\n                virtio_set_features(vdev,\n\n                                    (vdev->guest_features & 0x00000000ffffffffULL) |\n\n                                    ((uint64_t)features.features << 32));\n\n            } else {\n\n                /*\n\n                 * If the guest supports more feature bits, assert that it\n\n                 * passes us zeroes for those we don't support.\n\n                 */\n\n                if (features.features) {\n\n                    fprintf(stderr, \"Guest bug: features[%i]=%x (expected 0)\\n\",\n\n                            features.index, features.features);\n\n                    /* XXX: do a unit check here? */\n\n                }\n\n            }\n\n            sch->curr_status.scsw.count = ccw.count - sizeof(features);\n\n            ret = 0;\n\n        }\n\n        break;\n\n    case CCW_CMD_READ_CONF:\n\n        if (check_len) {\n\n            if (ccw.count > vdev->config_len) {\n\n                ret = -EINVAL;\n\n                break;\n\n            }\n\n        }\n\n        len = MIN(ccw.count, vdev->config_len);\n\n        if (!ccw.cda) {\n\n            ret = -EFAULT;\n\n        } else {\n\n            virtio_bus_get_vdev_config(&dev->bus, vdev->config);\n\n            cpu_physical_memory_write(ccw.cda, vdev->config, len);\n\n            sch->curr_status.scsw.count = ccw.count - len;\n\n            ret = 0;\n\n        }\n\n        break;\n\n    case CCW_CMD_WRITE_CONF:\n\n        if (check_len) {\n\n            if (ccw.count > vdev->config_len) {\n\n                ret = -EINVAL;\n\n                break;\n\n            }\n\n        }\n\n        len = MIN(ccw.count, vdev->config_len);\n\n        hw_len = len;\n\n        if (!ccw.cda) {\n\n            ret = -EFAULT;\n\n        } else {\n\n            config = cpu_physical_memory_map(ccw.cda, &hw_len, 0);\n\n            if (!config) {\n\n                ret = -EFAULT;\n\n            } else {\n\n                len = hw_len;\n\n                memcpy(vdev->config, config, len);\n\n                cpu_physical_memory_unmap(config, hw_len, 0, hw_len);\n\n                virtio_bus_set_vdev_config(&dev->bus, vdev->config);\n\n                sch->curr_status.scsw.count = ccw.count - len;\n\n                ret = 0;\n\n            }\n\n        }\n\n        break;\n\n    case CCW_CMD_READ_STATUS:\n\n        if (check_len) {\n\n            if (ccw.count != sizeof(status)) {\n\n                ret = -EINVAL;\n\n                break;\n\n            }\n\n        } else if (ccw.count < sizeof(status)) {\n\n            /* Can't execute command. */\n\n            ret = -EINVAL;\n\n            break;\n\n        }\n\n        if (!ccw.cda) {\n\n            ret = -EFAULT;\n\n        } else {\n\n            address_space_stb(&address_space_memory, ccw.cda, vdev->status,\n\n                                        MEMTXATTRS_UNSPECIFIED, NULL);\n\n            sch->curr_status.scsw.count = ccw.count - sizeof(vdev->status);;\n\n            ret = 0;\n\n        }\n\n        break;\n\n    case CCW_CMD_WRITE_STATUS:\n\n        if (check_len) {\n\n            if (ccw.count != sizeof(status)) {\n\n                ret = -EINVAL;\n\n                break;\n\n            }\n\n        } else if (ccw.count < sizeof(status)) {\n\n            /* Can't execute command. */\n\n            ret = -EINVAL;\n\n            break;\n\n        }\n\n        if (!ccw.cda) {\n\n            ret = -EFAULT;\n\n        } else {\n\n            status = address_space_ldub(&address_space_memory, ccw.cda,\n\n                                        MEMTXATTRS_UNSPECIFIED, NULL);\n\n            if (!(status & VIRTIO_CONFIG_S_DRIVER_OK)) {\n\n                virtio_ccw_stop_ioeventfd(dev);\n\n            }\n\n            if (virtio_set_status(vdev, status) == 0) {\n\n                if (vdev->status == 0) {\n\n                    virtio_ccw_reset_virtio(dev, vdev);\n\n                }\n\n                if (status & VIRTIO_CONFIG_S_DRIVER_OK) {\n\n                    virtio_ccw_start_ioeventfd(dev);\n\n                }\n\n                sch->curr_status.scsw.count = ccw.count - sizeof(status);\n\n                ret = 0;\n\n            } else {\n\n                /* Trigger a command reject. */\n\n                ret = -ENOSYS;\n\n            }\n\n        }\n\n        break;\n\n    case CCW_CMD_SET_IND:\n\n        if (check_len) {\n\n            if (ccw.count != sizeof(indicators)) {\n\n                ret = -EINVAL;\n\n                break;\n\n            }\n\n        } else if (ccw.count < sizeof(indicators)) {\n\n            /* Can't execute command. */\n\n            ret = -EINVAL;\n\n            break;\n\n        }\n\n        if (sch->thinint_active) {\n\n            /* Trigger a command reject. */\n\n            ret = -ENOSYS;\n\n            break;\n\n        }\n\n        if (virtio_get_num_queues(vdev) > NR_CLASSIC_INDICATOR_BITS) {\n\n            /* More queues than indicator bits --> trigger a reject */\n\n            ret = -ENOSYS;\n\n            break;\n\n        }\n\n        if (!ccw.cda) {\n\n            ret = -EFAULT;\n\n        } else {\n\n            indicators = address_space_ldq_be(&address_space_memory, ccw.cda,\n\n                                              MEMTXATTRS_UNSPECIFIED, NULL);\n\n            dev->indicators = get_indicator(indicators, sizeof(uint64_t));\n\n            sch->curr_status.scsw.count = ccw.count - sizeof(indicators);\n\n            ret = 0;\n\n        }\n\n        break;\n\n    case CCW_CMD_SET_CONF_IND:\n\n        if (check_len) {\n\n            if (ccw.count != sizeof(indicators)) {\n\n                ret = -EINVAL;\n\n                break;\n\n            }\n\n        } else if (ccw.count < sizeof(indicators)) {\n\n            /* Can't execute command. */\n\n            ret = -EINVAL;\n\n            break;\n\n        }\n\n        if (!ccw.cda) {\n\n            ret = -EFAULT;\n\n        } else {\n\n            indicators = address_space_ldq_be(&address_space_memory, ccw.cda,\n\n                                              MEMTXATTRS_UNSPECIFIED, NULL);\n\n            dev->indicators2 = get_indicator(indicators, sizeof(uint64_t));\n\n            sch->curr_status.scsw.count = ccw.count - sizeof(indicators);\n\n            ret = 0;\n\n        }\n\n        break;\n\n    case CCW_CMD_READ_VQ_CONF:\n\n        if (check_len) {\n\n            if (ccw.count != sizeof(vq_config)) {\n\n                ret = -EINVAL;\n\n                break;\n\n            }\n\n        } else if (ccw.count < sizeof(vq_config)) {\n\n            /* Can't execute command. */\n\n            ret = -EINVAL;\n\n            break;\n\n        }\n\n        if (!ccw.cda) {\n\n            ret = -EFAULT;\n\n        } else {\n\n            vq_config.index = address_space_lduw_be(&address_space_memory,\n\n                                                    ccw.cda,\n\n                                                    MEMTXATTRS_UNSPECIFIED,\n\n                                                    NULL);\n\n            if (vq_config.index >= VIRTIO_QUEUE_MAX) {\n\n                ret = -EINVAL;\n\n                break;\n\n            }\n\n            vq_config.num_max = virtio_queue_get_num(vdev,\n\n                                                     vq_config.index);\n\n            address_space_stw_be(&address_space_memory,\n\n                                 ccw.cda + sizeof(vq_config.index),\n\n                                 vq_config.num_max,\n\n                                 MEMTXATTRS_UNSPECIFIED,\n\n                                 NULL);\n\n            sch->curr_status.scsw.count = ccw.count - sizeof(vq_config);\n\n            ret = 0;\n\n        }\n\n        break;\n\n    case CCW_CMD_SET_IND_ADAPTER:\n\n        if (check_len) {\n\n            if (ccw.count != sizeof(*thinint)) {\n\n                ret = -EINVAL;\n\n                break;\n\n            }\n\n        } else if (ccw.count < sizeof(*thinint)) {\n\n            /* Can't execute command. */\n\n            ret = -EINVAL;\n\n            break;\n\n        }\n\n        len = sizeof(*thinint);\n\n        hw_len = len;\n\n        if (!ccw.cda) {\n\n            ret = -EFAULT;\n\n        } else if (dev->indicators && !sch->thinint_active) {\n\n            /* Trigger a command reject. */\n\n            ret = -ENOSYS;\n\n        } else {\n\n            thinint = cpu_physical_memory_map(ccw.cda, &hw_len, 0);\n\n            if (!thinint) {\n\n                ret = -EFAULT;\n\n            } else {\n\n                uint64_t ind_bit = ldq_be_p(&thinint->ind_bit);\n\n\n\n                len = hw_len;\n\n                dev->summary_indicator =\n\n                    get_indicator(ldq_be_p(&thinint->summary_indicator),\n\n                                  sizeof(uint8_t));\n\n                dev->indicators =\n\n                    get_indicator(ldq_be_p(&thinint->device_indicator),\n\n                                  ind_bit / 8 + 1);\n\n                dev->thinint_isc = thinint->isc;\n\n                dev->routes.adapter.ind_offset = ind_bit;\n\n                dev->routes.adapter.summary_offset = 7;\n\n                cpu_physical_memory_unmap(thinint, hw_len, 0, hw_len);\n\n                dev->routes.adapter.adapter_id = css_get_adapter_id(\n\n                                                 CSS_IO_ADAPTER_VIRTIO,\n\n                                                 dev->thinint_isc);\n\n                sch->thinint_active = ((dev->indicators != NULL) &&\n\n                                       (dev->summary_indicator != NULL));\n\n                sch->curr_status.scsw.count = ccw.count - len;\n\n                ret = 0;\n\n            }\n\n        }\n\n        break;\n\n    case CCW_CMD_SET_VIRTIO_REV:\n\n        len = sizeof(revinfo);\n\n        if (ccw.count < len) {\n\n            ret = -EINVAL;\n\n            break;\n\n        }\n\n        if (!ccw.cda) {\n\n            ret = -EFAULT;\n\n            break;\n\n        }\n\n        revinfo.revision =\n\n            address_space_lduw_be(&address_space_memory, ccw.cda,\n\n                                  MEMTXATTRS_UNSPECIFIED, NULL);\n\n        revinfo.length =\n\n            address_space_lduw_be(&address_space_memory,\n\n                                  ccw.cda + sizeof(revinfo.revision),\n\n                                  MEMTXATTRS_UNSPECIFIED, NULL);\n\n        if (ccw.count < len + revinfo.length ||\n\n            (check_len && ccw.count > len + revinfo.length)) {\n\n            ret = -EINVAL;\n\n            break;\n\n        }\n\n        /*\n\n         * Once we start to support revisions with additional data, we'll\n\n         * need to fetch it here. Nothing to do for now, though.\n\n         */\n\n        if (dev->revision >= 0 ||\n\n            revinfo.revision > virtio_ccw_rev_max(dev) ||\n\n            (dev->force_revision_1 && !revinfo.revision)) {\n\n            ret = -ENOSYS;\n\n            break;\n\n        }\n\n        ret = 0;\n\n        dev->revision = revinfo.revision;\n\n        break;\n\n    default:\n\n        ret = -ENOSYS;\n\n        break;\n\n    }\n\n    return ret;\n\n}\n", "idx": 23496}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "AioContext *aio_context_new(Error **errp)\n\n{\n\n    int ret;\n\n    AioContext *ctx;\n\n\n\n    ctx = (AioContext *) g_source_new(&aio_source_funcs, sizeof(AioContext));\n\n    aio_context_setup(ctx);\n\n\n\n    ret = event_notifier_init(&ctx->notifier, false);\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"Failed to initialize event notifier\");\n\n        goto fail;\n\n    }\n\n    g_source_set_can_recurse(&ctx->source, true);\n\n    qemu_lockcnt_init(&ctx->list_lock);\n\n    aio_set_event_notifier(ctx, &ctx->notifier,\n\n                           false,\n\n                           (EventNotifierHandler *)\n\n                           event_notifier_dummy_cb,\n\n                           event_notifier_poll);\n\n#ifdef CONFIG_LINUX_AIO\n\n    ctx->linux_aio = NULL;\n\n#endif\n\n    ctx->thread_pool = NULL;\n\n    qemu_rec_mutex_init(&ctx->lock);\n\n    timerlistgroup_init(&ctx->tlg, aio_timerlist_notify, ctx);\n\n\n\n    ctx->poll_ns = 0;\n\n    ctx->poll_max_ns = 0;\n\n    ctx->poll_grow = 0;\n\n    ctx->poll_shrink = 0;\n\n\n\n    return ctx;\n\nfail:\n\n    g_source_destroy(&ctx->source);\n\n    return NULL;\n\n}\n", "idx": 23497}
{"project": "qemu", "commit_id": "25c4d9cc845fb58f624dae8c0f690e20c70e7a1d", "target": 0, "func": "static TCGArg do_constant_folding_2(int op, TCGArg x, TCGArg y)\n\n{\n\n    switch (op) {\n\n    CASE_OP_32_64(add):\n\n        return x + y;\n\n\n\n    CASE_OP_32_64(sub):\n\n        return x - y;\n\n\n\n    CASE_OP_32_64(mul):\n\n        return x * y;\n\n\n\n    CASE_OP_32_64(and):\n\n        return x & y;\n\n\n\n    CASE_OP_32_64(or):\n\n        return x | y;\n\n\n\n    CASE_OP_32_64(xor):\n\n        return x ^ y;\n\n\n\n    case INDEX_op_shl_i32:\n\n        return (uint32_t)x << (uint32_t)y;\n\n\n\n#if TCG_TARGET_REG_BITS == 64\n\n    case INDEX_op_shl_i64:\n\n        return (uint64_t)x << (uint64_t)y;\n\n#endif\n\n\n\n    case INDEX_op_shr_i32:\n\n        return (uint32_t)x >> (uint32_t)y;\n\n\n\n#if TCG_TARGET_REG_BITS == 64\n\n    case INDEX_op_shr_i64:\n\n        return (uint64_t)x >> (uint64_t)y;\n\n#endif\n\n\n\n    case INDEX_op_sar_i32:\n\n        return (int32_t)x >> (int32_t)y;\n\n\n\n#if TCG_TARGET_REG_BITS == 64\n\n    case INDEX_op_sar_i64:\n\n        return (int64_t)x >> (int64_t)y;\n\n#endif\n\n\n\n#ifdef TCG_TARGET_HAS_rot_i32\n\n    case INDEX_op_rotr_i32:\n\n#if TCG_TARGET_REG_BITS == 64\n\n        x &= 0xffffffff;\n\n        y &= 0xffffffff;\n\n#endif\n\n        x = (x << (32 - y)) | (x >> y);\n\n        return x;\n\n#endif\n\n\n\n#ifdef TCG_TARGET_HAS_rot_i64\n\n#if TCG_TARGET_REG_BITS == 64\n\n    case INDEX_op_rotr_i64:\n\n        x = (x << (64 - y)) | (x >> y);\n\n        return x;\n\n#endif\n\n#endif\n\n\n\n#ifdef TCG_TARGET_HAS_rot_i32\n\n    case INDEX_op_rotl_i32:\n\n#if TCG_TARGET_REG_BITS == 64\n\n        x &= 0xffffffff;\n\n        y &= 0xffffffff;\n\n#endif\n\n        x = (x << y) | (x >> (32 - y));\n\n        return x;\n\n#endif\n\n\n\n#ifdef TCG_TARGET_HAS_rot_i64\n\n#if TCG_TARGET_REG_BITS == 64\n\n    case INDEX_op_rotl_i64:\n\n        x = (x << y) | (x >> (64 - y));\n\n        return x;\n\n#endif\n\n#endif\n\n\n\n#if defined(TCG_TARGET_HAS_not_i32) || defined(TCG_TARGET_HAS_not_i64)\n\n#ifdef TCG_TARGET_HAS_not_i32\n\n    case INDEX_op_not_i32:\n\n#endif\n\n#ifdef TCG_TARGET_HAS_not_i64\n\n    case INDEX_op_not_i64:\n\n#endif\n\n        return ~x;\n\n#endif\n\n\n\n#if defined(TCG_TARGET_HAS_ext8s_i32) || defined(TCG_TARGET_HAS_ext8s_i64)\n\n#ifdef TCG_TARGET_HAS_ext8s_i32\n\n    case INDEX_op_ext8s_i32:\n\n#endif\n\n#ifdef TCG_TARGET_HAS_ext8s_i64\n\n    case INDEX_op_ext8s_i64:\n\n#endif\n\n        return (int8_t)x;\n\n#endif\n\n\n\n#if defined(TCG_TARGET_HAS_ext16s_i32) || defined(TCG_TARGET_HAS_ext16s_i64)\n\n#ifdef TCG_TARGET_HAS_ext16s_i32\n\n    case INDEX_op_ext16s_i32:\n\n#endif\n\n#ifdef TCG_TARGET_HAS_ext16s_i64\n\n    case INDEX_op_ext16s_i64:\n\n#endif\n\n        return (int16_t)x;\n\n#endif\n\n\n\n#if defined(TCG_TARGET_HAS_ext8u_i32) || defined(TCG_TARGET_HAS_ext8u_i64)\n\n#ifdef TCG_TARGET_HAS_ext8u_i32\n\n    case INDEX_op_ext8u_i32:\n\n#endif\n\n#ifdef TCG_TARGET_HAS_ext8u_i64\n\n    case INDEX_op_ext8u_i64:\n\n#endif\n\n        return (uint8_t)x;\n\n#endif\n\n\n\n#if defined(TCG_TARGET_HAS_ext16u_i32) || defined(TCG_TARGET_HAS_ext16u_i64)\n\n#ifdef TCG_TARGET_HAS_ext16u_i32\n\n    case INDEX_op_ext16u_i32:\n\n#endif\n\n#ifdef TCG_TARGET_HAS_ext16u_i64\n\n    case INDEX_op_ext16u_i64:\n\n#endif\n\n        return (uint16_t)x;\n\n#endif\n\n\n\n#if TCG_TARGET_REG_BITS == 64\n\n#ifdef TCG_TARGET_HAS_ext32s_i64\n\n    case INDEX_op_ext32s_i64:\n\n        return (int32_t)x;\n\n#endif\n\n\n\n#ifdef TCG_TARGET_HAS_ext32u_i64\n\n    case INDEX_op_ext32u_i64:\n\n        return (uint32_t)x;\n\n#endif\n\n#endif\n\n\n\n    default:\n\n        fprintf(stderr,\n\n                \"Unrecognized operation %d in do_constant_folding.\\n\", op);\n\n        tcg_abort();\n\n    }\n\n}\n", "idx": 23498}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "func": "static int mp_user_setxattr(FsContext *ctx, const char *path, const char *name,\n\n                            void *value, size_t size, int flags)\n\n{\n\n    char buffer[PATH_MAX];\n\n    if (strncmp(name, \"user.virtfs.\", 12) == 0) {\n\n        /*\n\n         * Don't allow fetch of user.virtfs namesapce\n\n         * in case of mapped security\n\n         */\n\n        errno = EACCES;\n\n        return -1;\n\n    }\n\n    return lsetxattr(rpath(ctx, path, buffer), name, value, size, flags);\n\n}\n", "idx": 23500}
{"project": "qemu", "commit_id": "e0dfe5b18919a6a4deb841dcf3212e3e998c95e5", "target": 0, "func": "static int openpic_init(SysBusDevice *dev)\n\n{\n\n    OpenPICState *opp = FROM_SYSBUS(typeof (*opp), dev);\n\n    int i, j;\n\n    MemReg list_le[] = {\n\n        {\"glb\", &openpic_glb_ops_le, true,\n\n                OPENPIC_GLB_REG_START, OPENPIC_GLB_REG_SIZE},\n\n        {\"tmr\", &openpic_tmr_ops_le, true,\n\n                OPENPIC_TMR_REG_START, OPENPIC_TMR_REG_SIZE},\n\n        {\"msi\", &openpic_msi_ops_le, true,\n\n                OPENPIC_MSI_REG_START, OPENPIC_MSI_REG_SIZE},\n\n        {\"src\", &openpic_src_ops_le, true,\n\n                OPENPIC_SRC_REG_START, OPENPIC_SRC_REG_SIZE},\n\n        {\"cpu\", &openpic_cpu_ops_le, true,\n\n                OPENPIC_CPU_REG_START, OPENPIC_CPU_REG_SIZE},\n\n    };\n\n    MemReg list_be[] = {\n\n        {\"glb\", &openpic_glb_ops_be, true,\n\n                OPENPIC_GLB_REG_START, OPENPIC_GLB_REG_SIZE},\n\n        {\"tmr\", &openpic_tmr_ops_be, true,\n\n                OPENPIC_TMR_REG_START, OPENPIC_TMR_REG_SIZE},\n\n        {\"msi\", &openpic_msi_ops_be, true,\n\n                OPENPIC_MSI_REG_START, OPENPIC_MSI_REG_SIZE},\n\n        {\"src\", &openpic_src_ops_be, true,\n\n                OPENPIC_SRC_REG_START, OPENPIC_SRC_REG_SIZE},\n\n        {\"cpu\", &openpic_cpu_ops_be, true,\n\n                OPENPIC_CPU_REG_START, OPENPIC_CPU_REG_SIZE},\n\n    };\n\n    MemReg *list;\n\n\n\n    switch (opp->model) {\n\n    case OPENPIC_MODEL_FSL_MPIC_20:\n\n    default:\n\n        opp->flags |= OPENPIC_FLAG_IDR_CRIT;\n\n        opp->nb_irqs = 80;\n\n        opp->vid = VID_REVISION_1_2;\n\n        opp->vir = VIR_GENERIC;\n\n        opp->vector_mask = 0xFFFF;\n\n        opp->tfrr_reset = 0;\n\n        opp->ivpr_reset = IVPR_MASK_MASK;\n\n        opp->idr_reset = 1 << 0;\n\n        opp->max_irq = FSL_MPIC_20_MAX_IRQ;\n\n        opp->irq_ipi0 = FSL_MPIC_20_IPI_IRQ;\n\n        opp->irq_tim0 = FSL_MPIC_20_TMR_IRQ;\n\n        opp->irq_msi = FSL_MPIC_20_MSI_IRQ;\n\n        opp->brr1 = FSL_BRR1_IPID | FSL_BRR1_IPMJ | FSL_BRR1_IPMN;\n\n        /* XXX really only available as of MPIC 4.0 */\n\n        opp->mpic_mode_mask = GCR_MODE_PROXY;\n\n\n\n        msi_supported = true;\n\n        list = list_be;\n\n\n\n        for (i = 0; i < FSL_MPIC_20_MAX_EXT; i++) {\n\n            opp->src[i].level = false;\n\n        }\n\n\n\n        /* Internal interrupts, including message and MSI */\n\n        for (i = 16; i < MAX_SRC; i++) {\n\n            opp->src[i].type = IRQ_TYPE_FSLINT;\n\n            opp->src[i].level = true;\n\n        }\n\n\n\n        /* timers and IPIs */\n\n        for (i = MAX_SRC; i < MAX_IRQ; i++) {\n\n            opp->src[i].type = IRQ_TYPE_FSLSPECIAL;\n\n            opp->src[i].level = false;\n\n        }\n\n\n\n        break;\n\n\n\n    case OPENPIC_MODEL_RAVEN:\n\n        opp->nb_irqs = RAVEN_MAX_EXT;\n\n        opp->vid = VID_REVISION_1_3;\n\n        opp->vir = VIR_GENERIC;\n\n        opp->vector_mask = 0xFF;\n\n        opp->tfrr_reset = 4160000;\n\n        opp->ivpr_reset = IVPR_MASK_MASK | IVPR_MODE_MASK;\n\n        opp->idr_reset = 0;\n\n        opp->max_irq = RAVEN_MAX_IRQ;\n\n        opp->irq_ipi0 = RAVEN_IPI_IRQ;\n\n        opp->irq_tim0 = RAVEN_TMR_IRQ;\n\n        opp->brr1 = -1;\n\n        opp->mpic_mode_mask = GCR_MODE_MIXED;\n\n        list = list_le;\n\n        /* Don't map MSI region */\n\n        list[2].map = false;\n\n\n\n        /* Only UP supported today */\n\n        if (opp->nb_cpus != 1) {\n\n            return -EINVAL;\n\n        }\n\n        break;\n\n    }\n\n\n\n    memory_region_init(&opp->mem, \"openpic\", 0x40000);\n\n\n\n    for (i = 0; i < ARRAY_SIZE(list_le); i++) {\n\n        if (!list[i].map) {\n\n            continue;\n\n        }\n\n\n\n        memory_region_init_io(&opp->sub_io_mem[i], list[i].ops, opp,\n\n                              list[i].name, list[i].size);\n\n\n\n        memory_region_add_subregion(&opp->mem, list[i].start_addr,\n\n                                    &opp->sub_io_mem[i]);\n\n    }\n\n\n\n    for (i = 0; i < opp->nb_cpus; i++) {\n\n        opp->dst[i].irqs = g_new(qemu_irq, OPENPIC_OUTPUT_NB);\n\n        for (j = 0; j < OPENPIC_OUTPUT_NB; j++) {\n\n            sysbus_init_irq(dev, &opp->dst[i].irqs[j]);\n\n        }\n\n    }\n\n\n\n    register_savevm(&opp->busdev.qdev, \"openpic\", 0, 2,\n\n                    openpic_save, openpic_load, opp);\n\n\n\n    sysbus_init_mmio(dev, &opp->mem);\n\n    qdev_init_gpio_in(&dev->qdev, openpic_set_irq, opp->max_irq);\n\n\n\n    return 0;\n\n}\n", "idx": 23501}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "static void do_info_profile(Monitor *mon)\n\n{\n\n    int64_t total;\n\n    total = qemu_time;\n\n    if (total == 0)\n\n        total = 1;\n\n    monitor_printf(mon, \"async time  %\" PRId64 \" (%0.3f)\\n\",\n\n                   dev_time, dev_time / (double)ticks_per_sec);\n\n    monitor_printf(mon, \"qemu time   %\" PRId64 \" (%0.3f)\\n\",\n\n                   qemu_time, qemu_time / (double)ticks_per_sec);\n\n    monitor_printf(mon, \"kqemu time  %\" PRId64 \" (%0.3f %0.1f%%) count=%\"\n\n                        PRId64 \" int=%\" PRId64 \" excp=%\" PRId64 \" intr=%\"\n\n                        PRId64 \"\\n\",\n\n                   kqemu_time, kqemu_time / (double)ticks_per_sec,\n\n                   kqemu_time / (double)total * 100.0,\n\n                   kqemu_exec_count,\n\n                   kqemu_ret_int_count,\n\n                   kqemu_ret_excp_count,\n\n                   kqemu_ret_intr_count);\n\n    qemu_time = 0;\n\n    kqemu_time = 0;\n\n    kqemu_exec_count = 0;\n\n    dev_time = 0;\n\n    kqemu_ret_int_count = 0;\n\n    kqemu_ret_excp_count = 0;\n\n    kqemu_ret_intr_count = 0;\n\n#ifdef CONFIG_KQEMU\n\n    kqemu_record_dump();\n\n#endif\n\n}\n", "idx": 23502}
{"project": "qemu", "commit_id": "4ffdb337e74f9a4dae97ea0396d4e1a3dbb13723", "target": 0, "func": "void qemu_savevm_state_header(QEMUFile *f)\n\n{\n\n    trace_savevm_state_header();\n\n    qemu_put_be32(f, QEMU_VM_FILE_MAGIC);\n\n    qemu_put_be32(f, QEMU_VM_FILE_VERSION);\n\n\n\n    if (migrate_get_current()->send_configuration ||\n\n        enforce_config_section()) {\n\n        qemu_put_byte(f, QEMU_VM_CONFIGURATION);\n\n        vmstate_save_state(f, &vmstate_configuration, &savevm_state, 0);\n\n    }\n\n}\n", "idx": 23503}
{"project": "qemu", "commit_id": "b16595275bc9b9ce6a36bfb0344d514ab77e6b98", "target": 0, "func": "MemTxAttrs kvm_arch_post_run(CPUState *cs, struct kvm_run *run)\n\n{\n\n    ARMCPU *cpu;\n\n    uint32_t switched_level;\n\n\n\n    if (kvm_irqchip_in_kernel()) {\n\n        /*\n\n         * We only need to sync timer states with user-space interrupt\n\n         * controllers, so return early and save cycles if we don't.\n\n         */\n\n        return MEMTXATTRS_UNSPECIFIED;\n\n    }\n\n\n\n    cpu = ARM_CPU(cs);\n\n\n\n    /* Synchronize our shadowed in-kernel device irq lines with the kvm ones */\n\n    if (run->s.regs.device_irq_level != cpu->device_irq_level) {\n\n        switched_level = cpu->device_irq_level ^ run->s.regs.device_irq_level;\n\n\n\n        qemu_mutex_lock_iothread();\n\n\n\n        if (switched_level & KVM_ARM_DEV_EL1_VTIMER) {\n\n            qemu_set_irq(cpu->gt_timer_outputs[GTIMER_VIRT],\n\n                         !!(run->s.regs.device_irq_level &\n\n                            KVM_ARM_DEV_EL1_VTIMER));\n\n            switched_level &= ~KVM_ARM_DEV_EL1_VTIMER;\n\n        }\n\n\n\n        if (switched_level & KVM_ARM_DEV_EL1_PTIMER) {\n\n            qemu_set_irq(cpu->gt_timer_outputs[GTIMER_PHYS],\n\n                         !!(run->s.regs.device_irq_level &\n\n                            KVM_ARM_DEV_EL1_PTIMER));\n\n            switched_level &= ~KVM_ARM_DEV_EL1_PTIMER;\n\n        }\n\n\n\n        /* XXX PMU IRQ is missing */\n\n\n\n        if (switched_level) {\n\n            qemu_log_mask(LOG_UNIMP, \"%s: unhandled in-kernel device IRQ %x\\n\",\n\n                          __func__, switched_level);\n\n        }\n\n\n\n        /* We also mark unknown levels as processed to not waste cycles */\n\n        cpu->device_irq_level = run->s.regs.device_irq_level;\n\n        qemu_mutex_unlock_iothread();\n\n    }\n\n\n\n    return MEMTXATTRS_UNSPECIFIED;\n\n}\n", "idx": 23504}
{"project": "qemu", "commit_id": "79853e18d904b0a4bcef62701d48559688007c93", "target": 0, "func": "static void rtas_event_log_queue(int log_type, void *data)\n\n{\n\n    sPAPREventLogEntry *entry = g_new(sPAPREventLogEntry, 1);\n\n\n\n    g_assert(data);\n\n    entry->log_type = log_type;\n\n    entry->data = data;\n\n    QTAILQ_INSERT_TAIL(&spapr->pending_events, entry, next);\n\n}\n", "idx": 23505}
{"project": "qemu", "commit_id": "aa8f057e74ae08014736a690ff41f76c756f75f1", "target": 0, "func": "static void virtio_crypto_initfn(Object *obj)\n\n{\n\n    VirtIOCryptoPCI *dev = VIRTIO_CRYPTO_PCI(obj);\n\n\n\n    virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),\n\n                                TYPE_VIRTIO_CRYPTO);\n\n    object_property_add_alias(obj, \"cryptodev\", OBJECT(&dev->vdev),\n\n                              \"cryptodev\", &error_abort);\n\n}\n", "idx": 23510}
{"project": "qemu", "commit_id": "e1f7b4812eab992de46c98b3726745afb042a7f0", "target": 0, "func": "size_t virtio_serial_guest_ready(VirtIOSerialPort *port)\n\n{\n\n    VirtQueue *vq = port->ivq;\n\n    unsigned int bytes;\n\n\n\n    if (!virtio_queue_ready(vq) ||\n\n        !(port->vser->vdev.status & VIRTIO_CONFIG_S_DRIVER_OK) ||\n\n        virtio_queue_empty(vq)) {\n\n        return 0;\n\n    }\n\n    if (use_multiport(port->vser) && !port->guest_connected) {\n\n        return 0;\n\n    }\n\n    virtqueue_get_avail_bytes(vq, &bytes, NULL);\n\n    return bytes;\n\n}\n", "idx": 23511}
{"project": "qemu", "commit_id": "bb593904c18e22ea0671dfa1b02e24982f2bf0ea", "target": 0, "func": "static void gen_spr_ne_601 (CPUPPCState *env)\n\n{\n\n    /* Exception processing */\n\n    spr_register(env, SPR_DSISR, \"DSISR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    spr_register(env, SPR_DAR, \"DAR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Timer */\n\n    spr_register(env, SPR_DECR, \"DECR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_decr, &spr_write_decr,\n\n                 0x00000000);\n\n    /* Memory management */\n\n    spr_register(env, SPR_SDR1, \"SDR1\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_sdr1, &spr_write_sdr1,\n\n                 0x00000000);\n\n}\n", "idx": 23512}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void grlib_irqmp_write(void *opaque, target_phys_addr_t addr,\n\n                              uint64_t value, unsigned size)\n\n{\n\n    IRQMP      *irqmp = opaque;\n\n    IRQMPState *state;\n\n\n\n    assert(irqmp != NULL);\n\n    state = irqmp->state;\n\n    assert(state != NULL);\n\n\n\n    addr &= 0xff;\n\n\n\n    /* global registers */\n\n    switch (addr) {\n\n    case LEVEL_OFFSET:\n\n        value &= 0xFFFF << 1; /* clean up the value */\n\n        state->level = value;\n\n        return;\n\n\n\n    case PENDING_OFFSET:\n\n        /* Read Only */\n\n        return;\n\n\n\n    case FORCE0_OFFSET:\n\n        /* This register is an \"alias\" for the force register of CPU 0 */\n\n\n\n        value &= 0xFFFE; /* clean up the value */\n\n        state->force[0] = value;\n\n        grlib_irqmp_check_irqs(irqmp->state);\n\n        return;\n\n\n\n    case CLEAR_OFFSET:\n\n        value &= ~1; /* clean up the value */\n\n        state->pending &= ~value;\n\n        return;\n\n\n\n    case MP_STATUS_OFFSET:\n\n        /* Read Only (no SMP support) */\n\n        return;\n\n\n\n    case BROADCAST_OFFSET:\n\n        value &= 0xFFFE; /* clean up the value */\n\n        state->broadcast = value;\n\n        return;\n\n\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* mask registers */\n\n    if (addr >= MASK_OFFSET && addr < FORCE_OFFSET) {\n\n        int cpu = (addr - MASK_OFFSET) / 4;\n\n        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);\n\n\n\n        value &= ~1; /* clean up the value */\n\n        state->mask[cpu] = value;\n\n        grlib_irqmp_check_irqs(irqmp->state);\n\n        return;\n\n    }\n\n\n\n    /* force registers */\n\n    if (addr >= FORCE_OFFSET && addr < EXTENDED_OFFSET) {\n\n        int cpu = (addr - FORCE_OFFSET) / 4;\n\n        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);\n\n\n\n        uint32_t force = value & 0xFFFE;\n\n        uint32_t clear = (value >> 16) & 0xFFFE;\n\n        uint32_t old   = state->force[cpu];\n\n\n\n        state->force[cpu] = (old | force) & ~clear;\n\n        grlib_irqmp_check_irqs(irqmp->state);\n\n        return;\n\n    }\n\n\n\n    /* extended (not supported) */\n\n    if (addr >= EXTENDED_OFFSET && addr < IRQMP_REG_SIZE) {\n\n        int cpu = (addr - EXTENDED_OFFSET) / 4;\n\n        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);\n\n\n\n        value &= 0xF; /* clean up the value */\n\n        state->extended[cpu] = value;\n\n        return;\n\n    }\n\n\n\n    trace_grlib_irqmp_writel_unknown(addr, value);\n\n}\n", "idx": 23513}
{"project": "qemu", "commit_id": "d3b5491897456739c6dc21c604ef8bc28e294bfc", "target": 0, "func": "static void tss_load_seg(CPUX86State *env, int seg_reg, int selector)\n\n{\n\n    uint32_t e1, e2;\n\n    int rpl, dpl, cpl;\n\n\n\n    if ((selector & 0xfffc) != 0) {\n\n        if (load_segment(env, &e1, &e2, selector) != 0) {\n\n            raise_exception_err(env, EXCP0A_TSS, selector & 0xfffc);\n\n        }\n\n        if (!(e2 & DESC_S_MASK)) {\n\n            raise_exception_err(env, EXCP0A_TSS, selector & 0xfffc);\n\n        }\n\n        rpl = selector & 3;\n\n        dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n        cpl = env->hflags & HF_CPL_MASK;\n\n        if (seg_reg == R_CS) {\n\n            if (!(e2 & DESC_CS_MASK)) {\n\n                raise_exception_err(env, EXCP0A_TSS, selector & 0xfffc);\n\n            }\n\n            /* XXX: is it correct? */\n\n            if (dpl != rpl) {\n\n                raise_exception_err(env, EXCP0A_TSS, selector & 0xfffc);\n\n            }\n\n            if ((e2 & DESC_C_MASK) && dpl > rpl) {\n\n                raise_exception_err(env, EXCP0A_TSS, selector & 0xfffc);\n\n            }\n\n        } else if (seg_reg == R_SS) {\n\n            /* SS must be writable data */\n\n            if ((e2 & DESC_CS_MASK) || !(e2 & DESC_W_MASK)) {\n\n                raise_exception_err(env, EXCP0A_TSS, selector & 0xfffc);\n\n            }\n\n            if (dpl != cpl || dpl != rpl) {\n\n                raise_exception_err(env, EXCP0A_TSS, selector & 0xfffc);\n\n            }\n\n        } else {\n\n            /* not readable code */\n\n            if ((e2 & DESC_CS_MASK) && !(e2 & DESC_R_MASK)) {\n\n                raise_exception_err(env, EXCP0A_TSS, selector & 0xfffc);\n\n            }\n\n            /* if data or non conforming code, checks the rights */\n\n            if (((e2 >> DESC_TYPE_SHIFT) & 0xf) < 12) {\n\n                if (dpl < cpl || dpl < rpl) {\n\n                    raise_exception_err(env, EXCP0A_TSS, selector & 0xfffc);\n\n                }\n\n            }\n\n        }\n\n        if (!(e2 & DESC_P_MASK)) {\n\n            raise_exception_err(env, EXCP0B_NOSEG, selector & 0xfffc);\n\n        }\n\n        cpu_x86_load_seg_cache(env, seg_reg, selector,\n\n                               get_seg_base(e1, e2),\n\n                               get_seg_limit(e1, e2),\n\n                               e2);\n\n    } else {\n\n        if (seg_reg == R_SS || seg_reg == R_CS) {\n\n            raise_exception_err(env, EXCP0A_TSS, selector & 0xfffc);\n\n        }\n\n    }\n\n}\n", "idx": 23514}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_mpui_io_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    if (size != 2) {\n\n        return omap_badwidth_read16(opaque, addr);\n\n    }\n\n\n\n    if (addr == OMAP_MPUI_BASE)\t/* CMR */\n\n        return 0xfe4d;\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 23516}
{"project": "qemu", "commit_id": "b097cc52fc9126bd1a71dae8302b8536d28104dd", "target": 0, "func": "static void nvdimm_class_init(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    PCDIMMDeviceClass *ddc = PC_DIMM_CLASS(oc);\n\n    NVDIMMClass *nvc = NVDIMM_CLASS(oc);\n\n\n\n    /* nvdimm hotplug has not been supported yet. */\n\n    dc->hotpluggable = false;\n\n\n\n    ddc->realize = nvdimm_realize;\n\n    ddc->get_memory_region = nvdimm_get_memory_region;\n\n    ddc->get_vmstate_memory_region = nvdimm_get_vmstate_memory_region;\n\n\n\n    nvc->read_label_data = nvdimm_read_label_data;\n\n    nvc->write_label_data = nvdimm_write_label_data;\n\n}\n", "idx": 23517}
{"project": "qemu", "commit_id": "1964a397063967acc5ce71a2a24ed26e74824ee1", "target": 0, "func": "QEMUFile *qemu_fopen_ops(void *opaque, const QEMUFileOps *ops)\n\n{\n\n    QEMUFile *f;\n\n\n\n    f = g_malloc0(sizeof(QEMUFile));\n\n\n\n    f->opaque = opaque;\n\n    f->ops = ops;\n\n    f->is_write = 0;\n\n\n\n    return f;\n\n}\n", "idx": 23518}
{"project": "qemu", "commit_id": "3b098d56979d2f7fd707c5be85555d114353a28d", "target": 0, "func": "QmpOutputVisitor *qmp_output_visitor_new(void)\n\n{\n\n    QmpOutputVisitor *v;\n\n\n\n    v = g_malloc0(sizeof(*v));\n\n\n\n    v->visitor.type = VISITOR_OUTPUT;\n\n    v->visitor.start_struct = qmp_output_start_struct;\n\n    v->visitor.end_struct = qmp_output_end_struct;\n\n    v->visitor.start_list = qmp_output_start_list;\n\n    v->visitor.next_list = qmp_output_next_list;\n\n    v->visitor.end_list = qmp_output_end_list;\n\n    v->visitor.type_int64 = qmp_output_type_int64;\n\n    v->visitor.type_uint64 = qmp_output_type_uint64;\n\n    v->visitor.type_bool = qmp_output_type_bool;\n\n    v->visitor.type_str = qmp_output_type_str;\n\n    v->visitor.type_number = qmp_output_type_number;\n\n    v->visitor.type_any = qmp_output_type_any;\n\n    v->visitor.type_null = qmp_output_type_null;\n\n    v->visitor.free = qmp_output_free;\n\n\n\n    QTAILQ_INIT(&v->stack);\n\n\n\n    return v;\n\n}\n", "idx": 23519}
{"project": "qemu", "commit_id": "2d0d2837dcf786da415cf4165d37f4ddd684ff57", "target": 0, "func": "DriveInfo *add_init_drive(const char *optstr)\n\n{\n\n    DriveInfo *dinfo;\n\n    QemuOpts *opts;\n\n\n\n    opts = drive_def(optstr);\n\n    if (!opts)\n\n        return NULL;\n\n\n\n    dinfo = drive_init(opts, current_machine->use_scsi);\n\n    if (!dinfo) {\n\n        qemu_opts_del(opts);\n\n        return NULL;\n\n    }\n\n\n\n    return dinfo;\n\n}\n", "idx": 23520}
{"project": "qemu", "commit_id": "3823b9db77e753041c04c161ac9f4d4cfc661520", "target": 0, "func": "static void arm_cpu_do_interrupt_aarch32(CPUState *cs)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(cs);\n\n    CPUARMState *env = &cpu->env;\n\n    uint32_t addr;\n\n    uint32_t mask;\n\n    int new_mode;\n\n    uint32_t offset;\n\n    uint32_t moe;\n\n\n\n    /* If this is a debug exception we must update the DBGDSCR.MOE bits */\n\n    switch (env->exception.syndrome >> ARM_EL_EC_SHIFT) {\n\n    case EC_BREAKPOINT:\n\n    case EC_BREAKPOINT_SAME_EL:\n\n        moe = 1;\n\n        break;\n\n    case EC_WATCHPOINT:\n\n    case EC_WATCHPOINT_SAME_EL:\n\n        moe = 10;\n\n        break;\n\n    case EC_AA32_BKPT:\n\n        moe = 3;\n\n        break;\n\n    case EC_VECTORCATCH:\n\n        moe = 5;\n\n        break;\n\n    default:\n\n        moe = 0;\n\n        break;\n\n    }\n\n\n\n    if (moe) {\n\n        env->cp15.mdscr_el1 = deposit64(env->cp15.mdscr_el1, 2, 4, moe);\n\n    }\n\n\n\n    /* TODO: Vectored interrupt controller.  */\n\n    switch (cs->exception_index) {\n\n    case EXCP_UDEF:\n\n        new_mode = ARM_CPU_MODE_UND;\n\n        addr = 0x04;\n\n        mask = CPSR_I;\n\n        if (env->thumb)\n\n            offset = 2;\n\n        else\n\n            offset = 4;\n\n        break;\n\n    case EXCP_SWI:\n\n        new_mode = ARM_CPU_MODE_SVC;\n\n        addr = 0x08;\n\n        mask = CPSR_I;\n\n        /* The PC already points to the next instruction.  */\n\n        offset = 0;\n\n        break;\n\n    case EXCP_BKPT:\n\n        env->exception.fsr = 2;\n\n        /* Fall through to prefetch abort.  */\n\n    case EXCP_PREFETCH_ABORT:\n\n        A32_BANKED_CURRENT_REG_SET(env, ifsr, env->exception.fsr);\n\n        A32_BANKED_CURRENT_REG_SET(env, ifar, env->exception.vaddress);\n\n        qemu_log_mask(CPU_LOG_INT, \"...with IFSR 0x%x IFAR 0x%x\\n\",\n\n                      env->exception.fsr, (uint32_t)env->exception.vaddress);\n\n        new_mode = ARM_CPU_MODE_ABT;\n\n        addr = 0x0c;\n\n        mask = CPSR_A | CPSR_I;\n\n        offset = 4;\n\n        break;\n\n    case EXCP_DATA_ABORT:\n\n        A32_BANKED_CURRENT_REG_SET(env, dfsr, env->exception.fsr);\n\n        A32_BANKED_CURRENT_REG_SET(env, dfar, env->exception.vaddress);\n\n        qemu_log_mask(CPU_LOG_INT, \"...with DFSR 0x%x DFAR 0x%x\\n\",\n\n                      env->exception.fsr,\n\n                      (uint32_t)env->exception.vaddress);\n\n        new_mode = ARM_CPU_MODE_ABT;\n\n        addr = 0x10;\n\n        mask = CPSR_A | CPSR_I;\n\n        offset = 8;\n\n        break;\n\n    case EXCP_IRQ:\n\n        new_mode = ARM_CPU_MODE_IRQ;\n\n        addr = 0x18;\n\n        /* Disable IRQ and imprecise data aborts.  */\n\n        mask = CPSR_A | CPSR_I;\n\n        offset = 4;\n\n        if (env->cp15.scr_el3 & SCR_IRQ) {\n\n            /* IRQ routed to monitor mode */\n\n            new_mode = ARM_CPU_MODE_MON;\n\n            mask |= CPSR_F;\n\n        }\n\n        break;\n\n    case EXCP_FIQ:\n\n        new_mode = ARM_CPU_MODE_FIQ;\n\n        addr = 0x1c;\n\n        /* Disable FIQ, IRQ and imprecise data aborts.  */\n\n        mask = CPSR_A | CPSR_I | CPSR_F;\n\n        if (env->cp15.scr_el3 & SCR_FIQ) {\n\n            /* FIQ routed to monitor mode */\n\n            new_mode = ARM_CPU_MODE_MON;\n\n        }\n\n        offset = 4;\n\n        break;\n\n    case EXCP_SMC:\n\n        new_mode = ARM_CPU_MODE_MON;\n\n        addr = 0x08;\n\n        mask = CPSR_A | CPSR_I | CPSR_F;\n\n        offset = 0;\n\n        break;\n\n    default:\n\n        cpu_abort(cs, \"Unhandled exception 0x%x\\n\", cs->exception_index);\n\n        return; /* Never happens.  Keep compiler happy.  */\n\n    }\n\n\n\n    if (new_mode == ARM_CPU_MODE_MON) {\n\n        addr += env->cp15.mvbar;\n\n    } else if (A32_BANKED_CURRENT_REG_GET(env, sctlr) & SCTLR_V) {\n\n        /* High vectors. When enabled, base address cannot be remapped. */\n\n        addr += 0xffff0000;\n\n    } else {\n\n        /* ARM v7 architectures provide a vector base address register to remap\n\n         * the interrupt vector table.\n\n         * This register is only followed in non-monitor mode, and is banked.\n\n         * Note: only bits 31:5 are valid.\n\n         */\n\n        addr += A32_BANKED_CURRENT_REG_GET(env, vbar);\n\n    }\n\n\n\n    if ((env->uncached_cpsr & CPSR_M) == ARM_CPU_MODE_MON) {\n\n        env->cp15.scr_el3 &= ~SCR_NS;\n\n    }\n\n\n\n    switch_mode (env, new_mode);\n\n    /* For exceptions taken to AArch32 we must clear the SS bit in both\n\n     * PSTATE and in the old-state value we save to SPSR_<mode>, so zero it now.\n\n     */\n\n    env->uncached_cpsr &= ~PSTATE_SS;\n\n    env->spsr = cpsr_read(env);\n\n    /* Clear IT bits.  */\n\n    env->condexec_bits = 0;\n\n    /* Switch to the new mode, and to the correct instruction set.  */\n\n    env->uncached_cpsr = (env->uncached_cpsr & ~CPSR_M) | new_mode;\n\n    /* Set new mode endianness */\n\n    env->uncached_cpsr &= ~CPSR_E;\n\n    if (env->cp15.sctlr_el[arm_current_el(env)] & SCTLR_EE) {\n\n        env->uncached_cpsr |= ~CPSR_E;\n\n    }\n\n    env->daif |= mask;\n\n    /* this is a lie, as the was no c1_sys on V4T/V5, but who cares\n\n     * and we should just guard the thumb mode on V4 */\n\n    if (arm_feature(env, ARM_FEATURE_V4T)) {\n\n        env->thumb = (A32_BANKED_CURRENT_REG_GET(env, sctlr) & SCTLR_TE) != 0;\n\n    }\n\n    env->regs[14] = env->regs[15] + offset;\n\n    env->regs[15] = addr;\n\n}\n", "idx": 23521}
{"project": "qemu", "commit_id": "9eaaf971683c99ed197fa1b7d1a3ca9baabfb3ee", "target": 0, "func": "static void simple_list(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        LiteralQObject decoded;\n\n    } test_cases[] = {\n\n        {\n\n            .encoded = \"[43,42]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \"[43]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \"[]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \"[{}]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n\n                                    {},\n\n                                        })),\n\n                        {},\n\n                            })),\n\n        },\n\n        { }\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_json(test_cases[i].encoded);\n\n        g_assert(obj != NULL);\n\n        g_assert(qobject_type(obj) == QTYPE_QLIST);\n\n\n\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n\n\n        str = qobject_to_json(obj);\n\n        qobject_decref(obj);\n\n\n\n        obj = qobject_from_json(qstring_get_str(str));\n\n        g_assert(obj != NULL);\n\n        g_assert(qobject_type(obj) == QTYPE_QLIST);\n\n\n\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n        qobject_decref(obj);\n\n        QDECREF(str);\n\n    }\n\n}\n", "idx": 23522}
{"project": "qemu", "commit_id": "e912c96f7d2e5ccd8a6352ee74f5beee2a7d9976", "target": 0, "func": "static BusState *qbus_find_recursive(BusState *bus, const char *name,\n\n                                     const char *bus_typename)\n\n{\n\n    BusChild *kid;\n\n    BusState *child, *ret;\n\n    int match = 1;\n\n\n\n    if (name && (strcmp(bus->name, name) != 0)) {\n\n        match = 0;\n\n    }\n\n    if (bus_typename &&\n\n        (strcmp(object_get_typename(OBJECT(bus)), bus_typename) != 0)) {\n\n        match = 0;\n\n    }\n\n    if (match) {\n\n        return bus;\n\n    }\n\n\n\n    QTAILQ_FOREACH(kid, &bus->children, sibling) {\n\n        DeviceState *dev = kid->child;\n\n        QLIST_FOREACH(child, &dev->child_bus, sibling) {\n\n            ret = qbus_find_recursive(child, name, bus_typename);\n\n            if (ret) {\n\n                return ret;\n\n            }\n\n        }\n\n    }\n\n    return NULL;\n\n}\n", "idx": 23523}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t m5208_timer_read(void *opaque, target_phys_addr_t addr,\n\n                                 unsigned size)\n\n{\n\n    m5208_timer_state *s = (m5208_timer_state *)opaque;\n\n    switch (addr) {\n\n    case 0:\n\n        return s->pcsr;\n\n    case 2:\n\n        return s->pmr;\n\n    case 4:\n\n        return ptimer_get_count(s->timer);\n\n    default:\n\n        hw_error(\"m5208_timer_read: Bad offset 0x%x\\n\", (int)addr);\n\n        return 0;\n\n    }\n\n}\n", "idx": 23524}
{"project": "qemu", "commit_id": "6e0d8677cb443e7408c0b7a25a93c6596d7fa380", "target": 0, "func": "static inline void gen_cmps(DisasContext *s, int ot)\n\n{\n\n    gen_string_movl_A0_ESI(s);\n\n    gen_op_ld_T0_A0(ot + s->mem_index);\n\n    gen_string_movl_A0_EDI(s);\n\n    gen_op_ld_T1_A0(ot + s->mem_index);\n\n    gen_op_cmpl_T0_T1_cc();\n\n    gen_op_movl_T0_Dshift[ot]();\n\n#ifdef TARGET_X86_64\n\n    if (s->aflag == 2) {\n\n        gen_op_addq_ESI_T0();\n\n        gen_op_addq_EDI_T0();\n\n    } else\n\n#endif\n\n    if (s->aflag) {\n\n        gen_op_addl_ESI_T0();\n\n        gen_op_addl_EDI_T0();\n\n    } else {\n\n        gen_op_addw_ESI_T0();\n\n        gen_op_addw_EDI_T0();\n\n    }\n\n}\n", "idx": 23525}
{"project": "qemu", "commit_id": "f76faeda4bd59f972d09dd9d954297f17c21dd60", "target": 0, "func": "static CURLState *curl_init_state(BlockDriverState *bs, BDRVCURLState *s)\n\n{\n\n    CURLState *state = NULL;\n\n    int i, j;\n\n\n\n    do {\n\n        for (i=0; i<CURL_NUM_STATES; i++) {\n\n            for (j=0; j<CURL_NUM_ACB; j++)\n\n                if (s->states[i].acb[j])\n\n                    continue;\n\n            if (s->states[i].in_use)\n\n                continue;\n\n\n\n            state = &s->states[i];\n\n            state->in_use = 1;\n\n            break;\n\n        }\n\n        if (!state) {\n\n            aio_poll(bdrv_get_aio_context(bs), true);\n\n        }\n\n    } while(!state);\n\n\n\n    if (!state->curl) {\n\n        state->curl = curl_easy_init();\n\n        if (!state->curl) {\n\n            return NULL;\n\n        }\n\n        curl_easy_setopt(state->curl, CURLOPT_URL, s->url);\n\n        curl_easy_setopt(state->curl, CURLOPT_SSL_VERIFYPEER,\n\n                         (long) s->sslverify);\n\n        if (s->cookie) {\n\n            curl_easy_setopt(state->curl, CURLOPT_COOKIE, s->cookie);\n\n        }\n\n        curl_easy_setopt(state->curl, CURLOPT_TIMEOUT, s->timeout);\n\n        curl_easy_setopt(state->curl, CURLOPT_WRITEFUNCTION,\n\n                         (void *)curl_read_cb);\n\n        curl_easy_setopt(state->curl, CURLOPT_WRITEDATA, (void *)state);\n\n        curl_easy_setopt(state->curl, CURLOPT_PRIVATE, (void *)state);\n\n        curl_easy_setopt(state->curl, CURLOPT_AUTOREFERER, 1);\n\n        curl_easy_setopt(state->curl, CURLOPT_FOLLOWLOCATION, 1);\n\n        curl_easy_setopt(state->curl, CURLOPT_NOSIGNAL, 1);\n\n        curl_easy_setopt(state->curl, CURLOPT_ERRORBUFFER, state->errmsg);\n\n        curl_easy_setopt(state->curl, CURLOPT_FAILONERROR, 1);\n\n\n\n        /* Restrict supported protocols to avoid security issues in the more\n\n         * obscure protocols.  For example, do not allow POP3/SMTP/IMAP see\n\n         * CVE-2013-0249.\n\n         *\n\n         * Restricting protocols is only supported from 7.19.4 upwards.\n\n         */\n\n#if LIBCURL_VERSION_NUM >= 0x071304\n\n        curl_easy_setopt(state->curl, CURLOPT_PROTOCOLS, PROTOCOLS);\n\n        curl_easy_setopt(state->curl, CURLOPT_REDIR_PROTOCOLS, PROTOCOLS);\n\n#endif\n\n\n\n#ifdef DEBUG_VERBOSE\n\n        curl_easy_setopt(state->curl, CURLOPT_VERBOSE, 1);\n\n#endif\n\n    }\n\n\n\n    state->s = s;\n\n\n\n    return state;\n\n}\n", "idx": 23527}
{"project": "qemu", "commit_id": "d3606f07440ee2c2bebea2b9932938e08b66d90b", "target": 0, "func": "static bool elf_check_ehdr(struct elfhdr *ehdr)\n\n{\n\n    return (elf_check_arch(ehdr->e_machine)\n\n            && ehdr->e_ehsize == sizeof(struct elfhdr)\n\n            && ehdr->e_phentsize == sizeof(struct elf_phdr)\n\n            && ehdr->e_shentsize == sizeof(struct elf_shdr)\n\n            && (ehdr->e_type == ET_EXEC || ehdr->e_type == ET_DYN));\n\n}\n", "idx": 23528}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_dat_rIN(TCGContext *s, int cond, int opc, int opneg,\n\n                            TCGArg dst, TCGArg lhs, TCGArg rhs,\n\n                            bool rhs_is_const)\n\n{\n\n    /* Emit either the reg,imm or reg,reg form of a data-processing insn.\n\n     * rhs must satisfy the \"rIN\" constraint.\n\n     */\n\n    if (rhs_is_const) {\n\n        int rot = encode_imm(rhs);\n\n        if (rot < 0) {\n\n            rhs = -rhs;\n\n            rot = encode_imm(rhs);\n\n            assert(rot >= 0);\n\n            opc = opneg;\n\n        }\n\n        tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));\n\n    } else {\n\n        tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));\n\n    }\n\n}\n", "idx": 23529}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void add_completion(const char *str)\n\n{\n\n    if (nb_completions < NB_COMPLETIONS_MAX) {\n\n        completions[nb_completions++] = qemu_strdup(str);\n\n    }\n\n}\n", "idx": 23530}
{"project": "qemu", "commit_id": "2e6fc7eb1a4af1b127df5f07b8bb28af891946fa", "target": 0, "func": "static void raw_lock_medium(BlockDriverState *bs, bool locked)\n\n{\n\n    bdrv_lock_medium(bs->file->bs, locked);\n\n}\n", "idx": 23531}
{"project": "qemu", "commit_id": "afd59989db90683fa127fec501d2633bcfbd6379", "target": 0, "func": "static void irq_handler(void *opaque, int irq, int level)\n\n{\n\n    struct xlx_pic *p = opaque;\n\n\n\n    if (!(p->regs[R_MER] & 2)) {\n\n        qemu_irq_lower(p->parent_irq);\n\n        return;\n\n    }\n\n\n\n    /* edge triggered interrupt */\n\n    if (p->c_kind_of_intr & (1 << irq) && p->regs[R_MER] & 2) {\n\n        p->regs[R_ISR] |= (level << irq);\n\n    }\n\n\n\n    p->irq_pin_state &= ~(1 << irq);\n\n    p->irq_pin_state |= level << irq;\n\n    update_irq(p);\n\n}\n", "idx": 23532}
{"project": "qemu", "commit_id": "ad196a9d0c14f681f010bb4b979030ec125ba976", "target": 0, "func": "void net_slirp_smb(const char *exported_dir)\n\n{\n\n    if (slirp_smb_export) {\n\n        fprintf(stderr, \"-smb given twice\\n\");\n\n        exit(1);\n\n    }\n\n    slirp_smb_export = exported_dir;\n\n    if (slirp_inited) {\n\n        slirp_smb(exported_dir);\n\n    }\n\n}\n", "idx": 23533}
{"project": "qemu", "commit_id": "53cb28cbfea038f8ad50132dc8a684e638c7d48b", "target": 0, "func": "static void phys_map_node_reserve(unsigned nodes)\n\n{\n\n    if (next_map.nodes_nb + nodes > next_map.nodes_nb_alloc) {\n\n        next_map.nodes_nb_alloc = MAX(next_map.nodes_nb_alloc * 2,\n\n                                            16);\n\n        next_map.nodes_nb_alloc = MAX(next_map.nodes_nb_alloc,\n\n                                      next_map.nodes_nb + nodes);\n\n        next_map.nodes = g_renew(Node, next_map.nodes,\n\n                                 next_map.nodes_nb_alloc);\n\n    }\n\n}\n", "idx": 23534}
{"project": "qemu", "commit_id": "b854bc196f5c4b4e3299c0b0ee63cf828ece9e77", "target": 0, "func": "static int omap_dma_ch_reg_write(struct omap_dma_s *s,\n\n                int ch, int reg, uint16_t value) {\n\n    switch (reg) {\n\n    case 0x00:\t/* SYS_DMA_CSDP_CH0 */\n\n        s->ch[ch].burst[1] = (value & 0xc000) >> 14;\n\n        s->ch[ch].pack[1] = (value & 0x2000) >> 13;\n\n        s->ch[ch].port[1] = (enum omap_dma_port) ((value & 0x1e00) >> 9);\n\n        s->ch[ch].burst[0] = (value & 0x0180) >> 7;\n\n        s->ch[ch].pack[0] = (value & 0x0040) >> 6;\n\n        s->ch[ch].port[0] = (enum omap_dma_port) ((value & 0x003c) >> 2);\n\n        s->ch[ch].data_type = (1 << (value & 3));\n\n        if (s->ch[ch].port[0] >= omap_dma_port_last)\n\n            printf(\"%s: invalid DMA port %i\\n\", __FUNCTION__,\n\n                            s->ch[ch].port[0]);\n\n        if (s->ch[ch].port[1] >= omap_dma_port_last)\n\n            printf(\"%s: invalid DMA port %i\\n\", __FUNCTION__,\n\n                            s->ch[ch].port[1]);\n\n        if ((value & 3) == 3)\n\n            printf(\"%s: bad data_type for DMA channel %i\\n\", __FUNCTION__, ch);\n\n        break;\n\n\n\n    case 0x02:\t/* SYS_DMA_CCR_CH0 */\n\n        s->ch[ch].mode[1] = (omap_dma_addressing_t) ((value & 0xc000) >> 14);\n\n        s->ch[ch].mode[0] = (omap_dma_addressing_t) ((value & 0x3000) >> 12);\n\n        s->ch[ch].end_prog = (value & 0x0800) >> 11;\n\n        s->ch[ch].repeat = (value & 0x0200) >> 9;\n\n        s->ch[ch].auto_init = (value & 0x0100) >> 8;\n\n        s->ch[ch].priority = (value & 0x0040) >> 6;\n\n        s->ch[ch].fs = (value & 0x0020) >> 5;\n\n        s->ch[ch].sync = value & 0x001f;\n\n        if (value & 0x0080) {\n\n            if (s->ch[ch].running) {\n\n                if (!s->ch[ch].signalled &&\n\n                                s->ch[ch].auto_init && s->ch[ch].end_prog)\n\n                    omap_dma_channel_load(s, ch);\n\n            } else {\n\n                s->ch[ch].running = 1;\n\n                omap_dma_channel_load(s, ch);\n\n            }\n\n            if (!s->ch[ch].sync || (s->drq & (1 << s->ch[ch].sync)))\n\n                omap_dma_request_run(s, ch, 0);\n\n        } else {\n\n            s->ch[ch].running = 0;\n\n            omap_dma_request_stop(s, ch);\n\n        }\n\n        break;\n\n\n\n    case 0x04:\t/* SYS_DMA_CICR_CH0 */\n\n        s->ch[ch].interrupts = value & 0x003f;\n\n        break;\n\n\n\n    case 0x06:\t/* SYS_DMA_CSR_CH0 */\n\n        return 1;\n\n\n\n    case 0x08:\t/* SYS_DMA_CSSA_L_CH0 */\n\n        s->ch[ch].addr[0] &= 0xffff0000;\n\n        s->ch[ch].addr[0] |= value;\n\n        break;\n\n\n\n    case 0x0a:\t/* SYS_DMA_CSSA_U_CH0 */\n\n        s->ch[ch].addr[0] &= 0x0000ffff;\n\n        s->ch[ch].addr[0] |= value << 16;\n\n        break;\n\n\n\n    case 0x0c:\t/* SYS_DMA_CDSA_L_CH0 */\n\n        s->ch[ch].addr[1] &= 0xffff0000;\n\n        s->ch[ch].addr[1] |= value;\n\n        break;\n\n\n\n    case 0x0e:\t/* SYS_DMA_CDSA_U_CH0 */\n\n        s->ch[ch].addr[1] &= 0x0000ffff;\n\n        s->ch[ch].addr[1] |= value << 16;\n\n        break;\n\n\n\n    case 0x10:\t/* SYS_DMA_CEN_CH0 */\n\n        s->ch[ch].elements = value & 0xffff;\n\n        break;\n\n\n\n    case 0x12:\t/* SYS_DMA_CFN_CH0 */\n\n        s->ch[ch].frames = value & 0xffff;\n\n        break;\n\n\n\n    case 0x14:\t/* SYS_DMA_CFI_CH0 */\n\n        s->ch[ch].frame_index = value & 0xffff;\n\n        break;\n\n\n\n    case 0x16:\t/* SYS_DMA_CEI_CH0 */\n\n        s->ch[ch].element_index = value & 0xffff;\n\n        break;\n\n\n\n    case 0x18:\t/* SYS_DMA_CPC_CH0 */\n\n        return 1;\n\n\n\n    default:\n\n        OMAP_BAD_REG((unsigned long) reg);\n\n    }\n\n    return 0;\n\n}\n", "idx": 23535}
{"project": "qemu", "commit_id": "7a0e58fa648736a75f2a6943afd2ab08ea15b8e0", "target": 0, "func": "static void add_cpreg_to_hashtable(ARMCPU *cpu, const ARMCPRegInfo *r,\n\n                                   void *opaque, int state, int secstate,\n\n                                   int crm, int opc1, int opc2)\n\n{\n\n    /* Private utility function for define_one_arm_cp_reg_with_opaque():\n\n     * add a single reginfo struct to the hash table.\n\n     */\n\n    uint32_t *key = g_new(uint32_t, 1);\n\n    ARMCPRegInfo *r2 = g_memdup(r, sizeof(ARMCPRegInfo));\n\n    int is64 = (r->type & ARM_CP_64BIT) ? 1 : 0;\n\n    int ns = (secstate & ARM_CP_SECSTATE_NS) ? 1 : 0;\n\n\n\n    /* Reset the secure state to the specific incoming state.  This is\n\n     * necessary as the register may have been defined with both states.\n\n     */\n\n    r2->secure = secstate;\n\n\n\n    if (r->bank_fieldoffsets[0] && r->bank_fieldoffsets[1]) {\n\n        /* Register is banked (using both entries in array).\n\n         * Overwriting fieldoffset as the array is only used to define\n\n         * banked registers but later only fieldoffset is used.\n\n         */\n\n        r2->fieldoffset = r->bank_fieldoffsets[ns];\n\n    }\n\n\n\n    if (state == ARM_CP_STATE_AA32) {\n\n        if (r->bank_fieldoffsets[0] && r->bank_fieldoffsets[1]) {\n\n            /* If the register is banked then we don't need to migrate or\n\n             * reset the 32-bit instance in certain cases:\n\n             *\n\n             * 1) If the register has both 32-bit and 64-bit instances then we\n\n             *    can count on the 64-bit instance taking care of the\n\n             *    non-secure bank.\n\n             * 2) If ARMv8 is enabled then we can count on a 64-bit version\n\n             *    taking care of the secure bank.  This requires that separate\n\n             *    32 and 64-bit definitions are provided.\n\n             */\n\n            if ((r->state == ARM_CP_STATE_BOTH && ns) ||\n\n                (arm_feature(&cpu->env, ARM_FEATURE_V8) && !ns)) {\n\n                r2->type |= ARM_CP_NO_MIGRATE;\n\n                r2->resetfn = arm_cp_reset_ignore;\n\n            }\n\n        } else if ((secstate != r->secure) && !ns) {\n\n            /* The register is not banked so we only want to allow migration of\n\n             * the non-secure instance.\n\n             */\n\n            r2->type |= ARM_CP_NO_MIGRATE;\n\n            r2->resetfn = arm_cp_reset_ignore;\n\n        }\n\n\n\n        if (r->state == ARM_CP_STATE_BOTH) {\n\n            /* We assume it is a cp15 register if the .cp field is left unset.\n\n             */\n\n            if (r2->cp == 0) {\n\n                r2->cp = 15;\n\n            }\n\n\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n            if (r2->fieldoffset) {\n\n                r2->fieldoffset += sizeof(uint32_t);\n\n            }\n\n#endif\n\n        }\n\n    }\n\n    if (state == ARM_CP_STATE_AA64) {\n\n        /* To allow abbreviation of ARMCPRegInfo\n\n         * definitions, we treat cp == 0 as equivalent to\n\n         * the value for \"standard guest-visible sysreg\".\n\n         * STATE_BOTH definitions are also always \"standard\n\n         * sysreg\" in their AArch64 view (the .cp value may\n\n         * be non-zero for the benefit of the AArch32 view).\n\n         */\n\n        if (r->cp == 0 || r->state == ARM_CP_STATE_BOTH) {\n\n            r2->cp = CP_REG_ARM64_SYSREG_CP;\n\n        }\n\n        *key = ENCODE_AA64_CP_REG(r2->cp, r2->crn, crm,\n\n                                  r2->opc0, opc1, opc2);\n\n    } else {\n\n        *key = ENCODE_CP_REG(r2->cp, is64, ns, r2->crn, crm, opc1, opc2);\n\n    }\n\n    if (opaque) {\n\n        r2->opaque = opaque;\n\n    }\n\n    /* reginfo passed to helpers is correct for the actual access,\n\n     * and is never ARM_CP_STATE_BOTH:\n\n     */\n\n    r2->state = state;\n\n    /* Make sure reginfo passed to helpers for wildcarded regs\n\n     * has the correct crm/opc1/opc2 for this reg, not CP_ANY:\n\n     */\n\n    r2->crm = crm;\n\n    r2->opc1 = opc1;\n\n    r2->opc2 = opc2;\n\n    /* By convention, for wildcarded registers only the first\n\n     * entry is used for migration; the others are marked as\n\n     * NO_MIGRATE so we don't try to transfer the register\n\n     * multiple times. Special registers (ie NOP/WFI) are\n\n     * never migratable.\n\n     */\n\n    if ((r->type & ARM_CP_SPECIAL) ||\n\n        ((r->crm == CP_ANY) && crm != 0) ||\n\n        ((r->opc1 == CP_ANY) && opc1 != 0) ||\n\n        ((r->opc2 == CP_ANY) && opc2 != 0)) {\n\n        r2->type |= ARM_CP_NO_MIGRATE;\n\n    }\n\n\n\n    /* Overriding of an existing definition must be explicitly\n\n     * requested.\n\n     */\n\n    if (!(r->type & ARM_CP_OVERRIDE)) {\n\n        ARMCPRegInfo *oldreg;\n\n        oldreg = g_hash_table_lookup(cpu->cp_regs, key);\n\n        if (oldreg && !(oldreg->type & ARM_CP_OVERRIDE)) {\n\n            fprintf(stderr, \"Register redefined: cp=%d %d bit \"\n\n                    \"crn=%d crm=%d opc1=%d opc2=%d, \"\n\n                    \"was %s, now %s\\n\", r2->cp, 32 + 32 * is64,\n\n                    r2->crn, r2->crm, r2->opc1, r2->opc2,\n\n                    oldreg->name, r2->name);\n\n            g_assert_not_reached();\n\n        }\n\n    }\n\n    g_hash_table_insert(cpu->cp_regs, key, r2);\n\n}\n", "idx": 23536}
{"project": "qemu", "commit_id": "3335ddddf9e5ba7743dc8e3f767f4ef857ccd20c", "target": 0, "func": "static void read_event_data(SCLPEventFacility *ef, SCCB *sccb)\n\n{\n\n    unsigned int sclp_active_selection_mask;\n\n    unsigned int sclp_cp_receive_mask;\n\n\n\n    ReadEventData *red = (ReadEventData *) sccb;\n\n\n\n    if (be16_to_cpu(sccb->h.length) != SCCB_SIZE) {\n\n        sccb->h.response_code = cpu_to_be16(SCLP_RC_INSUFFICIENT_SCCB_LENGTH);\n\n        goto out;\n\n    }\n\n\n\n    sclp_cp_receive_mask = ef->receive_mask;\n\n\n\n    /* get active selection mask */\n\n    switch (sccb->h.function_code) {\n\n    case SCLP_UNCONDITIONAL_READ:\n\n        sclp_active_selection_mask = sclp_cp_receive_mask;\n\n        break;\n\n    case SCLP_SELECTIVE_READ:\n\n        if (!(sclp_cp_receive_mask & be32_to_cpu(red->mask))) {\n\n            sccb->h.response_code =\n\n                    cpu_to_be16(SCLP_RC_INVALID_SELECTION_MASK);\n\n            goto out;\n\n        }\n\n        sclp_active_selection_mask = be32_to_cpu(red->mask);\n\n        break;\n\n    default:\n\n        sccb->h.response_code = cpu_to_be16(SCLP_RC_INVALID_FUNCTION);\n\n        goto out;\n\n    }\n\n    sccb->h.response_code = cpu_to_be16(\n\n            handle_sccb_read_events(ef, sccb, sclp_active_selection_mask));\n\n\n\nout:\n\n    return;\n\n}\n", "idx": 23538}
{"project": "qemu", "commit_id": "9bada8971173345ceb37ed1a47b00a01a4dd48cf", "target": 0, "func": "static QObject *parse_keyword(JSONParserContext *ctxt)\n\n{\n\n    QObject *token;\n\n    const char *val;\n\n\n\n    token = parser_context_pop_token(ctxt);\n\n    assert(token && token_get_type(token) == JSON_KEYWORD);\n\n    val = token_get_value(token);\n\n\n\n    if (!strcmp(val, \"true\")) {\n\n        return QOBJECT(qbool_from_bool(true));\n\n    } else if (!strcmp(val, \"false\")) {\n\n        return QOBJECT(qbool_from_bool(false));\n\n    } else if (!strcmp(val, \"null\")) {\n\n        return qnull();\n\n    }\n\n    parse_error(ctxt, token, \"invalid keyword '%s'\", val);\n\n    return NULL;\n\n}\n", "idx": 23539}
{"project": "qemu", "commit_id": "10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b", "target": 0, "func": "static void nam_writeb (void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    PCIAC97LinkState *d = opaque;\n\n    AC97LinkState *s = &d->ac97;\n\n    dolog (\"U nam writeb %#x <- %#x\\n\", addr, val);\n\n    s->cas = 0;\n\n}\n", "idx": 23540}
{"project": "qemu", "commit_id": "6bdc21c050a2a7b92cbbd0b2a1f8934e9b5f896f", "target": 0, "func": "static void virtqueue_map_iovec(VirtIODevice *vdev, struct iovec *sg,\n\n                                hwaddr *addr, unsigned int *num_sg,\n\n                                unsigned int max_size, int is_write)\n\n{\n\n    unsigned int i;\n\n    hwaddr len;\n\n\n\n    /* Note: this function MUST validate input, some callers\n\n     * are passing in num_sg values received over the network.\n\n     */\n\n    /* TODO: teach all callers that this can fail, and return failure instead\n\n     * of asserting here.\n\n     * When we do, we might be able to re-enable NDEBUG below.\n\n     */\n\n#ifdef NDEBUG\n\n#error building with NDEBUG is not supported\n\n#endif\n\n    assert(*num_sg <= max_size);\n\n\n\n    for (i = 0; i < *num_sg; i++) {\n\n        len = sg[i].iov_len;\n\n        sg[i].iov_base = dma_memory_map(vdev->dma_as,\n\n                                        addr[i], &len, is_write ?\n\n                                        DMA_DIRECTION_FROM_DEVICE :\n\n                                        DMA_DIRECTION_TO_DEVICE);\n\n        if (!sg[i].iov_base) {\n\n            error_report(\"virtio: error trying to map MMIO memory\");\n\n            exit(1);\n\n        }\n\n        if (len != sg[i].iov_len) {\n\n            error_report(\"virtio: unexpected memory split\");\n\n            exit(1);\n\n        }\n\n    }\n\n}\n", "idx": 23541}
{"project": "qemu", "commit_id": "3d948cdf3760b52238038626a7ffa7d30913060b", "target": 0, "func": "void qmp_block_job_complete(const char *device, Error **errp)\n\n{\n\n    BlockJob *job = find_block_job(device);\n\n\n\n    if (!job) {\n\n        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);\n\n        return;\n\n    }\n\n\n\n    trace_qmp_block_job_complete(job);\n\n    block_job_complete(job, errp);\n\n}\n", "idx": 23542}
{"project": "qemu", "commit_id": "92c0bba9a95739c92e959fe478cb1acb92fa5446", "target": 0, "func": "static uint32_t omap_l4_io_readb(void *opaque, target_phys_addr_t addr)\n\n{\n\n    unsigned int i = (addr - OMAP2_L4_BASE) >> TARGET_PAGE_BITS;\n\n\n\n    return omap_l4_io_readb_fn[i](omap_l4_io_opaque[i], addr);\n\n}\n", "idx": 23543}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void qemu_chr_initial_reset(void)\n\n{\n\n    CharDriverState *chr;\n\n\n\n    initial_reset_issued = 1;\n\n\n\n    TAILQ_FOREACH(chr, &chardevs, next) {\n\n        qemu_chr_reset(chr);\n\n    }\n\n}\n", "idx": 23544}
{"project": "qemu", "commit_id": "ee312992a323530ea2cda8680f3a34746c72db8f", "target": 0, "func": "void qemu_input_event_sync(void)\n\n{\n\n    QemuInputHandlerState *s;\n\n\n\n    if (!runstate_is_running() && !runstate_check(RUN_STATE_SUSPENDED)) {\n\n        return;\n\n    }\n\n\n\n    trace_input_event_sync();\n\n\n\n    QTAILQ_FOREACH(s, &handlers, node) {\n\n        if (!s->events) {\n\n            continue;\n\n        }\n\n        if (s->handler->sync) {\n\n            s->handler->sync(s->dev);\n\n        }\n\n        s->events = 0;\n\n    }\n\n}\n", "idx": 23545}
{"project": "qemu", "commit_id": "8d5c773e323b22402abdd0beef4c7d2fc91dd0eb", "target": 0, "func": "static void par_write(CPUARMState *env, const ARMCPRegInfo *ri, uint64_t value)\n\n{\n\n    if (arm_feature(env, ARM_FEATURE_LPAE)) {\n\n        env->cp15.par_el1 = value;\n\n    } else if (arm_feature(env, ARM_FEATURE_V7)) {\n\n        env->cp15.par_el1 = value & 0xfffff6ff;\n\n    } else {\n\n        env->cp15.par_el1 = value & 0xfffff1ff;\n\n    }\n\n}\n", "idx": 23546}
{"project": "qemu", "commit_id": "8e9b0d24fb986d4241ae3b77752eca5dab4cb486", "target": 0, "func": "void vnc_client_write(void *opaque)\n\n{\n\n    VncState *vs = opaque;\n\n\n\n    vnc_lock_output(vs);\n\n    if (vs->output.offset\n\n#ifdef CONFIG_VNC_WS\n\n            || vs->ws_output.offset\n\n#endif\n\n            ) {\n\n        vnc_client_write_locked(opaque);\n\n    } else if (vs->csock != -1) {\n\n        qemu_set_fd_handler(vs->csock, vnc_client_read, NULL, vs);\n\n    }\n\n    vnc_unlock_output(vs);\n\n}\n", "idx": 23547}
{"project": "qemu", "commit_id": "1f001dc7bc9e435bf231a5b0edcad1c7c2bd6214", "target": 0, "func": "static void default_qemu_fd_register(int fd)\n\n{\n\n}\n", "idx": 23549}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_is_sg(BlockDriverState *bs)\n\n{\n\n    return bs->sg;\n\n}\n", "idx": 23550}
{"project": "qemu", "commit_id": "bb593904c18e22ea0671dfa1b02e24982f2bf0ea", "target": 0, "func": "void cpu_dump_state (CPUState *env, FILE *f, fprintf_function cpu_fprintf,\n\n                     int flags)\n\n{\n\n#define RGPL  4\n\n#define RFPL  4\n\n\n\n    int i;\n\n\n\n    cpu_fprintf(f, \"NIP \" TARGET_FMT_lx \"   LR \" TARGET_FMT_lx \" CTR \"\n\n                TARGET_FMT_lx \" XER \" TARGET_FMT_lx \"\\n\",\n\n                env->nip, env->lr, env->ctr, env->xer);\n\n    cpu_fprintf(f, \"MSR \" TARGET_FMT_lx \" HID0 \" TARGET_FMT_lx \"  HF \"\n\n                TARGET_FMT_lx \" idx %d\\n\", env->msr, env->spr[SPR_HID0],\n\n                env->hflags, env->mmu_idx);\n\n#if !defined(NO_TIMER_DUMP)\n\n    cpu_fprintf(f, \"TB %08\" PRIu32 \" %08\" PRIu64\n\n#if !defined(CONFIG_USER_ONLY)\n\n                \" DECR %08\" PRIu32\n\n#endif\n\n                \"\\n\",\n\n                cpu_ppc_load_tbu(env), cpu_ppc_load_tbl(env)\n\n#if !defined(CONFIG_USER_ONLY)\n\n                , cpu_ppc_load_decr(env)\n\n#endif\n\n                );\n\n#endif\n\n    for (i = 0; i < 32; i++) {\n\n        if ((i & (RGPL - 1)) == 0)\n\n            cpu_fprintf(f, \"GPR%02d\", i);\n\n        cpu_fprintf(f, \" %016\" PRIx64, ppc_dump_gpr(env, i));\n\n        if ((i & (RGPL - 1)) == (RGPL - 1))\n\n            cpu_fprintf(f, \"\\n\");\n\n    }\n\n    cpu_fprintf(f, \"CR \");\n\n    for (i = 0; i < 8; i++)\n\n        cpu_fprintf(f, \"%01x\", env->crf[i]);\n\n    cpu_fprintf(f, \"  [\");\n\n    for (i = 0; i < 8; i++) {\n\n        char a = '-';\n\n        if (env->crf[i] & 0x08)\n\n            a = 'L';\n\n        else if (env->crf[i] & 0x04)\n\n            a = 'G';\n\n        else if (env->crf[i] & 0x02)\n\n            a = 'E';\n\n        cpu_fprintf(f, \" %c%c\", a, env->crf[i] & 0x01 ? 'O' : ' ');\n\n    }\n\n    cpu_fprintf(f, \" ]             RES \" TARGET_FMT_lx \"\\n\",\n\n                env->reserve_addr);\n\n    for (i = 0; i < 32; i++) {\n\n        if ((i & (RFPL - 1)) == 0)\n\n            cpu_fprintf(f, \"FPR%02d\", i);\n\n        cpu_fprintf(f, \" %016\" PRIx64, *((uint64_t *)&env->fpr[i]));\n\n        if ((i & (RFPL - 1)) == (RFPL - 1))\n\n            cpu_fprintf(f, \"\\n\");\n\n    }\n\n    cpu_fprintf(f, \"FPSCR %08x\\n\", env->fpscr);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    cpu_fprintf(f, \"SRR0 \" TARGET_FMT_lx \" SRR1 \" TARGET_FMT_lx \" SDR1 \"\n\n                TARGET_FMT_lx \"\\n\", env->spr[SPR_SRR0], env->spr[SPR_SRR1],\n\n                env->sdr1);\n\n#endif\n\n\n\n#undef RGPL\n\n#undef RFPL\n\n}\n", "idx": 23551}
{"project": "qemu", "commit_id": "0ff0fad23d3693ecf7a0c462cdb48f0e60f93808", "target": 0, "func": "static int sockaddr_to_str(char *dest, int max_len,\n\n                           struct sockaddr_storage *ss, socklen_t ss_len,\n\n                           struct sockaddr_storage *ps, socklen_t ps_len,\n\n                           bool is_listen, bool is_telnet)\n\n{\n\n    char shost[NI_MAXHOST], sserv[NI_MAXSERV];\n\n    char phost[NI_MAXHOST], pserv[NI_MAXSERV];\n\n    const char *left = \"\", *right = \"\";\n\n\n\n    switch (ss->ss_family) {\n\n#ifndef _WIN32\n\n    case AF_UNIX:\n\n        return snprintf(dest, max_len, \"unix:%s%s\",\n\n                        ((struct sockaddr_un *)(ss))->sun_path,\n\n                        is_listen ? \",server\" : \"\");\n\n#endif\n\n    case AF_INET6:\n\n        left  = \"[\";\n\n        right = \"]\";\n\n        /* fall through */\n\n    case AF_INET:\n\n        getnameinfo((struct sockaddr *) ss, ss_len, shost, sizeof(shost),\n\n                    sserv, sizeof(sserv), NI_NUMERICHOST | NI_NUMERICSERV);\n\n        getnameinfo((struct sockaddr *) ps, ps_len, phost, sizeof(phost),\n\n                    pserv, sizeof(pserv), NI_NUMERICHOST | NI_NUMERICSERV);\n\n        return snprintf(dest, max_len, \"%s:%s%s%s:%s%s <-> %s%s%s:%s\",\n\n                        is_telnet ? \"telnet\" : \"tcp\",\n\n                        left, shost, right, sserv,\n\n                        is_listen ? \",server\" : \"\",\n\n                        left, phost, right, pserv);\n\n\n\n    default:\n\n        return snprintf(dest, max_len, \"unknown\");\n\n    }\n\n}\n", "idx": 23552}
{"project": "qemu", "commit_id": "7e84c2498f0ff3999937d18d1e9abaa030400000", "target": 0, "func": "static inline unsigned int get_seg_limit(uint32_t e1, uint32_t e2)\n\n{\n\n    unsigned int limit;\n\n    limit = (e1 & 0xffff) | (e2 & 0x000f0000);\n\n    if (e2 & DESC_G_MASK)\n\n        limit = (limit << 12) | 0xfff;\n\n    return limit;\n\n}\n", "idx": 23553}
{"project": "qemu", "commit_id": "fbe2e26c15af35e4d157874dc80f6a19eebaa83b", "target": 0, "func": "void hmp_info_block(Monitor *mon, const QDict *qdict)\n\n{\n\n    BlockInfoList *block_list, *info;\n\n    ImageInfo *image_info;\n\n    const char *device = qdict_get_try_str(qdict, \"device\");\n\n    bool verbose = qdict_get_try_bool(qdict, \"verbose\", 0);\n\n\n\n    block_list = qmp_query_block(NULL);\n\n\n\n    for (info = block_list; info; info = info->next) {\n\n        if (device && strcmp(device, info->value->device)) {\n\n            continue;\n\n        }\n\n        monitor_printf(mon, \"%s: removable=%d\",\n\n                       info->value->device, info->value->removable);\n\n\n\n        if (info->value->removable) {\n\n            monitor_printf(mon, \" locked=%d\", info->value->locked);\n\n            monitor_printf(mon, \" tray-open=%d\", info->value->tray_open);\n\n        }\n\n\n\n        if (info->value->has_io_status) {\n\n            monitor_printf(mon, \" io-status=%s\",\n\n                           BlockDeviceIoStatus_lookup[info->value->io_status]);\n\n        }\n\n\n\n        if (info->value->has_inserted) {\n\n            monitor_printf(mon, \" file=\");\n\n            monitor_print_filename(mon, info->value->inserted->file);\n\n\n\n            if (info->value->inserted->has_backing_file) {\n\n                monitor_printf(mon, \" backing_file=\");\n\n                monitor_print_filename(mon, info->value->inserted->backing_file);\n\n                monitor_printf(mon, \" backing_file_depth=%\" PRId64,\n\n                    info->value->inserted->backing_file_depth);\n\n            }\n\n            monitor_printf(mon, \" ro=%d drv=%s encrypted=%d\",\n\n                           info->value->inserted->ro,\n\n                           info->value->inserted->drv,\n\n                           info->value->inserted->encrypted);\n\n\n\n            monitor_printf(mon, \" bps=%\" PRId64 \" bps_rd=%\" PRId64\n\n                            \" bps_wr=%\" PRId64 \" iops=%\" PRId64\n\n                            \" iops_rd=%\" PRId64 \" iops_wr=%\" PRId64,\n\n                            info->value->inserted->bps,\n\n                            info->value->inserted->bps_rd,\n\n                            info->value->inserted->bps_wr,\n\n                            info->value->inserted->iops,\n\n                            info->value->inserted->iops_rd,\n\n                            info->value->inserted->iops_wr);\n\n\n\n            if (verbose) {\n\n                monitor_printf(mon, \" images:\\n\");\n\n                image_info = info->value->inserted->image;\n\n                while (1) {\n\n                        bdrv_image_info_dump((fprintf_function)monitor_printf,\n\n                                             mon, image_info);\n\n                    if (image_info->has_backing_image) {\n\n                        image_info = image_info->backing_image;\n\n                    } else {\n\n                        break;\n\n                    }\n\n                }\n\n            }\n\n        } else {\n\n            monitor_printf(mon, \" [not inserted]\");\n\n        }\n\n\n\n        monitor_printf(mon, \"\\n\");\n\n    }\n\n\n\n    qapi_free_BlockInfoList(block_list);\n\n}\n", "idx": 23554}
{"project": "qemu", "commit_id": "3b00f702c236900cca403bdcbed48d59bfec0fba", "target": 0, "func": "static void s390_flic_common_realize(DeviceState *dev, Error **errp)\n\n{\n\n    S390FLICState *fs = S390_FLIC_COMMON(dev);\n\n    uint32_t max_batch = fs->adapter_routes_max_batch;\n\n\n\n    if (max_batch > ADAPTER_ROUTES_MAX_GSI) {\n\n        error_setg(errp, \"flic property adapter_routes_max_batch too big\"\n\n                   \" (%d > %d)\", max_batch, ADAPTER_ROUTES_MAX_GSI);\n\n    }\n\n\n\n    fs->ais_supported = true;\n\n}\n", "idx": 23555}
{"project": "qemu", "commit_id": "25f2895e0e437a3548f9794846001fb5d5ab853d", "target": 1, "func": "void kvm_arm_reset_vcpu(ARMCPU *cpu)\n\n{\n\n    /* Re-init VCPU so that all registers are set to\n\n     * their respective reset values.\n\n     */\n\n    kvm_arm_vcpu_init(CPU(cpu));\n\n    write_kvmstate_to_list(cpu);\n\n}\n", "idx": 23563}
{"project": "qemu", "commit_id": "e03c902cb617414dae49d77a810f6957ff7affac", "target": 1, "func": "static uint32_t icp_accept(struct icp_server_state *ss)\n\n{\n\n    uint32_t xirr = ss->xirr;\n\n\n\n    qemu_irq_lower(ss->output);\n\n    ss->xirr = ss->pending_priority << 24;\n\n\n\n\n    trace_xics_icp_accept(xirr, ss->xirr);\n\n\n\n    return xirr;\n\n}", "idx": 23564}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "VIOsPAPRBus *spapr_vio_bus_init(void)\n\n{\n\n    VIOsPAPRBus *bus;\n\n    BusState *qbus;\n\n    DeviceState *dev;\n\n\n\n    /* Create bridge device */\n\n    dev = qdev_create(NULL, \"spapr-vio-bridge\");\n\n    qdev_init_nofail(dev);\n\n\n\n    /* Create bus on bridge device */\n\n\n\n    qbus = qbus_create(TYPE_SPAPR_VIO_BUS, dev, \"spapr-vio\");\n\n    bus = DO_UPCAST(VIOsPAPRBus, bus, qbus);\n\n    bus->next_reg = 0x1000;\n\n\n\n    /* hcall-vio */\n\n    spapr_register_hypercall(H_VIO_SIGNAL, h_vio_signal);\n\n\n\n    /* hcall-tce */\n\n    spapr_register_hypercall(H_PUT_TCE, h_put_tce);\n\n\n\n    /* hcall-crq */\n\n    spapr_register_hypercall(H_REG_CRQ, h_reg_crq);\n\n    spapr_register_hypercall(H_FREE_CRQ, h_free_crq);\n\n    spapr_register_hypercall(H_SEND_CRQ, h_send_crq);\n\n    spapr_register_hypercall(H_ENABLE_CRQ, h_enable_crq);\n\n\n\n    /* RTAS calls */\n\n    spapr_rtas_register(\"ibm,set-tce-bypass\", rtas_set_tce_bypass);\n\n    spapr_rtas_register(\"quiesce\", rtas_quiesce);\n\n\n\n    return bus;\n\n}\n", "idx": 23565}
{"project": "qemu", "commit_id": "eb2f9b024d68884a3b25e63e4dbf90b67f8da236", "target": 1, "func": "static void vmsvga_update_display(void *opaque)\n\n{\n\n    struct vmsvga_state_s *s = opaque;\n\n    DisplaySurface *surface;\n\n    bool dirty = false;\n\n\n\n    if (!s->enable) {\n\n        s->vga.update(&s->vga);\n\n        return;\n\n    }\n\n\n\n    vmsvga_check_size(s);\n\n    surface = qemu_console_surface(s->vga.con);\n\n\n\n    vmsvga_fifo_run(s);\n\n    vmsvga_update_rect_flush(s);\n\n\n\n    /*\n\n     * Is it more efficient to look at vram VGA-dirty bits or wait\n\n     * for the driver to issue SVGA_CMD_UPDATE?\n\n     */\n\n    if (memory_region_is_logging(&s->vga.vram)) {\n\n        vga_sync_dirty_bitmap(&s->vga);\n\n        dirty = memory_region_get_dirty(&s->vga.vram, 0,\n\n            surface_stride(surface) * surface_height(surface),\n\n            DIRTY_MEMORY_VGA);\n\n    }\n\n    if (s->invalidated || dirty) {\n\n        s->invalidated = 0;\n\n        memcpy(surface_data(surface), s->vga.vram_ptr,\n\n               surface_stride(surface) * surface_height(surface));\n\n        dpy_gfx_update(s->vga.con, 0, 0,\n\n                   surface_width(surface), surface_height(surface));\n\n    }\n\n    if (dirty) {\n\n        memory_region_reset_dirty(&s->vga.vram, 0,\n\n            surface_stride(surface) * surface_height(surface),\n\n            DIRTY_MEMORY_VGA);\n\n    }\n\n}\n", "idx": 23567}
{"project": "qemu", "commit_id": "b3ebc10c373ed5922d4bdb5076fd0e9fd7ff8056", "target": 1, "func": "static void vfio_msi_interrupt(void *opaque)\n\n{\n\n    VFIOMSIVector *vector = opaque;\n\n    VFIODevice *vdev = vector->vdev;\n\n    int nr = vector - vdev->msi_vectors;\n\n\n\n    if (!event_notifier_test_and_clear(&vector->interrupt)) {\n\n        return;\n\n    }\n\n\n\n    DPRINTF(\"%s(%04x:%02x:%02x.%x) vector %d\\n\", __func__,\n\n            vdev->host.domain, vdev->host.bus, vdev->host.slot,\n\n            vdev->host.function, nr);\n\n\n\n    if (vdev->interrupt == VFIO_INT_MSIX) {\n\n        msix_notify(&vdev->pdev, nr);\n\n    } else if (vdev->interrupt == VFIO_INT_MSI) {\n\n        msi_notify(&vdev->pdev, nr);\n\n    } else {\n\n        error_report(\"vfio: MSI interrupt receieved, but not enabled?\");\n\n    }\n\n}\n", "idx": 23569}
{"project": "qemu", "commit_id": "e2f89926f19d2940eda070542501f39f51a8c81f", "target": 1, "func": "void usb_packet_unmap(USBPacket *p)\n\n{\n\n    int is_write = (p->pid == USB_TOKEN_IN);\n\n    int i;\n\n\n\n    for (i = 0; i < p->iov.niov; i++) {\n\n        cpu_physical_memory_unmap(p->iov.iov[i].iov_base,\n\n                                  p->iov.iov[i].iov_len, is_write,\n\n                                  p->iov.iov[i].iov_len);\n\n    }\n\n}\n", "idx": 23582}
{"project": "qemu", "commit_id": "3a95e3a7d9a6fd7610fe483778ff7016d23be5ec", "target": 0, "func": "static void gen_mfc0 (DisasContext *ctx, int reg, int sel)\n\n{\n\n    const char *rn = \"invalid\";\n\n\n\n    switch (reg) {\n\n    case 0:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mfc0_index();\n\n            rn = \"Index\";\n\n            break;\n\n        case 1:\n\n//            gen_op_mfc0_mvpcontrol(); /* MT ASE */\n\n            rn = \"MVPControl\";\n\n//            break;\n\n        case 2:\n\n//            gen_op_mfc0_mvpconf0(); /* MT ASE */\n\n            rn = \"MVPConf0\";\n\n//            break;\n\n        case 3:\n\n//            gen_op_mfc0_mvpconf1(); /* MT ASE */\n\n            rn = \"MVPConf1\";\n\n//            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 1:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mfc0_random();\n\n            rn = \"Random\";\n\n            break;\n\n        case 1:\n\n//            gen_op_mfc0_vpecontrol(); /* MT ASE */\n\n            rn = \"VPEControl\";\n\n//            break;\n\n        case 2:\n\n//            gen_op_mfc0_vpeconf0(); /* MT ASE */\n\n            rn = \"VPEConf0\";\n\n//            break;\n\n        case 3:\n\n//            gen_op_mfc0_vpeconf1(); /* MT ASE */\n\n            rn = \"VPEConf1\";\n\n//            break;\n\n        case 4:\n\n//            gen_op_mfc0_YQMask(); /* MT ASE */\n\n            rn = \"YQMask\";\n\n//            break;\n\n        case 5:\n\n//            gen_op_mfc0_vpeschedule(); /* MT ASE */\n\n            rn = \"VPESchedule\";\n\n//            break;\n\n        case 6:\n\n//            gen_op_mfc0_vpeschefback(); /* MT ASE */\n\n            rn = \"VPEScheFBack\";\n\n//            break;\n\n        case 7:\n\n//            gen_op_mfc0_vpeopt(); /* MT ASE */\n\n            rn = \"VPEOpt\";\n\n//            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 2:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mfc0_entrylo0();\n\n            rn = \"EntryLo0\";\n\n            break;\n\n        case 1:\n\n//            gen_op_mfc0_tcstatus(); /* MT ASE */\n\n            rn = \"TCStatus\";\n\n//            break;\n\n        case 2:\n\n//            gen_op_mfc0_tcbind(); /* MT ASE */\n\n            rn = \"TCBind\";\n\n//            break;\n\n        case 3:\n\n//            gen_op_mfc0_tcrestart(); /* MT ASE */\n\n            rn = \"TCRestart\";\n\n//            break;\n\n        case 4:\n\n//            gen_op_mfc0_tchalt(); /* MT ASE */\n\n            rn = \"TCHalt\";\n\n//            break;\n\n        case 5:\n\n//            gen_op_mfc0_tccontext(); /* MT ASE */\n\n            rn = \"TCContext\";\n\n//            break;\n\n        case 6:\n\n//            gen_op_mfc0_tcschedule(); /* MT ASE */\n\n            rn = \"TCSchedule\";\n\n//            break;\n\n        case 7:\n\n//            gen_op_mfc0_tcschefback(); /* MT ASE */\n\n            rn = \"TCScheFBack\";\n\n//            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 3:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mfc0_entrylo1();\n\n            rn = \"EntryLo1\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 4:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mfc0_context();\n\n            rn = \"Context\";\n\n            break;\n\n        case 1:\n\n//            gen_op_mfc0_contextconfig(); /* SmartMIPS ASE */\n\n            rn = \"ContextConfig\";\n\n//            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 5:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mfc0_pagemask();\n\n            rn = \"PageMask\";\n\n            break;\n\n        case 1:\n\n            gen_op_mfc0_pagegrain();\n\n            rn = \"PageGrain\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 6:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mfc0_wired();\n\n            rn = \"Wired\";\n\n            break;\n\n        case 1:\n\n//            gen_op_mfc0_srsconf0(); /* shadow registers */\n\n            rn = \"SRSConf0\";\n\n//            break;\n\n        case 2:\n\n//            gen_op_mfc0_srsconf1(); /* shadow registers */\n\n            rn = \"SRSConf1\";\n\n//            break;\n\n        case 3:\n\n//            gen_op_mfc0_srsconf2(); /* shadow registers */\n\n            rn = \"SRSConf2\";\n\n//            break;\n\n        case 4:\n\n//            gen_op_mfc0_srsconf3(); /* shadow registers */\n\n            rn = \"SRSConf3\";\n\n//            break;\n\n        case 5:\n\n//            gen_op_mfc0_srsconf4(); /* shadow registers */\n\n            rn = \"SRSConf4\";\n\n//            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 7:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mfc0_hwrena();\n\n            rn = \"HWREna\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 8:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mfc0_badvaddr();\n\n            rn = \"BadVaddr\";\n\n            break;\n\n        default:\n\n            goto die;\n\n       }\n\n        break;\n\n    case 9:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mfc0_count();\n\n            rn = \"Count\";\n\n            break;\n\n        /* 6,7 are implementation dependent */\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 10:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mfc0_entryhi();\n\n            rn = \"EntryHi\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 11:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mfc0_compare();\n\n            rn = \"Compare\";\n\n            break;\n\n        /* 6,7 are implementation dependent */\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 12:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mfc0_status();\n\n            rn = \"Status\";\n\n            break;\n\n        case 1:\n\n            gen_op_mfc0_intctl();\n\n            rn = \"IntCtl\";\n\n            break;\n\n        case 2:\n\n            gen_op_mfc0_srsctl();\n\n            rn = \"SRSCtl\";\n\n            break;\n\n        case 3:\n\n            gen_op_mfc0_srsmap();\n\n            rn = \"SRSMap\";\n\n            break;\n\n        default:\n\n            goto die;\n\n       }\n\n        break;\n\n    case 13:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mfc0_cause();\n\n            rn = \"Cause\";\n\n            break;\n\n        default:\n\n            goto die;\n\n       }\n\n        break;\n\n    case 14:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mfc0_epc();\n\n            rn = \"EPC\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 15:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mfc0_prid();\n\n            rn = \"PRid\";\n\n            break;\n\n        case 1:\n\n            gen_op_mfc0_ebase();\n\n            rn = \"EBase\";\n\n            break;\n\n        default:\n\n            goto die;\n\n       }\n\n        break;\n\n    case 16:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mfc0_config0();\n\n            rn = \"Config\";\n\n            break;\n\n        case 1:\n\n            gen_op_mfc0_config1();\n\n            rn = \"Config1\";\n\n            break;\n\n        case 2:\n\n            gen_op_mfc0_config2();\n\n            rn = \"Config2\";\n\n            break;\n\n        case 3:\n\n            gen_op_mfc0_config3();\n\n            rn = \"Config3\";\n\n            break;\n\n        /* 4,5 are reserved */\n\n        /* 6,7 are implementation dependent */\n\n        case 6:\n\n            gen_op_mfc0_config6();\n\n            rn = \"Config6\";\n\n            break;\n\n        case 7:\n\n            gen_op_mfc0_config7();\n\n            rn = \"Config7\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 17:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mfc0_lladdr();\n\n            rn = \"LLAddr\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 18:\n\n        switch (sel) {\n\n        case 0 ... 7:\n\n            gen_op_mfc0_watchlo(sel);\n\n            rn = \"WatchLo\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 19:\n\n        switch (sel) {\n\n        case 0 ...7:\n\n            gen_op_mfc0_watchhi(sel);\n\n            rn = \"WatchHi\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 20:\n\n        switch (sel) {\n\n        case 0:\n\n#ifdef TARGET_MIPS64\n\n            gen_op_mfc0_xcontext();\n\n            rn = \"XContext\";\n\n            break;\n\n#endif\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 21:\n\n       /* Officially reserved, but sel 0 is used for R1x000 framemask */\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mfc0_framemask();\n\n            rn = \"Framemask\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 22:\n\n        /* ignored */\n\n        rn = \"'Diagnostic\"; /* implementation dependent */\n\n        break;\n\n    case 23:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mfc0_debug(); /* EJTAG support */\n\n            rn = \"Debug\";\n\n            break;\n\n        case 1:\n\n//            gen_op_mfc0_tracecontrol(); /* PDtrace support */\n\n            rn = \"TraceControl\";\n\n//            break;\n\n        case 2:\n\n//            gen_op_mfc0_tracecontrol2(); /* PDtrace support */\n\n            rn = \"TraceControl2\";\n\n//            break;\n\n        case 3:\n\n//            gen_op_mfc0_usertracedata(); /* PDtrace support */\n\n            rn = \"UserTraceData\";\n\n//            break;\n\n        case 4:\n\n//            gen_op_mfc0_debug(); /* PDtrace support */\n\n            rn = \"TraceBPC\";\n\n//            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 24:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mfc0_depc(); /* EJTAG support */\n\n            rn = \"DEPC\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 25:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mfc0_performance0();\n\n            rn = \"Performance0\";\n\n            break;\n\n        case 1:\n\n//            gen_op_mfc0_performance1();\n\n            rn = \"Performance1\";\n\n//            break;\n\n        case 2:\n\n//            gen_op_mfc0_performance2();\n\n            rn = \"Performance2\";\n\n//            break;\n\n        case 3:\n\n//            gen_op_mfc0_performance3();\n\n            rn = \"Performance3\";\n\n//            break;\n\n        case 4:\n\n//            gen_op_mfc0_performance4();\n\n            rn = \"Performance4\";\n\n//            break;\n\n        case 5:\n\n//            gen_op_mfc0_performance5();\n\n            rn = \"Performance5\";\n\n//            break;\n\n        case 6:\n\n//            gen_op_mfc0_performance6();\n\n            rn = \"Performance6\";\n\n//            break;\n\n        case 7:\n\n//            gen_op_mfc0_performance7();\n\n            rn = \"Performance7\";\n\n//            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 26:\n\n       rn = \"ECC\";\n\n       break;\n\n    case 27:\n\n        switch (sel) {\n\n        /* ignored */\n\n        case 0 ... 3:\n\n            rn = \"CacheErr\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 28:\n\n        switch (sel) {\n\n        case 0:\n\n        case 2:\n\n        case 4:\n\n        case 6:\n\n            gen_op_mfc0_taglo();\n\n            rn = \"TagLo\";\n\n            break;\n\n        case 1:\n\n        case 3:\n\n        case 5:\n\n        case 7:\n\n            gen_op_mfc0_datalo();\n\n            rn = \"DataLo\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 29:\n\n        switch (sel) {\n\n        case 0:\n\n        case 2:\n\n        case 4:\n\n        case 6:\n\n            gen_op_mfc0_taghi();\n\n            rn = \"TagHi\";\n\n            break;\n\n        case 1:\n\n        case 3:\n\n        case 5:\n\n        case 7:\n\n            gen_op_mfc0_datahi();\n\n            rn = \"DataHi\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 30:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mfc0_errorepc();\n\n            rn = \"ErrorEPC\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 31:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mfc0_desave(); /* EJTAG support */\n\n            rn = \"DESAVE\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    default:\n\n       goto die;\n\n    }\n\n#if defined MIPS_DEBUG_DISAS\n\n    if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n        fprintf(logfile, \"mfc0 %s (reg %d sel %d)\\n\",\n\n                rn, reg, sel);\n\n    }\n\n#endif\n\n    return;\n\n\n\ndie:\n\n#if defined MIPS_DEBUG_DISAS\n\n    if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n        fprintf(logfile, \"mfc0 %s (reg %d sel %d)\\n\",\n\n                rn, reg, sel);\n\n    }\n\n#endif\n\n    generate_exception(ctx, EXCP_RI);\n\n}\n", "idx": 23583}
{"project": "qemu", "commit_id": "bec1631100323fac0900aea71043d5c4e22fc2fa", "target": 0, "func": "static void tgen_branch(TCGContext *s, int cc, int labelno)\n\n{\n\n    TCGLabel* l = &s->labels[labelno];\n\n    if (l->has_value) {\n\n        tgen_gotoi(s, cc, l->u.value_ptr);\n\n    } else if (USE_LONG_BRANCHES) {\n\n        tcg_out16(s, RIL_BRCL | (cc << 4));\n\n        tcg_out_reloc(s, s->code_ptr, R_390_PC32DBL, labelno, -2);\n\n        s->code_ptr += 2;\n\n    } else {\n\n        tcg_out16(s, RI_BRC | (cc << 4));\n\n        tcg_out_reloc(s, s->code_ptr, R_390_PC16DBL, labelno, -2);\n\n        s->code_ptr += 1;\n\n    }\n\n}\n", "idx": 23585}
{"project": "qemu", "commit_id": "e7d336959b7c01699702dcda4b54a822972d74a8", "target": 0, "func": "static void s390_pci_generate_event(uint8_t cc, uint16_t pec, uint32_t fh,\n\n                                    uint32_t fid, uint64_t faddr, uint32_t e)\n\n{\n\n    SeiContainer *sei_cont;\n\n    S390pciState *s = S390_PCI_HOST_BRIDGE(\n\n        object_resolve_path(TYPE_S390_PCI_HOST_BRIDGE, NULL));\n\n\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    sei_cont = g_malloc0(sizeof(SeiContainer));\n\n    sei_cont->fh = fh;\n\n    sei_cont->fid = fid;\n\n    sei_cont->cc = cc;\n\n    sei_cont->pec = pec;\n\n    sei_cont->faddr = faddr;\n\n    sei_cont->e = e;\n\n\n\n    QTAILQ_INSERT_TAIL(&s->pending_sei, sei_cont, link);\n\n    css_generate_css_crws(0);\n\n}\n", "idx": 23586}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "void do_load_dcr (void)\n\n{\n\n    target_ulong val;\n\n\n\n    if (unlikely(env->dcr_env == NULL)) {\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"No DCR environment\\n\");\n\n        }\n\n        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_INVAL_INVAL);\n\n    } else if (unlikely(ppc_dcr_read(env->dcr_env, T0, &val) != 0)) {\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"DCR read error %d %03x\\n\", (int)T0, (int)T0);\n\n        }\n\n        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_PRIV_REG);\n\n    } else {\n\n        T0 = val;\n\n    }\n\n}\n", "idx": 23587}
{"project": "qemu", "commit_id": "a307d59434ba78b97544b42b8cfd24a1b62e39a6", "target": 0, "func": "static void pci_spapr_set_irq(void *opaque, int irq_num, int level)\n\n{\n\n    /*\n\n     * Here we use the number returned by pci_spapr_map_irq to find a\n\n     * corresponding qemu_irq.\n\n     */\n\n    sPAPRPHBState *phb = opaque;\n\n\n\n    qemu_set_irq(phb->lsi_table[irq_num].qirq, level);\n\n}\n", "idx": 23588}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_in_native_list_int64(TestInputVisitorData *data,\n\n                                              const void *unused)\n\n{\n\n    test_native_list_integer_helper(data, unused,\n\n                                    USER_DEF_NATIVE_LIST_UNION_KIND_S64);\n\n}\n", "idx": 23589}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "static void qint_destroy_obj(QObject *obj)\n\n{\n\n    assert(obj != NULL);\n\n    g_free(qobject_to_qint(obj));\n\n}\n", "idx": 23590}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static void test_io_channel(bool async,\n\n                            SocketAddress *listen_addr,\n\n                            SocketAddress *connect_addr,\n\n                            bool passFD)\n\n{\n\n    QIOChannel *src, *dst;\n\n    QIOChannelTest *test;\n\n    if (async) {\n\n        test_io_channel_setup_async(listen_addr, connect_addr, &src, &dst);\n\n\n\n        g_assert(!passFD ||\n\n                 qio_channel_has_feature(src, QIO_CHANNEL_FEATURE_FD_PASS));\n\n        g_assert(!passFD ||\n\n                 qio_channel_has_feature(dst, QIO_CHANNEL_FEATURE_FD_PASS));\n\n        g_assert(qio_channel_has_feature(src, QIO_CHANNEL_FEATURE_SHUTDOWN));\n\n        g_assert(qio_channel_has_feature(dst, QIO_CHANNEL_FEATURE_SHUTDOWN));\n\n\n\n        test = qio_channel_test_new();\n\n        qio_channel_test_run_threads(test, true, src, dst);\n\n        qio_channel_test_validate(test);\n\n\n\n        object_unref(OBJECT(src));\n\n        object_unref(OBJECT(dst));\n\n\n\n        test_io_channel_setup_async(listen_addr, connect_addr, &src, &dst);\n\n\n\n        g_assert(!passFD ||\n\n                 qio_channel_has_feature(src, QIO_CHANNEL_FEATURE_FD_PASS));\n\n        g_assert(!passFD ||\n\n                 qio_channel_has_feature(dst, QIO_CHANNEL_FEATURE_FD_PASS));\n\n        g_assert(qio_channel_has_feature(src, QIO_CHANNEL_FEATURE_SHUTDOWN));\n\n        g_assert(qio_channel_has_feature(dst, QIO_CHANNEL_FEATURE_SHUTDOWN));\n\n\n\n        test = qio_channel_test_new();\n\n        qio_channel_test_run_threads(test, false, src, dst);\n\n        qio_channel_test_validate(test);\n\n\n\n        object_unref(OBJECT(src));\n\n        object_unref(OBJECT(dst));\n\n    } else {\n\n        test_io_channel_setup_sync(listen_addr, connect_addr, &src, &dst);\n\n\n\n        g_assert(!passFD ||\n\n                 qio_channel_has_feature(src, QIO_CHANNEL_FEATURE_FD_PASS));\n\n        g_assert(!passFD ||\n\n                 qio_channel_has_feature(dst, QIO_CHANNEL_FEATURE_FD_PASS));\n\n        g_assert(qio_channel_has_feature(src, QIO_CHANNEL_FEATURE_SHUTDOWN));\n\n        g_assert(qio_channel_has_feature(dst, QIO_CHANNEL_FEATURE_SHUTDOWN));\n\n\n\n        test = qio_channel_test_new();\n\n        qio_channel_test_run_threads(test, true, src, dst);\n\n        qio_channel_test_validate(test);\n\n\n\n        object_unref(OBJECT(src));\n\n        object_unref(OBJECT(dst));\n\n\n\n        test_io_channel_setup_sync(listen_addr, connect_addr, &src, &dst);\n\n\n\n        g_assert(!passFD ||\n\n                 qio_channel_has_feature(src, QIO_CHANNEL_FEATURE_FD_PASS));\n\n        g_assert(!passFD ||\n\n                 qio_channel_has_feature(dst, QIO_CHANNEL_FEATURE_FD_PASS));\n\n        g_assert(qio_channel_has_feature(src, QIO_CHANNEL_FEATURE_SHUTDOWN));\n\n        g_assert(qio_channel_has_feature(dst, QIO_CHANNEL_FEATURE_SHUTDOWN));\n\n\n\n        test = qio_channel_test_new();\n\n        qio_channel_test_run_threads(test, false, src, dst);\n\n        qio_channel_test_validate(test);\n\n\n\n        object_unref(OBJECT(src));\n\n        object_unref(OBJECT(dst));\n\n    }\n\n}\n", "idx": 23591}
{"project": "qemu", "commit_id": "d1eb8f2acba579830cf3798c3c15ce51be852c56", "target": 0, "func": "int floatx80_le(floatx80 a, floatx80 b, float_status *status)\n\n{\n\n    flag aSign, bSign;\n\n\n\n    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )\n\n              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )\n\n         || (    ( extractFloatx80Exp( b ) == 0x7FFF )\n\n              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )\n\n       ) {\n\n        float_raise(float_flag_invalid, status);\n\n        return 0;\n\n    }\n\n    aSign = extractFloatx80Sign( a );\n\n    bSign = extractFloatx80Sign( b );\n\n    if ( aSign != bSign ) {\n\n        return\n\n               aSign\n\n            || (    ( ( (uint16_t) ( ( a.high | b.high )<<1 ) ) | a.low | b.low )\n\n                 == 0 );\n\n    }\n\n    return\n\n          aSign ? le128( b.high, b.low, a.high, a.low )\n\n        : le128( a.high, a.low, b.high, b.low );\n\n\n\n}\n", "idx": 23592}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int coroutine_fn bdrv_co_writev(BlockDriverState *bs, int64_t sector_num,\n\n    int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    trace_bdrv_co_writev(bs, sector_num, nb_sectors);\n\n\n\n    return bdrv_co_do_writev(bs, sector_num, nb_sectors, qiov, 0);\n\n}\n", "idx": 23593}
{"project": "qemu", "commit_id": "7e01376daea75e888c370aab521a7d4aeaf2ffd1", "target": 0, "func": "int ioinst_handle_tsch(S390CPU *cpu, uint64_t reg1, uint32_t ipb)\n\n{\n\n    CPUS390XState *env = &cpu->env;\n\n    int cssid, ssid, schid, m;\n\n    SubchDev *sch;\n\n    IRB irb;\n\n    uint64_t addr;\n\n    int cc, irb_len;\n\n    uint8_t ar;\n\n\n\n    if (ioinst_disassemble_sch_ident(reg1, &m, &cssid, &ssid, &schid)) {\n\n        program_interrupt(env, PGM_OPERAND, 2);\n\n        return -EIO;\n\n    }\n\n    trace_ioinst_sch_id(\"tsch\", cssid, ssid, schid);\n\n    addr = decode_basedisp_s(env, ipb, &ar);\n\n    if (addr & 3) {\n\n        program_interrupt(env, PGM_SPECIFICATION, 2);\n\n        return -EIO;\n\n    }\n\n\n\n    sch = css_find_subch(m, cssid, ssid, schid);\n\n    if (sch && css_subch_visible(sch)) {\n\n        cc = css_do_tsch_get_irb(sch, &irb, &irb_len);\n\n    } else {\n\n        cc = 3;\n\n    }\n\n    /* 0 - status pending, 1 - not status pending, 3 - not operational */\n\n    if (cc != 3) {\n\n        if (s390_cpu_virt_mem_write(cpu, addr, ar, &irb, irb_len) != 0) {\n\n            return -EFAULT;\n\n        }\n\n        css_do_tsch_update_subch(sch);\n\n    } else {\n\n        irb_len = sizeof(irb) - sizeof(irb.emw);\n\n        /* Access exceptions have a higher priority than cc3 */\n\n        if (s390_cpu_virt_mem_check_write(cpu, addr, ar, irb_len) != 0) {\n\n            return -EFAULT;\n\n        }\n\n    }\n\n\n\n    setcc(cpu, cc);\n\n    return 0;\n\n}\n", "idx": 23594}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "size_t v9fs_pack(struct iovec *in_sg, int in_num, size_t offset,\n\n                const void *src, size_t size)\n\n{\n\n    return v9fs_packunpack((void *)src, in_sg, in_num, offset, size, 1);\n\n}\n", "idx": 23596}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "void usb_packet_setup(USBPacket *p, int pid, uint8_t addr, uint8_t ep)\n\n{\n\n    assert(!usb_packet_is_inflight(p));\n\n    p->state = USB_PACKET_SETUP;\n\n    p->pid = pid;\n\n    p->devaddr = addr;\n\n    p->devep = ep;\n\n    p->result = 0;\n\n    qemu_iovec_reset(&p->iov);\n\n}\n", "idx": 23597}
{"project": "qemu", "commit_id": "75822a12c046646684bc8cad6296842b60e7b6bb", "target": 0, "func": "int nbd_client_init(BlockDriverState *bs, QIOChannelSocket *sioc,\n\n                    const char *export, Error **errp)\n\n{\n\n    NbdClientSession *client = nbd_get_client_session(bs);\n\n    int ret;\n\n\n\n    /* NBD handshake */\n\n    logout(\"session init %s\\n\", export);\n\n    qio_channel_set_blocking(QIO_CHANNEL(sioc), true, NULL);\n\n\n\n    ret = nbd_receive_negotiate(QIO_CHANNEL(sioc), export,\n\n                                &client->nbdflags,\n\n                                NULL, NULL,\n\n                                &client->ioc,\n\n                                &client->size, errp);\n\n    if (ret < 0) {\n\n        logout(\"Failed to negotiate with the NBD server\\n\");\n\n        return ret;\n\n    }\n\n\n\n    qemu_co_mutex_init(&client->send_mutex);\n\n    qemu_co_mutex_init(&client->free_sema);\n\n    client->sioc = sioc;\n\n    object_ref(OBJECT(client->sioc));\n\n\n\n    if (!client->ioc) {\n\n        client->ioc = QIO_CHANNEL(sioc);\n\n        object_ref(OBJECT(client->ioc));\n\n    }\n\n\n\n    /* Now that we're connected, set the socket to be non-blocking and\n\n     * kick the reply mechanism.  */\n\n    qio_channel_set_blocking(QIO_CHANNEL(sioc), false, NULL);\n\n\n\n    nbd_client_attach_aio_context(bs, bdrv_get_aio_context(bs));\n\n\n\n    logout(\"Established connection with NBD server\\n\");\n\n    return 0;\n\n}\n", "idx": 23598}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void cuda_writel (void *opaque, target_phys_addr_t addr, uint32_t value)\n\n{\n\n}\n", "idx": 23599}
{"project": "qemu", "commit_id": "bec1631100323fac0900aea71043d5c4e22fc2fa", "target": 0, "func": "static void tcg_out_brcond64(TCGContext *s, TCGCond cond,\n\n                             TCGArg arg1, TCGArg arg2, int const_arg2,\n\n                             int label_index, int small)\n\n{\n\n    tcg_out_cmp(s, arg1, arg2, const_arg2, P_REXW);\n\n    tcg_out_jxx(s, tcg_cond_to_jcc[cond], label_index, small);\n\n}\n", "idx": 23600}
{"project": "qemu", "commit_id": "3e21ffc954c09e90b25a446813ff1c0b26817aef", "target": 0, "func": "static void pci_init_wmask(PCIDevice *dev)\n\n{\n\n    int i;\n\n    int config_size = pci_config_size(dev);\n\n\n\n    dev->wmask[PCI_CACHE_LINE_SIZE] = 0xff;\n\n    dev->wmask[PCI_INTERRUPT_LINE] = 0xff;\n\n    pci_set_word(dev->wmask + PCI_COMMAND,\n\n                 PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);\n\n    for (i = PCI_CONFIG_HEADER_SIZE; i < config_size; ++i)\n\n        dev->wmask[i] = 0xff;\n\n}\n", "idx": 23601}
{"project": "qemu", "commit_id": "b7680cb6078bd7294a3dd86473d3f2fdee991dd0", "target": 0, "func": "static void *vnc_worker_thread(void *arg)\n\n{\n\n    VncJobQueue *queue = arg;\n\n\n\n    qemu_thread_self(&queue->thread);\n\n\n\n    while (!vnc_worker_thread_loop(queue)) ;\n\n    vnc_queue_clear(queue);\n\n    return NULL;\n\n}\n", "idx": 23602}
{"project": "qemu", "commit_id": "871d2f079661323a7645b388eb5ae8d7eeb3117c", "target": 0, "func": "int qemu_savevm_state(QEMUFile *f)\n\n{\n\n    int saved_vm_running;\n\n    int ret;\n\n\n\n    saved_vm_running = vm_running;\n\n    vm_stop(0);\n\n\n\n    ret = qemu_savevm_state_begin(f);\n\n    if (ret < 0)\n\n        goto out;\n\n\n\n    do {\n\n        ret = qemu_savevm_state_iterate(f);\n\n        if (ret < 0)\n\n            goto out;\n\n    } while (ret == 0);\n\n\n\n    ret = qemu_savevm_state_complete(f);\n\n\n\nout:\n\n    if (saved_vm_running)\n\n        vm_start();\n\n    return ret;\n\n}\n", "idx": 23603}
{"project": "qemu", "commit_id": "c9fbb99d41b05acf0d7b93deb2fcdbf9047c238e", "target": 0, "func": "static int vmdk_create(const char *filename, QEMUOptionParameter *options,\n\n                       Error **errp)\n\n{\n\n    int fd, idx = 0;\n\n    char desc[BUF_SIZE];\n\n    int64_t total_size = 0, filesize;\n\n    const char *adapter_type = NULL;\n\n    const char *backing_file = NULL;\n\n    const char *fmt = NULL;\n\n    int flags = 0;\n\n    int ret = 0;\n\n    bool flat, split, compress;\n\n    char ext_desc_lines[BUF_SIZE] = \"\";\n\n    char path[PATH_MAX], prefix[PATH_MAX], postfix[PATH_MAX];\n\n    const int64_t split_size = 0x80000000;  /* VMDK has constant split size */\n\n    const char *desc_extent_line;\n\n    char parent_desc_line[BUF_SIZE] = \"\";\n\n    uint32_t parent_cid = 0xffffffff;\n\n    uint32_t number_heads = 16;\n\n    bool zeroed_grain = false;\n\n    const char desc_template[] =\n\n        \"# Disk DescriptorFile\\n\"\n\n        \"version=1\\n\"\n\n        \"CID=%x\\n\"\n\n        \"parentCID=%x\\n\"\n\n        \"createType=\\\"%s\\\"\\n\"\n\n        \"%s\"\n\n        \"\\n\"\n\n        \"# Extent description\\n\"\n\n        \"%s\"\n\n        \"\\n\"\n\n        \"# The Disk Data Base\\n\"\n\n        \"#DDB\\n\"\n\n        \"\\n\"\n\n        \"ddb.virtualHWVersion = \\\"%d\\\"\\n\"\n\n        \"ddb.geometry.cylinders = \\\"%\" PRId64 \"\\\"\\n\"\n\n        \"ddb.geometry.heads = \\\"%d\\\"\\n\"\n\n        \"ddb.geometry.sectors = \\\"63\\\"\\n\"\n\n        \"ddb.adapterType = \\\"%s\\\"\\n\";\n\n\n\n    if (filename_decompose(filename, path, prefix, postfix, PATH_MAX, errp)) {\n\n        return -EINVAL;\n\n    }\n\n    /* Read out options */\n\n    while (options && options->name) {\n\n        if (!strcmp(options->name, BLOCK_OPT_SIZE)) {\n\n            total_size = options->value.n;\n\n        } else if (!strcmp(options->name, BLOCK_OPT_ADAPTER_TYPE)) {\n\n            adapter_type = options->value.s;\n\n        } else if (!strcmp(options->name, BLOCK_OPT_BACKING_FILE)) {\n\n            backing_file = options->value.s;\n\n        } else if (!strcmp(options->name, BLOCK_OPT_COMPAT6)) {\n\n            flags |= options->value.n ? BLOCK_FLAG_COMPAT6 : 0;\n\n        } else if (!strcmp(options->name, BLOCK_OPT_SUBFMT)) {\n\n            fmt = options->value.s;\n\n        } else if (!strcmp(options->name, BLOCK_OPT_ZEROED_GRAIN)) {\n\n            zeroed_grain |= options->value.n;\n\n        }\n\n        options++;\n\n    }\n\n    if (!adapter_type) {\n\n        adapter_type = \"ide\";\n\n    } else if (strcmp(adapter_type, \"ide\") &&\n\n               strcmp(adapter_type, \"buslogic\") &&\n\n               strcmp(adapter_type, \"lsilogic\") &&\n\n               strcmp(adapter_type, \"legacyESX\")) {\n\n        error_setg(errp, \"Unknown adapter type: '%s'\", adapter_type);\n\n        return -EINVAL;\n\n    }\n\n    if (strcmp(adapter_type, \"ide\") != 0) {\n\n        /* that's the number of heads with which vmware operates when\n\n           creating, exporting, etc. vmdk files with a non-ide adapter type */\n\n        number_heads = 255;\n\n    }\n\n    if (!fmt) {\n\n        /* Default format to monolithicSparse */\n\n        fmt = \"monolithicSparse\";\n\n    } else if (strcmp(fmt, \"monolithicFlat\") &&\n\n               strcmp(fmt, \"monolithicSparse\") &&\n\n               strcmp(fmt, \"twoGbMaxExtentSparse\") &&\n\n               strcmp(fmt, \"twoGbMaxExtentFlat\") &&\n\n               strcmp(fmt, \"streamOptimized\")) {\n\n        error_setg(errp, \"Unknown subformat: '%s'\", fmt);\n\n        return -EINVAL;\n\n    }\n\n    split = !(strcmp(fmt, \"twoGbMaxExtentFlat\") &&\n\n              strcmp(fmt, \"twoGbMaxExtentSparse\"));\n\n    flat = !(strcmp(fmt, \"monolithicFlat\") &&\n\n             strcmp(fmt, \"twoGbMaxExtentFlat\"));\n\n    compress = !strcmp(fmt, \"streamOptimized\");\n\n    if (flat) {\n\n        desc_extent_line = \"RW %lld FLAT \\\"%s\\\" 0\\n\";\n\n    } else {\n\n        desc_extent_line = \"RW %lld SPARSE \\\"%s\\\"\\n\";\n\n    }\n\n    if (flat && backing_file) {\n\n        error_setg(errp, \"Flat image can't have backing file\");\n\n        return -ENOTSUP;\n\n    }\n\n    if (flat && zeroed_grain) {\n\n        error_setg(errp, \"Flat image can't enable zeroed grain\");\n\n        return -ENOTSUP;\n\n    }\n\n    if (backing_file) {\n\n        BlockDriverState *bs = bdrv_new(\"\");\n\n        ret = bdrv_open(bs, backing_file, NULL, 0, NULL, errp);\n\n        if (ret != 0) {\n\n            bdrv_unref(bs);\n\n            return ret;\n\n        }\n\n        if (strcmp(bs->drv->format_name, \"vmdk\")) {\n\n            bdrv_unref(bs);\n\n            return -EINVAL;\n\n        }\n\n        parent_cid = vmdk_read_cid(bs, 0);\n\n        bdrv_unref(bs);\n\n        snprintf(parent_desc_line, sizeof(parent_desc_line),\n\n                \"parentFileNameHint=\\\"%s\\\"\", backing_file);\n\n    }\n\n\n\n    /* Create extents */\n\n    filesize = total_size;\n\n    while (filesize > 0) {\n\n        char desc_line[BUF_SIZE];\n\n        char ext_filename[PATH_MAX];\n\n        char desc_filename[PATH_MAX];\n\n        int64_t size = filesize;\n\n\n\n        if (split && size > split_size) {\n\n            size = split_size;\n\n        }\n\n        if (split) {\n\n            snprintf(desc_filename, sizeof(desc_filename), \"%s-%c%03d%s\",\n\n                    prefix, flat ? 'f' : 's', ++idx, postfix);\n\n        } else if (flat) {\n\n            snprintf(desc_filename, sizeof(desc_filename), \"%s-flat%s\",\n\n                    prefix, postfix);\n\n        } else {\n\n            snprintf(desc_filename, sizeof(desc_filename), \"%s%s\",\n\n                    prefix, postfix);\n\n        }\n\n        snprintf(ext_filename, sizeof(ext_filename), \"%s%s\",\n\n                path, desc_filename);\n\n\n\n        if (vmdk_create_extent(ext_filename, size,\n\n                               flat, compress, zeroed_grain)) {\n\n            return -EINVAL;\n\n        }\n\n        filesize -= size;\n\n\n\n        /* Format description line */\n\n        snprintf(desc_line, sizeof(desc_line),\n\n                    desc_extent_line, size / 512, desc_filename);\n\n        pstrcat(ext_desc_lines, sizeof(ext_desc_lines), desc_line);\n\n    }\n\n    /* generate descriptor file */\n\n    snprintf(desc, sizeof(desc), desc_template,\n\n            (unsigned int)time(NULL),\n\n            parent_cid,\n\n            fmt,\n\n            parent_desc_line,\n\n            ext_desc_lines,\n\n            (flags & BLOCK_FLAG_COMPAT6 ? 6 : 4),\n\n            total_size / (int64_t)(63 * number_heads * 512), number_heads,\n\n                adapter_type);\n\n    if (split || flat) {\n\n        fd = qemu_open(filename,\n\n                       O_WRONLY | O_CREAT | O_TRUNC | O_BINARY | O_LARGEFILE,\n\n                       0644);\n\n    } else {\n\n        fd = qemu_open(filename,\n\n                       O_WRONLY | O_BINARY | O_LARGEFILE,\n\n                       0644);\n\n    }\n\n    if (fd < 0) {\n\n        return -errno;\n\n    }\n\n    /* the descriptor offset = 0x200 */\n\n    if (!split && !flat && 0x200 != lseek(fd, 0x200, SEEK_SET)) {\n\n        ret = -errno;\n\n        goto exit;\n\n    }\n\n    ret = qemu_write_full(fd, desc, strlen(desc));\n\n    if (ret != strlen(desc)) {\n\n        ret = -errno;\n\n        goto exit;\n\n    }\n\n    ret = 0;\n\nexit:\n\n    qemu_close(fd);\n\n    return ret;\n\n}\n", "idx": 23604}
{"project": "qemu", "commit_id": "46c5874e9cd752ed8ded31af03472edd8fc3efc1", "target": 0, "func": "static void rtas_ibm_get_config_addr_info2(PowerPCCPU *cpu,\n\n                                           sPAPREnvironment *spapr,\n\n                                           uint32_t token, uint32_t nargs,\n\n                                           target_ulong args, uint32_t nret,\n\n                                           target_ulong rets)\n\n{\n\n    sPAPRPHBState *sphb;\n\n    sPAPRPHBClass *spc;\n\n    PCIDevice *pdev;\n\n    uint32_t addr, option;\n\n    uint64_t buid;\n\n\n\n    if ((nargs != 4) || (nret != 2)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    buid = ((uint64_t)rtas_ld(args, 1) << 32) | rtas_ld(args, 2);\n\n    sphb = find_phb(spapr, buid);\n\n    if (!sphb) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb);\n\n    if (!spc->eeh_set_option) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    /*\n\n     * We always have PE address of form \"00BB0001\". \"BB\"\n\n     * represents the bus number of PE's primary bus.\n\n     */\n\n    option = rtas_ld(args, 3);\n\n    switch (option) {\n\n    case RTAS_GET_PE_ADDR:\n\n        addr = rtas_ld(args, 0);\n\n        pdev = find_dev(spapr, buid, addr);\n\n        if (!pdev) {\n\n            goto param_error_exit;\n\n        }\n\n\n\n        rtas_st(rets, 1, (pci_bus_num(pdev->bus) << 16) + 1);\n\n        break;\n\n    case RTAS_GET_PE_MODE:\n\n        rtas_st(rets, 1, RTAS_PE_MODE_SHARED);\n\n        break;\n\n    default:\n\n        goto param_error_exit;\n\n    }\n\n\n\n    rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n    return;\n\n\n\nparam_error_exit:\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n", "idx": 23605}
{"project": "qemu", "commit_id": "c363acef772647f66becdbf46dd54e70e67f3cc9", "target": 0, "func": "__org_qemu_x_Union1 *qmp___org_qemu_x_command(__org_qemu_x_EnumList *a,\n\n                                              __org_qemu_x_StructList *b,\n\n                                              __org_qemu_x_Union2 *c,\n\n                                              __org_qemu_x_Alt *d,\n\n                                              Error **errp)\n\n{\n\n    __org_qemu_x_Union1 *ret = g_new0(__org_qemu_x_Union1, 1);\n\n\n\n    ret->kind = ORG_QEMU_X_UNION1_KIND___ORG_QEMU_X_BRANCH;\n\n    ret->__org_qemu_x_branch = strdup(\"blah1\");\n\n\n\n    return ret;\n\n}\n", "idx": 23606}
{"project": "qemu", "commit_id": "63f0f45f2e89b60ff8245fec81328ddfde42a303", "target": 0, "func": "static CURLState *curl_init_state(BDRVCURLState *s)\n\n{\n\n    CURLState *state = NULL;\n\n    int i, j;\n\n\n\n    do {\n\n        for (i=0; i<CURL_NUM_STATES; i++) {\n\n            for (j=0; j<CURL_NUM_ACB; j++)\n\n                if (s->states[i].acb[j])\n\n                    continue;\n\n            if (s->states[i].in_use)\n\n                continue;\n\n\n\n            state = &s->states[i];\n\n            state->in_use = 1;\n\n            break;\n\n        }\n\n        if (!state) {\n\n            qemu_aio_wait();\n\n        }\n\n    } while(!state);\n\n\n\n    if (!state->curl) {\n\n        state->curl = curl_easy_init();\n\n        if (!state->curl) {\n\n            return NULL;\n\n        }\n\n        curl_easy_setopt(state->curl, CURLOPT_URL, s->url);\n\n        curl_easy_setopt(state->curl, CURLOPT_SSL_VERIFYPEER,\n\n                         (long) s->sslverify);\n\n        curl_easy_setopt(state->curl, CURLOPT_TIMEOUT, 5);\n\n        curl_easy_setopt(state->curl, CURLOPT_WRITEFUNCTION,\n\n                         (void *)curl_read_cb);\n\n        curl_easy_setopt(state->curl, CURLOPT_WRITEDATA, (void *)state);\n\n        curl_easy_setopt(state->curl, CURLOPT_PRIVATE, (void *)state);\n\n        curl_easy_setopt(state->curl, CURLOPT_AUTOREFERER, 1);\n\n        curl_easy_setopt(state->curl, CURLOPT_FOLLOWLOCATION, 1);\n\n        curl_easy_setopt(state->curl, CURLOPT_NOSIGNAL, 1);\n\n        curl_easy_setopt(state->curl, CURLOPT_ERRORBUFFER, state->errmsg);\n\n        curl_easy_setopt(state->curl, CURLOPT_FAILONERROR, 1);\n\n\n\n        /* Restrict supported protocols to avoid security issues in the more\n\n         * obscure protocols.  For example, do not allow POP3/SMTP/IMAP see\n\n         * CVE-2013-0249.\n\n         *\n\n         * Restricting protocols is only supported from 7.19.4 upwards.\n\n         */\n\n#if LIBCURL_VERSION_NUM >= 0x071304\n\n        curl_easy_setopt(state->curl, CURLOPT_PROTOCOLS, PROTOCOLS);\n\n        curl_easy_setopt(state->curl, CURLOPT_REDIR_PROTOCOLS, PROTOCOLS);\n\n#endif\n\n\n\n#ifdef DEBUG_VERBOSE\n\n        curl_easy_setopt(state->curl, CURLOPT_VERBOSE, 1);\n\n#endif\n\n    }\n\n\n\n    state->s = s;\n\n\n\n    return state;\n\n}\n", "idx": 23607}
{"project": "qemu", "commit_id": "629bd516fda67c95ba1c7d1393bacb9e68ea0712", "target": 0, "func": "static inline int check_physical(CPUPPCState *env, mmu_ctx_t *ctx,\n\n                                 target_ulong eaddr, int rw)\n\n{\n\n    int in_plb, ret;\n\n\n\n    ctx->raddr = eaddr;\n\n    ctx->prot = PAGE_READ | PAGE_EXEC;\n\n    ret = 0;\n\n    switch (env->mmu_model) {\n\n    case POWERPC_MMU_32B:\n\n    case POWERPC_MMU_601:\n\n    case POWERPC_MMU_SOFT_6xx:\n\n    case POWERPC_MMU_SOFT_74xx:\n\n    case POWERPC_MMU_SOFT_4xx:\n\n    case POWERPC_MMU_REAL:\n\n    case POWERPC_MMU_BOOKE:\n\n        ctx->prot |= PAGE_WRITE;\n\n        break;\n\n#if defined(TARGET_PPC64)\n\n    case POWERPC_MMU_64B:\n\n    case POWERPC_MMU_2_06:\n\n    case POWERPC_MMU_2_06d:\n\n        /* Real address are 60 bits long */\n\n        ctx->raddr &= 0x0FFFFFFFFFFFFFFFULL;\n\n        ctx->prot |= PAGE_WRITE;\n\n        break;\n\n#endif\n\n    case POWERPC_MMU_SOFT_4xx_Z:\n\n        if (unlikely(msr_pe != 0)) {\n\n            /* 403 family add some particular protections,\n\n             * using PBL/PBU registers for accesses with no translation.\n\n             */\n\n            in_plb =\n\n                /* Check PLB validity */\n\n                (env->pb[0] < env->pb[1] &&\n\n                 /* and address in plb area */\n\n                 eaddr >= env->pb[0] && eaddr < env->pb[1]) ||\n\n                (env->pb[2] < env->pb[3] &&\n\n                 eaddr >= env->pb[2] && eaddr < env->pb[3]) ? 1 : 0;\n\n            if (in_plb ^ msr_px) {\n\n                /* Access in protected area */\n\n                if (rw == 1) {\n\n                    /* Access is not allowed */\n\n                    ret = -2;\n\n                }\n\n            } else {\n\n                /* Read-write access is allowed */\n\n                ctx->prot |= PAGE_WRITE;\n\n            }\n\n        }\n\n        break;\n\n    case POWERPC_MMU_MPC8xx:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_BOOKE206:\n\n        cpu_abort(env, \"BookE 2.06 MMU doesn't have physical real mode\\n\");\n\n        break;\n\n    default:\n\n        cpu_abort(env, \"Unknown or invalid MMU model\\n\");\n\n        return -1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 23608}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void onenand_command(OneNANDState *s)\n\n{\n\n    int b;\n\n    int sec;\n\n    void *buf;\n\n#define SETADDR(block, page)\t\t\t\\\n\n    sec = (s->addr[page] & 3) +\t\t\t\\\n\n            ((((s->addr[page] >> 2) & 0x3f) +\t\\\n\n              (((s->addr[block] & 0xfff) |\t\\\n\n                (s->addr[block] >> 15 ?\t\t\\\n\n                 s->density_mask : 0)) << 6)) << (PAGE_SHIFT - 9));\n\n#define SETBUF_M()\t\t\t\t\\\n\n    buf = (s->bufaddr & 8) ?\t\t\t\\\n\n            s->data[(s->bufaddr >> 2) & 1][0] : s->boot[0];\t\\\n\n    buf += (s->bufaddr & 3) << 9;\n\n#define SETBUF_S()\t\t\t\t\\\n\n    buf = (s->bufaddr & 8) ?\t\t\t\\\n\n            s->data[(s->bufaddr >> 2) & 1][1] : s->boot[1];\t\\\n\n    buf += (s->bufaddr & 3) << 4;\n\n\n\n    switch (s->command) {\n\n    case 0x00:\t/* Load single/multiple sector data unit into buffer */\n\n        SETADDR(ONEN_BUF_BLOCK, ONEN_BUF_PAGE)\n\n\n\n        SETBUF_M()\n\n        if (onenand_load_main(s, sec, s->count, buf))\n\n            s->status |= ONEN_ERR_CMD | ONEN_ERR_LOAD;\n\n\n\n#if 0\n\n        SETBUF_S()\n\n        if (onenand_load_spare(s, sec, s->count, buf))\n\n            s->status |= ONEN_ERR_CMD | ONEN_ERR_LOAD;\n\n#endif\n\n\n\n        /* TODO: if (s->bufaddr & 3) + s->count was > 4 (2k-pages)\n\n         * or    if (s->bufaddr & 1) + s->count was > 2 (1k-pages)\n\n         * then we need two split the read/write into two chunks.\n\n         */\n\n        s->intstatus |= ONEN_INT | ONEN_INT_LOAD;\n\n        break;\n\n    case 0x13:\t/* Load single/multiple spare sector into buffer */\n\n        SETADDR(ONEN_BUF_BLOCK, ONEN_BUF_PAGE)\n\n\n\n        SETBUF_S()\n\n        if (onenand_load_spare(s, sec, s->count, buf))\n\n            s->status |= ONEN_ERR_CMD | ONEN_ERR_LOAD;\n\n\n\n        /* TODO: if (s->bufaddr & 3) + s->count was > 4 (2k-pages)\n\n         * or    if (s->bufaddr & 1) + s->count was > 2 (1k-pages)\n\n         * then we need two split the read/write into two chunks.\n\n         */\n\n        s->intstatus |= ONEN_INT | ONEN_INT_LOAD;\n\n        break;\n\n    case 0x80:\t/* Program single/multiple sector data unit from buffer */\n\n        SETADDR(ONEN_BUF_BLOCK, ONEN_BUF_PAGE)\n\n\n\n        SETBUF_M()\n\n        if (onenand_prog_main(s, sec, s->count, buf))\n\n            s->status |= ONEN_ERR_CMD | ONEN_ERR_PROG;\n\n\n\n#if 0\n\n        SETBUF_S()\n\n        if (onenand_prog_spare(s, sec, s->count, buf))\n\n            s->status |= ONEN_ERR_CMD | ONEN_ERR_PROG;\n\n#endif\n\n\n\n        /* TODO: if (s->bufaddr & 3) + s->count was > 4 (2k-pages)\n\n         * or    if (s->bufaddr & 1) + s->count was > 2 (1k-pages)\n\n         * then we need two split the read/write into two chunks.\n\n         */\n\n        s->intstatus |= ONEN_INT | ONEN_INT_PROG;\n\n        break;\n\n    case 0x1a:\t/* Program single/multiple spare area sector from buffer */\n\n        SETADDR(ONEN_BUF_BLOCK, ONEN_BUF_PAGE)\n\n\n\n        SETBUF_S()\n\n        if (onenand_prog_spare(s, sec, s->count, buf))\n\n            s->status |= ONEN_ERR_CMD | ONEN_ERR_PROG;\n\n\n\n        /* TODO: if (s->bufaddr & 3) + s->count was > 4 (2k-pages)\n\n         * or    if (s->bufaddr & 1) + s->count was > 2 (1k-pages)\n\n         * then we need two split the read/write into two chunks.\n\n         */\n\n        s->intstatus |= ONEN_INT | ONEN_INT_PROG;\n\n        break;\n\n    case 0x1b:\t/* Copy-back program */\n\n        SETBUF_S()\n\n\n\n        SETADDR(ONEN_BUF_BLOCK, ONEN_BUF_PAGE)\n\n        if (onenand_load_main(s, sec, s->count, buf))\n\n            s->status |= ONEN_ERR_CMD | ONEN_ERR_PROG;\n\n\n\n        SETADDR(ONEN_BUF_DEST_BLOCK, ONEN_BUF_DEST_PAGE)\n\n        if (onenand_prog_main(s, sec, s->count, buf))\n\n            s->status |= ONEN_ERR_CMD | ONEN_ERR_PROG;\n\n\n\n        /* TODO: spare areas */\n\n\n\n        s->intstatus |= ONEN_INT | ONEN_INT_PROG;\n\n        break;\n\n\n\n    case 0x23:\t/* Unlock NAND array block(s) */\n\n        s->intstatus |= ONEN_INT;\n\n\n\n        /* XXX the previous (?) area should be locked automatically */\n\n        for (b = s->unladdr[0]; b <= s->unladdr[1]; b ++) {\n\n            if (b >= s->blocks) {\n\n                s->status |= ONEN_ERR_CMD;\n\n                break;\n\n            }\n\n            if (s->blockwp[b] == ONEN_LOCK_LOCKTIGHTEN)\n\n                break;\n\n\n\n            s->wpstatus = s->blockwp[b] = ONEN_LOCK_UNLOCKED;\n\n        }\n\n        break;\n\n    case 0x27:\t/* Unlock All NAND array blocks */\n\n        s->intstatus |= ONEN_INT;\n\n\n\n        for (b = 0; b < s->blocks; b ++) {\n\n            if (b >= s->blocks) {\n\n                s->status |= ONEN_ERR_CMD;\n\n                break;\n\n            }\n\n            if (s->blockwp[b] == ONEN_LOCK_LOCKTIGHTEN)\n\n                break;\n\n\n\n            s->wpstatus = s->blockwp[b] = ONEN_LOCK_UNLOCKED;\n\n        }\n\n        break;\n\n\n\n    case 0x2a:\t/* Lock NAND array block(s) */\n\n        s->intstatus |= ONEN_INT;\n\n\n\n        for (b = s->unladdr[0]; b <= s->unladdr[1]; b ++) {\n\n            if (b >= s->blocks) {\n\n                s->status |= ONEN_ERR_CMD;\n\n                break;\n\n            }\n\n            if (s->blockwp[b] == ONEN_LOCK_LOCKTIGHTEN)\n\n                break;\n\n\n\n            s->wpstatus = s->blockwp[b] = ONEN_LOCK_LOCKED;\n\n        }\n\n        break;\n\n    case 0x2c:\t/* Lock-tight NAND array block(s) */\n\n        s->intstatus |= ONEN_INT;\n\n\n\n        for (b = s->unladdr[0]; b <= s->unladdr[1]; b ++) {\n\n            if (b >= s->blocks) {\n\n                s->status |= ONEN_ERR_CMD;\n\n                break;\n\n            }\n\n            if (s->blockwp[b] == ONEN_LOCK_UNLOCKED)\n\n                continue;\n\n\n\n            s->wpstatus = s->blockwp[b] = ONEN_LOCK_LOCKTIGHTEN;\n\n        }\n\n        break;\n\n\n\n    case 0x71:\t/* Erase-Verify-Read */\n\n        s->intstatus |= ONEN_INT;\n\n        break;\n\n    case 0x95:\t/* Multi-block erase */\n\n        qemu_irq_pulse(s->intr);\n\n        /* Fall through.  */\n\n    case 0x94:\t/* Block erase */\n\n        sec = ((s->addr[ONEN_BUF_BLOCK] & 0xfff) |\n\n                        (s->addr[ONEN_BUF_BLOCK] >> 15 ? s->density_mask : 0))\n\n                << (BLOCK_SHIFT - 9);\n\n        if (onenand_erase(s, sec, 1 << (BLOCK_SHIFT - 9)))\n\n            s->status |= ONEN_ERR_CMD | ONEN_ERR_ERASE;\n\n\n\n        s->intstatus |= ONEN_INT | ONEN_INT_ERASE;\n\n        break;\n\n    case 0xb0:\t/* Erase suspend */\n\n        break;\n\n    case 0x30:\t/* Erase resume */\n\n        s->intstatus |= ONEN_INT | ONEN_INT_ERASE;\n\n        break;\n\n\n\n    case 0xf0:\t/* Reset NAND Flash core */\n\n        onenand_reset(s, 0);\n\n        break;\n\n    case 0xf3:\t/* Reset OneNAND */\n\n        onenand_reset(s, 0);\n\n        break;\n\n\n\n    case 0x65:\t/* OTP Access */\n\n        s->intstatus |= ONEN_INT;\n\n        s->bdrv_cur = NULL;\n\n        s->current = s->otp;\n\n        s->secs_cur = 1 << (BLOCK_SHIFT - 9);\n\n        s->addr[ONEN_BUF_BLOCK] = 0;\n\n        s->otpmode = 1;\n\n        break;\n\n\n\n    default:\n\n        s->status |= ONEN_ERR_CMD;\n\n        s->intstatus |= ONEN_INT;\n\n        fprintf(stderr, \"%s: unknown OneNAND command %x\\n\",\n\n                        __func__, s->command);\n\n    }\n\n\n\n    onenand_intr_update(s);\n\n}\n", "idx": 23609}
{"project": "qemu", "commit_id": "856d72454f03aea26fd61c728762ef9cd1d71512", "target": 0, "func": "void address_space_destroy(AddressSpace *as)\n\n{\n\n    /* Flush out anything from MemoryListeners listening in on this */\n\n    memory_region_transaction_begin();\n\n    as->root = NULL;\n\n    memory_region_transaction_commit();\n\n    QTAILQ_REMOVE(&address_spaces, as, address_spaces_link);\n\n    address_space_destroy_dispatch(as);\n\n    flatview_destroy(as->current_map);\n\n    g_free(as->name);\n\n    g_free(as->current_map);\n\n    g_free(as->ioeventfds);\n\n}\n", "idx": 23610}
{"project": "qemu", "commit_id": "6484e422479c93f28e3f8a68258b0eacd3b31e6d", "target": 0, "func": "int qemu_set_fd_handler2(int fd,\n\n                         IOCanReadHandler *fd_read_poll,\n\n                         IOHandler *fd_read,\n\n                         IOHandler *fd_write,\n\n                         void *opaque)\n\n{\n\n    IOHandlerRecord *ioh;\n\n\n\n    assert(fd >= 0);\n\n\n\n    if (!fd_read && !fd_write) {\n\n        QLIST_FOREACH(ioh, &io_handlers, next) {\n\n            if (ioh->fd == fd) {\n\n                ioh->deleted = 1;\n\n                break;\n\n            }\n\n        }\n\n    } else {\n\n        QLIST_FOREACH(ioh, &io_handlers, next) {\n\n            if (ioh->fd == fd)\n\n                goto found;\n\n        }\n\n        ioh = g_malloc0(sizeof(IOHandlerRecord));\n\n        QLIST_INSERT_HEAD(&io_handlers, ioh, next);\n\n    found:\n\n        ioh->fd = fd;\n\n        ioh->fd_read_poll = fd_read_poll;\n\n        ioh->fd_read = fd_read;\n\n        ioh->fd_write = fd_write;\n\n        ioh->opaque = opaque;\n\n        ioh->pollfds_idx = -1;\n\n        ioh->deleted = 0;\n\n        qemu_notify_event();\n\n    }\n\n    return 0;\n\n}\n", "idx": 23611}
{"project": "qemu", "commit_id": "a90a7425cf592a3afeff3eaf32f543b83050ee5c", "target": 0, "func": "static int tap_can_send(void *opaque)\n\n{\n\n    TAPState *s = opaque;\n\n\n\n    return qemu_can_send_packet(&s->nc);\n\n}\n", "idx": 23612}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void net_slirp_cleanup(VLANClientState *vc)\n\n{\n\n    SlirpState *s = vc->opaque;\n\n\n\n    slirp_cleanup(s->slirp);\n\n    slirp_smb_cleanup(s);\n\n    TAILQ_REMOVE(&slirp_stacks, s, entry);\n\n    qemu_free(s);\n\n}\n", "idx": 23614}
{"project": "qemu", "commit_id": "6877cff044cdf6da66885eab62363baf98bb39ee", "target": 0, "func": "static int assign_device(AssignedDevice *dev)\n\n{\n\n    uint32_t flags = KVM_DEV_ASSIGN_ENABLE_IOMMU;\n\n    int r;\n\n\n\n    /* Only pass non-zero PCI segment to capable module */\n\n    if (!kvm_check_extension(kvm_state, KVM_CAP_PCI_SEGMENT) &&\n\n        dev->host.domain) {\n\n        error_report(\"Can't assign device inside non-zero PCI segment \"\n\n                     \"as this KVM module doesn't support it.\");\n\n        return -ENODEV;\n\n    }\n\n\n\n    if (!kvm_check_extension(kvm_state, KVM_CAP_IOMMU)) {\n\n        error_report(\"No IOMMU found.  Unable to assign device \\\"%s\\\"\",\n\n                     dev->dev.qdev.id);\n\n        return -ENODEV;\n\n    }\n\n\n\n    if (dev->features & ASSIGNED_DEVICE_SHARE_INTX_MASK &&\n\n        kvm_has_intx_set_mask()) {\n\n        flags |= KVM_DEV_ASSIGN_PCI_2_3;\n\n    }\n\n\n\n    r = kvm_device_pci_assign(kvm_state, &dev->host, flags, &dev->dev_id);\n\n    if (r < 0) {\n\n        switch (r) {\n\n        case -EBUSY: {\n\n            char *cause;\n\n\n\n            cause = assign_failed_examine(dev);\n\n            error_report(\"Failed to assign device \\\"%s\\\" : %s\\n%s\",\n\n                         dev->dev.qdev.id, strerror(-r), cause);\n\n            g_free(cause);\n\n            break;\n\n        }\n\n        default:\n\n            error_report(\"Failed to assign device \\\"%s\\\" : %s\",\n\n                         dev->dev.qdev.id, strerror(-r));\n\n            break;\n\n        }\n\n    }\n\n    return r;\n\n}\n", "idx": 23615}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static ssize_t v9fs_synth_pwritev(FsContext *ctx, V9fsFidOpenState *fs,\n\n                                  const struct iovec *iov,\n\n                                  int iovcnt, off_t offset)\n\n{\n\n    int i, count = 0, wcount;\n\n    V9fsSynthOpenState *synth_open = fs->private;\n\n    V9fsSynthNode *node = synth_open->node;\n\n    if (!node->attr->write) {\n\n        errno = EPERM;\n\n        return -1;\n\n    }\n\n    for (i = 0; i < iovcnt; i++) {\n\n        wcount = node->attr->write(iov[i].iov_base, iov[i].iov_len,\n\n                                   offset, node->private);\n\n        offset += wcount;\n\n        count  += wcount;\n\n        /* If we wrote less than requested. we are done */\n\n        if (wcount < iov[i].iov_len) {\n\n            break;\n\n        }\n\n    }\n\n    return count;\n\n}\n", "idx": 23616}
{"project": "qemu", "commit_id": "7385aed20db5d83979f683b9d0048674411e963c", "target": 0, "func": "void helper_fdtoq(CPUSPARCState *env, float64 src)\n\n{\n\n    clear_float_exceptions(env);\n\n    QT0 = float64_to_float128(src, &env->fp_status);\n\n    check_ieee_exceptions(env);\n\n}\n", "idx": 23617}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t ecc_diag_mem_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    ECCState *s = opaque;\n\n    uint32_t ret = s->diag[(int)addr];\n\n\n\n    trace_ecc_diag_mem_readb(addr, ret);\n\n    return ret;\n\n}\n", "idx": 23618}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void uart_write(void *opaque, target_phys_addr_t offset,\n\n                          uint64_t value, unsigned size)\n\n{\n\n    UartState *s = (UartState *)opaque;\n\n\n\n    DB_PRINT(\" offset:%x data:%08x\\n\", offset, (unsigned)value);\n\n    offset >>= 2;\n\n    switch (offset) {\n\n    case R_IER: /* ier (wts imr) */\n\n        s->r[R_IMR] |= value;\n\n        break;\n\n    case R_IDR: /* idr (wtc imr) */\n\n        s->r[R_IMR] &= ~value;\n\n        break;\n\n    case R_IMR: /* imr (read only) */\n\n        break;\n\n    case R_CISR: /* cisr (wtc) */\n\n        s->r[R_CISR] &= ~value;\n\n        break;\n\n    case R_TX_RX: /* UARTDR */\n\n        switch (s->r[R_MR] & UART_MR_CHMODE) {\n\n        case NORMAL_MODE:\n\n            uart_write_tx_fifo(s, (uint8_t *) &value, 1);\n\n            break;\n\n        case LOCAL_LOOPBACK:\n\n            uart_write_rx_fifo(opaque, (uint8_t *) &value, 1);\n\n            break;\n\n        }\n\n        break;\n\n    default:\n\n        s->r[offset] = value;\n\n    }\n\n\n\n    switch (offset) {\n\n    case R_CR:\n\n        uart_ctrl_update(s);\n\n        break;\n\n    case R_MR:\n\n        uart_parameters_setup(s);\n\n        break;\n\n    }\n\n}\n", "idx": 23619}
{"project": "qemu", "commit_id": "e4533c7a8cdcc79ccdf695f0aaa2e23a5b926ed0", "target": 0, "func": "static inline int handle_cpu_signal(unsigned long pc, unsigned long address,\n\n                                    int is_write, sigset_t *old_set)\n\n{\n\n    TranslationBlock *tb;\n\n    int ret;\n\n    uint32_t found_pc;\n\n    \n\n#if defined(DEBUG_SIGNAL)\n\n    printf(\"qemu: SIGSEGV pc=0x%08lx address=%08lx wr=%d oldset=0x%08lx\\n\", \n\n           pc, address, is_write, *(unsigned long *)old_set);\n\n#endif\n\n    /* XXX: locking issue */\n\n    if (is_write && page_unprotect(address)) {\n\n        return 1;\n\n    }\n\n    tb = tb_find_pc(pc);\n\n    if (tb) {\n\n        /* the PC is inside the translated code. It means that we have\n\n           a virtual CPU fault */\n\n        ret = cpu_x86_search_pc(tb, &found_pc, pc);\n\n        if (ret < 0)\n\n            return 0;\n\n        env->eip = found_pc - tb->cs_base;\n\n        env->cr2 = address;\n\n        /* we restore the process signal mask as the sigreturn should\n\n           do it (XXX: use sigsetjmp) */\n\n        sigprocmask(SIG_SETMASK, old_set, NULL);\n\n        raise_exception_err(EXCP0E_PAGE, 4 | (is_write << 1));\n\n        /* never comes here */\n\n        return 1;\n\n    } else {\n\n        return 0;\n\n    }\n\n}\n", "idx": 23620}
{"project": "qemu", "commit_id": "153eba4726dfa1bdfc31d1fe973b2a61b9035492", "target": 0, "func": "static void piix4_device_unplug_request_cb(HotplugHandler *hotplug_dev,\n\n                                           DeviceState *dev, Error **errp)\n\n{\n\n    PIIX4PMState *s = PIIX4_PM(hotplug_dev);\n\n\n\n    if (s->acpi_memory_hotplug.is_enabled &&\n\n        object_dynamic_cast(OBJECT(dev), TYPE_PC_DIMM)) {\n\n        acpi_memory_unplug_request_cb(hotplug_dev, &s->acpi_memory_hotplug,\n\n                                      dev, errp);\n\n    } else if (object_dynamic_cast(OBJECT(dev), TYPE_PCI_DEVICE)) {\n\n        acpi_pcihp_device_unplug_cb(hotplug_dev, &s->acpi_pci_hotplug, dev,\n\n                                    errp);\n\n    } else if (object_dynamic_cast(OBJECT(dev), TYPE_CPU) &&\n\n               !s->cpu_hotplug_legacy) {\n\n        acpi_cpu_unplug_request_cb(hotplug_dev, &s->cpuhp_state, dev, errp);\n\n    } else {\n\n        error_setg(errp, \"acpi: device unplug request for not supported device\"\n\n                   \" type: %s\", object_get_typename(OBJECT(dev)));\n\n    }\n\n}\n", "idx": 23621}
{"project": "qemu", "commit_id": "ac1970fbe8ad5a70174f462109ac0f6c7bf1bc43", "target": 0, "func": "void tlb_set_page(CPUArchState *env, target_ulong vaddr,\n\n                  target_phys_addr_t paddr, int prot,\n\n                  int mmu_idx, target_ulong size)\n\n{\n\n    MemoryRegionSection *section;\n\n    unsigned int index;\n\n    target_ulong address;\n\n    target_ulong code_address;\n\n    uintptr_t addend;\n\n    CPUTLBEntry *te;\n\n    target_phys_addr_t iotlb;\n\n\n\n    assert(size >= TARGET_PAGE_SIZE);\n\n    if (size != TARGET_PAGE_SIZE) {\n\n        tlb_add_large_page(env, vaddr, size);\n\n    }\n\n    section = phys_page_find(paddr >> TARGET_PAGE_BITS);\n\n#if defined(DEBUG_TLB)\n\n    printf(\"tlb_set_page: vaddr=\" TARGET_FMT_lx \" paddr=0x\" TARGET_FMT_plx\n\n           \" prot=%x idx=%d pd=0x%08lx\\n\",\n\n           vaddr, paddr, prot, mmu_idx, pd);\n\n#endif\n\n\n\n    address = vaddr;\n\n    if (!(memory_region_is_ram(section->mr) ||\n\n          memory_region_is_romd(section->mr))) {\n\n        /* IO memory case (romd handled later) */\n\n        address |= TLB_MMIO;\n\n    }\n\n    if (memory_region_is_ram(section->mr) ||\n\n        memory_region_is_romd(section->mr)) {\n\n        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr)\n\n        + memory_region_section_addr(section, paddr);\n\n    } else {\n\n        addend = 0;\n\n    }\n\n\n\n    code_address = address;\n\n    iotlb = memory_region_section_get_iotlb(env, section, vaddr, paddr, prot,\n\n                                            &address);\n\n\n\n    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    env->iotlb[mmu_idx][index] = iotlb - vaddr;\n\n    te = &env->tlb_table[mmu_idx][index];\n\n    te->addend = addend - vaddr;\n\n    if (prot & PAGE_READ) {\n\n        te->addr_read = address;\n\n    } else {\n\n        te->addr_read = -1;\n\n    }\n\n\n\n    if (prot & PAGE_EXEC) {\n\n        te->addr_code = code_address;\n\n    } else {\n\n        te->addr_code = -1;\n\n    }\n\n    if (prot & PAGE_WRITE) {\n\n        if ((memory_region_is_ram(section->mr) && section->readonly)\n\n            || memory_region_is_romd(section->mr)) {\n\n            /* Write access calls the I/O callback.  */\n\n            te->addr_write = address | TLB_MMIO;\n\n        } else if (memory_region_is_ram(section->mr)\n\n                   && !cpu_physical_memory_is_dirty(\n\n                           section->mr->ram_addr\n\n                           + memory_region_section_addr(section, paddr))) {\n\n            te->addr_write = address | TLB_NOTDIRTY;\n\n        } else {\n\n            te->addr_write = address;\n\n        }\n\n    } else {\n\n        te->addr_write = -1;\n\n    }\n\n}\n", "idx": 23622}
{"project": "qemu", "commit_id": "0ac7cc2af500b948510f2481c22e84a57b0a2447", "target": 0, "func": "START_TEST(qobject_to_qstring_test)\n\n{\n\n    QString *qstring;\n\n\n\n    qstring = qstring_from_str(\"foo\");\n\n    fail_unless(qobject_to_qstring(QOBJECT(qstring)) == qstring);\n\n\n\n    QDECREF(qstring);\n\n}\n", "idx": 23623}
{"project": "qemu", "commit_id": "02f292d9051f616511f482275b571c6153e3a48b", "target": 1, "func": " static MachineClass *machine_parse(const char *name)\n\n{\n\n    MachineClass *mc = NULL;\n\n    GSList *el, *machines = object_class_get_list(TYPE_MACHINE, false);\n\n\n\n    if (name) {\n\n        mc = find_machine(name);\n\n    }\n\n    if (mc) {\n\n\n        return mc;\n\n    }\n\n    if (name && !is_help_option(name)) {\n\n        error_report(\"Unsupported machine type\");\n\n        error_printf(\"Use -machine help to list supported machines!\\n\");\n\n    } else {\n\n        printf(\"Supported machines are:\\n\");\n\n        machines = g_slist_sort(machines, machine_class_cmp);\n\n        for (el = machines; el; el = el->next) {\n\n            MachineClass *mc = el->data;\n\n            if (mc->alias) {\n\n                printf(\"%-20s %s (alias of %s)\\n\", mc->alias, mc->desc, mc->name);\n\n            }\n\n            printf(\"%-20s %s%s\\n\", mc->name, mc->desc,\n\n                   mc->is_default ? \" (default)\" : \"\");\n\n        }\n\n    }\n\n\n\n\n    exit(!name || !is_help_option(name));\n\n}", "idx": 23624}
{"project": "qemu", "commit_id": "4abf12f4ea866779b493ecf4606bd0b6d35f8348", "target": 1, "func": "static void rtl8139_io_writeb(void *opaque, uint8_t addr, uint32_t val)\n\n{\n\n    RTL8139State *s = opaque;\n\n\n\n    addr &= 0xff;\n\n\n\n    switch (addr)\n\n    {\n\n        case MAC0 ... MAC0+5:\n\n            s->phys[addr - MAC0] = val;\n\n            break;\n\n        case MAC0+6 ... MAC0+7:\n\n            /* reserved */\n\n            break;\n\n        case MAR0 ... MAR0+7:\n\n            s->mult[addr - MAR0] = val;\n\n            break;\n\n        case ChipCmd:\n\n            rtl8139_ChipCmd_write(s, val);\n\n            break;\n\n        case Cfg9346:\n\n            rtl8139_Cfg9346_write(s, val);\n\n            break;\n\n        case TxConfig: /* windows driver sometimes writes using byte-lenth call */\n\n            rtl8139_TxConfig_writeb(s, val);\n\n            break;\n\n        case Config0:\n\n            rtl8139_Config0_write(s, val);\n\n            break;\n\n        case Config1:\n\n            rtl8139_Config1_write(s, val);\n\n            break;\n\n        case Config3:\n\n            rtl8139_Config3_write(s, val);\n\n            break;\n\n        case Config4:\n\n            rtl8139_Config4_write(s, val);\n\n            break;\n\n        case Config5:\n\n            rtl8139_Config5_write(s, val);\n\n            break;\n\n        case MediaStatus:\n\n            /* ignore */\n\n            DPRINTF(\"not implemented write(b) to MediaStatus val=0x%02x\\n\",\n\n                val);\n\n            break;\n\n\n\n        case HltClk:\n\n            DPRINTF(\"HltClk write val=0x%08x\\n\", val);\n\n            if (val == 'R')\n\n            {\n\n                s->clock_enabled = 1;\n\n            }\n\n            else if (val == 'H')\n\n            {\n\n                s->clock_enabled = 0;\n\n            }\n\n            break;\n\n\n\n        case TxThresh:\n\n            DPRINTF(\"C+ TxThresh write(b) val=0x%02x\\n\", val);\n\n            s->TxThresh = val;\n\n            break;\n\n\n\n        case TxPoll:\n\n            DPRINTF(\"C+ TxPoll write(b) val=0x%02x\\n\", val);\n\n            if (val & (1 << 7))\n\n            {\n\n                DPRINTF(\"C+ TxPoll high priority transmission (not \"\n\n                    \"implemented)\\n\");\n\n                //rtl8139_cplus_transmit(s);\n\n            }\n\n            if (val & (1 << 6))\n\n            {\n\n                DPRINTF(\"C+ TxPoll normal priority transmission\\n\");\n\n                rtl8139_cplus_transmit(s);\n\n            }\n\n\n\n            break;\n\n\n\n        default:\n\n            DPRINTF(\"not implemented write(b) addr=0x%x val=0x%02x\\n\", addr,\n\n                val);\n\n            break;\n\n    }\n\n}\n", "idx": 23626}
{"project": "qemu", "commit_id": "c364c974d9ab90e25e7887f516da65d2811ba5e3", "target": 1, "func": "static int pci_qdev_init(DeviceState *qdev, DeviceInfo *base)\n\n{\n\n    PCIDevice *pci_dev = (PCIDevice *)qdev;\n\n    PCIDeviceInfo *info = container_of(base, PCIDeviceInfo, qdev);\n\n    PCIBus *bus;\n\n    int devfn, rc;\n\n\n\n    /* initialize cap_present for pci_is_express() and pci_config_size() */\n\n    if (info->is_express) {\n\n        pci_dev->cap_present |= QEMU_PCI_CAP_EXPRESS;\n\n    }\n\n\n\n    bus = FROM_QBUS(PCIBus, qdev_get_parent_bus(qdev));\n\n    devfn = pci_dev->devfn;\n\n    pci_dev = do_pci_register_device(pci_dev, bus, base->name, devfn,\n\n                                     info->config_read, info->config_write,\n\n                                     info->header_type);\n\n    assert(pci_dev);\n\n    rc = info->init(pci_dev);\n\n    if (rc != 0)\n\n        return rc;\n\n    if (qdev->hotplugged)\n\n        bus->hotplug(pci_dev, 1);\n\n    return 0;\n\n}\n", "idx": 23629}
{"project": "qemu", "commit_id": "8be487d8f184f2f721cabeac559fb7a6cba18c95", "target": 1, "func": "static void sdhci_set_inserted(DeviceState *dev, bool level)\n\n{\n\n    SDHCIState *s = (SDHCIState *)dev;\n\n    DPRINT_L1(\"Card state changed: %s!\\n\", level ? \"insert\" : \"eject\");\n\n\n\n    if ((s->norintsts & SDHC_NIS_REMOVE) && level) {\n\n        /* Give target some time to notice card ejection */\n\n        timer_mod(s->insert_timer,\n\n                       qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + SDHC_INSERTION_DELAY);\n\n    } else {\n\n        if (level) {\n\n            s->prnsts = 0x1ff0000;\n\n            if (s->norintstsen & SDHC_NISEN_INSERT) {\n\n                s->norintsts |= SDHC_NIS_INSERT;\n\n            }\n\n        } else {\n\n            s->prnsts = 0x1fa0000;\n\n            s->pwrcon &= ~SDHC_POWER_ON;\n\n            s->clkcon &= ~SDHC_CLOCK_SDCLK_EN;\n\n            if (s->norintstsen & SDHC_NISEN_REMOVE) {\n\n                s->norintsts |= SDHC_NIS_REMOVE;\n\n            }\n\n        }\n\n        sdhci_update_irq(s);\n\n    }\n\n}\n", "idx": 23633}
{"project": "qemu", "commit_id": "73d60fa5fae60c8e07e1f295d8c7fd5d04320160", "target": 1, "func": "static void get_sensor_type(IPMIBmcSim *ibs,\n\n                               uint8_t *cmd, unsigned int cmd_len,\n\n                               uint8_t *rsp, unsigned int *rsp_len,\n\n                               unsigned int max_rsp_len)\n\n{\n\n    IPMISensor *sens;\n\n\n\n\n\n    IPMI_CHECK_CMD_LEN(3);\n\n    if ((cmd[2] > MAX_SENSORS) ||\n\n            !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {\n\n        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;\n\n        return;\n\n    }\n\n    sens = ibs->sensors + cmd[2];\n\n    IPMI_ADD_RSP_DATA(sens->sensor_type);\n\n    IPMI_ADD_RSP_DATA(sens->evt_reading_type_code);\n\n}\n", "idx": 23634}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void sparc_cpu_initfn(Object *obj)\n\n{\n\n    CPUState *cs = CPU(obj);\n\n    SPARCCPU *cpu = SPARC_CPU(obj);\n\n    CPUSPARCState *env = &cpu->env;\n\n\n\n    cs->env_ptr = env;\n\n    cpu_exec_init(cs, &error_abort);\n\n\n\n    if (tcg_enabled()) {\n\n        gen_intermediate_code_init(env);\n\n    }\n\n}\n", "idx": 23637}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void register_to_network(RDMARegister *reg)\n\n{\n\n    reg->key.current_addr = htonll(reg->key.current_addr);\n\n    reg->current_index = htonl(reg->current_index);\n\n    reg->chunks = htonll(reg->chunks);\n\n}\n", "idx": 23638}
{"project": "qemu", "commit_id": "1984745ea8ad309a06690a83e91d031d21d709ff", "target": 1, "func": "void nand_setio(DeviceState *dev, uint32_t value)\n\n{\n\n    int i;\n\n    NANDFlashState *s = (NANDFlashState *) dev;\n\n    if (!s->ce && s->cle) {\n\n        if (nand_flash_ids[s->chip_id].options & NAND_SAMSUNG_LP) {\n\n            if (s->cmd == NAND_CMD_READ0 && value == NAND_CMD_LPREAD2)\n\n                return;\n\n            if (value == NAND_CMD_RANDOMREAD1) {\n\n                s->addr &= ~((1 << s->addr_shift) - 1);\n\n                s->addrlen = 0;\n\n                return;\n\n            }\n\n        }\n\n        if (value == NAND_CMD_READ0)\n\n            s->offset = 0;\n\n\telse if (value == NAND_CMD_READ1) {\n\n            s->offset = 0x100;\n\n            value = NAND_CMD_READ0;\n\n        }\n\n\telse if (value == NAND_CMD_READ2) {\n\n            s->offset = 1 << s->page_shift;\n\n            value = NAND_CMD_READ0;\n\n        }\n\n\n\n        s->cmd = value;\n\n\n\n        if (s->cmd == NAND_CMD_READSTATUS ||\n\n                s->cmd == NAND_CMD_PAGEPROGRAM2 ||\n\n                s->cmd == NAND_CMD_BLOCKERASE1 ||\n\n                s->cmd == NAND_CMD_BLOCKERASE2 ||\n\n                s->cmd == NAND_CMD_NOSERIALREAD2 ||\n\n                s->cmd == NAND_CMD_RANDOMREAD2 ||\n\n                s->cmd == NAND_CMD_RESET)\n\n            nand_command(s);\n\n\n\n        if (s->cmd != NAND_CMD_RANDOMREAD2) {\n\n            s->addrlen = 0;\n\n        }\n\n    }\n\n\n\n    if (s->ale) {\n\n        unsigned int shift = s->addrlen * 8;\n\n        unsigned int mask = ~(0xff << shift);\n\n        unsigned int v = value << shift;\n\n\n\n        s->addr = (s->addr & mask) | v;\n\n        s->addrlen ++;\n\n\n\n        switch (s->addrlen) {\n\n        case 1:\n\n            if (s->cmd == NAND_CMD_READID) {\n\n                nand_command(s);\n\n            }\n\n            break;\n\n        case 2: /* fix cache address as a byte address */\n\n            s->addr <<= (s->buswidth - 1);\n\n            break;\n\n        case 3:\n\n            if (!(nand_flash_ids[s->chip_id].options & NAND_SAMSUNG_LP) &&\n\n                    (s->cmd == NAND_CMD_READ0 ||\n\n                     s->cmd == NAND_CMD_PAGEPROGRAM1)) {\n\n                nand_command(s);\n\n            }\n\n            break;\n\n        case 4:\n\n            if ((nand_flash_ids[s->chip_id].options & NAND_SAMSUNG_LP) &&\n\n                    nand_flash_ids[s->chip_id].size < 256 && /* 1Gb or less */\n\n                    (s->cmd == NAND_CMD_READ0 ||\n\n                     s->cmd == NAND_CMD_PAGEPROGRAM1)) {\n\n                nand_command(s);\n\n            }\n\n            break;\n\n        case 5:\n\n            if ((nand_flash_ids[s->chip_id].options & NAND_SAMSUNG_LP) &&\n\n                    nand_flash_ids[s->chip_id].size >= 256 && /* 2Gb or more */\n\n                    (s->cmd == NAND_CMD_READ0 ||\n\n                     s->cmd == NAND_CMD_PAGEPROGRAM1)) {\n\n                nand_command(s);\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (!s->cle && !s->ale && s->cmd == NAND_CMD_PAGEPROGRAM1) {\n\n        if (s->iolen < (1 << s->page_shift) + (1 << s->oob_shift)) {\n\n            for (i = s->buswidth; i--; value >>= 8) {\n\n                s->io[s->iolen ++] = (uint8_t) (value & 0xff);\n\n            }\n\n        }\n\n    } else if (!s->cle && !s->ale && s->cmd == NAND_CMD_COPYBACKPRG1) {\n\n        if ((s->addr & ((1 << s->addr_shift) - 1)) <\n\n                (1 << s->page_shift) + (1 << s->oob_shift)) {\n\n            for (i = s->buswidth; i--; s->addr++, value >>= 8) {\n\n                s->io[s->iolen + (s->addr & ((1 << s->addr_shift) - 1))] =\n\n                    (uint8_t) (value & 0xff);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 23641}
{"project": "qemu", "commit_id": "01979a98d75b49c2acbbbb71521c285f8d8f9fb7", "target": 1, "func": "static int bdrv_qed_check(BlockDriverState *bs, BdrvCheckResult *result)\n\n{\n\n    return -ENOTSUP;\n\n}\n", "idx": 23642}
{"project": "qemu", "commit_id": "b5eff355460643d09e533024360fe0522f368c07", "target": 1, "func": "static int bdrv_wr_badreq_sectors(BlockDriverState *bs,\n\n                                  int64_t sector_num, int nb_sectors)\n\n{\n\n    if (sector_num < 0 ||\n\n        nb_sectors < 0)\n\n        return 1;\n\n\n\n    if (sector_num > bs->total_sectors - nb_sectors) {\n\n        if (bs->autogrow)\n\n            bs->total_sectors = sector_num + nb_sectors;\n\n        else\n\n            return 1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 23645}
{"project": "qemu", "commit_id": "d09a6fde1590ca3a45b608b6873a680f208dfeb5", "target": 1, "func": "static int ram_save_complete(QEMUFile *f, void *opaque)\n\n{\n\n    rcu_read_lock();\n\n\n\n    migration_bitmap_sync();\n\n\n\n    ram_control_before_iterate(f, RAM_CONTROL_FINISH);\n\n\n\n    /* try transferring iterative blocks of memory */\n\n\n\n    /* flush all remaining blocks regardless of rate limiting */\n\n    while (true) {\n\n        int pages;\n\n\n\n        pages = ram_find_and_save_block(f, true, &bytes_transferred);\n\n        /* no more blocks to sent */\n\n        if (pages == 0) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    flush_compressed_data(f);\n\n    ram_control_after_iterate(f, RAM_CONTROL_FINISH);\n\n    migration_end();\n\n\n\n    rcu_read_unlock();\n\n    qemu_put_be64(f, RAM_SAVE_FLAG_EOS);\n\n\n\n    return 0;\n\n}\n", "idx": 23646}
{"project": "qemu", "commit_id": "86e18cae209f8101ff9a6013a1ff6ae620c06944", "target": 1, "func": "static inline int ohci_put_ed(OHCIState *ohci,\n\n                              uint32_t addr, struct ohci_ed *ed)\n\n{\n\n    return put_dwords(ohci, addr, (uint32_t *)ed, sizeof(*ed) >> 2);\n\n}\n", "idx": 23648}
{"project": "qemu", "commit_id": "ae2150680190e510dcbcdfdbfb3a54369c75367f", "target": 1, "func": "static int read_cpuinfo(const char *field, char *value, int len)\n\n{\n\n    FILE *f;\n\n    int ret = -1;\n\n    int field_len = strlen(field);\n\n    char line[512];\n\n\n\n    f = fopen(\"/proc/cpuinfo\", \"r\");\n\n    if (!f) {\n\n        return -1;\n\n    }\n\n\n\n    do {\n\n        if(!fgets(line, sizeof(line), f)) {\n\n            break;\n\n        }\n\n        if (!strncmp(line, field, field_len)) {\n\n            strncpy(value, line, len);\n\n            ret = 0;\n\n            break;\n\n        }\n\n    } while(*line);\n\n\n\n    fclose(f);\n\n\n\n    return ret;\n\n}\n", "idx": 23649}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void puv3_board_init(CPUUniCore32State *env, ram_addr_t ram_size)\n\n{\n\n    MemoryRegion *ram_memory = g_new(MemoryRegion, 1);\n\n\n\n    /* SDRAM at address zero.  */\n\n    memory_region_init_ram(ram_memory, NULL, \"puv3.ram\", ram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(ram_memory);\n\n    memory_region_add_subregion(get_system_memory(), 0, ram_memory);\n\n}\n", "idx": 23650}
{"project": "qemu", "commit_id": "aa87d45855c7b255b451622a84a3e5b9b4393425", "target": 1, "func": "void enable_kvm_pv_eoi(void)\n\n{\n\n    kvm_default_features |= kvm_pv_eoi_features;\n\n}\n", "idx": 23655}
{"project": "qemu", "commit_id": "82e59a676c01b3df3b53998d428d0a64a55f2439", "target": 1, "func": "void hmp_memchar_write(Monitor *mon, const QDict *qdict)\n\n{\n\n    uint32_t size;\n\n    const char *chardev = qdict_get_str(qdict, \"device\");\n\n    const char *data = qdict_get_str(qdict, \"data\");\n\n    Error *errp = NULL;\n\n\n\n    size = strlen(data);\n\n    qmp_memchar_write(chardev, size, data, false, 0, &errp);\n\n\n\n    hmp_handle_error(mon, &errp);\n\n}\n", "idx": 23656}
{"project": "qemu", "commit_id": "91bea4e2bb1a5f7954a3b3a4f2e28e96bd25c458", "target": 1, "func": "iscsi_aio_writev(BlockDriverState *bs, int64_t sector_num,\n                 QEMUIOVector *qiov, int nb_sectors,\n                 BlockDriverCompletionFunc *cb,\n                 void *opaque)\n{\n    IscsiLun *iscsilun = bs->opaque;\n    IscsiAIOCB *acb;\n    acb = qemu_aio_get(&iscsi_aiocb_info, bs, cb, opaque);\n    trace_iscsi_aio_writev(iscsilun->iscsi, sector_num, nb_sectors, opaque, acb);\n    acb->iscsilun    = iscsilun;\n    acb->qiov        = qiov;\n    acb->nb_sectors  = nb_sectors;\n    acb->sector_num  = sector_num;\n    acb->retries     = ISCSI_CMD_RETRIES;\n    if (iscsi_aio_writev_acb(acb) != 0) {\n        qemu_aio_release(acb);\n    iscsi_set_events(iscsilun);\n    return &acb->common;", "idx": 23657}
{"project": "qemu", "commit_id": "1622ffd5151ad09c47785a380531ef1ebfc95be8", "target": 1, "func": "static void qemu_s390_flic_class_init(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    S390FLICStateClass *fsc = S390_FLIC_COMMON_CLASS(oc);\n\n\n\n    dc->reset = qemu_s390_flic_reset;\n\n    fsc->register_io_adapter = qemu_s390_register_io_adapter;\n\n    fsc->io_adapter_map = qemu_s390_io_adapter_map;\n\n    fsc->add_adapter_routes = qemu_s390_add_adapter_routes;\n\n    fsc->release_adapter_routes = qemu_s390_release_adapter_routes;\n\n    fsc->clear_io_irq = qemu_s390_clear_io_flic;\n\n    fsc->modify_ais_mode = qemu_s390_modify_ais_mode;\n\n\n}", "idx": 23658}
{"project": "qemu", "commit_id": "c3e10c7b4377c1cbc0a4fbc12312c2cf41c0cda7", "target": 1, "func": "static always_inline void gen_op_subfeo_64 (void)\n\n{\n\n    gen_op_move_T2_T0();\n\n    gen_op_subfe_64();\n\n    gen_op_check_subfo_64();\n\n}\n", "idx": 23659}
{"project": "qemu", "commit_id": "26c4e7ca72d970d120f0f51244bc8d37458512a0", "target": 1, "func": "static ssize_t rtl8139_do_receive(NetClientState *nc, const uint8_t *buf, size_t size_, int do_interrupt)\n\n{\n\n    RTL8139State *s = qemu_get_nic_opaque(nc);\n\n    PCIDevice *d = PCI_DEVICE(s);\n\n    /* size is the length of the buffer passed to the driver */\n\n    int size = size_;\n\n    const uint8_t *dot1q_buf = NULL;\n\n\n\n    uint32_t packet_header = 0;\n\n\n\n    uint8_t buf1[MIN_BUF_SIZE + VLAN_HLEN];\n\n    static const uint8_t broadcast_macaddr[6] =\n\n        { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\n\n\n    DPRINTF(\">>> received len=%d\\n\", size);\n\n\n\n    /* test if board clock is stopped */\n\n    if (!s->clock_enabled)\n\n    {\n\n        DPRINTF(\"stopped ==========================\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /* first check if receiver is enabled */\n\n\n\n    if (!rtl8139_receiver_enabled(s))\n\n    {\n\n        DPRINTF(\"receiver disabled ================\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /* XXX: check this */\n\n    if (s->RxConfig & AcceptAllPhys) {\n\n        /* promiscuous: receive all */\n\n        DPRINTF(\">>> packet received in promiscuous mode\\n\");\n\n\n\n    } else {\n\n        if (!memcmp(buf,  broadcast_macaddr, 6)) {\n\n            /* broadcast address */\n\n            if (!(s->RxConfig & AcceptBroadcast))\n\n            {\n\n                DPRINTF(\">>> broadcast packet rejected\\n\");\n\n\n\n                /* update tally counter */\n\n                ++s->tally_counters.RxERR;\n\n\n\n                return size;\n\n            }\n\n\n\n            packet_header |= RxBroadcast;\n\n\n\n            DPRINTF(\">>> broadcast packet received\\n\");\n\n\n\n            /* update tally counter */\n\n            ++s->tally_counters.RxOkBrd;\n\n\n\n        } else if (buf[0] & 0x01) {\n\n            /* multicast */\n\n            if (!(s->RxConfig & AcceptMulticast))\n\n            {\n\n                DPRINTF(\">>> multicast packet rejected\\n\");\n\n\n\n                /* update tally counter */\n\n                ++s->tally_counters.RxERR;\n\n\n\n                return size;\n\n            }\n\n\n\n            int mcast_idx = compute_mcast_idx(buf);\n\n\n\n            if (!(s->mult[mcast_idx >> 3] & (1 << (mcast_idx & 7))))\n\n            {\n\n                DPRINTF(\">>> multicast address mismatch\\n\");\n\n\n\n                /* update tally counter */\n\n                ++s->tally_counters.RxERR;\n\n\n\n                return size;\n\n            }\n\n\n\n            packet_header |= RxMulticast;\n\n\n\n            DPRINTF(\">>> multicast packet received\\n\");\n\n\n\n            /* update tally counter */\n\n            ++s->tally_counters.RxOkMul;\n\n\n\n        } else if (s->phys[0] == buf[0] &&\n\n                   s->phys[1] == buf[1] &&\n\n                   s->phys[2] == buf[2] &&\n\n                   s->phys[3] == buf[3] &&\n\n                   s->phys[4] == buf[4] &&\n\n                   s->phys[5] == buf[5]) {\n\n            /* match */\n\n            if (!(s->RxConfig & AcceptMyPhys))\n\n            {\n\n                DPRINTF(\">>> rejecting physical address matching packet\\n\");\n\n\n\n                /* update tally counter */\n\n                ++s->tally_counters.RxERR;\n\n\n\n                return size;\n\n            }\n\n\n\n            packet_header |= RxPhysical;\n\n\n\n            DPRINTF(\">>> physical address matching packet received\\n\");\n\n\n\n            /* update tally counter */\n\n            ++s->tally_counters.RxOkPhy;\n\n\n\n        } else {\n\n\n\n            DPRINTF(\">>> unknown packet\\n\");\n\n\n\n            /* update tally counter */\n\n            ++s->tally_counters.RxERR;\n\n\n\n            return size;\n\n        }\n\n    }\n\n\n\n    /* if too small buffer, then expand it\n\n     * Include some tailroom in case a vlan tag is later removed. */\n\n    if (size < MIN_BUF_SIZE + VLAN_HLEN) {\n\n        memcpy(buf1, buf, size);\n\n        memset(buf1 + size, 0, MIN_BUF_SIZE + VLAN_HLEN - size);\n\n        buf = buf1;\n\n        if (size < MIN_BUF_SIZE) {\n\n            size = MIN_BUF_SIZE;\n\n        }\n\n    }\n\n\n\n    if (rtl8139_cp_receiver_enabled(s))\n\n    {\n\n        if (!rtl8139_cp_rx_valid(s)) {\n\n            return size;\n\n        }\n\n\n\n        DPRINTF(\"in C+ Rx mode ================\\n\");\n\n\n\n        /* begin C+ receiver mode */\n\n\n\n/* w0 ownership flag */\n\n#define CP_RX_OWN (1<<31)\n\n/* w0 end of ring flag */\n\n#define CP_RX_EOR (1<<30)\n\n/* w0 bits 0...12 : buffer size */\n\n#define CP_RX_BUFFER_SIZE_MASK ((1<<13) - 1)\n\n/* w1 tag available flag */\n\n#define CP_RX_TAVA (1<<16)\n\n/* w1 bits 0...15 : VLAN tag */\n\n#define CP_RX_VLAN_TAG_MASK ((1<<16) - 1)\n\n/* w2 low  32bit of Rx buffer ptr */\n\n/* w3 high 32bit of Rx buffer ptr */\n\n\n\n        int descriptor = s->currCPlusRxDesc;\n\n        dma_addr_t cplus_rx_ring_desc;\n\n\n\n        cplus_rx_ring_desc = rtl8139_addr64(s->RxRingAddrLO, s->RxRingAddrHI);\n\n        cplus_rx_ring_desc += 16 * descriptor;\n\n\n\n        DPRINTF(\"+++ C+ mode reading RX descriptor %d from host memory at \"\n\n            \"%08x %08x = \"DMA_ADDR_FMT\"\\n\", descriptor, s->RxRingAddrHI,\n\n            s->RxRingAddrLO, cplus_rx_ring_desc);\n\n\n\n        uint32_t val, rxdw0,rxdw1,rxbufLO,rxbufHI;\n\n\n\n        pci_dma_read(d, cplus_rx_ring_desc, &val, 4);\n\n        rxdw0 = le32_to_cpu(val);\n\n        pci_dma_read(d, cplus_rx_ring_desc+4, &val, 4);\n\n        rxdw1 = le32_to_cpu(val);\n\n        pci_dma_read(d, cplus_rx_ring_desc+8, &val, 4);\n\n        rxbufLO = le32_to_cpu(val);\n\n        pci_dma_read(d, cplus_rx_ring_desc+12, &val, 4);\n\n        rxbufHI = le32_to_cpu(val);\n\n\n\n        DPRINTF(\"+++ C+ mode RX descriptor %d %08x %08x %08x %08x\\n\",\n\n            descriptor, rxdw0, rxdw1, rxbufLO, rxbufHI);\n\n\n\n        if (!(rxdw0 & CP_RX_OWN))\n\n        {\n\n            DPRINTF(\"C+ Rx mode : descriptor %d is owned by host\\n\",\n\n                descriptor);\n\n\n\n            s->IntrStatus |= RxOverflow;\n\n            ++s->RxMissed;\n\n\n\n            /* update tally counter */\n\n            ++s->tally_counters.RxERR;\n\n            ++s->tally_counters.MissPkt;\n\n\n\n            rtl8139_update_irq(s);\n\n            return size_;\n\n        }\n\n\n\n        uint32_t rx_space = rxdw0 & CP_RX_BUFFER_SIZE_MASK;\n\n\n\n        /* write VLAN info to descriptor variables. */\n\n        if (s->CpCmd & CPlusRxVLAN && be16_to_cpup((uint16_t *)\n\n                &buf[ETH_ALEN * 2]) == ETH_P_VLAN) {\n\n            dot1q_buf = &buf[ETH_ALEN * 2];\n\n            size -= VLAN_HLEN;\n\n            /* if too small buffer, use the tailroom added duing expansion */\n\n            if (size < MIN_BUF_SIZE) {\n\n                size = MIN_BUF_SIZE;\n\n            }\n\n\n\n            rxdw1 &= ~CP_RX_VLAN_TAG_MASK;\n\n            /* BE + ~le_to_cpu()~ + cpu_to_le() = BE */\n\n            rxdw1 |= CP_RX_TAVA | le16_to_cpup((uint16_t *)\n\n                &dot1q_buf[ETHER_TYPE_LEN]);\n\n\n\n            DPRINTF(\"C+ Rx mode : extracted vlan tag with tci: \"\"%u\\n\",\n\n                be16_to_cpup((uint16_t *)&dot1q_buf[ETHER_TYPE_LEN]));\n\n        } else {\n\n            /* reset VLAN tag flag */\n\n            rxdw1 &= ~CP_RX_TAVA;\n\n        }\n\n\n\n        /* TODO: scatter the packet over available receive ring descriptors space */\n\n\n\n        if (size+4 > rx_space)\n\n        {\n\n            DPRINTF(\"C+ Rx mode : descriptor %d size %d received %d + 4\\n\",\n\n                descriptor, rx_space, size);\n\n\n\n            s->IntrStatus |= RxOverflow;\n\n            ++s->RxMissed;\n\n\n\n            /* update tally counter */\n\n            ++s->tally_counters.RxERR;\n\n            ++s->tally_counters.MissPkt;\n\n\n\n            rtl8139_update_irq(s);\n\n            return size_;\n\n        }\n\n\n\n        dma_addr_t rx_addr = rtl8139_addr64(rxbufLO, rxbufHI);\n\n\n\n        /* receive/copy to target memory */\n\n        if (dot1q_buf) {\n\n            pci_dma_write(d, rx_addr, buf, 2 * ETH_ALEN);\n\n            pci_dma_write(d, rx_addr + 2 * ETH_ALEN,\n\n                          buf + 2 * ETH_ALEN + VLAN_HLEN,\n\n                          size - 2 * ETH_ALEN);\n\n        } else {\n\n            pci_dma_write(d, rx_addr, buf, size);\n\n        }\n\n\n\n        if (s->CpCmd & CPlusRxChkSum)\n\n        {\n\n            /* do some packet checksumming */\n\n        }\n\n\n\n        /* write checksum */\n\n        val = cpu_to_le32(crc32(0, buf, size_));\n\n        pci_dma_write(d, rx_addr+size, (uint8_t *)&val, 4);\n\n\n\n/* first segment of received packet flag */\n\n#define CP_RX_STATUS_FS (1<<29)\n\n/* last segment of received packet flag */\n\n#define CP_RX_STATUS_LS (1<<28)\n\n/* multicast packet flag */\n\n#define CP_RX_STATUS_MAR (1<<26)\n\n/* physical-matching packet flag */\n\n#define CP_RX_STATUS_PAM (1<<25)\n\n/* broadcast packet flag */\n\n#define CP_RX_STATUS_BAR (1<<24)\n\n/* runt packet flag */\n\n#define CP_RX_STATUS_RUNT (1<<19)\n\n/* crc error flag */\n\n#define CP_RX_STATUS_CRC (1<<18)\n\n/* IP checksum error flag */\n\n#define CP_RX_STATUS_IPF (1<<15)\n\n/* UDP checksum error flag */\n\n#define CP_RX_STATUS_UDPF (1<<14)\n\n/* TCP checksum error flag */\n\n#define CP_RX_STATUS_TCPF (1<<13)\n\n\n\n        /* transfer ownership to target */\n\n        rxdw0 &= ~CP_RX_OWN;\n\n\n\n        /* set first segment bit */\n\n        rxdw0 |= CP_RX_STATUS_FS;\n\n\n\n        /* set last segment bit */\n\n        rxdw0 |= CP_RX_STATUS_LS;\n\n\n\n        /* set received packet type flags */\n\n        if (packet_header & RxBroadcast)\n\n            rxdw0 |= CP_RX_STATUS_BAR;\n\n        if (packet_header & RxMulticast)\n\n            rxdw0 |= CP_RX_STATUS_MAR;\n\n        if (packet_header & RxPhysical)\n\n            rxdw0 |= CP_RX_STATUS_PAM;\n\n\n\n        /* set received size */\n\n        rxdw0 &= ~CP_RX_BUFFER_SIZE_MASK;\n\n        rxdw0 |= (size+4);\n\n\n\n        /* update ring data */\n\n        val = cpu_to_le32(rxdw0);\n\n        pci_dma_write(d, cplus_rx_ring_desc, (uint8_t *)&val, 4);\n\n        val = cpu_to_le32(rxdw1);\n\n        pci_dma_write(d, cplus_rx_ring_desc+4, (uint8_t *)&val, 4);\n\n\n\n        /* update tally counter */\n\n        ++s->tally_counters.RxOk;\n\n\n\n        /* seek to next Rx descriptor */\n\n        if (rxdw0 & CP_RX_EOR)\n\n        {\n\n            s->currCPlusRxDesc = 0;\n\n        }\n\n        else\n\n        {\n\n            ++s->currCPlusRxDesc;\n\n        }\n\n\n\n        DPRINTF(\"done C+ Rx mode ----------------\\n\");\n\n\n\n    }\n\n    else\n\n    {\n\n        DPRINTF(\"in ring Rx mode ================\\n\");\n\n\n\n        /* begin ring receiver mode */\n\n        int avail = MOD2(s->RxBufferSize + s->RxBufPtr - s->RxBufAddr, s->RxBufferSize);\n\n\n\n        /* if receiver buffer is empty then avail == 0 */\n\n\n\n#define RX_ALIGN(x) (((x) + 3) & ~0x3)\n\n\n\n        if (avail != 0 && RX_ALIGN(size + 8) >= avail)\n\n        {\n\n            DPRINTF(\"rx overflow: rx buffer length %d head 0x%04x \"\n\n                \"read 0x%04x === available 0x%04x need 0x%04x\\n\",\n\n                s->RxBufferSize, s->RxBufAddr, s->RxBufPtr, avail, size + 8);\n\n\n\n            s->IntrStatus |= RxOverflow;\n\n            ++s->RxMissed;\n\n            rtl8139_update_irq(s);\n\n            return size_;\n\n        }\n\n\n\n        packet_header |= RxStatusOK;\n\n\n\n        packet_header |= (((size+4) << 16) & 0xffff0000);\n\n\n\n        /* write header */\n\n        uint32_t val = cpu_to_le32(packet_header);\n\n\n\n        rtl8139_write_buffer(s, (uint8_t *)&val, 4);\n\n\n\n        rtl8139_write_buffer(s, buf, size);\n\n\n\n        /* write checksum */\n\n        val = cpu_to_le32(crc32(0, buf, size));\n\n        rtl8139_write_buffer(s, (uint8_t *)&val, 4);\n\n\n\n        /* correct buffer write pointer */\n\n        s->RxBufAddr = MOD2(RX_ALIGN(s->RxBufAddr), s->RxBufferSize);\n\n\n\n        /* now we can signal we have received something */\n\n\n\n        DPRINTF(\"received: rx buffer length %d head 0x%04x read 0x%04x\\n\",\n\n            s->RxBufferSize, s->RxBufAddr, s->RxBufPtr);\n\n    }\n\n\n\n    s->IntrStatus |= RxOK;\n\n\n\n    if (do_interrupt)\n\n    {\n\n        rtl8139_update_irq(s);\n\n    }\n\n\n\n    return size_;\n\n}\n", "idx": 23660}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "void start_auth_sasl(VncState *vs)\n\n{\n\n    const char *mechlist = NULL;\n\n    sasl_security_properties_t secprops;\n\n    int err;\n\n    char *localAddr, *remoteAddr;\n\n    int mechlistlen;\n\n\n\n    VNC_DEBUG(\"Initialize SASL auth %d\\n\", vs->csock);\n\n\n\n    /* Get local & remote client addresses in form  IPADDR;PORT */\n\n    if (!(localAddr = vnc_socket_local_addr(\"%s;%s\", vs->csock)))\n\n        goto authabort;\n\n\n\n    if (!(remoteAddr = vnc_socket_remote_addr(\"%s;%s\", vs->csock))) {\n\n        g_free(localAddr);\n\n        goto authabort;\n\n    }\n\n\n\n    err = sasl_server_new(\"vnc\",\n\n                          NULL, /* FQDN - just delegates to gethostname */\n\n                          NULL, /* User realm */\n\n                          localAddr,\n\n                          remoteAddr,\n\n                          NULL, /* Callbacks, not needed */\n\n                          SASL_SUCCESS_DATA,\n\n                          &vs->sasl.conn);\n\n    g_free(localAddr);\n\n    g_free(remoteAddr);\n\n    localAddr = remoteAddr = NULL;\n\n\n\n    if (err != SASL_OK) {\n\n        VNC_DEBUG(\"sasl context setup failed %d (%s)\",\n\n                  err, sasl_errstring(err, NULL, NULL));\n\n        vs->sasl.conn = NULL;\n\n        goto authabort;\n\n    }\n\n\n\n#ifdef CONFIG_VNC_TLS\n\n    /* Inform SASL that we've got an external SSF layer from TLS/x509 */\n\n    if (vs->auth == VNC_AUTH_VENCRYPT &&\n\n        vs->subauth == VNC_AUTH_VENCRYPT_X509SASL) {\n\n        gnutls_cipher_algorithm_t cipher;\n\n        sasl_ssf_t ssf;\n\n\n\n        cipher = gnutls_cipher_get(vs->tls.session);\n\n        if (!(ssf = (sasl_ssf_t)gnutls_cipher_get_key_size(cipher))) {\n\n            VNC_DEBUG(\"%s\", \"cannot TLS get cipher size\\n\");\n\n            sasl_dispose(&vs->sasl.conn);\n\n            vs->sasl.conn = NULL;\n\n            goto authabort;\n\n        }\n\n        ssf *= 8; /* tls key size is bytes, sasl wants bits */\n\n\n\n        err = sasl_setprop(vs->sasl.conn, SASL_SSF_EXTERNAL, &ssf);\n\n        if (err != SASL_OK) {\n\n            VNC_DEBUG(\"cannot set SASL external SSF %d (%s)\\n\",\n\n                      err, sasl_errstring(err, NULL, NULL));\n\n            sasl_dispose(&vs->sasl.conn);\n\n            vs->sasl.conn = NULL;\n\n            goto authabort;\n\n        }\n\n    } else\n\n#endif /* CONFIG_VNC_TLS */\n\n        vs->sasl.wantSSF = 1;\n\n\n\n    memset (&secprops, 0, sizeof secprops);\n\n    /* Inform SASL that we've got an external SSF layer from TLS */\n\n    if (vs->vd->is_unix\n\n#ifdef CONFIG_VNC_TLS\n\n        /* Disable SSF, if using TLS+x509+SASL only. TLS without x509\n\n           is not sufficiently strong */\n\n        || (vs->auth == VNC_AUTH_VENCRYPT &&\n\n            vs->subauth == VNC_AUTH_VENCRYPT_X509SASL)\n\n#endif /* CONFIG_VNC_TLS */\n\n        ) {\n\n        /* If we've got TLS or UNIX domain sock, we don't care about SSF */\n\n        secprops.min_ssf = 0;\n\n        secprops.max_ssf = 0;\n\n        secprops.maxbufsize = 8192;\n\n        secprops.security_flags = 0;\n\n    } else {\n\n        /* Plain TCP, better get an SSF layer */\n\n        secprops.min_ssf = 56; /* Good enough to require kerberos */\n\n        secprops.max_ssf = 100000; /* Arbitrary big number */\n\n        secprops.maxbufsize = 8192;\n\n        /* Forbid any anonymous or trivially crackable auth */\n\n        secprops.security_flags =\n\n            SASL_SEC_NOANONYMOUS | SASL_SEC_NOPLAINTEXT;\n\n    }\n\n\n\n    err = sasl_setprop(vs->sasl.conn, SASL_SEC_PROPS, &secprops);\n\n    if (err != SASL_OK) {\n\n        VNC_DEBUG(\"cannot set SASL security props %d (%s)\\n\",\n\n                  err, sasl_errstring(err, NULL, NULL));\n\n        sasl_dispose(&vs->sasl.conn);\n\n        vs->sasl.conn = NULL;\n\n        goto authabort;\n\n    }\n\n\n\n    err = sasl_listmech(vs->sasl.conn,\n\n                        NULL, /* Don't need to set user */\n\n                        \"\", /* Prefix */\n\n                        \",\", /* Separator */\n\n                        \"\", /* Suffix */\n\n                        &mechlist,\n\n                        NULL,\n\n                        NULL);\n\n    if (err != SASL_OK) {\n\n        VNC_DEBUG(\"cannot list SASL mechanisms %d (%s)\\n\",\n\n                  err, sasl_errdetail(vs->sasl.conn));\n\n        sasl_dispose(&vs->sasl.conn);\n\n        vs->sasl.conn = NULL;\n\n        goto authabort;\n\n    }\n\n    VNC_DEBUG(\"Available mechanisms for client: '%s'\\n\", mechlist);\n\n\n\n    vs->sasl.mechlist = g_strdup(mechlist);\n\n    mechlistlen = strlen(mechlist);\n\n    vnc_write_u32(vs, mechlistlen);\n\n    vnc_write(vs, mechlist, mechlistlen);\n\n    vnc_flush(vs);\n\n\n\n    VNC_DEBUG(\"Wait for client mechname length\\n\");\n\n    vnc_read_when(vs, protocol_client_auth_sasl_mechname_len, 4);\n\n\n\n    return;\n\n\n\n authabort:\n\n    vnc_client_error(vs);\n\n}\n", "idx": 23661}
{"project": "qemu", "commit_id": "12dccfe4f57ead8166567ec8a60d2ce91e266f04", "target": 1, "func": "fork_exec(struct socket *so, const char *ex, int do_pty)\n\n{\n\n\tint s;\n\n\tstruct sockaddr_in addr;\n\n\tsocklen_t addrlen = sizeof(addr);\n\n\tint opt;\n\n\tconst char *argv[256];\n\n\t/* don't want to clobber the original */\n\n\tchar *bptr;\n\n\tconst char *curarg;\n\n\tint c, i, ret;\n\n\tpid_t pid;\n\n\n\n\tDEBUG_CALL(\"fork_exec\");\n\n\tDEBUG_ARG(\"so = %p\", so);\n\n\tDEBUG_ARG(\"ex = %p\", ex);\n\n\tDEBUG_ARG(\"do_pty = %x\", do_pty);\n\n\n\n\tif (do_pty == 2) {\n\n                return 0;\n\n\t} else {\n\n\t\taddr.sin_family = AF_INET;\n\n\t\taddr.sin_port = 0;\n\n\t\taddr.sin_addr.s_addr = INADDR_ANY;\n\n\n\n\t\tif ((s = qemu_socket(AF_INET, SOCK_STREAM, 0)) < 0 ||\n\n\t\t    bind(s, (struct sockaddr *)&addr, addrlen) < 0 ||\n\n\t\t    listen(s, 1) < 0) {\n\n\t\t\terror_report(\"Error: inet socket: %s\", strerror(errno));\n\n\t\t\tclosesocket(s);\n\n\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\n\n\tpid = fork();\n\n\tswitch(pid) {\n\n\t case -1:\n\n\t\terror_report(\"Error: fork failed: %s\", strerror(errno));\n\n\t\tclose(s);\n\n\t\treturn 0;\n\n\n\n\t case 0:\n\n                setsid();\n\n\n\n\t\t/* Set the DISPLAY */\n\n                getsockname(s, (struct sockaddr *)&addr, &addrlen);\n\n                close(s);\n\n                /*\n\n                 * Connect to the socket\n\n                 * XXX If any of these fail, we're in trouble!\n\n                 */\n\n                s = qemu_socket(AF_INET, SOCK_STREAM, 0);\n\n                addr.sin_addr = loopback_addr;\n\n                do {\n\n                    ret = connect(s, (struct sockaddr *)&addr, addrlen);\n\n                } while (ret < 0 && errno == EINTR);\n\n\n\n\t\tdup2(s, 0);\n\n\t\tdup2(s, 1);\n\n\t\tdup2(s, 2);\n\n\t\tfor (s = getdtablesize() - 1; s >= 3; s--)\n\n\t\t   close(s);\n\n\n\n\t\ti = 0;\n\n\t\tbptr = g_strdup(ex); /* No need to free() this */\n\n\t\tif (do_pty == 1) {\n\n\t\t\t/* Setup \"slirp.telnetd -x\" */\n\n\t\t\targv[i++] = \"slirp.telnetd\";\n\n\t\t\targv[i++] = \"-x\";\n\n\t\t\targv[i++] = bptr;\n\n\t\t} else\n\n\t\t   do {\n\n\t\t\t/* Change the string into argv[] */\n\n\t\t\tcurarg = bptr;\n\n\t\t\twhile (*bptr != ' ' && *bptr != (char)0)\n\n\t\t\t   bptr++;\n\n\t\t\tc = *bptr;\n\n\t\t\t*bptr++ = (char)0;\n\n\t\t\targv[i++] = g_strdup(curarg);\n\n\t\t   } while (c);\n\n\n\n                argv[i] = NULL;\n\n\t\texecvp(argv[0], (char **)argv);\n\n\n\n\t\t/* Ooops, failed, let's tell the user why */\n\n        fprintf(stderr, \"Error: execvp of %s failed: %s\\n\",\n\n                argv[0], strerror(errno));\n\n\t\tclose(0); close(1); close(2); /* XXX */\n\n\t\texit(1);\n\n\n\n\t default:\n\n\t\tqemu_add_child_watch(pid);\n\n                /*\n\n                 * XXX this could block us...\n\n                 * XXX Should set a timer here, and if accept() doesn't\n\n                 * return after X seconds, declare it a failure\n\n                 * The only reason this will block forever is if socket()\n\n                 * of connect() fail in the child process\n\n                 */\n\n                do {\n\n                    so->s = accept(s, (struct sockaddr *)&addr, &addrlen);\n\n                } while (so->s < 0 && errno == EINTR);\n\n                closesocket(s);\n\n                socket_set_fast_reuse(so->s);\n\n                opt = 1;\n\n                qemu_setsockopt(so->s, SOL_SOCKET, SO_OOBINLINE, &opt, sizeof(int));\n\n\t\tqemu_set_nonblock(so->s);\n\n\n\n\t\t/* Append the telnet options now */\n\n                if (so->so_m != NULL && do_pty == 1)  {\n\n\t\t\tsbappend(so, so->so_m);\n\n                        so->so_m = NULL;\n\n\t\t}\n\n\n\n\t\treturn 1;\n\n\t}\n\n}\n", "idx": 23662}
{"project": "qemu", "commit_id": "d87aa138039a4be6d705793fd3e397c69c52405a", "target": 1, "func": "static void ohci_td_pkt(const char *msg, const uint8_t *buf, size_t len)\n\n{\n\n    bool print16 = !!trace_event_get_state(TRACE_USB_OHCI_TD_PKT_SHORT);\n\n    bool printall = !!trace_event_get_state(TRACE_USB_OHCI_TD_PKT_FULL);\n\n    const int width = 16;\n\n    int i;\n\n    char tmp[3 * width + 1];\n\n    char *p = tmp;\n\n\n\n    if (!printall && !print16) {\n\n        return;\n\n    }\n\n\n\n    for (i = 0; ; i++) {\n\n        if (i && (!(i % width) || (i == len))) {\n\n            if (!printall) {\n\n                trace_usb_ohci_td_pkt_short(msg, tmp);\n\n                break;\n\n            }\n\n            trace_usb_ohci_td_pkt_full(msg, tmp);\n\n            p = tmp;\n\n            *p = 0;\n\n        }\n\n        if (i == len) {\n\n            break;\n\n        }\n\n\n\n        p += sprintf(p, \" %.2x\", buf[i]);\n\n    }\n\n}\n", "idx": 23663}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "static int vnc_set_x509_credential(VncDisplay *vd,\n\n                                   const char *certdir,\n\n                                   const char *filename,\n\n                                   char **cred,\n\n                                   int ignoreMissing)\n\n{\n\n    struct stat sb;\n\n\n\n    g_free(*cred);\n\n    *cred = g_malloc(strlen(certdir) + strlen(filename) + 2);\n\n\n\n    strcpy(*cred, certdir);\n\n    strcat(*cred, \"/\");\n\n    strcat(*cred, filename);\n\n\n\n    VNC_DEBUG(\"Check %s\\n\", *cred);\n\n    if (stat(*cred, &sb) < 0) {\n\n        g_free(*cred);\n\n        *cred = NULL;\n\n        if (ignoreMissing && errno == ENOENT)\n\n            return 0;\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23666}
{"project": "qemu", "commit_id": "b5aec39672dc6084b43fa3f77764a6f549255a53", "target": 1, "func": "int kvmppc_remove_spapr_tce(void *table, int fd, uint32_t window_size)\n\n{\n\n    long len;\n\n\n\n    if (fd < 0) {\n\n        return -1;\n\n    }\n\n\n\n    len = (window_size / SPAPR_VIO_TCE_PAGE_SIZE)*sizeof(VIOsPAPR_RTCE);\n\n    if ((munmap(table, len) < 0) ||\n\n        (close(fd) < 0)) {\n\n        fprintf(stderr, \"KVM: Unexpected error removing KVM SPAPR TCE \"\n\n                \"table: %s\", strerror(errno));\n\n        /* Leak the table */\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23667}
{"project": "qemu", "commit_id": "b20909195745c34a819aed14ae996b60ab0f591f", "target": 1, "func": "iscsi_aio_read16_cb(struct iscsi_context *iscsi, int status,\n\n                    void *command_data, void *opaque)\n\n{\n\n    IscsiAIOCB *acb = opaque;\n\n\n\n    trace_iscsi_aio_read16_cb(iscsi, status, acb, acb->canceled);\n\n\n\n    if (acb->canceled) {\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    acb->status = 0;\n\n    if (status != 0) {\n\n        error_report(\"Failed to read16 data from iSCSI lun. %s\",\n\n                     iscsi_get_error(iscsi));\n\n        acb->status = -EIO;\n\n    }\n\n\n\n    iscsi_schedule_bh(iscsi_readv_writev_bh_cb, acb);\n\n}\n", "idx": 23670}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int uhci_complete_td(UHCIState *s, UHCI_TD *td, UHCIAsync *async, uint32_t *int_mask)\n\n{\n\n    int len = 0, max_len, err, ret;\n\n    uint8_t pid;\n\n\n\n    max_len = ((td->token >> 21) + 1) & 0x7ff;\n\n    pid = td->token & 0xff;\n\n\n\n    ret = async->packet.len;\n\n\n\n    if (td->ctrl & TD_CTRL_IOS)\n\n        td->ctrl &= ~TD_CTRL_ACTIVE;\n\n\n\n    if (ret < 0)\n\n        goto out;\n\n\n\n    len = async->packet.len;\n\n    td->ctrl = (td->ctrl & ~0x7ff) | ((len - 1) & 0x7ff);\n\n\n\n    /* The NAK bit may have been set by a previous frame, so clear it\n\n       here.  The docs are somewhat unclear, but win2k relies on this\n\n       behavior.  */\n\n    td->ctrl &= ~(TD_CTRL_ACTIVE | TD_CTRL_NAK);\n\n    if (td->ctrl & TD_CTRL_IOC)\n\n        *int_mask |= 0x01;\n\n\n\n    if (pid == USB_TOKEN_IN) {\n\n        if (len > max_len) {\n\n            ret = USB_RET_BABBLE;\n\n            goto out;\n\n        }\n\n\n\n        if (len > 0) {\n\n            /* write the data back */\n\n            cpu_physical_memory_write(td->buffer, async->buffer, len);\n\n        }\n\n\n\n        if ((td->ctrl & TD_CTRL_SPD) && len < max_len) {\n\n            *int_mask |= 0x02;\n\n            /* short packet: do not update QH */\n\n            DPRINTF(\"uhci: short packet. td 0x%x token 0x%x\\n\", async->td, async->token);\n\n            return 1;\n\n        }\n\n    }\n\n\n\n    /* success */\n\n    return 0;\n\n\n\nout:\n\n    switch(ret) {\n\n    case USB_RET_STALL:\n\n        td->ctrl |= TD_CTRL_STALL;\n\n        td->ctrl &= ~TD_CTRL_ACTIVE;\n\n        s->status |= UHCI_STS_USBERR;\n\n        if (td->ctrl & TD_CTRL_IOC) {\n\n            *int_mask |= 0x01;\n\n        }\n\n        uhci_update_irq(s);\n\n        return 1;\n\n\n\n    case USB_RET_BABBLE:\n\n        td->ctrl |= TD_CTRL_BABBLE | TD_CTRL_STALL;\n\n        td->ctrl &= ~TD_CTRL_ACTIVE;\n\n        s->status |= UHCI_STS_USBERR;\n\n        if (td->ctrl & TD_CTRL_IOC) {\n\n            *int_mask |= 0x01;\n\n        }\n\n        uhci_update_irq(s);\n\n        /* frame interrupted */\n\n        return -1;\n\n\n\n    case USB_RET_NAK:\n\n        td->ctrl |= TD_CTRL_NAK;\n\n        if (pid == USB_TOKEN_SETUP)\n\n            break;\n\n\treturn 1;\n\n\n\n    case USB_RET_NODEV:\n\n    default:\n\n\tbreak;\n\n    }\n\n\n\n    /* Retry the TD if error count is not zero */\n\n\n\n    td->ctrl |= TD_CTRL_TIMEOUT;\n\n    err = (td->ctrl >> TD_CTRL_ERROR_SHIFT) & 3;\n\n    if (err != 0) {\n\n        err--;\n\n        if (err == 0) {\n\n            td->ctrl &= ~TD_CTRL_ACTIVE;\n\n            s->status |= UHCI_STS_USBERR;\n\n            if (td->ctrl & TD_CTRL_IOC)\n\n                *int_mask |= 0x01;\n\n            uhci_update_irq(s);\n\n        }\n\n    }\n\n    td->ctrl = (td->ctrl & ~(3 << TD_CTRL_ERROR_SHIFT)) |\n\n        (err << TD_CTRL_ERROR_SHIFT);\n\n    return 1;\n\n}\n", "idx": 23671}
{"project": "qemu", "commit_id": "12848bfc5d719bad536c5448205a3226be1fda47", "target": 1, "func": "static int local_chmod(FsContext *fs_ctx, const char *path, FsCred *credp)\n\n{\n\n    if (fs_ctx->fs_sm == SM_MAPPED) {\n\n        return local_set_xattr(rpath(fs_ctx, path), credp);\n\n    } else if (fs_ctx->fs_sm == SM_PASSTHROUGH) {\n\n        return chmod(rpath(fs_ctx, path), credp->fc_mode);\n\n    }\n\n    return -1;\n\n}\n", "idx": 23673}
{"project": "qemu", "commit_id": "cd7bc87868d534f95e928cad98e2a52df7695771", "target": 1, "func": "static void usb_msd_class_initfn_storage(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);\n\n\n\n    uc->realize = usb_msd_realize_storage;\n\n\n    dc->props = msd_properties;\n\n}", "idx": 23674}
{"project": "qemu", "commit_id": "480cff632221dc4d4889bf72dd0f09cd35096bc1", "target": 1, "func": "void coroutine_fn qemu_co_mutex_unlock(CoMutex *mutex)\n\n{\n\n    Coroutine *self = qemu_coroutine_self();\n\n\n\n    trace_qemu_co_mutex_unlock_entry(mutex, self);\n\n\n\n    assert(mutex->locked);\n\n    assert(mutex->holder == self);\n\n    assert(qemu_in_coroutine());\n\n\n\n    mutex->holder = NULL;\n\n    self->locks_held--;\n\n    if (atomic_fetch_dec(&mutex->locked) == 1) {\n\n        /* No waiting qemu_co_mutex_lock().  Pfew, that was easy!  */\n\n        return;\n\n    }\n\n\n\n    for (;;) {\n\n        CoWaitRecord *to_wake = pop_waiter(mutex);\n\n        unsigned our_handoff;\n\n\n\n        if (to_wake) {\n\n            Coroutine *co = to_wake->co;\n\n            aio_co_wake(co);\n\n            break;\n\n        }\n\n\n\n        /* Some concurrent lock() is in progress (we know this because\n\n         * mutex->locked was >1) but it hasn't yet put itself on the wait\n\n         * queue.  Pick a sequence number for the handoff protocol (not 0).\n\n         */\n\n        if (++mutex->sequence == 0) {\n\n            mutex->sequence = 1;\n\n        }\n\n\n\n        our_handoff = mutex->sequence;\n\n        atomic_mb_set(&mutex->handoff, our_handoff);\n\n        if (!has_waiters(mutex)) {\n\n            /* The concurrent lock has not added itself yet, so it\n\n             * will be able to pick our handoff.\n\n             */\n\n            break;\n\n        }\n\n\n\n        /* Try to do the handoff protocol ourselves; if somebody else has\n\n         * already taken it, however, we're done and they're responsible.\n\n         */\n\n        if (atomic_cmpxchg(&mutex->handoff, our_handoff, 0) != our_handoff) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    trace_qemu_co_mutex_unlock_return(mutex, self);\n\n}\n", "idx": 23675}
{"project": "qemu", "commit_id": "30aa5c0d303c334c646e9db1ebadda0c0db8b13f", "target": 1, "func": "static uint32_t nvram_readb (void *opaque, target_phys_addr_t addr)\r\n\n{\r\n\n    ds1225y_t *NVRAM = opaque;\r\n\n    int64_t pos;\r\n\n\r\n\n    pos = addr - NVRAM->mem_base;\r\n\n    if (addr >= NVRAM->capacity)\r\n\n        addr -= NVRAM->capacity;\r\n\n\r\n\n    if (!ds1225y_set_to_mode(NVRAM, readmode, \"rb\"))\r\n\n        return 0;\r\n\n    qemu_fseek(NVRAM->file, pos, SEEK_SET);\r\n\n    return (uint32_t)qemu_get_byte(NVRAM->file);\r\n\n}\r\n", "idx": 23677}
{"project": "qemu", "commit_id": "761731b1805f6ef64eb615e5b82a0801db3cde78", "target": 0, "func": "void qmp_drive_backup(const char *device, const char *target,\n\n                      bool has_format, const char *format,\n\n                      enum MirrorSyncMode sync,\n\n                      bool has_mode, enum NewImageMode mode,\n\n                      bool has_speed, int64_t speed,\n\n                      bool has_on_source_error, BlockdevOnError on_source_error,\n\n                      bool has_on_target_error, BlockdevOnError on_target_error,\n\n                      Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *target_bs;\n\n    BlockDriverState *source = NULL;\n\n    BlockDriver *drv = NULL;\n\n    Error *local_err = NULL;\n\n    int flags;\n\n    int64_t size;\n\n    int ret;\n\n\n\n    if (!has_speed) {\n\n        speed = 0;\n\n    }\n\n    if (!has_on_source_error) {\n\n        on_source_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n    if (!has_on_target_error) {\n\n        on_target_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n    if (!has_mode) {\n\n        mode = NEW_IMAGE_MODE_ABSOLUTE_PATHS;\n\n    }\n\n\n\n    bs = bdrv_find(device);\n\n    if (!bs) {\n\n        error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n\n        return;\n\n    }\n\n\n\n    if (!bdrv_is_inserted(bs)) {\n\n        error_set(errp, QERR_DEVICE_HAS_NO_MEDIUM, device);\n\n        return;\n\n    }\n\n\n\n    if (!has_format) {\n\n        format = mode == NEW_IMAGE_MODE_EXISTING ? NULL : bs->drv->format_name;\n\n    }\n\n    if (format) {\n\n        drv = bdrv_find_format(format);\n\n        if (!drv) {\n\n            error_set(errp, QERR_INVALID_BLOCK_FORMAT, format);\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_BACKUP_SOURCE, errp)) {\n\n        return;\n\n    }\n\n\n\n    flags = bs->open_flags | BDRV_O_RDWR;\n\n\n\n    /* See if we have a backing HD we can use to create our new image\n\n     * on top of. */\n\n    if (sync == MIRROR_SYNC_MODE_TOP) {\n\n        source = bs->backing_hd;\n\n        if (!source) {\n\n            sync = MIRROR_SYNC_MODE_FULL;\n\n        }\n\n    }\n\n    if (sync == MIRROR_SYNC_MODE_NONE) {\n\n        source = bs;\n\n    }\n\n\n\n    size = bdrv_getlength(bs);\n\n    if (size < 0) {\n\n        error_setg_errno(errp, -size, \"bdrv_getlength failed\");\n\n        return;\n\n    }\n\n\n\n    if (mode != NEW_IMAGE_MODE_EXISTING) {\n\n        assert(format && drv);\n\n        if (source) {\n\n            bdrv_img_create(target, format, source->filename,\n\n                            source->drv->format_name, NULL,\n\n                            size, flags, &local_err, false);\n\n        } else {\n\n            bdrv_img_create(target, format, NULL, NULL, NULL,\n\n                            size, flags, &local_err, false);\n\n        }\n\n    }\n\n\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    target_bs = NULL;\n\n    ret = bdrv_open(&target_bs, target, NULL, NULL, flags, drv, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    backup_start(bs, target_bs, speed, sync, on_source_error, on_target_error,\n\n                 block_job_cb, bs, &local_err);\n\n    if (local_err != NULL) {\n\n        bdrv_unref(target_bs);\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n}\n", "idx": 23680}
{"project": "qemu", "commit_id": "9ea63c05d90ba85d819f9b2472ce6dfba7a403b4", "target": 0, "func": "int do_subchannel_work_virtual(SubchDev *sch)\n\n{\n\n\n\n    SCSW *s = &sch->curr_status.scsw;\n\n\n\n    if (s->ctrl & SCSW_FCTL_CLEAR_FUNC) {\n\n        sch_handle_clear_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_HALT_FUNC) {\n\n        sch_handle_halt_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_START_FUNC) {\n\n        /* Triggered by both ssch and rsch. */\n\n        sch_handle_start_func_virtual(sch);\n\n    } else {\n\n        /* Cannot happen. */\n\n        return 0;\n\n    }\n\n    css_inject_io_interrupt(sch);\n\n    return 0;\n\n}\n", "idx": 23682}
{"project": "qemu", "commit_id": "debaaa114a8877a939533ba846e64168fb287b7b", "target": 0, "func": "static void test_dma_fragmented(void)\n\n{\n\n    AHCIQState *ahci;\n\n    AHCICommand *cmd;\n\n    uint8_t px;\n\n    size_t bufsize = 4096;\n\n    unsigned char *tx = g_malloc(bufsize);\n\n    unsigned char *rx = g_malloc0(bufsize);\n\n    uint64_t ptr;\n\n\n\n    ahci = ahci_boot_and_enable();\n\n    px = ahci_port_select(ahci);\n\n    ahci_port_clear(ahci, px);\n\n\n\n    /* create pattern */\n\n    generate_pattern(tx, bufsize, AHCI_SECTOR_SIZE);\n\n\n\n    /* Create a DMA buffer in guest memory, and write our pattern to it. */\n\n    ptr = guest_alloc(ahci->parent->alloc, bufsize);\n\n    g_assert(ptr);\n\n    memwrite(ptr, tx, bufsize);\n\n\n\n    cmd = ahci_command_create(CMD_WRITE_DMA);\n\n    ahci_command_adjust(cmd, 0, ptr, bufsize, 32);\n\n    ahci_command_commit(ahci, cmd, px);\n\n    ahci_command_issue(ahci, cmd);\n\n    ahci_command_verify(ahci, cmd);\n\n    g_free(cmd);\n\n\n\n    cmd = ahci_command_create(CMD_READ_DMA);\n\n    ahci_command_adjust(cmd, 0, ptr, bufsize, 32);\n\n    ahci_command_commit(ahci, cmd, px);\n\n    ahci_command_issue(ahci, cmd);\n\n    ahci_command_verify(ahci, cmd);\n\n    g_free(cmd);\n\n\n\n    /* Read back the guest's receive buffer into local memory */\n\n    memread(ptr, rx, bufsize);\n\n    guest_free(ahci->parent->alloc, ptr);\n\n\n\n    g_assert_cmphex(memcmp(tx, rx, bufsize), ==, 0);\n\n\n\n    ahci_shutdown(ahci);\n\n\n\n    g_free(rx);\n\n    g_free(tx);\n\n}\n", "idx": 23683}
{"project": "qemu", "commit_id": "1c275925bfbbc2de84a8f0e09d1dd70bbefb6da3", "target": 0, "func": "static long do_rt_sigreturn_v1(CPUARMState *env)\n\n{\n\n        abi_ulong frame_addr;\n\n        struct rt_sigframe_v1 *frame = NULL;\n\n        sigset_t host_set;\n\n\n\n\t/*\n\n\t * Since we stacked the signal on a 64-bit boundary,\n\n\t * then 'sp' should be word aligned here.  If it's\n\n\t * not, then the user is trying to mess with us.\n\n\t */\n\n        frame_addr = env->regs[13];\n\n        if (frame_addr & 7) {\n\n            goto badframe;\n\n        }\n\n\n\n\tif (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))\n\n                goto badframe;\n\n\n\n        target_to_host_sigset(&host_set, &frame->uc.tuc_sigmask);\n\n        sigprocmask(SIG_SETMASK, &host_set, NULL);\n\n\n\n\tif (restore_sigcontext(env, &frame->uc.tuc_mcontext))\n\n\t\tgoto badframe;\n\n\n\n\tif (do_sigaltstack(frame_addr + offsetof(struct rt_sigframe_v1, uc.tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)\n\n\t\tgoto badframe;\n\n\n\n#if 0\n\n\t/* Send SIGTRAP if we're single-stepping */\n\n\tif (ptrace_cancel_bpt(current))\n\n\t\tsend_sig(SIGTRAP, current, 1);\n\n#endif\n\n\tunlock_user_struct(frame, frame_addr, 0);\n\n\treturn env->regs[0];\n\n\n\nbadframe:\n\n\tunlock_user_struct(frame, frame_addr, 0);\n\n        force_sig(TARGET_SIGSEGV /* , current */);\n\n\treturn 0;\n\n}\n", "idx": 23684}
{"project": "qemu", "commit_id": "f3c3b87dae44ac6c82246ceb3953793951800a9a", "target": 0, "func": "int qcow2_cache_flush(BlockDriverState *bs, Qcow2Cache *c)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int result = 0;\n\n    int ret;\n\n    int i;\n\n\n\n    trace_qcow2_cache_flush(qemu_coroutine_self(), c == s->l2_table_cache);\n\n\n\n    for (i = 0; i < c->size; i++) {\n\n        ret = qcow2_cache_entry_flush(bs, c, i);\n\n        if (ret < 0 && result != -ENOSPC) {\n\n            result = ret;\n\n        }\n\n    }\n\n\n\n    if (result == 0) {\n\n        ret = bdrv_flush(bs->file->bs);\n\n        if (ret < 0) {\n\n            result = ret;\n\n        }\n\n    }\n\n\n\n    return result;\n\n}\n", "idx": 23685}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static inline uint64_t ldq_phys_internal(target_phys_addr_t addr,\n\n                                         enum device_endian endian)\n\n{\n\n    uint8_t *ptr;\n\n    uint64_t val;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);\n\n\n\n    if (!(memory_region_is_ram(section->mr) ||\n\n          memory_region_is_romd(section->mr))) {\n\n        /* I/O case */\n\n        addr = memory_region_section_addr(section, addr);\n\n\n\n        /* XXX This is broken when device endian != cpu endian.\n\n               Fix and add \"endian\" variable check */\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n        val = io_mem_read(section->mr, addr, 4) << 32;\n\n        val |= io_mem_read(section->mr, addr + 4, 4);\n\n#else\n\n        val = io_mem_read(section->mr, addr, 4);\n\n        val |= io_mem_read(section->mr, addr + 4, 4) << 32;\n\n#endif\n\n    } else {\n\n        /* RAM case */\n\n        ptr = qemu_get_ram_ptr((memory_region_get_ram_addr(section->mr)\n\n                                & TARGET_PAGE_MASK)\n\n                               + memory_region_section_addr(section, addr));\n\n        switch (endian) {\n\n        case DEVICE_LITTLE_ENDIAN:\n\n            val = ldq_le_p(ptr);\n\n            break;\n\n        case DEVICE_BIG_ENDIAN:\n\n            val = ldq_be_p(ptr);\n\n            break;\n\n        default:\n\n            val = ldq_p(ptr);\n\n            break;\n\n        }\n\n    }\n\n    return val;\n\n}\n", "idx": 23686}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "MemoryRegion *pci_address_space_io(PCIDevice *dev)\n\n{\n\n    return dev->bus->address_space_io;\n\n}\n", "idx": 23687}
{"project": "qemu", "commit_id": "35c648078aa493c3b976840eb7cf2e53ab5b7a2d", "target": 0, "func": "static void malta_fpga_write(void *opaque, hwaddr addr,\n\n                             uint64_t val, unsigned size)\n\n{\n\n    MaltaFPGAState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = (addr & 0xfffff);\n\n\n\n    switch (saddr) {\n\n\n\n    /* SWITCH Register */\n\n    case 0x00200:\n\n        break;\n\n\n\n    /* JMPRS Register */\n\n    case 0x00210:\n\n        break;\n\n\n\n    /* LEDBAR Register */\n\n    case 0x00408:\n\n        s->leds = val & 0xff;\n\n        malta_fpga_update_display(s);\n\n        break;\n\n\n\n    /* ASCIIWORD Register */\n\n    case 0x00410:\n\n        snprintf(s->display_text, 9, \"%08X\", (uint32_t)val);\n\n        malta_fpga_update_display(s);\n\n        break;\n\n\n\n    /* ASCIIPOS0 to ASCIIPOS7 Registers */\n\n    case 0x00418:\n\n    case 0x00420:\n\n    case 0x00428:\n\n    case 0x00430:\n\n    case 0x00438:\n\n    case 0x00440:\n\n    case 0x00448:\n\n    case 0x00450:\n\n        s->display_text[(saddr - 0x00418) >> 3] = (char) val;\n\n        malta_fpga_update_display(s);\n\n        break;\n\n\n\n    /* SOFTRES Register */\n\n    case 0x00500:\n\n        if (val == 0x42)\n\n            qemu_system_reset_request ();\n\n        break;\n\n\n\n    /* BRKRES Register */\n\n    case 0x00508:\n\n        s->brk = val & 0xff;\n\n        break;\n\n\n\n    /* UART Registers are handled directly by the serial device */\n\n\n\n    /* GPOUT Register */\n\n    case 0x00a00:\n\n        s->gpout = val & 0xff;\n\n        break;\n\n\n\n    /* I2COE Register */\n\n    case 0x00b08:\n\n        s->i2coe = val & 0x03;\n\n        break;\n\n\n\n    /* I2COUT Register */\n\n    case 0x00b10:\n\n        eeprom24c0x_write(val & 0x02, val & 0x01);\n\n        s->i2cout = val;\n\n        break;\n\n\n\n    /* I2CSEL Register */\n\n    case 0x00b18:\n\n        s->i2csel = val & 0x01;\n\n        break;\n\n\n\n    default:\n\n#if 0\n\n        printf (\"malta_fpga_write: Bad register offset 0x\" TARGET_FMT_lx \"\\n\",\n\n                addr);\n\n#endif\n\n        break;\n\n    }\n\n}\n", "idx": 23688}
{"project": "qemu", "commit_id": "2e6fc7eb1a4af1b127df5f07b8bb28af891946fa", "target": 0, "func": "static int raw_reopen_prepare(BDRVReopenState *reopen_state,\n\n                              BlockReopenQueue *queue, Error **errp)\n\n{\n\n    assert(reopen_state != NULL);\n\n    assert(reopen_state->bs != NULL);\n\n\n\n    reopen_state->opaque = g_new0(BDRVRawState, 1);\n\n\n\n    return raw_read_options(\n\n        reopen_state->options,\n\n        reopen_state->bs,\n\n        reopen_state->opaque,\n\n        errp);\n\n}\n", "idx": 23689}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void lm32_uclinux_init(QEMUMachineInitArgs *args)\n\n{\n\n    const char *cpu_model = args->cpu_model;\n\n    const char *kernel_filename = args->kernel_filename;\n\n    const char *kernel_cmdline = args->kernel_cmdline;\n\n    const char *initrd_filename = args->initrd_filename;\n\n    LM32CPU *cpu;\n\n    CPULM32State *env;\n\n    DriveInfo *dinfo;\n\n    MemoryRegion *address_space_mem =  get_system_memory();\n\n    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);\n\n    qemu_irq *cpu_irq, irq[32];\n\n    HWSetup *hw;\n\n    ResetInfo *reset_info;\n\n    int i;\n\n\n\n    /* memory map */\n\n    target_phys_addr_t flash_base   = 0x04000000;\n\n    size_t flash_sector_size        = 256 * 1024;\n\n    size_t flash_size               = 32 * 1024 * 1024;\n\n    target_phys_addr_t ram_base     = 0x08000000;\n\n    size_t ram_size                 = 64 * 1024 * 1024;\n\n    target_phys_addr_t uart0_base   = 0x80000000;\n\n    target_phys_addr_t timer0_base  = 0x80002000;\n\n    target_phys_addr_t timer1_base  = 0x80010000;\n\n    target_phys_addr_t timer2_base  = 0x80012000;\n\n    int uart0_irq                   = 0;\n\n    int timer0_irq                  = 1;\n\n    int timer1_irq                  = 20;\n\n    int timer2_irq                  = 21;\n\n    target_phys_addr_t hwsetup_base = 0x0bffe000;\n\n    target_phys_addr_t cmdline_base = 0x0bfff000;\n\n    target_phys_addr_t initrd_base  = 0x08400000;\n\n    size_t initrd_max               = 0x01000000;\n\n\n\n    reset_info = g_malloc0(sizeof(ResetInfo));\n\n\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"lm32-full\";\n\n    }\n\n    cpu = cpu_lm32_init(cpu_model);\n\n    env = &cpu->env;\n\n    reset_info->cpu = cpu;\n\n\n\n    reset_info->flash_base = flash_base;\n\n\n\n    memory_region_init_ram(phys_ram, \"lm32_uclinux.sdram\", ram_size);\n\n    vmstate_register_ram_global(phys_ram);\n\n    memory_region_add_subregion(address_space_mem, ram_base, phys_ram);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    /* Spansion S29NS128P */\n\n    pflash_cfi02_register(flash_base, NULL, \"lm32_uclinux.flash\", flash_size,\n\n                          dinfo ? dinfo->bdrv : NULL, flash_sector_size,\n\n                          flash_size / flash_sector_size, 1, 2,\n\n                          0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1);\n\n\n\n    /* create irq lines */\n\n    cpu_irq = qemu_allocate_irqs(cpu_irq_handler, env, 1);\n\n    env->pic_state = lm32_pic_init(*cpu_irq);\n\n    for (i = 0; i < 32; i++) {\n\n        irq[i] = qdev_get_gpio_in(env->pic_state, i);\n\n    }\n\n\n\n    sysbus_create_simple(\"lm32-uart\", uart0_base, irq[uart0_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer0_base, irq[timer0_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer1_base, irq[timer1_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer2_base, irq[timer2_irq]);\n\n\n\n    /* make sure juart isn't the first chardev */\n\n    env->juart_state = lm32_juart_init();\n\n\n\n    reset_info->bootstrap_pc = flash_base;\n\n\n\n    if (kernel_filename) {\n\n        uint64_t entry;\n\n        int kernel_size;\n\n\n\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n\n                               1, ELF_MACHINE, 0);\n\n        reset_info->bootstrap_pc = entry;\n\n\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename, ram_base,\n\n                                              ram_size);\n\n            reset_info->bootstrap_pc = ram_base;\n\n        }\n\n\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* generate a rom with the hardware description */\n\n    hw = hwsetup_init();\n\n    hwsetup_add_cpu(hw, \"LM32\", 75000000);\n\n    hwsetup_add_flash(hw, \"flash\", flash_base, flash_size);\n\n    hwsetup_add_ddr_sdram(hw, \"ddr_sdram\", ram_base, ram_size);\n\n    hwsetup_add_timer(hw, \"timer0\", timer0_base, timer0_irq);\n\n    hwsetup_add_timer(hw, \"timer1_dev_only\", timer1_base, timer1_irq);\n\n    hwsetup_add_timer(hw, \"timer2_dev_only\", timer2_base, timer2_irq);\n\n    hwsetup_add_uart(hw, \"uart\", uart0_base, uart0_irq);\n\n    hwsetup_add_trailer(hw);\n\n    hwsetup_create_rom(hw, hwsetup_base);\n\n    hwsetup_free(hw);\n\n\n\n    reset_info->hwsetup_base = hwsetup_base;\n\n\n\n    if (kernel_cmdline && strlen(kernel_cmdline)) {\n\n        pstrcpy_targphys(\"cmdline\", cmdline_base, TARGET_PAGE_SIZE,\n\n                kernel_cmdline);\n\n        reset_info->cmdline_base = cmdline_base;\n\n    }\n\n\n\n    if (initrd_filename) {\n\n        size_t initrd_size;\n\n        initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                initrd_max);\n\n        reset_info->initrd_base = initrd_base;\n\n        reset_info->initrd_size = initrd_size;\n\n    }\n\n\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n}\n", "idx": 23690}
{"project": "qemu", "commit_id": "ba14414174b72fa231997243a9650feaa520d054", "target": 0, "func": "static void timestamp_put(QDict *qdict)\n\n{\n\n    int err;\n\n    QObject *obj;\n\n    qemu_timeval tv;\n\n\n\n    err = qemu_gettimeofday(&tv);\n\n    if (err < 0)\n\n        return;\n\n\n\n    obj = qobject_from_jsonf(\"{ 'seconds': %\" PRId64 \", \"\n\n                                \"'microseconds': %\" PRId64 \" }\",\n\n                                (int64_t) tv.tv_sec, (int64_t) tv.tv_usec);\n\n    assert(obj != NULL);\n\n\n\n    qdict_put_obj(qdict, \"timestamp\", obj);\n\n}\n", "idx": 23691}
{"project": "qemu", "commit_id": "1c275925bfbbc2de84a8f0e09d1dd70bbefb6da3", "target": 0, "func": "static int target_restore_sigframe(CPUARMState *env,\n\n                                   struct target_rt_sigframe *sf)\n\n{\n\n    sigset_t set;\n\n    int i;\n\n    struct target_aux_context *aux =\n\n        (struct target_aux_context *)sf->uc.tuc_mcontext.__reserved;\n\n    uint32_t magic, size, fpsr, fpcr;\n\n    uint64_t pstate;\n\n\n\n    target_to_host_sigset(&set, &sf->uc.tuc_sigmask);\n\n    sigprocmask(SIG_SETMASK, &set, NULL);\n\n\n\n    for (i = 0; i < 31; i++) {\n\n        __get_user(env->xregs[i], &sf->uc.tuc_mcontext.regs[i]);\n\n    }\n\n\n\n    __get_user(env->xregs[31], &sf->uc.tuc_mcontext.sp);\n\n    __get_user(env->pc, &sf->uc.tuc_mcontext.pc);\n\n    __get_user(pstate, &sf->uc.tuc_mcontext.pstate);\n\n    pstate_write(env, pstate);\n\n\n\n    __get_user(magic, &aux->fpsimd.head.magic);\n\n    __get_user(size, &aux->fpsimd.head.size);\n\n\n\n    if (magic != TARGET_FPSIMD_MAGIC\n\n        || size != sizeof(struct target_fpsimd_context)) {\n\n        return 1;\n\n    }\n\n\n\n    for (i = 0; i < 32; i++) {\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n        __get_user(env->vfp.regs[i * 2], &aux->fpsimd.vregs[i * 2 + 1]);\n\n        __get_user(env->vfp.regs[i * 2 + 1], &aux->fpsimd.vregs[i * 2]);\n\n#else\n\n        __get_user(env->vfp.regs[i * 2], &aux->fpsimd.vregs[i * 2]);\n\n        __get_user(env->vfp.regs[i * 2 + 1], &aux->fpsimd.vregs[i * 2 + 1]);\n\n#endif\n\n    }\n\n    __get_user(fpsr, &aux->fpsimd.fpsr);\n\n    vfp_set_fpsr(env, fpsr);\n\n    __get_user(fpcr, &aux->fpsimd.fpcr);\n\n    vfp_set_fpcr(env, fpcr);\n\n\n\n    return 0;\n\n}\n", "idx": 23694}
{"project": "qemu", "commit_id": "8a5956ad6392f115521dad774055c737c49fb0dd", "target": 0, "func": "static void reclaim_list_el(struct rcu_head *prcu)\n\n{\n\n    struct list_element *el = container_of(prcu, struct list_element, rcu);\n\n    g_free(el);\n\n    atomic_add(&n_reclaims, 1);\n\n}\n", "idx": 23695}
{"project": "qemu", "commit_id": "37ad223c515da2fe9f1c679768cb5ccaa42e57e1", "target": 0, "func": "build_hpet(GArray *table_data, GArray *linker)\n\n{\n\n    Acpi20Hpet *hpet;\n\n\n\n    hpet = acpi_data_push(table_data, sizeof(*hpet));\n\n    /* Note timer_block_id value must be kept in sync with value advertised by\n\n     * emulated hpet\n\n     */\n\n    hpet->timer_block_id = cpu_to_le32(0x8086a201);\n\n    hpet->addr.address = cpu_to_le64(HPET_BASE);\n\n    build_header(linker, table_data,\n\n                 (void *)hpet, \"HPET\", sizeof(*hpet), 1, NULL);\n\n}\n", "idx": 23696}
{"project": "qemu", "commit_id": "2374e73edafff0586cbfb67c333c5a7588f81fd5", "target": 0, "func": "uint64_t helper_ld_virt_to_phys (uint64_t virtaddr)\n\n{\n\n    uint64_t tlb_addr, physaddr;\n\n    int index, mmu_idx;\n\n    void *retaddr;\n\n\n\n    mmu_idx = cpu_mmu_index(env);\n\n    index = (virtaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n redo:\n\n    tlb_addr = env->tlb_table[mmu_idx][index].addr_read;\n\n    if ((virtaddr & TARGET_PAGE_MASK) ==\n\n        (tlb_addr & (TARGET_PAGE_MASK | TLB_INVALID_MASK))) {\n\n        physaddr = virtaddr + env->tlb_table[mmu_idx][index].addend;\n\n    } else {\n\n        /* the page is not in the TLB : fill it */\n\n        retaddr = GETPC();\n\n        tlb_fill(virtaddr, 0, mmu_idx, retaddr);\n\n        goto redo;\n\n    }\n\n    return physaddr;\n\n}\n", "idx": 23697}
{"project": "qemu", "commit_id": "08b277ac46da8b02e50cec455eca7cb2d12ffcf0", "target": 0, "func": "static bool less_than_7(void *opaque, int version_id)\n\n{\n\n    return version_id < 7;\n\n}\n", "idx": 23698}
{"project": "qemu", "commit_id": "506590836144af7d0de3fc4c691bb5ed49d41645", "target": 0, "func": "static void ppc_hash64_set_isi(CPUState *cs, CPUPPCState *env,\n\n                               uint64_t error_code)\n\n{\n\n    bool vpm;\n\n\n\n    if (msr_ir) {\n\n        vpm = !!(env->spr[SPR_LPCR] & LPCR_VPM1);\n\n    } else {\n\n        vpm = !!(env->spr[SPR_LPCR] & LPCR_VPM0);\n\n    }\n\n    if (vpm && !msr_hv) {\n\n        cs->exception_index = POWERPC_EXCP_HISI;\n\n    } else {\n\n        cs->exception_index = POWERPC_EXCP_ISI;\n\n    }\n\n    env->error_code = error_code;\n\n}\n", "idx": 23699}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static int vnc_tls_initialize(void)\n\n{\n\n    static int tlsinitialized = 0;\n\n\n\n    if (tlsinitialized)\n\n\treturn 1;\n\n\n\n    if (gnutls_global_init () < 0)\n\n\treturn 0;\n\n\n\n    /* XXX ought to re-generate diffie-hellmen params periodically */\n\n    if (gnutls_dh_params_init (&dh_params) < 0)\n\n\treturn 0;\n\n    if (gnutls_dh_params_generate2 (dh_params, DH_BITS) < 0)\n\n\treturn 0;\n\n\n\n#if defined(_VNC_DEBUG) && _VNC_DEBUG >= 2\n\n    gnutls_global_set_log_level(10);\n\n    gnutls_global_set_log_function(vnc_debug_gnutls_log);\n\n#endif\n\n\n\n    tlsinitialized = 1;\n\n\n\n    return 1;\n\n}\n", "idx": 23700}
{"project": "qemu", "commit_id": "285f7a62e464eac97e472ba6803ddede1e6c459e", "target": 0, "func": "void slirp_init(int restricted, struct in_addr vnetwork,\n\n                struct in_addr vnetmask, struct in_addr vhost,\n\n                const char *vhostname, const char *tftp_path,\n\n                const char *bootfile, struct in_addr vdhcp_start,\n\n                struct in_addr vnameserver)\n\n{\n\n    slirp_init_once();\n\n\n\n    link_up = 1;\n\n    slirp_restrict = restricted;\n\n\n\n    if_init();\n\n    ip_init();\n\n\n\n    /* Initialise mbufs *after* setting the MTU */\n\n    m_init();\n\n\n\n    vnetwork_addr = vnetwork;\n\n    vnetwork_mask = vnetmask;\n\n    vhost_addr = vhost;\n\n    if (vhostname) {\n\n        pstrcpy(slirp_hostname, sizeof(slirp_hostname), vhostname);\n\n    }\n\n    qemu_free(tftp_prefix);\n\n    tftp_prefix = NULL;\n\n    if (tftp_path) {\n\n        tftp_prefix = qemu_strdup(tftp_path);\n\n    }\n\n    qemu_free(bootp_filename);\n\n    bootp_filename = NULL;\n\n    if (bootfile) {\n\n        bootp_filename = qemu_strdup(bootfile);\n\n    }\n\n    vdhcp_startaddr = vdhcp_start;\n\n    vnameserver_addr = vnameserver;\n\n\n\n    register_savevm(\"slirp\", 0, 1, slirp_state_save, slirp_state_load, NULL);\n\n}\n", "idx": 23701}
{"project": "qemu", "commit_id": "991f8f0c91d65cebf51fa931450e02b0d5209012", "target": 0, "func": "static void bswap_phdr(struct elf_phdr *phdr)\n\n{\n\n    bswap32s(&phdr->p_type);            /* Segment type */\n\n    bswaptls(&phdr->p_offset);          /* Segment file offset */\n\n    bswaptls(&phdr->p_vaddr);           /* Segment virtual address */\n\n    bswaptls(&phdr->p_paddr);           /* Segment physical address */\n\n    bswaptls(&phdr->p_filesz);          /* Segment size in file */\n\n    bswaptls(&phdr->p_memsz);           /* Segment size in memory */\n\n    bswap32s(&phdr->p_flags);           /* Segment flags */\n\n    bswaptls(&phdr->p_align);           /* Segment alignment */\n\n}\n", "idx": 23702}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t ahci_idp_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    AHCIState *s = opaque;\n\n\n\n    if (addr == s->idp_offset) {\n\n        /* index register */\n\n        return s->idp_index;\n\n    } else if (addr == s->idp_offset + 4) {\n\n        /* data register - do memory read at location selected by index */\n\n        return ahci_mem_read(opaque, s->idp_index, size);\n\n    } else {\n\n        return 0;\n\n    }\n\n}\n", "idx": 23703}
{"project": "qemu", "commit_id": "9005b2a7589540a3733b3abdcfbccfe7746cd1a1", "target": 0, "func": "int qemu_chr_fe_write(CharDriverState *s, const uint8_t *buf, int len)\n\n{\n\n    return s->chr_write(s, buf, len);\n\n}\n", "idx": 23705}
{"project": "qemu", "commit_id": "27a69bb088bee6d4efea254659422fb9c751b3c7", "target": 0, "func": "static inline void gen_efdabs(DisasContext *ctx)\n\n{\n\n    if (unlikely(!ctx->spe_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_APU);\n\n        return;\n\n    }\n\n#if defined(TARGET_PPC64)\n\n    tcg_gen_andi_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], ~0x8000000000000000LL);\n\n#else\n\n    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_andi_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], ~0x80000000);\n\n#endif\n\n}\n", "idx": 23706}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "static inline void gen_op_mfspr (DisasContext *ctx)\n\n{\n\n    void (*read_cb)(void *opaque, int sprn);\n\n    uint32_t sprn = SPR(ctx->opcode);\n\n\n\n#if !defined(CONFIG_USER_ONLY)\n\n    if (ctx->supervisor)\n\n        read_cb = ctx->spr_cb[sprn].oea_read;\n\n    else\n\n#endif\n\n        read_cb = ctx->spr_cb[sprn].uea_read;\n\n    if (likely(read_cb != NULL)) {\n\n        if (likely(read_cb != SPR_NOACCESS)) {\n\n            (*read_cb)(ctx, sprn);\n\n            gen_op_store_T0_gpr(rD(ctx->opcode));\n\n        } else {\n\n            /* Privilege exception */\n\n            if (loglevel != 0) {\n\n                fprintf(logfile, \"Trying to read privileged spr %d %03x\\n\",\n\n                        sprn, sprn);\n\n            }\n\n            printf(\"Trying to read privileged spr %d %03x\\n\", sprn, sprn);\n\n            RET_PRIVREG(ctx);\n\n        }\n\n    } else {\n\n        /* Not defined */\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"Trying to read invalid spr %d %03x\\n\",\n\n                    sprn, sprn);\n\n        }\n\n        printf(\"Trying to read invalid spr %d %03x\\n\", sprn, sprn);\n\n        RET_EXCP(ctx, EXCP_PROGRAM, EXCP_INVAL | EXCP_INVAL_SPR);\n\n    }\n\n}\n", "idx": 23707}
{"project": "qemu", "commit_id": "2119882c7eb7e2c612b24fc0c8d86f5887d6f1c3", "target": 0, "func": "static void bdrv_do_release_matching_dirty_bitmap(BlockDriverState *bs,\n\n                                                  BdrvDirtyBitmap *bitmap,\n\n                                                  bool only_named)\n\n{\n\n    BdrvDirtyBitmap *bm, *next;\n\n    QLIST_FOREACH_SAFE(bm, &bs->dirty_bitmaps, list, next) {\n\n        if ((!bitmap || bm == bitmap) && (!only_named || bm->name)) {\n\n            assert(!bm->active_iterators);\n\n            assert(!bdrv_dirty_bitmap_frozen(bm));\n\n            assert(!bm->meta);\n\n            QLIST_REMOVE(bm, list);\n\n            hbitmap_free(bm->bitmap);\n\n            g_free(bm->name);\n\n            g_free(bm);\n\n\n\n            if (bitmap) {\n\n                return;\n\n            }\n\n        }\n\n    }\n\n    if (bitmap) {\n\n        abort();\n\n    }\n\n}\n", "idx": 23708}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t arm_thistimer_read(void *opaque, target_phys_addr_t addr,\n\n                                   unsigned size)\n\n{\n\n    arm_mptimer_state *s = (arm_mptimer_state *)opaque;\n\n    int id = get_current_cpu(s);\n\n    return timerblock_read(&s->timerblock[id * 2], addr, size);\n\n}\n", "idx": 23709}
{"project": "qemu", "commit_id": "f67409a5bb43ebe74401fa8e187267eb0f139293", "target": 1, "func": "static void nfs_refresh_filename(BlockDriverState *bs, QDict *options)\n\n{\n\n    NFSClient *client = bs->opaque;\n\n    QDict *opts = qdict_new();\n\n    QObject *server_qdict;\n\n    Visitor *ov;\n\n\n\n    qdict_put(opts, \"driver\", qstring_from_str(\"nfs\"));\n\n\n\n    if (client->uid && !client->gid) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nfs://%s%s?uid=%\" PRId64, client->server->host, client->path,\n\n                 client->uid);\n\n    } else if (!client->uid && client->gid) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nfs://%s%s?gid=%\" PRId64, client->server->host, client->path,\n\n                 client->gid);\n\n    } else if (client->uid && client->gid) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nfs://%s%s?uid=%\" PRId64 \"&gid=%\" PRId64,\n\n                 client->server->host, client->path, client->uid, client->gid);\n\n    } else {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nfs://%s%s\", client->server->host, client->path);\n\n    }\n\n\n\n    ov = qobject_output_visitor_new(&server_qdict);\n\n    visit_type_NFSServer(ov, NULL, &client->server, &error_abort);\n\n    visit_complete(ov, &server_qdict);\n\n    assert(qobject_type(server_qdict) == QTYPE_QDICT);\n\n\n\n    qdict_put_obj(opts, \"server\", server_qdict);\n\n    qdict_put(opts, \"path\", qstring_from_str(client->path));\n\n\n\n    if (client->uid) {\n\n        qdict_put(opts, \"uid\", qint_from_int(client->uid));\n\n    }\n\n    if (client->gid) {\n\n        qdict_put(opts, \"gid\", qint_from_int(client->gid));\n\n    }\n\n    if (client->tcp_syncnt) {\n\n        qdict_put(opts, \"tcp-syncnt\",\n\n                      qint_from_int(client->tcp_syncnt));\n\n    }\n\n    if (client->readahead) {\n\n        qdict_put(opts, \"readahead\",\n\n                      qint_from_int(client->readahead));\n\n    }\n\n    if (client->pagecache) {\n\n        qdict_put(opts, \"pagecache\",\n\n                      qint_from_int(client->pagecache));\n\n    }\n\n    if (client->debug) {\n\n        qdict_put(opts, \"debug\", qint_from_int(client->debug));\n\n    }\n\n\n\n    visit_free(ov);\n\n    qdict_flatten(opts);\n\n    bs->full_open_options = opts;\n\n}\n", "idx": 23710}
{"project": "qemu", "commit_id": "c29c1dd312f39ec18a3c6177c6da09a75e095d70", "target": 1, "func": "void backup_start(BlockDriverState *bs, BlockDriverState *target,\n                  int64_t speed, MirrorSyncMode sync_mode,\n                  BlockdevOnError on_source_error,\n                  BlockdevOnError on_target_error,\n                  BlockCompletionFunc *cb, void *opaque,\n                  Error **errp)\n{\n    int64_t len;\n    assert(bs);\n    assert(target);\n    assert(cb);\n    if (bs == target) {\n        error_setg(errp, \"Source and target cannot be the same\");\n    if ((on_source_error == BLOCKDEV_ON_ERROR_STOP ||\n         on_source_error == BLOCKDEV_ON_ERROR_ENOSPC) &&\n        !bdrv_iostatus_is_enabled(bs)) {\n        error_set(errp, QERR_INVALID_PARAMETER, \"on-source-error\");\n    len = bdrv_getlength(bs);\n    if (len < 0) {\n        error_setg_errno(errp, -len, \"unable to get length for '%s'\",\n    BackupBlockJob *job = block_job_create(&backup_job_driver, bs, speed,\n                                           cb, opaque, errp);\n    if (!job) {\n    bdrv_op_block_all(target, job->common.blocker);\n    job->on_source_error = on_source_error;\n    job->on_target_error = on_target_error;\n    job->target = target;\n    job->sync_mode = sync_mode;\n    job->common.len = len;\n    job->common.co = qemu_coroutine_create(backup_run);\n    qemu_coroutine_enter(job->common.co, job);", "idx": 23712}
{"project": "qemu", "commit_id": "7fe7b68b32ba609faeeee03556aac0eb1b187c91", "target": 1, "func": "ssize_t nbd_wr_sync(int fd, void *buffer, size_t size, bool do_read)\n\n{\n\n    size_t offset = 0;\n\n    int err;\n\n\n\n    if (qemu_in_coroutine()) {\n\n        if (do_read) {\n\n            return qemu_co_recv(fd, buffer, size);\n\n        } else {\n\n            return qemu_co_send(fd, buffer, size);\n\n        }\n\n    }\n\n\n\n    while (offset < size) {\n\n        ssize_t len;\n\n\n\n        if (do_read) {\n\n            len = qemu_recv(fd, buffer + offset, size - offset, 0);\n\n        } else {\n\n            len = send(fd, buffer + offset, size - offset, 0);\n\n        }\n\n\n\n        if (len < 0) {\n\n            err = socket_error();\n\n\n\n            /* recoverable error */\n\n            if (err == EINTR || err == EAGAIN) {\n\n                continue;\n\n            }\n\n\n\n            /* unrecoverable error */\n\n            return -err;\n\n        }\n\n\n\n        /* eof */\n\n        if (len == 0) {\n\n            break;\n\n        }\n\n\n\n        offset += len;\n\n    }\n\n\n\n    return offset;\n\n}\n", "idx": 23716}
{"project": "qemu", "commit_id": "7797a73947d5c0e63dd5552b348cf66c384b4555", "target": 1, "func": "static int dscm1xxxx_attach(PCMCIACardState *card)\n\n{\n\n    MicroDriveState *md = MICRODRIVE(card);\n\n    PCMCIACardClass *pcc = PCMCIA_CARD_GET_CLASS(card);\n\n\n\n    md->attr_base = pcc->cis[0x74] | (pcc->cis[0x76] << 8);\n\n    md->io_base = 0x0;\n\n\n\n    device_reset(DEVICE(md));\n\n    md_interrupt_update(md);\n\n\n\n    card->slot->card_string = \"DSCM-1xxxx Hitachi Microdrive\";\n\n    return 0;\n\n}\n", "idx": 23721}
{"project": "qemu", "commit_id": "9f953ca0b8ae71f4ea8112a3aac36454a2c4b907", "target": 1, "func": "static void s390_init(ram_addr_t ram_size,\n\n                      const char *boot_device,\n\n                      const char *kernel_filename,\n\n                      const char *kernel_cmdline,\n\n                      const char *initrd_filename,\n\n                      const char *cpu_model)\n\n{\n\n    CPUState *env = NULL;\n\n    ram_addr_t ram_addr;\n\n    ram_addr_t kernel_size = 0;\n\n    ram_addr_t initrd_offset;\n\n    ram_addr_t initrd_size = 0;\n\n    int i;\n\n\n\n    /* XXX we only work on KVM for now */\n\n\n\n    if (!kvm_enabled()) {\n\n        fprintf(stderr, \"The S390 target only works with KVM enabled\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* get a BUS */\n\n    s390_bus = s390_virtio_bus_init(&ram_size);\n\n\n\n    /* allocate RAM */\n\n    ram_addr = qemu_ram_alloc(NULL, \"s390.ram\", ram_size);\n\n    cpu_register_physical_memory(0, ram_size, ram_addr);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"host\";\n\n    }\n\n\n\n    ipi_states = qemu_malloc(sizeof(CPUState *) * smp_cpus);\n\n\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        CPUState *tmp_env;\n\n\n\n        tmp_env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            env = tmp_env;\n\n        }\n\n        ipi_states[i] = tmp_env;\n\n        tmp_env->halted = 1;\n\n        tmp_env->exception_index = EXCP_HLT;\n\n    }\n\n\n\n    env->halted = 0;\n\n    env->exception_index = 0;\n\n\n\n    if (kernel_filename) {\n\n        kernel_size = load_image(kernel_filename, qemu_get_ram_ptr(0));\n\n\n\n        if (lduw_phys(KERN_IMAGE_START) != 0x0dd0) {\n\n            fprintf(stderr, \"Specified image is not an s390 boot image\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        env->psw.addr = KERN_IMAGE_START;\n\n        env->psw.mask = 0x0000000180000000ULL;\n\n    } else {\n\n        ram_addr_t bios_size = 0;\n\n        char *bios_filename;\n\n\n\n        /* Load zipl bootloader */\n\n        if (bios_name == NULL) {\n\n            bios_name = ZIPL_FILENAME;\n\n        }\n\n\n\n        bios_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n        bios_size = load_image(bios_filename, qemu_get_ram_ptr(ZIPL_LOAD_ADDR));\n\n\n\n\n        if ((long)bios_size < 0) {\n\n            hw_error(\"could not load bootloader '%s'\\n\", bios_name);\n\n        }\n\n\n\n        if (bios_size > 4096) {\n\n            hw_error(\"stage1 bootloader is > 4k\\n\");\n\n        }\n\n\n\n        env->psw.addr = ZIPL_START;\n\n        env->psw.mask = 0x0000000180000000ULL;\n\n    }\n\n\n\n    if (initrd_filename) {\n\n        initrd_offset = INITRD_START;\n\n        while (kernel_size + 0x100000 > initrd_offset) {\n\n            initrd_offset += 0x100000;\n\n        }\n\n        initrd_size = load_image(initrd_filename, qemu_get_ram_ptr(initrd_offset));\n\n\n\n        stq_phys(INITRD_PARM_START, initrd_offset);\n\n        stq_phys(INITRD_PARM_SIZE, initrd_size);\n\n    }\n\n\n\n    if (kernel_cmdline) {\n\n        cpu_physical_memory_rw(KERN_PARM_AREA, (uint8_t *)kernel_cmdline,\n\n                               strlen(kernel_cmdline), 1);\n\n    }\n\n\n\n    /* Create VirtIO network adapters */\n\n    for(i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n        DeviceState *dev;\n\n\n\n        if (!nd->model) {\n\n            nd->model = qemu_strdup(\"virtio\");\n\n        }\n\n\n\n        if (strcmp(nd->model, \"virtio\")) {\n\n            fprintf(stderr, \"S390 only supports VirtIO nics\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        dev = qdev_create((BusState *)s390_bus, \"virtio-net-s390\");\n\n        qdev_set_nic_properties(dev, nd);\n\n        qdev_init_nofail(dev);\n\n    }\n\n\n\n    /* Create VirtIO disk drives */\n\n    for(i = 0; i < MAX_BLK_DEVS; i++) {\n\n        DriveInfo *dinfo;\n\n        DeviceState *dev;\n\n\n\n        dinfo = drive_get(IF_IDE, 0, i);\n\n        if (!dinfo) {\n\n            continue;\n\n        }\n\n\n\n        dev = qdev_create((BusState *)s390_bus, \"virtio-blk-s390\");\n\n        qdev_prop_set_drive_nofail(dev, \"drive\", dinfo->bdrv);\n\n        qdev_init_nofail(dev);\n\n    }\n\n}", "idx": 23723}
{"project": "qemu", "commit_id": "e7b921c2d9efc249f99b9feb0e7dca82c96aa5c4", "target": 1, "func": "static inline uint32_t regime_el(CPUARMState *env, ARMMMUIdx mmu_idx)\n\n{\n\n    switch (mmu_idx) {\n\n    case ARMMMUIdx_S2NS:\n\n    case ARMMMUIdx_S1E2:\n\n        return 2;\n\n    case ARMMMUIdx_S1E3:\n\n        return 3;\n\n    case ARMMMUIdx_S1SE0:\n\n        return arm_el_is_aa64(env, 3) ? 1 : 3;\n\n    case ARMMMUIdx_S1SE1:\n\n    case ARMMMUIdx_S1NSE0:\n\n    case ARMMMUIdx_S1NSE1:\n\n\n\n        return 1;\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n}", "idx": 23724}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static uint16_t nvme_del_cq(NvmeCtrl *n, NvmeCmd *cmd)\n\n{\n\n    NvmeDeleteQ *c = (NvmeDeleteQ *)cmd;\n\n    NvmeCQueue *cq;\n\n    uint16_t qid = le16_to_cpu(c->qid);\n\n\n\n    if (!qid || nvme_check_cqid(n, qid)) {\n\n        return NVME_INVALID_CQID | NVME_DNR;\n\n    }\n\n\n\n    cq = n->cq[qid];\n\n    if (!QTAILQ_EMPTY(&cq->sq_list)) {\n\n        return NVME_INVALID_QUEUE_DEL;\n\n    }\n\n    nvme_free_cq(cq, n);\n\n    return NVME_SUCCESS;\n\n}\n", "idx": 23726}
{"project": "qemu", "commit_id": "e829b0bb054ed3389e5b22dad61875e51674e629", "target": 1, "func": "iscsi_readcapacity16_cb(struct iscsi_context *iscsi, int status,\n\n                        void *command_data, void *opaque)\n\n{\n\n    struct IscsiTask *itask = opaque;\n\n    struct scsi_readcapacity16 *rc16;\n\n    struct scsi_task *task = command_data;\n\n\n\n    if (status != 0) {\n\n        error_report(\"iSCSI: Failed to read capacity of iSCSI lun. %s\",\n\n                     iscsi_get_error(iscsi));\n\n        itask->status   = 1;\n\n        itask->complete = 1;\n\n        scsi_free_scsi_task(task);\n\n        return;\n\n    }\n\n\n\n    rc16 = scsi_datain_unmarshall(task);\n\n    if (rc16 == NULL) {\n\n        error_report(\"iSCSI: Failed to unmarshall readcapacity16 data.\");\n\n        itask->status   = 1;\n\n        itask->complete = 1;\n\n        scsi_free_scsi_task(task);\n\n        return;\n\n    }\n\n\n\n    itask->iscsilun->block_size = rc16->block_length;\n\n    itask->iscsilun->num_blocks = rc16->returned_lba + 1;\n\n    itask->bs->total_sectors    = itask->iscsilun->num_blocks *\n\n                               itask->iscsilun->block_size / BDRV_SECTOR_SIZE ;\n\n\n\n    itask->status   = 0;\n\n    itask->complete = 1;\n\n    scsi_free_scsi_task(task);\n\n}\n", "idx": 23727}
{"project": "qemu", "commit_id": "d6309c170eb99950c9f1d881a5ff7163ae28d353", "target": 1, "func": "static void test_acpi_q35_tcg_cphp(void)\n\n{\n\n    test_data data;\n\n\n\n    memset(&data, 0, sizeof(data));\n\n    data.machine = MACHINE_Q35;\n\n    data.variant = \".cphp\";\n\n    test_acpi_one(\" -smp 2,cores=3,sockets=2,maxcpus=6\",\n\n                  &data);\n\n    free_test_data(&data);\n\n}\n", "idx": 23728}
{"project": "qemu", "commit_id": "ebca2df783a5a742bb93784524336d8cbb9e662b", "target": 1, "func": "TPMVersion tpm_backend_get_tpm_version(TPMBackend *s)\n\n{\n\n    TPMBackendClass *k = TPM_BACKEND_GET_CLASS(s);\n\n\n\n    assert(k->get_tpm_version);\n\n\n\n    return k->get_tpm_version(s);\n\n}\n", "idx": 23729}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fnmsub(CPUPPCState *env, uint64_t arg1, uint64_t arg2,\n\n                       uint64_t arg3)\n\n{\n\n    CPU_DoubleU farg1, farg2, farg3;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n    farg3.ll = arg3;\n\n\n\n    if (unlikely((float64_is_infinity(farg1.d) && float64_is_zero(farg2.d)) ||\n\n                 (float64_is_zero(farg1.d) &&\n\n                  float64_is_infinity(farg2.d)))) {\n\n        /* Multiplication of zero by infinity */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIMZ);\n\n    } else {\n\n        if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                     float64_is_signaling_nan(farg2.d) ||\n\n                     float64_is_signaling_nan(farg3.d))) {\n\n            /* sNaN operation */\n\n            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n        }\n\n        /* This is the way the PowerPC specification defines it */\n\n        float128 ft0_128, ft1_128;\n\n\n\n        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);\n\n        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);\n\n        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);\n\n        if (unlikely(float128_is_infinity(ft0_128) &&\n\n                     float64_is_infinity(farg3.d) &&\n\n                     float128_is_neg(ft0_128) == float64_is_neg(farg3.d))) {\n\n            /* Magnitude subtraction of infinities */\n\n            farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXISI);\n\n        } else {\n\n            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);\n\n            ft0_128 = float128_sub(ft0_128, ft1_128, &env->fp_status);\n\n            farg1.d = float128_to_float64(ft0_128, &env->fp_status);\n\n        }\n\n        if (likely(!float64_is_any_nan(farg1.d))) {\n\n            farg1.d = float64_chs(farg1.d);\n\n        }\n\n    }\n\n    return farg1.ll;\n\n}\n", "idx": 23733}
{"project": "qemu", "commit_id": "82cbbdc6a0958b49c77639a60906e30d02e6bb7b", "target": 0, "func": "int qemu_bh_poll(void)\n\n{\n\n    return aio_bh_poll(qemu_aio_context);\n\n}\n", "idx": 23735}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static struct omap_sti_s *omap_sti_init(struct omap_target_agent_s *ta,\n\n                MemoryRegion *sysmem,\n\n                target_phys_addr_t channel_base, qemu_irq irq, omap_clk clk,\n\n                CharDriverState *chr)\n\n{\n\n    struct omap_sti_s *s = (struct omap_sti_s *)\n\n            g_malloc0(sizeof(struct omap_sti_s));\n\n\n\n    s->irq = irq;\n\n    omap_sti_reset(s);\n\n\n\n    s->chr = chr ?: qemu_chr_new(\"null\", \"null\", NULL);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_sti_ops, s, \"omap.sti\",\n\n                          omap_l4_region_size(ta, 0));\n\n    omap_l4_attach(ta, 0, &s->iomem);\n\n\n\n    memory_region_init_io(&s->iomem_fifo, &omap_sti_fifo_ops, s,\n\n                          \"omap.sti.fifo\", 0x10000);\n\n    memory_region_add_subregion(sysmem, channel_base, &s->iomem_fifo);\n\n\n\n    return s;\n\n}\n", "idx": 23736}
{"project": "qemu", "commit_id": "f6102c329c43d7d5e0bee1fc2fe4043e05f9810c", "target": 0, "func": "static int init_event_facility(SCLPEventFacility *event_facility)\n\n{\n\n    DeviceState *sdev = DEVICE(event_facility);\n\n    DeviceState *quiesce;\n\n\n\n    /* Spawn a new bus for SCLP events */\n\n    qbus_create_inplace(&event_facility->sbus, sizeof(event_facility->sbus),\n\n                        TYPE_SCLP_EVENTS_BUS, sdev, NULL);\n\n\n\n    quiesce = qdev_create(&event_facility->sbus.qbus, \"sclpquiesce\");\n\n    if (!quiesce) {\n\n        return -1;\n\n    }\n\n    qdev_init_nofail(quiesce);\n\n\n\n    object_initialize(&cpu_hotplug, sizeof(cpu_hotplug), TYPE_SCLP_CPU_HOTPLUG);\n\n    qdev_set_parent_bus(DEVICE(&cpu_hotplug), BUS(&event_facility->sbus));\n\n    object_property_set_bool(OBJECT(&cpu_hotplug), true, \"realized\", NULL);\n\n\n\n    return 0;\n\n}\n", "idx": 23737}
{"project": "qemu", "commit_id": "e79ea67a9785a5da4d1889b6e2bb71d03e916add", "target": 0, "func": "static ssize_t qio_channel_websock_writev(QIOChannel *ioc,\n\n                                          const struct iovec *iov,\n\n                                          size_t niov,\n\n                                          int *fds,\n\n                                          size_t nfds,\n\n                                          Error **errp)\n\n{\n\n    QIOChannelWebsock *wioc = QIO_CHANNEL_WEBSOCK(ioc);\n\n    size_t i;\n\n    ssize_t done = 0;\n\n    ssize_t ret;\n\n\n\n    if (wioc->io_err) {\n\n        *errp = error_copy(wioc->io_err);\n\n        return -1;\n\n    }\n\n\n\n    if (wioc->io_eof) {\n\n        error_setg(errp, \"%s\", \"Broken pipe\");\n\n        return -1;\n\n    }\n\n\n\n    for (i = 0; i < niov; i++) {\n\n        size_t want = iov[i].iov_len;\n\n        if ((want + wioc->rawoutput.offset) > QIO_CHANNEL_WEBSOCK_MAX_BUFFER) {\n\n            want = (QIO_CHANNEL_WEBSOCK_MAX_BUFFER - wioc->rawoutput.offset);\n\n        }\n\n        if (want == 0) {\n\n            goto done;\n\n        }\n\n\n\n        buffer_reserve(&wioc->rawoutput, want);\n\n        buffer_append(&wioc->rawoutput, iov[i].iov_base, want);\n\n        done += want;\n\n        if (want < iov[i].iov_len) {\n\n            break;\n\n        }\n\n    }\n\n\n\n done:\n\n    ret = qio_channel_websock_write_wire(wioc, errp);\n\n    if (ret < 0 &&\n\n        ret != QIO_CHANNEL_ERR_BLOCK) {\n\n        qio_channel_websock_unset_watch(wioc);\n\n        return -1;\n\n    }\n\n\n\n    qio_channel_websock_set_watch(wioc);\n\n\n\n    if (done == 0) {\n\n        return QIO_CHANNEL_ERR_BLOCK;\n\n    }\n\n\n\n    return done;\n\n}\n", "idx": 23738}
{"project": "qemu", "commit_id": "20a81e4d178379381fbd522eda5f664ba2ecdaaa", "target": 0, "func": "static int virtio_blk_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    VirtIOBlock *s = opaque;\n\n\n\n    if (version_id != 2)\n\n        return -EINVAL;\n\n\n\n    virtio_load(&s->vdev, f);\n\n    while (qemu_get_sbyte(f)) {\n\n        VirtIOBlockReq *req = virtio_blk_alloc_request(s);\n\n        qemu_get_buffer(f, (unsigned char*)&req->elem, sizeof(req->elem));\n\n        req->next = s->rq;\n\n        s->rq = req->next;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23739}
{"project": "qemu", "commit_id": "8caa05d8891d0a09dc4c00908c24c6ddfd872bbe", "target": 0, "func": "bool timerlist_has_timers(QEMUTimerList *timer_list)\n\n{\n\n    return !!timer_list->active_timers;\n\n}\n", "idx": 23740}
{"project": "qemu", "commit_id": "02a08fef079469c005d48fe2d181f0e0eb5752ae", "target": 0, "func": "int inet_connect_opts(QemuOpts *opts, Error **errp)\n\n{\n\n    struct addrinfo ai,*res,*e;\n\n    const char *addr;\n\n    const char *port;\n\n    char uaddr[INET6_ADDRSTRLEN+1];\n\n    char uport[33];\n\n    int sock,rc;\n\n    bool block;\n\n\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_CANONNAME | AI_ADDRCONFIG;\n\n    ai.ai_family = PF_UNSPEC;\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    addr = qemu_opt_get(opts, \"host\");\n\n    port = qemu_opt_get(opts, \"port\");\n\n    block = qemu_opt_get_bool(opts, \"block\", 0);\n\n    if (addr == NULL || port == NULL) {\n\n        fprintf(stderr, \"inet_connect: host and/or port not specified\\n\");\n\n        error_set(errp, QERR_SOCKET_CREATE_FAILED);\n\n        return -1;\n\n    }\n\n\n\n    if (qemu_opt_get_bool(opts, \"ipv4\", 0))\n\n        ai.ai_family = PF_INET;\n\n    if (qemu_opt_get_bool(opts, \"ipv6\", 0))\n\n        ai.ai_family = PF_INET6;\n\n\n\n    /* lookup */\n\n    if (0 != (rc = getaddrinfo(addr, port, &ai, &res))) {\n\n        fprintf(stderr,\"getaddrinfo(%s,%s): %s\\n\", addr, port,\n\n                gai_strerror(rc));\n\n        error_set(errp, QERR_SOCKET_CREATE_FAILED);\n\n\treturn -1;\n\n    }\n\n\n\n    for (e = res; e != NULL; e = e->ai_next) {\n\n        if (getnameinfo((struct sockaddr*)e->ai_addr,e->ai_addrlen,\n\n                            uaddr,INET6_ADDRSTRLEN,uport,32,\n\n                            NI_NUMERICHOST | NI_NUMERICSERV) != 0) {\n\n            fprintf(stderr,\"%s: getnameinfo: oops\\n\", __FUNCTION__);\n\n            continue;\n\n        }\n\n        sock = qemu_socket(e->ai_family, e->ai_socktype, e->ai_protocol);\n\n        if (sock < 0) {\n\n            fprintf(stderr,\"%s: socket(%s): %s\\n\", __FUNCTION__,\n\n            inet_strfamily(e->ai_family), strerror(errno));\n\n            continue;\n\n        }\n\n        setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(void*)&on,sizeof(on));\n\n        if (!block) {\n\n            socket_set_nonblock(sock);\n\n        }\n\n        /* connect to peer */\n\n        do {\n\n            rc = 0;\n\n            if (connect(sock, e->ai_addr, e->ai_addrlen) < 0) {\n\n                rc = -socket_error();\n\n            }\n\n        } while (rc == -EINTR);\n\n\n\n  #ifdef _WIN32\n\n        if (!block && (rc == -EINPROGRESS || rc == -EWOULDBLOCK\n\n                       || rc == -WSAEALREADY)) {\n\n  #else\n\n        if (!block && (rc == -EINPROGRESS)) {\n\n  #endif\n\n            error_set(errp, QERR_SOCKET_CONNECT_IN_PROGRESS);\n\n        } else if (rc < 0) {\n\n            if (NULL == e->ai_next)\n\n                fprintf(stderr, \"%s: connect(%s,%s,%s,%s): %s\\n\", __FUNCTION__,\n\n                        inet_strfamily(e->ai_family),\n\n                        e->ai_canonname, uaddr, uport, strerror(errno));\n\n            closesocket(sock);\n\n            continue;\n\n        }\n\n        freeaddrinfo(res);\n\n        return sock;\n\n    }\n\n    error_set(errp, QERR_SOCKET_CONNECT_FAILED);\n\n    freeaddrinfo(res);\n\n    return -1;\n\n}\n", "idx": 23741}
{"project": "qemu", "commit_id": "1c7ad77e56767fb36a7ccc954d304d4ac768b374", "target": 0, "func": "static void ppc_cpu_do_nmi_on_cpu(CPUState *cs, run_on_cpu_data arg)\n\n{\n\n    cpu_synchronize_state(cs);\n\n    ppc_cpu_do_system_reset(cs);\n\n}\n", "idx": 23742}
{"project": "qemu", "commit_id": "f9f46db444a2dfc2ebf1f9f7d4b42163ab33187d", "target": 0, "func": "void HELPER(stby_e)(CPUHPPAState *env, target_ulong addr, target_ulong val)\n\n{\n\n    uintptr_t ra = GETPC();\n\n\n\n    switch (addr & 3) {\n\n    case 3:\n\n        /* The 3 byte store must appear atomic.  */\n\n        if (parallel_cpus) {\n\n            atomic_store_3(env, addr - 3, val, 0xffffff00u, ra);\n\n        } else {\n\n            cpu_stw_data_ra(env, addr - 3, val >> 16, ra);\n\n            cpu_stb_data_ra(env, addr - 1, val >> 8, ra);\n\n        }\n\n        break;\n\n    case 2:\n\n        cpu_stw_data_ra(env, addr - 2, val >> 16, ra);\n\n        break;\n\n    case 1:\n\n        cpu_stb_data_ra(env, addr - 1, val >> 24, ra);\n\n        break;\n\n    default:\n\n        /* Nothing is stored, but protection is checked and the\n\n           cacheline is marked dirty.  */\n\n#ifndef CONFIG_USER_ONLY\n\n        probe_write(env, addr, cpu_mmu_index(env, 0), ra);\n\n#endif\n\n        break;\n\n    }\n\n}\n", "idx": 23743}
{"project": "qemu", "commit_id": "b6ce27a593ab39ac28baebc3045901925046bebd", "target": 0, "func": "static void virtio_pci_modern_region_map(VirtIOPCIProxy *proxy,\n\n                                         VirtIOPCIRegion *region,\n\n                                         struct virtio_pci_cap *cap)\n\n{\n\n    memory_region_add_subregion(&proxy->modern_bar,\n\n                                region->offset,\n\n                                &region->mr);\n\n\n\n    cap->cfg_type = region->type;\n\n    cap->offset = cpu_to_le32(region->offset);\n\n    cap->length = cpu_to_le32(memory_region_size(&region->mr));\n\n    virtio_pci_add_mem_cap(proxy, cap);\n\n}\n", "idx": 23744}
{"project": "qemu", "commit_id": "d5aa3e6e0cd6259003790769c448d4fbb5b5c810", "target": 0, "func": "uint32_t net_checksum_add_cont(int len, uint8_t *buf, int seq)\n\n{\n\n    uint32_t sum = 0;\n\n    int i;\n\n\n\n    for (i = seq; i < seq + len; i++) {\n\n        if (i & 1) {\n\n            sum += (uint32_t)buf[i - seq];\n\n        } else {\n\n            sum += (uint32_t)buf[i - seq] << 8;\n\n        }\n\n    }\n\n    return sum;\n\n}\n", "idx": 23746}
{"project": "qemu", "commit_id": "d044be3714db9c3750c430a2bb1be74beee6fd27", "target": 0, "func": "static void mixer_reset (AC97LinkState *s)\n\n{\n\n    uint8_t active[LAST_INDEX];\n\n\n\n    dolog (\"mixer_reset\\n\");\n\n    memset (s->mixer_data, 0, sizeof (s->mixer_data));\n\n    memset (active, 0, sizeof (active));\n\n    mixer_store (s, AC97_Reset                   , 0x0000); /* 6940 */\n\n    mixer_store (s, AC97_Master_Volume_Mono_Mute , 0x8000);\n\n    mixer_store (s, AC97_PC_BEEP_Volume_Mute     , 0x0000);\n\n\n\n    mixer_store (s, AC97_Phone_Volume_Mute       , 0x8008);\n\n    mixer_store (s, AC97_Mic_Volume_Mute         , 0x8008);\n\n    mixer_store (s, AC97_CD_Volume_Mute          , 0x8808);\n\n    mixer_store (s, AC97_Aux_Volume_Mute         , 0x8808);\n\n    mixer_store (s, AC97_Record_Gain_Mic_Mute    , 0x8000);\n\n    mixer_store (s, AC97_General_Purpose         , 0x0000);\n\n    mixer_store (s, AC97_3D_Control              , 0x0000);\n\n    mixer_store (s, AC97_Powerdown_Ctrl_Stat     , 0x000f);\n\n\n\n    /*\n\n     * Sigmatel 9700 (STAC9700)\n\n     */\n\n    mixer_store (s, AC97_Vendor_ID1              , 0x8384);\n\n    mixer_store (s, AC97_Vendor_ID2              , 0x7600); /* 7608 */\n\n\n\n    mixer_store (s, AC97_Extended_Audio_ID       , 0x0809);\n\n    mixer_store (s, AC97_Extended_Audio_Ctrl_Stat, 0x0009);\n\n    mixer_store (s, AC97_PCM_Front_DAC_Rate      , 0xbb80);\n\n    mixer_store (s, AC97_PCM_Surround_DAC_Rate   , 0xbb80);\n\n    mixer_store (s, AC97_PCM_LFE_DAC_Rate        , 0xbb80);\n\n    mixer_store (s, AC97_PCM_LR_ADC_Rate         , 0xbb80);\n\n    mixer_store (s, AC97_MIC_ADC_Rate            , 0xbb80);\n\n\n\n    record_select (s, 0);\n\n    set_volume (s, AC97_Master_Volume_Mute, 0x8000);\n\n    set_volume (s, AC97_PCM_Out_Volume_Mute, 0x8808);\n\n    set_volume (s, AC97_Line_In_Volume_Mute, 0x8808);\n\n\n\n    reset_voices (s, active);\n\n}\n", "idx": 23747}
{"project": "qemu", "commit_id": "621ff94d5074d88253a5818c6b9c4db718fbfc65", "target": 0, "func": "static void write_dump_header(DumpState *s, Error **errp)\n\n{\n\n     Error *local_err = NULL;\n\n\n\n    if (s->dump_info.d_class == ELFCLASS32) {\n\n        create_header32(s, &local_err);\n\n    } else {\n\n        create_header64(s, &local_err);\n\n    }\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n    }\n\n}\n", "idx": 23748}
{"project": "qemu", "commit_id": "f671d173c7e1da555b693e8b14f3ed0852601809", "target": 0, "func": "static int parse_short_name(BDRVVVFATState* s,\n\n\tlong_file_name* lfn, direntry_t* direntry)\n\n{\n\n    int i, j;\n\n\n\n    if (!is_short_name(direntry))\n\n\treturn 1;\n\n\n\n    for (j = 7; j >= 0 && direntry->name[j] == ' '; j--);\n\n    for (i = 0; i <= j; i++) {\n\n\tif (direntry->name[i] <= ' ' || direntry->name[i] > 0x7f)\n\n\t    return -1;\n\n\telse if (s->downcase_short_names)\n\n\t    lfn->name[i] = qemu_tolower(direntry->name[i]);\n\n\telse\n\n\t    lfn->name[i] = direntry->name[i];\n\n    }\n\n\n\n    for (j = 2; j >= 0 && direntry->extension[j] == ' '; j--);\n\n    if (j >= 0) {\n\n\tlfn->name[i++] = '.';\n\n\tlfn->name[i + j + 1] = '\\0';\n\n\tfor (;j >= 0; j--) {\n\n\t    if (direntry->extension[j] <= ' ' || direntry->extension[j] > 0x7f)\n\n\t\treturn -2;\n\n\t    else if (s->downcase_short_names)\n\n\t\tlfn->name[i + j] = qemu_tolower(direntry->extension[j]);\n\n\t    else\n\n\t\tlfn->name[i + j] = direntry->extension[j];\n\n\t}\n\n    } else\n\n\tlfn->name[i + j + 1] = '\\0';\n\n\n\n    lfn->len = strlen((char*)lfn->name);\n\n\n\n    return 0;\n\n}\n", "idx": 23749}
{"project": "qemu", "commit_id": "3805c2eba8999049bbbea29fdcdea4d47d943c88", "target": 0, "func": "void gen_intermediate_code(CPUState *cs, TranslationBlock *tb)\n\n{\n\n    CPUARMState *env = cs->env_ptr;\n\n    ARMCPU *cpu = arm_env_get_cpu(env);\n\n    DisasContext dc1, *dc = &dc1;\n\n    target_ulong pc_start;\n\n    target_ulong next_page_start;\n\n    int num_insns;\n\n    int max_insns;\n\n    bool end_of_page;\n\n\n\n    /* generate intermediate code */\n\n\n\n    /* The A64 decoder has its own top level loop, because it doesn't need\n\n     * the A32/T32 complexity to do with conditional execution/IT blocks/etc.\n\n     */\n\n    if (ARM_TBFLAG_AARCH64_STATE(tb->flags)) {\n\n        gen_intermediate_code_a64(cs, tb);\n\n        return;\n\n    }\n\n\n\n    pc_start = tb->pc;\n\n\n\n    dc->tb = tb;\n\n\n\n    dc->is_jmp = DISAS_NEXT;\n\n    dc->pc = pc_start;\n\n    dc->singlestep_enabled = cs->singlestep_enabled;\n\n    dc->condjmp = 0;\n\n\n\n    dc->aarch64 = 0;\n\n    /* If we are coming from secure EL0 in a system with a 32-bit EL3, then\n\n     * there is no secure EL1, so we route exceptions to EL3.\n\n     */\n\n    dc->secure_routed_to_el3 = arm_feature(env, ARM_FEATURE_EL3) &&\n\n                               !arm_el_is_aa64(env, 3);\n\n    dc->thumb = ARM_TBFLAG_THUMB(tb->flags);\n\n    dc->sctlr_b = ARM_TBFLAG_SCTLR_B(tb->flags);\n\n    dc->be_data = ARM_TBFLAG_BE_DATA(tb->flags) ? MO_BE : MO_LE;\n\n    dc->condexec_mask = (ARM_TBFLAG_CONDEXEC(tb->flags) & 0xf) << 1;\n\n    dc->condexec_cond = ARM_TBFLAG_CONDEXEC(tb->flags) >> 4;\n\n    dc->mmu_idx = core_to_arm_mmu_idx(env, ARM_TBFLAG_MMUIDX(tb->flags));\n\n    dc->current_el = arm_mmu_idx_to_el(dc->mmu_idx);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    dc->user = (dc->current_el == 0);\n\n#endif\n\n    dc->ns = ARM_TBFLAG_NS(tb->flags);\n\n    dc->fp_excp_el = ARM_TBFLAG_FPEXC_EL(tb->flags);\n\n    dc->vfp_enabled = ARM_TBFLAG_VFPEN(tb->flags);\n\n    dc->vec_len = ARM_TBFLAG_VECLEN(tb->flags);\n\n    dc->vec_stride = ARM_TBFLAG_VECSTRIDE(tb->flags);\n\n    dc->c15_cpar = ARM_TBFLAG_XSCALE_CPAR(tb->flags);\n\n    dc->v7m_handler_mode = ARM_TBFLAG_HANDLER(tb->flags);\n\n    dc->cp_regs = cpu->cp_regs;\n\n    dc->features = env->features;\n\n\n\n    /* Single step state. The code-generation logic here is:\n\n     *  SS_ACTIVE == 0:\n\n     *   generate code with no special handling for single-stepping (except\n\n     *   that anything that can make us go to SS_ACTIVE == 1 must end the TB;\n\n     *   this happens anyway because those changes are all system register or\n\n     *   PSTATE writes).\n\n     *  SS_ACTIVE == 1, PSTATE.SS == 1: (active-not-pending)\n\n     *   emit code for one insn\n\n     *   emit code to clear PSTATE.SS\n\n     *   emit code to generate software step exception for completed step\n\n     *   end TB (as usual for having generated an exception)\n\n     *  SS_ACTIVE == 1, PSTATE.SS == 0: (active-pending)\n\n     *   emit code to generate a software step exception\n\n     *   end the TB\n\n     */\n\n    dc->ss_active = ARM_TBFLAG_SS_ACTIVE(tb->flags);\n\n    dc->pstate_ss = ARM_TBFLAG_PSTATE_SS(tb->flags);\n\n    dc->is_ldex = false;\n\n    dc->ss_same_el = false; /* Can't be true since EL_d must be AArch64 */\n\n\n\n    cpu_F0s = tcg_temp_new_i32();\n\n    cpu_F1s = tcg_temp_new_i32();\n\n    cpu_F0d = tcg_temp_new_i64();\n\n    cpu_F1d = tcg_temp_new_i64();\n\n    cpu_V0 = cpu_F0d;\n\n    cpu_V1 = cpu_F1d;\n\n    /* FIXME: cpu_M0 can probably be the same as cpu_V0.  */\n\n    cpu_M0 = tcg_temp_new_i64();\n\n    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0) {\n\n        max_insns = CF_COUNT_MASK;\n\n    }\n\n    if (max_insns > TCG_MAX_INSNS) {\n\n        max_insns = TCG_MAX_INSNS;\n\n    }\n\n\n\n    gen_tb_start(tb);\n\n\n\n    tcg_clear_temp_count();\n\n\n\n    /* A note on handling of the condexec (IT) bits:\n\n     *\n\n     * We want to avoid the overhead of having to write the updated condexec\n\n     * bits back to the CPUARMState for every instruction in an IT block. So:\n\n     * (1) if the condexec bits are not already zero then we write\n\n     * zero back into the CPUARMState now. This avoids complications trying\n\n     * to do it at the end of the block. (For example if we don't do this\n\n     * it's hard to identify whether we can safely skip writing condexec\n\n     * at the end of the TB, which we definitely want to do for the case\n\n     * where a TB doesn't do anything with the IT state at all.)\n\n     * (2) if we are going to leave the TB then we call gen_set_condexec()\n\n     * which will write the correct value into CPUARMState if zero is wrong.\n\n     * This is done both for leaving the TB at the end, and for leaving\n\n     * it because of an exception we know will happen, which is done in\n\n     * gen_exception_insn(). The latter is necessary because we need to\n\n     * leave the TB with the PC/IT state just prior to execution of the\n\n     * instruction which caused the exception.\n\n     * (3) if we leave the TB unexpectedly (eg a data abort on a load)\n\n     * then the CPUARMState will be wrong and we need to reset it.\n\n     * This is handled in the same way as restoration of the\n\n     * PC in these situations; we save the value of the condexec bits\n\n     * for each PC via tcg_gen_insn_start(), and restore_state_to_opc()\n\n     * then uses this to restore them after an exception.\n\n     *\n\n     * Note that there are no instructions which can read the condexec\n\n     * bits, and none which can write non-static values to them, so\n\n     * we don't need to care about whether CPUARMState is correct in the\n\n     * middle of a TB.\n\n     */\n\n\n\n    /* Reset the conditional execution bits immediately. This avoids\n\n       complications trying to do it at the end of the block.  */\n\n    if (dc->condexec_mask || dc->condexec_cond)\n\n      {\n\n        TCGv_i32 tmp = tcg_temp_new_i32();\n\n        tcg_gen_movi_i32(tmp, 0);\n\n        store_cpu_field(tmp, condexec_bits);\n\n      }\n\n    do {\n\n        dc->insn_start_idx = tcg_op_buf_count();\n\n        tcg_gen_insn_start(dc->pc,\n\n                           (dc->condexec_cond << 4) | (dc->condexec_mask >> 1),\n\n                           0);\n\n        num_insns++;\n\n\n\n#ifdef CONFIG_USER_ONLY\n\n        /* Intercept jump to the magic kernel page.  */\n\n        if (dc->pc >= 0xffff0000) {\n\n            /* We always get here via a jump, so know we are not in a\n\n               conditional execution block.  */\n\n            gen_exception_internal(EXCP_KERNEL_TRAP);\n\n            dc->is_jmp = DISAS_NORETURN;\n\n            break;\n\n        }\n\n#endif\n\n\n\n        if (unlikely(!QTAILQ_EMPTY(&cs->breakpoints))) {\n\n            CPUBreakpoint *bp;\n\n            QTAILQ_FOREACH(bp, &cs->breakpoints, entry) {\n\n                if (bp->pc == dc->pc) {\n\n                    if (bp->flags & BP_CPU) {\n\n                        gen_set_condexec(dc);\n\n                        gen_set_pc_im(dc, dc->pc);\n\n                        gen_helper_check_breakpoints(cpu_env);\n\n                        /* End the TB early; it's likely not going to be executed */\n\n                        dc->is_jmp = DISAS_UPDATE;\n\n                    } else {\n\n                        gen_exception_internal_insn(dc, 0, EXCP_DEBUG);\n\n                        /* The address covered by the breakpoint must be\n\n                           included in [tb->pc, tb->pc + tb->size) in order\n\n                           to for it to be properly cleared -- thus we\n\n                           increment the PC here so that the logic setting\n\n                           tb->size below does the right thing.  */\n\n                        /* TODO: Advance PC by correct instruction length to\n\n                         * avoid disassembler error messages */\n\n                        dc->pc += 2;\n\n                        goto done_generating;\n\n                    }\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (num_insns == max_insns && (tb->cflags & CF_LAST_IO)) {\n\n            gen_io_start();\n\n        }\n\n\n\n        if (dc->ss_active && !dc->pstate_ss) {\n\n            /* Singlestep state is Active-pending.\n\n             * If we're in this state at the start of a TB then either\n\n             *  a) we just took an exception to an EL which is being debugged\n\n             *     and this is the first insn in the exception handler\n\n             *  b) debug exceptions were masked and we just unmasked them\n\n             *     without changing EL (eg by clearing PSTATE.D)\n\n             * In either case we're going to take a swstep exception in the\n\n             * \"did not step an insn\" case, and so the syndrome ISV and EX\n\n             * bits should be zero.\n\n             */\n\n            assert(num_insns == 1);\n\n            gen_exception(EXCP_UDEF, syn_swstep(dc->ss_same_el, 0, 0),\n\n                          default_exception_el(dc));\n\n            goto done_generating;\n\n        }\n\n\n\n        if (dc->thumb) {\n\n            disas_thumb_insn(env, dc);\n\n            if (dc->condexec_mask) {\n\n                dc->condexec_cond = (dc->condexec_cond & 0xe)\n\n                                   | ((dc->condexec_mask >> 4) & 1);\n\n                dc->condexec_mask = (dc->condexec_mask << 1) & 0x1f;\n\n                if (dc->condexec_mask == 0) {\n\n                    dc->condexec_cond = 0;\n\n                }\n\n            }\n\n        } else {\n\n            unsigned int insn = arm_ldl_code(env, dc->pc, dc->sctlr_b);\n\n            dc->pc += 4;\n\n            disas_arm_insn(dc, insn);\n\n        }\n\n\n\n        if (dc->condjmp && !dc->is_jmp) {\n\n            gen_set_label(dc->condlabel);\n\n            dc->condjmp = 0;\n\n        }\n\n\n\n        if (tcg_check_temp_count()) {\n\n            fprintf(stderr, \"TCG temporary leak before \"TARGET_FMT_lx\"\\n\",\n\n                    dc->pc);\n\n        }\n\n\n\n        /* Translation stops when a conditional branch is encountered.\n\n         * Otherwise the subsequent code could get translated several times.\n\n         * Also stop translation when a page boundary is reached.  This\n\n         * ensures prefetch aborts occur at the right place.  */\n\n\n\n        /* We want to stop the TB if the next insn starts in a new page,\n\n         * or if it spans between this page and the next. This means that\n\n         * if we're looking at the last halfword in the page we need to\n\n         * see if it's a 16-bit Thumb insn (which will fit in this TB)\n\n         * or a 32-bit Thumb insn (which won't).\n\n         * This is to avoid generating a silly TB with a single 16-bit insn\n\n         * in it at the end of this page (which would execute correctly\n\n         * but isn't very efficient).\n\n         */\n\n        end_of_page = (dc->pc >= next_page_start) ||\n\n            ((dc->pc >= next_page_start - 3) && insn_crosses_page(env, dc));\n\n\n\n    } while (!dc->is_jmp && !tcg_op_buf_full() &&\n\n             !is_singlestepping(dc) &&\n\n             !singlestep &&\n\n             !end_of_page &&\n\n             num_insns < max_insns);\n\n\n\n    if (tb->cflags & CF_LAST_IO) {\n\n        if (dc->condjmp) {\n\n            /* FIXME:  This can theoretically happen with self-modifying\n\n               code.  */\n\n            cpu_abort(cs, \"IO on conditional branch instruction\");\n\n        }\n\n        gen_io_end();\n\n    }\n\n\n\n    /* At this stage dc->condjmp will only be set when the skipped\n\n       instruction was a conditional branch or trap, and the PC has\n\n       already been written.  */\n\n    gen_set_condexec(dc);\n\n    if (dc->is_jmp == DISAS_BX_EXCRET) {\n\n        /* Exception return branches need some special case code at the\n\n         * end of the TB, which is complex enough that it has to\n\n         * handle the single-step vs not and the condition-failed\n\n         * insn codepath itself.\n\n         */\n\n        gen_bx_excret_final_code(dc);\n\n    } else if (unlikely(is_singlestepping(dc))) {\n\n        /* Unconditional and \"condition passed\" instruction codepath. */\n\n        switch (dc->is_jmp) {\n\n        case DISAS_SWI:\n\n            gen_ss_advance(dc);\n\n            gen_exception(EXCP_SWI, syn_aa32_svc(dc->svc_imm, dc->thumb),\n\n                          default_exception_el(dc));\n\n            break;\n\n        case DISAS_HVC:\n\n            gen_ss_advance(dc);\n\n            gen_exception(EXCP_HVC, syn_aa32_hvc(dc->svc_imm), 2);\n\n            break;\n\n        case DISAS_SMC:\n\n            gen_ss_advance(dc);\n\n            gen_exception(EXCP_SMC, syn_aa32_smc(), 3);\n\n            break;\n\n        case DISAS_NEXT:\n\n        case DISAS_UPDATE:\n\n            gen_set_pc_im(dc, dc->pc);\n\n            /* fall through */\n\n        default:\n\n            /* FIXME: Single stepping a WFI insn will not halt the CPU. */\n\n            gen_singlestep_exception(dc);\n\n            break;\n\n        case DISAS_NORETURN:\n\n            break;\n\n        }\n\n    } else {\n\n        /* While branches must always occur at the end of an IT block,\n\n           there are a few other things that can cause us to terminate\n\n           the TB in the middle of an IT block:\n\n            - Exception generating instructions (bkpt, swi, undefined).\n\n            - Page boundaries.\n\n            - Hardware watchpoints.\n\n           Hardware breakpoints have already been handled and skip this code.\n\n         */\n\n        switch(dc->is_jmp) {\n\n        case DISAS_NEXT:\n\n            gen_goto_tb(dc, 1, dc->pc);\n\n            break;\n\n        case DISAS_JUMP:\n\n            gen_goto_ptr();\n\n            break;\n\n        case DISAS_UPDATE:\n\n            gen_set_pc_im(dc, dc->pc);\n\n            /* fall through */\n\n        default:\n\n            /* indicate that the hash table must be used to find the next TB */\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        case DISAS_NORETURN:\n\n            /* nothing more to generate */\n\n            break;\n\n        case DISAS_WFI:\n\n            gen_helper_wfi(cpu_env);\n\n            /* The helper doesn't necessarily throw an exception, but we\n\n             * must go back to the main loop to check for interrupts anyway.\n\n             */\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        case DISAS_WFE:\n\n            gen_helper_wfe(cpu_env);\n\n            break;\n\n        case DISAS_YIELD:\n\n            gen_helper_yield(cpu_env);\n\n            break;\n\n        case DISAS_SWI:\n\n            gen_exception(EXCP_SWI, syn_aa32_svc(dc->svc_imm, dc->thumb),\n\n                          default_exception_el(dc));\n\n            break;\n\n        case DISAS_HVC:\n\n            gen_exception(EXCP_HVC, syn_aa32_hvc(dc->svc_imm), 2);\n\n            break;\n\n        case DISAS_SMC:\n\n            gen_exception(EXCP_SMC, syn_aa32_smc(), 3);\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (dc->condjmp) {\n\n        /* \"Condition failed\" instruction codepath for the branch/trap insn */\n\n        gen_set_label(dc->condlabel);\n\n        gen_set_condexec(dc);\n\n        if (unlikely(is_singlestepping(dc))) {\n\n            gen_set_pc_im(dc, dc->pc);\n\n            gen_singlestep_exception(dc);\n\n        } else {\n\n            gen_goto_tb(dc, 1, dc->pc);\n\n        }\n\n    }\n\n\n\ndone_generating:\n\n    gen_tb_end(tb, num_insns);\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM) &&\n\n        qemu_log_in_addr_range(pc_start)) {\n\n        qemu_log_lock();\n\n        qemu_log(\"----------------\\n\");\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n        log_target_disas(cs, pc_start, dc->pc - pc_start,\n\n                         dc->thumb | (dc->sctlr_b << 1));\n\n        qemu_log(\"\\n\");\n\n        qemu_log_unlock();\n\n    }\n\n#endif\n\n    tb->size = dc->pc - pc_start;\n\n    tb->icount = num_insns;\n\n}\n", "idx": 23750}
{"project": "qemu", "commit_id": "88b062c2036cfd05b5111147736a08ba05ea05a9", "target": 0, "func": "int bdrv_pdiscard(BlockDriverState *bs, int64_t offset, int count)\n\n{\n\n    Coroutine *co;\n\n    DiscardCo rwco = {\n\n        .bs = bs,\n\n        .offset = offset,\n\n        .count = count,\n\n        .ret = NOT_DONE,\n\n    };\n\n\n\n    if (qemu_in_coroutine()) {\n\n        /* Fast-path if already in coroutine context */\n\n        bdrv_pdiscard_co_entry(&rwco);\n\n    } else {\n\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n\n\n        co = qemu_coroutine_create(bdrv_pdiscard_co_entry, &rwco);\n\n        qemu_coroutine_enter(co);\n\n        while (rwco.ret == NOT_DONE) {\n\n            aio_poll(aio_context, true);\n\n        }\n\n    }\n\n\n\n    return rwco.ret;\n\n}\n", "idx": 23751}
{"project": "qemu", "commit_id": "bec1631100323fac0900aea71043d5c4e22fc2fa", "target": 0, "func": "static void tgen_brcond(TCGContext *s, TCGType type, TCGCond c,\n\n                        TCGReg r1, TCGArg c2, int c2const, int labelno)\n\n{\n\n    int cc;\n\n\n\n    if (facilities & FACILITY_GEN_INST_EXT) {\n\n        bool is_unsigned = is_unsigned_cond(c);\n\n        bool in_range;\n\n        S390Opcode opc;\n\n\n\n        cc = tcg_cond_to_s390_cond[c];\n\n\n\n        if (!c2const) {\n\n            opc = (type == TCG_TYPE_I32\n\n                   ? (is_unsigned ? RIE_CLRJ : RIE_CRJ)\n\n                   : (is_unsigned ? RIE_CLGRJ : RIE_CGRJ));\n\n            tgen_compare_branch(s, opc, cc, r1, c2, labelno);\n\n            return;\n\n        }\n\n\n\n        /* COMPARE IMMEDIATE AND BRANCH RELATIVE has an 8-bit immediate field.\n\n           If the immediate we've been given does not fit that range, we'll\n\n           fall back to separate compare and branch instructions using the\n\n           larger comparison range afforded by COMPARE IMMEDIATE.  */\n\n        if (type == TCG_TYPE_I32) {\n\n            if (is_unsigned) {\n\n                opc = RIE_CLIJ;\n\n                in_range = (uint32_t)c2 == (uint8_t)c2;\n\n            } else {\n\n                opc = RIE_CIJ;\n\n                in_range = (int32_t)c2 == (int8_t)c2;\n\n            }\n\n        } else {\n\n            if (is_unsigned) {\n\n                opc = RIE_CLGIJ;\n\n                in_range = (uint64_t)c2 == (uint8_t)c2;\n\n            } else {\n\n                opc = RIE_CGIJ;\n\n                in_range = (int64_t)c2 == (int8_t)c2;\n\n            }\n\n        }\n\n        if (in_range) {\n\n            tgen_compare_imm_branch(s, opc, cc, r1, c2, labelno);\n\n            return;\n\n        }\n\n    }\n\n\n\n    cc = tgen_cmp(s, type, c, r1, c2, c2const);\n\n    tgen_branch(s, cc, labelno);\n\n}\n", "idx": 23752}
{"project": "qemu", "commit_id": "a369da5f31ddbdeb32a7f76622e480d3995fbb00", "target": 0, "func": "void mips_malta_init (ram_addr_t ram_size,\n\n                      const char *boot_device,\n\n                      const char *kernel_filename, const char *kernel_cmdline,\n\n                      const char *initrd_filename, const char *cpu_model)\n\n{\n\n    char *filename;\n\n    pflash_t *fl;\n\n    MemoryRegion *system_memory = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *bios, *bios_alias = g_new(MemoryRegion, 1);\n\n    target_long bios_size;\n\n    int64_t kernel_entry;\n\n    PCIBus *pci_bus;\n\n    ISABus *isa_bus;\n\n    CPUState *env;\n\n    qemu_irq *isa_irq;\n\n    qemu_irq *cpu_exit_irq;\n\n    int piix4_devfn;\n\n    i2c_bus *smbus;\n\n    int i;\n\n    DriveInfo *dinfo;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    DriveInfo *fd[MAX_FD];\n\n    int fl_idx = 0;\n\n    int fl_sectors = 0;\n\n    int be;\n\n\n\n    DeviceState *dev = qdev_create(NULL, \"mips-malta\");\n\n    MaltaState *s = DO_UPCAST(MaltaState, busdev.qdev, dev);\n\n\n\n    qdev_init_nofail(dev);\n\n\n\n    /* Make sure the first 3 serial ports are associated with a device. */\n\n    for(i = 0; i < 3; i++) {\n\n        if (!serial_hds[i]) {\n\n            char label[32];\n\n            snprintf(label, sizeof(label), \"serial%d\", i);\n\n            serial_hds[i] = qemu_chr_new(label, \"null\", NULL);\n\n        }\n\n    }\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n#ifdef TARGET_MIPS64\n\n        cpu_model = \"20Kc\";\n\n#else\n\n        cpu_model = \"24Kf\";\n\n#endif\n\n    }\n\n\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        /* Init internal devices */\n\n        cpu_mips_irq_init_cpu(env);\n\n        cpu_mips_clock_init(env);\n\n        qemu_register_reset(main_cpu_reset, env);\n\n    }\n\n    env = first_cpu;\n\n\n\n    /* allocate RAM */\n\n    if (ram_size > (256 << 20)) {\n\n        fprintf(stderr,\n\n                \"qemu: Too much memory for this machine: %d MB, maximum 256 MB\\n\",\n\n                ((unsigned int)ram_size / (1 << 20)));\n\n        exit(1);\n\n    }\n\n    memory_region_init_ram(ram, \"mips_malta.ram\", ram_size);\n\n    vmstate_register_ram_global(ram);\n\n    memory_region_add_subregion(system_memory, 0, ram);\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    /* FPGA */\n\n    malta_fpga_init(system_memory, 0x1f000000LL, env->irq[2], serial_hds[2]);\n\n\n\n    /* Load firmware in flash / BIOS unless we boot directly into a kernel. */\n\n    if (kernel_filename) {\n\n        /* Write a small bootloader to the flash location. */\n\n        bios = g_new(MemoryRegion, 1);\n\n        memory_region_init_ram(bios, \"mips_malta.bios\", BIOS_SIZE);\n\n        vmstate_register_ram_global(bios);\n\n        memory_region_set_readonly(bios, true);\n\n        memory_region_init_alias(bios_alias, \"bios.1fc\", bios, 0, BIOS_SIZE);\n\n        /* Map the bios at two physical locations, as on the real board. */\n\n        memory_region_add_subregion(system_memory, 0x1e000000LL, bios);\n\n        memory_region_add_subregion(system_memory, 0x1fc00000LL, bios_alias);\n\n        loaderparams.ram_size = ram_size;\n\n        loaderparams.kernel_filename = kernel_filename;\n\n        loaderparams.kernel_cmdline = kernel_cmdline;\n\n        loaderparams.initrd_filename = initrd_filename;\n\n        kernel_entry = load_kernel();\n\n        write_bootloader(env, memory_region_get_ram_ptr(bios), kernel_entry);\n\n    } else {\n\n        dinfo = drive_get(IF_PFLASH, 0, fl_idx);\n\n        if (dinfo) {\n\n            /* Load firmware from flash. */\n\n            bios_size = 0x400000;\n\n            fl_sectors = bios_size >> 16;\n\n#ifdef DEBUG_BOARD_INIT\n\n            printf(\"Register parallel flash %d size \" TARGET_FMT_lx \" at \"\n\n                   \"addr %08llx '%s' %x\\n\",\n\n                   fl_idx, bios_size, 0x1e000000LL,\n\n                   bdrv_get_device_name(dinfo->bdrv), fl_sectors);\n\n#endif\n\n            fl = pflash_cfi01_register(0x1e000000LL,\n\n                                       NULL, \"mips_malta.bios\", BIOS_SIZE,\n\n                                       dinfo->bdrv, 65536, fl_sectors,\n\n                                       4, 0x0000, 0x0000, 0x0000, 0x0000, be);\n\n            bios = pflash_cfi01_get_memory(fl);\n\n            /* Map the bios at two physical locations, as on the real board. */\n\n            memory_region_init_alias(bios_alias, \"bios.1fc\",\n\n                                     bios, 0, BIOS_SIZE);\n\n            memory_region_add_subregion(system_memory, 0x1fc00000LL,\n\n                                        bios_alias);\n\n           fl_idx++;\n\n        } else {\n\n            bios = g_new(MemoryRegion, 1);\n\n            memory_region_init_ram(bios, \"mips_malta.bios\", BIOS_SIZE);\n\n            vmstate_register_ram_global(bios);\n\n            memory_region_set_readonly(bios, true);\n\n            memory_region_init_alias(bios_alias, \"bios.1fc\",\n\n                                     bios, 0, BIOS_SIZE);\n\n            /* Map the bios at two physical locations, as on the real board. */\n\n            memory_region_add_subregion(system_memory, 0x1e000000LL, bios);\n\n            memory_region_add_subregion(system_memory, 0x1fc00000LL,\n\n                                        bios_alias);\n\n            /* Load a BIOS image. */\n\n            if (bios_name == NULL)\n\n                bios_name = BIOS_FILENAME;\n\n            filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n            if (filename) {\n\n                bios_size = load_image_targphys(filename, 0x1fc00000LL,\n\n                                                BIOS_SIZE);\n\n                g_free(filename);\n\n            } else {\n\n                bios_size = -1;\n\n            }\n\n            if ((bios_size < 0 || bios_size > BIOS_SIZE) && !kernel_filename) {\n\n                fprintf(stderr,\n\n                        \"qemu: Could not load MIPS bios '%s', and no -kernel argument was specified\\n\",\n\n                        bios_name);\n\n                exit(1);\n\n            }\n\n        }\n\n        /* In little endian mode the 32bit words in the bios are swapped,\n\n           a neat trick which allows bi-endian firmware. */\n\n#ifndef TARGET_WORDS_BIGENDIAN\n\n        {\n\n            uint32_t *addr = memory_region_get_ram_ptr(bios);\n\n            uint32_t *end = addr + bios_size;\n\n            while (addr < end) {\n\n                bswap32s(addr);\n\n                addr++;\n\n            }\n\n        }\n\n#endif\n\n    }\n\n\n\n    /* Board ID = 0x420 (Malta Board with CoreLV)\n\n       XXX: theoretically 0x1e000010 should map to flash and 0x1fc00010 should\n\n       map to the board ID. */\n\n    stl_p(memory_region_get_ram_ptr(bios) + 0x10, 0x00000420);\n\n\n\n    /* Init internal devices */\n\n    cpu_mips_irq_init_cpu(env);\n\n    cpu_mips_clock_init(env);\n\n\n\n    /*\n\n     * We have a circular dependency problem: pci_bus depends on isa_irq,\n\n     * isa_irq is provided by i8259, i8259 depends on ISA, ISA depends\n\n     * on piix4, and piix4 depends on pci_bus.  To stop the cycle we have\n\n     * qemu_irq_proxy() adds an extra bit of indirection, allowing us\n\n     * to resolve the isa_irq -> i8259 dependency after i8259 is initialized.\n\n     */\n\n    isa_irq = qemu_irq_proxy(&s->i8259, 16);\n\n\n\n    /* Northbridge */\n\n    pci_bus = gt64120_register(isa_irq);\n\n\n\n    /* Southbridge */\n\n    ide_drive_get(hd, MAX_IDE_BUS);\n\n\n\n    piix4_devfn = piix4_init(pci_bus, &isa_bus, 80);\n\n\n\n    /* Interrupt controller */\n\n    /* The 8259 is attached to the MIPS CPU INT0 pin, ie interrupt 2 */\n\n    s->i8259 = i8259_init(isa_bus, env->irq[2]);\n\n\n\n    isa_bus_irqs(isa_bus, s->i8259);\n\n    pci_piix4_ide_init(pci_bus, hd, piix4_devfn + 1);\n\n    usb_uhci_piix4_init(pci_bus, piix4_devfn + 2);\n\n    smbus = piix4_pm_init(pci_bus, piix4_devfn + 3, 0x1100,\n\n                          isa_get_irq(NULL, 9), NULL, NULL, 0);\n\n    /* TODO: Populate SPD eeprom data.  */\n\n    smbus_eeprom_init(smbus, 8, NULL, 0);\n\n    pit = pit_init(isa_bus, 0x40, 0);\n\n    cpu_exit_irq = qemu_allocate_irqs(cpu_request_exit, NULL, 1);\n\n    DMA_init(0, cpu_exit_irq);\n\n\n\n    /* Super I/O */\n\n    isa_create_simple(isa_bus, \"i8042\");\n\n\n\n    rtc_init(isa_bus, 2000, NULL);\n\n    serial_isa_init(isa_bus, 0, serial_hds[0]);\n\n    serial_isa_init(isa_bus, 1, serial_hds[1]);\n\n    if (parallel_hds[0])\n\n        parallel_init(isa_bus, 0, parallel_hds[0]);\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        fd[i] = drive_get(IF_FLOPPY, 0, i);\n\n    }\n\n    fdctrl_init_isa(isa_bus, fd);\n\n\n\n    /* Sound card */\n\n    audio_init(isa_bus, pci_bus);\n\n\n\n    /* Network card */\n\n    network_init();\n\n\n\n    /* Optional PCI video card */\n\n    if (cirrus_vga_enabled) {\n\n        pci_cirrus_vga_init(pci_bus);\n\n    } else if (vmsvga_enabled) {\n\n        if (!pci_vmsvga_init(pci_bus)) {\n\n            fprintf(stderr, \"Warning: vmware_vga not available,\"\n\n                    \" using standard VGA instead\\n\");\n\n            pci_vga_init(pci_bus);\n\n        }\n\n    } else if (std_vga_enabled) {\n\n        pci_vga_init(pci_bus);\n\n    }\n\n}\n", "idx": 23753}
{"project": "qemu", "commit_id": "105fad6bb226ac3404874fe3fd7013ad6f86fc86", "target": 0, "func": "void qmp_guest_set_time(bool has_time, int64_t time_ns, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    SYSTEMTIME ts;\n\n    FILETIME tf;\n\n    LONGLONG time;\n\n\n\n    if (!has_time) {\n\n        /* Unfortunately, Windows libraries don't provide an easy way to access\n\n         * RTC yet:\n\n         *\n\n         * https://msdn.microsoft.com/en-us/library/aa908981.aspx\n\n         */\n\n        error_setg(errp, \"Time argument is required on this platform\");\n\n        return;\n\n    }\n\n\n\n    /* Validate time passed by user. */\n\n    if (time_ns < 0 || time_ns / 100 > INT64_MAX - W32_FT_OFFSET) {\n\n        error_setg(errp, \"Time %\" PRId64 \"is invalid\", time_ns);\n\n        return;\n\n    }\n\n\n\n    time = time_ns / 100 + W32_FT_OFFSET;\n\n\n\n    tf.dwLowDateTime = (DWORD) time;\n\n    tf.dwHighDateTime = (DWORD) (time >> 32);\n\n\n\n    if (!FileTimeToSystemTime(&tf, &ts)) {\n\n        error_setg(errp, \"Failed to convert system time %d\",\n\n                   (int)GetLastError());\n\n        return;\n\n    }\n\n\n\n    acquire_privilege(SE_SYSTEMTIME_NAME, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    if (!SetSystemTime(&ts)) {\n\n        error_setg(errp, \"Failed to set time to guest: %d\", (int)GetLastError());\n\n        return;\n\n    }\n\n}\n", "idx": 23754}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "static uint32_t qpi_mem_readb(void *opaque, target_phys_addr_t addr)\n\n{\n\n    return 0;\n\n}\n", "idx": 23755}
{"project": "qemu", "commit_id": "406c20754a29586f6dc1fccacbca3792be24922c", "target": 0, "func": "struct MUSBState *musb_init(qemu_irq *irqs)\n\n{\n\n    MUSBState *s = g_malloc0(sizeof(*s));\n\n    int i;\n\n\n\n    s->irqs = irqs;\n\n\n\n    s->faddr = 0x00;\n\n    s->power = MGC_M_POWER_HSENAB;\n\n    s->tx_intr = 0x0000;\n\n    s->rx_intr = 0x0000;\n\n    s->tx_mask = 0xffff;\n\n    s->rx_mask = 0xffff;\n\n    s->intr = 0x00;\n\n    s->mask = 0x06;\n\n    s->idx = 0;\n\n\n\n    /* TODO: _DW */\n\n    s->ep[0].config = MGC_M_CONFIGDATA_SOFTCONE | MGC_M_CONFIGDATA_DYNFIFO;\n\n    for (i = 0; i < 16; i ++) {\n\n        s->ep[i].fifosize = 64;\n\n        s->ep[i].maxp[0] = 0x40;\n\n        s->ep[i].maxp[1] = 0x40;\n\n        s->ep[i].musb = s;\n\n        s->ep[i].epnum = i;\n\n        usb_packet_init(&s->ep[i].packey[0].p);\n\n        usb_packet_init(&s->ep[i].packey[1].p);\n\n    }\n\n\n\n    usb_bus_new(&s->bus, &musb_bus_ops, NULL /* FIXME */);\n\n    usb_register_port(&s->bus, &s->port, s, 0, &musb_port_ops,\n\n                      USB_SPEED_MASK_LOW | USB_SPEED_MASK_FULL);\n\n\n\n    return s;\n\n}\n", "idx": 23757}
{"project": "qemu", "commit_id": "f9f46db444a2dfc2ebf1f9f7d4b42163ab33187d", "target": 0, "func": "void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)\n\n{\n\n    uintptr_t ra = GETPC();\n\n\n\n    switch (addr & 3) {\n\n    case 3:\n\n        cpu_stb_data_ra(env, addr, val, ra);\n\n        break;\n\n    case 2:\n\n        cpu_stw_data_ra(env, addr, val, ra);\n\n        break;\n\n    case 1:\n\n        /* The 3 byte store must appear atomic.  */\n\n        if (parallel_cpus) {\n\n            atomic_store_3(env, addr, val, 0x00ffffffu, ra);\n\n        } else {\n\n            cpu_stb_data_ra(env, addr, val >> 16, ra);\n\n            cpu_stw_data_ra(env, addr + 1, val, ra);\n\n        }\n\n        break;\n\n    default:\n\n        cpu_stl_data_ra(env, addr, val, ra);\n\n        break;\n\n    }\n\n}\n", "idx": 23758}
{"project": "qemu", "commit_id": "765a707000e838c30b18d712fe6cb3dd8e0435f3", "target": 1, "func": "static int megasas_map_dcmd(MegasasState *s, MegasasCmd *cmd)\n\n{\n\n    dma_addr_t iov_pa, iov_size;\n\n\n\n    cmd->flags = le16_to_cpu(cmd->frame->header.flags);\n\n    if (!cmd->frame->header.sge_count) {\n\n        trace_megasas_dcmd_zero_sge(cmd->index);\n\n        cmd->iov_size = 0;\n\n        return 0;\n\n    } else if (cmd->frame->header.sge_count > 1) {\n\n        trace_megasas_dcmd_invalid_sge(cmd->index,\n\n                                       cmd->frame->header.sge_count);\n\n        cmd->iov_size = 0;\n\n        return -1;\n\n    }\n\n    iov_pa = megasas_sgl_get_addr(cmd, &cmd->frame->dcmd.sgl);\n\n    iov_size = megasas_sgl_get_len(cmd, &cmd->frame->dcmd.sgl);\n\n    pci_dma_sglist_init(&cmd->qsg, PCI_DEVICE(s), 1);\n\n    qemu_sglist_add(&cmd->qsg, iov_pa, iov_size);\n\n    cmd->iov_size = iov_size;\n\n    return cmd->iov_size;\n\n}\n", "idx": 23761}
{"project": "qemu", "commit_id": "e89001f72edde37fb36fa7c964daa1bbeb2eca26", "target": 1, "func": "void pc_cmos_init(ram_addr_t ram_size, ram_addr_t above_4g_mem_size,\n\n                  const char *boot_device,\n\n                  ISADevice *floppy, BusState *idebus0, BusState *idebus1,\n\n                  ISADevice *s)\n\n{\n\n    int val, nb, i;\n\n    FDriveType fd_type[2] = { FDRIVE_DRV_NONE, FDRIVE_DRV_NONE };\n\n    static pc_cmos_init_late_arg arg;\n\n\n\n    /* various important CMOS locations needed by PC/Bochs bios */\n\n\n\n    /* memory size */\n\n    val = 640; /* base memory in K */\n\n    rtc_set_memory(s, 0x15, val);\n\n    rtc_set_memory(s, 0x16, val >> 8);\n\n\n\n    val = (ram_size / 1024) - 1024;\n\n    if (val > 65535)\n\n        val = 65535;\n\n    rtc_set_memory(s, 0x17, val);\n\n    rtc_set_memory(s, 0x18, val >> 8);\n\n    rtc_set_memory(s, 0x30, val);\n\n    rtc_set_memory(s, 0x31, val >> 8);\n\n\n\n    if (above_4g_mem_size) {\n\n        rtc_set_memory(s, 0x5b, (unsigned int)above_4g_mem_size >> 16);\n\n        rtc_set_memory(s, 0x5c, (unsigned int)above_4g_mem_size >> 24);\n\n        rtc_set_memory(s, 0x5d, (uint64_t)above_4g_mem_size >> 32);\n\n    }\n\n\n\n    if (ram_size > (16 * 1024 * 1024))\n\n        val = (ram_size / 65536) - ((16 * 1024 * 1024) / 65536);\n\n    else\n\n        val = 0;\n\n    if (val > 65535)\n\n        val = 65535;\n\n    rtc_set_memory(s, 0x34, val);\n\n    rtc_set_memory(s, 0x35, val >> 8);\n\n\n\n    /* set the number of CPU */\n\n    rtc_set_memory(s, 0x5f, smp_cpus - 1);\n\n\n\n    /* set boot devices, and disable floppy signature check if requested */\n\n    if (set_boot_dev(s, boot_device, fd_bootchk)) {\n\n        exit(1);\n\n    }\n\n\n\n    /* floppy type */\n\n    if (floppy) {\n\n        for (i = 0; i < 2; i++) {\n\n            fd_type[i] = isa_fdc_get_drive_type(floppy, i);\n\n        }\n\n    }\n\n    val = (cmos_get_fd_drive_type(fd_type[0]) << 4) |\n\n        cmos_get_fd_drive_type(fd_type[1]);\n\n    rtc_set_memory(s, 0x10, val);\n\n\n\n    val = 0;\n\n    nb = 0;\n\n    if (fd_type[0] < FDRIVE_DRV_NONE) {\n\n        nb++;\n\n    }\n\n    if (fd_type[1] < FDRIVE_DRV_NONE) {\n\n        nb++;\n\n    }\n\n    switch (nb) {\n\n    case 0:\n\n        break;\n\n    case 1:\n\n        val |= 0x01; /* 1 drive, ready for boot */\n\n        break;\n\n    case 2:\n\n        val |= 0x41; /* 2 drives, ready for boot */\n\n        break;\n\n    }\n\n    val |= 0x02; /* FPU is there */\n\n    val |= 0x04; /* PS/2 mouse installed */\n\n    rtc_set_memory(s, REG_EQUIPMENT_BYTE, val);\n\n\n\n    /* hard drives */\n\n    arg.rtc_state = s;\n\n    arg.idebus[0] = idebus0;\n\n    arg.idebus[1] = idebus1;\n\n    qemu_register_reset(pc_cmos_init_late, &arg);\n\n}\n", "idx": 23763}
{"project": "qemu", "commit_id": "895b00f62a7e86724dc7352d67c7808d37366130", "target": 1, "func": "struct GuestFileRead *qmp_guest_file_read(int64_t handle, bool has_count,\n                                          int64_t count, Error **errp)\n{\n    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);\n    GuestFileRead *read_data = NULL;\n    guchar *buf;\n    FILE *fh;\n    size_t read_count;\n    if (!gfh) {\n    if (!has_count) {\n        count = QGA_READ_COUNT_DEFAULT;\n    } else if (count < 0) {\n        error_setg(errp, \"value '%\" PRId64 \"' is invalid for argument count\",\n                   count);\n    fh = gfh->fh;\n    buf = g_malloc0(count+1);\n    read_count = fread(buf, 1, count, fh);\n    if (ferror(fh)) {\n        error_setg_errno(errp, errno, \"failed to read file\");\n        slog(\"guest-file-read failed, handle: %\" PRId64, handle);\n    } else {\n        buf[read_count] = 0;\n        read_data = g_new0(GuestFileRead, 1);\n        read_data->count = read_count;\n        read_data->eof = feof(fh);\n        if (read_count) {\n            read_data->buf_b64 = g_base64_encode(buf, read_count);\n        gfh->state = RW_STATE_READING;\n    g_free(buf);\n    clearerr(fh);\n    return read_data;", "idx": 23766}
{"project": "qemu", "commit_id": "baf35cb90204d75404892aa4e52628ae7a00669b", "target": 1, "func": "void qemu_aio_wait_start(void)\n\n{\n\n}\n", "idx": 23768}
{"project": "qemu", "commit_id": "5f3e31012e334f3410e04abae7f88565df17c91a", "target": 1, "func": "int64_t cpu_get_ticks(void)\n\n{\n\n    if (use_icount) {\n\n        return cpu_get_icount();\n\n    }\n\n    if (!timers_state.cpu_ticks_enabled) {\n\n        return timers_state.cpu_ticks_offset;\n\n    } else {\n\n        int64_t ticks;\n\n        ticks = cpu_get_real_ticks();\n\n        if (timers_state.cpu_ticks_prev > ticks) {\n\n            /* Note: non increasing ticks may happen if the host uses\n\n               software suspend */\n\n            timers_state.cpu_ticks_offset += timers_state.cpu_ticks_prev - ticks;\n\n        }\n\n        timers_state.cpu_ticks_prev = ticks;\n\n        return ticks + timers_state.cpu_ticks_offset;\n\n    }\n\n}\n", "idx": 23770}
{"project": "qemu", "commit_id": "52c91dac6bd891656f297dab76da51fc8bc61309", "target": 1, "func": "static void memory_region_destructor_alias(MemoryRegion *mr)\n\n{\n\n    memory_region_unref(mr->alias);\n\n}\n", "idx": 23771}
{"project": "qemu", "commit_id": "4b9b7092b4cbef084138a446b8247ba89fd474f4", "target": 1, "func": "static void cdrom_change_cb(void *opaque, int reason)\n\n{\n\n    IDEState *s = opaque;\n\n    uint64_t nb_sectors;\n\n\n\n    if (!(reason & CHANGE_MEDIA)) {\n\n        return;\n\n    }\n\n\n\n    bdrv_get_geometry(s->bs, &nb_sectors);\n\n    s->nb_sectors = nb_sectors;\n\n\n\n    s->sense_key = SENSE_UNIT_ATTENTION;\n\n    s->asc = ASC_MEDIUM_MAY_HAVE_CHANGED;\n\n    s->cdrom_changed = 1;\n\n    s->events.new_media = true;\n\n    ide_set_irq(s->bus);\n\n}\n", "idx": 23772}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_rev16(TCGv var)\n\n{\n\n    TCGv tmp = new_tmp();\n\n    tcg_gen_shri_i32(tmp, var, 8);\n\n    tcg_gen_andi_i32(tmp, tmp, 0x00ff00ff);\n\n    tcg_gen_shli_i32(var, var, 8);\n\n    tcg_gen_andi_i32(var, var, 0xff00ff00);\n\n    tcg_gen_or_i32(var, var, tmp);\n\n    dead_tmp(tmp);\n\n}\n", "idx": 23773}
{"project": "qemu", "commit_id": "52f34623b499cb0273118b1f637c2c6ebaf5d5a1", "target": 1, "func": "static int gdb_handle_packet(GDBState *s, const char *line_buf)\n\n{\n\n    CPUArchState *env;\n\n    const char *p;\n\n    uint32_t thread;\n\n    int ch, reg_size, type, res;\n\n    char buf[MAX_PACKET_LENGTH];\n\n    uint8_t mem_buf[MAX_PACKET_LENGTH];\n\n    uint8_t *registers;\n\n    target_ulong addr, len;\n\n\n\n#ifdef DEBUG_GDB\n\n    printf(\"command='%s'\\n\", line_buf);\n\n#endif\n\n    p = line_buf;\n\n    ch = *p++;\n\n    switch(ch) {\n\n    case '?':\n\n        /* TODO: Make this return the correct value for user-mode.  */\n\n        snprintf(buf, sizeof(buf), \"T%02xthread:%02x;\", GDB_SIGNAL_TRAP,\n\n                 cpu_index(ENV_GET_CPU(s->c_cpu)));\n\n        put_packet(s, buf);\n\n        /* Remove all the breakpoints when this query is issued,\n\n         * because gdb is doing and initial connect and the state\n\n         * should be cleaned up.\n\n         */\n\n        gdb_breakpoint_remove_all();\n\n        break;\n\n    case 'c':\n\n        if (*p != '\\0') {\n\n            addr = strtoull(p, (char **)&p, 16);\n\n            gdb_set_cpu_pc(s, addr);\n\n        }\n\n        s->signal = 0;\n\n        gdb_continue(s);\n\n\treturn RS_IDLE;\n\n    case 'C':\n\n        s->signal = gdb_signal_to_target (strtoul(p, (char **)&p, 16));\n\n        if (s->signal == -1)\n\n            s->signal = 0;\n\n        gdb_continue(s);\n\n        return RS_IDLE;\n\n    case 'v':\n\n        if (strncmp(p, \"Cont\", 4) == 0) {\n\n            int res_signal, res_thread;\n\n\n\n            p += 4;\n\n            if (*p == '?') {\n\n                put_packet(s, \"vCont;c;C;s;S\");\n\n                break;\n\n            }\n\n            res = 0;\n\n            res_signal = 0;\n\n            res_thread = 0;\n\n            while (*p) {\n\n                int action, signal;\n\n\n\n                if (*p++ != ';') {\n\n                    res = 0;\n\n                    break;\n\n                }\n\n                action = *p++;\n\n                signal = 0;\n\n                if (action == 'C' || action == 'S') {\n\n                    signal = strtoul(p, (char **)&p, 16);\n\n                } else if (action != 'c' && action != 's') {\n\n                    res = 0;\n\n                    break;\n\n                }\n\n                thread = 0;\n\n                if (*p == ':') {\n\n                    thread = strtoull(p+1, (char **)&p, 16);\n\n                }\n\n                action = tolower(action);\n\n                if (res == 0 || (res == 'c' && action == 's')) {\n\n                    res = action;\n\n                    res_signal = signal;\n\n                    res_thread = thread;\n\n                }\n\n            }\n\n            if (res) {\n\n                if (res_thread != -1 && res_thread != 0) {\n\n                    env = find_cpu(res_thread);\n\n                    if (env == NULL) {\n\n                        put_packet(s, \"E22\");\n\n                        break;\n\n                    }\n\n                    s->c_cpu = env;\n\n                }\n\n                if (res == 's') {\n\n                    cpu_single_step(s->c_cpu, sstep_flags);\n\n                }\n\n                s->signal = res_signal;\n\n                gdb_continue(s);\n\n                return RS_IDLE;\n\n            }\n\n            break;\n\n        } else {\n\n            goto unknown_command;\n\n        }\n\n    case 'k':\n\n#ifdef CONFIG_USER_ONLY\n\n        /* Kill the target */\n\n        fprintf(stderr, \"\\nQEMU: Terminated via GDBstub\\n\");\n\n        exit(0);\n\n#endif\n\n    case 'D':\n\n        /* Detach packet */\n\n        gdb_breakpoint_remove_all();\n\n        gdb_syscall_mode = GDB_SYS_DISABLED;\n\n        gdb_continue(s);\n\n        put_packet(s, \"OK\");\n\n        break;\n\n    case 's':\n\n        if (*p != '\\0') {\n\n            addr = strtoull(p, (char **)&p, 16);\n\n            gdb_set_cpu_pc(s, addr);\n\n        }\n\n        cpu_single_step(s->c_cpu, sstep_flags);\n\n        gdb_continue(s);\n\n\treturn RS_IDLE;\n\n    case 'F':\n\n        {\n\n            target_ulong ret;\n\n            target_ulong err;\n\n\n\n            ret = strtoull(p, (char **)&p, 16);\n\n            if (*p == ',') {\n\n                p++;\n\n                err = strtoull(p, (char **)&p, 16);\n\n            } else {\n\n                err = 0;\n\n            }\n\n            if (*p == ',')\n\n                p++;\n\n            type = *p;\n\n            if (s->current_syscall_cb) {\n\n                s->current_syscall_cb(s->c_cpu, ret, err);\n\n                s->current_syscall_cb = NULL;\n\n            }\n\n            if (type == 'C') {\n\n                put_packet(s, \"T02\");\n\n            } else {\n\n                gdb_continue(s);\n\n            }\n\n        }\n\n        break;\n\n    case 'g':\n\n        cpu_synchronize_state(ENV_GET_CPU(s->g_cpu));\n\n        env = s->g_cpu;\n\n        len = 0;\n\n        for (addr = 0; addr < num_g_regs; addr++) {\n\n            reg_size = gdb_read_register(s->g_cpu, mem_buf + len, addr);\n\n            len += reg_size;\n\n        }\n\n        memtohex(buf, mem_buf, len);\n\n        put_packet(s, buf);\n\n        break;\n\n    case 'G':\n\n        cpu_synchronize_state(ENV_GET_CPU(s->g_cpu));\n\n        env = s->g_cpu;\n\n        registers = mem_buf;\n\n        len = strlen(p) / 2;\n\n        hextomem((uint8_t *)registers, p, len);\n\n        for (addr = 0; addr < num_g_regs && len > 0; addr++) {\n\n            reg_size = gdb_write_register(s->g_cpu, registers, addr);\n\n            len -= reg_size;\n\n            registers += reg_size;\n\n        }\n\n        put_packet(s, \"OK\");\n\n        break;\n\n    case 'm':\n\n        addr = strtoull(p, (char **)&p, 16);\n\n        if (*p == ',')\n\n            p++;\n\n        len = strtoull(p, NULL, 16);\n\n        if (target_memory_rw_debug(s->g_cpu, addr, mem_buf, len, 0) != 0) {\n\n            put_packet (s, \"E14\");\n\n        } else {\n\n            memtohex(buf, mem_buf, len);\n\n            put_packet(s, buf);\n\n        }\n\n        break;\n\n    case 'M':\n\n        addr = strtoull(p, (char **)&p, 16);\n\n        if (*p == ',')\n\n            p++;\n\n        len = strtoull(p, (char **)&p, 16);\n\n        if (*p == ':')\n\n            p++;\n\n        hextomem(mem_buf, p, len);\n\n        if (target_memory_rw_debug(s->g_cpu, addr, mem_buf, len, 1) != 0) {\n\n            put_packet(s, \"E14\");\n\n        } else {\n\n            put_packet(s, \"OK\");\n\n        }\n\n        break;\n\n    case 'p':\n\n        /* Older gdb are really dumb, and don't use 'g' if 'p' is avaialable.\n\n           This works, but can be very slow.  Anything new enough to\n\n           understand XML also knows how to use this properly.  */\n\n        if (!gdb_has_xml)\n\n            goto unknown_command;\n\n        addr = strtoull(p, (char **)&p, 16);\n\n        reg_size = gdb_read_register(s->g_cpu, mem_buf, addr);\n\n        if (reg_size) {\n\n            memtohex(buf, mem_buf, reg_size);\n\n            put_packet(s, buf);\n\n        } else {\n\n            put_packet(s, \"E14\");\n\n        }\n\n        break;\n\n    case 'P':\n\n        if (!gdb_has_xml)\n\n            goto unknown_command;\n\n        addr = strtoull(p, (char **)&p, 16);\n\n        if (*p == '=')\n\n            p++;\n\n        reg_size = strlen(p) / 2;\n\n        hextomem(mem_buf, p, reg_size);\n\n        gdb_write_register(s->g_cpu, mem_buf, addr);\n\n        put_packet(s, \"OK\");\n\n        break;\n\n    case 'Z':\n\n    case 'z':\n\n        type = strtoul(p, (char **)&p, 16);\n\n        if (*p == ',')\n\n            p++;\n\n        addr = strtoull(p, (char **)&p, 16);\n\n        if (*p == ',')\n\n            p++;\n\n        len = strtoull(p, (char **)&p, 16);\n\n        if (ch == 'Z')\n\n            res = gdb_breakpoint_insert(addr, len, type);\n\n        else\n\n            res = gdb_breakpoint_remove(addr, len, type);\n\n        if (res >= 0)\n\n             put_packet(s, \"OK\");\n\n        else if (res == -ENOSYS)\n\n            put_packet(s, \"\");\n\n        else\n\n            put_packet(s, \"E22\");\n\n        break;\n\n    case 'H':\n\n        type = *p++;\n\n        thread = strtoull(p, (char **)&p, 16);\n\n        if (thread == -1 || thread == 0) {\n\n            put_packet(s, \"OK\");\n\n            break;\n\n        }\n\n        env = find_cpu(thread);\n\n        if (env == NULL) {\n\n            put_packet(s, \"E22\");\n\n            break;\n\n        }\n\n        switch (type) {\n\n        case 'c':\n\n            s->c_cpu = env;\n\n            put_packet(s, \"OK\");\n\n            break;\n\n        case 'g':\n\n            s->g_cpu = env;\n\n            put_packet(s, \"OK\");\n\n            break;\n\n        default:\n\n             put_packet(s, \"E22\");\n\n             break;\n\n        }\n\n        break;\n\n    case 'T':\n\n        thread = strtoull(p, (char **)&p, 16);\n\n        env = find_cpu(thread);\n\n\n\n        if (env != NULL) {\n\n            put_packet(s, \"OK\");\n\n        } else {\n\n            put_packet(s, \"E22\");\n\n        }\n\n        break;\n\n    case 'q':\n\n    case 'Q':\n\n        /* parse any 'q' packets here */\n\n        if (!strcmp(p,\"qemu.sstepbits\")) {\n\n            /* Query Breakpoint bit definitions */\n\n            snprintf(buf, sizeof(buf), \"ENABLE=%x,NOIRQ=%x,NOTIMER=%x\",\n\n                     SSTEP_ENABLE,\n\n                     SSTEP_NOIRQ,\n\n                     SSTEP_NOTIMER);\n\n            put_packet(s, buf);\n\n            break;\n\n        } else if (strncmp(p,\"qemu.sstep\",10) == 0) {\n\n            /* Display or change the sstep_flags */\n\n            p += 10;\n\n            if (*p != '=') {\n\n                /* Display current setting */\n\n                snprintf(buf, sizeof(buf), \"0x%x\", sstep_flags);\n\n                put_packet(s, buf);\n\n                break;\n\n            }\n\n            p++;\n\n            type = strtoul(p, (char **)&p, 16);\n\n            sstep_flags = type;\n\n            put_packet(s, \"OK\");\n\n            break;\n\n        } else if (strcmp(p,\"C\") == 0) {\n\n            /* \"Current thread\" remains vague in the spec, so always return\n\n             *  the first CPU (gdb returns the first thread). */\n\n            put_packet(s, \"QC1\");\n\n            break;\n\n        } else if (strcmp(p,\"fThreadInfo\") == 0) {\n\n            s->query_cpu = first_cpu->env_ptr;\n\n            goto report_cpuinfo;\n\n        } else if (strcmp(p,\"sThreadInfo\") == 0) {\n\n        report_cpuinfo:\n\n            if (s->query_cpu) {\n\n                snprintf(buf, sizeof(buf), \"m%x\",\n\n                         cpu_index(ENV_GET_CPU(s->query_cpu)));\n\n                put_packet(s, buf);\n\n                s->query_cpu = ENV_GET_CPU(s->query_cpu)->next_cpu->env_ptr;\n\n            } else\n\n                put_packet(s, \"l\");\n\n            break;\n\n        } else if (strncmp(p,\"ThreadExtraInfo,\", 16) == 0) {\n\n            thread = strtoull(p+16, (char **)&p, 16);\n\n            env = find_cpu(thread);\n\n            if (env != NULL) {\n\n                CPUState *cpu = ENV_GET_CPU(env);\n\n                cpu_synchronize_state(cpu);\n\n                len = snprintf((char *)mem_buf, sizeof(mem_buf),\n\n                               \"CPU#%d [%s]\", cpu->cpu_index,\n\n                               cpu->halted ? \"halted \" : \"running\");\n\n                memtohex(buf, mem_buf, len);\n\n                put_packet(s, buf);\n\n            }\n\n            break;\n\n        }\n\n#ifdef CONFIG_USER_ONLY\n\n        else if (strncmp(p, \"Offsets\", 7) == 0) {\n\n            TaskState *ts = s->c_cpu->opaque;\n\n\n\n            snprintf(buf, sizeof(buf),\n\n                     \"Text=\" TARGET_ABI_FMT_lx \";Data=\" TARGET_ABI_FMT_lx\n\n                     \";Bss=\" TARGET_ABI_FMT_lx,\n\n                     ts->info->code_offset,\n\n                     ts->info->data_offset,\n\n                     ts->info->data_offset);\n\n            put_packet(s, buf);\n\n            break;\n\n        }\n\n#else /* !CONFIG_USER_ONLY */\n\n        else if (strncmp(p, \"Rcmd,\", 5) == 0) {\n\n            int len = strlen(p + 5);\n\n\n\n            if ((len % 2) != 0) {\n\n                put_packet(s, \"E01\");\n\n                break;\n\n            }\n\n            hextomem(mem_buf, p + 5, len);\n\n            len = len / 2;\n\n            mem_buf[len++] = 0;\n\n            qemu_chr_be_write(s->mon_chr, mem_buf, len);\n\n            put_packet(s, \"OK\");\n\n            break;\n\n        }\n\n#endif /* !CONFIG_USER_ONLY */\n\n        if (strncmp(p, \"Supported\", 9) == 0) {\n\n            snprintf(buf, sizeof(buf), \"PacketSize=%x\", MAX_PACKET_LENGTH);\n\n#ifdef GDB_CORE_XML\n\n            pstrcat(buf, sizeof(buf), \";qXfer:features:read+\");\n\n#endif\n\n            put_packet(s, buf);\n\n            break;\n\n        }\n\n#ifdef GDB_CORE_XML\n\n        if (strncmp(p, \"Xfer:features:read:\", 19) == 0) {\n\n            const char *xml;\n\n            target_ulong total_len;\n\n\n\n            gdb_has_xml = 1;\n\n            p += 19;\n\n            xml = get_feature_xml(p, &p);\n\n            if (!xml) {\n\n                snprintf(buf, sizeof(buf), \"E00\");\n\n                put_packet(s, buf);\n\n                break;\n\n            }\n\n\n\n            if (*p == ':')\n\n                p++;\n\n            addr = strtoul(p, (char **)&p, 16);\n\n            if (*p == ',')\n\n                p++;\n\n            len = strtoul(p, (char **)&p, 16);\n\n\n\n            total_len = strlen(xml);\n\n            if (addr > total_len) {\n\n                snprintf(buf, sizeof(buf), \"E00\");\n\n                put_packet(s, buf);\n\n                break;\n\n            }\n\n            if (len > (MAX_PACKET_LENGTH - 5) / 2)\n\n                len = (MAX_PACKET_LENGTH - 5) / 2;\n\n            if (len < total_len - addr) {\n\n                buf[0] = 'm';\n\n                len = memtox(buf + 1, xml + addr, len);\n\n            } else {\n\n                buf[0] = 'l';\n\n                len = memtox(buf + 1, xml + addr, total_len - addr);\n\n            }\n\n            put_packet_binary(s, buf, len + 1);\n\n            break;\n\n        }\n\n#endif\n\n        /* Unrecognised 'q' command.  */\n\n        goto unknown_command;\n\n\n\n    default:\n\n    unknown_command:\n\n        /* put empty packet */\n\n        buf[0] = '\\0';\n\n        put_packet(s, buf);\n\n        break;\n\n    }\n\n    return RS_IDLE;\n\n}\n", "idx": 23774}
{"project": "qemu", "commit_id": "21f3f8db0e61884ca48e9969b0305d54f1efe24b", "target": 1, "func": "static void spapr_dt_ov5_platform_support(void *fdt, int chosen)\n\n{\n\n    PowerPCCPU *first_ppc_cpu = POWERPC_CPU(first_cpu);\n\n\n\n    char val[2 * 4] = {\n\n        23, 0x00, /* Xive mode: 0 = legacy (as in ISA 2.7), 1 = Exploitation */\n\n        24, 0x00, /* Hash/Radix, filled in below. */\n\n        25, 0x00, /* Hash options: Segment Tables == no, GTSE == no. */\n\n        26, 0x40, /* Radix options: GTSE == yes. */\n\n    };\n\n\n\n    if (kvm_enabled()) {\n\n        if (kvmppc_has_cap_mmu_radix() && kvmppc_has_cap_mmu_hash_v3()) {\n\n            val[3] = 0x80; /* OV5_MMU_BOTH */\n\n        } else if (kvmppc_has_cap_mmu_radix()) {\n\n            val[3] = 0x40; /* OV5_MMU_RADIX_300 */\n\n        } else {\n\n            val[3] = 0x00; /* Hash */\n\n        }\n\n    } else {\n\n        if (first_ppc_cpu->env.mmu_model & POWERPC_MMU_V3) {\n\n            /* V3 MMU supports both hash and radix (with dynamic switching) */\n\n            val[3] = 0xC0;\n\n        } else {\n\n            /* Otherwise we can only do hash */\n\n            val[3] = 0x00;\n\n        }\n\n    }\n\n    _FDT(fdt_setprop(fdt, chosen, \"ibm,arch-vec-5-platform-support\",\n\n                     val, sizeof(val)));\n\n}\n", "idx": 23777}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "    vmstate_get_subsection(const VMStateSubsection *sub, char *idstr)\n\n{\n\n    while (sub && sub->needed) {\n\n        if (strcmp(idstr, sub->vmsd->name) == 0) {\n\n            return sub->vmsd;\n\n        }\n\n        sub++;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 23778}
{"project": "qemu", "commit_id": "be18b2b53ebbf2eb3f00e7890d0b9ff8b58d22bf", "target": 1, "func": "int ppc_hash64_handle_mmu_fault(PowerPCCPU *cpu, target_ulong eaddr,\n\n                                int rwx, int mmu_idx)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUPPCState *env = &cpu->env;\n\n    ppc_slb_t *slb;\n\n    hwaddr pte_offset;\n\n    ppc_hash_pte64_t pte;\n\n    int pp_prot, amr_prot, prot;\n\n    uint64_t new_pte1;\n\n    const int need_prot[] = {PAGE_READ, PAGE_WRITE, PAGE_EXEC};\n\n    hwaddr raddr;\n\n\n\n    assert((rwx == 0) || (rwx == 1) || (rwx == 2));\n\n\n\n    /* 1. Handle real mode accesses */\n\n    if (((rwx == 2) && (msr_ir == 0)) || ((rwx != 2) && (msr_dr == 0))) {\n\n        /* Translation is off */\n\n        /* In real mode the top 4 effective address bits are ignored */\n\n        raddr = eaddr & 0x0FFFFFFFFFFFFFFFULL;\n\n        tlb_set_page(cs, eaddr & TARGET_PAGE_MASK, raddr & TARGET_PAGE_MASK,\n\n                     PAGE_READ | PAGE_WRITE | PAGE_EXEC, mmu_idx,\n\n                     TARGET_PAGE_SIZE);\n\n        return 0;\n\n    }\n\n\n\n    /* 2. Translation is on, so look up the SLB */\n\n    slb = slb_lookup(cpu, eaddr);\n\n\n\n    if (!slb) {\n\n        if (rwx == 2) {\n\n            cs->exception_index = POWERPC_EXCP_ISEG;\n\n            env->error_code = 0;\n\n        } else {\n\n            cs->exception_index = POWERPC_EXCP_DSEG;\n\n            env->error_code = 0;\n\n            env->spr[SPR_DAR] = eaddr;\n\n        }\n\n        return 1;\n\n    }\n\n\n\n    /* 3. Check for segment level no-execute violation */\n\n    if ((rwx == 2) && (slb->vsid & SLB_VSID_N)) {\n\n        cs->exception_index = POWERPC_EXCP_ISI;\n\n        env->error_code = 0x10000000;\n\n        return 1;\n\n    }\n\n\n\n    /* 4. Locate the PTE in the hash table */\n\n    pte_offset = ppc_hash64_htab_lookup(cpu, slb, eaddr, &pte);\n\n    if (pte_offset == -1) {\n\n        if (rwx == 2) {\n\n            cs->exception_index = POWERPC_EXCP_ISI;\n\n            env->error_code = 0x40000000;\n\n        } else {\n\n            cs->exception_index = POWERPC_EXCP_DSI;\n\n            env->error_code = 0;\n\n            env->spr[SPR_DAR] = eaddr;\n\n            if (rwx == 1) {\n\n                env->spr[SPR_DSISR] = 0x42000000;\n\n            } else {\n\n                env->spr[SPR_DSISR] = 0x40000000;\n\n            }\n\n        }\n\n        return 1;\n\n    }\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n                \"found PTE at offset %08\" HWADDR_PRIx \"\\n\", pte_offset);\n\n\n\n    /* 5. Check access permissions */\n\n\n\n    pp_prot = ppc_hash64_pte_prot(cpu, slb, pte);\n\n    amr_prot = ppc_hash64_amr_prot(cpu, pte);\n\n    prot = pp_prot & amr_prot;\n\n\n\n    if ((need_prot[rwx] & ~prot) != 0) {\n\n        /* Access right violation */\n\n        qemu_log_mask(CPU_LOG_MMU, \"PTE access rejected\\n\");\n\n        if (rwx == 2) {\n\n            cs->exception_index = POWERPC_EXCP_ISI;\n\n            env->error_code = 0x08000000;\n\n        } else {\n\n            target_ulong dsisr = 0;\n\n\n\n            cs->exception_index = POWERPC_EXCP_DSI;\n\n            env->error_code = 0;\n\n            env->spr[SPR_DAR] = eaddr;\n\n            if (need_prot[rwx] & ~pp_prot) {\n\n                dsisr |= 0x08000000;\n\n            }\n\n            if (rwx == 1) {\n\n                dsisr |= 0x02000000;\n\n            }\n\n            if (need_prot[rwx] & ~amr_prot) {\n\n                dsisr |= 0x00200000;\n\n            }\n\n            env->spr[SPR_DSISR] = dsisr;\n\n        }\n\n        return 1;\n\n    }\n\n\n\n    qemu_log_mask(CPU_LOG_MMU, \"PTE access granted !\\n\");\n\n\n\n    /* 6. Update PTE referenced and changed bits if necessary */\n\n\n\n    new_pte1 = pte.pte1 | HPTE64_R_R; /* set referenced bit */\n\n    if (rwx == 1) {\n\n        new_pte1 |= HPTE64_R_C; /* set changed (dirty) bit */\n\n    } else {\n\n        /* Treat the page as read-only for now, so that a later write\n\n         * will pass through this function again to set the C bit */\n\n        prot &= ~PAGE_WRITE;\n\n    }\n\n\n\n    if (new_pte1 != pte.pte1) {\n\n        ppc_hash64_store_hpte(cpu, pte_offset / HASH_PTE_SIZE_64,\n\n                              pte.pte0, new_pte1);\n\n    }\n\n\n\n    /* 7. Determine the real address from the PTE */\n\n\n\n    raddr = deposit64(pte.pte1 & HPTE64_R_RPN, 0, slb->sps->page_shift, eaddr);\n\n\n\n    tlb_set_page(cs, eaddr & TARGET_PAGE_MASK, raddr & TARGET_PAGE_MASK,\n\n                 prot, mmu_idx, TARGET_PAGE_SIZE);\n\n\n\n    return 0;\n\n}\n", "idx": 23779}
{"project": "qemu", "commit_id": "cc60e327c0988a5e5288cf7bb78cd9848db800ab", "target": 1, "func": "static int img_rebase(int argc, char **argv)\n\n{\n\n    BlockDriverState *bs, *bs_old_backing, *bs_new_backing;\n\n    BlockDriver *old_backing_drv, *new_backing_drv;\n\n    char *filename;\n\n    const char *fmt, *out_basefmt, *out_baseimg;\n\n    int c, flags, ret;\n\n    int unsafe = 0;\n\n\n\n    /* Parse commandline parameters */\n\n    fmt = NULL;\n\n    out_baseimg = NULL;\n\n    out_basefmt = NULL;\n\n\n\n    for(;;) {\n\n        c = getopt(argc, argv, \"uhf:F:b:\");\n\n        if (c == -1)\n\n            break;\n\n        switch(c) {\n\n        case 'h':\n\n            help();\n\n            return 0;\n\n        case 'f':\n\n            fmt = optarg;\n\n            break;\n\n        case 'F':\n\n            out_basefmt = optarg;\n\n            break;\n\n        case 'b':\n\n            out_baseimg = optarg;\n\n            break;\n\n        case 'u':\n\n            unsafe = 1;\n\n            break;\n\n        }\n\n    }\n\n\n\n    if ((optind >= argc) || !out_baseimg)\n\n        help();\n\n    filename = argv[optind++];\n\n\n\n    /*\n\n     * Open the images.\n\n     *\n\n     * Ignore the old backing file for unsafe rebase in case we want to correct\n\n     * the reference to a renamed or moved backing file.\n\n     */\n\n    flags = BDRV_O_FLAGS | BDRV_O_RDWR | (unsafe ? BDRV_O_NO_BACKING : 0);\n\n    bs = bdrv_new_open(filename, fmt, flags);\n\n\n\n    /* Find the right drivers for the backing files */\n\n    old_backing_drv = NULL;\n\n    new_backing_drv = NULL;\n\n\n\n    if (!unsafe && bs->backing_format[0] != '\\0') {\n\n        old_backing_drv = bdrv_find_format(bs->backing_format);\n\n        if (old_backing_drv == NULL) {\n\n            error(\"Invalid format name: '%s'\", bs->backing_format);\n\n        }\n\n    }\n\n\n\n    if (out_basefmt != NULL) {\n\n        new_backing_drv = bdrv_find_format(out_basefmt);\n\n        if (new_backing_drv == NULL) {\n\n            error(\"Invalid format name: '%s'\", out_basefmt);\n\n        }\n\n    }\n\n\n\n    /* For safe rebasing we need to compare old and new backing file */\n\n    if (unsafe) {\n\n        /* Make the compiler happy */\n\n        bs_old_backing = NULL;\n\n        bs_new_backing = NULL;\n\n    } else {\n\n        char backing_name[1024];\n\n\n\n        bs_old_backing = bdrv_new(\"old_backing\");\n\n        bdrv_get_backing_filename(bs, backing_name, sizeof(backing_name));\n\n        if (bdrv_open(bs_old_backing, backing_name, BDRV_O_FLAGS,\n\n            old_backing_drv))\n\n        {\n\n            error(\"Could not open old backing file '%s'\", backing_name);\n\n            return -1;\n\n        }\n\n\n\n        bs_new_backing = bdrv_new(\"new_backing\");\n\n        if (bdrv_open(bs_new_backing, out_baseimg, BDRV_O_FLAGS | BDRV_O_RDWR,\n\n            new_backing_drv))\n\n        {\n\n            error(\"Could not open new backing file '%s'\", out_baseimg);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /*\n\n     * Check each unallocated cluster in the COW file. If it is unallocated,\n\n     * accesses go to the backing file. We must therefore compare this cluster\n\n     * in the old and new backing file, and if they differ we need to copy it\n\n     * from the old backing file into the COW file.\n\n     *\n\n     * If qemu-img crashes during this step, no harm is done. The content of\n\n     * the image is the same as the original one at any time.\n\n     */\n\n    if (!unsafe) {\n\n        uint64_t num_sectors;\n\n        uint64_t sector;\n\n        int n, n1;\n\n        uint8_t * buf_old;\n\n        uint8_t * buf_new;\n\n\n\n        buf_old = qemu_malloc(IO_BUF_SIZE);\n\n        buf_new = qemu_malloc(IO_BUF_SIZE);\n\n\n\n        bdrv_get_geometry(bs, &num_sectors);\n\n\n\n        for (sector = 0; sector < num_sectors; sector += n) {\n\n\n\n            /* How many sectors can we handle with the next read? */\n\n            if (sector + (IO_BUF_SIZE / 512) <= num_sectors) {\n\n                n = (IO_BUF_SIZE / 512);\n\n            } else {\n\n                n = num_sectors - sector;\n\n            }\n\n\n\n            /* If the cluster is allocated, we don't need to take action */\n\n            if (bdrv_is_allocated(bs, sector, n, &n1)) {\n\n                n = n1;\n\n                continue;\n\n            }\n\n\n\n            /* Read old and new backing file */\n\n            if (bdrv_read(bs_old_backing, sector, buf_old, n) < 0) {\n\n                error(\"error while reading from old backing file\");\n\n            }\n\n            if (bdrv_read(bs_new_backing, sector, buf_new, n) < 0) {\n\n                error(\"error while reading from new backing file\");\n\n            }\n\n\n\n            /* If they differ, we need to write to the COW file */\n\n            uint64_t written = 0;\n\n\n\n            while (written < n) {\n\n                int pnum;\n\n\n\n                if (compare_sectors(buf_old + written * 512,\n\n                    buf_new + written * 512, n - written, &pnum))\n\n                {\n\n                    ret = bdrv_write(bs, sector + written,\n\n                        buf_old + written * 512, pnum);\n\n                    if (ret < 0) {\n\n                        error(\"Error while writing to COW image: %s\",\n\n                            strerror(-ret));\n\n                    }\n\n                }\n\n\n\n                written += pnum;\n\n            }\n\n        }\n\n\n\n        qemu_free(buf_old);\n\n        qemu_free(buf_new);\n\n    }\n\n\n\n    /*\n\n     * Change the backing file. All clusters that are different from the old\n\n     * backing file are overwritten in the COW file now, so the visible content\n\n     * doesn't change when we switch the backing file.\n\n     */\n\n    ret = bdrv_change_backing_file(bs, out_baseimg, out_basefmt);\n\n    if (ret == -ENOSPC) {\n\n        error(\"Could not change the backing file to '%s': No space left in \"\n\n            \"the file header\", out_baseimg);\n\n    } else if (ret < 0) {\n\n        error(\"Could not change the backing file to '%s': %s\",\n\n            out_baseimg, strerror(-ret));\n\n    }\n\n\n\n    /*\n\n     * TODO At this point it is possible to check if any clusters that are\n\n     * allocated in the COW file are the same in the backing file. If so, they\n\n     * could be dropped from the COW file. Don't do this before switching the\n\n     * backing file, in case of a crash this would lead to corruption.\n\n     */\n\n\n\n    /* Cleanup */\n\n    if (!unsafe) {\n\n        bdrv_delete(bs_old_backing);\n\n        bdrv_delete(bs_new_backing);\n\n    }\n\n\n\n    bdrv_delete(bs);\n\n\n\n    return 0;\n\n}\n", "idx": 23782}
{"project": "qemu", "commit_id": "99577c492fb2916165ed9bc215f058877f0a4106", "target": 1, "func": "static void s390_ccw_realize(S390CCWDevice *cdev, char *sysfsdev, Error **errp)\n\n{\n\n    CcwDevice *ccw_dev = CCW_DEVICE(cdev);\n\n    CCWDeviceClass *ck = CCW_DEVICE_GET_CLASS(ccw_dev);\n\n    DeviceState *parent = DEVICE(ccw_dev);\n\n    BusState *qbus = qdev_get_parent_bus(parent);\n\n    VirtualCssBus *cbus = VIRTUAL_CSS_BUS(qbus);\n\n    SubchDev *sch;\n\n    int ret;\n\n    Error *err = NULL;\n\n\n\n    s390_ccw_get_dev_info(cdev, sysfsdev, &err);\n\n    if (err) {\n\n        goto out_err_propagate;\n\n    }\n\n\n\n    sch = css_create_sch(ccw_dev->devno, false, cbus->squash_mcss, &err);\n\n    if (!sch) {\n\n        goto out_mdevid_free;\n\n    }\n\n    sch->driver_data = cdev;\n\n    sch->do_subchannel_work = do_subchannel_work_passthrough;\n\n\n\n    ccw_dev->sch = sch;\n\n    ret = css_sch_build_schib(sch, &cdev->hostid);\n\n    if (ret) {\n\n        error_setg_errno(&err, -ret, \"%s: Failed to build initial schib\",\n\n                         __func__);\n\n        goto out_err;\n\n    }\n\n\n\n    ck->realize(ccw_dev, &err);\n\n    if (err) {\n\n        goto out_err;\n\n    }\n\n\n\n    css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,\n\n                          parent->hotplugged, 1);\n\n    return;\n\n\n\nout_err:\n\n    css_subch_assign(sch->cssid, sch->ssid, sch->schid, sch->devno, NULL);\n\n    ccw_dev->sch = NULL;\n\n    g_free(sch);\n\nout_mdevid_free:\n\n    g_free(cdev->mdevid);\n\nout_err_propagate:\n\n    error_propagate(errp, err);\n\n}\n", "idx": 23785}
{"project": "qemu", "commit_id": "d9631b90da6ac592ea76b41a654dd5d29b2645d4", "target": 1, "func": "static void build_pci_bus_end(PCIBus *bus, void *bus_state)\n\n{\n\n    AcpiBuildPciBusHotplugState *child = bus_state;\n\n    AcpiBuildPciBusHotplugState *parent = child->parent;\n\n    GArray *bus_table = build_alloc_array();\n\n    DECLARE_BITMAP(slot_hotplug_enable, PCI_SLOT_MAX);\n\n    DECLARE_BITMAP(slot_device_present, PCI_SLOT_MAX);\n\n    DECLARE_BITMAP(slot_device_system, PCI_SLOT_MAX);\n\n    DECLARE_BITMAP(slot_device_vga, PCI_SLOT_MAX);\n\n    DECLARE_BITMAP(slot_device_qxl, PCI_SLOT_MAX);\n\n    uint8_t op;\n\n    int i;\n\n    QObject *bsel;\n\n    GArray *method;\n\n    bool bus_hotplug_support = false;\n\n\n\n    if (bus->parent_dev) {\n\n        op = 0x82; /* DeviceOp */\n\n        build_append_nameseg(bus_table, \"S%.02X_\",\n\n                             bus->parent_dev->devfn);\n\n        build_append_byte(bus_table, 0x08); /* NameOp */\n\n        build_append_nameseg(bus_table, \"_SUN\");\n\n        build_append_value(bus_table, PCI_SLOT(bus->parent_dev->devfn), 1);\n\n        build_append_byte(bus_table, 0x08); /* NameOp */\n\n        build_append_nameseg(bus_table, \"_ADR\");\n\n        build_append_value(bus_table, (PCI_SLOT(bus->parent_dev->devfn) << 16) |\n\n                           PCI_FUNC(bus->parent_dev->devfn), 4);\n\n    } else {\n\n        op = 0x10; /* ScopeOp */;\n\n        build_append_nameseg(bus_table, \"PCI0\");\n\n    }\n\n\n\n    bsel = object_property_get_qobject(OBJECT(bus), ACPI_PCIHP_PROP_BSEL, NULL);\n\n    if (bsel) {\n\n        build_append_byte(bus_table, 0x08); /* NameOp */\n\n        build_append_nameseg(bus_table, \"BSEL\");\n\n        build_append_int(bus_table, qint_get_int(qobject_to_qint(bsel)));\n\n        memset(slot_hotplug_enable, 0xff, sizeof slot_hotplug_enable);\n\n    } else {\n\n        /* No bsel - no slots are hot-pluggable */\n\n        memset(slot_hotplug_enable, 0x00, sizeof slot_hotplug_enable);\n\n    }\n\n\n\n    memset(slot_device_present, 0x00, sizeof slot_device_present);\n\n    memset(slot_device_system, 0x00, sizeof slot_device_present);\n\n    memset(slot_device_vga, 0x00, sizeof slot_device_vga);\n\n    memset(slot_device_qxl, 0x00, sizeof slot_device_qxl);\n\n\n\n    for (i = 0; i < ARRAY_SIZE(bus->devices); i += PCI_FUNC_MAX) {\n\n        DeviceClass *dc;\n\n        PCIDeviceClass *pc;\n\n        PCIDevice *pdev = bus->devices[i];\n\n        int slot = PCI_SLOT(i);\n\n\n\n        if (!pdev) {\n\n            continue;\n\n        }\n\n\n\n        set_bit(slot, slot_device_present);\n\n        pc = PCI_DEVICE_GET_CLASS(pdev);\n\n        dc = DEVICE_GET_CLASS(pdev);\n\n\n\n        if (pc->class_id == PCI_CLASS_BRIDGE_ISA) {\n\n            set_bit(slot, slot_device_system);\n\n        }\n\n\n\n        if (pc->class_id == PCI_CLASS_DISPLAY_VGA) {\n\n            set_bit(slot, slot_device_vga);\n\n\n\n            if (object_dynamic_cast(OBJECT(pdev), \"qxl-vga\")) {\n\n                set_bit(slot, slot_device_qxl);\n\n            }\n\n        }\n\n\n\n        if (!dc->hotpluggable || pc->is_bridge) {\n\n            clear_bit(slot, slot_hotplug_enable);\n\n        }\n\n    }\n\n\n\n    /* Append Device object for each slot */\n\n    for (i = 0; i < PCI_SLOT_MAX; i++) {\n\n        bool can_eject = test_bit(i, slot_hotplug_enable);\n\n        bool present = test_bit(i, slot_device_present);\n\n        bool vga = test_bit(i, slot_device_vga);\n\n        bool qxl = test_bit(i, slot_device_qxl);\n\n        bool system = test_bit(i, slot_device_system);\n\n        if (can_eject) {\n\n            void *pcihp = acpi_data_push(bus_table,\n\n                                         ACPI_PCIHP_SIZEOF);\n\n            memcpy(pcihp, ACPI_PCIHP_AML, ACPI_PCIHP_SIZEOF);\n\n            patch_pcihp(i, pcihp);\n\n            bus_hotplug_support = true;\n\n        } else if (qxl) {\n\n            void *pcihp = acpi_data_push(bus_table,\n\n                                         ACPI_PCIQXL_SIZEOF);\n\n            memcpy(pcihp, ACPI_PCIQXL_AML, ACPI_PCIQXL_SIZEOF);\n\n            patch_pciqxl(i, pcihp);\n\n        } else if (vga) {\n\n            void *pcihp = acpi_data_push(bus_table,\n\n                                         ACPI_PCIVGA_SIZEOF);\n\n            memcpy(pcihp, ACPI_PCIVGA_AML, ACPI_PCIVGA_SIZEOF);\n\n            patch_pcivga(i, pcihp);\n\n        } else if (system) {\n\n            /* Nothing to do: system devices are in DSDT. */\n\n        } else if (present) {\n\n            void *pcihp = acpi_data_push(bus_table,\n\n                                         ACPI_PCINOHP_SIZEOF);\n\n            memcpy(pcihp, ACPI_PCINOHP_AML, ACPI_PCINOHP_SIZEOF);\n\n            patch_pcinohp(i, pcihp);\n\n        }\n\n    }\n\n\n\n    if (bsel) {\n\n        method = build_alloc_method(\"DVNT\", 2);\n\n\n\n        for (i = 0; i < PCI_SLOT_MAX; i++) {\n\n            GArray *notify;\n\n            uint8_t op;\n\n\n\n            if (!test_bit(i, slot_hotplug_enable)) {\n\n                continue;\n\n            }\n\n\n\n            notify = build_alloc_array();\n\n            op = 0xA0; /* IfOp */\n\n\n\n            build_append_byte(notify, 0x7B); /* AndOp */\n\n            build_append_byte(notify, 0x68); /* Arg0Op */\n\n            build_append_int(notify, 0x1 << i);\n\n            build_append_byte(notify, 0x00); /* NullName */\n\n            build_append_byte(notify, 0x86); /* NotifyOp */\n\n            build_append_nameseg(notify, \"S%.02X_\", PCI_DEVFN(i, 0));\n\n            build_append_byte(notify, 0x69); /* Arg1Op */\n\n\n\n            /* Pack it up */\n\n            build_package(notify, op, 0);\n\n\n\n            build_append_array(method, notify);\n\n\n\n            build_free_array(notify);\n\n        }\n\n\n\n        build_append_and_cleanup_method(bus_table, method);\n\n    }\n\n\n\n    /* Append PCNT method to notify about events on local and child buses.\n\n     * Add unconditionally for root since DSDT expects it.\n\n     */\n\n    if (bus_hotplug_support || child->notify_table->len || !bus->parent_dev) {\n\n        method = build_alloc_method(\"PCNT\", 0);\n\n\n\n        /* If bus supports hotplug select it and notify about local events */\n\n        if (bsel) {\n\n            build_append_byte(method, 0x70); /* StoreOp */\n\n            build_append_int(method, qint_get_int(qobject_to_qint(bsel)));\n\n            build_append_nameseg(method, \"BNUM\");\n\n            build_append_nameseg(method, \"DVNT\");\n\n            build_append_nameseg(method, \"PCIU\");\n\n            build_append_int(method, 1); /* Device Check */\n\n            build_append_nameseg(method, \"DVNT\");\n\n            build_append_nameseg(method, \"PCID\");\n\n            build_append_int(method, 3); /* Eject Request */\n\n        }\n\n\n\n        /* Notify about child bus events in any case */\n\n        build_append_array(method, child->notify_table);\n\n\n\n        build_append_and_cleanup_method(bus_table, method);\n\n\n\n        /* Append description of child buses */\n\n        build_append_array(bus_table, child->device_table);\n\n\n\n        /* Pack it up */\n\n        if (bus->parent_dev) {\n\n            build_extop_package(bus_table, op);\n\n        } else {\n\n            build_package(bus_table, op, 0);\n\n        }\n\n\n\n        /* Append our bus description to parent table */\n\n        build_append_array(parent->device_table, bus_table);\n\n\n\n        /* Also tell parent how to notify us, invoking PCNT method.\n\n         * At the moment this is not needed for root as we have a single root.\n\n         */\n\n        if (bus->parent_dev) {\n\n            build_append_byte(parent->notify_table, '^'); /* ParentPrefixChar */\n\n            build_append_byte(parent->notify_table, 0x2E); /* DualNamePrefix */\n\n            build_append_nameseg(parent->notify_table, \"S%.02X_\",\n\n                                 bus->parent_dev->devfn);\n\n            build_append_nameseg(parent->notify_table, \"PCNT\");\n\n        }\n\n    }\n\n\n\n    build_free_array(bus_table);\n\n    build_pci_bus_state_cleanup(child);\n\n    g_free(child);\n\n}\n", "idx": 23787}
{"project": "qemu", "commit_id": "8786db7cb96f8ce5c75c6e1e074319c9dca8d356", "target": 1, "func": "void memory_region_sync_dirty_bitmap(MemoryRegion *mr)\n\n{\n\n    FlatRange *fr;\n\n\n\n    FOR_EACH_FLAT_RANGE(fr, &address_space_memory.current_map) {\n\n        if (fr->mr == mr) {\n\n            MEMORY_LISTENER_UPDATE_REGION(fr, &address_space_memory,\n\n                                          Forward, log_sync);\n\n        }\n\n    }\n\n}\n", "idx": 23788}
{"project": "qemu", "commit_id": "b544c1aba8681c2fe5d6715fbd37cf6caf1bc7bb", "target": 1, "func": "static void coroutine_fn resend_aioreq(BDRVSheepdogState *s, AIOReq *aio_req)\n\n{\n\n    SheepdogAIOCB *acb = aio_req->aiocb;\n\n    bool create = false;\n\n\n\n    /* check whether this request becomes a CoW one */\n\n    if (acb->aiocb_type == AIOCB_WRITE_UDATA && is_data_obj(aio_req->oid)) {\n\n        int idx = data_oid_to_idx(aio_req->oid);\n\n\n\n        if (is_data_obj_writable(&s->inode, idx)) {\n\n            goto out;\n\n        }\n\n\n\n        if (check_simultaneous_create(s, aio_req)) {\n\n            return;\n\n        }\n\n\n\n        if (s->inode.data_vdi_id[idx]) {\n\n            aio_req->base_oid = vid_to_data_oid(s->inode.data_vdi_id[idx], idx);\n\n            aio_req->flags |= SD_FLAG_CMD_COW;\n\n        }\n\n        create = true;\n\n    }\n\nout:\n\n    if (is_data_obj(aio_req->oid)) {\n\n        add_aio_request(s, aio_req, acb->qiov->iov, acb->qiov->niov, create,\n\n                        acb->aiocb_type);\n\n    } else {\n\n        struct iovec iov;\n\n        iov.iov_base = &s->inode;\n\n        iov.iov_len = sizeof(s->inode);\n\n        add_aio_request(s, aio_req, &iov, 1, false, AIOCB_WRITE_UDATA);\n\n    }\n\n}\n", "idx": 23789}
{"project": "qemu", "commit_id": "73a8912b8aeed1c992e3f9cb4880e9d1edb935de", "target": 1, "func": "static void *do_data_decompress(void *opaque)\n\n{\n\n    DecompressParam *param = opaque;\n\n    unsigned long pagesize;\n\n\n\n    while (!quit_decomp_thread) {\n\n        qemu_mutex_lock(&param->mutex);\n\n        while (!param->start && !quit_decomp_thread) {\n\n            qemu_cond_wait(&param->cond, &param->mutex);\n\n            pagesize = TARGET_PAGE_SIZE;\n\n            if (!quit_decomp_thread) {\n\n                /* uncompress() will return failed in some case, especially\n\n                 * when the page is dirted when doing the compression, it's\n\n                 * not a problem because the dirty page will be retransferred\n\n                 * and uncompress() won't break the data in other pages.\n\n                 */\n\n                uncompress((Bytef *)param->des, &pagesize,\n\n                           (const Bytef *)param->compbuf, param->len);\n\n            }\n\n            param->start = false;\n\n        }\n\n        qemu_mutex_unlock(&param->mutex);\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 23790}
{"project": "qemu", "commit_id": "b45c03f585ea9bb1af76c73e82195418c294919d", "target": 1, "func": "struct omap_mmc_s *omap_mmc_init(hwaddr base,\n\n                MemoryRegion *sysmem,\n\n                BlockBackend *blk,\n\n                qemu_irq irq, qemu_irq dma[], omap_clk clk)\n\n{\n\n    struct omap_mmc_s *s = (struct omap_mmc_s *)\n\n            g_malloc0(sizeof(struct omap_mmc_s));\n\n\n\n    s->irq = irq;\n\n    s->dma = dma;\n\n    s->clk = clk;\n\n    s->lines = 1;\t/* TODO: needs to be settable per-board */\n\n    s->rev = 1;\n\n\n\n    omap_mmc_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, \"omap.mmc\", 0x800);\n\n    memory_region_add_subregion(sysmem, base, &s->iomem);\n\n\n\n    /* Instantiate the storage */\n\n    s->card = sd_init(blk, false);\n\n    if (s->card == NULL) {\n\n        exit(1);\n\n    }\n\n\n\n    return s;\n\n}\n", "idx": 23800}
{"project": "qemu", "commit_id": "340065e5a11a515382c8b1112424c97e86ad2a3f", "target": 1, "func": "static void pc_machine_class_init(ObjectClass *oc, void *data)\n\n{\n\n    MachineClass *mc = MACHINE_CLASS(oc);\n\n    PCMachineClass *pcmc = PC_MACHINE_CLASS(oc);\n\n    HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(oc);\n\n\n\n    pcmc->inter_dimm_gap = true;\n\n    pcmc->get_hotplug_handler = mc->get_hotplug_handler;\n\n    mc->get_hotplug_handler = pc_get_hotpug_handler;\n\n    mc->cpu_index_to_socket_id = pc_cpu_index_to_socket_id;\n\n    mc->default_boot_order = \"cad\";\n\n    mc->hot_add_cpu = pc_hot_add_cpu;\n\n    mc->max_cpus = 255;\n\n    mc->reset = pc_machine_reset;\n\n    hc->plug = pc_machine_device_plug_cb;\n\n    hc->unplug_request = pc_machine_device_unplug_request_cb;\n\n    hc->unplug = pc_machine_device_unplug_cb;\n\n}\n", "idx": 23803}
{"project": "qemu", "commit_id": "11b7b07f8a15879134a54e73fade98d5e11e04f8", "target": 1, "func": "static void test_none(void)\n\n{\n\n    struct qdist dist;\n\n    char *pr;\n\n\n\n    qdist_init(&dist);\n\n\n\n    g_assert(isnan(qdist_avg(&dist)));\n\n    g_assert(isnan(qdist_xmin(&dist)));\n\n    g_assert(isnan(qdist_xmax(&dist)));\n\n\n\n    pr = qdist_pr_plain(&dist, 0);\n\n    g_assert(pr == NULL);\n\n\n\n    pr = qdist_pr_plain(&dist, 2);\n\n    g_assert(pr == NULL);\n\n\n\n    qdist_destroy(&dist);\n\n}\n", "idx": 23804}
{"project": "qemu", "commit_id": "3d3efba020da1de57a715e2087cf761ed0ad0904", "target": 1, "func": "void process_pending_signals(CPUArchState *cpu_env)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(cpu_env);\n\n    int sig;\n\n    TaskState *ts = cpu->opaque;\n\n\n\n    if (!ts->signal_pending)\n\n        return;\n\n\n\n    /* FIXME: This is not threadsafe.  */\n\n    for(sig = 1; sig <= TARGET_NSIG; sig++) {\n\n        if (ts->sigtab[sig - 1].pending) {\n\n            handle_pending_signal(cpu_env, sig);\n\n            return;\n\n        }\n\n    }\n\n    /* if no signal is pending, just return */\n\n    ts->signal_pending = 0;\n\n    return;\n\n}\n", "idx": 23805}
{"project": "qemu", "commit_id": "599d0c45615b7d099d256738a586d0f63bc707e6", "target": 1, "func": "static int xen_host_pci_sysfs_path(const XenHostPCIDevice *d,\n\n                                   const char *name, char *buf, ssize_t size)\n\n{\n\n    int rc;\n\n\n\n    rc = snprintf(buf, size, \"/sys/bus/pci/devices/%04x:%02x:%02x.%d/%s\",\n\n                  d->domain, d->bus, d->dev, d->func, name);\n\n\n\n    if (rc >= size || rc < 0) {\n\n        /* The output is truncated, or some other error was encountered */\n\n        return -ENODEV;\n\n    }\n\n    return 0;\n\n}\n", "idx": 23806}
{"project": "qemu", "commit_id": "fb8b273579eaa1e6cee4017e4b23104e17a36f07", "target": 1, "func": "ram_addr_t qemu_ram_alloc_from_ptr(DeviceState *dev, const char *name,\n\n                                   ram_addr_t size, void *host)\n\n{\n\n    RAMBlock *new_block, *block;\n\n\n\n    size = TARGET_PAGE_ALIGN(size);\n\n    new_block = qemu_mallocz(sizeof(*new_block));\n\n\n\n    if (dev && dev->parent_bus && dev->parent_bus->info->get_dev_path) {\n\n        char *id = dev->parent_bus->info->get_dev_path(dev);\n\n        if (id) {\n\n            snprintf(new_block->idstr, sizeof(new_block->idstr), \"%s/\", id);\n\n            qemu_free(id);\n\n\n\n    pstrcat(new_block->idstr, sizeof(new_block->idstr), name);\n\n\n\n    QLIST_FOREACH(block, &ram_list.blocks, next) {\n\n        if (!strcmp(block->idstr, new_block->idstr)) {\n\n            fprintf(stderr, \"RAMBlock \\\"%s\\\" already registered, abort!\\n\",\n\n                    new_block->idstr);\n\n\n\n\n\n\n    new_block->offset = find_ram_offset(size);\n\n    if (host) {\n\n        new_block->host = host;\n\n        new_block->flags |= RAM_PREALLOC_MASK;\n\n    } else {\n\n        if (mem_path) {\n\n#if defined (__linux__) && !defined(TARGET_S390X)\n\n            new_block->host = file_ram_alloc(new_block, size, mem_path);\n\n            if (!new_block->host) {\n\n                new_block->host = qemu_vmalloc(size);\n\n                qemu_madvise(new_block->host, size, QEMU_MADV_MERGEABLE);\n\n\n#else\n\n            fprintf(stderr, \"-mem-path option unsupported\\n\");\n\n            exit(1);\n\n#endif\n\n        } else {\n\n#if defined(TARGET_S390X) && defined(CONFIG_KVM)\n\n            /* S390 KVM requires the topmost vma of the RAM to be smaller than\n\n               an system defined value, which is at least 256GB. Larger systems\n\n               have larger values. We put the guest between the end of data\n\n               segment (system break) and this value. We use 32GB as a base to\n\n               have enough room for the system break to grow. */\n\n            new_block->host = mmap((void*)0x800000000, size,\n\n                                   PROT_EXEC|PROT_READ|PROT_WRITE,\n\n                                   MAP_SHARED | MAP_ANONYMOUS | MAP_FIXED, -1, 0);\n\n\n\n\n\n#else\n\n            if (xen_mapcache_enabled()) {\n\n                xen_ram_alloc(new_block->offset, size);\n\n            } else {\n\n                new_block->host = qemu_vmalloc(size);\n\n\n#endif\n\n            qemu_madvise(new_block->host, size, QEMU_MADV_MERGEABLE);\n\n\n\n    new_block->length = size;\n\n\n\n    QLIST_INSERT_HEAD(&ram_list.blocks, new_block, next);\n\n\n\n    ram_list.phys_dirty = qemu_realloc(ram_list.phys_dirty,\n\n                                       last_ram_offset() >> TARGET_PAGE_BITS);\n\n    memset(ram_list.phys_dirty + (new_block->offset >> TARGET_PAGE_BITS),\n\n           0xff, size >> TARGET_PAGE_BITS);\n\n\n\n    if (kvm_enabled())\n\n        kvm_setup_guest_memory(new_block->host, size);\n\n\n\n    return new_block->offset;\n", "idx": 23807}
{"project": "qemu", "commit_id": "13289fb5a716e06fb06febb880e5e116d485f82b", "target": 1, "func": "char *qmp_memchar_read(const char *device, int64_t size,\n\n                       bool has_format, enum DataFormat format,\n\n                       Error **errp)\n\n{\n\n    CharDriverState *chr;\n\n    uint8_t *read_data;\n\n    size_t count;\n\n    char *data;\n\n\n\n    chr = qemu_chr_find(device);\n\n    if (!chr) {\n\n        error_setg(errp, \"Device '%s' not found\", device);\n\n        return NULL;\n\n    }\n\n\n\n    if (qemu_is_chr(chr, \"memory\")) {\n\n        error_setg(errp,\"%s is not memory char device\", device);\n\n        return NULL;\n\n    }\n\n\n\n    if (size <= 0) {\n\n        error_setg(errp, \"size must be greater than zero\");\n\n        return NULL;\n\n    }\n\n\n\n    count = qemu_chr_cirmem_count(chr);\n\n    if (count == 0) {\n\n        return g_strdup(\"\");\n\n    }\n\n\n\n    size = size > count ? count : size;\n\n    read_data = g_malloc0(size + 1);\n\n\n\n    cirmem_chr_read(chr, read_data, size);\n\n\n\n    if (has_format && (format == DATA_FORMAT_BASE64)) {\n\n        data = g_base64_encode(read_data, size);\n\n\n    } else {\n\n        data = (char *)read_data;\n\n    }\n\n\n\n    return data;\n\n}", "idx": 23808}
{"project": "qemu", "commit_id": "8be7e7e4c72c048b90e3482557954a24bba43ba7", "target": 1, "func": "QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)\n\n{\n\n    QemuOpts *opts;\n\n\n\n    opts = qemu_opts_create(list, qdict_get_try_str(qdict, \"id\"), 1);\n\n    if (opts == NULL)\n\n        return NULL;\n\n\n\n    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);\n\n    return opts;\n\n}\n", "idx": 23809}
{"project": "qemu", "commit_id": "27af7d6ea5015e5ef1f7985eab94a8a218267a2b", "target": 1, "func": "static void xbzrle_cache_zero_page(ram_addr_t current_addr)\n\n{\n\n    if (ram_bulk_stage || !migrate_use_xbzrle()) {\n\n        return;\n\n    }\n\n\n\n    /* We don't care if this fails to allocate a new cache page\n\n     * as long as it updated an old one */\n\n    cache_insert(XBZRLE.cache, current_addr, ZERO_TARGET_PAGE);\n\n}\n", "idx": 23810}
{"project": "qemu", "commit_id": "406bc339b0505fcfc2ffcbca1f05a3756e338a65", "target": 1, "func": "static void breakpoint_invalidate(CPUState *cpu, target_ulong pc)\n\n{\n\n    /* Flush the whole TB as this will not have race conditions\n\n     * even if we don't have proper locking yet.\n\n     * Ideally we would just invalidate the TBs for the\n\n     * specified PC.\n\n     */\n\n    tb_flush(cpu);\n\n}\n", "idx": 23811}
{"project": "qemu", "commit_id": "7c4228b4771acddcb8815079bc116007cec8a1ff", "target": 1, "func": "static void vfio_bar_quirk_teardown(VFIODevice *vdev, int nr)\n\n{\n\n    VFIOBAR *bar = &vdev->bars[nr];\n\n\n\n    while (!QLIST_EMPTY(&bar->quirks)) {\n\n        VFIOQuirk *quirk = QLIST_FIRST(&bar->quirks);\n\n        memory_region_del_subregion(&bar->mem, &quirk->mem);\n\n\n        QLIST_REMOVE(quirk, next);\n\n        g_free(quirk);\n\n    }\n\n}", "idx": 23812}
{"project": "qemu", "commit_id": "e634b89c6ed2309814de7a89bd7c5ced96f59291", "target": 0, "func": "static void spapr_populate_pci_devices_dt(PCIBus *bus, PCIDevice *pdev,\n\n                                          void *opaque)\n\n{\n\n    PCIBus *sec_bus;\n\n    sPAPRFDT *p = opaque;\n\n    int offset;\n\n    sPAPRFDT s_fdt;\n\n    uint32_t drc_index = spapr_phb_get_pci_drc_index(p->sphb, pdev);\n\n\n\n    offset = spapr_create_pci_child_dt(p->sphb, pdev,\n\n                                       drc_index, NULL,\n\n                                       p->fdt, p->node_off);\n\n    if (!offset) {\n\n        error_report(\"Failed to create pci child device tree node\");\n\n        return;\n\n    }\n\n\n\n    if ((pci_default_read_config(pdev, PCI_HEADER_TYPE, 1) !=\n\n         PCI_HEADER_TYPE_BRIDGE)) {\n\n        return;\n\n    }\n\n\n\n    sec_bus = pci_bridge_get_sec_bus(PCI_BRIDGE(pdev));\n\n    if (!sec_bus) {\n\n        return;\n\n    }\n\n\n\n    s_fdt.fdt = p->fdt;\n\n    s_fdt.node_off = offset;\n\n    s_fdt.sphb = p->sphb;\n\n    pci_for_each_device(sec_bus, pci_bus_num(sec_bus),\n\n                        spapr_populate_pci_devices_dt,\n\n                        &s_fdt);\n\n}\n", "idx": 23813}
{"project": "qemu", "commit_id": "2494c9f6405a1979319f12d1bb4e9a6eb28a529d", "target": 0, "func": "static void fifo_trigger_update(void *opaque)\n\n{\n\n    CadenceUARTState *s = opaque;\n\n\n\n    s->r[R_CISR] |= UART_INTR_TIMEOUT;\n\n\n\n    uart_update_status(s);\n\n}\n", "idx": 23814}
{"project": "qemu", "commit_id": "35c2c8dc8c0899882a8e0d349d93bd657772f1e7", "target": 0, "func": "const char *qemu_get_version(void)\n\n{\n\n    return qemu_version;\n\n}\n", "idx": 23815}
{"project": "qemu", "commit_id": "ad674e53b5cce265fadafbde2c6a4f190345cd00", "target": 0, "func": "static void conditional_branch(DBDMA_channel *ch)\n\n{\n\n    dbdma_cmd *current = &ch->current;\n\n    uint16_t br;\n\n    uint16_t sel_mask, sel_value;\n\n    uint32_t status;\n\n    int cond;\n\n\n\n    DBDMA_DPRINTF(\"conditional_branch\\n\");\n\n\n\n    /* check if we must branch */\n\n\n\n    br = le16_to_cpu(current->command) & BR_MASK;\n\n\n\n    switch(br) {\n\n    case BR_NEVER:  /* don't branch */\n\n        next(ch);\n\n        return;\n\n    case BR_ALWAYS: /* always branch */\n\n        branch(ch);\n\n        return;\n\n    }\n\n\n\n    status = be32_to_cpu(ch->regs[DBDMA_STATUS]) & DEVSTAT;\n\n\n\n    sel_mask = (be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) >> 16) & 0x0f;\n\n    sel_value = be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) & 0x0f;\n\n\n\n    cond = (status & sel_mask) == (sel_value & sel_mask);\n\n\n\n    switch(br) {\n\n    case BR_IFSET:  /* branch if condition bit is 1 */\n\n        if (cond)\n\n            branch(ch);\n\n        else\n\n            next(ch);\n\n        return;\n\n    case BR_IFCLR:  /* branch if condition bit is 0 */\n\n        if (!cond)\n\n            branch(ch);\n\n        else\n\n            next(ch);\n\n        return;\n\n    }\n\n}\n", "idx": 23816}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static int v9fs_synth_truncate(FsContext *ctx, V9fsPath *path, off_t offset)\n\n{\n\n    errno = ENOSYS;\n\n    return -1;\n\n}\n", "idx": 23817}
{"project": "qemu", "commit_id": "64d7e9a421fea0ac50b44541f5521de455e7cd5d", "target": 0, "func": "int pit_get_mode(PITState *pit, int channel)\n\n{\n\n    PITChannelState *s = &pit->channels[channel];\n\n    return s->mode;\n\n}\n", "idx": 23818}
{"project": "qemu", "commit_id": "ef76dc59fa5203d146a2acf85a0ad5a5971a4824", "target": 0, "func": "START_TEST(unterminated_sq_string)\n\n{\n\n    QObject *obj = qobject_from_json(\"'abc\");\n\n    fail_unless(obj == NULL);\n\n}\n", "idx": 23819}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void release_drive(Object *obj, const char *name, void *opaque)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop = opaque;\n\n    BlockDriverState **ptr = qdev_get_prop_ptr(dev, prop);\n\n\n\n    if (*ptr) {\n\n        bdrv_detach_dev(*ptr, dev);\n\n        blockdev_auto_del(*ptr);\n\n    }\n\n}\n", "idx": 23820}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_validate_fail_union_native_list(TestInputVisitorData *data,\n\n                                                 const void *unused)\n\n{\n\n    UserDefNativeListUnion *tmp = NULL;\n\n    Error *err = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data,\n\n                           \"{ 'type': 'integer', 'data' : [ 'string' ] }\");\n\n\n\n    visit_type_UserDefNativeListUnion(v, NULL, &tmp, &err);\n\n    error_free_or_abort(&err);\n\n    g_assert(!tmp);\n\n}\n", "idx": 23822}
{"project": "qemu", "commit_id": "d63cb48db9016328a7a69f3a1c2938cd3dfc9d1a", "target": 0, "func": "void store_booke_tsr (CPUState *env, target_ulong val)\n\n{\n\n    LOG_TB(\"%s: val \" TARGET_FMT_lx \"\\n\", __func__, val);\n\n    env->spr[SPR_40x_TSR] &= ~(val & 0xFC000000);\n\n    if (val & 0x80000000)\n\n        ppc_set_irq(env, PPC_INTERRUPT_PIT, 0);\n\n}\n", "idx": 23823}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "func": "static ssize_t local_readlink(FsContext *fs_ctx, V9fsPath *fs_path,\n\n                              char *buf, size_t bufsz)\n\n{\n\n    ssize_t tsize = -1;\n\n    char buffer[PATH_MAX];\n\n    char *path = fs_path->data;\n\n\n\n    if ((fs_ctx->export_flags & V9FS_SM_MAPPED) ||\n\n        (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE)) {\n\n        int fd;\n\n        fd = open(rpath(fs_ctx, path, buffer), O_RDONLY | O_NOFOLLOW);\n\n        if (fd == -1) {\n\n            return -1;\n\n        }\n\n        do {\n\n            tsize = read(fd, (void *)buf, bufsz);\n\n        } while (tsize == -1 && errno == EINTR);\n\n        close(fd);\n\n        return tsize;\n\n    } else if ((fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||\n\n               (fs_ctx->export_flags & V9FS_SM_NONE)) {\n\n        tsize = readlink(rpath(fs_ctx, path, buffer), buf, bufsz);\n\n    }\n\n    return tsize;\n\n}\n", "idx": 23824}
{"project": "qemu", "commit_id": "3e8522e23f6ab3c2b89ebb962ec4c2227d88aca6", "target": 0, "func": "static void pc_dimm_unplug(HotplugHandler *hotplug_dev,\n\n                           DeviceState *dev, Error **errp)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(hotplug_dev);\n\n    PCDIMMDevice *dimm = PC_DIMM(dev);\n\n    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(dimm);\n\n    MemoryRegion *mr = ddc->get_memory_region(dimm);\n\n    HotplugHandlerClass *hhc;\n\n    Error *local_err = NULL;\n\n\n\n    if (object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM)) {\n\n        error_setg(&local_err,\n\n                   \"nvdimm device hot unplug is not supported yet.\");\n\n        goto out;\n\n    }\n\n\n\n    hhc = HOTPLUG_HANDLER_GET_CLASS(pcms->acpi_dev);\n\n    hhc->unplug(HOTPLUG_HANDLER(pcms->acpi_dev), dev, &local_err);\n\n\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n\n\n    pc_dimm_memory_unplug(dev, &pcms->hotplug_memory, mr);\n\n    object_unparent(OBJECT(dev));\n\n\n\n out:\n\n    error_propagate(errp, local_err);\n\n}\n", "idx": 23825}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void pflash_cfi02_realize(DeviceState *dev, Error **errp)\n\n{\n\n    pflash_t *pfl = CFI_PFLASH02(dev);\n\n    uint32_t chip_len;\n\n    int ret;\n\n    Error *local_err = NULL;\n\n\n\n    chip_len = pfl->sector_len * pfl->nb_blocs;\n\n    /* XXX: to be fixed */\n\n#if 0\n\n    if (total_len != (8 * 1024 * 1024) && total_len != (16 * 1024 * 1024) &&\n\n        total_len != (32 * 1024 * 1024) && total_len != (64 * 1024 * 1024))\n\n        return NULL;\n\n#endif\n\n\n\n    memory_region_init_rom_device(&pfl->orig_mem, OBJECT(pfl), pfl->be ?\n\n                                  &pflash_cfi02_ops_be : &pflash_cfi02_ops_le,\n\n                                  pfl, pfl->name, chip_len, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    vmstate_register_ram(&pfl->orig_mem, DEVICE(pfl));\n\n    pfl->storage = memory_region_get_ram_ptr(&pfl->orig_mem);\n\n    pfl->chip_len = chip_len;\n\n    if (pfl->bs) {\n\n        /* read the initial flash content */\n\n        ret = bdrv_read(pfl->bs, 0, pfl->storage, chip_len >> 9);\n\n        if (ret < 0) {\n\n            vmstate_unregister_ram(&pfl->orig_mem, DEVICE(pfl));\n\n            error_setg(errp, \"failed to read the initial flash content\");\n\n            return;\n\n        }\n\n    }\n\n\n\n    pflash_setup_mappings(pfl);\n\n    pfl->rom_mode = 1;\n\n    sysbus_init_mmio(SYS_BUS_DEVICE(dev), &pfl->mem);\n\n\n\n    if (pfl->bs) {\n\n        pfl->ro = bdrv_is_read_only(pfl->bs);\n\n    } else {\n\n        pfl->ro = 0;\n\n    }\n\n\n\n    pfl->timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, pflash_timer, pfl);\n\n    pfl->wcycle = 0;\n\n    pfl->cmd = 0;\n\n    pfl->status = 0;\n\n    /* Hardcoded CFI table (mostly from SG29 Spansion flash) */\n\n    pfl->cfi_len = 0x52;\n\n    /* Standard \"QRY\" string */\n\n    pfl->cfi_table[0x10] = 'Q';\n\n    pfl->cfi_table[0x11] = 'R';\n\n    pfl->cfi_table[0x12] = 'Y';\n\n    /* Command set (AMD/Fujitsu) */\n\n    pfl->cfi_table[0x13] = 0x02;\n\n    pfl->cfi_table[0x14] = 0x00;\n\n    /* Primary extended table address */\n\n    pfl->cfi_table[0x15] = 0x31;\n\n    pfl->cfi_table[0x16] = 0x00;\n\n    /* Alternate command set (none) */\n\n    pfl->cfi_table[0x17] = 0x00;\n\n    pfl->cfi_table[0x18] = 0x00;\n\n    /* Alternate extended table (none) */\n\n    pfl->cfi_table[0x19] = 0x00;\n\n    pfl->cfi_table[0x1A] = 0x00;\n\n    /* Vcc min */\n\n    pfl->cfi_table[0x1B] = 0x27;\n\n    /* Vcc max */\n\n    pfl->cfi_table[0x1C] = 0x36;\n\n    /* Vpp min (no Vpp pin) */\n\n    pfl->cfi_table[0x1D] = 0x00;\n\n    /* Vpp max (no Vpp pin) */\n\n    pfl->cfi_table[0x1E] = 0x00;\n\n    /* Reserved */\n\n    pfl->cfi_table[0x1F] = 0x07;\n\n    /* Timeout for min size buffer write (NA) */\n\n    pfl->cfi_table[0x20] = 0x00;\n\n    /* Typical timeout for block erase (512 ms) */\n\n    pfl->cfi_table[0x21] = 0x09;\n\n    /* Typical timeout for full chip erase (4096 ms) */\n\n    pfl->cfi_table[0x22] = 0x0C;\n\n    /* Reserved */\n\n    pfl->cfi_table[0x23] = 0x01;\n\n    /* Max timeout for buffer write (NA) */\n\n    pfl->cfi_table[0x24] = 0x00;\n\n    /* Max timeout for block erase */\n\n    pfl->cfi_table[0x25] = 0x0A;\n\n    /* Max timeout for chip erase */\n\n    pfl->cfi_table[0x26] = 0x0D;\n\n    /* Device size */\n\n    pfl->cfi_table[0x27] = ctz32(chip_len);\n\n    /* Flash device interface (8 & 16 bits) */\n\n    pfl->cfi_table[0x28] = 0x02;\n\n    pfl->cfi_table[0x29] = 0x00;\n\n    /* Max number of bytes in multi-bytes write */\n\n    /* XXX: disable buffered write as it's not supported */\n\n    //    pfl->cfi_table[0x2A] = 0x05;\n\n    pfl->cfi_table[0x2A] = 0x00;\n\n    pfl->cfi_table[0x2B] = 0x00;\n\n    /* Number of erase block regions (uniform) */\n\n    pfl->cfi_table[0x2C] = 0x01;\n\n    /* Erase block region 1 */\n\n    pfl->cfi_table[0x2D] = pfl->nb_blocs - 1;\n\n    pfl->cfi_table[0x2E] = (pfl->nb_blocs - 1) >> 8;\n\n    pfl->cfi_table[0x2F] = pfl->sector_len >> 8;\n\n    pfl->cfi_table[0x30] = pfl->sector_len >> 16;\n\n\n\n    /* Extended */\n\n    pfl->cfi_table[0x31] = 'P';\n\n    pfl->cfi_table[0x32] = 'R';\n\n    pfl->cfi_table[0x33] = 'I';\n\n\n\n    pfl->cfi_table[0x34] = '1';\n\n    pfl->cfi_table[0x35] = '0';\n\n\n\n    pfl->cfi_table[0x36] = 0x00;\n\n    pfl->cfi_table[0x37] = 0x00;\n\n    pfl->cfi_table[0x38] = 0x00;\n\n    pfl->cfi_table[0x39] = 0x00;\n\n\n\n    pfl->cfi_table[0x3a] = 0x00;\n\n\n\n    pfl->cfi_table[0x3b] = 0x00;\n\n    pfl->cfi_table[0x3c] = 0x00;\n\n}\n", "idx": 23826}
{"project": "qemu", "commit_id": "b07c32dc4bdda102803ed6699438fef059c8f408", "target": 0, "func": "static inline void gen_op_arith_divw(DisasContext *ctx, TCGv ret, TCGv arg1,\n\n                                     TCGv arg2, int sign, int compute_ov)\n\n{\n\n    TCGLabel *l1 = gen_new_label();\n\n    TCGLabel *l2 = gen_new_label();\n\n    TCGv_i32 t0 = tcg_temp_local_new_i32();\n\n    TCGv_i32 t1 = tcg_temp_local_new_i32();\n\n\n\n    tcg_gen_trunc_tl_i32(t0, arg1);\n\n    tcg_gen_trunc_tl_i32(t1, arg2);\n\n    tcg_gen_brcondi_i32(TCG_COND_EQ, t1, 0, l1);\n\n    if (sign) {\n\n        TCGLabel *l3 = gen_new_label();\n\n        tcg_gen_brcondi_i32(TCG_COND_NE, t1, -1, l3);\n\n        tcg_gen_brcondi_i32(TCG_COND_EQ, t0, INT32_MIN, l1);\n\n        gen_set_label(l3);\n\n        tcg_gen_div_i32(t0, t0, t1);\n\n    } else {\n\n        tcg_gen_divu_i32(t0, t0, t1);\n\n    }\n\n    if (compute_ov) {\n\n        tcg_gen_movi_tl(cpu_ov, 0);\n\n    }\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    if (sign) {\n\n        tcg_gen_sari_i32(t0, t0, 31);\n\n    } else {\n\n        tcg_gen_movi_i32(t0, 0);\n\n    }\n\n    if (compute_ov) {\n\n        tcg_gen_movi_tl(cpu_ov, 1);\n\n        tcg_gen_movi_tl(cpu_so, 1);\n\n    }\n\n    gen_set_label(l2);\n\n    tcg_gen_extu_i32_tl(ret, t0);\n\n    tcg_temp_free_i32(t0);\n\n    tcg_temp_free_i32(t1);\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, ret);\n\n}\n", "idx": 23827}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static void omap_prcm_apll_update(struct omap_prcm_s *s)\n\n{\n\n    int mode[2];\n\n\n\n    mode[0] = (s->clken[9] >> 6) & 3;\n\n    s->apll_lock[0] = (mode[0] == 3);\n\n    mode[1] = (s->clken[9] >> 2) & 3;\n\n    s->apll_lock[1] = (mode[1] == 3);\n\n    /* TODO: update clocks */\n\n\n\n    if (mode[0] == 1 || mode[0] == 2 || mode[1] == 1 || mode[1] == 2)\n\n        fprintf(stderr, \"%s: bad EN_54M_PLL or bad EN_96M_PLL\\n\",\n\n                        __FUNCTION__);\n\n}\n", "idx": 23828}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t musicpal_gpio_read(void *opaque, target_phys_addr_t offset,\n\n                                   unsigned size)\n\n{\n\n    musicpal_gpio_state *s = opaque;\n\n\n\n    switch (offset) {\n\n    case MP_GPIO_OE_HI: /* used for LCD brightness control */\n\n        return s->lcd_brightness & MP_OE_LCD_BRIGHTNESS;\n\n\n\n    case MP_GPIO_OUT_LO:\n\n        return s->out_state & 0xFFFF;\n\n    case MP_GPIO_OUT_HI:\n\n        return s->out_state >> 16;\n\n\n\n    case MP_GPIO_IN_LO:\n\n        return s->in_state & 0xFFFF;\n\n    case MP_GPIO_IN_HI:\n\n        return s->in_state >> 16;\n\n\n\n    case MP_GPIO_IER_LO:\n\n        return s->ier & 0xFFFF;\n\n    case MP_GPIO_IER_HI:\n\n        return s->ier >> 16;\n\n\n\n    case MP_GPIO_IMR_LO:\n\n        return s->imr & 0xFFFF;\n\n    case MP_GPIO_IMR_HI:\n\n        return s->imr >> 16;\n\n\n\n    case MP_GPIO_ISR_LO:\n\n        return s->isr & 0xFFFF;\n\n    case MP_GPIO_ISR_HI:\n\n        return s->isr >> 16;\n\n\n\n    default:\n\n        return 0;\n\n    }\n\n}\n", "idx": 23829}
{"project": "qemu", "commit_id": "debaaa114a8877a939533ba846e64168fb287b7b", "target": 0, "func": "static void test_sanity(void)\n\n{\n\n    AHCIQState *ahci;\n\n    ahci = ahci_boot();\n\n    ahci_shutdown(ahci);\n\n}\n", "idx": 23830}
{"project": "qemu", "commit_id": "621ff94d5074d88253a5818c6b9c4db718fbfc65", "target": 0, "func": "static int qcow2_create(const char *filename, QemuOpts *opts, Error **errp)\n\n{\n\n    char *backing_file = NULL;\n\n    char *backing_fmt = NULL;\n\n    char *buf = NULL;\n\n    uint64_t size = 0;\n\n    int flags = 0;\n\n    size_t cluster_size = DEFAULT_CLUSTER_SIZE;\n\n    PreallocMode prealloc;\n\n    int version = 3;\n\n    uint64_t refcount_bits = 16;\n\n    int refcount_order;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    /* Read out options */\n\n    size = ROUND_UP(qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0),\n\n                    BDRV_SECTOR_SIZE);\n\n    backing_file = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FILE);\n\n    backing_fmt = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FMT);\n\n    if (qemu_opt_get_bool_del(opts, BLOCK_OPT_ENCRYPT, false)) {\n\n        flags |= BLOCK_FLAG_ENCRYPT;\n\n    }\n\n    cluster_size = qemu_opt_get_size_del(opts, BLOCK_OPT_CLUSTER_SIZE,\n\n                                         DEFAULT_CLUSTER_SIZE);\n\n    buf = qemu_opt_get_del(opts, BLOCK_OPT_PREALLOC);\n\n    prealloc = qapi_enum_parse(PreallocMode_lookup, buf,\n\n                               PREALLOC_MODE__MAX, PREALLOC_MODE_OFF,\n\n                               &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n    g_free(buf);\n\n    buf = qemu_opt_get_del(opts, BLOCK_OPT_COMPAT_LEVEL);\n\n    if (!buf) {\n\n        /* keep the default */\n\n    } else if (!strcmp(buf, \"0.10\")) {\n\n        version = 2;\n\n    } else if (!strcmp(buf, \"1.1\")) {\n\n        version = 3;\n\n    } else {\n\n        error_setg(errp, \"Invalid compatibility level: '%s'\", buf);\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    if (qemu_opt_get_bool_del(opts, BLOCK_OPT_LAZY_REFCOUNTS, false)) {\n\n        flags |= BLOCK_FLAG_LAZY_REFCOUNTS;\n\n    }\n\n\n\n    if (backing_file && prealloc != PREALLOC_MODE_OFF) {\n\n        error_setg(errp, \"Backing file and preallocation cannot be used at \"\n\n                   \"the same time\");\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    if (version < 3 && (flags & BLOCK_FLAG_LAZY_REFCOUNTS)) {\n\n        error_setg(errp, \"Lazy refcounts only supported with compatibility \"\n\n                   \"level 1.1 and above (use compat=1.1 or greater)\");\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    refcount_bits = qemu_opt_get_number_del(opts, BLOCK_OPT_REFCOUNT_BITS,\n\n                                            refcount_bits);\n\n    if (refcount_bits > 64 || !is_power_of_2(refcount_bits)) {\n\n        error_setg(errp, \"Refcount width must be a power of two and may not \"\n\n                   \"exceed 64 bits\");\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    if (version < 3 && refcount_bits != 16) {\n\n        error_setg(errp, \"Different refcount widths than 16 bits require \"\n\n                   \"compatibility level 1.1 or above (use compat=1.1 or \"\n\n                   \"greater)\");\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    refcount_order = ctz32(refcount_bits);\n\n\n\n    ret = qcow2_create2(filename, size, backing_file, backing_fmt, flags,\n\n                        cluster_size, prealloc, opts, version, refcount_order,\n\n                        &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n    }\n\n\n\nfinish:\n\n    g_free(backing_file);\n\n    g_free(backing_fmt);\n\n    g_free(buf);\n\n    return ret;\n\n}\n", "idx": 23831}
{"project": "qemu", "commit_id": "d5a8ee60a0fbc20a2c2d02f3bda1bb1bd365f1ee", "target": 1, "func": "static void bdrv_query_info(BlockBackend *blk, BlockInfo **p_info,\n\n                            Error **errp)\n\n{\n\n    BlockInfo *info = g_malloc0(sizeof(*info));\n\n    BlockDriverState *bs = blk_bs(blk);\n\n    BlockDriverState *bs0;\n\n    ImageInfo **p_image_info;\n\n    Error *local_err = NULL;\n\n    info->device = g_strdup(blk_name(blk));\n\n    info->type = g_strdup(\"unknown\");\n\n    info->locked = blk_dev_is_medium_locked(blk);\n\n    info->removable = blk_dev_has_removable_media(blk);\n\n\n\n    if (blk_dev_has_removable_media(blk)) {\n\n        info->has_tray_open = true;\n\n        info->tray_open = blk_dev_is_tray_open(blk);\n\n    }\n\n\n\n    if (bdrv_iostatus_is_enabled(bs)) {\n\n        info->has_io_status = true;\n\n        info->io_status = bs->iostatus;\n\n    }\n\n\n\n    if (!QLIST_EMPTY(&bs->dirty_bitmaps)) {\n\n        info->has_dirty_bitmaps = true;\n\n        info->dirty_bitmaps = bdrv_query_dirty_bitmaps(bs);\n\n    }\n\n\n\n    if (bs->drv) {\n\n        info->has_inserted = true;\n\n        info->inserted = bdrv_block_device_info(bs);\n\n\n\n        bs0 = bs;\n\n        p_image_info = &info->inserted->image;\n\n        while (1) {\n\n            bdrv_query_image_info(bs0, p_image_info, &local_err);\n\n            if (local_err) {\n\n                error_propagate(errp, local_err);\n\n                goto err;\n\n            }\n\n            if (bs0->drv && bs0->backing_hd) {\n\n                bs0 = bs0->backing_hd;\n\n                (*p_image_info)->has_backing_image = true;\n\n                p_image_info = &((*p_image_info)->backing_image);\n\n            } else {\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    *p_info = info;\n\n    return;\n\n\n\n err:\n\n    qapi_free_BlockInfo(info);\n\n}\n", "idx": 23834}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void put_float64(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint64_t *v = pv;\n\n\n\n    qemu_put_be64(f, float64_val(*v));\n\n}\n", "idx": 23838}
{"project": "qemu", "commit_id": "cdde6ffc27517bdf069734fbc5693ce2b14edc75", "target": 1, "func": "static void pci_host_config_write(void *opaque, target_phys_addr_t addr,\n\n                                  uint64_t val, unsigned len)\n\n{\n\n    PCIHostState *s = opaque;\n\n\n\n    PCI_DPRINTF(\"%s addr \" TARGET_FMT_plx \" len %d val %\"PRIx64\"\\n\",\n\n                __func__, addr, len, val);\n\n\n\n\n    s->config_reg = val;\n", "idx": 23839}
{"project": "qemu", "commit_id": "b3f7f0c5e6449be7275f1762bccbfa2177395a3b", "target": 1, "func": "static int colo_do_checkpoint_transaction(MigrationState *s,\n\n                                          QIOChannelBuffer *bioc,\n\n                                          QEMUFile *fb)\n\n{\n\n    Error *local_err = NULL;\n\n    int ret = -1;\n\n\n\n    colo_send_message(s->to_dst_file, COLO_MESSAGE_CHECKPOINT_REQUEST,\n\n                      &local_err);\n\n    if (local_err) {\n\n\n\n\n\n    colo_receive_check_message(s->rp_state.from_dst_file,\n\n                    COLO_MESSAGE_CHECKPOINT_REPLY, &local_err);\n\n    if (local_err) {\n\n\n\n    /* Reset channel-buffer directly */\n\n    qio_channel_io_seek(QIO_CHANNEL(bioc), 0, 0, NULL);\n\n    bioc->usage = 0;\n\n\n\n    qemu_mutex_lock_iothread();\n\n\n\n\n\n    vm_stop_force_state(RUN_STATE_COLO);\n\n\n    trace_colo_vm_state_change(\"run\", \"stop\");\n\n\n\n\n\n\n\n\n\n\n    /* Disable block migration */\n\n    s->params.blk = 0;\n\n    s->params.shared = 0;\n\n    qemu_savevm_state_header(fb);\n\n    qemu_savevm_state_begin(fb, &s->params);\n\n    qemu_mutex_lock_iothread();\n\n    qemu_savevm_state_complete_precopy(fb, false);\n\n\n\n\n    qemu_fflush(fb);\n\n\n\n    colo_send_message(s->to_dst_file, COLO_MESSAGE_VMSTATE_SEND, &local_err);\n\n    if (local_err) {\n\n\n\n\n     * We need the size of the VMstate data in Secondary side,\n\n     * With which we can decide how much data should be read.\n\n\n    colo_send_message_value(s->to_dst_file, COLO_MESSAGE_VMSTATE_SIZE,\n\n                            bioc->usage, &local_err);\n\n    if (local_err) {\n\n\n\n\n\n    qemu_put_buffer(s->to_dst_file, bioc->data, bioc->usage);\n\n    qemu_fflush(s->to_dst_file);\n\n    ret = qemu_file_get_error(s->to_dst_file);\n\n    if (ret < 0) {\n\n\n\n\n\n    colo_receive_check_message(s->rp_state.from_dst_file,\n\n                       COLO_MESSAGE_VMSTATE_RECEIVED, &local_err);\n\n    if (local_err) {\n\n\n\n\n\n    colo_receive_check_message(s->rp_state.from_dst_file,\n\n                       COLO_MESSAGE_VMSTATE_LOADED, &local_err);\n\n    if (local_err) {\n\n\n\n\n\n    ret = 0;\n\n\n\n    qemu_mutex_lock_iothread();\n\n    vm_start();\n\n\n    trace_colo_vm_state_change(\"stop\", \"run\");\n\n\n\nout:\n\n    if (local_err) {\n\n        error_report_err(local_err);\n\n\n    return ret;\n", "idx": 23840}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void qpci_msix_disable(QPCIDevice *dev)\n\n{\n\n    uint8_t addr;\n\n    uint16_t val;\n\n\n\n    g_assert(dev->msix_enabled);\n\n    addr = qpci_find_capability(dev, PCI_CAP_ID_MSIX);\n\n    g_assert_cmphex(addr, !=, 0);\n\n    val = qpci_config_readw(dev, addr + PCI_MSIX_FLAGS);\n\n    qpci_config_writew(dev, addr + PCI_MSIX_FLAGS,\n\n                                                val & ~PCI_MSIX_FLAGS_ENABLE);\n\n\n\n    qpci_iounmap(dev, dev->msix_table);\n\n    qpci_iounmap(dev, dev->msix_pba);\n\n    dev->msix_enabled = 0;\n\n    dev->msix_table = NULL;\n\n    dev->msix_pba = NULL;\n\n}\n", "idx": 23841}
{"project": "qemu", "commit_id": "a9fc37f6bc3f2ab90585cb16493da9f6dcfbfbcf", "target": 1, "func": "static void qobject_input_type_number(Visitor *v, const char *name, double *obj,\n\n                                      Error **errp)\n\n{\n\n    QObjectInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    QInt *qint;\n\n    QFloat *qfloat;\n\n\n\n    if (!qobj) {\n\n        return;\n\n    }\n\n    qint = qobject_to_qint(qobj);\n\n    if (qint) {\n\n        *obj = qint_get_int(qobject_to_qint(qobj));\n\n        return;\n\n    }\n\n\n\n    qfloat = qobject_to_qfloat(qobj);\n\n    if (qfloat) {\n\n        *obj = qfloat_get_double(qobject_to_qfloat(qobj));\n\n        return;\n\n    }\n\n\n\n    error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n               \"number\");\n\n}\n", "idx": 23842}
{"project": "qemu", "commit_id": "0479097859372a760843ad1b9c6ed3705c6423ca", "target": 1, "func": "static MemoryRegion *nvdimm_get_memory_region(PCDIMMDevice *dimm)\n\n{\n\n    NVDIMMDevice *nvdimm = NVDIMM(dimm);\n\n\n\n    return &nvdimm->nvdimm_mr;\n\n}\n", "idx": 23845}
{"project": "qemu", "commit_id": "7334d6507a7578152bb7addcef84e4cf634814a4", "target": 0, "func": "static void usb_serial_realize(USBDevice *dev, Error **errp)\n\n{\n\n    USBSerialState *s = DO_UPCAST(USBSerialState, dev, dev);\n\n\n\n    usb_desc_create_serial(dev);\n\n    usb_desc_init(dev);\n\n    dev->auto_attach = 0;\n\n\n\n    if (!s->cs) {\n\n        error_setg(errp, \"Property chardev is required\");\n\n        return;\n\n    }\n\n\n\n    qemu_chr_add_handlers(s->cs, usb_serial_can_read, usb_serial_read,\n\n                          usb_serial_event, s);\n\n    usb_serial_handle_reset(dev);\n\n\n\n    if (s->cs->be_open && !dev->attached) {\n\n        usb_device_attach(dev, errp);\n\n    }\n\n}\n", "idx": 23846}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static struct omap_rtc_s *omap_rtc_init(MemoryRegion *system_memory,\n\n                                        target_phys_addr_t base,\n\n                                        qemu_irq timerirq, qemu_irq alarmirq,\n\n                                        omap_clk clk)\n\n{\n\n    struct omap_rtc_s *s = (struct omap_rtc_s *)\n\n            g_malloc0(sizeof(struct omap_rtc_s));\n\n\n\n    s->irq = timerirq;\n\n    s->alarm = alarmirq;\n\n    s->clk = qemu_new_timer_ms(rtc_clock, omap_rtc_tick, s);\n\n\n\n    omap_rtc_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_rtc_ops, s,\n\n                          \"omap-rtc\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 23847}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void tmu2_write(void *opaque, target_phys_addr_t addr, uint64_t value,\n\n                       unsigned size)\n\n{\n\n    MilkymistTMU2State *s = opaque;\n\n\n\n    trace_milkymist_tmu2_memory_write(addr, value);\n\n\n\n    addr >>= 2;\n\n    switch (addr) {\n\n    case R_CTL:\n\n        s->regs[addr] = value;\n\n        if (value & CTL_START_BUSY) {\n\n            tmu2_start(s);\n\n        }\n\n        break;\n\n    case R_BRIGHTNESS:\n\n    case R_HMESHLAST:\n\n    case R_VMESHLAST:\n\n    case R_CHROMAKEY:\n\n    case R_VERTICESADDR:\n\n    case R_TEXFBUF:\n\n    case R_TEXHRES:\n\n    case R_TEXVRES:\n\n    case R_TEXHMASK:\n\n    case R_TEXVMASK:\n\n    case R_DSTFBUF:\n\n    case R_DSTHRES:\n\n    case R_DSTVRES:\n\n    case R_DSTHOFFSET:\n\n    case R_DSTVOFFSET:\n\n    case R_DSTSQUAREW:\n\n    case R_DSTSQUAREH:\n\n    case R_ALPHA:\n\n        s->regs[addr] = value;\n\n        break;\n\n\n\n    default:\n\n        error_report(\"milkymist_tmu2: write access to unknown register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    }\n\n\n\n    tmu2_check_registers(s);\n\n}\n", "idx": 23848}
{"project": "qemu", "commit_id": "ccf1e2dcd6091eea1fc2341c63201aa1a6094978", "target": 0, "func": "static ssize_t qio_channel_socket_writev(QIOChannel *ioc,\n\n                                         const struct iovec *iov,\n\n                                         size_t niov,\n\n                                         int *fds,\n\n                                         size_t nfds,\n\n                                         Error **errp)\n\n{\n\n    QIOChannelSocket *sioc = QIO_CHANNEL_SOCKET(ioc);\n\n    ssize_t ret;\n\n    struct msghdr msg = { NULL, };\n\n    char control[CMSG_SPACE(sizeof(int) * SOCKET_MAX_FDS)] = { 0 };\n\n    size_t fdsize = sizeof(int) * nfds;\n\n    struct cmsghdr *cmsg;\n\n\n\n    msg.msg_iov = (struct iovec *)iov;\n\n    msg.msg_iovlen = niov;\n\n\n\n    if (nfds) {\n\n        if (nfds > SOCKET_MAX_FDS) {\n\n            error_setg_errno(errp, EINVAL,\n\n                             \"Only %d FDs can be sent, got %zu\",\n\n                             SOCKET_MAX_FDS, nfds);\n\n            return -1;\n\n        }\n\n\n\n        msg.msg_control = control;\n\n        msg.msg_controllen = CMSG_SPACE(sizeof(int) * nfds);\n\n\n\n        cmsg = CMSG_FIRSTHDR(&msg);\n\n        cmsg->cmsg_len = CMSG_LEN(fdsize);\n\n        cmsg->cmsg_level = SOL_SOCKET;\n\n        cmsg->cmsg_type = SCM_RIGHTS;\n\n        memcpy(CMSG_DATA(cmsg), fds, fdsize);\n\n    }\n\n\n\n retry:\n\n    ret = sendmsg(sioc->fd, &msg, 0);\n\n    if (ret <= 0) {\n\n        if (socket_error() == EAGAIN ||\n\n            socket_error() == EWOULDBLOCK) {\n\n            return QIO_CHANNEL_ERR_BLOCK;\n\n        }\n\n        if (socket_error() == EINTR) {\n\n            goto retry;\n\n        }\n\n        error_setg_errno(errp, socket_error(),\n\n                         \"Unable to write to socket\");\n\n        return -1;\n\n    }\n\n    return ret;\n\n}\n", "idx": 23849}
{"project": "qemu", "commit_id": "0ff0fad23d3693ecf7a0c462cdb48f0e60f93808", "target": 0, "func": "static int SocketAddress_to_str(char *dest, int max_len,\n\n                                const char *prefix, SocketAddress *addr,\n\n                                bool is_listen, bool is_telnet)\n\n{\n\n    switch (addr->type) {\n\n    case SOCKET_ADDRESS_KIND_INET:\n\n        return snprintf(dest, max_len, \"%s%s:%s:%s%s\", prefix,\n\n                        is_telnet ? \"telnet\" : \"tcp\", addr->u.inet->host,\n\n                        addr->u.inet->port, is_listen ? \",server\" : \"\");\n\n        break;\n\n    case SOCKET_ADDRESS_KIND_UNIX:\n\n        return snprintf(dest, max_len, \"%sunix:%s%s\", prefix,\n\n                        addr->u.q_unix->path, is_listen ? \",server\" : \"\");\n\n        break;\n\n    case SOCKET_ADDRESS_KIND_FD:\n\n        return snprintf(dest, max_len, \"%sfd:%s%s\", prefix, addr->u.fd->str,\n\n                        is_listen ? \",server\" : \"\");\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n}\n", "idx": 23850}
{"project": "qemu", "commit_id": "031380d8770d2df6c386e4aeabd412007d3ebd54", "target": 0, "func": "static int blkverify_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    BDRVBlkverifyState *s = bs->opaque;\n\n    int ret;\n\n    char *raw, *c;\n\n\n\n    /* Parse the blkverify: prefix */\n\n    if (strncmp(filename, \"blkverify:\", strlen(\"blkverify:\"))) {\n\n        return -EINVAL;\n\n    }\n\n    filename += strlen(\"blkverify:\");\n\n\n\n    /* Parse the raw image filename */\n\n    c = strchr(filename, ':');\n\n    if (c == NULL) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    raw = strdup(filename);\n\n    raw[c - filename] = '\\0';\n\n    ret = bdrv_file_open(&bs->file, raw, flags);\n\n    free(raw);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    filename = c + 1;\n\n\n\n    /* Open the test file */\n\n    s->test_file = bdrv_new(\"\");\n\n    ret = bdrv_open(s->test_file, filename, flags, NULL);\n\n    if (ret < 0) {\n\n        bdrv_delete(s->test_file);\n\n        s->test_file = NULL;\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23851}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int32_t scsi_disk_dma_command(SCSIRequest *req, uint8_t *buf)\n\n{\n\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    uint32_t len;\n\n    uint8_t command;\n\n\n\n    command = buf[0];\n\n\n\n    if (s->tray_open || !bdrv_is_inserted(s->qdev.conf.bs)) {\n\n        scsi_check_condition(r, SENSE_CODE(NO_MEDIUM));\n\n        return 0;\n\n    }\n\n\n\n    len = scsi_data_cdb_length(r->req.cmd.buf);\n\n    switch (command) {\n\n    case READ_6:\n\n    case READ_10:\n\n    case READ_12:\n\n    case READ_16:\n\n        DPRINTF(\"Read (sector %\" PRId64 \", count %u)\\n\", r->req.cmd.lba, len);\n\n        if (r->req.cmd.buf[1] & 0xe0) {\n\n            goto illegal_request;\n\n        }\n\n        if (!check_lba_range(s, r->req.cmd.lba, len)) {\n\n            goto illegal_lba;\n\n        }\n\n        r->sector = r->req.cmd.lba * (s->qdev.blocksize / 512);\n\n        r->sector_count = len * (s->qdev.blocksize / 512);\n\n        break;\n\n    case WRITE_6:\n\n    case WRITE_10:\n\n    case WRITE_12:\n\n    case WRITE_16:\n\n    case WRITE_VERIFY_10:\n\n    case WRITE_VERIFY_12:\n\n    case WRITE_VERIFY_16:\n\n        if (bdrv_is_read_only(s->qdev.conf.bs)) {\n\n            scsi_check_condition(r, SENSE_CODE(WRITE_PROTECTED));\n\n            return 0;\n\n        }\n\n        DPRINTF(\"Write %s(sector %\" PRId64 \", count %u)\\n\",\n\n                (command & 0xe) == 0xe ? \"And Verify \" : \"\",\n\n                r->req.cmd.lba, len);\n\n        if (r->req.cmd.buf[1] & 0xe0) {\n\n            goto illegal_request;\n\n        }\n\n        if (!check_lba_range(s, r->req.cmd.lba, len)) {\n\n            goto illegal_lba;\n\n        }\n\n        r->sector = r->req.cmd.lba * (s->qdev.blocksize / 512);\n\n        r->sector_count = len * (s->qdev.blocksize / 512);\n\n        break;\n\n    default:\n\n        abort();\n\n    illegal_request:\n\n        scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n\n        return 0;\n\n    illegal_lba:\n\n        scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE));\n\n        return 0;\n\n    }\n\n    if (r->sector_count == 0) {\n\n        scsi_req_complete(&r->req, GOOD);\n\n    }\n\n    assert(r->iov.iov_len == 0);\n\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n\n        return -r->sector_count * 512;\n\n    } else {\n\n        return r->sector_count * 512;\n\n    }\n\n}\n", "idx": 23852}
{"project": "qemu", "commit_id": "ac1970fbe8ad5a70174f462109ac0f6c7bf1bc43", "target": 0, "func": "static void core_begin(MemoryListener *listener)\n\n{\n\n    destroy_all_mappings();\n\n    phys_sections_clear();\n\n    phys_map.ptr = PHYS_MAP_NODE_NIL;\n\n    phys_section_unassigned = dummy_section(&io_mem_unassigned);\n\n    phys_section_notdirty = dummy_section(&io_mem_notdirty);\n\n    phys_section_rom = dummy_section(&io_mem_rom);\n\n    phys_section_watch = dummy_section(&io_mem_watch);\n\n}\n", "idx": 23853}
{"project": "qemu", "commit_id": "5819e3e072f41cbf81ad80d822a5c468a91f54e0", "target": 0, "func": "static void gdb_accept(void)\n\n{\n\n    GDBState *s;\n\n    struct sockaddr_in sockaddr;\n\n    socklen_t len;\n\n    int fd;\n\n\n\n    for(;;) {\n\n        len = sizeof(sockaddr);\n\n        fd = accept(gdbserver_fd, (struct sockaddr *)&sockaddr, &len);\n\n        if (fd < 0 && errno != EINTR) {\n\n            perror(\"accept\");\n\n            return;\n\n        } else if (fd >= 0) {\n\n#ifndef _WIN32\n\n            fcntl(fd, F_SETFD, FD_CLOEXEC);\n\n#endif\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* set short latency */\n\n    socket_set_nodelay(fd);\n\n\n\n    s = g_malloc0(sizeof(GDBState));\n\n    s->c_cpu = first_cpu;\n\n    s->g_cpu = first_cpu;\n\n    s->fd = fd;\n\n    gdb_has_xml = false;\n\n\n\n    gdbserver_state = s;\n\n\n\n    fcntl(fd, F_SETFL, O_NONBLOCK);\n\n}\n", "idx": 23855}
{"project": "qemu", "commit_id": "91479dd0b5bd3b087b92ddd7bc3f2c54982cfe17", "target": 0, "func": "START_TEST(qlist_new_test)\n\n{\n\n    QList *qlist;\n\n\n\n    qlist = qlist_new();\n\n    fail_unless(qlist != NULL);\n\n    fail_unless(qlist->base.refcnt == 1);\n\n    fail_unless(qobject_type(QOBJECT(qlist)) == QTYPE_QLIST);\n\n\n\n    // destroy doesn't exist yet\n\n    g_free(qlist);\n\n}\n", "idx": 23856}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void do_info(int argc, const char **argv)\n\n{\n\n    term_cmd_t *cmd;\n\n    const char *item;\n\n\n\n    if (argc < 2)\n\n        goto help;\n\n    item = argv[1];\n\n    for(cmd = info_cmds; cmd->name != NULL; cmd++) {\n\n        if (compare_cmd(argv[1], cmd->name)) \n\n            goto found;\n\n    }\n\n help:\n\n    help_cmd(argv[0]);\n\n    return;\n\n found:\n\n    cmd->handler(argc, argv);\n\n}\n", "idx": 23857}
{"project": "qemu", "commit_id": "3df9caf88f5c0859ae380101fea47609ba1dbfbd", "target": 0, "func": "static void scsi_command_complete(void *opaque, int ret)\n\n{\n\n    int status;\n\n    SCSIGenericReq *r = (SCSIGenericReq *)opaque;\n\n\n\n    r->req.aiocb = NULL;\n\n    if (r->req.io_canceled) {\n\n        goto done;\n\n    }\n\n    if (r->io_header.driver_status & SG_ERR_DRIVER_SENSE) {\n\n        r->req.sense_len = r->io_header.sb_len_wr;\n\n    }\n\n\n\n    if (ret != 0) {\n\n        switch (ret) {\n\n        case -EDOM:\n\n            status = TASK_SET_FULL;\n\n            break;\n\n        case -ENOMEM:\n\n            status = CHECK_CONDITION;\n\n            scsi_req_build_sense(&r->req, SENSE_CODE(TARGET_FAILURE));\n\n            break;\n\n        default:\n\n            status = CHECK_CONDITION;\n\n            scsi_req_build_sense(&r->req, SENSE_CODE(IO_ERROR));\n\n            break;\n\n        }\n\n    } else {\n\n        if (r->io_header.host_status == SG_ERR_DID_NO_CONNECT ||\n\n            r->io_header.host_status == SG_ERR_DID_BUS_BUSY ||\n\n            r->io_header.host_status == SG_ERR_DID_TIME_OUT ||\n\n            (r->io_header.driver_status & SG_ERR_DRIVER_TIMEOUT)) {\n\n            status = BUSY;\n\n            BADF(\"Driver Timeout\\n\");\n\n        } else if (r->io_header.host_status) {\n\n            status = CHECK_CONDITION;\n\n            scsi_req_build_sense(&r->req, SENSE_CODE(I_T_NEXUS_LOSS));\n\n        } else if (r->io_header.status) {\n\n            status = r->io_header.status;\n\n        } else if (r->io_header.driver_status & SG_ERR_DRIVER_SENSE) {\n\n            status = CHECK_CONDITION;\n\n        } else {\n\n            status = GOOD;\n\n        }\n\n    }\n\n    DPRINTF(\"Command complete 0x%p tag=0x%x status=%d\\n\",\n\n            r, r->req.tag, status);\n\n\n\n    scsi_req_complete(&r->req, status);\n\ndone:\n\n    if (!r->req.io_canceled) {\n\n        scsi_req_unref(&r->req);\n\n    }\n\n}\n", "idx": 23858}
{"project": "qemu", "commit_id": "cc8fa0e80836c51ba644d910cd89540a5bc83fc2", "target": 0, "func": "static bool iasl_installed(void)\n\n{\n\n    gchar *out = NULL, *out_err = NULL;\n\n    bool ret;\n\n\n\n    /* pass 'out' and 'out_err' in order to be redirected */\n\n    ret = g_spawn_command_line_sync(\"iasl\", &out, &out_err, NULL, NULL);\n\n\n\n    if (out_err) {\n\n        ret = ret && (out_err[0] == '\\0');\n\n        g_free(out_err);\n\n    }\n\n\n\n    if (out) {\n\n        g_free(out);\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 23859}
{"project": "qemu", "commit_id": "c58c7b959b93b864a27fd6b3646ee1465ab8832b", "target": 0, "func": "static void qxl_blit(PCIQXLDevice *qxl, QXLRect *rect)\n\n{\n\n    DisplaySurface *surface = qemu_console_surface(qxl->vga.con);\n\n    uint8_t *dst = surface_data(surface);\n\n    uint8_t *src;\n\n    int len, i;\n\n\n\n    if (is_buffer_shared(surface)) {\n\n        return;\n\n    }\n\n    if (!qxl->guest_primary.data) {\n\n        trace_qxl_render_blit_guest_primary_initialized();\n\n        qxl->guest_primary.data = memory_region_get_ram_ptr(&qxl->vga.vram);\n\n    }\n\n    trace_qxl_render_blit(qxl->guest_primary.qxl_stride,\n\n            rect->left, rect->right, rect->top, rect->bottom);\n\n    src = qxl->guest_primary.data;\n\n    if (qxl->guest_primary.qxl_stride < 0) {\n\n        /* qxl surface is upside down, walk src scanlines\n\n         * in reverse order to flip it */\n\n        src += (qxl->guest_primary.surface.height - rect->top - 1) *\n\n            qxl->guest_primary.abs_stride;\n\n    } else {\n\n        src += rect->top * qxl->guest_primary.abs_stride;\n\n    }\n\n    dst += rect->top  * qxl->guest_primary.abs_stride;\n\n    src += rect->left * qxl->guest_primary.bytes_pp;\n\n    dst += rect->left * qxl->guest_primary.bytes_pp;\n\n    len  = (rect->right - rect->left) * qxl->guest_primary.bytes_pp;\n\n\n\n    for (i = rect->top; i < rect->bottom; i++) {\n\n        memcpy(dst, src, len);\n\n        dst += qxl->guest_primary.abs_stride;\n\n        src += qxl->guest_primary.qxl_stride;\n\n    }\n\n}\n", "idx": 23860}
{"project": "qemu", "commit_id": "9167a69a816b8956d62da628b5b4dc87674647d6", "target": 0, "func": "void *lsi_scsi_init(PCIBus *bus, int devfn)\n\n{\n\n    LSIState *s;\n\n\n\n    s = (LSIState *)pci_register_device(bus, \"LSI53C895A SCSI HBA\",\n\n                                        sizeof(*s), devfn, NULL, NULL);\n\n    if (s == NULL) {\n\n        fprintf(stderr, \"lsi-scsi: Failed to register PCI device\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    s->pci_dev.config[0x00] = 0x00;\n\n    s->pci_dev.config[0x01] = 0x10;\n\n    s->pci_dev.config[0x02] = 0x12;\n\n    s->pci_dev.config[0x03] = 0x00;\n\n    s->pci_dev.config[0x0b] = 0x01;\n\n    s->pci_dev.config[0x3d] = 0x01; /* interrupt pin 1 */\n\n\n\n    s->mmio_io_addr = cpu_register_io_memory(0, lsi_mmio_readfn,\n\n                                             lsi_mmio_writefn, s);\n\n    s->ram_io_addr = cpu_register_io_memory(0, lsi_ram_readfn,\n\n                                            lsi_ram_writefn, s);\n\n\n\n    pci_register_io_region((struct PCIDevice *)s, 0, 256,\n\n                           PCI_ADDRESS_SPACE_IO, lsi_io_mapfunc);\n\n    pci_register_io_region((struct PCIDevice *)s, 1, 0x400,\n\n                           PCI_ADDRESS_SPACE_MEM, lsi_mmio_mapfunc);\n\n    pci_register_io_region((struct PCIDevice *)s, 2, 0x2000,\n\n                           PCI_ADDRESS_SPACE_MEM, lsi_ram_mapfunc);\n\n    s->queue = qemu_malloc(sizeof(lsi_queue));\n\n    s->queue_len = 1;\n\n    s->active_commands = 0;\n\n\n\n    lsi_soft_reset(s);\n\n\n\n    return s;\n\n}\n", "idx": 23861}
{"project": "qemu", "commit_id": "a369da5f31ddbdeb32a7f76622e480d3995fbb00", "target": 0, "func": "PCIDevice *pci_try_create(PCIBus *bus, int devfn, const char *name)\n\n{\n\n    return pci_try_create_multifunction(bus, devfn, false, name);\n\n}\n", "idx": 23862}
{"project": "qemu", "commit_id": "b6d36def6d9e9fd187327182d0abafc9b7085d8f", "target": 0, "func": "int qcow2_discard_clusters(BlockDriverState *bs, uint64_t offset,\n\n    int nb_sectors, enum qcow2_discard_type type, bool full_discard)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t end_offset;\n\n    unsigned int nb_clusters;\n\n    int ret;\n\n\n\n    end_offset = offset + (nb_sectors << BDRV_SECTOR_BITS);\n\n\n\n    /* Round start up and end down */\n\n    offset = align_offset(offset, s->cluster_size);\n\n    end_offset = start_of_cluster(s, end_offset);\n\n\n\n    if (offset > end_offset) {\n\n        return 0;\n\n    }\n\n\n\n    nb_clusters = size_to_clusters(s, end_offset - offset);\n\n\n\n    s->cache_discards = true;\n\n\n\n    /* Each L2 table is handled by its own loop iteration */\n\n    while (nb_clusters > 0) {\n\n        ret = discard_single_l2(bs, offset, nb_clusters, type, full_discard);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        nb_clusters -= ret;\n\n        offset += (ret * s->cluster_size);\n\n    }\n\n\n\n    ret = 0;\n\nfail:\n\n    s->cache_discards = false;\n\n    qcow2_process_discards(bs, ret);\n\n\n\n    return ret;\n\n}\n", "idx": 23863}
{"project": "qemu", "commit_id": "45a50b1668822c23afc2a89f724654e176518bc4", "target": 0, "func": "int read_targphys(int fd, target_phys_addr_t dst_addr, size_t nbytes)\n\n{\n\n    uint8_t buf[4096];\n\n    target_phys_addr_t dst_begin = dst_addr;\n\n    size_t want, did;\n\n\n\n    while (nbytes) {\n\n\twant = nbytes > sizeof(buf) ? sizeof(buf) : nbytes;\n\n\tdid = read(fd, buf, want);\n\n\tif (did != want) break;\n\n\n\n\tcpu_physical_memory_write_rom(dst_addr, buf, did);\n\n\tdst_addr += did;\n\n\tnbytes -= did;\n\n    }\n\n    return dst_addr - dst_begin;\n\n}\n", "idx": 23864}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "uint32_t cpu_inl(CPUState *env, pio_addr_t addr)\n\n{\n\n    uint32_t val;\n\n    val = ioport_read(2, addr);\n\n    LOG_IOPORT(\"inl : %04\"FMT_pioaddr\" %08\"PRIx32\"\\n\", addr, val);\n\n#ifdef CONFIG_KQEMU\n\n    if (env)\n\n        env->last_io_time = cpu_get_time_fast();\n\n#endif\n\n    return val;\n\n}\n", "idx": 23866}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "e1000_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n    E1000State *s = opaque;\n\n    struct e1000_rx_desc desc;\n\n    target_phys_addr_t base;\n\n    unsigned int n, rdt;\n\n    uint32_t rdh_start;\n\n    uint16_t vlan_special = 0;\n\n    uint8_t vlan_status = 0, vlan_offset = 0;\n\n\n\n    if (!(s->mac_reg[RCTL] & E1000_RCTL_EN))\n\n        return;\n\n\n\n    if (size > s->rxbuf_size) {\n\n        DBGOUT(RX, \"packet too large for buffers (%lu > %d)\\n\",\n\n               (unsigned long)size, s->rxbuf_size);\n\n        return;\n\n    }\n\n\n\n    if (!receive_filter(s, buf, size))\n\n        return;\n\n\n\n    if (vlan_enabled(s) && is_vlan_packet(s, buf)) {\n\n        vlan_special = cpu_to_le16(be16_to_cpup((uint16_t *)(buf + 14)));\n\n        memmove((void *)(buf + 4), buf, 12);\n\n        vlan_status = E1000_RXD_STAT_VP;\n\n        vlan_offset = 4;\n\n        size -= 4;\n\n    }\n\n\n\n    rdh_start = s->mac_reg[RDH];\n\n    size += 4; // for the header\n\n    do {\n\n        if (s->mac_reg[RDH] == s->mac_reg[RDT] && s->check_rxov) {\n\n            set_ics(s, 0, E1000_ICS_RXO);\n\n            return;\n\n        }\n\n        base = ((uint64_t)s->mac_reg[RDBAH] << 32) + s->mac_reg[RDBAL] +\n\n               sizeof(desc) * s->mac_reg[RDH];\n\n        cpu_physical_memory_read(base, (void *)&desc, sizeof(desc));\n\n        desc.special = vlan_special;\n\n        desc.status |= (vlan_status | E1000_RXD_STAT_DD);\n\n        if (desc.buffer_addr) {\n\n            cpu_physical_memory_write(le64_to_cpu(desc.buffer_addr),\n\n                                      (void *)(buf + vlan_offset), size);\n\n            desc.length = cpu_to_le16(size);\n\n            desc.status |= E1000_RXD_STAT_EOP|E1000_RXD_STAT_IXSM;\n\n        } else // as per intel docs; skip descriptors with null buf addr\n\n            DBGOUT(RX, \"Null RX descriptor!!\\n\");\n\n        cpu_physical_memory_write(base, (void *)&desc, sizeof(desc));\n\n\n\n        if (++s->mac_reg[RDH] * sizeof(desc) >= s->mac_reg[RDLEN])\n\n            s->mac_reg[RDH] = 0;\n\n        s->check_rxov = 1;\n\n        /* see comment in start_xmit; same here */\n\n        if (s->mac_reg[RDH] == rdh_start) {\n\n            DBGOUT(RXERR, \"RDH wraparound @%x, RDT %x, RDLEN %x\\n\",\n\n                   rdh_start, s->mac_reg[RDT], s->mac_reg[RDLEN]);\n\n            set_ics(s, 0, E1000_ICS_RXO);\n\n            return;\n\n        }\n\n    } while (desc.buffer_addr == 0);\n\n\n\n    s->mac_reg[GPRC]++;\n\n    s->mac_reg[TPR]++;\n\n    n = s->mac_reg[TORL];\n\n    if ((s->mac_reg[TORL] += size) < n)\n\n        s->mac_reg[TORH]++;\n\n\n\n    n = E1000_ICS_RXT0;\n\n    if ((rdt = s->mac_reg[RDT]) < s->mac_reg[RDH])\n\n        rdt += s->mac_reg[RDLEN] / sizeof(desc);\n\n    if (((rdt - s->mac_reg[RDH]) * sizeof(desc)) <= s->mac_reg[RDLEN] >>\n\n        s->rxbuf_min_shift)\n\n        n |= E1000_ICS_RXDMT0;\n\n\n\n    set_ics(s, 0, n);\n\n}\n", "idx": 23867}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_mcbsp_read(void *opaque, target_phys_addr_t addr,\n\n                                unsigned size)\n\n{\n\n    struct omap_mcbsp_s *s = (struct omap_mcbsp_s *) opaque;\n\n    int offset = addr & OMAP_MPUI_REG_MASK;\n\n    uint16_t ret;\n\n\n\n    if (size != 2) {\n\n        return omap_badwidth_read16(opaque, addr);\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x00:\t/* DRR2 */\n\n        if (((s->rcr[0] >> 5) & 7) < 3)\t\t\t/* RWDLEN1 */\n\n            return 0x0000;\n\n        /* Fall through.  */\n\n    case 0x02:\t/* DRR1 */\n\n        if (s->rx_req < 2) {\n\n            printf(\"%s: Rx FIFO underrun\\n\", __FUNCTION__);\n\n            omap_mcbsp_rx_done(s);\n\n        } else {\n\n            s->tx_req -= 2;\n\n            if (s->codec && s->codec->in.len >= 2) {\n\n                ret = s->codec->in.fifo[s->codec->in.start ++] << 8;\n\n                ret |= s->codec->in.fifo[s->codec->in.start ++];\n\n                s->codec->in.len -= 2;\n\n            } else\n\n                ret = 0x0000;\n\n            if (!s->tx_req)\n\n                omap_mcbsp_rx_done(s);\n\n            return ret;\n\n        }\n\n        return 0x0000;\n\n\n\n    case 0x04:\t/* DXR2 */\n\n    case 0x06:\t/* DXR1 */\n\n        return 0x0000;\n\n\n\n    case 0x08:\t/* SPCR2 */\n\n        return s->spcr[1];\n\n    case 0x0a:\t/* SPCR1 */\n\n        return s->spcr[0];\n\n    case 0x0c:\t/* RCR2 */\n\n        return s->rcr[1];\n\n    case 0x0e:\t/* RCR1 */\n\n        return s->rcr[0];\n\n    case 0x10:\t/* XCR2 */\n\n        return s->xcr[1];\n\n    case 0x12:\t/* XCR1 */\n\n        return s->xcr[0];\n\n    case 0x14:\t/* SRGR2 */\n\n        return s->srgr[1];\n\n    case 0x16:\t/* SRGR1 */\n\n        return s->srgr[0];\n\n    case 0x18:\t/* MCR2 */\n\n        return s->mcr[1];\n\n    case 0x1a:\t/* MCR1 */\n\n        return s->mcr[0];\n\n    case 0x1c:\t/* RCERA */\n\n        return s->rcer[0];\n\n    case 0x1e:\t/* RCERB */\n\n        return s->rcer[1];\n\n    case 0x20:\t/* XCERA */\n\n        return s->xcer[0];\n\n    case 0x22:\t/* XCERB */\n\n        return s->xcer[1];\n\n    case 0x24:\t/* PCR0 */\n\n        return s->pcr;\n\n    case 0x26:\t/* RCERC */\n\n        return s->rcer[2];\n\n    case 0x28:\t/* RCERD */\n\n        return s->rcer[3];\n\n    case 0x2a:\t/* XCERC */\n\n        return s->xcer[2];\n\n    case 0x2c:\t/* XCERD */\n\n        return s->xcer[3];\n\n    case 0x2e:\t/* RCERE */\n\n        return s->rcer[4];\n\n    case 0x30:\t/* RCERF */\n\n        return s->rcer[5];\n\n    case 0x32:\t/* XCERE */\n\n        return s->xcer[4];\n\n    case 0x34:\t/* XCERF */\n\n        return s->xcer[5];\n\n    case 0x36:\t/* RCERG */\n\n        return s->rcer[6];\n\n    case 0x38:\t/* RCERH */\n\n        return s->rcer[7];\n\n    case 0x3a:\t/* XCERG */\n\n        return s->xcer[6];\n\n    case 0x3c:\t/* XCERH */\n\n        return s->xcer[7];\n\n    }\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 23868}
{"project": "qemu", "commit_id": "a209f4615c6853a226e847810b6c607c71b6a046", "target": 0, "func": "static int virtio_blk_handle_scsi_req(VirtIOBlockReq *req)\n\n{\n\n    int status = VIRTIO_BLK_S_OK;\n\n    struct virtio_scsi_inhdr *scsi = NULL;\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(req->dev);\n\n    VirtQueueElement *elem = &req->elem;\n\n    VirtIOBlock *blk = req->dev;\n\n\n\n#ifdef __linux__\n\n    int i;\n\n    VirtIOBlockIoctlReq *ioctl_req;\n\n#endif\n\n\n\n    /*\n\n     * We require at least one output segment each for the virtio_blk_outhdr\n\n     * and the SCSI command block.\n\n     *\n\n     * We also at least require the virtio_blk_inhdr, the virtio_scsi_inhdr\n\n     * and the sense buffer pointer in the input segments.\n\n     */\n\n    if (elem->out_num < 2 || elem->in_num < 3) {\n\n        status = VIRTIO_BLK_S_IOERR;\n\n        goto fail;\n\n    }\n\n\n\n    /*\n\n     * The scsi inhdr is placed in the second-to-last input segment, just\n\n     * before the regular inhdr.\n\n     */\n\n    scsi = (void *)elem->in_sg[elem->in_num - 2].iov_base;\n\n\n\n    if (!blk->conf.scsi) {\n\n        status = VIRTIO_BLK_S_UNSUPP;\n\n        goto fail;\n\n    }\n\n\n\n    /*\n\n     * No support for bidirection commands yet.\n\n     */\n\n    if (elem->out_num > 2 && elem->in_num > 3) {\n\n        status = VIRTIO_BLK_S_UNSUPP;\n\n        goto fail;\n\n    }\n\n\n\n#ifdef __linux__\n\n    ioctl_req = g_new0(VirtIOBlockIoctlReq, 1);\n\n    ioctl_req->req = req;\n\n    ioctl_req->hdr.interface_id = 'S';\n\n    ioctl_req->hdr.cmd_len = elem->out_sg[1].iov_len;\n\n    ioctl_req->hdr.cmdp = elem->out_sg[1].iov_base;\n\n    ioctl_req->hdr.dxfer_len = 0;\n\n\n\n    if (elem->out_num > 2) {\n\n        /*\n\n         * If there are more than the minimally required 2 output segments\n\n         * there is write payload starting from the third iovec.\n\n         */\n\n        ioctl_req->hdr.dxfer_direction = SG_DXFER_TO_DEV;\n\n        ioctl_req->hdr.iovec_count = elem->out_num - 2;\n\n\n\n        for (i = 0; i < ioctl_req->hdr.iovec_count; i++) {\n\n            ioctl_req->hdr.dxfer_len += elem->out_sg[i + 2].iov_len;\n\n        }\n\n\n\n        ioctl_req->hdr.dxferp = elem->out_sg + 2;\n\n\n\n    } else if (elem->in_num > 3) {\n\n        /*\n\n         * If we have more than 3 input segments the guest wants to actually\n\n         * read data.\n\n         */\n\n        ioctl_req->hdr.dxfer_direction = SG_DXFER_FROM_DEV;\n\n        ioctl_req->hdr.iovec_count = elem->in_num - 3;\n\n        for (i = 0; i < ioctl_req->hdr.iovec_count; i++) {\n\n            ioctl_req->hdr.dxfer_len += elem->in_sg[i].iov_len;\n\n        }\n\n\n\n        ioctl_req->hdr.dxferp = elem->in_sg;\n\n    } else {\n\n        /*\n\n         * Some SCSI commands don't actually transfer any data.\n\n         */\n\n        ioctl_req->hdr.dxfer_direction = SG_DXFER_NONE;\n\n    }\n\n\n\n    ioctl_req->hdr.sbp = elem->in_sg[elem->in_num - 3].iov_base;\n\n    ioctl_req->hdr.mx_sb_len = elem->in_sg[elem->in_num - 3].iov_len;\n\n\n\n    blk_aio_ioctl(blk->blk, SG_IO, &ioctl_req->hdr,\n\n                  virtio_blk_ioctl_complete, ioctl_req);\n\n    return -EINPROGRESS;\n\n#else\n\n    abort();\n\n#endif\n\n\n\nfail:\n\n    /* Just put anything nonzero so that the ioctl fails in the guest.  */\n\n    if (scsi) {\n\n        virtio_stl_p(vdev, &scsi->errors, 255);\n\n    }\n\n    return status;\n\n}\n", "idx": 23869}
{"project": "qemu", "commit_id": "42e4126b793d15ec40f3a84017e1d8afecda1b6d", "target": 1, "func": "uint32_t pci_default_read_config(PCIDevice *d,\n\n                                 uint32_t address, int len)\n\n{\n\n    uint32_t val = 0;\n\n    assert(len == 1 || len == 2 || len == 4);\n\n    len = MIN(len, pci_config_size(d) - address);\n\n    memcpy(&val, d->config + address, len);\n\n    return le32_to_cpu(val);\n\n}\n", "idx": 23874}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_rfci_40x(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    /* Restore CPU state */\n\n    gen_helper_40x_rfci(cpu_env);\n\n    gen_sync_exception(ctx);\n\n#endif\n\n}\n", "idx": 23875}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "int qemu_strtoul(const char *nptr, const char **endptr, int base,\n\n                 unsigned long *result)\n\n{\n\n    char *p;\n\n    int err = 0;\n\n    if (!nptr) {\n\n        if (endptr) {\n\n            *endptr = nptr;\n\n        }\n\n        err = -EINVAL;\n\n    } else {\n\n        errno = 0;\n\n        *result = strtoul(nptr, &p, base);\n\n        err = check_strtox_error(endptr, p, errno);\n\n    }\n\n    return err;\n\n}\n", "idx": 23884}
{"project": "qemu", "commit_id": "6cecf093735f2e5af7d0e29d957350320044e354", "target": 1, "func": "static void virtio_9p_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);\n\n\n\n    dc->props = virtio_9p_properties;\n\n    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);\n\n    vdc->realize = virtio_9p_device_realize;\n\n\n    vdc->get_features = virtio_9p_get_features;\n\n    vdc->get_config = virtio_9p_get_config;\n\n}", "idx": 23885}
{"project": "qemu", "commit_id": "af7e9e74c6a62a5bcd911726a9e88d28b61490e0", "target": 1, "func": "static void openpic_gbl_write(void *opaque, hwaddr addr, uint64_t val,\n\n                              unsigned len)\n\n{\n\n    OpenPICState *opp = opaque;\n\n    IRQ_dst_t *dst;\n\n    int idx;\n\n\n\n    DPRINTF(\"%s: addr \" TARGET_FMT_plx \" <= %08x\\n\", __func__, addr, val);\n\n    if (addr & 0xF)\n\n        return;\n\n    switch (addr) {\n\n    case 0x00: /* Block Revision Register1 (BRR1) is Readonly */\n\n        break;\n\n    case 0x40:\n\n    case 0x50:\n\n    case 0x60:\n\n    case 0x70:\n\n    case 0x80:\n\n    case 0x90:\n\n    case 0xA0:\n\n    case 0xB0:\n\n        openpic_cpu_write_internal(opp, addr, val, get_current_cpu());\n\n        break;\n\n    case 0x1000: /* FREP */\n\n        break;\n\n    case 0x1020: /* GLBC */\n\n        if (val & GLBC_RESET) {\n\n            openpic_reset(&opp->busdev.qdev);\n\n        }\n\n        break;\n\n    case 0x1080: /* VENI */\n\n        break;\n\n    case 0x1090: /* PINT */\n\n        for (idx = 0; idx < opp->nb_cpus; idx++) {\n\n            if ((val & (1 << idx)) && !(opp->pint & (1 << idx))) {\n\n                DPRINTF(\"Raise OpenPIC RESET output for CPU %d\\n\", idx);\n\n                dst = &opp->dst[idx];\n\n                qemu_irq_raise(dst->irqs[OPENPIC_OUTPUT_RESET]);\n\n            } else if (!(val & (1 << idx)) && (opp->pint & (1 << idx))) {\n\n                DPRINTF(\"Lower OpenPIC RESET output for CPU %d\\n\", idx);\n\n                dst = &opp->dst[idx];\n\n                qemu_irq_lower(dst->irqs[OPENPIC_OUTPUT_RESET]);\n\n            }\n\n        }\n\n        opp->pint = val;\n\n        break;\n\n    case 0x10A0: /* IPI_IPVP */\n\n    case 0x10B0:\n\n    case 0x10C0:\n\n    case 0x10D0:\n\n        {\n\n            int idx;\n\n            idx = (addr - 0x10A0) >> 4;\n\n            write_IRQreg_ipvp(opp, opp->irq_ipi0 + idx, val);\n\n        }\n\n        break;\n\n    case 0x10E0: /* SPVE */\n\n        opp->spve = val & opp->vector_mask;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 23887}
{"project": "qemu", "commit_id": "fbeadf50f2f965741def823036b086bbc2999b1f", "target": 1, "func": "unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,\n\n\t\t\t\t unsigned long offset)\n\n{\n\n    const unsigned long *p = addr + BITOP_WORD(offset);\n\n    unsigned long result = offset & ~(BITS_PER_LONG-1);\n\n    unsigned long tmp;\n\n\n\n    if (offset >= size) {\n\n        return size;\n\n    }\n\n    size -= result;\n\n    offset %= BITS_PER_LONG;\n\n    if (offset) {\n\n        tmp = *(p++);\n\n        tmp |= ~0UL >> (BITS_PER_LONG - offset);\n\n        if (size < BITS_PER_LONG) {\n\n            goto found_first;\n\n        }\n\n        if (~tmp) {\n\n            goto found_middle;\n\n        }\n\n        size -= BITS_PER_LONG;\n\n        result += BITS_PER_LONG;\n\n    }\n\n    while (size & ~(BITS_PER_LONG-1)) {\n\n        if (~(tmp = *(p++))) {\n\n            goto found_middle;\n\n        }\n\n        result += BITS_PER_LONG;\n\n        size -= BITS_PER_LONG;\n\n    }\n\n    if (!size) {\n\n        return result;\n\n    }\n\n    tmp = *p;\n\n\n\nfound_first:\n\n    tmp |= ~0UL << size;\n\n    if (tmp == ~0UL) {\t/* Are any bits zero? */\n\n        return result + size;\t/* Nope. */\n\n    }\n\nfound_middle:\n\n    return result + ffz(tmp);\n\n}\n", "idx": 23888}
{"project": "qemu", "commit_id": "0ccb9c1d8128a020720d5c6abf99a470742a1b94", "target": 1, "func": "void HELPER(divs)(CPUM68KState *env, uint32_t word)\n\n{\n\n    int32_t num;\n\n    int32_t den;\n\n    int32_t quot;\n\n    int32_t rem;\n\n\n\n    num = env->div1;\n\n    den = env->div2;\n\n    if (den == 0) {\n\n        raise_exception(env, EXCP_DIV0);\n\n    }\n\n    quot = num / den;\n\n    rem = num % den;\n\n\n\n    env->cc_v = (word && quot != (int16_t)quot ? -1 : 0);\n\n    env->cc_z = quot;\n\n    env->cc_n = quot;\n\n    env->cc_c = 0;\n\n\n\n    env->div1 = quot;\n\n    env->div2 = rem;\n\n}\n", "idx": 23890}
{"project": "qemu", "commit_id": "c3adb5b9168a57790b5074489b6f0275ac3cc8b5", "target": 1, "func": "static void dma_bdrv_cb(void *opaque, int ret)\n\n{\n\n    DMAAIOCB *dbs = (DMAAIOCB *)opaque;\n\n    target_phys_addr_t cur_addr, cur_len;\n\n    void *mem;\n\n\n\n    dbs->acb = NULL;\n\n    dbs->sector_num += dbs->iov.size / 512;\n\n    dma_bdrv_unmap(dbs);\n\n    qemu_iovec_reset(&dbs->iov);\n\n\n\n    if (dbs->sg_cur_index == dbs->sg->nsg || ret < 0) {\n\n        dbs->common.cb(dbs->common.opaque, ret);\n\n        qemu_iovec_destroy(&dbs->iov);\n\n        qemu_aio_release(dbs);\n\n        return;\n\n    }\n\n\n\n    while (dbs->sg_cur_index < dbs->sg->nsg) {\n\n        cur_addr = dbs->sg->sg[dbs->sg_cur_index].base + dbs->sg_cur_byte;\n\n        cur_len = dbs->sg->sg[dbs->sg_cur_index].len - dbs->sg_cur_byte;\n\n        mem = cpu_physical_memory_map(cur_addr, &cur_len, !dbs->to_dev);\n\n        if (!mem)\n\n            break;\n\n        qemu_iovec_add(&dbs->iov, mem, cur_len);\n\n        dbs->sg_cur_byte += cur_len;\n\n        if (dbs->sg_cur_byte == dbs->sg->sg[dbs->sg_cur_index].len) {\n\n            dbs->sg_cur_byte = 0;\n\n            ++dbs->sg_cur_index;\n\n        }\n\n    }\n\n\n\n    if (dbs->iov.size == 0) {\n\n        cpu_register_map_client(dbs, continue_after_map_failure);\n\n        return;\n\n    }\n\n\n\n    dbs->acb = dbs->io_func(dbs->bs, dbs->sector_num, &dbs->iov,\n\n                            dbs->iov.size / 512, dma_bdrv_cb, dbs);\n\n    if (!dbs->acb) {\n\n        dma_bdrv_unmap(dbs);\n\n        qemu_iovec_destroy(&dbs->iov);\n\n        return;\n\n    }\n\n}\n", "idx": 23891}
{"project": "qemu", "commit_id": "36b62ae6a58f9a588fd33be9386e18a2b90103f5", "target": 1, "func": "static uint64_t fw_cfg_data_mem_read(void *opaque, hwaddr addr,\n\n                                     unsigned size)\n\n{\n\n    FWCfgState *s = opaque;\n\n    uint8_t buf[8];\n\n    unsigned i;\n\n\n\n    for (i = 0; i < size; ++i) {\n\n        buf[i] = fw_cfg_read(s);\n\n    }\n\n    switch (size) {\n\n    case 1:\n\n        return buf[0];\n\n    case 2:\n\n        return lduw_he_p(buf);\n\n    case 4:\n\n        return (uint32_t)ldl_he_p(buf);\n\n    case 8:\n\n        return ldq_he_p(buf);\n\n    }\n\n    abort();\n\n}\n", "idx": 23892}
{"project": "qemu", "commit_id": "dc491fead04a92a612df93b85b0ebf9dcc3f6684", "target": 1, "func": "static void test_redirector_rx(void)\n\n{\n\n#ifndef _WIN32\n\n/* socketpair(PF_UNIX) which does not exist on windows */\n\n\n\n    int backend_sock[2], send_sock;\n\n    char *cmdline;\n\n    uint32_t ret = 0, len = 0;\n\n    char send_buf[] = \"Hello!!\";\n\n    char sock_path0[] = \"filter-redirector0.XXXXXX\";\n\n    char sock_path1[] = \"filter-redirector1.XXXXXX\";\n\n    char *recv_buf;\n\n    uint32_t size = sizeof(send_buf);\n\n    size = htonl(size);\n\n\n\n    ret = socketpair(PF_UNIX, SOCK_STREAM, 0, backend_sock);\n\n    g_assert_cmpint(ret, !=, -1);\n\n\n\n    ret = mkstemp(sock_path0);\n\n    g_assert_cmpint(ret, !=, -1);\n\n    ret = mkstemp(sock_path1);\n\n    g_assert_cmpint(ret, !=, -1);\n\n\n\n    cmdline = g_strdup_printf(\"-netdev socket,id=qtest-bn0,fd=%d \"\n\n                \"-device rtl8139,netdev=qtest-bn0,id=qtest-e0 \"\n\n                \"-chardev socket,id=redirector0,path=%s,server,nowait \"\n\n                \"-chardev socket,id=redirector1,path=%s,server,nowait \"\n\n                \"-chardev socket,id=redirector2,path=%s,nowait \"\n\n                \"-object filter-redirector,id=qtest-f0,netdev=qtest-bn0,\"\n\n                \"queue=rx,indev=redirector0 \"\n\n                \"-object filter-redirector,id=qtest-f1,netdev=qtest-bn0,\"\n\n                \"queue=rx,outdev=redirector2 \"\n\n                \"-object filter-redirector,id=qtest-f2,netdev=qtest-bn0,\"\n\n                \"queue=rx,indev=redirector1 \"\n\n                , backend_sock[1], sock_path0, sock_path1, sock_path0);\n\n    qtest_start(cmdline);\n\n    g_free(cmdline);\n\n\n\n    struct iovec iov[] = {\n\n        {\n\n            .iov_base = &size,\n\n            .iov_len = sizeof(size),\n\n        }, {\n\n            .iov_base = send_buf,\n\n            .iov_len = sizeof(send_buf),\n\n        },\n\n    };\n\n\n\n    send_sock = unix_connect(sock_path1, NULL);\n\n    g_assert_cmpint(send_sock, !=, -1);\n\n    /* send a qmp command to guarantee that 'connected' is setting to true. */\n\n    qmp(\"{ 'execute' : 'query-status'}\");\n\n\n\n    ret = iov_send(send_sock, iov, 2, 0, sizeof(size) + sizeof(send_buf));\n\n    g_assert_cmpint(ret, ==, sizeof(send_buf) + sizeof(size));\n\n    close(send_sock);\n\n\n\n    ret = qemu_recv(backend_sock[0], &len, sizeof(len), 0);\n\n    g_assert_cmpint(ret, ==, sizeof(len));\n\n    len = ntohl(len);\n\n\n\n    g_assert_cmpint(len, ==, sizeof(send_buf));\n\n    recv_buf = g_malloc(len);\n\n    ret = qemu_recv(backend_sock[0], recv_buf, len, 0);\n\n    g_assert_cmpstr(recv_buf, ==, send_buf);\n\n\n\n    g_free(recv_buf);\n\n    unlink(sock_path0);\n\n    unlink(sock_path1);\n\n    qtest_end();\n\n\n\n#endif\n\n}\n", "idx": 23893}
{"project": "qemu", "commit_id": "38ee14f4f33f8836fc0e209ca59c6ae8c6edf380", "target": 1, "func": "static void vnc_refresh(DisplayChangeListener *dcl)\n\n{\n\n    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);\n\n    VncState *vs, *vn;\n\n    int has_dirty, rects = 0;\n\n\n\n    graphic_hw_update(NULL);\n\n\n\n    if (vnc_trylock_display(vd)) {\n\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n\n        return;\n\n    }\n\n\n\n    has_dirty = vnc_refresh_server_surface(vd);\n\n    vnc_unlock_display(vd);\n\n\n\n    QTAILQ_FOREACH_SAFE(vs, &vd->clients, next, vn) {\n\n        rects += vnc_update_client(vs, has_dirty);\n\n        /* vs might be free()ed here */\n\n    }\n\n\n\n    if (QTAILQ_EMPTY(&vd->clients)) {\n\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_MAX);\n\n        return;\n\n    }\n\n\n\n    if (has_dirty && rects) {\n\n        vd->dcl.update_interval /= 2;\n\n        if (vd->dcl.update_interval < VNC_REFRESH_INTERVAL_BASE) {\n\n            vd->dcl.update_interval = VNC_REFRESH_INTERVAL_BASE;\n\n        }\n\n    } else {\n\n        vd->dcl.update_interval += VNC_REFRESH_INTERVAL_INC;\n\n        if (vd->dcl.update_interval > VNC_REFRESH_INTERVAL_MAX) {\n\n            vd->dcl.update_interval = VNC_REFRESH_INTERVAL_MAX;\n\n        }\n\n    }\n\n}\n", "idx": 23894}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_end_implicit_struct(Visitor *v, Error **errp)\n\n{\n\n    assert(!error_is_set(errp));\n\n    if (v->end_implicit_struct) {\n\n        v->end_implicit_struct(v, errp);\n\n    }\n\n}\n", "idx": 23895}
{"project": "qemu", "commit_id": "6658ffb81ee56a510d7d77025872a508a9adce3a", "target": 1, "func": "int tlb_set_page_exec(CPUState *env, target_ulong vaddr, \n                      target_phys_addr_t paddr, int prot, \n                      int is_user, int is_softmmu)\n{\n    PhysPageDesc *p;\n    unsigned long pd;\n    unsigned int index;\n    target_ulong address;\n    target_phys_addr_t addend;\n    int ret;\n    CPUTLBEntry *te;\n    int i;\n    p = phys_page_find(paddr >> TARGET_PAGE_BITS);\n    if (!p) {\n        pd = IO_MEM_UNASSIGNED;\n        pd = p->phys_offset;\n#if defined(DEBUG_TLB)\n    printf(\"tlb_set_page: vaddr=\" TARGET_FMT_lx \" paddr=0x%08x prot=%x u=%d smmu=%d pd=0x%08lx\\n\",\n           vaddr, (int)paddr, prot, is_user, is_softmmu, pd);\n#endif\n    ret = 0;\n#if !defined(CONFIG_SOFTMMU)\n    if (is_softmmu) \n#endif\n    {\n        if ((pd & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !(pd & IO_MEM_ROMD)) {\n            /* IO memory case */\n            address = vaddr | pd;\n            addend = paddr;\n            /* standard memory */\n            address = vaddr;\n            addend = (unsigned long)phys_ram_base + (pd & TARGET_PAGE_MASK);\n        index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n        addend -= vaddr;\n        te = &env->tlb_table[is_user][index];\n        te->addend = addend;\n        if (prot & PAGE_READ) {\n            te->addr_read = address;\n            te->addr_read = -1;\n        if (prot & PAGE_EXEC) {\n            te->addr_code = address;\n            te->addr_code = -1;\n        if (prot & PAGE_WRITE) {\n            if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_ROM || \n                (pd & IO_MEM_ROMD)) {\n                /* write access calls the I/O callback */\n                te->addr_write = vaddr | \n                    (pd & ~(TARGET_PAGE_MASK | IO_MEM_ROMD));\n            } else if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM && \n                       !cpu_physical_memory_is_dirty(pd)) {\n                te->addr_write = vaddr | IO_MEM_NOTDIRTY;\n                te->addr_write = address;\n            te->addr_write = -1;\n#if !defined(CONFIG_SOFTMMU)\n    else {\n        if ((pd & ~TARGET_PAGE_MASK) > IO_MEM_ROM) {\n            /* IO access: no mapping is done as it will be handled by the\n               soft MMU */\n            if (!(env->hflags & HF_SOFTMMU_MASK))\n                ret = 2;\n            void *map_addr;\n            if (vaddr >= MMAP_AREA_END) {\n                ret = 2;\n                if (prot & PROT_WRITE) {\n                    if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_ROM || \n#if defined(TARGET_HAS_SMC) || 1\n                        first_tb ||\n#endif\n                        ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM && \n                         !cpu_physical_memory_is_dirty(pd))) {\n                        /* ROM: we do as if code was inside */\n                        /* if code is present, we only map as read only and save the\n                           original mapping */\n                        VirtPageDesc *vp;\n                        vp = virt_page_find_alloc(vaddr >> TARGET_PAGE_BITS, 1);\n                        vp->phys_addr = pd;\n                        vp->prot = prot;\n                        vp->valid_tag = virt_valid_tag;\n                        prot &= ~PAGE_WRITE;\n                map_addr = mmap((void *)vaddr, TARGET_PAGE_SIZE, prot, \n                                MAP_SHARED | MAP_FIXED, phys_ram_fd, (pd & TARGET_PAGE_MASK));\n                if (map_addr == MAP_FAILED) {\n                    cpu_abort(env, \"mmap failed when mapped physical address 0x%08x to virtual address 0x%08x\\n\",\n                              paddr, vaddr);\n#endif\n    return ret;", "idx": 23896}
{"project": "qemu", "commit_id": "4f4896db5fb2285df016ff927508560c89b845a4", "target": 1, "func": "static void qed_aio_write_inplace(QEDAIOCB *acb, uint64_t offset, size_t len)\n\n{\n\n    /* Allocate buffer for zero writes */\n\n    if (acb->flags & QED_AIOCB_ZERO) {\n\n        struct iovec *iov = acb->qiov->iov;\n\n\n\n        if (!iov->iov_base) {\n\n            iov->iov_base = qemu_blockalign(acb->common.bs, iov->iov_len);\n\n            memset(iov->iov_base, 0, iov->iov_len);\n\n        }\n\n    }\n\n\n\n    /* Calculate the I/O vector */\n\n    acb->cur_cluster = offset;\n\n    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);\n\n\n\n    /* Do the actual write */\n\n    qed_aio_write_main(acb, 0);\n\n}\n", "idx": 23897}
{"project": "qemu", "commit_id": "894e02804c862c6940b43a0a488164655d3fb3f0", "target": 1, "func": "static int nbd_reject_length(NBDClient *client, bool fatal, Error **errp)\n\n{\n\n    int ret;\n\n\n\n    assert(client->optlen);\n\n    if (nbd_drop(client->ioc, client->optlen, errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    ret = nbd_negotiate_send_rep_err(client, NBD_REP_ERR_INVALID, errp,\n\n                                     \"option '%s' should have zero length\",\n\n                                     nbd_opt_lookup(client->opt));\n\n    if (fatal && !ret) {\n\n        error_setg(errp, \"option '%s' should have zero length\",\n\n                   nbd_opt_lookup(client->opt));\n\n        return -EINVAL;\n\n    }\n\n    return ret;\n\n}\n", "idx": 23899}
{"project": "qemu", "commit_id": "1a71992376792a0d11ea27688bd1a21cdffd1826", "target": 1, "func": "static void do_ext_interrupt(CPUS390XState *env)\n\n{\n\n    S390CPU *cpu = s390_env_get_cpu(env);\n\n    uint64_t mask, addr;\n\n    LowCore *lowcore;\n\n    ExtQueue *q;\n\n\n\n    if (!(env->psw.mask & PSW_MASK_EXT)) {\n\n        cpu_abort(CPU(cpu), \"Ext int w/o ext mask\\n\");\n\n    }\n\n\n\n    if (env->ext_index < 0 || env->ext_index > MAX_EXT_QUEUE) {\n\n        cpu_abort(CPU(cpu), \"Ext queue overrun: %d\\n\", env->ext_index);\n\n    }\n\n\n\n    q = &env->ext_queue[env->ext_index];\n\n    lowcore = cpu_map_lowcore(env);\n\n\n\n    lowcore->ext_int_code = cpu_to_be16(q->code);\n\n    lowcore->ext_params = cpu_to_be32(q->param);\n\n    lowcore->ext_params2 = cpu_to_be64(q->param64);\n\n    lowcore->external_old_psw.mask = cpu_to_be64(get_psw_mask(env));\n\n    lowcore->external_old_psw.addr = cpu_to_be64(env->psw.addr);\n\n    lowcore->cpu_addr = cpu_to_be16(env->cpu_num | VIRTIO_SUBCODE_64);\n\n    mask = be64_to_cpu(lowcore->external_new_psw.mask);\n\n    addr = be64_to_cpu(lowcore->external_new_psw.addr);\n\n\n\n    cpu_unmap_lowcore(lowcore);\n\n\n\n    env->ext_index--;\n\n    if (env->ext_index == -1) {\n\n        env->pending_int &= ~INTERRUPT_EXT;\n\n    }\n\n\n\n    DPRINTF(\"%s: %\" PRIx64 \" %\" PRIx64 \"\\n\", __func__,\n\n            env->psw.mask, env->psw.addr);\n\n\n\n    load_psw(env, mask, addr);\n\n}\n", "idx": 23901}
{"project": "qemu", "commit_id": "b45c03f585ea9bb1af76c73e82195418c294919d", "target": 1, "func": "static struct omap_rtc_s *omap_rtc_init(MemoryRegion *system_memory,\n\n                                        hwaddr base,\n\n                                        qemu_irq timerirq, qemu_irq alarmirq,\n\n                                        omap_clk clk)\n\n{\n\n    struct omap_rtc_s *s = (struct omap_rtc_s *)\n\n            g_malloc0(sizeof(struct omap_rtc_s));\n\n\n\n    s->irq = timerirq;\n\n    s->alarm = alarmirq;\n\n    s->clk = timer_new_ms(rtc_clock, omap_rtc_tick, s);\n\n\n\n    omap_rtc_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &omap_rtc_ops, s,\n\n                          \"omap-rtc\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 23902}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mtmsrd(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    if (ctx->opcode & 0x00010000) {\n\n        /* Special form that does not need any synchronisation */\n\n        TCGv t0 = tcg_temp_new();\n\n        tcg_gen_andi_tl(t0, cpu_gpr[rS(ctx->opcode)], (1 << MSR_RI) | (1 << MSR_EE));\n\n        tcg_gen_andi_tl(cpu_msr, cpu_msr, ~(target_ulong)((1 << MSR_RI) | (1 << MSR_EE)));\n\n        tcg_gen_or_tl(cpu_msr, cpu_msr, t0);\n\n        tcg_temp_free(t0);\n\n    } else {\n\n        /* XXX: we need to update nip before the store\n\n         *      if we enter power saving mode, we will exit the loop\n\n         *      directly from ppc_store_msr\n\n         */\n\n        gen_update_nip(ctx, ctx->nip);\n\n        gen_helper_store_msr(cpu_env, cpu_gpr[rS(ctx->opcode)]);\n\n        /* Must stop the translation as machine state (may have) changed */\n\n        /* Note that mtmsr is not always defined as context-synchronizing */\n\n        gen_stop_exception(ctx);\n\n    }\n\n#endif\n\n}\n", "idx": 23904}
{"project": "qemu", "commit_id": "751f8cfe2a556b3ef49f6af2860e2d1d2a1ec66a", "target": 1, "func": "int monitor_set_cpu(int cpu_index)\n\n{\n\n    CPUState *cpu;\n\n\n\n    cpu = qemu_get_cpu(cpu_index);\n\n    if (cpu == NULL) {\n\n        return -1;\n\n    }\n\n    cur_mon->mon_cpu = cpu;\n\n    return 0;\n\n}\n", "idx": 23911}
{"project": "qemu", "commit_id": "57be80f948cdbb75ef00fd8345845d83010d8af1", "target": 1, "func": "static int kvmppc_read_host_property(const char *node_path, const char *prop,\n\n                                     void *val, size_t len)\n\n{\n\n    char *path;\n\n    FILE *f;\n\n    int ret;\n\n    int pathlen;\n\n\n\n    pathlen = snprintf(NULL, 0, \"%s/%s/%s\", PROC_DEVTREE_PATH, node_path, prop)\n\n              + 1;\n\n    path = qemu_malloc(pathlen);\n\n    if (path == NULL) {\n\n        ret = -ENOMEM;\n\n        goto out;\n\n    }\n\n\n\n    snprintf(path, pathlen, \"%s/%s/%s\", PROC_DEVTREE_PATH, node_path, prop);\n\n\n\n    f = fopen(path, \"rb\");\n\n    if (f == NULL) {\n\n        ret = errno;\n\n        goto free;\n\n    }\n\n\n\n    len = fread(val, len, 1, f);\n\n    if (len != 1) {\n\n        ret = ferror(f);\n\n        goto close;\n\n    }\n\n\n\nclose:\n\n    fclose(f);\n\nfree:\n\n    free(path);\n\nout:\n\n    return ret;\n\n}\n", "idx": 23912}
{"project": "qemu", "commit_id": "27af7d6ea5015e5ef1f7985eab94a8a218267a2b", "target": 1, "func": "int cache_insert(PageCache *cache, uint64_t addr, const uint8_t *pdata)\n\n{\n\n\n\n    CacheItem *it = NULL;\n\n\n\n    g_assert(cache);\n\n    g_assert(cache->page_cache);\n\n\n\n    /* actual update of entry */\n\n    it = cache_get_by_addr(cache, addr);\n\n\n\n    /* allocate page */\n\n    if (!it->it_data) {\n\n        it->it_data = g_try_malloc(cache->page_size);\n\n        if (!it->it_data) {\n\n            DPRINTF(\"Error allocating page\\n\");\n\n            return -1;\n\n        }\n\n        cache->num_items++;\n\n    }\n\n\n\n    memcpy(it->it_data, pdata, cache->page_size);\n\n\n\n    it->it_age = ++cache->max_item_age;\n\n    it->it_addr = addr;\n\n\n\n    return 0;\n\n}\n", "idx": 23914}
{"project": "qemu", "commit_id": "5c32be5baf41aec4f4675d2bf24f9948756abf3c", "target": 1, "func": "static void tcg_out_qemu_ld(TCGContext *s, TCGReg data, TCGReg addr,\n\n                            TCGMemOpIdx oi, bool is_64)\n\n{\n\n    TCGMemOp memop = get_memop(oi);\n\n#ifdef CONFIG_SOFTMMU\n\n    unsigned memi = get_mmuidx(oi);\n\n    TCGReg addrz, param;\n\n    tcg_insn_unit *func;\n\n    tcg_insn_unit *label_ptr;\n\n\n\n    addrz = tcg_out_tlb_load(s, addr, memi, memop,\n\n                             offsetof(CPUTLBEntry, addr_read));\n\n\n\n    /* The fast path is exactly one insn.  Thus we can perform the\n\n       entire TLB Hit in the (annulled) delay slot of the branch\n\n       over the TLB Miss case.  */\n\n\n\n    /* beq,a,pt %[xi]cc, label0 */\n\n    label_ptr = s->code_ptr;\n\n    tcg_out_bpcc0(s, COND_E, BPCC_A | BPCC_PT\n\n                  | (TARGET_LONG_BITS == 64 ? BPCC_XCC : BPCC_ICC), 0);\n\n    /* delay slot */\n\n    tcg_out_ldst_rr(s, data, addrz, TCG_REG_O1,\n\n                    qemu_ld_opc[memop & (MO_BSWAP | MO_SSIZE)]);\n\n\n\n    /* TLB Miss.  */\n\n\n\n    param = TCG_REG_O1;\n\n    if (!SPARC64 && TARGET_LONG_BITS == 64) {\n\n        /* Skip the high-part; we'll perform the extract in the trampoline.  */\n\n        param++;\n\n    }\n\n    tcg_out_mov(s, TCG_TYPE_REG, param++, addr);\n\n\n\n    /* We use the helpers to extend SB and SW data, leaving the case\n\n       of SL needing explicit extending below.  */\n\n    if ((memop & MO_SSIZE) == MO_SL) {\n\n        func = qemu_ld_trampoline[memop & (MO_BSWAP | MO_SIZE)];\n\n    } else {\n\n        func = qemu_ld_trampoline[memop & (MO_BSWAP | MO_SSIZE)];\n\n    }\n\n    tcg_debug_assert(func != NULL);\n\n    tcg_out_call_nodelay(s, func);\n\n    /* delay slot */\n\n    tcg_out_movi(s, TCG_TYPE_I32, param, oi);\n\n\n\n    /* Recall that all of the helpers return 64-bit results.\n\n       Which complicates things for sparcv8plus.  */\n\n    if (SPARC64) {\n\n        /* We let the helper sign-extend SB and SW, but leave SL for here.  */\n\n        if (is_64 && (memop & MO_SSIZE) == MO_SL) {\n\n            tcg_out_arithi(s, data, TCG_REG_O0, 0, SHIFT_SRA);\n\n        } else {\n\n            tcg_out_mov(s, TCG_TYPE_REG, data, TCG_REG_O0);\n\n        }\n\n    } else {\n\n        if ((memop & MO_SIZE) == MO_64) {\n\n            tcg_out_arithi(s, TCG_REG_O0, TCG_REG_O0, 32, SHIFT_SLLX);\n\n            tcg_out_arithi(s, TCG_REG_O1, TCG_REG_O1, 0, SHIFT_SRL);\n\n            tcg_out_arith(s, data, TCG_REG_O0, TCG_REG_O1, ARITH_OR);\n\n        } else if (is_64) {\n\n            /* Re-extend from 32-bit rather than reassembling when we\n\n               know the high register must be an extension.  */\n\n            tcg_out_arithi(s, data, TCG_REG_O1, 0,\n\n                           memop & MO_SIGN ? SHIFT_SRA : SHIFT_SRL);\n\n        } else {\n\n            tcg_out_mov(s, TCG_TYPE_I32, data, TCG_REG_O1);\n\n        }\n\n    }\n\n\n\n    *label_ptr |= INSN_OFF19(tcg_ptr_byte_diff(s->code_ptr, label_ptr));\n\n#else\n\n    if (SPARC64 && TARGET_LONG_BITS == 32) {\n\n        tcg_out_arithi(s, TCG_REG_T1, addr, 0, SHIFT_SRL);\n\n        addr = TCG_REG_T1;\n\n    }\n\n    tcg_out_ldst_rr(s, data, addr,\n\n                    (guest_base ? TCG_GUEST_BASE_REG : TCG_REG_G0),\n\n                    qemu_ld_opc[memop & (MO_BSWAP | MO_SSIZE)]);\n\n#endif /* CONFIG_SOFTMMU */\n\n}\n", "idx": 23916}
{"project": "qemu", "commit_id": "3178e2755ec5a7fb1afe583fb6ac2622c2c42184", "target": 1, "func": "static int sd_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    int ret, fd;\n\n    uint32_t vid = 0;\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    char vdi[SD_MAX_VDI_LEN], tag[SD_MAX_VDI_TAG_LEN];\n\n    uint32_t snapid;\n\n    char *buf = NULL;\n\n\n\n    strstart(filename, \"sheepdog:\", (const char **)&filename);\n\n\n\n    QLIST_INIT(&s->inflight_aio_head);\n\n    QLIST_INIT(&s->pending_aio_head);\n\n    s->fd = -1;\n\n\n\n    memset(vdi, 0, sizeof(vdi));\n\n    memset(tag, 0, sizeof(tag));\n\n    if (parse_vdiname(s, filename, vdi, &snapid, tag) < 0) {\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n    s->fd = get_sheep_fd(s);\n\n    if (s->fd < 0) {\n\n        ret = s->fd;\n\n        goto out;\n\n    }\n\n\n\n    ret = find_vdi_name(s, vdi, snapid, tag, &vid, 0);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    s->cache_enabled = 1;\n\n    s->flush_fd = connect_to_sdog(s->addr, s->port);\n\n    if (s->flush_fd < 0) {\n\n        error_report(\"failed to connect\");\n\n        ret = s->flush_fd;\n\n        goto out;\n\n    }\n\n\n\n    if (snapid || tag[0] != '\\0') {\n\n        dprintf(\"%\" PRIx32 \" snapshot inode was open.\\n\", vid);\n\n        s->is_snapshot = 1;\n\n    }\n\n\n\n    fd = connect_to_sdog(s->addr, s->port);\n\n    if (fd < 0) {\n\n        error_report(\"failed to connect\");\n\n        ret = fd;\n\n        goto out;\n\n    }\n\n\n\n    buf = g_malloc(SD_INODE_SIZE);\n\n    ret = read_object(fd, buf, vid_to_vdi_oid(vid), 0, SD_INODE_SIZE, 0,\n\n                      s->cache_enabled);\n\n\n\n    closesocket(fd);\n\n\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    memcpy(&s->inode, buf, sizeof(s->inode));\n\n    s->min_dirty_data_idx = UINT32_MAX;\n\n    s->max_dirty_data_idx = 0;\n\n\n\n    bs->total_sectors = s->inode.vdi_size / SECTOR_SIZE;\n\n    strncpy(s->name, vdi, sizeof(s->name));\n\n    qemu_co_mutex_init(&s->lock);\n\n    g_free(buf);\n\n    return 0;\n\nout:\n\n    qemu_aio_set_fd_handler(s->fd, NULL, NULL, NULL, NULL);\n\n    if (s->fd >= 0) {\n\n        closesocket(s->fd);\n\n    }\n\n    g_free(buf);\n\n    return ret;\n\n}\n", "idx": 23917}
{"project": "qemu", "commit_id": "e36c87667aa2204a3f19efe7bbcb6eb41f098e40", "target": 1, "func": "opts_visitor_cleanup(OptsVisitor *ov)\n\n{\n\n    if (ov->unprocessed_opts != NULL) {\n\n        g_hash_table_destroy(ov->unprocessed_opts);\n\n    }\n\n    g_free(ov->fake_id_opt);\n\n    memset(ov, '\\0', sizeof *ov);\n\n}\n", "idx": 23918}
{"project": "qemu", "commit_id": "2b880bcdbeb87b9cb4e325dd6e872373458f82d9", "target": 1, "func": "static void qvirtio_9p_pci_stop(QVirtIO9P *v9p)\n\n{\n\n    qvirtqueue_cleanup(v9p->dev->bus, v9p->vq, v9p->qs->alloc);\n\n    qvirtio_pci_device_disable(container_of(v9p->dev, QVirtioPCIDevice, vdev));\n\n    g_free(v9p->dev);\n\n    qvirtio_9p_stop(v9p);\n\n}\n", "idx": 23919}
{"project": "qemu", "commit_id": "7d553f27fce284805d7f94603932045ee3bbb979", "target": 0, "func": "static int usb_host_open(USBHostDevice *s, libusb_device *dev)\n\n{\n\n    USBDevice *udev = USB_DEVICE(s);\n\n    int bus_num = libusb_get_bus_number(dev);\n\n    int addr    = libusb_get_device_address(dev);\n\n    int rc;\n\n\n\n    trace_usb_host_open_started(bus_num, addr);\n\n\n\n    if (s->dh != NULL) {\n\n        goto fail;\n\n    }\n\n    rc = libusb_open(dev, &s->dh);\n\n    if (rc != 0) {\n\n        goto fail;\n\n    }\n\n\n\n    s->dev     = dev;\n\n    s->bus_num = bus_num;\n\n    s->addr    = addr;\n\n\n\n    usb_host_detach_kernel(s);\n\n\n\n    libusb_get_device_descriptor(dev, &s->ddesc);\n\n    usb_host_get_port(s->dev, s->port, sizeof(s->port));\n\n\n\n    usb_ep_init(udev);\n\n    usb_host_ep_update(s);\n\n\n\n    udev->speed     = speed_map[libusb_get_device_speed(dev)];\n\n    usb_host_speed_compat(s);\n\n\n\n    if (s->ddesc.iProduct) {\n\n        libusb_get_string_descriptor_ascii(s->dh, s->ddesc.iProduct,\n\n                                           (unsigned char *)udev->product_desc,\n\n                                           sizeof(udev->product_desc));\n\n    } else {\n\n        snprintf(udev->product_desc, sizeof(udev->product_desc),\n\n                 \"host:%d.%d\", bus_num, addr);\n\n    }\n\n\n\n    rc = usb_device_attach(udev);\n\n    if (rc) {\n\n        goto fail;\n\n    }\n\n\n\n    trace_usb_host_open_success(bus_num, addr);\n\n    return 0;\n\n\n\nfail:\n\n    trace_usb_host_open_failure(bus_num, addr);\n\n    if (s->dh != NULL) {\n\n        libusb_close(s->dh);\n\n        s->dh = NULL;\n\n        s->dev = NULL;\n\n    }\n\n    return -1;\n\n}\n", "idx": 23922}
{"project": "qemu", "commit_id": "4407c1c56adb0d3ef2bcbf577592d72278d6e11f", "target": 0, "func": "static void virtio_blk_dma_restart_cb(void *opaque, int running,\n\n                                      RunState state)\n\n{\n\n    VirtIOBlock *s = opaque;\n\n\n\n    if (!running) {\n\n        return;\n\n    }\n\n\n\n    if (!s->bh) {\n\n        s->bh = qemu_bh_new(virtio_blk_dma_restart_bh, s);\n\n        qemu_bh_schedule(s->bh);\n\n    }\n\n}\n", "idx": 23923}
{"project": "qemu", "commit_id": "2a313e5cf6ed90b932b0abe2b4f2055785397f93", "target": 0, "func": "int64_t xbzrle_cache_resize(int64_t new_size, Error **errp)\n\n{\n\n    PageCache *new_cache;\n\n    int64_t ret;\n\n\n\n    /* Check for truncation */\n\n    if (new_size != (size_t)new_size) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                   \"exceeding address space\");\n\n        return -1;\n\n    }\n\n\n\n    /* Cache should not be larger than guest ram size */\n\n    if (new_size > ram_bytes_total()) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                   \"exceeds guest ram size\");\n\n        return -1;\n\n    }\n\n\n\n    XBZRLE_cache_lock();\n\n\n\n    if (XBZRLE.cache != NULL) {\n\n        if (pow2floor(new_size) == migrate_xbzrle_cache_size()) {\n\n            goto out_new_size;\n\n        }\n\n        new_cache = cache_init(new_size, TARGET_PAGE_SIZE, errp);\n\n        if (!new_cache) {\n\n            ret = -1;\n\n            goto out;\n\n        }\n\n\n\n        cache_fini(XBZRLE.cache);\n\n        XBZRLE.cache = new_cache;\n\n    }\n\n\n\nout_new_size:\n\n    ret = pow2floor(new_size);\n\nout:\n\n    XBZRLE_cache_unlock();\n\n    return ret;\n\n}\n", "idx": 23924}
{"project": "qemu", "commit_id": "cc5d0e04ee313d0ceee5d8e4e697142eaf240dca", "target": 0, "func": "int parse_debug_env(const char *name, int max, int initial)\n\n{\n\n    char *debug_env = getenv(name);\n\n    char *inv = NULL;\n\n    int debug;\n\n\n\n    if (!debug_env) {\n\n        return initial;\n\n    }\n\n    debug = strtol(debug_env, &inv, 10);\n\n    if (inv == debug_env) {\n\n        return initial;\n\n    }\n\n    if (debug < 0 || debug > max) {\n\n        fprintf(stderr, \"warning: %s not in [0, %d]\", name, max);\n\n        return initial;\n\n    }\n\n    return debug;\n\n}\n", "idx": 23925}
{"project": "qemu", "commit_id": "698feb5e13a2d763369909ce33f2bd7a7c1c11c0", "target": 0, "func": "static void vfio_listener_region_del(MemoryListener *listener,\n\n                                     MemoryRegionSection *section)\n\n{\n\n    VFIOContainer *container = container_of(listener, VFIOContainer, listener);\n\n    hwaddr iova, end;\n\n    Int128 llend, llsize;\n\n    int ret;\n\n\n\n    if (vfio_listener_skipped_section(section)) {\n\n        trace_vfio_listener_region_del_skip(\n\n                section->offset_within_address_space,\n\n                section->offset_within_address_space +\n\n                int128_get64(int128_sub(section->size, int128_one())));\n\n        return;\n\n    }\n\n\n\n    if (unlikely((section->offset_within_address_space & ~TARGET_PAGE_MASK) !=\n\n                 (section->offset_within_region & ~TARGET_PAGE_MASK))) {\n\n        error_report(\"%s received unaligned region\", __func__);\n\n        return;\n\n    }\n\n\n\n    if (memory_region_is_iommu(section->mr)) {\n\n        VFIOGuestIOMMU *giommu;\n\n\n\n        QLIST_FOREACH(giommu, &container->giommu_list, giommu_next) {\n\n            if (giommu->iommu == section->mr) {\n\n                memory_region_unregister_iommu_notifier(giommu->iommu,\n\n                                                        &giommu->n);\n\n                QLIST_REMOVE(giommu, giommu_next);\n\n                g_free(giommu);\n\n                break;\n\n            }\n\n        }\n\n\n\n        /*\n\n         * FIXME: We assume the one big unmap below is adequate to\n\n         * remove any individual page mappings in the IOMMU which\n\n         * might have been copied into VFIO. This works for a page table\n\n         * based IOMMU where a big unmap flattens a large range of IO-PTEs.\n\n         * That may not be true for all IOMMU types.\n\n         */\n\n    }\n\n\n\n    iova = TARGET_PAGE_ALIGN(section->offset_within_address_space);\n\n    llend = int128_make64(section->offset_within_address_space);\n\n    llend = int128_add(llend, section->size);\n\n    llend = int128_and(llend, int128_exts64(TARGET_PAGE_MASK));\n\n\n\n    if (int128_ge(int128_make64(iova), llend)) {\n\n        return;\n\n    }\n\n    end = int128_get64(int128_sub(llend, int128_one()));\n\n\n\n    llsize = int128_sub(llend, int128_make64(iova));\n\n\n\n    trace_vfio_listener_region_del(iova, end);\n\n\n\n    ret = vfio_dma_unmap(container, iova, int128_get64(llsize));\n\n    memory_region_unref(section->mr);\n\n    if (ret) {\n\n        error_report(\"vfio_dma_unmap(%p, 0x%\"HWADDR_PRIx\", \"\n\n                     \"0x%\"HWADDR_PRIx\") = %d (%m)\",\n\n                     container, iova, int128_get64(llsize), ret);\n\n    }\n\n\n\n    if (container->iommu_type == VFIO_SPAPR_TCE_v2_IOMMU) {\n\n        vfio_spapr_remove_window(container,\n\n                                 section->offset_within_address_space);\n\n        if (vfio_host_win_del(container,\n\n                              section->offset_within_address_space,\n\n                              section->offset_within_address_space +\n\n                              int128_get64(section->size) - 1) < 0) {\n\n            hw_error(\"%s: Cannot delete missing window at %\"HWADDR_PRIx,\n\n                     __func__, section->offset_within_address_space);\n\n        }\n\n    }\n\n}\n", "idx": 23926}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "VirtIOSCSIReq *virtio_scsi_init_req(VirtIOSCSI *s, VirtQueue *vq)\n\n{\n\n    VirtIOSCSIReq *req;\n\n    VirtIOSCSICommon *vs = (VirtIOSCSICommon *)s;\n\n    const size_t zero_skip = offsetof(VirtIOSCSIReq, vring);\n\n\n\n    req = g_malloc(sizeof(*req) + vs->cdb_size);\n\n    req->vq = vq;\n\n    req->dev = s;\n\n    qemu_sglist_init(&req->qsgl, DEVICE(s), 8, &address_space_memory);\n\n    qemu_iovec_init(&req->resp_iov, 1);\n\n    memset((uint8_t *)req + zero_skip, 0, sizeof(*req) - zero_skip);\n\n    return req;\n\n}\n", "idx": 23927}
{"project": "qemu", "commit_id": "ed9164a3549f93204d6b096136cda2ce54e9f03a", "target": 0, "func": "static void qemu_cpu_kick_thread(CPUState *cpu)\n\n{\n\n#ifndef _WIN32\n\n    int err;\n\n\n\n    err = pthread_kill(cpu->thread->thread, SIG_IPI);\n\n    if (err) {\n\n        fprintf(stderr, \"qemu:%s: %s\", __func__, strerror(err));\n\n        exit(1);\n\n    }\n\n#else /* _WIN32 */\n\n    if (!qemu_cpu_is_self(cpu)) {\n\n        SuspendThread(cpu->hThread);\n\n        cpu_signal(0);\n\n        ResumeThread(cpu->hThread);\n\n    }\n\n#endif\n\n}\n", "idx": 23928}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "bool bdrv_unallocated_blocks_are_zero(BlockDriverState *bs)\n\n{\n\n    BlockDriverInfo bdi;\n\n\n\n    if (bs->backing_hd) {\n\n        return false;\n\n    }\n\n\n\n    if (bdrv_get_info(bs, &bdi) == 0) {\n\n        return bdi.unallocated_blocks_are_zero;\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 23930}
{"project": "qemu", "commit_id": "75ebec11afe49539f71cc1c494e3010f91c86adb", "target": 0, "func": "static uint64_t virtio_net_get_features(VirtIODevice *vdev, uint64_t features,\n\n                                        Error **errp)\n\n{\n\n    VirtIONet *n = VIRTIO_NET(vdev);\n\n    NetClientState *nc = qemu_get_queue(n->nic);\n\n\n\n    /* Firstly sync all virtio-net possible supported features */\n\n    features |= n->host_features;\n\n\n\n    virtio_add_feature(&features, VIRTIO_NET_F_MAC);\n\n\n\n    if (!peer_has_vnet_hdr(n)) {\n\n        virtio_clear_feature(&features, VIRTIO_NET_F_CSUM);\n\n        virtio_clear_feature(&features, VIRTIO_NET_F_HOST_TSO4);\n\n        virtio_clear_feature(&features, VIRTIO_NET_F_HOST_TSO6);\n\n        virtio_clear_feature(&features, VIRTIO_NET_F_HOST_ECN);\n\n\n\n        virtio_clear_feature(&features, VIRTIO_NET_F_GUEST_CSUM);\n\n        virtio_clear_feature(&features, VIRTIO_NET_F_GUEST_TSO4);\n\n        virtio_clear_feature(&features, VIRTIO_NET_F_GUEST_TSO6);\n\n        virtio_clear_feature(&features, VIRTIO_NET_F_GUEST_ECN);\n\n    }\n\n\n\n    if (!peer_has_vnet_hdr(n) || !peer_has_ufo(n)) {\n\n        virtio_clear_feature(&features, VIRTIO_NET_F_GUEST_UFO);\n\n        virtio_clear_feature(&features, VIRTIO_NET_F_HOST_UFO);\n\n    }\n\n\n\n    if (!get_vhost_net(nc->peer)) {\n\n        return features;\n\n    }\n\n    return vhost_net_get_features(get_vhost_net(nc->peer), features);\n\n}\n", "idx": 23931}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "PXA2xxState *pxa270_init(MemoryRegion *address_space,\n\n                         unsigned int sdram_size, const char *revision)\n\n{\n\n    PXA2xxState *s;\n\n    int i;\n\n    DriveInfo *dinfo;\n\n    s = (PXA2xxState *) g_malloc0(sizeof(PXA2xxState));\n\n\n\n    if (revision && strncmp(revision, \"pxa27\", 5)) {\n\n        fprintf(stderr, \"Machine requires a PXA27x processor.\\n\");\n\n        exit(1);\n\n    }\n\n    if (!revision)\n\n        revision = \"pxa270\";\n\n    \n\n    s->cpu = cpu_arm_init(revision);\n\n    if (s->cpu == NULL) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    s->reset = qemu_allocate_irq(pxa2xx_reset, s, 0);\n\n\n\n    /* SDRAM & Internal Memory Storage */\n\n    memory_region_init_ram(&s->sdram, NULL, \"pxa270.sdram\", sdram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->sdram);\n\n    memory_region_add_subregion(address_space, PXA2XX_SDRAM_BASE, &s->sdram);\n\n    memory_region_init_ram(&s->internal, NULL, \"pxa270.internal\", 0x40000,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->internal);\n\n    memory_region_add_subregion(address_space, PXA2XX_INTERNAL_BASE,\n\n                                &s->internal);\n\n\n\n    s->pic = pxa2xx_pic_init(0x40d00000, s->cpu);\n\n\n\n    s->dma = pxa27x_dma_init(0x40000000,\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_DMA));\n\n\n\n    sysbus_create_varargs(\"pxa27x-timer\", 0x40a00000,\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_OST_0 + 0),\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_OST_0 + 1),\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_OST_0 + 2),\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_OST_0 + 3),\n\n                    qdev_get_gpio_in(s->pic, PXA27X_PIC_OST_4_11),\n\n                    NULL);\n\n\n\n    s->gpio = pxa2xx_gpio_init(0x40e00000, s->cpu, s->pic, 121);\n\n\n\n    dinfo = drive_get(IF_SD, 0, 0);\n\n    if (!dinfo) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital device\\n\");\n\n        exit(1);\n\n    }\n\n    s->mmc = pxa2xx_mmci_init(address_space, 0x41100000,\n\n                    blk_bs(blk_by_legacy_dinfo(dinfo)),\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_MMC),\n\n                    qdev_get_gpio_in(s->dma, PXA2XX_RX_RQ_MMCI),\n\n                    qdev_get_gpio_in(s->dma, PXA2XX_TX_RQ_MMCI));\n\n\n\n    for (i = 0; pxa270_serial[i].io_base; i++) {\n\n        if (serial_hds[i]) {\n\n            serial_mm_init(address_space, pxa270_serial[i].io_base, 2,\n\n                           qdev_get_gpio_in(s->pic, pxa270_serial[i].irqn),\n\n                           14857000 / 16, serial_hds[i],\n\n                           DEVICE_NATIVE_ENDIAN);\n\n        } else {\n\n            break;\n\n        }\n\n    }\n\n    if (serial_hds[i])\n\n        s->fir = pxa2xx_fir_init(address_space, 0x40800000,\n\n                        qdev_get_gpio_in(s->pic, PXA2XX_PIC_ICP),\n\n                        qdev_get_gpio_in(s->dma, PXA2XX_RX_RQ_ICP),\n\n                        qdev_get_gpio_in(s->dma, PXA2XX_TX_RQ_ICP),\n\n                        serial_hds[i]);\n\n\n\n    s->lcd = pxa2xx_lcdc_init(address_space, 0x44000000,\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_LCD));\n\n\n\n    s->cm_base = 0x41300000;\n\n    s->cm_regs[CCCR >> 2] = 0x02000210;\t/* 416.0 MHz */\n\n    s->clkcfg = 0x00000009;\t\t/* Turbo mode active */\n\n    memory_region_init_io(&s->cm_iomem, NULL, &pxa2xx_cm_ops, s, \"pxa2xx-cm\", 0x1000);\n\n    memory_region_add_subregion(address_space, s->cm_base, &s->cm_iomem);\n\n    vmstate_register(NULL, 0, &vmstate_pxa2xx_cm, s);\n\n\n\n    pxa2xx_setup_cp14(s);\n\n\n\n    s->mm_base = 0x48000000;\n\n    s->mm_regs[MDMRS >> 2] = 0x00020002;\n\n    s->mm_regs[MDREFR >> 2] = 0x03ca4000;\n\n    s->mm_regs[MECR >> 2] = 0x00000001;\t/* Two PC Card sockets */\n\n    memory_region_init_io(&s->mm_iomem, NULL, &pxa2xx_mm_ops, s, \"pxa2xx-mm\", 0x1000);\n\n    memory_region_add_subregion(address_space, s->mm_base, &s->mm_iomem);\n\n    vmstate_register(NULL, 0, &vmstate_pxa2xx_mm, s);\n\n\n\n    s->pm_base = 0x40f00000;\n\n    memory_region_init_io(&s->pm_iomem, NULL, &pxa2xx_pm_ops, s, \"pxa2xx-pm\", 0x100);\n\n    memory_region_add_subregion(address_space, s->pm_base, &s->pm_iomem);\n\n    vmstate_register(NULL, 0, &vmstate_pxa2xx_pm, s);\n\n\n\n    for (i = 0; pxa27x_ssp[i].io_base; i ++);\n\n    s->ssp = (SSIBus **)g_malloc0(sizeof(SSIBus *) * i);\n\n    for (i = 0; pxa27x_ssp[i].io_base; i ++) {\n\n        DeviceState *dev;\n\n        dev = sysbus_create_simple(TYPE_PXA2XX_SSP, pxa27x_ssp[i].io_base,\n\n                        qdev_get_gpio_in(s->pic, pxa27x_ssp[i].irqn));\n\n        s->ssp[i] = (SSIBus *)qdev_get_child_bus(dev, \"ssi\");\n\n    }\n\n\n\n    if (usb_enabled(false)) {\n\n        sysbus_create_simple(\"sysbus-ohci\", 0x4c000000,\n\n                        qdev_get_gpio_in(s->pic, PXA2XX_PIC_USBH1));\n\n    }\n\n\n\n    s->pcmcia[0] = pxa2xx_pcmcia_init(address_space, 0x20000000);\n\n    s->pcmcia[1] = pxa2xx_pcmcia_init(address_space, 0x30000000);\n\n\n\n    sysbus_create_simple(TYPE_PXA2XX_RTC, 0x40900000,\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_RTCALARM));\n\n\n\n    s->i2c[0] = pxa2xx_i2c_init(0x40301600,\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_I2C), 0xffff);\n\n    s->i2c[1] = pxa2xx_i2c_init(0x40f00100,\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_PWRI2C), 0xff);\n\n\n\n    s->i2s = pxa2xx_i2s_init(address_space, 0x40400000,\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_I2S),\n\n                    qdev_get_gpio_in(s->dma, PXA2XX_RX_RQ_I2S),\n\n                    qdev_get_gpio_in(s->dma, PXA2XX_TX_RQ_I2S));\n\n\n\n    s->kp = pxa27x_keypad_init(address_space, 0x41500000,\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_KEYPAD));\n\n\n\n    /* GPIO1 resets the processor */\n\n    /* The handler can be overridden by board-specific code */\n\n    qdev_connect_gpio_out(s->gpio, 1, s->reset);\n\n    return s;\n\n}\n", "idx": 23932}
{"project": "qemu", "commit_id": "b0fd8d18683f0d77a8e6b482771ebea82234d727", "target": 0, "func": "static void setup_rt_frame(int sig, struct target_sigaction *ka,\n\n                           target_siginfo_t *info,\n\n                           target_sigset_t *set, CPUAlphaState *env)\n\n{\n\n    abi_ulong frame_addr, r26;\n\n    struct target_rt_sigframe *frame;\n\n    int i, err = 0;\n\n\n\n    frame_addr = get_sigframe(ka, env, sizeof(*frame));\n\n    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0)) {\n\n        goto give_sigsegv;\n\n    }\n\n\n\n    err |= copy_siginfo_to_user(&frame->info, info);\n\n\n\n    __put_user(0, &frame->uc.tuc_flags);\n\n    __put_user(0, &frame->uc.tuc_link);\n\n    __put_user(set->sig[0], &frame->uc.tuc_osf_sigmask);\n\n    __put_user(target_sigaltstack_used.ss_sp,\n\n               &frame->uc.tuc_stack.ss_sp);\n\n    __put_user(sas_ss_flags(env->ir[IR_SP]),\n\n               &frame->uc.tuc_stack.ss_flags);\n\n    __put_user(target_sigaltstack_used.ss_size,\n\n               &frame->uc.tuc_stack.ss_size);\n\n    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);\n\n    for (i = 0; i < TARGET_NSIG_WORDS; ++i) {\n\n        __put_user(set->sig[i], &frame->uc.tuc_sigmask.sig[i]);\n\n    }\n\n\n\n    if (ka->sa_restorer) {\n\n        r26 = ka->sa_restorer;\n\n    } else {\n\n        __put_user(INSN_MOV_R30_R16, &frame->retcode[0]);\n\n        __put_user(INSN_LDI_R0 + TARGET_NR_rt_sigreturn,\n\n                   &frame->retcode[1]);\n\n        __put_user(INSN_CALLSYS, &frame->retcode[2]);\n\n        /* imb(); */\n\n        r26 = frame_addr;\n\n    }\n\n\n\n    if (err) {\n\n    give_sigsegv:\n\n       if (sig == TARGET_SIGSEGV) {\n\n            ka->_sa_handler = TARGET_SIG_DFL;\n\n        }\n\n        force_sig(TARGET_SIGSEGV);\n\n    }\n\n\n\n    env->ir[IR_RA] = r26;\n\n    env->ir[IR_PV] = env->pc = ka->_sa_handler;\n\n    env->ir[IR_A0] = sig;\n\n    env->ir[IR_A1] = frame_addr + offsetof(struct target_rt_sigframe, info);\n\n    env->ir[IR_A2] = frame_addr + offsetof(struct target_rt_sigframe, uc);\n\n    env->ir[IR_SP] = frame_addr;\n\n}\n", "idx": 23933}
{"project": "qemu", "commit_id": "85a67692d04e15a6b7d5a0e2b9d573d8bffbe108", "target": 0, "func": "static gboolean pty_chr_timer(gpointer opaque)\n\n{\n\n    struct CharDriverState *chr = opaque;\n\n    PtyCharDriver *s = chr->opaque;\n\n\n\n    if (s->connected) {\n\n        goto out;\n\n    }\n\n    if (s->polling) {\n\n        /* If we arrive here without polling being cleared due\n\n         * read returning -EIO, then we are (re-)connected */\n\n        pty_chr_state(chr, 1);\n\n        goto out;\n\n    }\n\n\n\n    /* Next poll ... */\n\n    pty_chr_update_read_handler(chr);\n\n\n\nout:\n\n    return FALSE;\n\n}\n", "idx": 23934}
{"project": "qemu", "commit_id": "ad07cd69ecaffbaa015459a46975ab32e50df805", "target": 0, "func": "static void virtio_scsi_reset(VirtIODevice *vdev)\n\n{\n\n    VirtIOSCSI *s = VIRTIO_SCSI(vdev);\n\n    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(vdev);\n\n\n\n    if (s->ctx) {\n\n        virtio_scsi_dataplane_stop(s);\n\n    }\n\n    s->resetting++;\n\n    qbus_reset_all(&s->bus.qbus);\n\n    s->resetting--;\n\n\n\n    vs->sense_size = VIRTIO_SCSI_SENSE_DEFAULT_SIZE;\n\n    vs->cdb_size = VIRTIO_SCSI_CDB_DEFAULT_SIZE;\n\n    s->events_dropped = false;\n\n}\n", "idx": 23935}
{"project": "qemu", "commit_id": "eb159d13ee36a9ef2a83e3ab66f1b2ae1cc2d9f1", "target": 0, "func": "int do_eject(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    BlockDriverState *bs;\n\n    int force = qdict_get_int(qdict, \"force\");\n\n    const char *filename = qdict_get_str(qdict, \"device\");\n\n\n\n    bs = bdrv_find(filename);\n\n    if (!bs) {\n\n        qerror_report(QERR_DEVICE_NOT_FOUND, filename);\n\n        return -1;\n\n    }\n\n    return eject_device(mon, bs, force);\n\n}\n", "idx": 23936}
{"project": "qemu", "commit_id": "30f6da6656c94964ba8677928588592d9667007e", "target": 0, "func": "static int qxl_post_load(void *opaque, int version)\n\n{\n\n    PCIQXLDevice* d = opaque;\n\n    uint8_t *ram_start = d->vga.vram_ptr;\n\n    QXLCommandExt *cmds;\n\n    int in, out, i, newmode;\n\n\n\n    dprint(d, 1, \"%s: start\\n\", __FUNCTION__);\n\n\n\n    assert(d->last_release_offset < d->vga.vram_size);\n\n    if (d->last_release_offset == 0) {\n\n        d->last_release = NULL;\n\n    } else {\n\n        d->last_release = (QXLReleaseInfo *)(ram_start + d->last_release_offset);\n\n    }\n\n\n\n    d->modes = (QXLModes*)((uint8_t*)d->rom + d->rom->modes_offset);\n\n\n\n    dprint(d, 1, \"%s: restore mode (%s)\\n\", __FUNCTION__,\n\n        qxl_mode_to_string(d->mode));\n\n    newmode = d->mode;\n\n    d->mode = QXL_MODE_UNDEFINED;\n\n    switch (newmode) {\n\n    case QXL_MODE_UNDEFINED:\n\n        break;\n\n    case QXL_MODE_VGA:\n\n        qxl_enter_vga_mode(d);\n\n        break;\n\n    case QXL_MODE_NATIVE:\n\n        for (i = 0; i < NUM_MEMSLOTS; i++) {\n\n            if (!d->guest_slots[i].active) {\n\n                continue;\n\n            }\n\n            qxl_add_memslot(d, i, 0, QXL_SYNC);\n\n        }\n\n        qxl_create_guest_primary(d, 1, QXL_SYNC);\n\n\n\n        /* replay surface-create and cursor-set commands */\n\n        cmds = g_malloc0(sizeof(QXLCommandExt) * (NUM_SURFACES + 1));\n\n        for (in = 0, out = 0; in < NUM_SURFACES; in++) {\n\n            if (d->guest_surfaces.cmds[in] == 0) {\n\n                continue;\n\n            }\n\n            cmds[out].cmd.data = d->guest_surfaces.cmds[in];\n\n            cmds[out].cmd.type = QXL_CMD_SURFACE;\n\n            cmds[out].group_id = MEMSLOT_GROUP_GUEST;\n\n            out++;\n\n        }\n\n        cmds[out].cmd.data = d->guest_cursor;\n\n        cmds[out].cmd.type = QXL_CMD_CURSOR;\n\n        cmds[out].group_id = MEMSLOT_GROUP_GUEST;\n\n        out++;\n\n        qxl_spice_loadvm_commands(d, cmds, out);\n\n        g_free(cmds);\n\n\n\n        break;\n\n    case QXL_MODE_COMPAT:\n\n        qxl_set_mode(d, d->shadow_rom.mode, 1);\n\n        break;\n\n    }\n\n    dprint(d, 1, \"%s: done\\n\", __FUNCTION__);\n\n\n\n    return 0;\n\n}\n", "idx": 23937}
{"project": "qemu", "commit_id": "203d65a4706be345c209f3408d3a011a3e48f0c9", "target": 0, "func": "static void imx_gpt_reset(DeviceState *dev)\n\n{\n\n    IMXGPTState *s = IMX_GPT(dev);\n\n\n\n    /* stop timer */\n\n    ptimer_stop(s->timer);\n\n\n\n    /*\n\n     * Soft reset doesn't touch some bits; hard reset clears them\n\n     */\n\n    s->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|\n\n               GPT_CR_WAITEN|GPT_CR_DBGEN);\n\n    s->sr = 0;\n\n    s->pr = 0;\n\n    s->ir = 0;\n\n    s->cnt = 0;\n\n    s->ocr1 = TIMER_MAX;\n\n    s->ocr2 = TIMER_MAX;\n\n    s->ocr3 = TIMER_MAX;\n\n    s->icr1 = 0;\n\n    s->icr2 = 0;\n\n\n\n    s->next_timeout = TIMER_MAX;\n\n    s->next_int = 0;\n\n\n\n    /* compute new freq */\n\n    imx_gpt_set_freq(s);\n\n\n\n    /* reset the limit to TIMER_MAX */\n\n    ptimer_set_limit(s->timer, TIMER_MAX, 1);\n\n\n\n    /* if the timer is still enabled, restart it */\n\n    if (s->freq && (s->cr & GPT_CR_EN)) {\n\n        ptimer_run(s->timer, 1);\n\n    }\n\n}\n", "idx": 23938}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void musicpal_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    ARMCPU *cpu;\n\n    qemu_irq pic[32];\n\n    DeviceState *dev;\n\n    DeviceState *i2c_dev;\n\n    DeviceState *lcd_dev;\n\n    DeviceState *key_dev;\n\n    DeviceState *wm8750_dev;\n\n    SysBusDevice *s;\n\n    I2CBus *i2c;\n\n    int i;\n\n    unsigned long flash_size;\n\n    DriveInfo *dinfo;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *sram = g_new(MemoryRegion, 1);\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"arm926\";\n\n    }\n\n    cpu = cpu_arm_init(cpu_model);\n\n    if (!cpu) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* For now we use a fixed - the original - RAM size */\n\n    memory_region_init_ram(ram, NULL, \"musicpal.ram\", MP_RAM_DEFAULT_SIZE,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(ram);\n\n    memory_region_add_subregion(address_space_mem, 0, ram);\n\n\n\n    memory_region_init_ram(sram, NULL, \"musicpal.sram\", MP_SRAM_SIZE,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(sram);\n\n    memory_region_add_subregion(address_space_mem, MP_SRAM_BASE, sram);\n\n\n\n    dev = sysbus_create_simple(TYPE_MV88W8618_PIC, MP_PIC_BASE,\n\n                               qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_IRQ));\n\n    for (i = 0; i < 32; i++) {\n\n        pic[i] = qdev_get_gpio_in(dev, i);\n\n    }\n\n    sysbus_create_varargs(TYPE_MV88W8618_PIT, MP_PIT_BASE, pic[MP_TIMER1_IRQ],\n\n                          pic[MP_TIMER2_IRQ], pic[MP_TIMER3_IRQ],\n\n                          pic[MP_TIMER4_IRQ], NULL);\n\n\n\n    if (serial_hds[0]) {\n\n        serial_mm_init(address_space_mem, MP_UART1_BASE, 2, pic[MP_UART1_IRQ],\n\n                       1825000, serial_hds[0], DEVICE_NATIVE_ENDIAN);\n\n    }\n\n    if (serial_hds[1]) {\n\n        serial_mm_init(address_space_mem, MP_UART2_BASE, 2, pic[MP_UART2_IRQ],\n\n                       1825000, serial_hds[1], DEVICE_NATIVE_ENDIAN);\n\n    }\n\n\n\n    /* Register flash */\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    if (dinfo) {\n\n        BlockDriverState *bs = blk_bs(blk_by_legacy_dinfo(dinfo));\n\n\n\n        flash_size = bdrv_getlength(bs);\n\n        if (flash_size != 8*1024*1024 && flash_size != 16*1024*1024 &&\n\n            flash_size != 32*1024*1024) {\n\n            fprintf(stderr, \"Invalid flash image size\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        /*\n\n         * The original U-Boot accesses the flash at 0xFE000000 instead of\n\n         * 0xFF800000 (if there is 8 MB flash). So remap flash access if the\n\n         * image is smaller than 32 MB.\n\n         */\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n        pflash_cfi02_register(0x100000000ULL-MP_FLASH_SIZE_MAX, NULL,\n\n                              \"musicpal.flash\", flash_size,\n\n                              bs, 0x10000, (flash_size + 0xffff) >> 16,\n\n                              MP_FLASH_SIZE_MAX / flash_size,\n\n                              2, 0x00BF, 0x236D, 0x0000, 0x0000,\n\n                              0x5555, 0x2AAA, 1);\n\n#else\n\n        pflash_cfi02_register(0x100000000ULL-MP_FLASH_SIZE_MAX, NULL,\n\n                              \"musicpal.flash\", flash_size,\n\n                              bs, 0x10000, (flash_size + 0xffff) >> 16,\n\n                              MP_FLASH_SIZE_MAX / flash_size,\n\n                              2, 0x00BF, 0x236D, 0x0000, 0x0000,\n\n                              0x5555, 0x2AAA, 0);\n\n#endif\n\n\n\n    }\n\n    sysbus_create_simple(TYPE_MV88W8618_FLASHCFG, MP_FLASHCFG_BASE, NULL);\n\n\n\n    qemu_check_nic_model(&nd_table[0], \"mv88w8618\");\n\n    dev = qdev_create(NULL, TYPE_MV88W8618_ETH);\n\n    qdev_set_nic_properties(dev, &nd_table[0]);\n\n    qdev_init_nofail(dev);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, MP_ETH_BASE);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, pic[MP_ETH_IRQ]);\n\n\n\n    sysbus_create_simple(\"mv88w8618_wlan\", MP_WLAN_BASE, NULL);\n\n\n\n    sysbus_create_simple(TYPE_MUSICPAL_MISC, MP_MISC_BASE, NULL);\n\n\n\n    dev = sysbus_create_simple(TYPE_MUSICPAL_GPIO, MP_GPIO_BASE,\n\n                               pic[MP_GPIO_IRQ]);\n\n    i2c_dev = sysbus_create_simple(\"gpio_i2c\", -1, NULL);\n\n    i2c = (I2CBus *)qdev_get_child_bus(i2c_dev, \"i2c\");\n\n\n\n    lcd_dev = sysbus_create_simple(TYPE_MUSICPAL_LCD, MP_LCD_BASE, NULL);\n\n    key_dev = sysbus_create_simple(TYPE_MUSICPAL_KEY, -1, NULL);\n\n\n\n    /* I2C read data */\n\n    qdev_connect_gpio_out(i2c_dev, 0,\n\n                          qdev_get_gpio_in(dev, MP_GPIO_I2C_DATA_BIT));\n\n    /* I2C data */\n\n    qdev_connect_gpio_out(dev, 3, qdev_get_gpio_in(i2c_dev, 0));\n\n    /* I2C clock */\n\n    qdev_connect_gpio_out(dev, 4, qdev_get_gpio_in(i2c_dev, 1));\n\n\n\n    for (i = 0; i < 3; i++) {\n\n        qdev_connect_gpio_out(dev, i, qdev_get_gpio_in(lcd_dev, i));\n\n    }\n\n    for (i = 0; i < 4; i++) {\n\n        qdev_connect_gpio_out(key_dev, i, qdev_get_gpio_in(dev, i + 8));\n\n    }\n\n    for (i = 4; i < 8; i++) {\n\n        qdev_connect_gpio_out(key_dev, i, qdev_get_gpio_in(dev, i + 15));\n\n    }\n\n\n\n    wm8750_dev = i2c_create_slave(i2c, \"wm8750\", MP_WM_ADDR);\n\n    dev = qdev_create(NULL, \"mv88w8618_audio\");\n\n    s = SYS_BUS_DEVICE(dev);\n\n    qdev_prop_set_ptr(dev, \"wm8750\", wm8750_dev);\n\n    qdev_init_nofail(dev);\n\n    sysbus_mmio_map(s, 0, MP_AUDIO_BASE);\n\n    sysbus_connect_irq(s, 0, pic[MP_AUDIO_IRQ]);\n\n\n\n    musicpal_binfo.ram_size = MP_RAM_DEFAULT_SIZE;\n\n    musicpal_binfo.kernel_filename = kernel_filename;\n\n    musicpal_binfo.kernel_cmdline = kernel_cmdline;\n\n    musicpal_binfo.initrd_filename = initrd_filename;\n\n    arm_load_kernel(cpu, &musicpal_binfo);\n\n}\n", "idx": 23939}
{"project": "qemu", "commit_id": "45a50b1668822c23afc2a89f724654e176518bc4", "target": 0, "func": "int fread_targphys(target_phys_addr_t dst_addr, size_t nbytes, FILE *f)\n\n{\n\n    uint8_t buf[4096];\n\n    target_phys_addr_t dst_begin = dst_addr;\n\n    size_t want, did;\n\n\n\n    while (nbytes) {\n\n\twant = nbytes > sizeof(buf) ? sizeof(buf) : nbytes;\n\n\tdid = fread(buf, 1, want, f);\n\n\n\n\tcpu_physical_memory_write_rom(dst_addr, buf, did);\n\n\tdst_addr += did;\n\n\tnbytes -= did;\n\n\tif (did != want)\n\n\t    break;\n\n    }\n\n    return dst_addr - dst_begin;\n\n}\n", "idx": 23941}
{"project": "qemu", "commit_id": "9ed415b28b0c808e8b0fc631902cb9ce277f0245", "target": 1, "func": "static int dynticks_start_timer(struct qemu_alarm_timer *t)\n\n{\n\n    struct sigevent ev;\n\n    timer_t host_timer;\n\n    struct sigaction act;\n\n\n\n    sigfillset(&act.sa_mask);\n\n    act.sa_flags = 0;\n\n    act.sa_handler = host_alarm_handler;\n\n\n\n    sigaction(SIGALRM, &act, NULL);\n\n\n\n\n\n\n\n\n    ev.sigev_value.sival_int = 0;\n\n    ev.sigev_notify = SIGEV_SIGNAL;\n\n    ev.sigev_signo = SIGALRM;\n\n\n\n    if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {\n\n        perror(\"timer_create\");\n\n\n\n        /* disable dynticks */\n\n        fprintf(stderr, \"Dynamic Ticks disabled\\n\");\n\n\n\n        return -1;\n\n    }\n\n\n\n    t->priv = (void *)(long)host_timer;\n\n\n\n    return 0;\n\n}", "idx": 23942}
{"project": "qemu", "commit_id": "156abc2f901617834307d93f3c066250957f75b1", "target": 1, "func": "void qmp_blockdev_change_medium(const char *device, const char *filename,\n\n                                bool has_format, const char *format,\n\n                                bool has_read_only,\n\n                                BlockdevChangeReadOnlyMode read_only,\n\n                                Error **errp)\n\n{\n\n    BlockBackend *blk;\n\n    BlockDriverState *medium_bs = NULL;\n\n    int bdrv_flags, ret;\n\n    QDict *options = NULL;\n\n    Error *err = NULL;\n\n\n\n    blk = blk_by_name(device);\n\n    if (!blk) {\n\n        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n\n                  \"Device '%s' not found\", device);\n\n        goto fail;\n\n    }\n\n\n\n    if (blk_bs(blk)) {\n\n        blk_update_root_state(blk);\n\n    }\n\n\n\n    bdrv_flags = blk_get_open_flags_from_root_state(blk);\n\n\n\n\n\n    if (!has_read_only) {\n\n        read_only = BLOCKDEV_CHANGE_READ_ONLY_MODE_RETAIN;\n\n    }\n\n\n\n    switch (read_only) {\n\n    case BLOCKDEV_CHANGE_READ_ONLY_MODE_RETAIN:\n\n        break;\n\n\n\n    case BLOCKDEV_CHANGE_READ_ONLY_MODE_READ_ONLY:\n\n        bdrv_flags &= ~BDRV_O_RDWR;\n\n        break;\n\n\n\n    case BLOCKDEV_CHANGE_READ_ONLY_MODE_READ_WRITE:\n\n        bdrv_flags |= BDRV_O_RDWR;\n\n        break;\n\n\n\n    default:\n\n        abort();\n\n    }\n\n\n\n    if (has_format) {\n\n        options = qdict_new();\n\n        qdict_put(options, \"driver\", qstring_from_str(format));\n\n    }\n\n\n\n    assert(!medium_bs);\n\n    ret = bdrv_open(&medium_bs, filename, NULL, options, bdrv_flags, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    blk_apply_root_state(blk, medium_bs);\n\n\n\n    bdrv_add_key(medium_bs, NULL, &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        goto fail;\n\n    }\n\n\n\n    qmp_blockdev_open_tray(device, false, false, &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        goto fail;\n\n    }\n\n\n\n    qmp_x_blockdev_remove_medium(device, &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        goto fail;\n\n    }\n\n\n\n    qmp_blockdev_insert_anon_medium(device, medium_bs, &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        goto fail;\n\n    }\n\n\n\n    qmp_blockdev_close_tray(device, errp);\n\n\n\nfail:\n\n    /* If the medium has been inserted, the device has its own reference, so\n\n     * ours must be relinquished; and if it has not been inserted successfully,\n\n     * the reference must be relinquished anyway */\n\n    bdrv_unref(medium_bs);\n\n}", "idx": 23944}
{"project": "qemu", "commit_id": "805b5d98c649d26fc44d2d7755a97f18e62b438a", "target": 1, "func": "static void v9fs_link(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    int32_t dfid, oldfid;\n    V9fsFidState *dfidp, *oldfidp;\n    V9fsString name;\n    size_t offset = 7;\n    int err = 0;\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dds\", &dfid, &oldfid, &name);\n    if (err < 0) {\n    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n    dfidp = get_fid(pdu, dfid);\n    if (dfidp == NULL) {\n        err = -ENOENT;\n    oldfidp = get_fid(pdu, oldfid);\n    if (oldfidp == NULL) {\n        err = -ENOENT;\n        goto out;\n    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);\n    if (!err) {\n        err = offset;\nout:\n    put_fid(pdu, dfidp);\nout_nofid:\n    v9fs_string_free(&name);\n    pdu_complete(pdu, err);", "idx": 23945}
{"project": "qemu", "commit_id": "b946a1533209f61a93e34898aebb5b43154b99c3", "target": 1, "func": "static PCIDevice *nic_init(PCIBus * bus, NICInfo * nd, uint32_t device)\n\n{\n\n    PCIEEPRO100State *d;\n\n    EEPRO100State *s;\n\n\n\n    logout(\"\\n\");\n\n\n\n    d = (PCIEEPRO100State *) pci_register_device(bus, nd->model,\n\n                                                 sizeof(PCIEEPRO100State), -1,\n\n                                                 NULL, NULL);\n\n\n\n    s = &d->eepro100;\n\n    s->device = device;\n\n    s->pci_dev = &d->dev;\n\n\n\n    pci_reset(s);\n\n\n\n    /* Add 64 * 2 EEPROM. i82557 and i82558 support a 64 word EEPROM,\n\n     * i82559 and later support 64 or 256 word EEPROM. */\n\n    s->eeprom = eeprom93xx_new(EEPROM_SIZE);\n\n\n\n    /* Handler for memory-mapped I/O */\n\n    d->eepro100.mmio_index =\n\n        cpu_register_io_memory(0, pci_mmio_read, pci_mmio_write, s);\n\n\n\n    pci_register_io_region(&d->dev, 0, PCI_MEM_SIZE,\n\n                           PCI_ADDRESS_SPACE_MEM |\n\n                           PCI_ADDRESS_SPACE_MEM_PREFETCH, pci_mmio_map);\n\n    pci_register_io_region(&d->dev, 1, PCI_IO_SIZE, PCI_ADDRESS_SPACE_IO,\n\n                           pci_map);\n\n    pci_register_io_region(&d->dev, 2, PCI_FLASH_SIZE, PCI_ADDRESS_SPACE_MEM,\n\n                           pci_mmio_map);\n\n\n\n    memcpy(s->macaddr, nd->macaddr, 6);\n\n    logout(\"macaddr: %s\\n\", nic_dump(&s->macaddr[0], 6));\n\n    assert(s->region[1] == 0);\n\n\n\n    nic_reset(s);\n\n\n\n    s->vc = qemu_new_vlan_client(nd->vlan, nd->model, nd->name,\n\n                                 nic_receive, nic_can_receive, s);\n\n\n\n    qemu_format_nic_info_str(s->vc, s->macaddr);\n\n\n\n    qemu_register_reset(nic_reset, s);\n\n\n\n    register_savevm(s->vc->model, -1, 3, nic_save, nic_load, s);\n\n    return (PCIDevice *)d;\n\n}\n", "idx": 23946}
{"project": "qemu", "commit_id": "b7022d9ac61311f92aef0994e2ab801b76d55f14", "target": 1, "func": "static void s390_pci_generate_event(uint8_t cc, uint16_t pec, uint32_t fh,\n\n                                    uint32_t fid, uint64_t faddr, uint32_t e)\n\n{\n\n    SeiContainer *sei_cont = g_malloc0(sizeof(SeiContainer));\n\n    S390pciState *s = S390_PCI_HOST_BRIDGE(\n\n        object_resolve_path(TYPE_S390_PCI_HOST_BRIDGE, NULL));\n\n\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    sei_cont->fh = fh;\n\n    sei_cont->fid = fid;\n\n    sei_cont->cc = cc;\n\n    sei_cont->pec = pec;\n\n    sei_cont->faddr = faddr;\n\n    sei_cont->e = e;\n\n\n\n    QTAILQ_INSERT_TAIL(&s->pending_sei, sei_cont, link);\n\n    css_generate_css_crws(0);\n\n}\n", "idx": 23947}
{"project": "qemu", "commit_id": "6133b39f3c36623425a6ede9e89d93175fde15cd", "target": 1, "func": "void coroutine_fn co_aio_sleep_ns(AioContext *ctx, QEMUClockType type,\n                                  int64_t ns)\n{\n    CoSleepCB sleep_cb = {\n        .co = qemu_coroutine_self(),\n    };\n    sleep_cb.ts = aio_timer_new(ctx, type, SCALE_NS, co_sleep_cb, &sleep_cb);\n    timer_mod(sleep_cb.ts, qemu_clock_get_ns(type) + ns);\n    qemu_coroutine_yield();\n    timer_del(sleep_cb.ts);\n    timer_free(sleep_cb.ts);", "idx": 23948}
{"project": "qemu", "commit_id": "9ecaa27e7123211f45ca723a736ffae14f6c1f42", "target": 1, "func": "uint32_t HELPER(mul32)(CPUOpenRISCState *env,\n\n                       uint32_t ra, uint32_t rb)\n\n{\n\n    uint64_t result;\n\n    uint32_t high, cy;\n\n\n\n    OpenRISCCPU *cpu = openrisc_env_get_cpu(env);\n\n\n\n    result = (uint64_t)ra * rb;\n\n    /* regisiers in or32 is 32bit, so 32 is NOT a magic number.\n\n       or64 is not handled in this function, and not implement yet,\n\n       TARGET_LONG_BITS for or64 is 64, it will break this function,\n\n       so, we didn't use TARGET_LONG_BITS here.  */\n\n    high = result >> 32;\n\n    cy = result >> (32 - 1);\n\n\n\n    if ((cy & 0x1) == 0x0) {\n\n        if (high == 0x0) {\n\n            return result;\n\n        }\n\n    }\n\n\n\n    if ((cy & 0x1) == 0x1) {\n\n        if (high == 0xffffffff) {\n\n            return result;\n\n        }\n\n    }\n\n\n\n    cpu->env.sr |= (SR_OV | SR_CY);\n\n    if (cpu->env.sr & SR_OVE) {\n\n        raise_exception(cpu, EXCP_RANGE);\n\n    }\n\n\n\n    return result;\n\n}\n", "idx": 23949}
{"project": "qemu", "commit_id": "daf767b16aeb32e5b9a77066ba130fe723f875ca", "target": 1, "func": "void cpu_set_log(int log_flags)\n\n{\n\n    loglevel = log_flags;\n\n    if (loglevel && !logfile) {\n\n        logfile = fopen(logfilename, log_append ? \"a\" : \"w\");\n\n        if (!logfile) {\n\n            perror(logfilename);\n\n            _exit(1);\n\n        }\n\n#if !defined(CONFIG_SOFTMMU)\n\n        /* must avoid mmap() usage of glibc by setting a buffer \"by hand\" */\n\n        {\n\n            static char logfile_buf[4096];\n\n            setvbuf(logfile, logfile_buf, _IOLBF, sizeof(logfile_buf));\n\n        }\n\n#elif !defined(_WIN32)\n\n        /* Win32 doesn't support line-buffering and requires size >= 2 */\n\n        setvbuf(logfile, NULL, _IOLBF, 0);\n\n#endif\n\n        log_append = 1;\n\n    }\n\n    if (!loglevel && logfile) {\n\n        fclose(logfile);\n\n        logfile = NULL;\n\n    }\n\n}\n", "idx": 23950}
{"project": "qemu", "commit_id": "01a720125f5e2f0a23d2682b39dead2fcc820066", "target": 1, "func": "void helper_ocbi(CPUSH4State *env, uint32_t address)\n\n{\n\n    memory_content **current = &(env->movcal_backup);\n\n    while (*current)\n\n    {\n\n\tuint32_t a = (*current)->address;\n\n\tif ((a & ~0x1F) == (address & ~0x1F))\n\n\t{\n\n\t    memory_content *next = (*current)->next;\n\n            cpu_stl_data(env, a, (*current)->value);\n\n\t    \n\n\t    if (next == NULL)\n\n\t    {\n\n\t\tenv->movcal_backup_tail = current;\n\n\t    }\n\n\n\n\t    free (*current);\n\n\t    *current = next;\n\n\t    break;\n\n\t}\n\n    }\n\n}\n", "idx": 23951}
{"project": "qemu", "commit_id": "8417cebfda193c7f9ca70be5e308eaa92cf84b94", "target": 1, "func": "static void render_memory_region(FlatView *view,\n\n                                 MemoryRegion *mr,\n\n                                 target_phys_addr_t base,\n\n                                 AddrRange clip)\n\n{\n\n    MemoryRegion *subregion;\n\n    unsigned i;\n\n    target_phys_addr_t offset_in_region;\n\n    uint64_t remain;\n\n    uint64_t now;\n\n    FlatRange fr;\n\n    AddrRange tmp;\n\n\n\n    base += mr->addr;\n\n\n\n    tmp = addrrange_make(base, mr->size);\n\n\n\n    if (!addrrange_intersects(tmp, clip)) {\n\n        return;\n\n    }\n\n\n\n    clip = addrrange_intersection(tmp, clip);\n\n\n\n    if (mr->alias) {\n\n        base -= mr->alias->addr;\n\n        base -= mr->alias_offset;\n\n        render_memory_region(view, mr->alias, base, clip);\n\n        return;\n\n    }\n\n\n\n    /* Render subregions in priority order. */\n\n    QTAILQ_FOREACH(subregion, &mr->subregions, subregions_link) {\n\n        render_memory_region(view, subregion, base, clip);\n\n    }\n\n\n\n    if (!mr->terminates) {\n\n        return;\n\n    }\n\n\n\n    offset_in_region = clip.start - base;\n\n    base = clip.start;\n\n    remain = clip.size;\n\n\n\n    /* Render the region itself into any gaps left by the current view. */\n\n    for (i = 0; i < view->nr && remain; ++i) {\n\n        if (base >= addrrange_end(view->ranges[i].addr)) {\n\n            continue;\n\n        }\n\n        if (base < view->ranges[i].addr.start) {\n\n            now = MIN(remain, view->ranges[i].addr.start - base);\n\n            fr.mr = mr;\n\n            fr.offset_in_region = offset_in_region;\n\n            fr.addr = addrrange_make(base, now);\n\n            fr.dirty_log_mask = mr->dirty_log_mask;\n\n            flatview_insert(view, i, &fr);\n\n            ++i;\n\n            base += now;\n\n            offset_in_region += now;\n\n            remain -= now;\n\n        }\n\n        if (base == view->ranges[i].addr.start) {\n\n            now = MIN(remain, view->ranges[i].addr.size);\n\n            base += now;\n\n            offset_in_region += now;\n\n            remain -= now;\n\n        }\n\n    }\n\n    if (remain) {\n\n        fr.mr = mr;\n\n        fr.offset_in_region = offset_in_region;\n\n        fr.addr = addrrange_make(base, remain);\n\n        fr.dirty_log_mask = mr->dirty_log_mask;\n\n        flatview_insert(view, i, &fr);\n\n    }\n\n}\n", "idx": 23953}
{"project": "qemu", "commit_id": "089da572b956ef0f8f5b8d5917358e07892a77c2", "target": 1, "func": "void fw_cfg_add_i32(FWCfgState *s, uint16_t key, uint32_t value)\n\n{\n\n    uint32_t *copy;\n\n\n\n    copy = g_malloc(sizeof(value));\n\n    *copy = cpu_to_le32(value);\n\n    fw_cfg_add_bytes(s, key, (uint8_t *)copy, sizeof(value));\n\n}\n", "idx": 23954}
{"project": "qemu", "commit_id": "b45c03f585ea9bb1af76c73e82195418c294919d", "target": 1, "func": "struct omap_lcd_panel_s *omap_lcdc_init(MemoryRegion *sysmem,\n\n                                        hwaddr base,\n\n                                        qemu_irq irq,\n\n                                        struct omap_dma_lcd_channel_s *dma,\n\n                                        omap_clk clk)\n\n{\n\n    struct omap_lcd_panel_s *s = (struct omap_lcd_panel_s *)\n\n            g_malloc0(sizeof(struct omap_lcd_panel_s));\n\n\n\n    s->irq = irq;\n\n    s->dma = dma;\n\n    s->sysmem = sysmem;\n\n    omap_lcdc_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &omap_lcdc_ops, s, \"omap.lcdc\", 0x100);\n\n    memory_region_add_subregion(sysmem, base, &s->iomem);\n\n\n\n    s->con = graphic_console_init(NULL, 0, &omap_ops, s);\n\n\n\n    return s;\n\n}\n", "idx": 23955}
{"project": "qemu", "commit_id": "81907a582901671c15be36a63b5063f88f3487e2", "target": 1, "func": "void cpsr_write(CPUARMState *env, uint32_t val, uint32_t mask,\n\n                CPSRWriteType write_type)\n\n{\n\n    uint32_t changed_daif;\n\n\n\n    if (mask & CPSR_NZCV) {\n\n        env->ZF = (~val) & CPSR_Z;\n\n        env->NF = val;\n\n        env->CF = (val >> 29) & 1;\n\n        env->VF = (val << 3) & 0x80000000;\n\n    }\n\n    if (mask & CPSR_Q)\n\n        env->QF = ((val & CPSR_Q) != 0);\n\n    if (mask & CPSR_T)\n\n        env->thumb = ((val & CPSR_T) != 0);\n\n    if (mask & CPSR_IT_0_1) {\n\n        env->condexec_bits &= ~3;\n\n        env->condexec_bits |= (val >> 25) & 3;\n\n    }\n\n    if (mask & CPSR_IT_2_7) {\n\n        env->condexec_bits &= 3;\n\n        env->condexec_bits |= (val >> 8) & 0xfc;\n\n    }\n\n    if (mask & CPSR_GE) {\n\n        env->GE = (val >> 16) & 0xf;\n\n    }\n\n\n\n    /* In a V7 implementation that includes the security extensions but does\n\n     * not include Virtualization Extensions the SCR.FW and SCR.AW bits control\n\n     * whether non-secure software is allowed to change the CPSR_F and CPSR_A\n\n     * bits respectively.\n\n     *\n\n     * In a V8 implementation, it is permitted for privileged software to\n\n     * change the CPSR A/F bits regardless of the SCR.AW/FW bits.\n\n     */\n\n    if (write_type != CPSRWriteRaw && !arm_feature(env, ARM_FEATURE_V8) &&\n\n        arm_feature(env, ARM_FEATURE_EL3) &&\n\n        !arm_feature(env, ARM_FEATURE_EL2) &&\n\n        !arm_is_secure(env)) {\n\n\n\n        changed_daif = (env->daif ^ val) & mask;\n\n\n\n        if (changed_daif & CPSR_A) {\n\n            /* Check to see if we are allowed to change the masking of async\n\n             * abort exceptions from a non-secure state.\n\n             */\n\n            if (!(env->cp15.scr_el3 & SCR_AW)) {\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"Ignoring attempt to switch CPSR_A flag from \"\n\n                              \"non-secure world with SCR.AW bit clear\\n\");\n\n                mask &= ~CPSR_A;\n\n            }\n\n        }\n\n\n\n        if (changed_daif & CPSR_F) {\n\n            /* Check to see if we are allowed to change the masking of FIQ\n\n             * exceptions from a non-secure state.\n\n             */\n\n            if (!(env->cp15.scr_el3 & SCR_FW)) {\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"Ignoring attempt to switch CPSR_F flag from \"\n\n                              \"non-secure world with SCR.FW bit clear\\n\");\n\n                mask &= ~CPSR_F;\n\n            }\n\n\n\n            /* Check whether non-maskable FIQ (NMFI) support is enabled.\n\n             * If this bit is set software is not allowed to mask\n\n             * FIQs, but is allowed to set CPSR_F to 0.\n\n             */\n\n            if ((A32_BANKED_CURRENT_REG_GET(env, sctlr) & SCTLR_NMFI) &&\n\n                (val & CPSR_F)) {\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"Ignoring attempt to enable CPSR_F flag \"\n\n                              \"(non-maskable FIQ [NMFI] support enabled)\\n\");\n\n                mask &= ~CPSR_F;\n\n            }\n\n        }\n\n    }\n\n\n\n    env->daif &= ~(CPSR_AIF & mask);\n\n    env->daif |= val & CPSR_AIF & mask;\n\n\n\n    if (write_type != CPSRWriteRaw &&\n\n        (env->uncached_cpsr & CPSR_M) != CPSR_USER &&\n\n        ((env->uncached_cpsr ^ val) & mask & CPSR_M)) {\n\n        if (bad_mode_switch(env, val & CPSR_M)) {\n\n            /* Attempt to switch to an invalid mode: this is UNPREDICTABLE.\n\n             * We choose to ignore the attempt and leave the CPSR M field\n\n             * untouched.\n\n             */\n\n            mask &= ~CPSR_M;\n\n        } else {\n\n            switch_mode(env, val & CPSR_M);\n\n        }\n\n    }\n\n    mask &= ~CACHED_CPSR_BITS;\n\n    env->uncached_cpsr = (env->uncached_cpsr & ~mask) | (val & mask);\n\n}\n", "idx": 23956}
{"project": "qemu", "commit_id": "02ed3e7c1665205ddae052774d6f26c71d3d9b30", "target": 1, "func": "static void virtio_crypto_free_request(VirtIOCryptoReq *req)\n\n{\n\n    if (req) {\n\n        if (req->flags == CRYPTODEV_BACKEND_ALG_SYM) {\n\n            g_free(req->u.sym_op_info);\n\n        }\n\n        g_free(req);\n\n    }\n\n}\n", "idx": 23957}
{"project": "qemu", "commit_id": "b14ef7c9ab41ea824c3ccadb070ad95567cca84e", "target": 1, "func": "void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,\n\n                          int unused, int size)\n\n{\n\n    if (is_exec)\n\n        helper_raise_exception(EXCP_IBE);\n\n    else\n\n        helper_raise_exception(EXCP_DBE);\n\n}\n", "idx": 23958}
{"project": "qemu", "commit_id": "57ee366ce9cf8d9f7a52b7b654b9db78fe887349", "target": 1, "func": "static void qemu_aio_complete(void *opaque, int ret)\n\n{\n\n    struct ioreq *ioreq = opaque;\n\n\n\n    if (ret != 0) {\n\n        xen_be_printf(&ioreq->blkdev->xendev, 0, \"%s I/O error\\n\",\n\n                      ioreq->req.operation == BLKIF_OP_READ ? \"read\" : \"write\");\n\n        ioreq->aio_errors++;\n\n    }\n\n\n\n    ioreq->aio_inflight--;\n\n    if (ioreq->presync) {\n\n        ioreq->presync = 0;\n\n        ioreq_runio_qemu_aio(ioreq);\n\n        return;\n\n    }\n\n    if (ioreq->aio_inflight > 0) {\n\n        return;\n\n    }\n\n    if (ioreq->postsync) {\n\n        ioreq->postsync = 0;\n\n        ioreq->aio_inflight++;\n\n        blk_aio_flush(ioreq->blkdev->blk, qemu_aio_complete, ioreq);\n\n        return;\n\n    }\n\n\n\n    ioreq->status = ioreq->aio_errors ? BLKIF_RSP_ERROR : BLKIF_RSP_OKAY;\n\n    ioreq_unmap(ioreq);\n\n    ioreq_finish(ioreq);\n\n    switch (ioreq->req.operation) {\n\n    case BLKIF_OP_WRITE:\n\n    case BLKIF_OP_FLUSH_DISKCACHE:\n\n        if (!ioreq->req.nr_segments) {\n\n            break;\n\n        }\n\n    case BLKIF_OP_READ:\n\n        block_acct_done(blk_get_stats(ioreq->blkdev->blk), &ioreq->acct);\n\n        break;\n\n    case BLKIF_OP_DISCARD:\n\n    default:\n\n        break;\n\n    }\n\n    qemu_bh_schedule(ioreq->blkdev->bh);\n\n}\n", "idx": 23959}
{"project": "qemu", "commit_id": "9a321e92343891e30f6fe8bfaad40454ae358bfb", "target": 1, "func": "static void spapr_msi_setmsg(PCIDevice *pdev, hwaddr addr, bool msix,\n\n                             unsigned first_irq, unsigned req_num)\n\n{\n\n    unsigned i;\n\n    MSIMessage msg = { .address = addr, .data = first_irq };\n\n\n\n    if (!msix) {\n\n        msi_set_message(pdev, msg);\n\n        trace_spapr_pci_msi_setup(pdev->name, 0, msg.address);\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < req_num; ++i, ++msg.data) {\n\n        msix_set_message(pdev, i, msg);\n\n        trace_spapr_pci_msi_setup(pdev->name, i, msg.address);\n\n    }\n\n}\n", "idx": 23960}
{"project": "qemu", "commit_id": "b41d320fef705289d2b73f4949731eb2e189161d", "target": 1, "func": "static void spapr_reset_htab(sPAPRMachineState *spapr)\n\n{\n\n    long shift;\n\n    int index;\n\n\n\n    shift = kvmppc_reset_htab(spapr->htab_shift);\n\n    if (shift > 0) {\n\n        if (shift != spapr->htab_shift) {\n\n            error_setg(&error_abort, \"Requested HTAB allocation failed during reset\");\n\n        }\n\n\n\n        /* Tell readers to update their file descriptor */\n\n        if (spapr->htab_fd >= 0) {\n\n            spapr->htab_fd_stale = true;\n\n        }\n\n    } else {\n\n        memset(spapr->htab, 0, HTAB_SIZE(spapr));\n\n\n\n        for (index = 0; index < HTAB_SIZE(spapr) / HASH_PTE_SIZE_64; index++) {\n\n            DIRTY_HPTE(HPTE(spapr->htab, index));\n\n        }\n\n    }\n\n\n\n    /* Update the RMA size if necessary */\n\n    if (spapr->vrma_adjust) {\n\n        spapr->rma_size = kvmppc_rma_size(spapr_node0_size(),\n\n                                          spapr->htab_shift);\n\n    }\n\n}\n", "idx": 23961}
{"project": "qemu", "commit_id": "7b53f2940e3bf43ae50c929330a4837ca4da7a94", "target": 1, "func": "void raise_irq_cpu_hotplug(void)\n\n{\n\n    qemu_irq_raise(irq_cpu_hotplug);\n\n}\n", "idx": 23962}
{"project": "qemu", "commit_id": "66a08cbe6ad1aebec8eecf58b3ba042e19dd1649", "target": 1, "func": "static void uhci_queue_free(UHCIQueue *queue)\n\n{\n\n    UHCIState *s = queue->uhci;\n\n    UHCIAsync *async;\n\n\n\n    while (!QTAILQ_EMPTY(&queue->asyncs)) {\n\n        async = QTAILQ_FIRST(&queue->asyncs);\n\n        uhci_async_cancel(async);\n\n    }\n\n\n\n    trace_usb_uhci_queue_del(queue->token);\n\n    QTAILQ_REMOVE(&s->queues, queue, next);\n\n    g_free(queue);\n\n}\n", "idx": 23963}
{"project": "qemu", "commit_id": "bdd81addf4033ce26e6cd180b060f63095f3ded9", "target": 1, "func": "static void vfio_probe_nvidia_bar0_quirk(VFIOPCIDevice *vdev, int nr)\n\n{\n\n    VFIOQuirk *quirk;\n\n    VFIOConfigMirrorQuirk *mirror;\n\n\n\n    if (!vfio_pci_is(vdev, PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID) ||\n\n        !vfio_is_vga(vdev) || nr != 0) {\n\n        return;\n\n    }\n\n\n\n    quirk = g_malloc0(sizeof(*quirk));\n\n    mirror = quirk->data = g_malloc0(sizeof(*mirror));\n\n    mirror->mem = quirk->mem = g_malloc0(sizeof(MemoryRegion));\n\n    quirk->nr_mem = 1;\n\n    mirror->vdev = vdev;\n\n    mirror->offset = 0x88000;\n\n    mirror->bar = nr;\n\n\n\n    memory_region_init_io(mirror->mem, OBJECT(vdev),\n\n                          &vfio_nvidia_mirror_quirk, mirror,\n\n                          \"vfio-nvidia-bar0-88000-mirror-quirk\",\n\n                          PCIE_CONFIG_SPACE_SIZE);\n\n    memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,\n\n                                        mirror->offset, mirror->mem, 1);\n\n\n\n    QLIST_INSERT_HEAD(&vdev->bars[nr].quirks, quirk, next);\n\n\n\n    /* The 0x1800 offset mirror only seems to get used by legacy VGA */\n\n    if (vdev->has_vga) {\n\n        quirk = g_malloc0(sizeof(*quirk));\n\n        mirror = quirk->data = g_malloc0(sizeof(*mirror));\n\n        mirror->mem = quirk->mem = g_malloc0(sizeof(MemoryRegion));\n\n        quirk->nr_mem = 1;\n\n        mirror->vdev = vdev;\n\n        mirror->offset = 0x1800;\n\n        mirror->bar = nr;\n\n\n\n        memory_region_init_io(mirror->mem, OBJECT(vdev),\n\n                              &vfio_nvidia_mirror_quirk, mirror,\n\n                              \"vfio-nvidia-bar0-1800-mirror-quirk\",\n\n                              PCI_CONFIG_SPACE_SIZE);\n\n        memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,\n\n                                            mirror->offset, mirror->mem, 1);\n\n\n\n        QLIST_INSERT_HEAD(&vdev->bars[nr].quirks, quirk, next);\n\n    }\n\n\n\n    trace_vfio_quirk_nvidia_bar0_probe(vdev->vbasedev.name);\n\n}\n", "idx": 23965}
{"project": "qemu", "commit_id": "7d8abfcb50a33aed369bbd267852cf04009c49e9", "target": 1, "func": "aio_write_f(int argc, char **argv)\n\n{\n\n\tint nr_iov, c;\n\n\tint pattern = 0xcd;\n\n\tstruct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));\n\n\tBlockDriverAIOCB *acb;\n\n\n\n\twhile ((c = getopt(argc, argv, \"CqP:\")) != EOF) {\n\n\t\tswitch (c) {\n\n\t\tcase 'C':\n\n\t\t\tctx->Cflag = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'q':\n\n\t\t\tctx->qflag = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'P':\n\n\t\t\tpattern = atoi(optarg);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\treturn command_usage(&aio_write_cmd);\n\n\t\t}\n\n\t}\n\n\n\n\tif (optind > argc - 2)\n\n\t\treturn command_usage(&aio_write_cmd);\n\n\n\n\tctx->offset = cvtnum(argv[optind]);\n\n\tif (ctx->offset < 0) {\n\n\t\tprintf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n\t\treturn 0;\n\n\t}\n\n\toptind++;\n\n\n\n\tif (ctx->offset & 0x1ff) {\n\n\t\tprintf(\"offset %lld is not sector aligned\\n\",\n\n\t\t\t(long long)ctx->offset);\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tnr_iov = argc - optind;\n\n\tctx->buf = create_iovec(&ctx->qiov, &argv[optind], nr_iov, pattern);\n\n\n\n\tgettimeofday(&ctx->t1, NULL);\n\n\tacb = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov,\n\n\t\t\t      ctx->qiov.size >> 9, aio_write_done, ctx);\n\n\tif (!acb)\n\n\t\treturn -EIO;\n\n\n\n\treturn 0;\n\n}\n", "idx": 23968}
{"project": "qemu", "commit_id": "6ab3fc32ea640026726bc5f9f4db622d0954fb8a", "target": 1, "func": "static void debugcon_ioport_write(void *opaque, hwaddr addr, uint64_t val,\n\n                                  unsigned width)\n\n{\n\n    DebugconState *s = opaque;\n\n    unsigned char ch = val;\n\n\n\n#ifdef DEBUG_DEBUGCON\n\n    printf(\" [debugcon: write addr=0x%04\" HWADDR_PRIx \" val=0x%02\" PRIx64 \"]\\n\", addr, val);\n\n#endif\n\n\n\n    qemu_chr_fe_write(s->chr, &ch, 1);\n\n}\n", "idx": 23969}
{"project": "qemu", "commit_id": "164a101f28a53cd3db60ed874e7c3630e7988ed8", "target": 1, "func": "static void test_wait_event_notifier(void)\n\n{\n\n    EventNotifierTestData data = { .n = 0, .active = 1 };\n\n    event_notifier_init(&data.e, false);\n\n    aio_set_event_notifier(ctx, &data.e, event_ready_cb, event_active_cb);\n\n    g_assert(aio_poll(ctx, false));\n\n    g_assert_cmpint(data.n, ==, 0);\n\n    g_assert_cmpint(data.active, ==, 1);\n\n\n\n    event_notifier_set(&data.e);\n\n    g_assert(aio_poll(ctx, false));\n\n    g_assert_cmpint(data.n, ==, 1);\n\n    g_assert_cmpint(data.active, ==, 0);\n\n\n\n    g_assert(!aio_poll(ctx, false));\n\n    g_assert_cmpint(data.n, ==, 1);\n\n    g_assert_cmpint(data.active, ==, 0);\n\n\n\n    aio_set_event_notifier(ctx, &data.e, NULL, NULL);\n\n    g_assert(!aio_poll(ctx, false));\n\n    g_assert_cmpint(data.n, ==, 1);\n\n\n\n    event_notifier_cleanup(&data.e);\n\n}\n", "idx": 23972}
{"project": "qemu", "commit_id": "d96391c1ffeb30a0afa695c86579517c69d9a889", "target": 1, "func": "target_ulong helper_rdhwr_synci_step(CPUMIPSState *env)\n\n{\n\n    check_hwrena(env, 1);\n\n    return env->SYNCI_Step;\n\n}\n", "idx": 23973}
{"project": "qemu", "commit_id": "8927cfbba232e28304734f7afd463c1b84134031", "target": 1, "func": "static void qxl_reset_state(PCIQXLDevice *d)\n\n{\n\n    QXLRam *ram = d->ram;\n\n    QXLRom *rom = d->rom;\n\n\n\n    assert(SPICE_RING_IS_EMPTY(&ram->cmd_ring));\n\n    assert(SPICE_RING_IS_EMPTY(&ram->cursor_ring));\n\n    d->shadow_rom.update_id = cpu_to_le32(0);\n\n    *rom = d->shadow_rom;\n\n    qxl_rom_set_dirty(d);\n\n    init_qxl_ram(d);\n\n    d->num_free_res = 0;\n\n    d->last_release = NULL;\n\n    memset(&d->ssd.dirty, 0, sizeof(d->ssd.dirty));\n\n}\n", "idx": 23978}
{"project": "qemu", "commit_id": "6d49d6d4edb8106f1a83375d91fa518c631ba00f", "target": 1, "func": "static inline void powerpc_excp(PowerPCCPU *cpu, int excp_model, int excp)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUPPCState *env = &cpu->env;\n\n    target_ulong msr, new_msr, vector;\n\n    int srr0, srr1, asrr0, asrr1;\n\n    int lpes0, lpes1, lev, ail;\n\n\n\n    if (0) {\n\n        /* XXX: find a suitable condition to enable the hypervisor mode */\n\n        lpes0 = (env->spr[SPR_LPCR] >> 1) & 1;\n\n        lpes1 = (env->spr[SPR_LPCR] >> 2) & 1;\n\n    } else {\n\n        /* Those values ensure we won't enter the hypervisor mode */\n\n        lpes0 = 0;\n\n        lpes1 = 1;\n\n    }\n\n\n\n    qemu_log_mask(CPU_LOG_INT, \"Raise exception at \" TARGET_FMT_lx\n\n                  \" => %08x (%02x)\\n\", env->nip, excp, env->error_code);\n\n\n\n    /* new srr1 value excluding must-be-zero bits */\n\n    if (excp_model == POWERPC_EXCP_BOOKE) {\n\n        msr = env->msr;\n\n    } else {\n\n        msr = env->msr & ~0x783f0000ULL;\n\n    }\n\n\n\n    /* new interrupt handler msr */\n\n    new_msr = env->msr & ((target_ulong)1 << MSR_ME);\n\n\n\n    /* target registers */\n\n    srr0 = SPR_SRR0;\n\n    srr1 = SPR_SRR1;\n\n    asrr0 = -1;\n\n    asrr1 = -1;\n\n\n\n    /* Exception targetting modifiers\n\n     *\n\n     * AIL is initialized here but can be cleared by\n\n     * selected exceptions\n\n     */\n\n#if defined(TARGET_PPC64)\n\n    if (excp_model == POWERPC_EXCP_POWER7 ||\n\n        excp_model == POWERPC_EXCP_POWER8) {\n\n        if (excp_model == POWERPC_EXCP_POWER8) {\n\n            ail = (env->spr[SPR_LPCR] & LPCR_AIL) >> LPCR_AIL_SHIFT;\n\n        } else {\n\n            ail = 0;\n\n        }\n\n    } else\n\n#endif /* defined(TARGET_PPC64) */\n\n    {\n\n        ail = 0;\n\n    }\n\n\n\n    switch (excp) {\n\n    case POWERPC_EXCP_NONE:\n\n        /* Should never happen */\n\n        return;\n\n    case POWERPC_EXCP_CRITICAL:    /* Critical input                         */\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_40x:\n\n            srr0 = SPR_40x_SRR2;\n\n            srr1 = SPR_40x_SRR3;\n\n            break;\n\n        case POWERPC_EXCP_BOOKE:\n\n            srr0 = SPR_BOOKE_CSRR0;\n\n            srr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        case POWERPC_EXCP_G2:\n\n            break;\n\n        default:\n\n            goto excp_invalid;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_MCHECK:    /* Machine check exception                  */\n\n        if (msr_me == 0) {\n\n            /* Machine check exception is not enabled.\n\n             * Enter checkstop state.\n\n             */\n\n            fprintf(stderr, \"Machine check while not allowed. \"\n\n                    \"Entering checkstop state\\n\");\n\n            if (qemu_log_separate()) {\n\n                qemu_log(\"Machine check while not allowed. \"\n\n                        \"Entering checkstop state\\n\");\n\n            }\n\n            cs->halted = 1;\n\n            cs->interrupt_request |= CPU_INTERRUPT_EXITTB;\n\n        }\n\n        if (0) {\n\n            /* XXX: find a suitable condition to enable the hypervisor mode */\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        }\n\n        ail = 0;\n\n\n\n        /* machine check exceptions don't have ME set */\n\n        new_msr &= ~((target_ulong)1 << MSR_ME);\n\n\n\n        /* XXX: should also have something loaded in DAR / DSISR */\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_40x:\n\n            srr0 = SPR_40x_SRR2;\n\n            srr1 = SPR_40x_SRR3;\n\n            break;\n\n        case POWERPC_EXCP_BOOKE:\n\n            /* FIXME: choose one or the other based on CPU type */\n\n            srr0 = SPR_BOOKE_MCSRR0;\n\n            srr1 = SPR_BOOKE_MCSRR1;\n\n            asrr0 = SPR_BOOKE_CSRR0;\n\n            asrr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_DSI:       /* Data storage exception                   */\n\n        LOG_EXCP(\"DSI exception: DSISR=\" TARGET_FMT_lx\" DAR=\" TARGET_FMT_lx\n\n                 \"\\n\", env->spr[SPR_DSISR], env->spr[SPR_DAR]);\n\n        if (lpes1 == 0) {\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_ISI:       /* Instruction storage exception            */\n\n        LOG_EXCP(\"ISI exception: msr=\" TARGET_FMT_lx \", nip=\" TARGET_FMT_lx\n\n                 \"\\n\", msr, env->nip);\n\n        if (lpes1 == 0) {\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        }\n\n        msr |= env->error_code;\n\n        goto store_next;\n\n    case POWERPC_EXCP_EXTERNAL:  /* External input                           */\n\n        cs = CPU(cpu);\n\n\n\n        if (lpes0 == 1) {\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        }\n\n        if (env->mpic_proxy) {\n\n            /* IACK the IRQ on delivery */\n\n            env->spr[SPR_BOOKE_EPR] = ldl_phys(cs->as, env->mpic_iack);\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_ALIGN:     /* Alignment exception                      */\n\n        if (lpes1 == 0) {\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        }\n\n        /* XXX: this is false */\n\n        /* Get rS/rD and rA from faulting opcode */\n\n        env->spr[SPR_DSISR] |= (cpu_ldl_code(env, (env->nip - 4))\n\n                                & 0x03FF0000) >> 16;\n\n        goto store_next;\n\n    case POWERPC_EXCP_PROGRAM:   /* Program exception                        */\n\n        switch (env->error_code & ~0xF) {\n\n        case POWERPC_EXCP_FP:\n\n            if ((msr_fe0 == 0 && msr_fe1 == 0) || msr_fp == 0) {\n\n                LOG_EXCP(\"Ignore floating point exception\\n\");\n\n                cs->exception_index = POWERPC_EXCP_NONE;\n\n                env->error_code = 0;\n\n                return;\n\n            }\n\n            if (lpes1 == 0) {\n\n                new_msr |= (target_ulong)MSR_HVB;\n\n            }\n\n            msr |= 0x00100000;\n\n            if (msr_fe0 == msr_fe1) {\n\n                goto store_next;\n\n            }\n\n            msr |= 0x00010000;\n\n            break;\n\n        case POWERPC_EXCP_INVAL:\n\n            LOG_EXCP(\"Invalid instruction at \" TARGET_FMT_lx \"\\n\", env->nip);\n\n            if (lpes1 == 0) {\n\n                new_msr |= (target_ulong)MSR_HVB;\n\n            }\n\n            msr |= 0x00080000;\n\n            env->spr[SPR_BOOKE_ESR] = ESR_PIL;\n\n            break;\n\n        case POWERPC_EXCP_PRIV:\n\n            if (lpes1 == 0) {\n\n                new_msr |= (target_ulong)MSR_HVB;\n\n            }\n\n            msr |= 0x00040000;\n\n            env->spr[SPR_BOOKE_ESR] = ESR_PPR;\n\n            break;\n\n        case POWERPC_EXCP_TRAP:\n\n            if (lpes1 == 0) {\n\n                new_msr |= (target_ulong)MSR_HVB;\n\n            }\n\n            msr |= 0x00020000;\n\n            env->spr[SPR_BOOKE_ESR] = ESR_PTR;\n\n            break;\n\n        default:\n\n            /* Should never occur */\n\n            cpu_abort(cs, \"Invalid program exception %d. Aborting\\n\",\n\n                      env->error_code);\n\n            break;\n\n        }\n\n        goto store_current;\n\n    case POWERPC_EXCP_FPU:       /* Floating-point unavailable exception     */\n\n        if (lpes1 == 0) {\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        }\n\n        goto store_current;\n\n    case POWERPC_EXCP_SYSCALL:   /* System call exception                    */\n\n        dump_syscall(env);\n\n        lev = env->error_code;\n\n        if ((lev == 1) && cpu_ppc_hypercall) {\n\n            cpu_ppc_hypercall(cpu);\n\n            return;\n\n        }\n\n        if (lev == 1 || (lpes0 == 0 && lpes1 == 0)) {\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_APU:       /* Auxiliary processor unavailable          */\n\n        goto store_current;\n\n    case POWERPC_EXCP_DECR:      /* Decrementer exception                    */\n\n        if (lpes1 == 0) {\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_FIT:       /* Fixed-interval timer interrupt           */\n\n        /* FIT on 4xx */\n\n        LOG_EXCP(\"FIT exception\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_WDT:       /* Watchdog timer interrupt                 */\n\n        LOG_EXCP(\"WDT exception\\n\");\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_BOOKE:\n\n            srr0 = SPR_BOOKE_CSRR0;\n\n            srr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_DTLB:      /* Data TLB error                           */\n\n        goto store_next;\n\n    case POWERPC_EXCP_ITLB:      /* Instruction TLB error                    */\n\n        goto store_next;\n\n    case POWERPC_EXCP_DEBUG:     /* Debug interrupt                          */\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_BOOKE:\n\n            /* FIXME: choose one or the other based on CPU type */\n\n            srr0 = SPR_BOOKE_DSRR0;\n\n            srr1 = SPR_BOOKE_DSRR1;\n\n            asrr0 = SPR_BOOKE_CSRR0;\n\n            asrr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        /* XXX: TODO */\n\n        cpu_abort(cs, \"Debug exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_SPEU:      /* SPE/embedded floating-point unavailable  */\n\n        env->spr[SPR_BOOKE_ESR] = ESR_SPV;\n\n        goto store_current;\n\n    case POWERPC_EXCP_EFPDI:     /* Embedded floating-point data interrupt   */\n\n        /* XXX: TODO */\n\n        cpu_abort(cs, \"Embedded floating point data exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        env->spr[SPR_BOOKE_ESR] = ESR_SPV;\n\n        goto store_next;\n\n    case POWERPC_EXCP_EFPRI:     /* Embedded floating-point round interrupt  */\n\n        /* XXX: TODO */\n\n        cpu_abort(cs, \"Embedded floating point round exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        env->spr[SPR_BOOKE_ESR] = ESR_SPV;\n\n        goto store_next;\n\n    case POWERPC_EXCP_EPERFM:    /* Embedded performance monitor interrupt   */\n\n        /* XXX: TODO */\n\n        cpu_abort(cs,\n\n                  \"Performance counter exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_DOORI:     /* Embedded doorbell interrupt              */\n\n        goto store_next;\n\n    case POWERPC_EXCP_DOORCI:    /* Embedded doorbell critical interrupt     */\n\n        srr0 = SPR_BOOKE_CSRR0;\n\n        srr1 = SPR_BOOKE_CSRR1;\n\n        goto store_next;\n\n    case POWERPC_EXCP_RESET:     /* System reset exception                   */\n\n        if (msr_pow) {\n\n            /* indicate that we resumed from power save mode */\n\n            msr |= 0x10000;\n\n        } else {\n\n            new_msr &= ~((target_ulong)1 << MSR_ME);\n\n        }\n\n\n\n        if (0) {\n\n            /* XXX: find a suitable condition to enable the hypervisor mode */\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        }\n\n        ail = 0;\n\n        goto store_next;\n\n    case POWERPC_EXCP_DSEG:      /* Data segment exception                   */\n\n        if (lpes1 == 0) {\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_ISEG:      /* Instruction segment exception            */\n\n        if (lpes1 == 0) {\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_HDECR:     /* Hypervisor decrementer exception         */\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)MSR_HVB;\n\n        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);\n\n        goto store_next;\n\n    case POWERPC_EXCP_TRACE:     /* Trace exception                          */\n\n        if (lpes1 == 0) {\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_HDSI:      /* Hypervisor data storage exception        */\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)MSR_HVB;\n\n        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);\n\n        goto store_next;\n\n    case POWERPC_EXCP_HISI:      /* Hypervisor instruction storage exception */\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)MSR_HVB;\n\n        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);\n\n        goto store_next;\n\n    case POWERPC_EXCP_HDSEG:     /* Hypervisor data segment exception        */\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)MSR_HVB;\n\n        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);\n\n        goto store_next;\n\n    case POWERPC_EXCP_HISEG:     /* Hypervisor instruction segment exception */\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)MSR_HVB;\n\n        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);\n\n        goto store_next;\n\n    case POWERPC_EXCP_VPU:       /* Vector unavailable exception             */\n\n        if (lpes1 == 0) {\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        }\n\n        goto store_current;\n\n    case POWERPC_EXCP_VSXU:       /* VSX unavailable exception               */\n\n        if (lpes1 == 0) {\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        }\n\n        goto store_current;\n\n    case POWERPC_EXCP_FU:         /* Facility unavailable exception          */\n\n        if (lpes1 == 0) {\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        }\n\n        goto store_current;\n\n    case POWERPC_EXCP_PIT:       /* Programmable interval timer interrupt    */\n\n        LOG_EXCP(\"PIT exception\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_IO:        /* IO error exception                       */\n\n        /* XXX: TODO */\n\n        cpu_abort(cs, \"601 IO error exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_RUNM:      /* Run mode exception                       */\n\n        /* XXX: TODO */\n\n        cpu_abort(cs, \"601 run mode exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_EMUL:      /* Emulation trap exception                 */\n\n        /* XXX: TODO */\n\n        cpu_abort(cs, \"602 emulation trap exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_IFTLB:     /* Instruction fetch TLB error              */\n\n        if (lpes1 == 0) { /* XXX: check this */\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        }\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_602:\n\n        case POWERPC_EXCP_603:\n\n        case POWERPC_EXCP_603E:\n\n        case POWERPC_EXCP_G2:\n\n            goto tlb_miss_tgpr;\n\n        case POWERPC_EXCP_7x5:\n\n            goto tlb_miss;\n\n        case POWERPC_EXCP_74xx:\n\n            goto tlb_miss_74xx;\n\n        default:\n\n            cpu_abort(cs, \"Invalid instruction TLB miss exception\\n\");\n\n            break;\n\n        }\n\n        break;\n\n    case POWERPC_EXCP_DLTLB:     /* Data load TLB miss                       */\n\n        if (lpes1 == 0) { /* XXX: check this */\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        }\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_602:\n\n        case POWERPC_EXCP_603:\n\n        case POWERPC_EXCP_603E:\n\n        case POWERPC_EXCP_G2:\n\n            goto tlb_miss_tgpr;\n\n        case POWERPC_EXCP_7x5:\n\n            goto tlb_miss;\n\n        case POWERPC_EXCP_74xx:\n\n            goto tlb_miss_74xx;\n\n        default:\n\n            cpu_abort(cs, \"Invalid data load TLB miss exception\\n\");\n\n            break;\n\n        }\n\n        break;\n\n    case POWERPC_EXCP_DSTLB:     /* Data store TLB miss                      */\n\n        if (lpes1 == 0) { /* XXX: check this */\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        }\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_602:\n\n        case POWERPC_EXCP_603:\n\n        case POWERPC_EXCP_603E:\n\n        case POWERPC_EXCP_G2:\n\n        tlb_miss_tgpr:\n\n            /* Swap temporary saved registers with GPRs */\n\n            if (!(new_msr & ((target_ulong)1 << MSR_TGPR))) {\n\n                new_msr |= (target_ulong)1 << MSR_TGPR;\n\n                hreg_swap_gpr_tgpr(env);\n\n            }\n\n            goto tlb_miss;\n\n        case POWERPC_EXCP_7x5:\n\n        tlb_miss:\n\n#if defined(DEBUG_SOFTWARE_TLB)\n\n            if (qemu_log_enabled()) {\n\n                const char *es;\n\n                target_ulong *miss, *cmp;\n\n                int en;\n\n\n\n                if (excp == POWERPC_EXCP_IFTLB) {\n\n                    es = \"I\";\n\n                    en = 'I';\n\n                    miss = &env->spr[SPR_IMISS];\n\n                    cmp = &env->spr[SPR_ICMP];\n\n                } else {\n\n                    if (excp == POWERPC_EXCP_DLTLB) {\n\n                        es = \"DL\";\n\n                    } else {\n\n                        es = \"DS\";\n\n                    }\n\n                    en = 'D';\n\n                    miss = &env->spr[SPR_DMISS];\n\n                    cmp = &env->spr[SPR_DCMP];\n\n                }\n\n                qemu_log(\"6xx %sTLB miss: %cM \" TARGET_FMT_lx \" %cC \"\n\n                         TARGET_FMT_lx \" H1 \" TARGET_FMT_lx \" H2 \"\n\n                         TARGET_FMT_lx \" %08x\\n\", es, en, *miss, en, *cmp,\n\n                         env->spr[SPR_HASH1], env->spr[SPR_HASH2],\n\n                         env->error_code);\n\n            }\n\n#endif\n\n            msr |= env->crf[0] << 28;\n\n            msr |= env->error_code; /* key, D/I, S/L bits */\n\n            /* Set way using a LRU mechanism */\n\n            msr |= ((env->last_way + 1) & (env->nb_ways - 1)) << 17;\n\n            break;\n\n        case POWERPC_EXCP_74xx:\n\n        tlb_miss_74xx:\n\n#if defined(DEBUG_SOFTWARE_TLB)\n\n            if (qemu_log_enabled()) {\n\n                const char *es;\n\n                target_ulong *miss, *cmp;\n\n                int en;\n\n\n\n                if (excp == POWERPC_EXCP_IFTLB) {\n\n                    es = \"I\";\n\n                    en = 'I';\n\n                    miss = &env->spr[SPR_TLBMISS];\n\n                    cmp = &env->spr[SPR_PTEHI];\n\n                } else {\n\n                    if (excp == POWERPC_EXCP_DLTLB) {\n\n                        es = \"DL\";\n\n                    } else {\n\n                        es = \"DS\";\n\n                    }\n\n                    en = 'D';\n\n                    miss = &env->spr[SPR_TLBMISS];\n\n                    cmp = &env->spr[SPR_PTEHI];\n\n                }\n\n                qemu_log(\"74xx %sTLB miss: %cM \" TARGET_FMT_lx \" %cC \"\n\n                         TARGET_FMT_lx \" %08x\\n\", es, en, *miss, en, *cmp,\n\n                         env->error_code);\n\n            }\n\n#endif\n\n            msr |= env->error_code; /* key bit */\n\n            break;\n\n        default:\n\n            cpu_abort(cs, \"Invalid data store TLB miss exception\\n\");\n\n            break;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_FPA:       /* Floating-point assist exception          */\n\n        /* XXX: TODO */\n\n        cpu_abort(cs, \"Floating point assist exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_DABR:      /* Data address breakpoint                  */\n\n        /* XXX: TODO */\n\n        cpu_abort(cs, \"DABR exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_IABR:      /* Instruction address breakpoint           */\n\n        /* XXX: TODO */\n\n        cpu_abort(cs, \"IABR exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_SMI:       /* System management interrupt              */\n\n        /* XXX: TODO */\n\n        cpu_abort(cs, \"SMI exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_THERM:     /* Thermal interrupt                        */\n\n        /* XXX: TODO */\n\n        cpu_abort(cs, \"Thermal management exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_PERFM:     /* Embedded performance monitor interrupt   */\n\n        if (lpes1 == 0) {\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        }\n\n        /* XXX: TODO */\n\n        cpu_abort(cs,\n\n                  \"Performance counter exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_VPUA:      /* Vector assist exception                  */\n\n        /* XXX: TODO */\n\n        cpu_abort(cs, \"VPU assist exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_SOFTP:     /* Soft patch exception                     */\n\n        /* XXX: TODO */\n\n        cpu_abort(cs,\n\n                  \"970 soft-patch exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_MAINT:     /* Maintenance exception                    */\n\n        /* XXX: TODO */\n\n        cpu_abort(cs,\n\n                  \"970 maintenance exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_MEXTBR:    /* Maskable external breakpoint             */\n\n        /* XXX: TODO */\n\n        cpu_abort(cs, \"Maskable external exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_NMEXTBR:   /* Non maskable external breakpoint         */\n\n        /* XXX: TODO */\n\n        cpu_abort(cs, \"Non maskable external exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    default:\n\n    excp_invalid:\n\n        cpu_abort(cs, \"Invalid PowerPC exception %d. Aborting\\n\", excp);\n\n        break;\n\n    store_current:\n\n        /* save current instruction location */\n\n        env->spr[srr0] = env->nip - 4;\n\n        break;\n\n    store_next:\n\n        /* save next instruction location */\n\n        env->spr[srr0] = env->nip;\n\n        break;\n\n    }\n\n    /* Save MSR */\n\n    env->spr[srr1] = msr;\n\n    /* If any alternate SRR register are defined, duplicate saved values */\n\n    if (asrr0 != -1) {\n\n        env->spr[asrr0] = env->spr[srr0];\n\n    }\n\n    if (asrr1 != -1) {\n\n        env->spr[asrr1] = env->spr[srr1];\n\n    }\n\n\n\n    if (env->spr[SPR_LPCR] & LPCR_AIL) {\n\n        new_msr |= (1 << MSR_IR) | (1 << MSR_DR);\n\n    }\n\n\n\n#ifdef TARGET_PPC64\n\n    if (excp_model == POWERPC_EXCP_POWER7 ||\n\n        excp_model == POWERPC_EXCP_POWER8) {\n\n        if (env->spr[SPR_LPCR] & LPCR_ILE) {\n\n            new_msr |= (target_ulong)1 << MSR_LE;\n\n        }\n\n    } else if (msr_ile) {\n\n        new_msr |= (target_ulong)1 << MSR_LE;\n\n    }\n\n#else\n\n    if (msr_ile) {\n\n        new_msr |= (target_ulong)1 << MSR_LE;\n\n    }\n\n#endif\n\n\n\n    /* Jump to handler */\n\n    vector = env->excp_vectors[excp];\n\n    if (vector == (target_ulong)-1ULL) {\n\n        cpu_abort(cs, \"Raised an exception without defined vector %d\\n\",\n\n                  excp);\n\n    }\n\n    vector |= env->excp_prefix;\n\n\n\n    /* AIL only works if there is no HV transition and we are running with\n\n     * translations enabled\n\n     */\n\n    if (!((msr >> MSR_IR) & 1) || !((msr >> MSR_DR) & 1)) {\n\n        ail = 0;\n\n    }\n\n    /* Handle AIL */\n\n    if (ail) {\n\n        new_msr |= (1 << MSR_IR) | (1 << MSR_DR);\n\n        switch(ail) {\n\n        case AIL_0001_8000:\n\n            vector |= 0x18000;\n\n            break;\n\n        case AIL_C000_0000_0000_4000:\n\n            vector |= 0xc000000000004000ull;\n\n            break;\n\n        default:\n\n            cpu_abort(cs, \"Invalid AIL combination %d\\n\", ail);\n\n            break;\n\n        }\n\n    }\n\n\n\n#if defined(TARGET_PPC64)\n\n    if (excp_model == POWERPC_EXCP_BOOKE) {\n\n        if (env->spr[SPR_BOOKE_EPCR] & EPCR_ICM) {\n\n            /* Cat.64-bit: EPCR.ICM is copied to MSR.CM */\n\n            new_msr |= (target_ulong)1 << MSR_CM;\n\n        } else {\n\n            vector = (uint32_t)vector;\n\n        }\n\n    } else {\n\n        if (!msr_isf && !(env->mmu_model & POWERPC_MMU_64)) {\n\n            vector = (uint32_t)vector;\n\n        } else {\n\n            new_msr |= (target_ulong)1 << MSR_SF;\n\n        }\n\n    }\n\n#endif\n\n    /* We don't use hreg_store_msr here as already have treated\n\n     * any special case that could occur. Just store MSR and update hflags\n\n     *\n\n     * Note: We *MUST* not use hreg_store_msr() as-is anyway because it\n\n     * will prevent setting of the HV bit which some exceptions might need\n\n     * to do.\n\n     */\n\n    env->msr = new_msr & env->msr_mask;\n\n    hreg_compute_hflags(env);\n\n    env->nip = vector;\n\n    /* Reset exception state */\n\n    cs->exception_index = POWERPC_EXCP_NONE;\n\n    env->error_code = 0;\n\n\n\n    /* Any interrupt is context synchronizing, check if TCG TLB\n\n     * needs a delayed flush on ppc64\n\n     */\n\n    check_tlb_flush(env);\n\n}\n", "idx": 23980}
{"project": "qemu", "commit_id": "7e55d65c56a03dcd2c5d7c49d37c5a74b55d4bd6", "target": 1, "func": "static int v9fs_xattr_write(V9fsState *s, V9fsPDU *pdu, V9fsFidState *fidp,\n\n                            uint64_t off, uint32_t count,\n\n                            struct iovec *sg, int cnt)\n\n{\n\n    int i, to_copy;\n\n    ssize_t err = 0;\n\n    int write_count;\n\n    int64_t xattr_len;\n\n    size_t offset = 7;\n\n\n\n\n\n    xattr_len = fidp->fs.xattr.len;\n\n    write_count = xattr_len - off;\n\n    if (write_count > count) {\n\n        write_count = count;\n\n    } else if (write_count < 0) {\n\n        /*\n\n         * write beyond XATTR value len specified in\n\n         * xattrcreate\n\n         */\n\n        err = -ENOSPC;\n\n        goto out;\n\n    }\n\n    err = pdu_marshal(pdu, offset, \"d\", write_count);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n    err += offset;\n\n    fidp->fs.xattr.copied_len += write_count;\n\n    /*\n\n     * Now copy the content from sg list\n\n     */\n\n    for (i = 0; i < cnt; i++) {\n\n        if (write_count > sg[i].iov_len) {\n\n            to_copy = sg[i].iov_len;\n\n        } else {\n\n            to_copy = write_count;\n\n        }\n\n        memcpy((char *)fidp->fs.xattr.value + off, sg[i].iov_base, to_copy);\n\n        /* updating vs->off since we are not using below */\n\n        off += to_copy;\n\n        write_count -= to_copy;\n\n    }\n\nout:\n\n    return err;\n\n}\n", "idx": 23981}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void test_retry_flush(const char *machine)\n\n{\n\n    QPCIDevice *dev;\n\n    void *bmdma_base, *ide_base;\n\n    uint8_t data;\n\n    const char *s;\n\n\n\n    prepare_blkdebug_script(debug_path, \"flush_to_disk\");\n\n\n\n    ide_test_start(\n\n        \"-vnc none \"\n\n        \"-drive file=blkdebug:%s:%s,if=ide,cache=writeback,format=raw,\"\n\n        \"rerror=stop,werror=stop\",\n\n        debug_path, tmp_path);\n\n\n\n    dev = get_pci_device(&bmdma_base, &ide_base);\n\n\n\n    qtest_irq_intercept_in(global_qtest, \"ioapic\");\n\n\n\n    /* Dirty media so that CMD_FLUSH_CACHE will actually go to disk */\n\n    make_dirty(0);\n\n\n\n    /* FLUSH CACHE command on device 0*/\n\n    qpci_io_writeb(dev, ide_base + reg_device, 0);\n\n    qpci_io_writeb(dev, ide_base + reg_command, CMD_FLUSH_CACHE);\n\n\n\n    /* Check status while request is in flight*/\n\n    data = qpci_io_readb(dev, ide_base + reg_status);\n\n    assert_bit_set(data, BSY | DRDY);\n\n    assert_bit_clear(data, DF | ERR | DRQ);\n\n\n\n    qmp_eventwait(\"STOP\");\n\n\n\n    /* Complete the command */\n\n    s = \"{'execute':'cont' }\";\n\n    qmp_discard_response(s);\n\n\n\n    /* Check registers */\n\n    data = qpci_io_readb(dev, ide_base + reg_device);\n\n    g_assert_cmpint(data & DEV, ==, 0);\n\n\n\n    do {\n\n        data = qpci_io_readb(dev, ide_base + reg_status);\n\n    } while (data & BSY);\n\n\n\n    assert_bit_set(data, DRDY);\n\n    assert_bit_clear(data, BSY | DF | ERR | DRQ);\n\n\n\n    ide_test_quit();\n\n}\n", "idx": 23982}
{"project": "qemu", "commit_id": "6f2d8978728c48ca46f5c01835438508aace5c64", "target": 1, "func": "void do_brinc (void)\n\n{\n\n    uint32_t a, b, d, mask;\n\n\n\n    mask = (uint32_t)(-1UL) >> MASKBITS;\n\n    b = T1_64 & mask;\n\n    a = T0_64 & mask;\n\n    d = word_reverse(1 + word_reverse(a | ~mask));\n\n    T0_64 = (T0_64 & ~mask) | (d & mask);\n\n}\n", "idx": 23984}
{"project": "qemu", "commit_id": "5e54769c921a3d8cd8858444f5a3fa62cc44260e", "target": 1, "func": "static void check_suspend_mode(GuestSuspendMode mode, Error **errp)\n\n{\n\n    SYSTEM_POWER_CAPABILITIES sys_pwr_caps;\n\n    Error *local_err = NULL;\n\n\n\n    if (error_is_set(errp)) {\n\n        return;\n\n    }\n\n    ZeroMemory(&sys_pwr_caps, sizeof(sys_pwr_caps));\n\n    if (!GetPwrCapabilities(&sys_pwr_caps)) {\n\n        error_set(&local_err, QERR_QGA_COMMAND_FAILED,\n\n                  \"failed to determine guest suspend capabilities\");\n\n        goto out;\n\n    }\n\n\n\n    switch (mode) {\n\n    case GUEST_SUSPEND_MODE_DISK:\n\n        if (!sys_pwr_caps.SystemS4) {\n\n            error_set(&local_err, QERR_QGA_COMMAND_FAILED,\n\n                      \"suspend-to-disk not supported by OS\");\n\n        }\n\n        break;\n\n    case GUEST_SUSPEND_MODE_RAM:\n\n        if (!sys_pwr_caps.SystemS3) {\n\n            error_set(&local_err, QERR_QGA_COMMAND_FAILED,\n\n                      \"suspend-to-ram not supported by OS\");\n\n        }\n\n        break;\n\n    default:\n\n        error_set(&local_err, QERR_INVALID_PARAMETER_VALUE, \"mode\",\n\n                  \"GuestSuspendMode\");\n\n    }\n\n\n\nout:\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n    }\n\n}\n", "idx": 23985}
{"project": "qemu", "commit_id": "db486cc334aafd3dbdaf107388e37fc3d6d3e171", "target": 1, "func": "static gint range_compare(gconstpointer a, gconstpointer b)\n\n{\n\n    Range *ra = (Range *)a, *rb = (Range *)b;\n\n    if (ra->begin == rb->begin && ra->end == rb->end) {\n\n        return 0;\n\n    } else if (range_get_last(ra->begin, ra->end) <\n\n               range_get_last(rb->begin, rb->end)) {\n\n        return -1;\n\n    } else {\n\n        return 1;\n\n    }\n\n}\n", "idx": 23986}
{"project": "qemu", "commit_id": "12ac6d3db721a288c8953c5c253230aa0949a0e1", "target": 1, "func": "static void report_unsupported_feature(BlockDriverState *bs,\n\n    Error **errp, Qcow2Feature *table, uint64_t mask)\n\n{\n\n    while (table && table->name[0] != '\\0') {\n\n        if (table->type == QCOW2_FEAT_TYPE_INCOMPATIBLE) {\n\n            if (mask & (1 << table->bit)) {\n\n                report_unsupported(bs, errp, \"%.46s\", table->name);\n\n                mask &= ~(1 << table->bit);\n\n            }\n\n        }\n\n        table++;\n\n    }\n\n\n\n    if (mask) {\n\n        report_unsupported(bs, errp, \"Unknown incompatible feature: %\" PRIx64,\n\n                           mask);\n\n    }\n\n}\n", "idx": 23987}
{"project": "qemu", "commit_id": "fd28aa132362320f9f3a30b23f634bb14dee528e", "target": 1, "func": "void qemu_ram_free(ram_addr_t addr)\n\n{\n\n    RAMBlock *block;\n\n\n\n    QLIST_FOREACH(block, &ram_list.blocks, next) {\n\n        if (addr == block->offset) {\n\n            QLIST_REMOVE(block, next);\n\n            if (block->flags & RAM_PREALLOC_MASK) {\n\n                ;\n\n            } else if (mem_path) {\n\n#if defined (__linux__) && !defined(TARGET_S390X)\n\n                if (block->fd) {\n\n                    munmap(block->host, block->length);\n\n                    close(block->fd);\n\n                } else {\n\n                    qemu_vfree(block->host);\n\n                }\n\n\n\n#endif\n\n            } else {\n\n#if defined(TARGET_S390X) && defined(CONFIG_KVM)\n\n                munmap(block->host, block->length);\n\n\n                qemu_vfree(block->host);\n\n#endif\n\n            }\n\n            qemu_free(block);\n\n            return;\n\n        }\n\n    }\n\n\n\n}", "idx": 23988}
{"project": "qemu", "commit_id": "ee640c625e190a0c0e6b8966adc0e4720fb75200", "target": 1, "func": "static int rocker_msix_init(Rocker *r)\n\n{\n\n    PCIDevice *dev = PCI_DEVICE(r);\n\n    int err;\n\n\n\n    err = msix_init(dev, ROCKER_MSIX_VEC_COUNT(r->fp_ports),\n\n                    &r->msix_bar,\n\n                    ROCKER_PCI_MSIX_BAR_IDX, ROCKER_PCI_MSIX_TABLE_OFFSET,\n\n                    &r->msix_bar,\n\n                    ROCKER_PCI_MSIX_BAR_IDX, ROCKER_PCI_MSIX_PBA_OFFSET,\n\n                    0);\n\n    if (err) {\n\n        return err;\n\n    }\n\n\n\n    err = rocker_msix_vectors_use(r, ROCKER_MSIX_VEC_COUNT(r->fp_ports));\n\n    if (err) {\n\n        goto err_msix_vectors_use;\n\n    }\n\n\n\n    return 0;\n\n\n\nerr_msix_vectors_use:\n\n    msix_uninit(dev, &r->msix_bar, &r->msix_bar);\n\n    return err;\n\n}\n", "idx": 23989}
{"project": "qemu", "commit_id": "1c7336c5d1f720e8d320cb36f9d747ad24663e0d", "target": 1, "func": "static void gen_tlbia(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    gen_helper_tlbia(cpu_env);\n\n#endif\n\n}\n", "idx": 23995}
{"project": "qemu", "commit_id": "cdd346371e09709be8e46398bb097dc690a746f2", "target": 1, "func": "static uint16_t nvme_get_feature(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)\n\n{\n\n    uint32_t dw10 = le32_to_cpu(cmd->cdw10);\n\n    uint32_t result;\n\n\n\n    switch (dw10) {\n\n    case NVME_VOLATILE_WRITE_CACHE:\n\n        result = blk_enable_write_cache(n->conf.blk);\n\n        break;\n\n    case NVME_NUMBER_OF_QUEUES:\n\n        result = cpu_to_le32((n->num_queues - 1) | ((n->num_queues - 1) << 16));\n\n        break;\n\n    default:\n\n        return NVME_INVALID_FIELD | NVME_DNR;\n\n    }\n\n\n\n    req->cqe.result = result;\n\n    return NVME_SUCCESS;\n\n}\n", "idx": 24001}
{"project": "qemu", "commit_id": "1da45e0c4cf4719fa75898d019e0874b9b2bc774", "target": 1, "func": "iscsi_allocmap_update(IscsiLun *iscsilun, int64_t sector_num,\n\n                      int nb_sectors, bool allocated, bool valid)\n\n{\n\n    int64_t cl_num_expanded, nb_cls_expanded, cl_num_shrunk, nb_cls_shrunk;\n\n\n\n    if (iscsilun->allocmap == NULL) {\n\n        return;\n\n    }\n\n    /* expand to entirely contain all affected clusters */\n\n    cl_num_expanded = sector_num / iscsilun->cluster_sectors;\n\n    nb_cls_expanded = DIV_ROUND_UP(sector_num + nb_sectors,\n\n                                   iscsilun->cluster_sectors) - cl_num_expanded;\n\n    /* shrink to touch only completely contained clusters */\n\n    cl_num_shrunk = DIV_ROUND_UP(sector_num, iscsilun->cluster_sectors);\n\n    nb_cls_shrunk = (sector_num + nb_sectors) / iscsilun->cluster_sectors\n\n                      - cl_num_shrunk;\n\n    if (allocated) {\n\n        bitmap_set(iscsilun->allocmap, cl_num_expanded, nb_cls_expanded);\n\n    } else {\n\n        bitmap_clear(iscsilun->allocmap, cl_num_shrunk, nb_cls_shrunk);\n\n    }\n\n\n\n    if (iscsilun->allocmap_valid == NULL) {\n\n        return;\n\n    }\n\n    if (valid) {\n\n        bitmap_set(iscsilun->allocmap_valid, cl_num_shrunk, nb_cls_shrunk);\n\n    } else {\n\n        bitmap_clear(iscsilun->allocmap_valid, cl_num_expanded,\n\n                     nb_cls_expanded);\n\n    }\n\n}\n", "idx": 24003}
{"project": "qemu", "commit_id": "9604f70fdf8e21ec0dbf6eac5e59a0eb8beadd64", "target": 1, "func": "static void pc_init_pci_1_5(QEMUMachineInitArgs *args)\n\n{\n\n    has_pci_info = false;\n\n    pc_init_pci(args);\n\n}\n", "idx": 24006}
{"project": "qemu", "commit_id": "278412d0e710e2e848c6e510f8308e5b1ed4d03e", "target": 1, "func": "static int usbnet_can_receive(NetClientState *nc)\n{\n    USBNetState *s = qemu_get_nic_opaque(nc);\n    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {\n        return 1;\n    return !s->in_len;", "idx": 24007}
{"project": "qemu", "commit_id": "8e7a6db96566fe4162edaeb3e8b62fc8004d1598", "target": 1, "func": "static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0,\n\n                                           TCGv arg1, TCGv arg2, int sub)\n\n{\n\n    TCGv t0 = tcg_temp_new();\n\n\n\n    tcg_gen_xor_tl(cpu_ov, arg0, arg1);\n\n    tcg_gen_xor_tl(t0, arg1, arg2);\n\n    if (sub) {\n\n        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);\n\n    } else {\n\n        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);\n\n    }\n\n    tcg_temp_free(t0);\n\n    if (NARROW_MODE(ctx)) {\n\n        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);\n\n    }\n\n    tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);\n\n    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);\n\n}\n", "idx": 24009}
{"project": "qemu", "commit_id": "ccbcfedd17fd2d13521fcee66810d0df464ec1cc", "target": 1, "func": "int qemu_devtree_add_subnode(void *fdt, const char *name)\n\n{\n\n    int offset;\n\n    char *dupname = g_strdup(name);\n\n    char *basename = strrchr(dupname, '/');\n\n    int retval;\n\n\n\n    if (!basename) {\n\n        return -1;\n\n    }\n\n\n\n    basename[0] = '\\0';\n\n    basename++;\n\n\n\n    offset = fdt_path_offset(fdt, dupname);\n\n    if (offset < 0) {\n\n        return offset;\n\n    }\n\n\n\n    retval = fdt_add_subnode(fdt, offset, basename);\n\n    g_free(dupname);\n\n    return retval;\n\n}\n", "idx": 24010}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "static void pxa2xx_pcmcia_initfn(Object *obj)\n\n{\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);\n\n    PXA2xxPCMCIAState *s = PXA2XX_PCMCIA(obj);\n\n\n\n    memory_region_init(&s->container_mem, obj, \"container\", 0x10000000);\n\n    sysbus_init_mmio(sbd, &s->container_mem);\n\n\n\n    /* Socket I/O Memory Space */\n\n    memory_region_init_io(&s->iomem, NULL, &pxa2xx_pcmcia_io_ops, s,\n\n                          \"pxa2xx-pcmcia-io\", 0x04000000);\n\n    memory_region_add_subregion(&s->container_mem, 0x00000000,\n\n                                &s->iomem);\n\n\n\n    /* Then next 64 MB is reserved */\n\n\n\n    /* Socket Attribute Memory Space */\n\n    memory_region_init_io(&s->attr_iomem, NULL, &pxa2xx_pcmcia_attr_ops, s,\n\n                          \"pxa2xx-pcmcia-attribute\", 0x04000000);\n\n    memory_region_add_subregion(&s->container_mem, 0x08000000,\n\n                                &s->attr_iomem);\n\n\n\n    /* Socket Common Memory Space */\n\n    memory_region_init_io(&s->common_iomem, NULL, &pxa2xx_pcmcia_common_ops, s,\n\n                          \"pxa2xx-pcmcia-common\", 0x04000000);\n\n    memory_region_add_subregion(&s->container_mem, 0x0c000000,\n\n                                &s->common_iomem);\n\n\n\n    s->slot.irq = qemu_allocate_irqs(pxa2xx_pcmcia_set_irq, s, 1)[0];\n\n\n\n    object_property_add_link(obj, \"card\", TYPE_PCMCIA_CARD,\n\n                             (Object **)&s->card,\n\n                             NULL, /* read-only property */\n\n                             0, NULL);\n\n}\n", "idx": 24015}
{"project": "qemu", "commit_id": "7cfd527525a7d6b1c904890a6b84c1227846415e", "target": 1, "func": "static int mirror_cow_align(MirrorBlockJob *s, int64_t *offset,\n\n                            uint64_t *bytes)\n\n{\n\n    bool need_cow;\n\n    int ret = 0;\n\n    int64_t align_offset = *offset;\n\n    unsigned int align_bytes = *bytes;\n\n    int max_bytes = s->granularity * s->max_iov;\n\n\n\n    assert(*bytes < INT_MAX);\n\n    need_cow = !test_bit(*offset / s->granularity, s->cow_bitmap);\n\n    need_cow |= !test_bit((*offset + *bytes - 1) / s->granularity,\n\n                          s->cow_bitmap);\n\n    if (need_cow) {\n\n        bdrv_round_to_clusters(blk_bs(s->target), *offset, *bytes,\n\n                               &align_offset, &align_bytes);\n\n    }\n\n\n\n    if (align_bytes > max_bytes) {\n\n        align_bytes = max_bytes;\n\n        if (need_cow) {\n\n            align_bytes = QEMU_ALIGN_DOWN(align_bytes, s->target_cluster_size);\n\n        }\n\n    }\n\n    /* Clipping may result in align_bytes unaligned to chunk boundary, but\n\n     * that doesn't matter because it's already the end of source image. */\n\n    align_bytes = mirror_clip_bytes(s, align_offset, align_bytes);\n\n\n\n    ret = align_offset + align_bytes - (*offset + *bytes);\n\n    *offset = align_offset;\n\n    *bytes = align_bytes;\n\n    assert(ret >= 0);\n\n    return ret;\n\n}\n", "idx": 24016}
{"project": "qemu", "commit_id": "44b6789299a8acca3f25331bc411055cafc7bb06", "target": 1, "func": "static void GCC_FMT_ATTR(2, 3) blkverify_err(BlkverifyAIOCB *acb,\n\n                                             const char *fmt, ...)\n\n{\n\n    va_list ap;\n\n\n\n    va_start(ap, fmt);\n\n    fprintf(stderr, \"blkverify: %s sector_num=%\" PRId64 \" nb_sectors=%d \",\n\n            acb->is_write ? \"write\" : \"read\", acb->sector_num,\n\n            acb->nb_sectors);\n\n    vfprintf(stderr, fmt, ap);\n\n    fprintf(stderr, \"\\n\");\n\n    va_end(ap);\n\n    exit(1);\n\n}\n", "idx": 24017}
{"project": "qemu", "commit_id": "be93f216278d84d283187c95cef16c0b60b711b8", "target": 1, "func": "static int alsa_poll_helper (snd_pcm_t *handle, struct pollhlp *hlp, int mask)\n\n{\n\n    int i, count, err;\n\n    struct pollfd *pfds;\n\n\n\n    count = snd_pcm_poll_descriptors_count (handle);\n\n    if (count <= 0) {\n\n        dolog (\"Could not initialize poll mode\\n\"\n\n               \"Invalid number of poll descriptors %d\\n\", count);\n\n        return -1;\n\n    }\n\n\n\n    pfds = audio_calloc (\"alsa_poll_helper\", count, sizeof (*pfds));\n\n    if (!pfds) {\n\n        dolog (\"Could not initialize poll mode\\n\");\n\n        return -1;\n\n    }\n\n\n\n    err = snd_pcm_poll_descriptors (handle, pfds, count);\n\n    if (err < 0) {\n\n        alsa_logerr (err, \"Could not initialize poll mode\\n\"\n\n                     \"Could not obtain poll descriptors\\n\");\n\n        g_free (pfds);\n\n        return -1;\n\n    }\n\n\n\n    for (i = 0; i < count; ++i) {\n\n        if (pfds[i].events & POLLIN) {\n\n            err = qemu_set_fd_handler (pfds[i].fd, alsa_poll_handler,\n\n                                       NULL, hlp);\n\n        }\n\n        if (pfds[i].events & POLLOUT) {\n\n            if (conf.verbose) {\n\n                dolog (\"POLLOUT %d %d\\n\", i, pfds[i].fd);\n\n            }\n\n            err = qemu_set_fd_handler (pfds[i].fd, NULL,\n\n                                       alsa_poll_handler, hlp);\n\n        }\n\n        if (conf.verbose) {\n\n            dolog (\"Set handler events=%#x index=%d fd=%d err=%d\\n\",\n\n                   pfds[i].events, i, pfds[i].fd, err);\n\n        }\n\n\n\n        if (err) {\n\n            dolog (\"Failed to set handler events=%#x index=%d fd=%d err=%d\\n\",\n\n                   pfds[i].events, i, pfds[i].fd, err);\n\n\n\n            while (i--) {\n\n                qemu_set_fd_handler (pfds[i].fd, NULL, NULL, NULL);\n\n            }\n\n            g_free (pfds);\n\n            return -1;\n\n        }\n\n    }\n\n    hlp->pfds = pfds;\n\n    hlp->count = count;\n\n    hlp->handle = handle;\n\n    hlp->mask = mask;\n\n    return 0;\n\n}\n", "idx": 24022}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static MigrationState *migrate_init(const MigrationParams *params)\n\n{\n\n    MigrationState *s = migrate_get_current();\n\n    int64_t bandwidth_limit = s->bandwidth_limit;\n\n    bool enabled_capabilities[MIGRATION_CAPABILITY_MAX];\n\n    int64_t xbzrle_cache_size = s->xbzrle_cache_size;\n\n\n\n    memcpy(enabled_capabilities, s->enabled_capabilities,\n\n           sizeof(enabled_capabilities));\n\n\n\n    memset(s, 0, sizeof(*s));\n\n    s->params = *params;\n\n    memcpy(s->enabled_capabilities, enabled_capabilities,\n\n           sizeof(enabled_capabilities));\n\n    s->xbzrle_cache_size = xbzrle_cache_size;\n\n\n\n    s->bandwidth_limit = bandwidth_limit;\n\n    s->state = MIG_STATE_SETUP;\n\n    trace_migrate_set_state(MIG_STATE_SETUP);\n\n\n\n    s->total_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);\n\n    return s;\n\n}\n", "idx": 24024}
{"project": "qemu", "commit_id": "5d443f5adad6ddd8238602990b7e86404a288d48", "target": 1, "func": "static void chr_read(void *opaque, const uint8_t *buf, int size)\n{\n    TestServer *s = opaque;\n    CharDriverState *chr = s->chr;\n    VhostUserMsg msg;\n    uint8_t *p = (uint8_t *) &msg;\n    int fd;\n    if (size != VHOST_USER_HDR_SIZE) {\n        g_test_message(\"Wrong message size received %d\\n\", size);\n        return;\n    g_mutex_lock(&s->data_mutex);\n    memcpy(p, buf, VHOST_USER_HDR_SIZE);\n    if (msg.size) {\n        p += VHOST_USER_HDR_SIZE;\n        size = qemu_chr_fe_read_all(chr, p, msg.size);\n        if (size != msg.size) {\n            g_test_message(\"Wrong message size received %d != %d\\n\",\n                           size, msg.size);\n            return;\n    switch (msg.request) {\n    case VHOST_USER_GET_FEATURES:\n        /* send back features to qemu */\n        msg.flags |= VHOST_USER_REPLY_MASK;\n        msg.size = sizeof(m.payload.u64);\n        msg.payload.u64 = 0x1ULL << VHOST_F_LOG_ALL |\n            0x1ULL << VHOST_USER_F_PROTOCOL_FEATURES;\n        p = (uint8_t *) &msg;\n        qemu_chr_fe_write_all(chr, p, VHOST_USER_HDR_SIZE + msg.size);\n        break;\n    case VHOST_USER_SET_FEATURES:\n\tg_assert_cmpint(msg.payload.u64 & (0x1ULL << VHOST_USER_F_PROTOCOL_FEATURES),\n\t\t\t!=, 0ULL);\n        break;\n    case VHOST_USER_GET_PROTOCOL_FEATURES:\n        /* send back features to qemu */\n        msg.flags |= VHOST_USER_REPLY_MASK;\n        msg.size = sizeof(m.payload.u64);\n        msg.payload.u64 = 1 << VHOST_USER_PROTOCOL_F_LOG_SHMFD;\n        p = (uint8_t *) &msg;\n        qemu_chr_fe_write_all(chr, p, VHOST_USER_HDR_SIZE + msg.size);\n        break;\n    case VHOST_USER_GET_VRING_BASE:\n        /* send back vring base to qemu */\n        msg.flags |= VHOST_USER_REPLY_MASK;\n        msg.size = sizeof(m.payload.state);\n        msg.payload.state.num = 0;\n        p = (uint8_t *) &msg;\n        qemu_chr_fe_write_all(chr, p, VHOST_USER_HDR_SIZE + msg.size);\n        assert(msg.payload.state.index < 2);\n        s->rings &= ~(0x1ULL << msg.payload.state.index);\n        break;\n    case VHOST_USER_SET_MEM_TABLE:\n        /* received the mem table */\n        memcpy(&s->memory, &msg.payload.memory, sizeof(msg.payload.memory));\n        s->fds_num = qemu_chr_fe_get_msgfds(chr, s->fds, G_N_ELEMENTS(s->fds));\n        /* signal the test that it can continue */\n        g_cond_signal(&s->data_cond);\n        break;\n    case VHOST_USER_SET_VRING_KICK:\n    case VHOST_USER_SET_VRING_CALL:\n        /* consume the fd */\n        qemu_chr_fe_get_msgfds(chr, &fd, 1);\n        /*\n         * This is a non-blocking eventfd.\n         * The receive function forces it to be blocking,\n         * so revert it back to non-blocking.\n         */\n        qemu_set_nonblock(fd);\n        break;\n    case VHOST_USER_SET_LOG_BASE:\n        if (s->log_fd != -1) {\n            close(s->log_fd);\n            s->log_fd = -1;\n        qemu_chr_fe_get_msgfds(chr, &s->log_fd, 1);\n        msg.flags |= VHOST_USER_REPLY_MASK;\n        msg.size = 0;\n        p = (uint8_t *) &msg;\n        qemu_chr_fe_write_all(chr, p, VHOST_USER_HDR_SIZE);\n        g_cond_signal(&s->data_cond);\n        break;\n    case VHOST_USER_SET_VRING_BASE:\n        assert(msg.payload.state.index < 2);\n        s->rings |= 0x1ULL << msg.payload.state.index;\n        break;\n    default:\n        break;\n    g_mutex_unlock(&s->data_mutex);", "idx": 24025}
{"project": "qemu", "commit_id": "afed5a5a7030a074a181d2a0ce8202de71a6ada4", "target": 1, "func": "CpuInfoList *qmp_query_cpus(Error **errp)\n\n{\n\n    MachineState *ms = MACHINE(qdev_get_machine());\n\n    MachineClass *mc = MACHINE_GET_CLASS(ms);\n\n    CpuInfoList *head = NULL, *cur_item = NULL;\n\n    CPUState *cpu;\n\n\n\n    CPU_FOREACH(cpu) {\n\n        CpuInfoList *info;\n\n#if defined(TARGET_I386)\n\n        X86CPU *x86_cpu = X86_CPU(cpu);\n\n        CPUX86State *env = &x86_cpu->env;\n\n#elif defined(TARGET_PPC)\n\n        PowerPCCPU *ppc_cpu = POWERPC_CPU(cpu);\n\n        CPUPPCState *env = &ppc_cpu->env;\n\n#elif defined(TARGET_SPARC)\n\n        SPARCCPU *sparc_cpu = SPARC_CPU(cpu);\n\n        CPUSPARCState *env = &sparc_cpu->env;\n\n#elif defined(TARGET_MIPS)\n\n        MIPSCPU *mips_cpu = MIPS_CPU(cpu);\n\n        CPUMIPSState *env = &mips_cpu->env;\n\n#elif defined(TARGET_TRICORE)\n\n        TriCoreCPU *tricore_cpu = TRICORE_CPU(cpu);\n\n        CPUTriCoreState *env = &tricore_cpu->env;\n\n#endif\n\n\n\n        cpu_synchronize_state(cpu);\n\n\n\n        info = g_malloc0(sizeof(*info));\n\n        info->value = g_malloc0(sizeof(*info->value));\n\n        info->value->CPU = cpu->cpu_index;\n\n        info->value->current = (cpu == first_cpu);\n\n        info->value->halted = cpu->halted;\n\n        info->value->qom_path = object_get_canonical_path(OBJECT(cpu));\n\n        info->value->thread_id = cpu->thread_id;\n\n#if defined(TARGET_I386)\n\n        info->value->arch = CPU_INFO_ARCH_X86;\n\n        info->value->u.x86.pc = env->eip + env->segs[R_CS].base;\n\n#elif defined(TARGET_PPC)\n\n        info->value->arch = CPU_INFO_ARCH_PPC;\n\n        info->value->u.ppc.nip = env->nip;\n\n#elif defined(TARGET_SPARC)\n\n        info->value->arch = CPU_INFO_ARCH_SPARC;\n\n        info->value->u.q_sparc.pc = env->pc;\n\n        info->value->u.q_sparc.npc = env->npc;\n\n#elif defined(TARGET_MIPS)\n\n        info->value->arch = CPU_INFO_ARCH_MIPS;\n\n        info->value->u.q_mips.PC = env->active_tc.PC;\n\n#elif defined(TARGET_TRICORE)\n\n        info->value->arch = CPU_INFO_ARCH_TRICORE;\n\n        info->value->u.tricore.PC = env->PC;\n\n#else\n\n        info->value->arch = CPU_INFO_ARCH_OTHER;\n\n#endif\n\n\n\n\n\n\n\n\n\n\n        /* XXX: waiting for the qapi to support GSList */\n\n        if (!cur_item) {\n\n            head = cur_item = info;\n\n        } else {\n\n            cur_item->next = info;\n\n            cur_item = info;\n\n\n\n\n\n    return head;\n", "idx": 24030}
{"project": "qemu", "commit_id": "073de86aa934d46d596a2367e7501da5500e5b86", "target": 1, "func": "static hwaddr ppc_hash64_htab_lookup(PowerPCCPU *cpu,\n\n                                     ppc_slb_t *slb, target_ulong eaddr,\n\n                                     ppc_hash_pte64_t *pte)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    hwaddr pte_offset;\n\n    hwaddr hash;\n\n    uint64_t vsid, epnmask, epn, ptem;\n\n\n\n    /* The SLB store path should prevent any bad page size encodings\n\n     * getting in there, so: */\n\n    assert(slb->sps);\n\n\n\n    epnmask = ~((1ULL << slb->sps->page_shift) - 1);\n\n\n\n    if (slb->vsid & SLB_VSID_B) {\n\n        /* 1TB segment */\n\n        vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT_1T;\n\n        epn = (eaddr & ~SEGMENT_MASK_1T) & epnmask;\n\n        hash = vsid ^ (vsid << 25) ^ (epn >> slb->sps->page_shift);\n\n    } else {\n\n        /* 256M segment */\n\n        vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT;\n\n        epn = (eaddr & ~SEGMENT_MASK_256M) & epnmask;\n\n        hash = vsid ^ (epn >> slb->sps->page_shift);\n\n    }\n\n    ptem = (slb->vsid & SLB_VSID_PTEM) | ((epn >> 16) & HPTE64_V_AVPN);\n\n\n\n    /* Page address translation */\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n            \"htab_base \" TARGET_FMT_plx \" htab_mask \" TARGET_FMT_plx\n\n            \" hash \" TARGET_FMT_plx \"\\n\",\n\n            env->htab_base, env->htab_mask, hash);\n\n\n\n    /* Primary PTEG lookup */\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n            \"0 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n            \" vsid=\" TARGET_FMT_lx \" ptem=\" TARGET_FMT_lx\n\n            \" hash=\" TARGET_FMT_plx \"\\n\",\n\n            env->htab_base, env->htab_mask, vsid, ptem,  hash);\n\n    pte_offset = ppc_hash64_pteg_search(cpu, hash, slb, 0, ptem, pte);\n\n\n\n    if (pte_offset == -1) {\n\n        /* Secondary PTEG lookup */\n\n        qemu_log_mask(CPU_LOG_MMU,\n\n                \"1 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n                \" vsid=\" TARGET_FMT_lx \" api=\" TARGET_FMT_lx\n\n                \" hash=\" TARGET_FMT_plx \"\\n\", env->htab_base,\n\n                env->htab_mask, vsid, ptem, ~hash);\n\n\n\n        pte_offset = ppc_hash64_pteg_search(cpu, ~hash, slb, 1, ptem, pte);\n\n    }\n\n\n\n    return pte_offset;\n\n}\n", "idx": 24031}
{"project": "qemu", "commit_id": "ec6469a3b1da26247bdb3f5dd5276fabcc1b694a", "target": 1, "func": "static always_inline void gen_op_neg (DisasContext *ctx, TCGv ret, TCGv arg1, int ov_check)\n\n{\n\n    int l1, l2;\n\n\n\n    l1 = gen_new_label();\n\n    l2 = gen_new_label();\n\n#if defined(TARGET_PPC64)\n\n    if (ctx->sf_mode) {\n\n        tcg_gen_brcondi_tl(TCG_COND_EQ, arg1, INT64_MIN, l1);\n\n    } else {\n\n        TCGv t0 = tcg_temp_new(TCG_TYPE_TL);\n\n\ttcg_gen_ext32s_tl(t0, arg1);\n\n        tcg_gen_brcondi_tl(TCG_COND_EQ, t0, INT32_MIN, l1);\n\n    }\n\n#else\n\n        tcg_gen_brcondi_tl(TCG_COND_EQ, arg1, INT32_MIN, l1);\n\n#endif\n\n    tcg_gen_neg_tl(ret, arg1);\n\n    if (ov_check) {\n\n        tcg_gen_andi_tl(cpu_xer, cpu_xer, ~(1 << XER_OV));\n\n    }\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_mov_tl(ret, arg1);\n\n    if (ov_check) {\n\n        tcg_gen_ori_tl(cpu_xer, cpu_xer, (1 << XER_OV) | (1 << XER_SO));\n\n    }\n\n    gen_set_label(l2);\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, ret);\n\n}\n", "idx": 24032}
{"project": "qemu", "commit_id": "007cd223de527b5f41278f2d886c1a4beb3e67aa", "target": 1, "func": "static int tx_consume(Rocker *r, DescInfo *info)\n\n{\n\n    PCIDevice *dev = PCI_DEVICE(r);\n\n    char *buf = desc_get_buf(info, true);\n\n    RockerTlv *tlv_frag;\n\n    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];\n\n    struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };\n\n    uint32_t pport;\n\n    uint32_t port;\n\n    uint16_t tx_offload = ROCKER_TX_OFFLOAD_NONE;\n\n    uint16_t tx_l3_csum_off = 0;\n\n    uint16_t tx_tso_mss = 0;\n\n    uint16_t tx_tso_hdr_len = 0;\n\n    int iovcnt = 0;\n\n    int err = ROCKER_OK;\n\n    int rem;\n\n    int i;\n\n\n\n    if (!buf) {\n\n        return -ROCKER_ENXIO;\n\n    }\n\n\n\n    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));\n\n\n\n    if (!tlvs[ROCKER_TLV_TX_FRAGS]) {\n\n        return -ROCKER_EINVAL;\n\n    }\n\n\n\n    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));\n\n    if (!fp_port_from_pport(pport, &port)) {\n\n        return -ROCKER_EINVAL;\n\n    }\n\n\n\n    if (tlvs[ROCKER_TLV_TX_OFFLOAD]) {\n\n        tx_offload = rocker_tlv_get_u8(tlvs[ROCKER_TLV_TX_OFFLOAD]);\n\n    }\n\n\n\n    switch (tx_offload) {\n\n    case ROCKER_TX_OFFLOAD_L3_CSUM:\n\n        if (!tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]) {\n\n            return -ROCKER_EINVAL;\n\n        }\n\n        break;\n\n    case ROCKER_TX_OFFLOAD_TSO:\n\n        if (!tlvs[ROCKER_TLV_TX_TSO_MSS] ||\n\n            !tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]) {\n\n            return -ROCKER_EINVAL;\n\n        }\n\n        break;\n\n    }\n\n\n\n    if (tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]) {\n\n        tx_l3_csum_off = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]);\n\n    }\n\n\n\n    if (tlvs[ROCKER_TLV_TX_TSO_MSS]) {\n\n        tx_tso_mss = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_TSO_MSS]);\n\n    }\n\n\n\n    if (tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]) {\n\n        tx_tso_hdr_len = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]);\n\n    }\n\n\n\n    rocker_tlv_for_each_nested(tlv_frag, tlvs[ROCKER_TLV_TX_FRAGS], rem) {\n\n        hwaddr frag_addr;\n\n        uint16_t frag_len;\n\n\n\n        if (rocker_tlv_type(tlv_frag) != ROCKER_TLV_TX_FRAG) {\n\n            err = -ROCKER_EINVAL;\n\n            goto err_bad_attr;\n\n        }\n\n\n\n        rocker_tlv_parse_nested(tlvs, ROCKER_TLV_TX_FRAG_ATTR_MAX, tlv_frag);\n\n\n\n        if (!tlvs[ROCKER_TLV_TX_FRAG_ATTR_ADDR] ||\n\n            !tlvs[ROCKER_TLV_TX_FRAG_ATTR_LEN]) {\n\n            err = -ROCKER_EINVAL;\n\n            goto err_bad_attr;\n\n        }\n\n\n\n        frag_addr = rocker_tlv_get_le64(tlvs[ROCKER_TLV_TX_FRAG_ATTR_ADDR]);\n\n        frag_len = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_FRAG_ATTR_LEN]);\n\n\n\n        iov[iovcnt].iov_len = frag_len;\n\n        iov[iovcnt].iov_base = g_malloc(frag_len);\n\n        if (!iov[iovcnt].iov_base) {\n\n            err = -ROCKER_ENOMEM;\n\n            goto err_no_mem;\n\n        }\n\n\n\n        if (pci_dma_read(dev, frag_addr, iov[iovcnt].iov_base,\n\n                     iov[iovcnt].iov_len)) {\n\n            err = -ROCKER_ENXIO;\n\n            goto err_bad_io;\n\n        }\n\n\n\n        if (++iovcnt > ROCKER_TX_FRAGS_MAX) {\n\n            goto err_too_many_frags;\n\n        }\n\n    }\n\n\n\n    if (iovcnt) {\n\n        /* XXX perform Tx offloads */\n\n        /* XXX   silence compiler for now */\n\n        tx_l3_csum_off += tx_tso_mss = tx_tso_hdr_len = 0;\n\n    }\n\n\n\n    err = fp_port_eg(r->fp_port[port], iov, iovcnt);\n\n\n\nerr_too_many_frags:\n\nerr_bad_io:\n\nerr_no_mem:\n\nerr_bad_attr:\n\n    for (i = 0; i < ROCKER_TX_FRAGS_MAX; i++) {\n\n        g_free(iov[i].iov_base);\n\n    }\n\n\n\n    return err;\n\n}\n", "idx": 24033}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_neon_dup_low16(TCGv var)\n\n{\n\n    TCGv tmp = new_tmp();\n\n    tcg_gen_ext16u_i32(var, var);\n\n    tcg_gen_shli_i32(tmp, var, 16);\n\n    tcg_gen_or_i32(var, var, tmp);\n\n    dead_tmp(tmp);\n\n}\n", "idx": 24034}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static void audio_print_settings (audsettings_t *as)\n\n{\n\n    dolog (\"frequency=%d nchannels=%d fmt=\", as->freq, as->nchannels);\n\n\n\n    switch (as->fmt) {\n\n    case AUD_FMT_S8:\n\n        AUD_log (NULL, \"S8\");\n\n        break;\n\n    case AUD_FMT_U8:\n\n        AUD_log (NULL, \"U8\");\n\n        break;\n\n    case AUD_FMT_S16:\n\n        AUD_log (NULL, \"S16\");\n\n        break;\n\n    case AUD_FMT_U16:\n\n        AUD_log (NULL, \"U16\");\n\n        break;\n\n    case AUD_FMT_S32:\n\n        AUD_log (NULL, \"S32\");\n\n        break;\n\n    case AUD_FMT_U32:\n\n        AUD_log (NULL, \"U32\");\n\n        break;\n\n    default:\n\n        AUD_log (NULL, \"invalid(%d)\", as->fmt);\n\n        break;\n\n    }\n\n\n\n    AUD_log (NULL, \" endianness=\");\n\n    switch (as->endianness) {\n\n    case 0:\n\n        AUD_log (NULL, \"little\");\n\n        break;\n\n    case 1:\n\n        AUD_log (NULL, \"big\");\n\n        break;\n\n    default:\n\n        AUD_log (NULL, \"invalid\");\n\n        break;\n\n    }\n\n    AUD_log (NULL, \"\\n\");\n\n}\n", "idx": 24035}
{"project": "qemu", "commit_id": "7bd427d801e1e3293a634d3c83beadaa90ffb911", "target": 0, "func": "static void vnc_refresh(void *opaque)\n\n{\n\n    VncDisplay *vd = opaque;\n\n    VncState *vs, *vn;\n\n    int has_dirty, rects = 0;\n\n\n\n    vga_hw_update();\n\n\n\n    if (vnc_trylock_display(vd)) {\n\n        vd->timer_interval = VNC_REFRESH_INTERVAL_BASE;\n\n        qemu_mod_timer(vd->timer, qemu_get_clock(rt_clock) +\n\n                       vd->timer_interval);\n\n        return;\n\n    }\n\n\n\n    has_dirty = vnc_refresh_server_surface(vd);\n\n    vnc_unlock_display(vd);\n\n\n\n    QTAILQ_FOREACH_SAFE(vs, &vd->clients, next, vn) {\n\n        rects += vnc_update_client(vs, has_dirty);\n\n        /* vs might be free()ed here */\n\n    }\n\n\n\n    /* vd->timer could be NULL now if the last client disconnected,\n\n     * in this case don't update the timer */\n\n    if (vd->timer == NULL)\n\n        return;\n\n\n\n    if (has_dirty && rects) {\n\n        vd->timer_interval /= 2;\n\n        if (vd->timer_interval < VNC_REFRESH_INTERVAL_BASE)\n\n            vd->timer_interval = VNC_REFRESH_INTERVAL_BASE;\n\n    } else {\n\n        vd->timer_interval += VNC_REFRESH_INTERVAL_INC;\n\n        if (vd->timer_interval > VNC_REFRESH_INTERVAL_MAX)\n\n            vd->timer_interval = VNC_REFRESH_INTERVAL_MAX;\n\n    }\n\n    qemu_mod_timer(vd->timer, qemu_get_clock(rt_clock) + vd->timer_interval);\n\n}\n", "idx": 24036}
{"project": "qemu", "commit_id": "d4d34b0d3f5af5c8e09980da0de2eebe9a27dc71", "target": 0, "func": "static void set_pointer(Object *obj, Visitor *v, Property *prop,\n\n                        int (*parse)(DeviceState *dev, const char *str, void **ptr),\n\n                        const char *name, Error **errp)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Error *local_err = NULL;\n\n    void **ptr = qdev_get_prop_ptr(dev, prop);\n\n    char *str;\n\n    int ret;\n\n\n\n    if (dev->state != DEV_STATE_CREATED) {\n\n        error_set(errp, QERR_PERMISSION_DENIED);\n\n        return;\n\n    }\n\n\n\n    visit_type_str(v, &str, name, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n    if (!*str) {\n\n        g_free(str);\n\n        *ptr = NULL;\n\n        return;\n\n    }\n\n    ret = parse(dev, str, ptr);\n\n    error_set_from_qdev_prop_error(errp, ret, dev, prop, str);\n\n    g_free(str);\n\n}\n", "idx": 24038}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "func": "static int scsi_hd_initfn(SCSIDevice *dev)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, dev);\n\n    s->qdev.blocksize = s->qdev.conf.logical_block_size;\n\n    s->qdev.type = TYPE_DISK;\n\n    if (!s->product) {\n\n        s->product = g_strdup(\"QEMU HARDDISK\");\n\n    }\n\n    return scsi_initfn(&s->qdev);\n\n}\n", "idx": 24039}
{"project": "qemu", "commit_id": "2c30dd744aa02d31a8a3b87daaba0b2cb774f346", "target": 0, "func": "static int local_parse_opts(QemuOpts *opts, struct FsDriverEntry *fse)\n\n{\n\n    const char *sec_model = qemu_opt_get(opts, \"security_model\");\n\n    const char *path = qemu_opt_get(opts, \"path\");\n\n\n\n    if (!sec_model) {\n\n        fprintf(stderr, \"security model not specified, \"\n\n                \"local fs needs security model\\nvalid options are:\"\n\n                \"\\tsecurity_model=[passthrough|mapped|none]\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (!strcmp(sec_model, \"passthrough\")) {\n\n        fse->export_flags |= V9FS_SM_PASSTHROUGH;\n\n    } else if (!strcmp(sec_model, \"mapped\")) {\n\n        fse->export_flags |= V9FS_SM_MAPPED;\n\n    } else if (!strcmp(sec_model, \"none\")) {\n\n        fse->export_flags |= V9FS_SM_NONE;\n\n    } else {\n\n        fprintf(stderr, \"Invalid security model %s specified, valid options are\"\n\n                \"\\n\\t [passthrough|mapped|none]\\n\", sec_model);\n\n        return -1;\n\n    }\n\n\n\n    if (!path) {\n\n        fprintf(stderr, \"fsdev: No path specified.\\n\");\n\n        return -1;\n\n    }\n\n    fse->path = g_strdup(path);\n\n\n\n    return 0;\n\n}\n", "idx": 24040}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "static void spr_write_dbatl_h (void *opaque, int sprn)\n\n{\n\n    DisasContext *ctx = opaque;\n\n\n\n    gen_op_store_dbatl((sprn - SPR_DBAT4L) / 2);\n\n    RET_STOP(ctx);\n\n}\n", "idx": 24041}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float64 HELPER(ucf64_sf2df)(float32 x, CPUUniCore32State *env)\n\n{\n\n    return float32_to_float64(x, &env->ucf64.fp_status);\n\n}\n", "idx": 24042}
{"project": "qemu", "commit_id": "548f66db33b91bf305c4e5228bb29585701ab58d", "target": 0, "func": "static void do_branch_reg(DisasContext *dc, int32_t offset, uint32_t insn,\n\n                          TCGv r_cond, TCGv r_reg)\n\n{\n\n    unsigned int cond = GET_FIELD_SP(insn, 25, 27), a = (insn & (1 << 29));\n\n    target_ulong target = dc->pc + offset;\n\n\n\n    flush_cond(dc, r_cond);\n\n    gen_cond_reg(r_cond, cond, r_reg);\n\n    if (a) {\n\n        gen_branch_a(dc, target, dc->npc, r_cond);\n\n        dc->is_br = 1;\n\n    } else {\n\n        dc->pc = dc->npc;\n\n        dc->jump_pc[0] = target;\n\n        dc->jump_pc[1] = dc->npc + 4;\n\n        dc->npc = JUMP_PC;\n\n    }\n\n}\n", "idx": 24043}
{"project": "qemu", "commit_id": "2cd53943115be5118b5b2d4b80ee0a39c94c4f73", "target": 0, "func": "static void cpu_common_reset(CPUState *cpu)\n\n{\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n\n\n    if (qemu_loglevel_mask(CPU_LOG_RESET)) {\n\n        qemu_log(\"CPU Reset (CPU %d)\\n\", cpu->cpu_index);\n\n        log_cpu_state(cpu, cc->reset_dump_flags);\n\n    }\n\n\n\n    cpu->interrupt_request = 0;\n\n    cpu->halted = 0;\n\n    cpu->mem_io_pc = 0;\n\n    cpu->mem_io_vaddr = 0;\n\n    cpu->icount_extra = 0;\n\n    cpu->icount_decr.u32 = 0;\n\n    cpu->can_do_io = 1;\n\n    cpu->exception_index = -1;\n\n    cpu->crash_occurred = false;\n\n\n\n    if (tcg_enabled()) {\n\n        cpu_tb_jmp_cache_clear(cpu);\n\n\n\n#ifdef CONFIG_SOFTMMU\n\n        tlb_flush(cpu, 0);\n\n#endif\n\n    }\n\n}\n", "idx": 24044}
{"project": "qemu", "commit_id": "a9321a4d49d65d29c2926a51aedc5b91a01f3591", "target": 0, "func": "static target_ulong disas_insn(DisasContext *s, target_ulong pc_start)\n\n{\n\n    int b, prefixes, aflag, dflag;\n\n    int shift, ot;\n\n    int modrm, reg, rm, mod, reg_addr, op, opreg, offset_addr, val;\n\n    target_ulong next_eip, tval;\n\n    int rex_w, rex_r;\n\n\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {\n\n        tcg_gen_debug_insn_start(pc_start);\n\n    }\n\n    s->pc = pc_start;\n\n    prefixes = 0;\n\n    aflag = s->code32;\n\n    dflag = s->code32;\n\n    s->override = -1;\n\n    rex_w = -1;\n\n    rex_r = 0;\n\n#ifdef TARGET_X86_64\n\n    s->rex_x = 0;\n\n    s->rex_b = 0;\n\n    x86_64_hregs = 0;\n\n#endif\n\n    s->rip_offset = 0; /* for relative ip address */\n\n next_byte:\n\n    b = cpu_ldub_code(cpu_single_env, s->pc);\n\n    s->pc++;\n\n    /* check prefixes */\n\n#ifdef TARGET_X86_64\n\n    if (CODE64(s)) {\n\n        switch (b) {\n\n        case 0xf3:\n\n            prefixes |= PREFIX_REPZ;\n\n            goto next_byte;\n\n        case 0xf2:\n\n            prefixes |= PREFIX_REPNZ;\n\n            goto next_byte;\n\n        case 0xf0:\n\n            prefixes |= PREFIX_LOCK;\n\n            goto next_byte;\n\n        case 0x2e:\n\n            s->override = R_CS;\n\n            goto next_byte;\n\n        case 0x36:\n\n            s->override = R_SS;\n\n            goto next_byte;\n\n        case 0x3e:\n\n            s->override = R_DS;\n\n            goto next_byte;\n\n        case 0x26:\n\n            s->override = R_ES;\n\n            goto next_byte;\n\n        case 0x64:\n\n            s->override = R_FS;\n\n            goto next_byte;\n\n        case 0x65:\n\n            s->override = R_GS;\n\n            goto next_byte;\n\n        case 0x66:\n\n            prefixes |= PREFIX_DATA;\n\n            goto next_byte;\n\n        case 0x67:\n\n            prefixes |= PREFIX_ADR;\n\n            goto next_byte;\n\n        case 0x40 ... 0x4f:\n\n            /* REX prefix */\n\n            rex_w = (b >> 3) & 1;\n\n            rex_r = (b & 0x4) << 1;\n\n            s->rex_x = (b & 0x2) << 2;\n\n            REX_B(s) = (b & 0x1) << 3;\n\n            x86_64_hregs = 1; /* select uniform byte register addressing */\n\n            goto next_byte;\n\n        }\n\n        if (rex_w == 1) {\n\n            /* 0x66 is ignored if rex.w is set */\n\n            dflag = 2;\n\n        } else {\n\n            if (prefixes & PREFIX_DATA)\n\n                dflag ^= 1;\n\n        }\n\n        if (!(prefixes & PREFIX_ADR))\n\n            aflag = 2;\n\n    } else\n\n#endif\n\n    {\n\n        switch (b) {\n\n        case 0xf3:\n\n            prefixes |= PREFIX_REPZ;\n\n            goto next_byte;\n\n        case 0xf2:\n\n            prefixes |= PREFIX_REPNZ;\n\n            goto next_byte;\n\n        case 0xf0:\n\n            prefixes |= PREFIX_LOCK;\n\n            goto next_byte;\n\n        case 0x2e:\n\n            s->override = R_CS;\n\n            goto next_byte;\n\n        case 0x36:\n\n            s->override = R_SS;\n\n            goto next_byte;\n\n        case 0x3e:\n\n            s->override = R_DS;\n\n            goto next_byte;\n\n        case 0x26:\n\n            s->override = R_ES;\n\n            goto next_byte;\n\n        case 0x64:\n\n            s->override = R_FS;\n\n            goto next_byte;\n\n        case 0x65:\n\n            s->override = R_GS;\n\n            goto next_byte;\n\n        case 0x66:\n\n            prefixes |= PREFIX_DATA;\n\n            goto next_byte;\n\n        case 0x67:\n\n            prefixes |= PREFIX_ADR;\n\n            goto next_byte;\n\n        }\n\n        if (prefixes & PREFIX_DATA)\n\n            dflag ^= 1;\n\n        if (prefixes & PREFIX_ADR)\n\n            aflag ^= 1;\n\n    }\n\n\n\n    s->prefix = prefixes;\n\n    s->aflag = aflag;\n\n    s->dflag = dflag;\n\n\n\n    /* lock generation */\n\n    if (prefixes & PREFIX_LOCK)\n\n        gen_helper_lock();\n\n\n\n    /* now check op code */\n\n reswitch:\n\n    switch(b) {\n\n    case 0x0f:\n\n        /**************************/\n\n        /* extended op code */\n\n        b = cpu_ldub_code(cpu_single_env, s->pc++) | 0x100;\n\n        goto reswitch;\n\n\n\n        /**************************/\n\n        /* arith & logic */\n\n    case 0x00 ... 0x05:\n\n    case 0x08 ... 0x0d:\n\n    case 0x10 ... 0x15:\n\n    case 0x18 ... 0x1d:\n\n    case 0x20 ... 0x25:\n\n    case 0x28 ... 0x2d:\n\n    case 0x30 ... 0x35:\n\n    case 0x38 ... 0x3d:\n\n        {\n\n            int op, f, val;\n\n            op = (b >> 3) & 7;\n\n            f = (b >> 1) & 3;\n\n\n\n            if ((b & 1) == 0)\n\n                ot = OT_BYTE;\n\n            else\n\n                ot = dflag + OT_WORD;\n\n\n\n            switch(f) {\n\n            case 0: /* OP Ev, Gv */\n\n                modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n                reg = ((modrm >> 3) & 7) | rex_r;\n\n                mod = (modrm >> 6) & 3;\n\n                rm = (modrm & 7) | REX_B(s);\n\n                if (mod != 3) {\n\n                    gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n                    opreg = OR_TMP0;\n\n                } else if (op == OP_XORL && rm == reg) {\n\n                xor_zero:\n\n                    /* xor reg, reg optimisation */\n\n                    gen_op_movl_T0_0();\n\n                    s->cc_op = CC_OP_LOGICB + ot;\n\n                    gen_op_mov_reg_T0(ot, reg);\n\n                    gen_op_update1_cc();\n\n                    break;\n\n                } else {\n\n                    opreg = rm;\n\n                }\n\n                gen_op_mov_TN_reg(ot, 1, reg);\n\n                gen_op(s, op, ot, opreg);\n\n                break;\n\n            case 1: /* OP Gv, Ev */\n\n                modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n                mod = (modrm >> 6) & 3;\n\n                reg = ((modrm >> 3) & 7) | rex_r;\n\n                rm = (modrm & 7) | REX_B(s);\n\n                if (mod != 3) {\n\n                    gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n                    gen_op_ld_T1_A0(ot + s->mem_index);\n\n                } else if (op == OP_XORL && rm == reg) {\n\n                    goto xor_zero;\n\n                } else {\n\n                    gen_op_mov_TN_reg(ot, 1, rm);\n\n                }\n\n                gen_op(s, op, ot, reg);\n\n                break;\n\n            case 2: /* OP A, Iv */\n\n                val = insn_get(s, ot);\n\n                gen_op_movl_T1_im(val);\n\n                gen_op(s, op, ot, OR_EAX);\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 0x82:\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n    case 0x80: /* GRP1 */\n\n    case 0x81:\n\n    case 0x83:\n\n        {\n\n            int val;\n\n\n\n            if ((b & 1) == 0)\n\n                ot = OT_BYTE;\n\n            else\n\n                ot = dflag + OT_WORD;\n\n\n\n            modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n            mod = (modrm >> 6) & 3;\n\n            rm = (modrm & 7) | REX_B(s);\n\n            op = (modrm >> 3) & 7;\n\n\n\n            if (mod != 3) {\n\n                if (b == 0x83)\n\n                    s->rip_offset = 1;\n\n                else\n\n                    s->rip_offset = insn_const_size(ot);\n\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n                opreg = OR_TMP0;\n\n            } else {\n\n                opreg = rm;\n\n            }\n\n\n\n            switch(b) {\n\n            default:\n\n            case 0x80:\n\n            case 0x81:\n\n            case 0x82:\n\n                val = insn_get(s, ot);\n\n                break;\n\n            case 0x83:\n\n                val = (int8_t)insn_get(s, OT_BYTE);\n\n                break;\n\n            }\n\n            gen_op_movl_T1_im(val);\n\n            gen_op(s, op, ot, opreg);\n\n        }\n\n        break;\n\n\n\n        /**************************/\n\n        /* inc, dec, and other misc arith */\n\n    case 0x40 ... 0x47: /* inc Gv */\n\n        ot = dflag ? OT_LONG : OT_WORD;\n\n        gen_inc(s, ot, OR_EAX + (b & 7), 1);\n\n        break;\n\n    case 0x48 ... 0x4f: /* dec Gv */\n\n        ot = dflag ? OT_LONG : OT_WORD;\n\n        gen_inc(s, ot, OR_EAX + (b & 7), -1);\n\n        break;\n\n    case 0xf6: /* GRP3 */\n\n    case 0xf7:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag + OT_WORD;\n\n\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        op = (modrm >> 3) & 7;\n\n        if (mod != 3) {\n\n            if (op == 0)\n\n                s->rip_offset = insn_const_size(ot);\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            gen_op_ld_T0_A0(ot + s->mem_index);\n\n        } else {\n\n            gen_op_mov_TN_reg(ot, 0, rm);\n\n        }\n\n\n\n        switch(op) {\n\n        case 0: /* test */\n\n            val = insn_get(s, ot);\n\n            gen_op_movl_T1_im(val);\n\n            gen_op_testl_T0_T1_cc();\n\n            s->cc_op = CC_OP_LOGICB + ot;\n\n            break;\n\n        case 2: /* not */\n\n            tcg_gen_not_tl(cpu_T[0], cpu_T[0]);\n\n            if (mod != 3) {\n\n                gen_op_st_T0_A0(ot + s->mem_index);\n\n            } else {\n\n                gen_op_mov_reg_T0(ot, rm);\n\n            }\n\n            break;\n\n        case 3: /* neg */\n\n            tcg_gen_neg_tl(cpu_T[0], cpu_T[0]);\n\n            if (mod != 3) {\n\n                gen_op_st_T0_A0(ot + s->mem_index);\n\n            } else {\n\n                gen_op_mov_reg_T0(ot, rm);\n\n            }\n\n            gen_op_update_neg_cc();\n\n            s->cc_op = CC_OP_SUBB + ot;\n\n            break;\n\n        case 4: /* mul */\n\n            switch(ot) {\n\n            case OT_BYTE:\n\n                gen_op_mov_TN_reg(OT_BYTE, 1, R_EAX);\n\n                tcg_gen_ext8u_tl(cpu_T[0], cpu_T[0]);\n\n                tcg_gen_ext8u_tl(cpu_T[1], cpu_T[1]);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n\n                gen_op_mov_reg_T0(OT_WORD, R_EAX);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n\n                tcg_gen_andi_tl(cpu_cc_src, cpu_T[0], 0xff00);\n\n                s->cc_op = CC_OP_MULB;\n\n                break;\n\n            case OT_WORD:\n\n                gen_op_mov_TN_reg(OT_WORD, 1, R_EAX);\n\n                tcg_gen_ext16u_tl(cpu_T[0], cpu_T[0]);\n\n                tcg_gen_ext16u_tl(cpu_T[1], cpu_T[1]);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n\n                gen_op_mov_reg_T0(OT_WORD, R_EAX);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n\n                tcg_gen_shri_tl(cpu_T[0], cpu_T[0], 16);\n\n                gen_op_mov_reg_T0(OT_WORD, R_EDX);\n\n                tcg_gen_mov_tl(cpu_cc_src, cpu_T[0]);\n\n                s->cc_op = CC_OP_MULW;\n\n                break;\n\n            default:\n\n            case OT_LONG:\n\n#ifdef TARGET_X86_64\n\n                gen_op_mov_TN_reg(OT_LONG, 1, R_EAX);\n\n                tcg_gen_ext32u_tl(cpu_T[0], cpu_T[0]);\n\n                tcg_gen_ext32u_tl(cpu_T[1], cpu_T[1]);\n\n                tcg_gen_mul_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n\n                gen_op_mov_reg_T0(OT_LONG, R_EAX);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n\n                tcg_gen_shri_tl(cpu_T[0], cpu_T[0], 32);\n\n                gen_op_mov_reg_T0(OT_LONG, R_EDX);\n\n                tcg_gen_mov_tl(cpu_cc_src, cpu_T[0]);\n\n#else\n\n                {\n\n                    TCGv_i64 t0, t1;\n\n                    t0 = tcg_temp_new_i64();\n\n                    t1 = tcg_temp_new_i64();\n\n                    gen_op_mov_TN_reg(OT_LONG, 1, R_EAX);\n\n                    tcg_gen_extu_i32_i64(t0, cpu_T[0]);\n\n                    tcg_gen_extu_i32_i64(t1, cpu_T[1]);\n\n                    tcg_gen_mul_i64(t0, t0, t1);\n\n                    tcg_gen_trunc_i64_i32(cpu_T[0], t0);\n\n                    gen_op_mov_reg_T0(OT_LONG, R_EAX);\n\n                    tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n\n                    tcg_gen_shri_i64(t0, t0, 32);\n\n                    tcg_gen_trunc_i64_i32(cpu_T[0], t0);\n\n                    gen_op_mov_reg_T0(OT_LONG, R_EDX);\n\n                    tcg_gen_mov_tl(cpu_cc_src, cpu_T[0]);\n\n                }\n\n#endif\n\n                s->cc_op = CC_OP_MULL;\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case OT_QUAD:\n\n                gen_helper_mulq_EAX_T0(cpu_env, cpu_T[0]);\n\n                s->cc_op = CC_OP_MULQ;\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        case 5: /* imul */\n\n            switch(ot) {\n\n            case OT_BYTE:\n\n                gen_op_mov_TN_reg(OT_BYTE, 1, R_EAX);\n\n                tcg_gen_ext8s_tl(cpu_T[0], cpu_T[0]);\n\n                tcg_gen_ext8s_tl(cpu_T[1], cpu_T[1]);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n\n                gen_op_mov_reg_T0(OT_WORD, R_EAX);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n\n                tcg_gen_ext8s_tl(cpu_tmp0, cpu_T[0]);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T[0], cpu_tmp0);\n\n                s->cc_op = CC_OP_MULB;\n\n                break;\n\n            case OT_WORD:\n\n                gen_op_mov_TN_reg(OT_WORD, 1, R_EAX);\n\n                tcg_gen_ext16s_tl(cpu_T[0], cpu_T[0]);\n\n                tcg_gen_ext16s_tl(cpu_T[1], cpu_T[1]);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n\n                gen_op_mov_reg_T0(OT_WORD, R_EAX);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n\n                tcg_gen_ext16s_tl(cpu_tmp0, cpu_T[0]);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T[0], cpu_tmp0);\n\n                tcg_gen_shri_tl(cpu_T[0], cpu_T[0], 16);\n\n                gen_op_mov_reg_T0(OT_WORD, R_EDX);\n\n                s->cc_op = CC_OP_MULW;\n\n                break;\n\n            default:\n\n            case OT_LONG:\n\n#ifdef TARGET_X86_64\n\n                gen_op_mov_TN_reg(OT_LONG, 1, R_EAX);\n\n                tcg_gen_ext32s_tl(cpu_T[0], cpu_T[0]);\n\n                tcg_gen_ext32s_tl(cpu_T[1], cpu_T[1]);\n\n                tcg_gen_mul_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n\n                gen_op_mov_reg_T0(OT_LONG, R_EAX);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n\n                tcg_gen_ext32s_tl(cpu_tmp0, cpu_T[0]);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T[0], cpu_tmp0);\n\n                tcg_gen_shri_tl(cpu_T[0], cpu_T[0], 32);\n\n                gen_op_mov_reg_T0(OT_LONG, R_EDX);\n\n#else\n\n                {\n\n                    TCGv_i64 t0, t1;\n\n                    t0 = tcg_temp_new_i64();\n\n                    t1 = tcg_temp_new_i64();\n\n                    gen_op_mov_TN_reg(OT_LONG, 1, R_EAX);\n\n                    tcg_gen_ext_i32_i64(t0, cpu_T[0]);\n\n                    tcg_gen_ext_i32_i64(t1, cpu_T[1]);\n\n                    tcg_gen_mul_i64(t0, t0, t1);\n\n                    tcg_gen_trunc_i64_i32(cpu_T[0], t0);\n\n                    gen_op_mov_reg_T0(OT_LONG, R_EAX);\n\n                    tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n\n                    tcg_gen_sari_tl(cpu_tmp0, cpu_T[0], 31);\n\n                    tcg_gen_shri_i64(t0, t0, 32);\n\n                    tcg_gen_trunc_i64_i32(cpu_T[0], t0);\n\n                    gen_op_mov_reg_T0(OT_LONG, R_EDX);\n\n                    tcg_gen_sub_tl(cpu_cc_src, cpu_T[0], cpu_tmp0);\n\n                }\n\n#endif\n\n                s->cc_op = CC_OP_MULL;\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case OT_QUAD:\n\n                gen_helper_imulq_EAX_T0(cpu_env, cpu_T[0]);\n\n                s->cc_op = CC_OP_MULQ;\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        case 6: /* div */\n\n            switch(ot) {\n\n            case OT_BYTE:\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_divb_AL(cpu_env, cpu_T[0]);\n\n                break;\n\n            case OT_WORD:\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_divw_AX(cpu_env, cpu_T[0]);\n\n                break;\n\n            default:\n\n            case OT_LONG:\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_divl_EAX(cpu_env, cpu_T[0]);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case OT_QUAD:\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_divq_EAX(cpu_env, cpu_T[0]);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        case 7: /* idiv */\n\n            switch(ot) {\n\n            case OT_BYTE:\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_idivb_AL(cpu_env, cpu_T[0]);\n\n                break;\n\n            case OT_WORD:\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_idivw_AX(cpu_env, cpu_T[0]);\n\n                break;\n\n            default:\n\n            case OT_LONG:\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_idivl_EAX(cpu_env, cpu_T[0]);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case OT_QUAD:\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_idivq_EAX(cpu_env, cpu_T[0]);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        default:\n\n            goto illegal_op;\n\n        }\n\n        break;\n\n\n\n    case 0xfe: /* GRP4 */\n\n    case 0xff: /* GRP5 */\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag + OT_WORD;\n\n\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        op = (modrm >> 3) & 7;\n\n        if (op >= 2 && b == 0xfe) {\n\n            goto illegal_op;\n\n        }\n\n        if (CODE64(s)) {\n\n            if (op == 2 || op == 4) {\n\n                /* operand size for jumps is 64 bit */\n\n                ot = OT_QUAD;\n\n            } else if (op == 3 || op == 5) {\n\n                ot = dflag ? OT_LONG + (rex_w == 1) : OT_WORD;\n\n            } else if (op == 6) {\n\n                /* default push size is 64 bit */\n\n                ot = dflag ? OT_QUAD : OT_WORD;\n\n            }\n\n        }\n\n        if (mod != 3) {\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            if (op >= 2 && op != 3 && op != 5)\n\n                gen_op_ld_T0_A0(ot + s->mem_index);\n\n        } else {\n\n            gen_op_mov_TN_reg(ot, 0, rm);\n\n        }\n\n\n\n        switch(op) {\n\n        case 0: /* inc Ev */\n\n            if (mod != 3)\n\n                opreg = OR_TMP0;\n\n            else\n\n                opreg = rm;\n\n            gen_inc(s, ot, opreg, 1);\n\n            break;\n\n        case 1: /* dec Ev */\n\n            if (mod != 3)\n\n                opreg = OR_TMP0;\n\n            else\n\n                opreg = rm;\n\n            gen_inc(s, ot, opreg, -1);\n\n            break;\n\n        case 2: /* call Ev */\n\n            /* XXX: optimize if memory (no 'and' is necessary) */\n\n            if (s->dflag == 0)\n\n                gen_op_andl_T0_ffff();\n\n            next_eip = s->pc - s->cs_base;\n\n            gen_movtl_T1_im(next_eip);\n\n            gen_push_T1(s);\n\n            gen_op_jmp_T0();\n\n            gen_eob(s);\n\n            break;\n\n        case 3: /* lcall Ev */\n\n            gen_op_ld_T1_A0(ot + s->mem_index);\n\n            gen_add_A0_im(s, 1 << (ot - OT_WORD + 1));\n\n            gen_op_ldu_T0_A0(OT_WORD + s->mem_index);\n\n        do_lcall:\n\n            if (s->pe && !s->vm86) {\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                gen_helper_lcall_protected(cpu_env, cpu_tmp2_i32, cpu_T[1],\n\n                                           tcg_const_i32(dflag),\n\n                                           tcg_const_i32(s->pc - pc_start));\n\n            } else {\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                gen_helper_lcall_real(cpu_env, cpu_tmp2_i32, cpu_T[1],\n\n                                      tcg_const_i32(dflag),\n\n                                      tcg_const_i32(s->pc - s->cs_base));\n\n            }\n\n            gen_eob(s);\n\n            break;\n\n        case 4: /* jmp Ev */\n\n            if (s->dflag == 0)\n\n                gen_op_andl_T0_ffff();\n\n            gen_op_jmp_T0();\n\n            gen_eob(s);\n\n            break;\n\n        case 5: /* ljmp Ev */\n\n            gen_op_ld_T1_A0(ot + s->mem_index);\n\n            gen_add_A0_im(s, 1 << (ot - OT_WORD + 1));\n\n            gen_op_ldu_T0_A0(OT_WORD + s->mem_index);\n\n        do_ljmp:\n\n            if (s->pe && !s->vm86) {\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                gen_helper_ljmp_protected(cpu_env, cpu_tmp2_i32, cpu_T[1],\n\n                                          tcg_const_i32(s->pc - pc_start));\n\n            } else {\n\n                gen_op_movl_seg_T0_vm(R_CS);\n\n                gen_op_movl_T0_T1();\n\n                gen_op_jmp_T0();\n\n            }\n\n            gen_eob(s);\n\n            break;\n\n        case 6: /* push Ev */\n\n            gen_push_T0(s);\n\n            break;\n\n        default:\n\n            goto illegal_op;\n\n        }\n\n        break;\n\n\n\n    case 0x84: /* test Ev, Gv */\n\n    case 0x85:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag + OT_WORD;\n\n\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        gen_ldst_modrm(s, modrm, ot, OR_TMP0, 0);\n\n        gen_op_mov_TN_reg(ot, 1, reg);\n\n        gen_op_testl_T0_T1_cc();\n\n        s->cc_op = CC_OP_LOGICB + ot;\n\n        break;\n\n\n\n    case 0xa8: /* test eAX, Iv */\n\n    case 0xa9:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag + OT_WORD;\n\n        val = insn_get(s, ot);\n\n\n\n        gen_op_mov_TN_reg(ot, 0, OR_EAX);\n\n        gen_op_movl_T1_im(val);\n\n        gen_op_testl_T0_T1_cc();\n\n        s->cc_op = CC_OP_LOGICB + ot;\n\n        break;\n\n\n\n    case 0x98: /* CWDE/CBW */\n\n#ifdef TARGET_X86_64\n\n        if (dflag == 2) {\n\n            gen_op_mov_TN_reg(OT_LONG, 0, R_EAX);\n\n            tcg_gen_ext32s_tl(cpu_T[0], cpu_T[0]);\n\n            gen_op_mov_reg_T0(OT_QUAD, R_EAX);\n\n        } else\n\n#endif\n\n        if (dflag == 1) {\n\n            gen_op_mov_TN_reg(OT_WORD, 0, R_EAX);\n\n            tcg_gen_ext16s_tl(cpu_T[0], cpu_T[0]);\n\n            gen_op_mov_reg_T0(OT_LONG, R_EAX);\n\n        } else {\n\n            gen_op_mov_TN_reg(OT_BYTE, 0, R_EAX);\n\n            tcg_gen_ext8s_tl(cpu_T[0], cpu_T[0]);\n\n            gen_op_mov_reg_T0(OT_WORD, R_EAX);\n\n        }\n\n        break;\n\n    case 0x99: /* CDQ/CWD */\n\n#ifdef TARGET_X86_64\n\n        if (dflag == 2) {\n\n            gen_op_mov_TN_reg(OT_QUAD, 0, R_EAX);\n\n            tcg_gen_sari_tl(cpu_T[0], cpu_T[0], 63);\n\n            gen_op_mov_reg_T0(OT_QUAD, R_EDX);\n\n        } else\n\n#endif\n\n        if (dflag == 1) {\n\n            gen_op_mov_TN_reg(OT_LONG, 0, R_EAX);\n\n            tcg_gen_ext32s_tl(cpu_T[0], cpu_T[0]);\n\n            tcg_gen_sari_tl(cpu_T[0], cpu_T[0], 31);\n\n            gen_op_mov_reg_T0(OT_LONG, R_EDX);\n\n        } else {\n\n            gen_op_mov_TN_reg(OT_WORD, 0, R_EAX);\n\n            tcg_gen_ext16s_tl(cpu_T[0], cpu_T[0]);\n\n            tcg_gen_sari_tl(cpu_T[0], cpu_T[0], 15);\n\n            gen_op_mov_reg_T0(OT_WORD, R_EDX);\n\n        }\n\n        break;\n\n    case 0x1af: /* imul Gv, Ev */\n\n    case 0x69: /* imul Gv, Ev, I */\n\n    case 0x6b:\n\n        ot = dflag + OT_WORD;\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        if (b == 0x69)\n\n            s->rip_offset = insn_const_size(ot);\n\n        else if (b == 0x6b)\n\n            s->rip_offset = 1;\n\n        gen_ldst_modrm(s, modrm, ot, OR_TMP0, 0);\n\n        if (b == 0x69) {\n\n            val = insn_get(s, ot);\n\n            gen_op_movl_T1_im(val);\n\n        } else if (b == 0x6b) {\n\n            val = (int8_t)insn_get(s, OT_BYTE);\n\n            gen_op_movl_T1_im(val);\n\n        } else {\n\n            gen_op_mov_TN_reg(ot, 1, reg);\n\n        }\n\n\n\n#ifdef TARGET_X86_64\n\n        if (ot == OT_QUAD) {\n\n            gen_helper_imulq_T0_T1(cpu_T[0], cpu_env, cpu_T[0], cpu_T[1]);\n\n        } else\n\n#endif\n\n        if (ot == OT_LONG) {\n\n#ifdef TARGET_X86_64\n\n                tcg_gen_ext32s_tl(cpu_T[0], cpu_T[0]);\n\n                tcg_gen_ext32s_tl(cpu_T[1], cpu_T[1]);\n\n                tcg_gen_mul_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n\n                tcg_gen_ext32s_tl(cpu_tmp0, cpu_T[0]);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T[0], cpu_tmp0);\n\n#else\n\n                {\n\n                    TCGv_i64 t0, t1;\n\n                    t0 = tcg_temp_new_i64();\n\n                    t1 = tcg_temp_new_i64();\n\n                    tcg_gen_ext_i32_i64(t0, cpu_T[0]);\n\n                    tcg_gen_ext_i32_i64(t1, cpu_T[1]);\n\n                    tcg_gen_mul_i64(t0, t0, t1);\n\n                    tcg_gen_trunc_i64_i32(cpu_T[0], t0);\n\n                    tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n\n                    tcg_gen_sari_tl(cpu_tmp0, cpu_T[0], 31);\n\n                    tcg_gen_shri_i64(t0, t0, 32);\n\n                    tcg_gen_trunc_i64_i32(cpu_T[1], t0);\n\n                    tcg_gen_sub_tl(cpu_cc_src, cpu_T[1], cpu_tmp0);\n\n                }\n\n#endif\n\n        } else {\n\n            tcg_gen_ext16s_tl(cpu_T[0], cpu_T[0]);\n\n            tcg_gen_ext16s_tl(cpu_T[1], cpu_T[1]);\n\n            /* XXX: use 32 bit mul which could be faster */\n\n            tcg_gen_mul_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n\n            tcg_gen_ext16s_tl(cpu_tmp0, cpu_T[0]);\n\n            tcg_gen_sub_tl(cpu_cc_src, cpu_T[0], cpu_tmp0);\n\n        }\n\n        gen_op_mov_reg_T0(ot, reg);\n\n        s->cc_op = CC_OP_MULB + ot;\n\n        break;\n\n    case 0x1c0:\n\n    case 0x1c1: /* xadd Ev, Gv */\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag + OT_WORD;\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3) {\n\n            rm = (modrm & 7) | REX_B(s);\n\n            gen_op_mov_TN_reg(ot, 0, reg);\n\n            gen_op_mov_TN_reg(ot, 1, rm);\n\n            gen_op_addl_T0_T1();\n\n            gen_op_mov_reg_T1(ot, reg);\n\n            gen_op_mov_reg_T0(ot, rm);\n\n        } else {\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            gen_op_mov_TN_reg(ot, 0, reg);\n\n            gen_op_ld_T1_A0(ot + s->mem_index);\n\n            gen_op_addl_T0_T1();\n\n            gen_op_st_T0_A0(ot + s->mem_index);\n\n            gen_op_mov_reg_T1(ot, reg);\n\n        }\n\n        gen_op_update2_cc();\n\n        s->cc_op = CC_OP_ADDB + ot;\n\n        break;\n\n    case 0x1b0:\n\n    case 0x1b1: /* cmpxchg Ev, Gv */\n\n        {\n\n            int label1, label2;\n\n            TCGv t0, t1, t2, a0;\n\n\n\n            if ((b & 1) == 0)\n\n                ot = OT_BYTE;\n\n            else\n\n                ot = dflag + OT_WORD;\n\n            modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            t0 = tcg_temp_local_new();\n\n            t1 = tcg_temp_local_new();\n\n            t2 = tcg_temp_local_new();\n\n            a0 = tcg_temp_local_new();\n\n            gen_op_mov_v_reg(ot, t1, reg);\n\n            if (mod == 3) {\n\n                rm = (modrm & 7) | REX_B(s);\n\n                gen_op_mov_v_reg(ot, t0, rm);\n\n            } else {\n\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n                tcg_gen_mov_tl(a0, cpu_A0);\n\n                gen_op_ld_v(ot + s->mem_index, t0, a0);\n\n                rm = 0; /* avoid warning */\n\n            }\n\n            label1 = gen_new_label();\n\n            tcg_gen_sub_tl(t2, cpu_regs[R_EAX], t0);\n\n            gen_extu(ot, t2);\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, t2, 0, label1);\n\n            label2 = gen_new_label();\n\n            if (mod == 3) {\n\n                gen_op_mov_reg_v(ot, R_EAX, t0);\n\n                tcg_gen_br(label2);\n\n                gen_set_label(label1);\n\n                gen_op_mov_reg_v(ot, rm, t1);\n\n            } else {\n\n                /* perform no-op store cycle like physical cpu; must be\n\n                   before changing accumulator to ensure idempotency if\n\n                   the store faults and the instruction is restarted */\n\n                gen_op_st_v(ot + s->mem_index, t0, a0);\n\n                gen_op_mov_reg_v(ot, R_EAX, t0);\n\n                tcg_gen_br(label2);\n\n                gen_set_label(label1);\n\n                gen_op_st_v(ot + s->mem_index, t1, a0);\n\n            }\n\n            gen_set_label(label2);\n\n            tcg_gen_mov_tl(cpu_cc_src, t0);\n\n            tcg_gen_mov_tl(cpu_cc_dst, t2);\n\n            s->cc_op = CC_OP_SUBB + ot;\n\n            tcg_temp_free(t0);\n\n            tcg_temp_free(t1);\n\n            tcg_temp_free(t2);\n\n            tcg_temp_free(a0);\n\n        }\n\n        break;\n\n    case 0x1c7: /* cmpxchg8b */\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        if ((mod == 3) || ((modrm & 0x38) != 0x8))\n\n            goto illegal_op;\n\n#ifdef TARGET_X86_64\n\n        if (dflag == 2) {\n\n            if (!(s->cpuid_ext_features & CPUID_EXT_CX16))\n\n                goto illegal_op;\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            if (s->cc_op != CC_OP_DYNAMIC)\n\n                gen_op_set_cc_op(s->cc_op);\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            gen_helper_cmpxchg16b(cpu_env, cpu_A0);\n\n        } else\n\n#endif        \n\n        {\n\n            if (!(s->cpuid_features & CPUID_CX8))\n\n                goto illegal_op;\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            if (s->cc_op != CC_OP_DYNAMIC)\n\n                gen_op_set_cc_op(s->cc_op);\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            gen_helper_cmpxchg8b(cpu_env, cpu_A0);\n\n        }\n\n        s->cc_op = CC_OP_EFLAGS;\n\n        break;\n\n\n\n        /**************************/\n\n        /* push/pop */\n\n    case 0x50 ... 0x57: /* push */\n\n        gen_op_mov_TN_reg(OT_LONG, 0, (b & 7) | REX_B(s));\n\n        gen_push_T0(s);\n\n        break;\n\n    case 0x58 ... 0x5f: /* pop */\n\n        if (CODE64(s)) {\n\n            ot = dflag ? OT_QUAD : OT_WORD;\n\n        } else {\n\n            ot = dflag + OT_WORD;\n\n        }\n\n        gen_pop_T0(s);\n\n        /* NOTE: order is important for pop %sp */\n\n        gen_pop_update(s);\n\n        gen_op_mov_reg_T0(ot, (b & 7) | REX_B(s));\n\n        break;\n\n    case 0x60: /* pusha */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_pusha(s);\n\n        break;\n\n    case 0x61: /* popa */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_popa(s);\n\n        break;\n\n    case 0x68: /* push Iv */\n\n    case 0x6a:\n\n        if (CODE64(s)) {\n\n            ot = dflag ? OT_QUAD : OT_WORD;\n\n        } else {\n\n            ot = dflag + OT_WORD;\n\n        }\n\n        if (b == 0x68)\n\n            val = insn_get(s, ot);\n\n        else\n\n            val = (int8_t)insn_get(s, OT_BYTE);\n\n        gen_op_movl_T0_im(val);\n\n        gen_push_T0(s);\n\n        break;\n\n    case 0x8f: /* pop Ev */\n\n        if (CODE64(s)) {\n\n            ot = dflag ? OT_QUAD : OT_WORD;\n\n        } else {\n\n            ot = dflag + OT_WORD;\n\n        }\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        gen_pop_T0(s);\n\n        if (mod == 3) {\n\n            /* NOTE: order is important for pop %sp */\n\n            gen_pop_update(s);\n\n            rm = (modrm & 7) | REX_B(s);\n\n            gen_op_mov_reg_T0(ot, rm);\n\n        } else {\n\n            /* NOTE: order is important too for MMU exceptions */\n\n            s->popl_esp_hack = 1 << ot;\n\n            gen_ldst_modrm(s, modrm, ot, OR_TMP0, 1);\n\n            s->popl_esp_hack = 0;\n\n            gen_pop_update(s);\n\n        }\n\n        break;\n\n    case 0xc8: /* enter */\n\n        {\n\n            int level;\n\n            val = cpu_lduw_code(cpu_single_env, s->pc);\n\n            s->pc += 2;\n\n            level = cpu_ldub_code(cpu_single_env, s->pc++);\n\n            gen_enter(s, val, level);\n\n        }\n\n        break;\n\n    case 0xc9: /* leave */\n\n        /* XXX: exception not precise (ESP is updated before potential exception) */\n\n        if (CODE64(s)) {\n\n            gen_op_mov_TN_reg(OT_QUAD, 0, R_EBP);\n\n            gen_op_mov_reg_T0(OT_QUAD, R_ESP);\n\n        } else if (s->ss32) {\n\n            gen_op_mov_TN_reg(OT_LONG, 0, R_EBP);\n\n            gen_op_mov_reg_T0(OT_LONG, R_ESP);\n\n        } else {\n\n            gen_op_mov_TN_reg(OT_WORD, 0, R_EBP);\n\n            gen_op_mov_reg_T0(OT_WORD, R_ESP);\n\n        }\n\n        gen_pop_T0(s);\n\n        if (CODE64(s)) {\n\n            ot = dflag ? OT_QUAD : OT_WORD;\n\n        } else {\n\n            ot = dflag + OT_WORD;\n\n        }\n\n        gen_op_mov_reg_T0(ot, R_EBP);\n\n        gen_pop_update(s);\n\n        break;\n\n    case 0x06: /* push es */\n\n    case 0x0e: /* push cs */\n\n    case 0x16: /* push ss */\n\n    case 0x1e: /* push ds */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_op_movl_T0_seg(b >> 3);\n\n        gen_push_T0(s);\n\n        break;\n\n    case 0x1a0: /* push fs */\n\n    case 0x1a8: /* push gs */\n\n        gen_op_movl_T0_seg((b >> 3) & 7);\n\n        gen_push_T0(s);\n\n        break;\n\n    case 0x07: /* pop es */\n\n    case 0x17: /* pop ss */\n\n    case 0x1f: /* pop ds */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        reg = b >> 3;\n\n        gen_pop_T0(s);\n\n        gen_movl_seg_T0(s, reg, pc_start - s->cs_base);\n\n        gen_pop_update(s);\n\n        if (reg == R_SS) {\n\n            /* if reg == SS, inhibit interrupts/trace. */\n\n            /* If several instructions disable interrupts, only the\n\n               _first_ does it */\n\n            if (!(s->tb->flags & HF_INHIBIT_IRQ_MASK))\n\n                gen_helper_set_inhibit_irq(cpu_env);\n\n            s->tf = 0;\n\n        }\n\n        if (s->is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x1a1: /* pop fs */\n\n    case 0x1a9: /* pop gs */\n\n        gen_pop_T0(s);\n\n        gen_movl_seg_T0(s, (b >> 3) & 7, pc_start - s->cs_base);\n\n        gen_pop_update(s);\n\n        if (s->is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n\n\n        /**************************/\n\n        /* mov */\n\n    case 0x88:\n\n    case 0x89: /* mov Gv, Ev */\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag + OT_WORD;\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        /* generate a generic store */\n\n        gen_ldst_modrm(s, modrm, ot, reg, 1);\n\n        break;\n\n    case 0xc6:\n\n    case 0xc7: /* mov Ev, Iv */\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag + OT_WORD;\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod != 3) {\n\n            s->rip_offset = insn_const_size(ot);\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n        }\n\n        val = insn_get(s, ot);\n\n        gen_op_movl_T0_im(val);\n\n        if (mod != 3)\n\n            gen_op_st_T0_A0(ot + s->mem_index);\n\n        else\n\n            gen_op_mov_reg_T0(ot, (modrm & 7) | REX_B(s));\n\n        break;\n\n    case 0x8a:\n\n    case 0x8b: /* mov Ev, Gv */\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = OT_WORD + dflag;\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        gen_ldst_modrm(s, modrm, ot, OR_TMP0, 0);\n\n        gen_op_mov_reg_T0(ot, reg);\n\n        break;\n\n    case 0x8e: /* mov seg, Gv */\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        reg = (modrm >> 3) & 7;\n\n        if (reg >= 6 || reg == R_CS)\n\n            goto illegal_op;\n\n        gen_ldst_modrm(s, modrm, OT_WORD, OR_TMP0, 0);\n\n        gen_movl_seg_T0(s, reg, pc_start - s->cs_base);\n\n        if (reg == R_SS) {\n\n            /* if reg == SS, inhibit interrupts/trace */\n\n            /* If several instructions disable interrupts, only the\n\n               _first_ does it */\n\n            if (!(s->tb->flags & HF_INHIBIT_IRQ_MASK))\n\n                gen_helper_set_inhibit_irq(cpu_env);\n\n            s->tf = 0;\n\n        }\n\n        if (s->is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x8c: /* mov Gv, seg */\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        reg = (modrm >> 3) & 7;\n\n        mod = (modrm >> 6) & 3;\n\n        if (reg >= 6)\n\n            goto illegal_op;\n\n        gen_op_movl_T0_seg(reg);\n\n        if (mod == 3)\n\n            ot = OT_WORD + dflag;\n\n        else\n\n            ot = OT_WORD;\n\n        gen_ldst_modrm(s, modrm, ot, OR_TMP0, 1);\n\n        break;\n\n\n\n    case 0x1b6: /* movzbS Gv, Eb */\n\n    case 0x1b7: /* movzwS Gv, Eb */\n\n    case 0x1be: /* movsbS Gv, Eb */\n\n    case 0x1bf: /* movswS Gv, Eb */\n\n        {\n\n            int d_ot;\n\n            /* d_ot is the size of destination */\n\n            d_ot = dflag + OT_WORD;\n\n            /* ot is the size of source */\n\n            ot = (b & 1) + OT_BYTE;\n\n            modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            rm = (modrm & 7) | REX_B(s);\n\n\n\n            if (mod == 3) {\n\n                gen_op_mov_TN_reg(ot, 0, rm);\n\n                switch(ot | (b & 8)) {\n\n                case OT_BYTE:\n\n                    tcg_gen_ext8u_tl(cpu_T[0], cpu_T[0]);\n\n                    break;\n\n                case OT_BYTE | 8:\n\n                    tcg_gen_ext8s_tl(cpu_T[0], cpu_T[0]);\n\n                    break;\n\n                case OT_WORD:\n\n                    tcg_gen_ext16u_tl(cpu_T[0], cpu_T[0]);\n\n                    break;\n\n                default:\n\n                case OT_WORD | 8:\n\n                    tcg_gen_ext16s_tl(cpu_T[0], cpu_T[0]);\n\n                    break;\n\n                }\n\n                gen_op_mov_reg_T0(d_ot, reg);\n\n            } else {\n\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n                if (b & 8) {\n\n                    gen_op_lds_T0_A0(ot + s->mem_index);\n\n                } else {\n\n                    gen_op_ldu_T0_A0(ot + s->mem_index);\n\n                }\n\n                gen_op_mov_reg_T0(d_ot, reg);\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 0x8d: /* lea */\n\n        ot = dflag + OT_WORD;\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        /* we must ensure that no segment is added */\n\n        s->override = -1;\n\n        val = s->addseg;\n\n        s->addseg = 0;\n\n        gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n        s->addseg = val;\n\n        gen_op_mov_reg_A0(ot - OT_WORD, reg);\n\n        break;\n\n\n\n    case 0xa0: /* mov EAX, Ov */\n\n    case 0xa1:\n\n    case 0xa2: /* mov Ov, EAX */\n\n    case 0xa3:\n\n        {\n\n            target_ulong offset_addr;\n\n\n\n            if ((b & 1) == 0)\n\n                ot = OT_BYTE;\n\n            else\n\n                ot = dflag + OT_WORD;\n\n#ifdef TARGET_X86_64\n\n            if (s->aflag == 2) {\n\n                offset_addr = cpu_ldq_code(cpu_single_env, s->pc);\n\n                s->pc += 8;\n\n                gen_op_movq_A0_im(offset_addr);\n\n            } else\n\n#endif\n\n            {\n\n                if (s->aflag) {\n\n                    offset_addr = insn_get(s, OT_LONG);\n\n                } else {\n\n                    offset_addr = insn_get(s, OT_WORD);\n\n                }\n\n                gen_op_movl_A0_im(offset_addr);\n\n            }\n\n            gen_add_A0_ds_seg(s);\n\n            if ((b & 2) == 0) {\n\n                gen_op_ld_T0_A0(ot + s->mem_index);\n\n                gen_op_mov_reg_T0(ot, R_EAX);\n\n            } else {\n\n                gen_op_mov_TN_reg(ot, 0, R_EAX);\n\n                gen_op_st_T0_A0(ot + s->mem_index);\n\n            }\n\n        }\n\n        break;\n\n    case 0xd7: /* xlat */\n\n#ifdef TARGET_X86_64\n\n        if (s->aflag == 2) {\n\n            gen_op_movq_A0_reg(R_EBX);\n\n            gen_op_mov_TN_reg(OT_QUAD, 0, R_EAX);\n\n            tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xff);\n\n            tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_T[0]);\n\n        } else\n\n#endif\n\n        {\n\n            gen_op_movl_A0_reg(R_EBX);\n\n            gen_op_mov_TN_reg(OT_LONG, 0, R_EAX);\n\n            tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xff);\n\n            tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_T[0]);\n\n            if (s->aflag == 0)\n\n                gen_op_andl_A0_ffff();\n\n            else\n\n                tcg_gen_andi_tl(cpu_A0, cpu_A0, 0xffffffff);\n\n        }\n\n        gen_add_A0_ds_seg(s);\n\n        gen_op_ldu_T0_A0(OT_BYTE + s->mem_index);\n\n        gen_op_mov_reg_T0(OT_BYTE, R_EAX);\n\n        break;\n\n    case 0xb0 ... 0xb7: /* mov R, Ib */\n\n        val = insn_get(s, OT_BYTE);\n\n        gen_op_movl_T0_im(val);\n\n        gen_op_mov_reg_T0(OT_BYTE, (b & 7) | REX_B(s));\n\n        break;\n\n    case 0xb8 ... 0xbf: /* mov R, Iv */\n\n#ifdef TARGET_X86_64\n\n        if (dflag == 2) {\n\n            uint64_t tmp;\n\n            /* 64 bit case */\n\n            tmp = cpu_ldq_code(cpu_single_env, s->pc);\n\n            s->pc += 8;\n\n            reg = (b & 7) | REX_B(s);\n\n            gen_movtl_T0_im(tmp);\n\n            gen_op_mov_reg_T0(OT_QUAD, reg);\n\n        } else\n\n#endif\n\n        {\n\n            ot = dflag ? OT_LONG : OT_WORD;\n\n            val = insn_get(s, ot);\n\n            reg = (b & 7) | REX_B(s);\n\n            gen_op_movl_T0_im(val);\n\n            gen_op_mov_reg_T0(ot, reg);\n\n        }\n\n        break;\n\n\n\n    case 0x91 ... 0x97: /* xchg R, EAX */\n\n    do_xchg_reg_eax:\n\n        ot = dflag + OT_WORD;\n\n        reg = (b & 7) | REX_B(s);\n\n        rm = R_EAX;\n\n        goto do_xchg_reg;\n\n    case 0x86:\n\n    case 0x87: /* xchg Ev, Gv */\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag + OT_WORD;\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3) {\n\n            rm = (modrm & 7) | REX_B(s);\n\n        do_xchg_reg:\n\n            gen_op_mov_TN_reg(ot, 0, reg);\n\n            gen_op_mov_TN_reg(ot, 1, rm);\n\n            gen_op_mov_reg_T0(ot, rm);\n\n            gen_op_mov_reg_T1(ot, reg);\n\n        } else {\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            gen_op_mov_TN_reg(ot, 0, reg);\n\n            /* for xchg, lock is implicit */\n\n            if (!(prefixes & PREFIX_LOCK))\n\n                gen_helper_lock();\n\n            gen_op_ld_T1_A0(ot + s->mem_index);\n\n            gen_op_st_T0_A0(ot + s->mem_index);\n\n            if (!(prefixes & PREFIX_LOCK))\n\n                gen_helper_unlock();\n\n            gen_op_mov_reg_T1(ot, reg);\n\n        }\n\n        break;\n\n    case 0xc4: /* les Gv */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        op = R_ES;\n\n        goto do_lxx;\n\n    case 0xc5: /* lds Gv */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        op = R_DS;\n\n        goto do_lxx;\n\n    case 0x1b2: /* lss Gv */\n\n        op = R_SS;\n\n        goto do_lxx;\n\n    case 0x1b4: /* lfs Gv */\n\n        op = R_FS;\n\n        goto do_lxx;\n\n    case 0x1b5: /* lgs Gv */\n\n        op = R_GS;\n\n    do_lxx:\n\n        ot = dflag ? OT_LONG : OT_WORD;\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n        gen_op_ld_T1_A0(ot + s->mem_index);\n\n        gen_add_A0_im(s, 1 << (ot - OT_WORD + 1));\n\n        /* load the segment first to handle exceptions properly */\n\n        gen_op_ldu_T0_A0(OT_WORD + s->mem_index);\n\n        gen_movl_seg_T0(s, op, pc_start - s->cs_base);\n\n        /* then put the data */\n\n        gen_op_mov_reg_T1(ot, reg);\n\n        if (s->is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* shifts */\n\n    case 0xc0:\n\n    case 0xc1:\n\n        /* shift Ev,Ib */\n\n        shift = 2;\n\n    grp2:\n\n        {\n\n            if ((b & 1) == 0)\n\n                ot = OT_BYTE;\n\n            else\n\n                ot = dflag + OT_WORD;\n\n\n\n            modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n            mod = (modrm >> 6) & 3;\n\n            op = (modrm >> 3) & 7;\n\n\n\n            if (mod != 3) {\n\n                if (shift == 2) {\n\n                    s->rip_offset = 1;\n\n                }\n\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n                opreg = OR_TMP0;\n\n            } else {\n\n                opreg = (modrm & 7) | REX_B(s);\n\n            }\n\n\n\n            /* simpler op */\n\n            if (shift == 0) {\n\n                gen_shift(s, op, ot, opreg, OR_ECX);\n\n            } else {\n\n                if (shift == 2) {\n\n                    shift = cpu_ldub_code(cpu_single_env, s->pc++);\n\n                }\n\n                gen_shifti(s, op, ot, opreg, shift);\n\n            }\n\n        }\n\n        break;\n\n    case 0xd0:\n\n    case 0xd1:\n\n        /* shift Ev,1 */\n\n        shift = 1;\n\n        goto grp2;\n\n    case 0xd2:\n\n    case 0xd3:\n\n        /* shift Ev,cl */\n\n        shift = 0;\n\n        goto grp2;\n\n\n\n    case 0x1a4: /* shld imm */\n\n        op = 0;\n\n        shift = 1;\n\n        goto do_shiftd;\n\n    case 0x1a5: /* shld cl */\n\n        op = 0;\n\n        shift = 0;\n\n        goto do_shiftd;\n\n    case 0x1ac: /* shrd imm */\n\n        op = 1;\n\n        shift = 1;\n\n        goto do_shiftd;\n\n    case 0x1ad: /* shrd cl */\n\n        op = 1;\n\n        shift = 0;\n\n    do_shiftd:\n\n        ot = dflag + OT_WORD;\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        if (mod != 3) {\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            opreg = OR_TMP0;\n\n        } else {\n\n            opreg = rm;\n\n        }\n\n        gen_op_mov_TN_reg(ot, 1, reg);\n\n\n\n        if (shift) {\n\n            val = cpu_ldub_code(cpu_single_env, s->pc++);\n\n            tcg_gen_movi_tl(cpu_T3, val);\n\n        } else {\n\n            tcg_gen_mov_tl(cpu_T3, cpu_regs[R_ECX]);\n\n        }\n\n        gen_shiftd_rm_T1_T3(s, ot, opreg, op);\n\n        break;\n\n\n\n        /************************/\n\n        /* floats */\n\n    case 0xd8 ... 0xdf:\n\n        if (s->flags & (HF_EM_MASK | HF_TS_MASK)) {\n\n            /* if CR0.EM or CR0.TS are set, generate an FPU exception */\n\n            /* XXX: what to do if illegal op ? */\n\n            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n            break;\n\n        }\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = modrm & 7;\n\n        op = ((b & 7) << 3) | ((modrm >> 3) & 7);\n\n        if (mod != 3) {\n\n            /* memory op */\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            switch(op) {\n\n            case 0x00 ... 0x07: /* fxxxs */\n\n            case 0x10 ... 0x17: /* fixxxl */\n\n            case 0x20 ... 0x27: /* fxxxl */\n\n            case 0x30 ... 0x37: /* fixxx */\n\n                {\n\n                    int op1;\n\n                    op1 = op & 7;\n\n\n\n                    switch(op >> 4) {\n\n                    case 0:\n\n                        gen_op_ld_T0_A0(OT_LONG + s->mem_index);\n\n                        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                        gen_helper_flds_FT0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 1:\n\n                        gen_op_ld_T0_A0(OT_LONG + s->mem_index);\n\n                        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                        gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 2:\n\n                        tcg_gen_qemu_ld64(cpu_tmp1_i64, cpu_A0, \n\n                                          (s->mem_index >> 2) - 1);\n\n                        gen_helper_fldl_FT0(cpu_env, cpu_tmp1_i64);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        gen_op_lds_T0_A0(OT_WORD + s->mem_index);\n\n                        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                        gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    }\n\n\n\n                    gen_helper_fp_arith_ST0_FT0(op1);\n\n                    if (op1 == 3) {\n\n                        /* fcomp needs pop */\n\n                        gen_helper_fpop(cpu_env);\n\n                    }\n\n                }\n\n                break;\n\n            case 0x08: /* flds */\n\n            case 0x0a: /* fsts */\n\n            case 0x0b: /* fstps */\n\n            case 0x18 ... 0x1b: /* fildl, fisttpl, fistl, fistpl */\n\n            case 0x28 ... 0x2b: /* fldl, fisttpll, fstl, fstpl */\n\n            case 0x38 ... 0x3b: /* filds, fisttps, fists, fistps */\n\n                switch(op & 7) {\n\n                case 0:\n\n                    switch(op >> 4) {\n\n                    case 0:\n\n                        gen_op_ld_T0_A0(OT_LONG + s->mem_index);\n\n                        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                        gen_helper_flds_ST0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 1:\n\n                        gen_op_ld_T0_A0(OT_LONG + s->mem_index);\n\n                        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                        gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 2:\n\n                        tcg_gen_qemu_ld64(cpu_tmp1_i64, cpu_A0, \n\n                                          (s->mem_index >> 2) - 1);\n\n                        gen_helper_fldl_ST0(cpu_env, cpu_tmp1_i64);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        gen_op_lds_T0_A0(OT_WORD + s->mem_index);\n\n                        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                        gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    }\n\n                    break;\n\n                case 1:\n\n                    /* XXX: the corresponding CPUID bit must be tested ! */\n\n                    switch(op >> 4) {\n\n                    case 1:\n\n                        gen_helper_fisttl_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_extu_i32_tl(cpu_T[0], cpu_tmp2_i32);\n\n                        gen_op_st_T0_A0(OT_LONG + s->mem_index);\n\n                        break;\n\n                    case 2:\n\n                        gen_helper_fisttll_ST0(cpu_tmp1_i64, cpu_env);\n\n                        tcg_gen_qemu_st64(cpu_tmp1_i64, cpu_A0, \n\n                                          (s->mem_index >> 2) - 1);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        gen_helper_fistt_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_extu_i32_tl(cpu_T[0], cpu_tmp2_i32);\n\n                        gen_op_st_T0_A0(OT_WORD + s->mem_index);\n\n                        break;\n\n                    }\n\n                    gen_helper_fpop(cpu_env);\n\n                    break;\n\n                default:\n\n                    switch(op >> 4) {\n\n                    case 0:\n\n                        gen_helper_fsts_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_extu_i32_tl(cpu_T[0], cpu_tmp2_i32);\n\n                        gen_op_st_T0_A0(OT_LONG + s->mem_index);\n\n                        break;\n\n                    case 1:\n\n                        gen_helper_fistl_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_extu_i32_tl(cpu_T[0], cpu_tmp2_i32);\n\n                        gen_op_st_T0_A0(OT_LONG + s->mem_index);\n\n                        break;\n\n                    case 2:\n\n                        gen_helper_fstl_ST0(cpu_tmp1_i64, cpu_env);\n\n                        tcg_gen_qemu_st64(cpu_tmp1_i64, cpu_A0, \n\n                                          (s->mem_index >> 2) - 1);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        gen_helper_fist_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_extu_i32_tl(cpu_T[0], cpu_tmp2_i32);\n\n                        gen_op_st_T0_A0(OT_WORD + s->mem_index);\n\n                        break;\n\n                    }\n\n                    if ((op & 7) == 3)\n\n                        gen_helper_fpop(cpu_env);\n\n                    break;\n\n                }\n\n                break;\n\n            case 0x0c: /* fldenv mem */\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_fldenv(cpu_env, cpu_A0, tcg_const_i32(s->dflag));\n\n                break;\n\n            case 0x0d: /* fldcw mem */\n\n                gen_op_ld_T0_A0(OT_WORD + s->mem_index);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                gen_helper_fldcw(cpu_env, cpu_tmp2_i32);\n\n                break;\n\n            case 0x0e: /* fnstenv mem */\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_fstenv(cpu_env, cpu_A0, tcg_const_i32(s->dflag));\n\n                break;\n\n            case 0x0f: /* fnstcw mem */\n\n                gen_helper_fnstcw(cpu_tmp2_i32, cpu_env);\n\n                tcg_gen_extu_i32_tl(cpu_T[0], cpu_tmp2_i32);\n\n                gen_op_st_T0_A0(OT_WORD + s->mem_index);\n\n                break;\n\n            case 0x1d: /* fldt mem */\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_fldt_ST0(cpu_env, cpu_A0);\n\n                break;\n\n            case 0x1f: /* fstpt mem */\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_fstt_ST0(cpu_env, cpu_A0);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x2c: /* frstor mem */\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_frstor(cpu_env, cpu_A0, tcg_const_i32(s->dflag));\n\n                break;\n\n            case 0x2e: /* fnsave mem */\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_fsave(cpu_env, cpu_A0, tcg_const_i32(s->dflag));\n\n                break;\n\n            case 0x2f: /* fnstsw mem */\n\n                gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);\n\n                tcg_gen_extu_i32_tl(cpu_T[0], cpu_tmp2_i32);\n\n                gen_op_st_T0_A0(OT_WORD + s->mem_index);\n\n                break;\n\n            case 0x3c: /* fbld */\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_fbld_ST0(cpu_env, cpu_A0);\n\n                break;\n\n            case 0x3e: /* fbstp */\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                gen_helper_fbst_ST0(cpu_env, cpu_A0);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x3d: /* fildll */\n\n                tcg_gen_qemu_ld64(cpu_tmp1_i64, cpu_A0, \n\n                                  (s->mem_index >> 2) - 1);\n\n                gen_helper_fildll_ST0(cpu_env, cpu_tmp1_i64);\n\n                break;\n\n            case 0x3f: /* fistpll */\n\n                gen_helper_fistll_ST0(cpu_tmp1_i64, cpu_env);\n\n                tcg_gen_qemu_st64(cpu_tmp1_i64, cpu_A0, \n\n                                  (s->mem_index >> 2) - 1);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            default:\n\n                goto illegal_op;\n\n            }\n\n        } else {\n\n            /* register float ops */\n\n            opreg = rm;\n\n\n\n            switch(op) {\n\n            case 0x08: /* fld sti */\n\n                gen_helper_fpush(cpu_env);\n\n                gen_helper_fmov_ST0_STN(cpu_env,\n\n                                        tcg_const_i32((opreg + 1) & 7));\n\n                break;\n\n            case 0x09: /* fxchg sti */\n\n            case 0x29: /* fxchg4 sti, undocumented op */\n\n            case 0x39: /* fxchg7 sti, undocumented op */\n\n                gen_helper_fxchg_ST0_STN(cpu_env, tcg_const_i32(opreg));\n\n                break;\n\n            case 0x0a: /* grp d9/2 */\n\n                switch(rm) {\n\n                case 0: /* fnop */\n\n                    /* check exceptions (FreeBSD FPU probe) */\n\n                    if (s->cc_op != CC_OP_DYNAMIC)\n\n                        gen_op_set_cc_op(s->cc_op);\n\n                    gen_jmp_im(pc_start - s->cs_base);\n\n                    gen_helper_fwait(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto illegal_op;\n\n                }\n\n                break;\n\n            case 0x0c: /* grp d9/4 */\n\n                switch(rm) {\n\n                case 0: /* fchs */\n\n                    gen_helper_fchs_ST0(cpu_env);\n\n                    break;\n\n                case 1: /* fabs */\n\n                    gen_helper_fabs_ST0(cpu_env);\n\n                    break;\n\n                case 4: /* ftst */\n\n                    gen_helper_fldz_FT0(cpu_env);\n\n                    gen_helper_fcom_ST0_FT0(cpu_env);\n\n                    break;\n\n                case 5: /* fxam */\n\n                    gen_helper_fxam_ST0(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto illegal_op;\n\n                }\n\n                break;\n\n            case 0x0d: /* grp d9/5 */\n\n                {\n\n                    switch(rm) {\n\n                    case 0:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fld1_ST0(cpu_env);\n\n                        break;\n\n                    case 1:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldl2t_ST0(cpu_env);\n\n                        break;\n\n                    case 2:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldl2e_ST0(cpu_env);\n\n                        break;\n\n                    case 3:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldpi_ST0(cpu_env);\n\n                        break;\n\n                    case 4:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldlg2_ST0(cpu_env);\n\n                        break;\n\n                    case 5:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldln2_ST0(cpu_env);\n\n                        break;\n\n                    case 6:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldz_ST0(cpu_env);\n\n                        break;\n\n                    default:\n\n                        goto illegal_op;\n\n                    }\n\n                }\n\n                break;\n\n            case 0x0e: /* grp d9/6 */\n\n                switch(rm) {\n\n                case 0: /* f2xm1 */\n\n                    gen_helper_f2xm1(cpu_env);\n\n                    break;\n\n                case 1: /* fyl2x */\n\n                    gen_helper_fyl2x(cpu_env);\n\n                    break;\n\n                case 2: /* fptan */\n\n                    gen_helper_fptan(cpu_env);\n\n                    break;\n\n                case 3: /* fpatan */\n\n                    gen_helper_fpatan(cpu_env);\n\n                    break;\n\n                case 4: /* fxtract */\n\n                    gen_helper_fxtract(cpu_env);\n\n                    break;\n\n                case 5: /* fprem1 */\n\n                    gen_helper_fprem1(cpu_env);\n\n                    break;\n\n                case 6: /* fdecstp */\n\n                    gen_helper_fdecstp(cpu_env);\n\n                    break;\n\n                default:\n\n                case 7: /* fincstp */\n\n                    gen_helper_fincstp(cpu_env);\n\n                    break;\n\n                }\n\n                break;\n\n            case 0x0f: /* grp d9/7 */\n\n                switch(rm) {\n\n                case 0: /* fprem */\n\n                    gen_helper_fprem(cpu_env);\n\n                    break;\n\n                case 1: /* fyl2xp1 */\n\n                    gen_helper_fyl2xp1(cpu_env);\n\n                    break;\n\n                case 2: /* fsqrt */\n\n                    gen_helper_fsqrt(cpu_env);\n\n                    break;\n\n                case 3: /* fsincos */\n\n                    gen_helper_fsincos(cpu_env);\n\n                    break;\n\n                case 5: /* fscale */\n\n                    gen_helper_fscale(cpu_env);\n\n                    break;\n\n                case 4: /* frndint */\n\n                    gen_helper_frndint(cpu_env);\n\n                    break;\n\n                case 6: /* fsin */\n\n                    gen_helper_fsin(cpu_env);\n\n                    break;\n\n                default:\n\n                case 7: /* fcos */\n\n                    gen_helper_fcos(cpu_env);\n\n                    break;\n\n                }\n\n                break;\n\n            case 0x00: case 0x01: case 0x04 ... 0x07: /* fxxx st, sti */\n\n            case 0x20: case 0x21: case 0x24 ... 0x27: /* fxxx sti, st */\n\n            case 0x30: case 0x31: case 0x34 ... 0x37: /* fxxxp sti, st */\n\n                {\n\n                    int op1;\n\n\n\n                    op1 = op & 7;\n\n                    if (op >= 0x20) {\n\n                        gen_helper_fp_arith_STN_ST0(op1, opreg);\n\n                        if (op >= 0x30)\n\n                            gen_helper_fpop(cpu_env);\n\n                    } else {\n\n                        gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                        gen_helper_fp_arith_ST0_FT0(op1);\n\n                    }\n\n                }\n\n                break;\n\n            case 0x02: /* fcom */\n\n            case 0x22: /* fcom2, undocumented op */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcom_ST0_FT0(cpu_env);\n\n                break;\n\n            case 0x03: /* fcomp */\n\n            case 0x23: /* fcomp3, undocumented op */\n\n            case 0x32: /* fcomp5, undocumented op */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcom_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x15: /* da/5 */\n\n                switch(rm) {\n\n                case 1: /* fucompp */\n\n                    gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));\n\n                    gen_helper_fucom_ST0_FT0(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto illegal_op;\n\n                }\n\n                break;\n\n            case 0x1c:\n\n                switch(rm) {\n\n                case 0: /* feni (287 only, just do nop here) */\n\n                    break;\n\n                case 1: /* fdisi (287 only, just do nop here) */\n\n                    break;\n\n                case 2: /* fclex */\n\n                    gen_helper_fclex(cpu_env);\n\n                    break;\n\n                case 3: /* fninit */\n\n                    gen_helper_fninit(cpu_env);\n\n                    break;\n\n                case 4: /* fsetpm (287 only, just do nop here) */\n\n                    break;\n\n                default:\n\n                    goto illegal_op;\n\n                }\n\n                break;\n\n            case 0x1d: /* fucomi */\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucomi_ST0_FT0(cpu_env);\n\n                s->cc_op = CC_OP_EFLAGS;\n\n                break;\n\n            case 0x1e: /* fcomi */\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcomi_ST0_FT0(cpu_env);\n\n                s->cc_op = CC_OP_EFLAGS;\n\n                break;\n\n            case 0x28: /* ffree sti */\n\n                gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));\n\n                break;\n\n            case 0x2a: /* fst sti */\n\n                gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));\n\n                break;\n\n            case 0x2b: /* fstp sti */\n\n            case 0x0b: /* fstp1 sti, undocumented op */\n\n            case 0x3a: /* fstp8 sti, undocumented op */\n\n            case 0x3b: /* fstp9 sti, undocumented op */\n\n                gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x2c: /* fucom st(i) */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucom_ST0_FT0(cpu_env);\n\n                break;\n\n            case 0x2d: /* fucomp st(i) */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucom_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x33: /* de/3 */\n\n                switch(rm) {\n\n                case 1: /* fcompp */\n\n                    gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));\n\n                    gen_helper_fcom_ST0_FT0(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto illegal_op;\n\n                }\n\n                break;\n\n            case 0x38: /* ffreep sti, undocumented op */\n\n                gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x3c: /* df/4 */\n\n                switch(rm) {\n\n                case 0:\n\n                    gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);\n\n                    tcg_gen_extu_i32_tl(cpu_T[0], cpu_tmp2_i32);\n\n                    gen_op_mov_reg_T0(OT_WORD, R_EAX);\n\n                    break;\n\n                default:\n\n                    goto illegal_op;\n\n                }\n\n                break;\n\n            case 0x3d: /* fucomip */\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucomi_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                s->cc_op = CC_OP_EFLAGS;\n\n                break;\n\n            case 0x3e: /* fcomip */\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcomi_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                s->cc_op = CC_OP_EFLAGS;\n\n                break;\n\n            case 0x10 ... 0x13: /* fcmovxx */\n\n            case 0x18 ... 0x1b:\n\n                {\n\n                    int op1, l1;\n\n                    static const uint8_t fcmov_cc[8] = {\n\n                        (JCC_B << 1),\n\n                        (JCC_Z << 1),\n\n                        (JCC_BE << 1),\n\n                        (JCC_P << 1),\n\n                    };\n\n                    op1 = fcmov_cc[op & 3] | (((op >> 3) & 1) ^ 1);\n\n                    l1 = gen_new_label();\n\n                    gen_jcc1(s, s->cc_op, op1, l1);\n\n                    gen_helper_fmov_ST0_STN(cpu_env, tcg_const_i32(opreg));\n\n                    gen_set_label(l1);\n\n                }\n\n                break;\n\n            default:\n\n                goto illegal_op;\n\n            }\n\n        }\n\n        break;\n\n        /************************/\n\n        /* string ops */\n\n\n\n    case 0xa4: /* movsS */\n\n    case 0xa5:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag + OT_WORD;\n\n\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_movs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_movs(s, ot);\n\n        }\n\n        break;\n\n\n\n    case 0xaa: /* stosS */\n\n    case 0xab:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag + OT_WORD;\n\n\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_stos(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_stos(s, ot);\n\n        }\n\n        break;\n\n    case 0xac: /* lodsS */\n\n    case 0xad:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag + OT_WORD;\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_lods(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_lods(s, ot);\n\n        }\n\n        break;\n\n    case 0xae: /* scasS */\n\n    case 0xaf:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag + OT_WORD;\n\n        if (prefixes & PREFIX_REPNZ) {\n\n            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);\n\n        } else if (prefixes & PREFIX_REPZ) {\n\n            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);\n\n        } else {\n\n            gen_scas(s, ot);\n\n            s->cc_op = CC_OP_SUBB + ot;\n\n        }\n\n        break;\n\n\n\n    case 0xa6: /* cmpsS */\n\n    case 0xa7:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag + OT_WORD;\n\n        if (prefixes & PREFIX_REPNZ) {\n\n            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);\n\n        } else if (prefixes & PREFIX_REPZ) {\n\n            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);\n\n        } else {\n\n            gen_cmps(s, ot);\n\n            s->cc_op = CC_OP_SUBB + ot;\n\n        }\n\n        break;\n\n    case 0x6c: /* insS */\n\n    case 0x6d:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag ? OT_LONG : OT_WORD;\n\n        gen_op_mov_TN_reg(OT_WORD, 0, R_EDX);\n\n        gen_op_andl_T0_ffff();\n\n        gen_check_io(s, ot, pc_start - s->cs_base, \n\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes) | 4);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_ins(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_ins(s, ot);\n\n            if (use_icount) {\n\n                gen_jmp(s, s->pc - s->cs_base);\n\n            }\n\n        }\n\n        break;\n\n    case 0x6e: /* outsS */\n\n    case 0x6f:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag ? OT_LONG : OT_WORD;\n\n        gen_op_mov_TN_reg(OT_WORD, 0, R_EDX);\n\n        gen_op_andl_T0_ffff();\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     svm_is_rep(prefixes) | 4);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_outs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_outs(s, ot);\n\n            if (use_icount) {\n\n                gen_jmp(s, s->pc - s->cs_base);\n\n            }\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* port I/O */\n\n\n\n    case 0xe4:\n\n    case 0xe5:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag ? OT_LONG : OT_WORD;\n\n        val = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        gen_op_movl_T0_im(val);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));\n\n        if (use_icount)\n\n            gen_io_start();\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n        gen_helper_in_func(ot, cpu_T[1], cpu_tmp2_i32);\n\n        gen_op_mov_reg_T1(ot, R_EAX);\n\n        if (use_icount) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xe6:\n\n    case 0xe7:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag ? OT_LONG : OT_WORD;\n\n        val = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        gen_op_movl_T0_im(val);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     svm_is_rep(prefixes));\n\n        gen_op_mov_TN_reg(ot, 1, R_EAX);\n\n\n\n        if (use_icount)\n\n            gen_io_start();\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[1]);\n\n        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n\n        if (use_icount) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xec:\n\n    case 0xed:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag ? OT_LONG : OT_WORD;\n\n        gen_op_mov_TN_reg(OT_WORD, 0, R_EDX);\n\n        gen_op_andl_T0_ffff();\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));\n\n        if (use_icount)\n\n            gen_io_start();\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n        gen_helper_in_func(ot, cpu_T[1], cpu_tmp2_i32);\n\n        gen_op_mov_reg_T1(ot, R_EAX);\n\n        if (use_icount) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xee:\n\n    case 0xef:\n\n        if ((b & 1) == 0)\n\n            ot = OT_BYTE;\n\n        else\n\n            ot = dflag ? OT_LONG : OT_WORD;\n\n        gen_op_mov_TN_reg(OT_WORD, 0, R_EDX);\n\n        gen_op_andl_T0_ffff();\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     svm_is_rep(prefixes));\n\n        gen_op_mov_TN_reg(ot, 1, R_EAX);\n\n\n\n        if (use_icount)\n\n            gen_io_start();\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[1]);\n\n        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n\n        if (use_icount) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* control */\n\n    case 0xc2: /* ret im */\n\n        val = cpu_ldsw_code(cpu_single_env, s->pc);\n\n        s->pc += 2;\n\n        gen_pop_T0(s);\n\n        if (CODE64(s) && s->dflag)\n\n            s->dflag = 2;\n\n        gen_stack_update(s, val + (2 << s->dflag));\n\n        if (s->dflag == 0)\n\n            gen_op_andl_T0_ffff();\n\n        gen_op_jmp_T0();\n\n        gen_eob(s);\n\n        break;\n\n    case 0xc3: /* ret */\n\n        gen_pop_T0(s);\n\n        gen_pop_update(s);\n\n        if (s->dflag == 0)\n\n            gen_op_andl_T0_ffff();\n\n        gen_op_jmp_T0();\n\n        gen_eob(s);\n\n        break;\n\n    case 0xca: /* lret im */\n\n        val = cpu_ldsw_code(cpu_single_env, s->pc);\n\n        s->pc += 2;\n\n    do_lret:\n\n        if (s->pe && !s->vm86) {\n\n            if (s->cc_op != CC_OP_DYNAMIC)\n\n                gen_op_set_cc_op(s->cc_op);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_lret_protected(cpu_env, tcg_const_i32(s->dflag),\n\n                                      tcg_const_i32(val));\n\n        } else {\n\n            gen_stack_A0(s);\n\n            /* pop offset */\n\n            gen_op_ld_T0_A0(1 + s->dflag + s->mem_index);\n\n            if (s->dflag == 0)\n\n                gen_op_andl_T0_ffff();\n\n            /* NOTE: keeping EIP updated is not a problem in case of\n\n               exception */\n\n            gen_op_jmp_T0();\n\n            /* pop selector */\n\n            gen_op_addl_A0_im(2 << s->dflag);\n\n            gen_op_ld_T0_A0(1 + s->dflag + s->mem_index);\n\n            gen_op_movl_seg_T0_vm(R_CS);\n\n            /* add stack offset */\n\n            gen_stack_update(s, val + (4 << s->dflag));\n\n        }\n\n        gen_eob(s);\n\n        break;\n\n    case 0xcb: /* lret */\n\n        val = 0;\n\n        goto do_lret;\n\n    case 0xcf: /* iret */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_IRET);\n\n        if (!s->pe) {\n\n            /* real mode */\n\n            gen_helper_iret_real(cpu_env, tcg_const_i32(s->dflag));\n\n            s->cc_op = CC_OP_EFLAGS;\n\n        } else if (s->vm86) {\n\n            if (s->iopl != 3) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_helper_iret_real(cpu_env, tcg_const_i32(s->dflag));\n\n                s->cc_op = CC_OP_EFLAGS;\n\n            }\n\n        } else {\n\n            if (s->cc_op != CC_OP_DYNAMIC)\n\n                gen_op_set_cc_op(s->cc_op);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_iret_protected(cpu_env, tcg_const_i32(s->dflag),\n\n                                      tcg_const_i32(s->pc - s->cs_base));\n\n            s->cc_op = CC_OP_EFLAGS;\n\n        }\n\n        gen_eob(s);\n\n        break;\n\n    case 0xe8: /* call im */\n\n        {\n\n            if (dflag)\n\n                tval = (int32_t)insn_get(s, OT_LONG);\n\n            else\n\n                tval = (int16_t)insn_get(s, OT_WORD);\n\n            next_eip = s->pc - s->cs_base;\n\n            tval += next_eip;\n\n            if (s->dflag == 0)\n\n                tval &= 0xffff;\n\n            else if(!CODE64(s))\n\n                tval &= 0xffffffff;\n\n            gen_movtl_T0_im(next_eip);\n\n            gen_push_T0(s);\n\n            gen_jmp(s, tval);\n\n        }\n\n        break;\n\n    case 0x9a: /* lcall im */\n\n        {\n\n            unsigned int selector, offset;\n\n\n\n            if (CODE64(s))\n\n                goto illegal_op;\n\n            ot = dflag ? OT_LONG : OT_WORD;\n\n            offset = insn_get(s, ot);\n\n            selector = insn_get(s, OT_WORD);\n\n\n\n            gen_op_movl_T0_im(selector);\n\n            gen_op_movl_T1_imu(offset);\n\n        }\n\n        goto do_lcall;\n\n    case 0xe9: /* jmp im */\n\n        if (dflag)\n\n            tval = (int32_t)insn_get(s, OT_LONG);\n\n        else\n\n            tval = (int16_t)insn_get(s, OT_WORD);\n\n        tval += s->pc - s->cs_base;\n\n        if (s->dflag == 0)\n\n            tval &= 0xffff;\n\n        else if(!CODE64(s))\n\n            tval &= 0xffffffff;\n\n        gen_jmp(s, tval);\n\n        break;\n\n    case 0xea: /* ljmp im */\n\n        {\n\n            unsigned int selector, offset;\n\n\n\n            if (CODE64(s))\n\n                goto illegal_op;\n\n            ot = dflag ? OT_LONG : OT_WORD;\n\n            offset = insn_get(s, ot);\n\n            selector = insn_get(s, OT_WORD);\n\n\n\n            gen_op_movl_T0_im(selector);\n\n            gen_op_movl_T1_imu(offset);\n\n        }\n\n        goto do_ljmp;\n\n    case 0xeb: /* jmp Jb */\n\n        tval = (int8_t)insn_get(s, OT_BYTE);\n\n        tval += s->pc - s->cs_base;\n\n        if (s->dflag == 0)\n\n            tval &= 0xffff;\n\n        gen_jmp(s, tval);\n\n        break;\n\n    case 0x70 ... 0x7f: /* jcc Jb */\n\n        tval = (int8_t)insn_get(s, OT_BYTE);\n\n        goto do_jcc;\n\n    case 0x180 ... 0x18f: /* jcc Jv */\n\n        if (dflag) {\n\n            tval = (int32_t)insn_get(s, OT_LONG);\n\n        } else {\n\n            tval = (int16_t)insn_get(s, OT_WORD);\n\n        }\n\n    do_jcc:\n\n        next_eip = s->pc - s->cs_base;\n\n        tval += next_eip;\n\n        if (s->dflag == 0)\n\n            tval &= 0xffff;\n\n        gen_jcc(s, b, tval, next_eip);\n\n        break;\n\n\n\n    case 0x190 ... 0x19f: /* setcc Gv */\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        gen_setcc(s, b);\n\n        gen_ldst_modrm(s, modrm, OT_BYTE, OR_TMP0, 1);\n\n        break;\n\n    case 0x140 ... 0x14f: /* cmov Gv, Ev */\n\n        {\n\n            int l1;\n\n            TCGv t0;\n\n\n\n            ot = dflag + OT_WORD;\n\n            modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            t0 = tcg_temp_local_new();\n\n            if (mod != 3) {\n\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n                gen_op_ld_v(ot + s->mem_index, t0, cpu_A0);\n\n            } else {\n\n                rm = (modrm & 7) | REX_B(s);\n\n                gen_op_mov_v_reg(ot, t0, rm);\n\n            }\n\n#ifdef TARGET_X86_64\n\n            if (ot == OT_LONG) {\n\n                /* XXX: specific Intel behaviour ? */\n\n                l1 = gen_new_label();\n\n                gen_jcc1(s, s->cc_op, b ^ 1, l1);\n\n                tcg_gen_mov_tl(cpu_regs[reg], t0);\n\n                gen_set_label(l1);\n\n                tcg_gen_ext32u_tl(cpu_regs[reg], cpu_regs[reg]);\n\n            } else\n\n#endif\n\n            {\n\n                l1 = gen_new_label();\n\n                gen_jcc1(s, s->cc_op, b ^ 1, l1);\n\n                gen_op_mov_reg_v(ot, reg, t0);\n\n                gen_set_label(l1);\n\n            }\n\n            tcg_temp_free(t0);\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* flags */\n\n    case 0x9c: /* pushf */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_PUSHF);\n\n        if (s->vm86 && s->iopl != 3) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            if (s->cc_op != CC_OP_DYNAMIC)\n\n                gen_op_set_cc_op(s->cc_op);\n\n            gen_helper_read_eflags(cpu_T[0], cpu_env);\n\n            gen_push_T0(s);\n\n        }\n\n        break;\n\n    case 0x9d: /* popf */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_POPF);\n\n        if (s->vm86 && s->iopl != 3) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_pop_T0(s);\n\n            if (s->cpl == 0) {\n\n                if (s->dflag) {\n\n                    gen_helper_write_eflags(cpu_env, cpu_T[0],\n\n                                            tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                           ID_MASK | NT_MASK |\n\n                                                           IF_MASK |\n\n                                                           IOPL_MASK)));\n\n                } else {\n\n                    gen_helper_write_eflags(cpu_env, cpu_T[0],\n\n                                            tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                           ID_MASK | NT_MASK |\n\n                                                           IF_MASK | IOPL_MASK)\n\n                                                          & 0xffff));\n\n                }\n\n            } else {\n\n                if (s->cpl <= s->iopl) {\n\n                    if (s->dflag) {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T[0],\n\n                                                tcg_const_i32((TF_MASK |\n\n                                                               AC_MASK |\n\n                                                               ID_MASK |\n\n                                                               NT_MASK |\n\n                                                               IF_MASK)));\n\n                    } else {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T[0],\n\n                                                tcg_const_i32((TF_MASK |\n\n                                                               AC_MASK |\n\n                                                               ID_MASK |\n\n                                                               NT_MASK |\n\n                                                               IF_MASK)\n\n                                                              & 0xffff));\n\n                    }\n\n                } else {\n\n                    if (s->dflag) {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T[0],\n\n                                           tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                          ID_MASK | NT_MASK)));\n\n                    } else {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T[0],\n\n                                           tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                          ID_MASK | NT_MASK)\n\n                                                         & 0xffff));\n\n                    }\n\n                }\n\n            }\n\n            gen_pop_update(s);\n\n            s->cc_op = CC_OP_EFLAGS;\n\n            /* abort translation because TF flag may change */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x9e: /* sahf */\n\n        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))\n\n            goto illegal_op;\n\n        gen_op_mov_TN_reg(OT_BYTE, 0, R_AH);\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_compute_eflags(cpu_cc_src);\n\n        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, CC_O);\n\n        tcg_gen_andi_tl(cpu_T[0], cpu_T[0], CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n        tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, cpu_T[0]);\n\n        s->cc_op = CC_OP_EFLAGS;\n\n        break;\n\n    case 0x9f: /* lahf */\n\n        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))\n\n            goto illegal_op;\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_compute_eflags(cpu_T[0]);\n\n        /* Note: gen_compute_eflags() only gives the condition codes */\n\n        tcg_gen_ori_tl(cpu_T[0], cpu_T[0], 0x02);\n\n        gen_op_mov_reg_T0(OT_BYTE, R_AH);\n\n        break;\n\n    case 0xf5: /* cmc */\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_compute_eflags(cpu_cc_src);\n\n        tcg_gen_xori_tl(cpu_cc_src, cpu_cc_src, CC_C);\n\n        s->cc_op = CC_OP_EFLAGS;\n\n        break;\n\n    case 0xf8: /* clc */\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_compute_eflags(cpu_cc_src);\n\n        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_C);\n\n        s->cc_op = CC_OP_EFLAGS;\n\n        break;\n\n    case 0xf9: /* stc */\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_compute_eflags(cpu_cc_src);\n\n        tcg_gen_ori_tl(cpu_cc_src, cpu_cc_src, CC_C);\n\n        s->cc_op = CC_OP_EFLAGS;\n\n        break;\n\n    case 0xfc: /* cld */\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, 1);\n\n        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));\n\n        break;\n\n    case 0xfd: /* std */\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, -1);\n\n        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));\n\n        break;\n\n\n\n        /************************/\n\n        /* bit operations */\n\n    case 0x1ba: /* bt/bts/btr/btc Gv, im */\n\n        ot = dflag + OT_WORD;\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        op = (modrm >> 3) & 7;\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        if (mod != 3) {\n\n            s->rip_offset = 1;\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            gen_op_ld_T0_A0(ot + s->mem_index);\n\n        } else {\n\n            gen_op_mov_TN_reg(ot, 0, rm);\n\n        }\n\n        /* load shift */\n\n        val = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        gen_op_movl_T1_im(val);\n\n        if (op < 4)\n\n            goto illegal_op;\n\n        op -= 4;\n\n        goto bt_op;\n\n    case 0x1a3: /* bt Gv, Ev */\n\n        op = 0;\n\n        goto do_btx;\n\n    case 0x1ab: /* bts */\n\n        op = 1;\n\n        goto do_btx;\n\n    case 0x1b3: /* btr */\n\n        op = 2;\n\n        goto do_btx;\n\n    case 0x1bb: /* btc */\n\n        op = 3;\n\n    do_btx:\n\n        ot = dflag + OT_WORD;\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        gen_op_mov_TN_reg(OT_LONG, 1, reg);\n\n        if (mod != 3) {\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            /* specific case: we need to add a displacement */\n\n            gen_exts(ot, cpu_T[1]);\n\n            tcg_gen_sari_tl(cpu_tmp0, cpu_T[1], 3 + ot);\n\n            tcg_gen_shli_tl(cpu_tmp0, cpu_tmp0, ot);\n\n            tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_tmp0);\n\n            gen_op_ld_T0_A0(ot + s->mem_index);\n\n        } else {\n\n            gen_op_mov_TN_reg(ot, 0, rm);\n\n        }\n\n    bt_op:\n\n        tcg_gen_andi_tl(cpu_T[1], cpu_T[1], (1 << (3 + ot)) - 1);\n\n        switch(op) {\n\n        case 0:\n\n            tcg_gen_shr_tl(cpu_cc_src, cpu_T[0], cpu_T[1]);\n\n            tcg_gen_movi_tl(cpu_cc_dst, 0);\n\n            break;\n\n        case 1:\n\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T[0], cpu_T[1]);\n\n            tcg_gen_movi_tl(cpu_tmp0, 1);\n\n            tcg_gen_shl_tl(cpu_tmp0, cpu_tmp0, cpu_T[1]);\n\n            tcg_gen_or_tl(cpu_T[0], cpu_T[0], cpu_tmp0);\n\n            break;\n\n        case 2:\n\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T[0], cpu_T[1]);\n\n            tcg_gen_movi_tl(cpu_tmp0, 1);\n\n            tcg_gen_shl_tl(cpu_tmp0, cpu_tmp0, cpu_T[1]);\n\n            tcg_gen_not_tl(cpu_tmp0, cpu_tmp0);\n\n            tcg_gen_and_tl(cpu_T[0], cpu_T[0], cpu_tmp0);\n\n            break;\n\n        default:\n\n        case 3:\n\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T[0], cpu_T[1]);\n\n            tcg_gen_movi_tl(cpu_tmp0, 1);\n\n            tcg_gen_shl_tl(cpu_tmp0, cpu_tmp0, cpu_T[1]);\n\n            tcg_gen_xor_tl(cpu_T[0], cpu_T[0], cpu_tmp0);\n\n            break;\n\n        }\n\n        s->cc_op = CC_OP_SARB + ot;\n\n        if (op != 0) {\n\n            if (mod != 3)\n\n                gen_op_st_T0_A0(ot + s->mem_index);\n\n            else\n\n                gen_op_mov_reg_T0(ot, rm);\n\n            tcg_gen_mov_tl(cpu_cc_src, cpu_tmp4);\n\n            tcg_gen_movi_tl(cpu_cc_dst, 0);\n\n        }\n\n        break;\n\n    case 0x1bc: /* bsf */\n\n    case 0x1bd: /* bsr */\n\n        {\n\n            int label1;\n\n            TCGv t0;\n\n\n\n            ot = dflag + OT_WORD;\n\n            modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            gen_ldst_modrm(s,modrm, ot, OR_TMP0, 0);\n\n            gen_extu(ot, cpu_T[0]);\n\n            t0 = tcg_temp_local_new();\n\n            tcg_gen_mov_tl(t0, cpu_T[0]);\n\n            if ((b & 1) && (prefixes & PREFIX_REPZ) &&\n\n                (s->cpuid_ext3_features & CPUID_EXT3_ABM)) {\n\n                switch(ot) {\n\n                case OT_WORD: gen_helper_lzcnt(cpu_T[0], t0,\n\n                    tcg_const_i32(16)); break;\n\n                case OT_LONG: gen_helper_lzcnt(cpu_T[0], t0,\n\n                    tcg_const_i32(32)); break;\n\n                case OT_QUAD: gen_helper_lzcnt(cpu_T[0], t0,\n\n                    tcg_const_i32(64)); break;\n\n                }\n\n                gen_op_mov_reg_T0(ot, reg);\n\n            } else {\n\n                label1 = gen_new_label();\n\n                tcg_gen_movi_tl(cpu_cc_dst, 0);\n\n                tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, label1);\n\n                if (b & 1) {\n\n                    gen_helper_bsr(cpu_T[0], t0);\n\n                } else {\n\n                    gen_helper_bsf(cpu_T[0], t0);\n\n                }\n\n                gen_op_mov_reg_T0(ot, reg);\n\n                tcg_gen_movi_tl(cpu_cc_dst, 1);\n\n                gen_set_label(label1);\n\n                tcg_gen_discard_tl(cpu_cc_src);\n\n                s->cc_op = CC_OP_LOGICB + ot;\n\n            }\n\n            tcg_temp_free(t0);\n\n        }\n\n        break;\n\n        /************************/\n\n        /* bcd */\n\n    case 0x27: /* daa */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_helper_daa(cpu_env);\n\n        s->cc_op = CC_OP_EFLAGS;\n\n        break;\n\n    case 0x2f: /* das */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_helper_das(cpu_env);\n\n        s->cc_op = CC_OP_EFLAGS;\n\n        break;\n\n    case 0x37: /* aaa */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_helper_aaa(cpu_env);\n\n        s->cc_op = CC_OP_EFLAGS;\n\n        break;\n\n    case 0x3f: /* aas */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_helper_aas(cpu_env);\n\n        s->cc_op = CC_OP_EFLAGS;\n\n        break;\n\n    case 0xd4: /* aam */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        val = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        if (val == 0) {\n\n            gen_exception(s, EXCP00_DIVZ, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_aam(cpu_env, tcg_const_i32(val));\n\n            s->cc_op = CC_OP_LOGICB;\n\n        }\n\n        break;\n\n    case 0xd5: /* aad */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        val = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        gen_helper_aad(cpu_env, tcg_const_i32(val));\n\n        s->cc_op = CC_OP_LOGICB;\n\n        break;\n\n        /************************/\n\n        /* misc */\n\n    case 0x90: /* nop */\n\n        /* XXX: correct lock test for all insn */\n\n        if (prefixes & PREFIX_LOCK) {\n\n            goto illegal_op;\n\n        }\n\n        /* If REX_B is set, then this is xchg eax, r8d, not a nop.  */\n\n        if (REX_B(s)) {\n\n            goto do_xchg_reg_eax;\n\n        }\n\n        if (prefixes & PREFIX_REPZ) {\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_PAUSE);\n\n        }\n\n        break;\n\n    case 0x9b: /* fwait */\n\n        if ((s->flags & (HF_MP_MASK | HF_TS_MASK)) ==\n\n            (HF_MP_MASK | HF_TS_MASK)) {\n\n            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n        } else {\n\n            if (s->cc_op != CC_OP_DYNAMIC)\n\n                gen_op_set_cc_op(s->cc_op);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_fwait(cpu_env);\n\n        }\n\n        break;\n\n    case 0xcc: /* int3 */\n\n        gen_interrupt(s, EXCP03_INT3, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        break;\n\n    case 0xcd: /* int N */\n\n        val = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        if (s->vm86 && s->iopl != 3) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_interrupt(s, val, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xce: /* into */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_into(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n        break;\n\n#ifdef WANT_ICEBP\n\n    case 0xf1: /* icebp (undocumented, exits to external debugger) */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_ICEBP);\n\n#if 1\n\n        gen_debug(s, pc_start - s->cs_base);\n\n#else\n\n        /* start debug */\n\n        tb_flush(cpu_single_env);\n\n        cpu_set_log(CPU_LOG_INT | CPU_LOG_TB_IN_ASM);\n\n#endif\n\n        break;\n\n#endif\n\n    case 0xfa: /* cli */\n\n        if (!s->vm86) {\n\n            if (s->cpl <= s->iopl) {\n\n                gen_helper_cli(cpu_env);\n\n            } else {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            }\n\n        } else {\n\n            if (s->iopl == 3) {\n\n                gen_helper_cli(cpu_env);\n\n            } else {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            }\n\n        }\n\n        break;\n\n    case 0xfb: /* sti */\n\n        if (!s->vm86) {\n\n            if (s->cpl <= s->iopl) {\n\n            gen_sti:\n\n                gen_helper_sti(cpu_env);\n\n                /* interruptions are enabled only the first insn after sti */\n\n                /* If several instructions disable interrupts, only the\n\n                   _first_ does it */\n\n                if (!(s->tb->flags & HF_INHIBIT_IRQ_MASK))\n\n                    gen_helper_set_inhibit_irq(cpu_env);\n\n                /* give a chance to handle pending irqs */\n\n                gen_jmp_im(s->pc - s->cs_base);\n\n                gen_eob(s);\n\n            } else {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            }\n\n        } else {\n\n            if (s->iopl == 3) {\n\n                goto gen_sti;\n\n            } else {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            }\n\n        }\n\n        break;\n\n    case 0x62: /* bound */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        ot = dflag ? OT_LONG : OT_WORD;\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        reg = (modrm >> 3) & 7;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        gen_op_mov_TN_reg(ot, 0, reg);\n\n        gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n        if (ot == OT_WORD) {\n\n            gen_helper_boundw(cpu_env, cpu_A0, cpu_tmp2_i32);\n\n        } else {\n\n            gen_helper_boundl(cpu_env, cpu_A0, cpu_tmp2_i32);\n\n        }\n\n        break;\n\n    case 0x1c8 ... 0x1cf: /* bswap reg */\n\n        reg = (b & 7) | REX_B(s);\n\n#ifdef TARGET_X86_64\n\n        if (dflag == 2) {\n\n            gen_op_mov_TN_reg(OT_QUAD, 0, reg);\n\n            tcg_gen_bswap64_i64(cpu_T[0], cpu_T[0]);\n\n            gen_op_mov_reg_T0(OT_QUAD, reg);\n\n        } else\n\n#endif\n\n        {\n\n            gen_op_mov_TN_reg(OT_LONG, 0, reg);\n\n            tcg_gen_ext32u_tl(cpu_T[0], cpu_T[0]);\n\n            tcg_gen_bswap32_tl(cpu_T[0], cpu_T[0]);\n\n            gen_op_mov_reg_T0(OT_LONG, reg);\n\n        }\n\n        break;\n\n    case 0xd6: /* salc */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_compute_eflags_c(cpu_T[0]);\n\n        tcg_gen_neg_tl(cpu_T[0], cpu_T[0]);\n\n        gen_op_mov_reg_T0(OT_BYTE, R_EAX);\n\n        break;\n\n    case 0xe0: /* loopnz */\n\n    case 0xe1: /* loopz */\n\n    case 0xe2: /* loop */\n\n    case 0xe3: /* jecxz */\n\n        {\n\n            int l1, l2, l3;\n\n\n\n            tval = (int8_t)insn_get(s, OT_BYTE);\n\n            next_eip = s->pc - s->cs_base;\n\n            tval += next_eip;\n\n            if (s->dflag == 0)\n\n                tval &= 0xffff;\n\n\n\n            l1 = gen_new_label();\n\n            l2 = gen_new_label();\n\n            l3 = gen_new_label();\n\n            b &= 3;\n\n            switch(b) {\n\n            case 0: /* loopnz */\n\n            case 1: /* loopz */\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_op_add_reg_im(s->aflag, R_ECX, -1);\n\n                gen_op_jz_ecx(s->aflag, l3);\n\n                gen_compute_eflags(cpu_tmp0);\n\n                tcg_gen_andi_tl(cpu_tmp0, cpu_tmp0, CC_Z);\n\n                if (b == 0) {\n\n                    tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_tmp0, 0, l1);\n\n                } else {\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_tmp0, 0, l1);\n\n                }\n\n                break;\n\n            case 2: /* loop */\n\n                gen_op_add_reg_im(s->aflag, R_ECX, -1);\n\n                gen_op_jnz_ecx(s->aflag, l1);\n\n                break;\n\n            default:\n\n            case 3: /* jcxz */\n\n                gen_op_jz_ecx(s->aflag, l1);\n\n                break;\n\n            }\n\n\n\n            gen_set_label(l3);\n\n            gen_jmp_im(next_eip);\n\n            tcg_gen_br(l2);\n\n\n\n            gen_set_label(l1);\n\n            gen_jmp_im(tval);\n\n            gen_set_label(l2);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x130: /* wrmsr */\n\n    case 0x132: /* rdmsr */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            if (s->cc_op != CC_OP_DYNAMIC)\n\n                gen_op_set_cc_op(s->cc_op);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            if (b & 2) {\n\n                gen_helper_rdmsr(cpu_env);\n\n            } else {\n\n                gen_helper_wrmsr(cpu_env);\n\n            }\n\n        }\n\n        break;\n\n    case 0x131: /* rdtsc */\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        if (use_icount)\n\n            gen_io_start();\n\n        gen_helper_rdtsc(cpu_env);\n\n        if (use_icount) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0x133: /* rdpmc */\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_rdpmc(cpu_env);\n\n        break;\n\n    case 0x134: /* sysenter */\n\n        /* For Intel SYSENTER is valid on 64-bit */\n\n        if (CODE64(s) && cpu_single_env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)\n\n            goto illegal_op;\n\n        if (!s->pe) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_sysenter(cpu_env);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x135: /* sysexit */\n\n        /* For Intel SYSEXIT is valid on 64-bit */\n\n        if (CODE64(s) && cpu_single_env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)\n\n            goto illegal_op;\n\n        if (!s->pe) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_sysexit(cpu_env, tcg_const_i32(dflag));\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n#ifdef TARGET_X86_64\n\n    case 0x105: /* syscall */\n\n        /* XXX: is it usable in real mode ? */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_syscall(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n        gen_eob(s);\n\n        break;\n\n    case 0x107: /* sysret */\n\n        if (!s->pe) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_sysret(cpu_env, tcg_const_i32(s->dflag));\n\n            /* condition codes are modified only in long mode */\n\n            if (s->lma)\n\n                s->cc_op = CC_OP_EFLAGS;\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n#endif\n\n    case 0x1a2: /* cpuid */\n\n        if (s->cc_op != CC_OP_DYNAMIC)\n\n            gen_op_set_cc_op(s->cc_op);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_cpuid(cpu_env);\n\n        break;\n\n    case 0xf4: /* hlt */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            if (s->cc_op != CC_OP_DYNAMIC)\n\n                gen_op_set_cc_op(s->cc_op);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_hlt(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n            s->is_jmp = DISAS_TB_JUMP;\n\n        }\n\n        break;\n\n    case 0x100:\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        op = (modrm >> 3) & 7;\n\n        switch(op) {\n\n        case 0: /* sldt */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_READ);\n\n            tcg_gen_ld32u_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,ldt.selector));\n\n            ot = OT_WORD;\n\n            if (mod == 3)\n\n                ot += s->dflag;\n\n            gen_ldst_modrm(s, modrm, ot, OR_TMP0, 1);\n\n            break;\n\n        case 2: /* lldt */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_WRITE);\n\n                gen_ldst_modrm(s, modrm, OT_WORD, OR_TMP0, 0);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                gen_helper_lldt(cpu_env, cpu_tmp2_i32);\n\n            }\n\n            break;\n\n        case 1: /* str */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_READ);\n\n            tcg_gen_ld32u_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,tr.selector));\n\n            ot = OT_WORD;\n\n            if (mod == 3)\n\n                ot += s->dflag;\n\n            gen_ldst_modrm(s, modrm, ot, OR_TMP0, 1);\n\n            break;\n\n        case 3: /* ltr */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_WRITE);\n\n                gen_ldst_modrm(s, modrm, OT_WORD, OR_TMP0, 0);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                gen_helper_ltr(cpu_env, cpu_tmp2_i32);\n\n            }\n\n            break;\n\n        case 4: /* verr */\n\n        case 5: /* verw */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            gen_ldst_modrm(s, modrm, OT_WORD, OR_TMP0, 0);\n\n            if (s->cc_op != CC_OP_DYNAMIC)\n\n                gen_op_set_cc_op(s->cc_op);\n\n            if (op == 4) {\n\n                gen_helper_verr(cpu_env, cpu_T[0]);\n\n            } else {\n\n                gen_helper_verw(cpu_env, cpu_T[0]);\n\n            }\n\n            s->cc_op = CC_OP_EFLAGS;\n\n            break;\n\n        default:\n\n            goto illegal_op;\n\n        }\n\n        break;\n\n    case 0x101:\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        op = (modrm >> 3) & 7;\n\n        rm = modrm & 7;\n\n        switch(op) {\n\n        case 0: /* sgdt */\n\n            if (mod == 3)\n\n                goto illegal_op;\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_READ);\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            tcg_gen_ld32u_tl(cpu_T[0], cpu_env, offsetof(CPUX86State, gdt.limit));\n\n            gen_op_st_T0_A0(OT_WORD + s->mem_index);\n\n            gen_add_A0_im(s, 2);\n\n            tcg_gen_ld_tl(cpu_T[0], cpu_env, offsetof(CPUX86State, gdt.base));\n\n            if (!s->dflag)\n\n                gen_op_andl_T0_im(0xffffff);\n\n            gen_op_st_T0_A0(CODE64(s) + OT_LONG + s->mem_index);\n\n            break;\n\n        case 1:\n\n            if (mod == 3) {\n\n                switch (rm) {\n\n                case 0: /* monitor */\n\n                    if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) ||\n\n                        s->cpl != 0)\n\n                        goto illegal_op;\n\n                    if (s->cc_op != CC_OP_DYNAMIC)\n\n                        gen_op_set_cc_op(s->cc_op);\n\n                    gen_jmp_im(pc_start - s->cs_base);\n\n#ifdef TARGET_X86_64\n\n                    if (s->aflag == 2) {\n\n                        gen_op_movq_A0_reg(R_EAX);\n\n                    } else\n\n#endif\n\n                    {\n\n                        gen_op_movl_A0_reg(R_EAX);\n\n                        if (s->aflag == 0)\n\n                            gen_op_andl_A0_ffff();\n\n                    }\n\n                    gen_add_A0_ds_seg(s);\n\n                    gen_helper_monitor(cpu_env, cpu_A0);\n\n                    break;\n\n                case 1: /* mwait */\n\n                    if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) ||\n\n                        s->cpl != 0)\n\n                        goto illegal_op;\n\n                    gen_update_cc_op(s);\n\n                    gen_jmp_im(pc_start - s->cs_base);\n\n                    gen_helper_mwait(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n                    gen_eob(s);\n\n                    break;\n\n                default:\n\n                    goto illegal_op;\n\n                }\n\n            } else { /* sidt */\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_READ);\n\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n                tcg_gen_ld32u_tl(cpu_T[0], cpu_env, offsetof(CPUX86State, idt.limit));\n\n                gen_op_st_T0_A0(OT_WORD + s->mem_index);\n\n                gen_add_A0_im(s, 2);\n\n                tcg_gen_ld_tl(cpu_T[0], cpu_env, offsetof(CPUX86State, idt.base));\n\n                if (!s->dflag)\n\n                    gen_op_andl_T0_im(0xffffff);\n\n                gen_op_st_T0_A0(CODE64(s) + OT_LONG + s->mem_index);\n\n            }\n\n            break;\n\n        case 2: /* lgdt */\n\n        case 3: /* lidt */\n\n            if (mod == 3) {\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                switch(rm) {\n\n                case 0: /* VMRUN */\n\n                    if (!(s->flags & HF_SVME_MASK) || !s->pe)\n\n                        goto illegal_op;\n\n                    if (s->cpl != 0) {\n\n                        gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                        break;\n\n                    } else {\n\n                        gen_helper_vmrun(cpu_env, tcg_const_i32(s->aflag),\n\n                                         tcg_const_i32(s->pc - pc_start));\n\n                        tcg_gen_exit_tb(0);\n\n                        s->is_jmp = DISAS_TB_JUMP;\n\n                    }\n\n                    break;\n\n                case 1: /* VMMCALL */\n\n                    if (!(s->flags & HF_SVME_MASK))\n\n                        goto illegal_op;\n\n                    gen_helper_vmmcall(cpu_env);\n\n                    break;\n\n                case 2: /* VMLOAD */\n\n                    if (!(s->flags & HF_SVME_MASK) || !s->pe)\n\n                        goto illegal_op;\n\n                    if (s->cpl != 0) {\n\n                        gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                        break;\n\n                    } else {\n\n                        gen_helper_vmload(cpu_env, tcg_const_i32(s->aflag));\n\n                    }\n\n                    break;\n\n                case 3: /* VMSAVE */\n\n                    if (!(s->flags & HF_SVME_MASK) || !s->pe)\n\n                        goto illegal_op;\n\n                    if (s->cpl != 0) {\n\n                        gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                        break;\n\n                    } else {\n\n                        gen_helper_vmsave(cpu_env, tcg_const_i32(s->aflag));\n\n                    }\n\n                    break;\n\n                case 4: /* STGI */\n\n                    if ((!(s->flags & HF_SVME_MASK) &&\n\n                         !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT)) || \n\n                        !s->pe)\n\n                        goto illegal_op;\n\n                    if (s->cpl != 0) {\n\n                        gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                        break;\n\n                    } else {\n\n                        gen_helper_stgi(cpu_env);\n\n                    }\n\n                    break;\n\n                case 5: /* CLGI */\n\n                    if (!(s->flags & HF_SVME_MASK) || !s->pe)\n\n                        goto illegal_op;\n\n                    if (s->cpl != 0) {\n\n                        gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                        break;\n\n                    } else {\n\n                        gen_helper_clgi(cpu_env);\n\n                    }\n\n                    break;\n\n                case 6: /* SKINIT */\n\n                    if ((!(s->flags & HF_SVME_MASK) && \n\n                         !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT)) || \n\n                        !s->pe)\n\n                        goto illegal_op;\n\n                    gen_helper_skinit(cpu_env);\n\n                    break;\n\n                case 7: /* INVLPGA */\n\n                    if (!(s->flags & HF_SVME_MASK) || !s->pe)\n\n                        goto illegal_op;\n\n                    if (s->cpl != 0) {\n\n                        gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                        break;\n\n                    } else {\n\n                        gen_helper_invlpga(cpu_env, tcg_const_i32(s->aflag));\n\n                    }\n\n                    break;\n\n                default:\n\n                    goto illegal_op;\n\n                }\n\n            } else if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start,\n\n                                        op==2 ? SVM_EXIT_GDTR_WRITE : SVM_EXIT_IDTR_WRITE);\n\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n                gen_op_ld_T1_A0(OT_WORD + s->mem_index);\n\n                gen_add_A0_im(s, 2);\n\n                gen_op_ld_T0_A0(CODE64(s) + OT_LONG + s->mem_index);\n\n                if (!s->dflag)\n\n                    gen_op_andl_T0_im(0xffffff);\n\n                if (op == 2) {\n\n                    tcg_gen_st_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,gdt.base));\n\n                    tcg_gen_st32_tl(cpu_T[1], cpu_env, offsetof(CPUX86State,gdt.limit));\n\n                } else {\n\n                    tcg_gen_st_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,idt.base));\n\n                    tcg_gen_st32_tl(cpu_T[1], cpu_env, offsetof(CPUX86State,idt.limit));\n\n                }\n\n            }\n\n            break;\n\n        case 4: /* smsw */\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_CR0);\n\n#if defined TARGET_X86_64 && defined HOST_WORDS_BIGENDIAN\n\n            tcg_gen_ld32u_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,cr[0]) + 4);\n\n#else\n\n            tcg_gen_ld32u_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,cr[0]));\n\n#endif\n\n            gen_ldst_modrm(s, modrm, OT_WORD, OR_TMP0, 1);\n\n            break;\n\n        case 6: /* lmsw */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);\n\n                gen_ldst_modrm(s, modrm, OT_WORD, OR_TMP0, 0);\n\n                gen_helper_lmsw(cpu_env, cpu_T[0]);\n\n                gen_jmp_im(s->pc - s->cs_base);\n\n                gen_eob(s);\n\n            }\n\n            break;\n\n        case 7:\n\n            if (mod != 3) { /* invlpg */\n\n                if (s->cpl != 0) {\n\n                    gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                } else {\n\n                    if (s->cc_op != CC_OP_DYNAMIC)\n\n                        gen_op_set_cc_op(s->cc_op);\n\n                    gen_jmp_im(pc_start - s->cs_base);\n\n                    gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n                    gen_helper_invlpg(cpu_env, cpu_A0);\n\n                    gen_jmp_im(s->pc - s->cs_base);\n\n                    gen_eob(s);\n\n                }\n\n            } else {\n\n                switch (rm) {\n\n                case 0: /* swapgs */\n\n#ifdef TARGET_X86_64\n\n                    if (CODE64(s)) {\n\n                        if (s->cpl != 0) {\n\n                            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                        } else {\n\n                            tcg_gen_ld_tl(cpu_T[0], cpu_env,\n\n                                offsetof(CPUX86State,segs[R_GS].base));\n\n                            tcg_gen_ld_tl(cpu_T[1], cpu_env,\n\n                                offsetof(CPUX86State,kernelgsbase));\n\n                            tcg_gen_st_tl(cpu_T[1], cpu_env,\n\n                                offsetof(CPUX86State,segs[R_GS].base));\n\n                            tcg_gen_st_tl(cpu_T[0], cpu_env,\n\n                                offsetof(CPUX86State,kernelgsbase));\n\n                        }\n\n                    } else\n\n#endif\n\n                    {\n\n                        goto illegal_op;\n\n                    }\n\n                    break;\n\n                case 1: /* rdtscp */\n\n                    if (!(s->cpuid_ext2_features & CPUID_EXT2_RDTSCP))\n\n                        goto illegal_op;\n\n                    if (s->cc_op != CC_OP_DYNAMIC)\n\n                        gen_op_set_cc_op(s->cc_op);\n\n                    gen_jmp_im(pc_start - s->cs_base);\n\n                    if (use_icount)\n\n                        gen_io_start();\n\n                    gen_helper_rdtscp(cpu_env);\n\n                    if (use_icount) {\n\n                        gen_io_end();\n\n                        gen_jmp(s, s->pc - s->cs_base);\n\n                    }\n\n                    break;\n\n                default:\n\n                    goto illegal_op;\n\n                }\n\n            }\n\n            break;\n\n        default:\n\n            goto illegal_op;\n\n        }\n\n        break;\n\n    case 0x108: /* invd */\n\n    case 0x109: /* wbinvd */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_svm_check_intercept(s, pc_start, (b & 2) ? SVM_EXIT_INVD : SVM_EXIT_WBINVD);\n\n            /* nothing to do */\n\n        }\n\n        break;\n\n    case 0x63: /* arpl or movslS (x86_64) */\n\n#ifdef TARGET_X86_64\n\n        if (CODE64(s)) {\n\n            int d_ot;\n\n            /* d_ot is the size of destination */\n\n            d_ot = dflag + OT_WORD;\n\n\n\n            modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            rm = (modrm & 7) | REX_B(s);\n\n\n\n            if (mod == 3) {\n\n                gen_op_mov_TN_reg(OT_LONG, 0, rm);\n\n                /* sign extend */\n\n                if (d_ot == OT_QUAD)\n\n                    tcg_gen_ext32s_tl(cpu_T[0], cpu_T[0]);\n\n                gen_op_mov_reg_T0(d_ot, reg);\n\n            } else {\n\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n                if (d_ot == OT_QUAD) {\n\n                    gen_op_lds_T0_A0(OT_LONG + s->mem_index);\n\n                } else {\n\n                    gen_op_ld_T0_A0(OT_LONG + s->mem_index);\n\n                }\n\n                gen_op_mov_reg_T0(d_ot, reg);\n\n            }\n\n        } else\n\n#endif\n\n        {\n\n            int label1;\n\n            TCGv t0, t1, t2, a0;\n\n\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            t0 = tcg_temp_local_new();\n\n            t1 = tcg_temp_local_new();\n\n            t2 = tcg_temp_local_new();\n\n            ot = OT_WORD;\n\n            modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n            reg = (modrm >> 3) & 7;\n\n            mod = (modrm >> 6) & 3;\n\n            rm = modrm & 7;\n\n            if (mod != 3) {\n\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n                gen_op_ld_v(ot + s->mem_index, t0, cpu_A0);\n\n                a0 = tcg_temp_local_new();\n\n                tcg_gen_mov_tl(a0, cpu_A0);\n\n            } else {\n\n                gen_op_mov_v_reg(ot, t0, rm);\n\n                TCGV_UNUSED(a0);\n\n            }\n\n            gen_op_mov_v_reg(ot, t1, reg);\n\n            tcg_gen_andi_tl(cpu_tmp0, t0, 3);\n\n            tcg_gen_andi_tl(t1, t1, 3);\n\n            tcg_gen_movi_tl(t2, 0);\n\n            label1 = gen_new_label();\n\n            tcg_gen_brcond_tl(TCG_COND_GE, cpu_tmp0, t1, label1);\n\n            tcg_gen_andi_tl(t0, t0, ~3);\n\n            tcg_gen_or_tl(t0, t0, t1);\n\n            tcg_gen_movi_tl(t2, CC_Z);\n\n            gen_set_label(label1);\n\n            if (mod != 3) {\n\n                gen_op_st_v(ot + s->mem_index, t0, a0);\n\n                tcg_temp_free(a0);\n\n           } else {\n\n                gen_op_mov_reg_v(ot, rm, t0);\n\n            }\n\n            if (s->cc_op != CC_OP_DYNAMIC)\n\n                gen_op_set_cc_op(s->cc_op);\n\n            gen_compute_eflags(cpu_cc_src);\n\n            tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_Z);\n\n            tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, t2);\n\n            s->cc_op = CC_OP_EFLAGS;\n\n            tcg_temp_free(t0);\n\n            tcg_temp_free(t1);\n\n            tcg_temp_free(t2);\n\n        }\n\n        break;\n\n    case 0x102: /* lar */\n\n    case 0x103: /* lsl */\n\n        {\n\n            int label1;\n\n            TCGv t0;\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            ot = dflag ? OT_LONG : OT_WORD;\n\n            modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            gen_ldst_modrm(s, modrm, OT_WORD, OR_TMP0, 0);\n\n            t0 = tcg_temp_local_new();\n\n            if (s->cc_op != CC_OP_DYNAMIC)\n\n                gen_op_set_cc_op(s->cc_op);\n\n            if (b == 0x102) {\n\n                gen_helper_lar(t0, cpu_env, cpu_T[0]);\n\n            } else {\n\n                gen_helper_lsl(t0, cpu_env, cpu_T[0]);\n\n            }\n\n            tcg_gen_andi_tl(cpu_tmp0, cpu_cc_src, CC_Z);\n\n            label1 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_tmp0, 0, label1);\n\n            gen_op_mov_reg_v(ot, reg, t0);\n\n            gen_set_label(label1);\n\n            s->cc_op = CC_OP_EFLAGS;\n\n            tcg_temp_free(t0);\n\n        }\n\n        break;\n\n    case 0x118:\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        op = (modrm >> 3) & 7;\n\n        switch(op) {\n\n        case 0: /* prefetchnta */\n\n        case 1: /* prefetchnt0 */\n\n        case 2: /* prefetchnt0 */\n\n        case 3: /* prefetchnt0 */\n\n            if (mod == 3)\n\n                goto illegal_op;\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            /* nothing more to do */\n\n            break;\n\n        default: /* nop (multi byte) */\n\n            gen_nop_modrm(s, modrm);\n\n            break;\n\n        }\n\n        break;\n\n    case 0x119 ... 0x11f: /* nop (multi byte) */\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        gen_nop_modrm(s, modrm);\n\n        break;\n\n    case 0x120: /* mov reg, crN */\n\n    case 0x122: /* mov crN, reg */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n            /* Ignore the mod bits (assume (modrm&0xc0)==0xc0).\n\n             * AMD documentation (24594.pdf) and testing of\n\n             * intel 386 and 486 processors all show that the mod bits\n\n             * are assumed to be 1's, regardless of actual values.\n\n             */\n\n            rm = (modrm & 7) | REX_B(s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (CODE64(s))\n\n                ot = OT_QUAD;\n\n            else\n\n                ot = OT_LONG;\n\n            if ((prefixes & PREFIX_LOCK) && (reg == 0) &&\n\n                (s->cpuid_ext3_features & CPUID_EXT3_CR8LEG)) {\n\n                reg = 8;\n\n            }\n\n            switch(reg) {\n\n            case 0:\n\n            case 2:\n\n            case 3:\n\n            case 4:\n\n            case 8:\n\n                if (s->cc_op != CC_OP_DYNAMIC)\n\n                    gen_op_set_cc_op(s->cc_op);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                if (b & 2) {\n\n                    gen_op_mov_TN_reg(ot, 0, rm);\n\n                    gen_helper_write_crN(cpu_env, tcg_const_i32(reg),\n\n                                         cpu_T[0]);\n\n                    gen_jmp_im(s->pc - s->cs_base);\n\n                    gen_eob(s);\n\n                } else {\n\n                    gen_helper_read_crN(cpu_T[0], cpu_env, tcg_const_i32(reg));\n\n                    gen_op_mov_reg_T0(ot, rm);\n\n                }\n\n                break;\n\n            default:\n\n                goto illegal_op;\n\n            }\n\n        }\n\n        break;\n\n    case 0x121: /* mov reg, drN */\n\n    case 0x123: /* mov drN, reg */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n            /* Ignore the mod bits (assume (modrm&0xc0)==0xc0).\n\n             * AMD documentation (24594.pdf) and testing of\n\n             * intel 386 and 486 processors all show that the mod bits\n\n             * are assumed to be 1's, regardless of actual values.\n\n             */\n\n            rm = (modrm & 7) | REX_B(s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (CODE64(s))\n\n                ot = OT_QUAD;\n\n            else\n\n                ot = OT_LONG;\n\n            /* XXX: do it dynamically with CR4.DE bit */\n\n            if (reg == 4 || reg == 5 || reg >= 8)\n\n                goto illegal_op;\n\n            if (b & 2) {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_DR0 + reg);\n\n                gen_op_mov_TN_reg(ot, 0, rm);\n\n                gen_helper_movl_drN_T0(cpu_env, tcg_const_i32(reg), cpu_T[0]);\n\n                gen_jmp_im(s->pc - s->cs_base);\n\n                gen_eob(s);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_DR0 + reg);\n\n                tcg_gen_ld_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,dr[reg]));\n\n                gen_op_mov_reg_T0(ot, rm);\n\n            }\n\n        }\n\n        break;\n\n    case 0x106: /* clts */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);\n\n            gen_helper_clts(cpu_env);\n\n            /* abort block because static cpu state changed */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    /* MMX/3DNow!/SSE/SSE2/SSE3/SSSE3/SSE4 support */\n\n    case 0x1c3: /* MOVNTI reg, mem */\n\n        if (!(s->cpuid_features & CPUID_SSE2))\n\n            goto illegal_op;\n\n        ot = s->dflag == 2 ? OT_QUAD : OT_LONG;\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        /* generate a generic store */\n\n        gen_ldst_modrm(s, modrm, ot, reg, 1);\n\n        break;\n\n    case 0x1ae:\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        op = (modrm >> 3) & 7;\n\n        switch(op) {\n\n        case 0: /* fxsave */\n\n            if (mod == 3 || !(s->cpuid_features & CPUID_FXSR) ||\n\n                (s->prefix & PREFIX_LOCK))\n\n                goto illegal_op;\n\n            if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            if (s->cc_op != CC_OP_DYNAMIC)\n\n                gen_op_set_cc_op(s->cc_op);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_fxsave(cpu_env, cpu_A0, tcg_const_i32((s->dflag == 2)));\n\n            break;\n\n        case 1: /* fxrstor */\n\n            if (mod == 3 || !(s->cpuid_features & CPUID_FXSR) ||\n\n                (s->prefix & PREFIX_LOCK))\n\n                goto illegal_op;\n\n            if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            if (s->cc_op != CC_OP_DYNAMIC)\n\n                gen_op_set_cc_op(s->cc_op);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_fxrstor(cpu_env, cpu_A0,\n\n                               tcg_const_i32((s->dflag == 2)));\n\n            break;\n\n        case 2: /* ldmxcsr */\n\n        case 3: /* stmxcsr */\n\n            if (s->flags & HF_TS_MASK) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK) ||\n\n                mod == 3)\n\n                goto illegal_op;\n\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            if (op == 2) {\n\n                gen_op_ld_T0_A0(OT_LONG + s->mem_index);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                gen_helper_ldmxcsr(cpu_env, cpu_tmp2_i32);\n\n            } else {\n\n                tcg_gen_ld32u_tl(cpu_T[0], cpu_env, offsetof(CPUX86State, mxcsr));\n\n                gen_op_st_T0_A0(OT_LONG + s->mem_index);\n\n            }\n\n            break;\n\n        case 5: /* lfence */\n\n        case 6: /* mfence */\n\n            if ((modrm & 0xc7) != 0xc0 || !(s->cpuid_features & CPUID_SSE2))\n\n                goto illegal_op;\n\n            break;\n\n        case 7: /* sfence / clflush */\n\n            if ((modrm & 0xc7) == 0xc0) {\n\n                /* sfence */\n\n                /* XXX: also check for cpuid_ext2_features & CPUID_EXT2_EMMX */\n\n                if (!(s->cpuid_features & CPUID_SSE))\n\n                    goto illegal_op;\n\n            } else {\n\n                /* clflush */\n\n                if (!(s->cpuid_features & CPUID_CLFLUSH))\n\n                    goto illegal_op;\n\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n            }\n\n            break;\n\n        default:\n\n            goto illegal_op;\n\n        }\n\n        break;\n\n    case 0x10d: /* 3DNow! prefetch(w) */\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n\n        /* ignore for now */\n\n        break;\n\n    case 0x1aa: /* rsm */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_RSM);\n\n        if (!(s->flags & HF_SMM_MASK))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(s->pc - s->cs_base);\n\n        gen_helper_rsm(cpu_env);\n\n        gen_eob(s);\n\n        break;\n\n    case 0x1b8: /* SSE4.2 popcnt */\n\n        if ((prefixes & (PREFIX_REPZ | PREFIX_LOCK | PREFIX_REPNZ)) !=\n\n             PREFIX_REPZ)\n\n            goto illegal_op;\n\n        if (!(s->cpuid_ext_features & CPUID_EXT_POPCNT))\n\n            goto illegal_op;\n\n\n\n        modrm = cpu_ldub_code(cpu_single_env, s->pc++);\n\n        reg = ((modrm >> 3) & 7);\n\n\n\n        if (s->prefix & PREFIX_DATA)\n\n            ot = OT_WORD;\n\n        else if (s->dflag != 2)\n\n            ot = OT_LONG;\n\n        else\n\n            ot = OT_QUAD;\n\n\n\n        gen_ldst_modrm(s, modrm, ot, OR_TMP0, 0);\n\n        gen_helper_popcnt(cpu_T[0], cpu_env, cpu_T[0], tcg_const_i32(ot));\n\n        gen_op_mov_reg_T0(ot, reg);\n\n\n\n        s->cc_op = CC_OP_EFLAGS;\n\n        break;\n\n    case 0x10e ... 0x10f:\n\n        /* 3DNow! instructions, ignore prefixes */\n\n        s->prefix &= ~(PREFIX_REPZ | PREFIX_REPNZ | PREFIX_DATA);\n\n    case 0x110 ... 0x117:\n\n    case 0x128 ... 0x12f:\n\n    case 0x138 ... 0x13a:\n\n    case 0x150 ... 0x179:\n\n    case 0x17c ... 0x17f:\n\n    case 0x1c2:\n\n    case 0x1c4 ... 0x1c6:\n\n    case 0x1d0 ... 0x1fe:\n\n        gen_sse(s, b, pc_start, rex_r);\n\n        break;\n\n    default:\n\n        goto illegal_op;\n\n    }\n\n    /* lock generation */\n\n    if (s->prefix & PREFIX_LOCK)\n\n        gen_helper_unlock();\n\n    return s->pc;\n\n illegal_op:\n\n    if (s->prefix & PREFIX_LOCK)\n\n        gen_helper_unlock();\n\n    /* XXX: ensure that no lock was generated */\n\n    gen_exception(s, EXCP06_ILLOP, pc_start - s->cs_base);\n\n    return s->pc;\n\n}\n", "idx": 24045}
{"project": "qemu", "commit_id": "30656b097e9dd7978d3fe9416cb9f5a421a9e63e", "target": 0, "func": "static ssize_t colo_rewriter_receive_iov(NetFilterState *nf,\n\n                                         NetClientState *sender,\n\n                                         unsigned flags,\n\n                                         const struct iovec *iov,\n\n                                         int iovcnt,\n\n                                         NetPacketSent *sent_cb)\n\n{\n\n    RewriterState *s = FILTER_COLO_REWRITER(nf);\n\n    Connection *conn;\n\n    ConnectionKey key;\n\n    Packet *pkt;\n\n    ssize_t size = iov_size(iov, iovcnt);\n\n    char *buf = g_malloc0(size);\n\n\n\n    iov_to_buf(iov, iovcnt, 0, buf, size);\n\n    pkt = packet_new(buf, size);\n\n\n\n    /*\n\n     * if we get tcp packet\n\n     * we will rewrite it to make secondary guest's\n\n     * connection established successfully\n\n     */\n\n    if (pkt && is_tcp_packet(pkt)) {\n\n\n\n        fill_connection_key(pkt, &key);\n\n\n\n        if (sender == nf->netdev) {\n\n            /*\n\n             * We need make tcp TX and RX packet\n\n             * into one connection.\n\n             */\n\n            reverse_connection_key(&key);\n\n        }\n\n        conn = connection_get(s->connection_track_table,\n\n                              &key,\n\n                              NULL);\n\n\n\n        if (sender == nf->netdev) {\n\n            /* NET_FILTER_DIRECTION_TX */\n\n            /* handle_primary_tcp_pkt */\n\n        } else {\n\n            /* NET_FILTER_DIRECTION_RX */\n\n            /* handle_secondary_tcp_pkt */\n\n        }\n\n    }\n\n\n\n    packet_destroy(pkt, NULL);\n\n    pkt = NULL;\n\n    return 0;\n\n}\n", "idx": 24046}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque,\n\n                      int abort_on_failure)\n\n{\n\n    QemuOpts *opts;\n\n    int rc = 0;\n\n\n\n    TAILQ_FOREACH(opts, &list->head, next) {\n\n        rc = func(opts, opaque);\n\n        if (abort_on_failure  &&  rc != 0)\n\n            break;\n\n    }\n\n    return rc;\n\n}\n", "idx": 24047}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void subpage_write(void *opaque, target_phys_addr_t addr,\n\n                          uint64_t value, unsigned len)\n\n{\n\n    subpage_t *mmio = opaque;\n\n    unsigned int idx = SUBPAGE_IDX(addr);\n\n    MemoryRegionSection *section;\n\n#if defined(DEBUG_SUBPAGE)\n\n    printf(\"%s: subpage %p len %d addr \" TARGET_FMT_plx\n\n           \" idx %d value %\"PRIx64\"\\n\",\n\n           __func__, mmio, len, addr, idx, value);\n\n#endif\n\n\n\n    section = &phys_sections[mmio->sub_section[idx]];\n\n    addr += mmio->base;\n\n    addr -= section->offset_within_address_space;\n\n    addr += section->offset_within_region;\n\n    io_mem_write(section->mr, addr, value, len);\n\n}\n", "idx": 24050}
{"project": "qemu", "commit_id": "891fb2cd4592b6fe76106a69e0ca40efbf82726a", "target": 0, "func": "int usb_device_attach(USBDevice *dev)\n\n{\n\n    USBBus *bus = usb_bus_from_device(dev);\n\n\n\n    if (bus->nfree == 1 && dev->port_path == NULL) {\n\n        /* Create a new hub and chain it on\n\n           (unless a physical port location is specified). */\n\n        usb_create_simple(bus, \"usb-hub\");\n\n    }\n\n    return do_attach(dev);\n\n}\n", "idx": 24051}
{"project": "qemu", "commit_id": "83f338f73ecb88cc6f85d6e7b81ebef112ce07be", "target": 0, "func": "static void cpu_debug_handler(CPUState *env)\n\n{\n\n    gdb_set_stop_cpu(env);\n\n    qemu_system_debug_request();\n\n}\n", "idx": 24052}
{"project": "qemu", "commit_id": "a3251186fc6a04d421e9c4b65aa04ec32379ec38", "target": 0, "func": "static CCPrepare gen_prepare_cc(DisasContext *s, int b, TCGv reg)\n\n{\n\n    int inv, jcc_op, size, cond;\n\n    CCPrepare cc;\n\n    TCGv t0;\n\n\n\n    inv = b & 1;\n\n    jcc_op = (b >> 1) & 7;\n\n\n\n    switch (s->cc_op) {\n\n    case CC_OP_SUBB ... CC_OP_SUBQ:\n\n        /* We optimize relational operators for the cmp/jcc case.  */\n\n        size = s->cc_op - CC_OP_SUBB;\n\n        switch (jcc_op) {\n\n        case JCC_BE:\n\n            tcg_gen_add_tl(cpu_tmp4, cpu_cc_dst, cpu_cc_src);\n\n            gen_extu(size, cpu_tmp4);\n\n            t0 = gen_ext_tl(cpu_tmp0, cpu_cc_src, size, false);\n\n            cc = (CCPrepare) { .cond = TCG_COND_LEU, .reg = cpu_tmp4,\n\n                               .reg2 = t0, .mask = -1, .use_reg2 = true };\n\n            break;\n\n\n\n        case JCC_L:\n\n            cond = TCG_COND_LT;\n\n            goto fast_jcc_l;\n\n        case JCC_LE:\n\n            cond = TCG_COND_LE;\n\n        fast_jcc_l:\n\n            tcg_gen_add_tl(cpu_tmp4, cpu_cc_dst, cpu_cc_src);\n\n            gen_exts(size, cpu_tmp4);\n\n            t0 = gen_ext_tl(cpu_tmp0, cpu_cc_src, size, true);\n\n            cc = (CCPrepare) { .cond = cond, .reg = cpu_tmp4,\n\n                               .reg2 = t0, .mask = -1, .use_reg2 = true };\n\n            break;\n\n\n\n        default:\n\n            goto slow_jcc;\n\n        }\n\n        break;\n\n\n\n    default:\n\n    slow_jcc:\n\n        /* This actually generates good code for JC, JZ and JS.  */\n\n        switch (jcc_op) {\n\n        case JCC_O:\n\n            cc = gen_prepare_eflags_o(s, reg);\n\n            break;\n\n        case JCC_B:\n\n            cc = gen_prepare_eflags_c(s, reg);\n\n            break;\n\n        case JCC_Z:\n\n            cc = gen_prepare_eflags_z(s, reg);\n\n            break;\n\n        case JCC_BE:\n\n            gen_compute_eflags(s);\n\n            cc = (CCPrepare) { .cond = TCG_COND_NE, .reg = cpu_cc_src,\n\n                               .mask = CC_Z | CC_C };\n\n            break;\n\n        case JCC_S:\n\n            cc = gen_prepare_eflags_s(s, reg);\n\n            break;\n\n        case JCC_P:\n\n            cc = gen_prepare_eflags_p(s, reg);\n\n            break;\n\n        case JCC_L:\n\n            gen_compute_eflags(s);\n\n            if (TCGV_EQUAL(reg, cpu_cc_src)) {\n\n                reg = cpu_tmp0;\n\n            }\n\n            tcg_gen_shri_tl(reg, cpu_cc_src, 4); /* CC_O -> CC_S */\n\n            tcg_gen_xor_tl(reg, reg, cpu_cc_src);\n\n            cc = (CCPrepare) { .cond = TCG_COND_NE, .reg = reg,\n\n                               .mask = CC_S };\n\n            break;\n\n        default:\n\n        case JCC_LE:\n\n            gen_compute_eflags(s);\n\n            if (TCGV_EQUAL(reg, cpu_cc_src)) {\n\n                reg = cpu_tmp0;\n\n            }\n\n            tcg_gen_shri_tl(reg, cpu_cc_src, 4); /* CC_O -> CC_S */\n\n            tcg_gen_xor_tl(reg, reg, cpu_cc_src);\n\n            cc = (CCPrepare) { .cond = TCG_COND_NE, .reg = reg,\n\n                               .mask = CC_S | CC_Z };\n\n            break;\n\n        }\n\n        break;\n\n    }\n\n\n\n    if (inv) {\n\n        cc.cond = tcg_invert_cond(cc.cond);\n\n    }\n\n    return cc;\n\n}\n", "idx": 24053}
{"project": "qemu", "commit_id": "8360544a6d3a54df1fce80f55ba4ad075a8ded54", "target": 0, "func": "static uint16_t qpci_spapr_io_readw(QPCIBus *bus, void *addr)\n\n{\n\n    QPCIBusSPAPR *s = container_of(bus, QPCIBusSPAPR, bus);\n\n    uint64_t port = (uintptr_t)addr;\n\n    uint16_t v;\n\n    if (port < s->pio.size) {\n\n        v = readw(s->pio_cpu_base + port);\n\n    } else {\n\n        v = readw(s->mmio_cpu_base + port);\n\n    }\n\n    return bswap16(v);\n\n}\n", "idx": 24054}
{"project": "qemu", "commit_id": "f03a1af581b926118d619ad1acc3304ad84d5e5b", "target": 1, "func": "static void init_proc_book3s_64(CPUPPCState *env, int version)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_tbl(env);\n\n    gen_spr_book3s_altivec(env);\n\n    gen_spr_book3s_pmu_sup(env);\n\n    gen_spr_book3s_pmu_user(env);\n\n    gen_spr_book3s_common(env);\n\n\n\n    switch (version) {\n\n    case BOOK3S_CPU_970:\n\n    case BOOK3S_CPU_POWER5PLUS:\n\n        gen_spr_970_hid(env);\n\n        gen_spr_970_hior(env);\n\n        gen_low_BATs(env);\n\n        gen_spr_970_pmu_sup(env);\n\n        gen_spr_970_pmu_user(env);\n\n        break;\n\n    case BOOK3S_CPU_POWER7:\n\n    case BOOK3S_CPU_POWER8:\n\n        gen_spr_book3s_ids(env);\n\n        gen_spr_amr(env, version >= BOOK3S_CPU_POWER8);\n\n        gen_spr_book3s_purr(env);\n\n        env->ci_large_pages = true;\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n    if (version >= BOOK3S_CPU_POWER5PLUS) {\n\n        gen_spr_power5p_common(env);\n\n        gen_spr_power5p_lpar(env);\n\n        gen_spr_power5p_ear(env);\n\n    } else {\n\n        gen_spr_970_lpar(env);\n\n    }\n\n    if (version == BOOK3S_CPU_970) {\n\n        gen_spr_970_dbg(env);\n\n    }\n\n    if (version >= BOOK3S_CPU_POWER6) {\n\n        gen_spr_power6_common(env);\n\n        gen_spr_power6_dbg(env);\n\n    }\n\n    if (version == BOOK3S_CPU_POWER7) {\n\n        gen_spr_power7_book4(env);\n\n    }\n\n    if (version >= BOOK3S_CPU_POWER8) {\n\n        gen_spr_power8_tce_address_control(env);\n\n        gen_spr_power8_ids(env);\n\n        gen_spr_power8_ebb(env);\n\n        gen_spr_power8_fscr(env);\n\n        gen_spr_power8_pmu_sup(env);\n\n        gen_spr_power8_pmu_user(env);\n\n        gen_spr_power8_tm(env);\n\n        gen_spr_power8_pspb(env);\n\n        gen_spr_vtb(env);\n\n        gen_spr_power8_ic(env);\n\n        gen_spr_power8_book4(env);\n\n    }\n\n    if (version < BOOK3S_CPU_POWER8) {\n\n        gen_spr_book3s_dbg(env);\n\n    } else {\n\n        gen_spr_book3s_207_dbg(env);\n\n    }\n\n#if !defined(CONFIG_USER_ONLY)\n\n    switch (version) {\n\n    case BOOK3S_CPU_970:\n\n    case BOOK3S_CPU_POWER5PLUS:\n\n        env->slb_nr = 64;\n\n        break;\n\n    case BOOK3S_CPU_POWER7:\n\n    case BOOK3S_CPU_POWER8:\n\n    default:\n\n        env->slb_nr = 32;\n\n        break;\n\n    }\n\n#endif\n\n    /* Allocate hardware IRQ controller */\n\n    switch (version) {\n\n    case BOOK3S_CPU_970:\n\n    case BOOK3S_CPU_POWER5PLUS:\n\n        init_excp_970(env);\n\n        ppc970_irq_init(ppc_env_get_cpu(env));\n\n        break;\n\n    case BOOK3S_CPU_POWER7:\n\n    case BOOK3S_CPU_POWER8:\n\n        init_excp_POWER7(env);\n\n        ppcPOWER7_irq_init(ppc_env_get_cpu(env));\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n\n\n    env->dcache_line_size = 128;\n\n    env->icache_line_size = 128;\n\n}\n", "idx": 24058}
{"project": "qemu", "commit_id": "c6047e9621f77a65993bcda8f58b676996e24bb5", "target": 1, "func": "static void virtio_host_initfn(Object *obj)\n\n{\n\n    VirtIOInputHostPCI *dev = VIRTIO_INPUT_HOST_PCI(obj);\n\n\n\n    virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),\n\n                                TYPE_VIRTIO_INPUT_HOST);\n\n}\n", "idx": 24059}
{"project": "qemu", "commit_id": "c2b6ff51e4a3ad1f7ec5dbc94970e9778b31d718", "target": 1, "func": "int qcow2_update_snapshot_refcount(BlockDriverState *bs,\n\n    int64_t l1_table_offset, int l1_size, int addend)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t *l1_table, *l2_table, l2_offset, offset, l1_size2, l1_allocated;\n\n    int64_t old_offset, old_l2_offset;\n\n    int i, j, l1_modified = 0, nb_csectors, refcount;\n\n    int ret;\n\n\n\n    l2_table = NULL;\n\n    l1_table = NULL;\n\n    l1_size2 = l1_size * sizeof(uint64_t);\n\n\n\n    /* WARNING: qcow2_snapshot_goto relies on this function not using the\n\n     * l1_table_offset when it is the current s->l1_table_offset! Be careful\n\n     * when changing this! */\n\n    if (l1_table_offset != s->l1_table_offset) {\n\n        l1_table = g_malloc0(align_offset(l1_size2, 512));\n\n        l1_allocated = 1;\n\n\n\n        ret = bdrv_pread(bs->file, l1_table_offset, l1_table, l1_size2);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        for(i = 0;i < l1_size; i++)\n\n            be64_to_cpus(&l1_table[i]);\n\n    } else {\n\n        assert(l1_size == s->l1_size);\n\n        l1_table = s->l1_table;\n\n        l1_allocated = 0;\n\n    }\n\n\n\n    for(i = 0; i < l1_size; i++) {\n\n        l2_offset = l1_table[i];\n\n        if (l2_offset) {\n\n            old_l2_offset = l2_offset;\n\n            l2_offset &= L1E_OFFSET_MASK;\n\n\n\n            ret = qcow2_cache_get(bs, s->l2_table_cache, l2_offset,\n\n                (void**) &l2_table);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            for(j = 0; j < s->l2_size; j++) {\n\n                offset = be64_to_cpu(l2_table[j]);\n\n                if (offset != 0) {\n\n                    old_offset = offset;\n\n                    offset &= ~QCOW_OFLAG_COPIED;\n\n                    if (offset & QCOW_OFLAG_COMPRESSED) {\n\n                        nb_csectors = ((offset >> s->csize_shift) &\n\n                                       s->csize_mask) + 1;\n\n                        if (addend != 0) {\n\n                            int ret;\n\n                            ret = update_refcount(bs,\n\n                                (offset & s->cluster_offset_mask) & ~511,\n\n                                nb_csectors * 512, addend);\n\n                            if (ret < 0) {\n\n                                goto fail;\n\n                            }\n\n                        }\n\n                        /* compressed clusters are never modified */\n\n                        refcount = 2;\n\n                    } else {\n\n                        uint64_t cluster_index = (offset & L2E_OFFSET_MASK) >> s->cluster_bits;\n\n                        if (addend != 0) {\n\n                            refcount = update_cluster_refcount(bs, cluster_index, addend);\n\n                        } else {\n\n                            refcount = get_refcount(bs, cluster_index);\n\n                        }\n\n\n\n                        if (refcount < 0) {\n\n                            ret = refcount;\n\n                            goto fail;\n\n                        }\n\n                    }\n\n\n\n                    if (refcount == 1) {\n\n                        offset |= QCOW_OFLAG_COPIED;\n\n                    }\n\n                    if (offset != old_offset) {\n\n                        if (addend > 0) {\n\n                            qcow2_cache_set_dependency(bs, s->l2_table_cache,\n\n                                s->refcount_block_cache);\n\n                        }\n\n                        l2_table[j] = cpu_to_be64(offset);\n\n                        qcow2_cache_entry_mark_dirty(s->l2_table_cache, l2_table);\n\n                    }\n\n                }\n\n            }\n\n\n\n            ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n\n\n            if (addend != 0) {\n\n                refcount = update_cluster_refcount(bs, l2_offset >> s->cluster_bits, addend);\n\n            } else {\n\n                refcount = get_refcount(bs, l2_offset >> s->cluster_bits);\n\n            }\n\n            if (refcount < 0) {\n\n                ret = refcount;\n\n                goto fail;\n\n            } else if (refcount == 1) {\n\n                l2_offset |= QCOW_OFLAG_COPIED;\n\n            }\n\n            if (l2_offset != old_l2_offset) {\n\n                l1_table[i] = l2_offset;\n\n                l1_modified = 1;\n\n            }\n\n        }\n\n    }\n\n\n\n    ret = bdrv_flush(bs);\n\nfail:\n\n    if (l2_table) {\n\n        qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n    }\n\n\n\n    /* Update L1 only if it isn't deleted anyway (addend = -1) */\n\n    if (addend >= 0 && l1_modified) {\n\n        for(i = 0; i < l1_size; i++)\n\n            cpu_to_be64s(&l1_table[i]);\n\n        if (bdrv_pwrite_sync(bs->file, l1_table_offset, l1_table,\n\n                        l1_size2) < 0)\n\n            goto fail;\n\n        for(i = 0; i < l1_size; i++)\n\n            be64_to_cpus(&l1_table[i]);\n\n    }\n\n    if (l1_allocated)\n\n        g_free(l1_table);\n\n    return ret;\n\n}\n", "idx": 24060}
{"project": "qemu", "commit_id": "6d74ca5aa83b83fb52332f7735c61ecb7a5328c1", "target": 1, "func": "static uint32_t syborg_virtio_readl(void *opaque, target_phys_addr_t offset)\n\n{\n\n    SyborgVirtIOProxy *s = opaque;\n\n    VirtIODevice *vdev = s->vdev;\n\n    uint32_t ret;\n\n\n\n    DPRINTF(\"readl 0x%x\\n\", (int)offset);\n\n    if (offset >= SYBORG_VIRTIO_CONFIG) {\n\n        return virtio_config_readl(vdev, offset - SYBORG_VIRTIO_CONFIG);\n\n    }\n\n    switch(offset >> 2) {\n\n    case SYBORG_VIRTIO_ID:\n\n        ret = SYBORG_ID_VIRTIO;\n\n        break;\n\n    case SYBORG_VIRTIO_DEVTYPE:\n\n        ret = s->id;\n\n        break;\n\n    case SYBORG_VIRTIO_HOST_FEATURES:\n\n        ret = vdev->get_features(vdev);\n\n        ret |= (1 << VIRTIO_F_NOTIFY_ON_EMPTY);\n\n        break;\n\n    case SYBORG_VIRTIO_GUEST_FEATURES:\n\n        ret = vdev->features;\n\n        break;\n\n    case SYBORG_VIRTIO_QUEUE_BASE:\n\n        ret = virtio_queue_get_addr(vdev, vdev->queue_sel);\n\n        break;\n\n    case SYBORG_VIRTIO_QUEUE_NUM:\n\n        ret = virtio_queue_get_num(vdev, vdev->queue_sel);\n\n        break;\n\n    case SYBORG_VIRTIO_QUEUE_SEL:\n\n        ret = vdev->queue_sel;\n\n        break;\n\n    case SYBORG_VIRTIO_STATUS:\n\n        ret = vdev->status;\n\n        break;\n\n    case SYBORG_VIRTIO_INT_ENABLE:\n\n        ret = s->int_enable;\n\n        break;\n\n    case SYBORG_VIRTIO_INT_STATUS:\n\n        ret = vdev->isr;\n\n        break;\n\n    default:\n\n        BADF(\"Bad read offset 0x%x\\n\", (int)offset);\n\n        return 0;\n\n    }\n\n    return ret;\n\n}\n", "idx": 24062}
{"project": "qemu", "commit_id": "07555ba6f303d4be8af538c3a66cc46ccb2e5751", "target": 1, "func": "static int nfs_file_create(const char *url, QemuOpts *opts, Error **errp)\n\n{\n\n    int ret = 0;\n\n    int64_t total_size = 0;\n\n    NFSClient *client = g_new0(NFSClient, 1);\n\n    QDict *options = NULL;\n\n\n\n    client->aio_context = qemu_get_aio_context();\n\n\n\n    /* Read out options */\n\n    total_size = ROUND_UP(qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0),\n\n                          BDRV_SECTOR_SIZE);\n\n\n\n    options = qdict_new();\n\n    ret = nfs_parse_uri(url, options, errp);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    ret = nfs_client_open(client, options, O_CREAT, errp, 0);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n    ret = nfs_ftruncate(client->context, client->fh, total_size);\n\n    nfs_client_close(client);\n\nout:\n\n\n    g_free(client);\n\n    return ret;\n\n}", "idx": 24064}
{"project": "qemu", "commit_id": "91a9ecefb6d7f066c6eecc09f7231ce7969d1817", "target": 1, "func": "int setenv(const char *name, const char *value, int overwrite)\n{\n    int result = 0;\n    if (overwrite || !getenv(name)) {\n        size_t length = strlen(name) + strlen(value) + 2;\n        char *string = g_malloc(length);\n        snprintf(string, length, \"%s=%s\", name, value);\n        result = putenv(string);\n    }\n    return result;\n}", "idx": 24065}
{"project": "qemu", "commit_id": "5706db1deb061ee9affdcea81e59c4c2cad7c41e", "target": 1, "func": "static int alsa_init_out (HWVoiceOut *hw, struct audsettings *as)\n\n{\n\n    ALSAVoiceOut *alsa = (ALSAVoiceOut *) hw;\n\n    struct alsa_params_req req;\n\n    struct alsa_params_obt obt;\n\n    snd_pcm_t *handle;\n\n    struct audsettings obt_as;\n\n\n\n    req.fmt = aud_to_alsafmt (as->fmt, as->endianness);\n\n    req.freq = as->freq;\n\n    req.nchannels = as->nchannels;\n\n    req.period_size = conf.period_size_out;\n\n    req.buffer_size = conf.buffer_size_out;\n\n    req.size_in_usec = conf.size_in_usec_out;\n\n    req.override_mask =\n\n        (conf.period_size_out_overridden ? 1 : 0) |\n\n        (conf.buffer_size_out_overridden ? 2 : 0);\n\n\n\n    if (alsa_open (0, &req, &obt, &handle)) {\n\n        return -1;\n\n    }\n\n\n\n    obt_as.freq = obt.freq;\n\n    obt_as.nchannels = obt.nchannels;\n\n    obt_as.fmt = obt.fmt;\n\n    obt_as.endianness = obt.endianness;\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n    hw->samples = obt.samples;\n\n\n\n    alsa->pcm_buf = audio_calloc (AUDIO_FUNC, obt.samples, 1 << hw->info.shift);\n\n    if (!alsa->pcm_buf) {\n\n        dolog (\"Could not allocate DAC buffer (%d samples, each %d bytes)\\n\",\n\n               hw->samples, 1 << hw->info.shift);\n\n        alsa_anal_close1 (&handle);\n\n        return -1;\n\n    }\n\n\n\n    alsa->handle = handle;\n\n    return 0;\n\n}\n", "idx": 24066}
{"project": "qemu", "commit_id": "77cb0f5aafc8e6d0c6d3c339f381c9b7921648e0", "target": 1, "func": "static void adb_kbd_reset(DeviceState *dev)\n\n{\n\n    ADBDevice *d = ADB_DEVICE(dev);\n\n    KBDState *s = ADB_KEYBOARD(dev);\n\n\n\n    d->handler = 1;\n\n    d->devaddr = ADB_DEVID_KEYBOARD;\n\n    memset(s->data, 0, sizeof(s->data));\n\n    s->rptr = 0;\n\n    s->wptr = 0;\n\n    s->count = 0;\n\n}\n", "idx": 24068}
{"project": "qemu", "commit_id": "f3ced3c59287dabc253f83f0c70aa4934470c15e", "target": 1, "func": "void tb_flush_jmp_cache(CPUState *cpu, target_ulong addr)\n\n{\n\n    unsigned int i;\n\n\n\n    /* Discard jump cache entries for any tb which might potentially\n\n       overlap the flushed page.  */\n\n    i = tb_jmp_cache_hash_page(addr - TARGET_PAGE_SIZE);\n\n    memset(&cpu->tb_jmp_cache[i], 0,\n\n           TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));\n\n\n\n    i = tb_jmp_cache_hash_page(addr);\n\n    memset(&cpu->tb_jmp_cache[i], 0,\n\n           TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));\n\n}\n", "idx": 24075}
{"project": "qemu", "commit_id": "3456a8d1852e970688b73d03fdc44dde851759e1", "target": 1, "func": "static void qcow2_invalidate_cache(BlockDriverState *bs)\n{\n    BDRVQcowState *s = bs->opaque;\n    int flags = s->flags;\n    AES_KEY aes_encrypt_key;\n    AES_KEY aes_decrypt_key;\n    uint32_t crypt_method = 0;\n    QDict *options;\n    /*\n     * Backing files are read-only which makes all of their metadata immutable,\n     * that means we don't have to worry about reopening them here.\n     */\n    if (s->crypt_method) {\n        crypt_method = s->crypt_method;\n        memcpy(&aes_encrypt_key, &s->aes_encrypt_key, sizeof(aes_encrypt_key));\n        memcpy(&aes_decrypt_key, &s->aes_decrypt_key, sizeof(aes_decrypt_key));\n    }\n    qcow2_close(bs);\n    options = qdict_new();\n    qdict_put(options, QCOW2_OPT_LAZY_REFCOUNTS,\n              qbool_from_int(s->use_lazy_refcounts));\n    memset(s, 0, sizeof(BDRVQcowState));\n    qcow2_open(bs, options, flags, NULL);\n    QDECREF(options);\n    if (crypt_method) {\n        s->crypt_method = crypt_method;\n        memcpy(&s->aes_encrypt_key, &aes_encrypt_key, sizeof(aes_encrypt_key));\n        memcpy(&s->aes_decrypt_key, &aes_decrypt_key, sizeof(aes_decrypt_key));\n    }\n}", "idx": 24078}
{"project": "qemu", "commit_id": "2886be1b01c274570fa139748a402207482405bd", "target": 1, "func": "void acpi_pm1_evt_write_sts(ACPIREGS *ar, uint16_t val)\n\n{\n\n    uint16_t pm1_sts = acpi_pm1_evt_get_sts(ar, ar->tmr.overflow_time);\n\n    if (pm1_sts & val & ACPI_BITMASK_TIMER_STATUS) {\n\n        /* if TMRSTS is reset, then compute the new overflow time */\n\n        acpi_pm_tmr_calc_overflow_time(ar);\n\n    }\n\n    ar->pm1.evt.sts &= ~val;\n\n}\n", "idx": 24080}
{"project": "qemu", "commit_id": "fa879d62eb51253d00b6920ce1d1d9d261370a49", "target": 0, "func": "DeviceState *bdrv_get_attached(BlockDriverState *bs)\n\n{\n\n    return bs->peer;\n\n}\n", "idx": 24084}
{"project": "qemu", "commit_id": "d9f62dde1303286b24ac8ce88be27e2b9b9c5f46", "target": 0, "func": "static void qapi_dealloc_push(QapiDeallocVisitor *qov, void *value)\n\n{\n\n    StackEntry *e = g_malloc0(sizeof(*e));\n\n\n\n    e->value = value;\n\n\n\n    /* see if we're just pushing a list head tracker */\n\n    if (value == NULL) {\n\n        e->is_list_head = true;\n\n    }\n\n    QTAILQ_INSERT_HEAD(&qov->stack, e, node);\n\n}\n", "idx": 24085}
{"project": "qemu", "commit_id": "1f3870ab242018b724b845957f7f928a2d7c1f5b", "target": 0, "func": "static int usb_host_update_interfaces(USBHostDevice *dev, int configuration)\n\n{\n\n    int dev_descr_len, config_descr_len;\n\n    int interface, nb_interfaces, nb_configurations;\n\n    int ret, i;\n\n\n\n    if (configuration == 0) /* address state - ignore */\n\n        return 1;\n\n\n\n    i = 0;\n\n    dev_descr_len = dev->descr[0];\n\n    if (dev_descr_len > dev->descr_len)\n\n        goto fail;\n\n    nb_configurations = dev->descr[17];\n\n\n\n    i += dev_descr_len;\n\n    while (i < dev->descr_len) {\n\n#ifdef DEBUG\n\n        printf(\"i is %d, descr_len is %d, dl %d, dt %d\\n\", i, dev->descr_len,\n\n               dev->descr[i], dev->descr[i+1]);\n\n#endif\n\n        if (dev->descr[i+1] != USB_DT_CONFIG) {\n\n            i += dev->descr[i];\n\n            continue;\n\n        }\n\n        config_descr_len = dev->descr[i];\n\n\n\n        if (configuration == dev->descr[i + 5])\n\n            break;\n\n\n\n        i += config_descr_len;\n\n    }\n\n\n\n    if (i >= dev->descr_len) {\n\n        printf(\"usb_host: error - device has no matching configuration\\n\");\n\n        goto fail;\n\n    }\n\n    nb_interfaces = dev->descr[i + 4];\n\n\n\n#ifdef USBDEVFS_DISCONNECT\n\n    /* earlier Linux 2.4 do not support that */\n\n    {\n\n        struct usbdevfs_ioctl ctrl;\n\n        for (interface = 0; interface < nb_interfaces; interface++) {\n\n            ctrl.ioctl_code = USBDEVFS_DISCONNECT;\n\n            ctrl.ifno = interface;\n\n            ret = ioctl(dev->fd, USBDEVFS_IOCTL, &ctrl);\n\n            if (ret < 0 && errno != ENODATA) {\n\n                perror(\"USBDEVFS_DISCONNECT\");\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n#endif\n\n\n\n    /* XXX: only grab if all interfaces are free */\n\n    for (interface = 0; interface < nb_interfaces; interface++) {\n\n        ret = ioctl(dev->fd, USBDEVFS_CLAIMINTERFACE, &interface);\n\n        if (ret < 0) {\n\n            if (errno == EBUSY) {\n\n                fprintf(stderr,\n\n                        \"usb_host: warning - device already grabbed\\n\");\n\n            } else {\n\n                perror(\"USBDEVFS_CLAIMINTERFACE\");\n\n            }\n\n        fail:\n\n            return 0;\n\n        }\n\n    }\n\n\n\n#ifdef DEBUG\n\n    printf(\"usb_host: %d interfaces claimed for configuration %d\\n\",\n\n           nb_interfaces, configuration);\n\n#endif\n\n\n\n    return 1;\n\n}\n", "idx": 24086}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "void *vnc_zlib_zalloc(void *x, unsigned items, unsigned size)\n\n{\n\n    void *p;\n\n\n\n    size *= items;\n\n    size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);\n\n\n\n    p = qemu_mallocz(size);\n\n\n\n    return (p);\n\n}\n", "idx": 24087}
{"project": "qemu", "commit_id": "237d78f8fc62e62f62246883ecf62e44ed35fb80", "target": 0, "func": "static int get_block_status(BlockDriverState *bs, int64_t offset,\n\n                            int64_t bytes, MapEntry *e)\n\n{\n\n    int64_t ret;\n\n    int depth;\n\n    BlockDriverState *file;\n\n    bool has_offset;\n\n    int nb_sectors = bytes >> BDRV_SECTOR_BITS;\n\n\n\n    assert(bytes < INT_MAX);\n\n    /* As an optimization, we could cache the current range of unallocated\n\n     * clusters in each file of the chain, and avoid querying the same\n\n     * range repeatedly.\n\n     */\n\n\n\n    depth = 0;\n\n    for (;;) {\n\n        ret = bdrv_get_block_status(bs, offset >> BDRV_SECTOR_BITS, nb_sectors,\n\n                                    &nb_sectors, &file);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        assert(nb_sectors);\n\n        if (ret & (BDRV_BLOCK_ZERO|BDRV_BLOCK_DATA)) {\n\n            break;\n\n        }\n\n        bs = backing_bs(bs);\n\n        if (bs == NULL) {\n\n            ret = 0;\n\n            break;\n\n        }\n\n\n\n        depth++;\n\n    }\n\n\n\n    has_offset = !!(ret & BDRV_BLOCK_OFFSET_VALID);\n\n\n\n    *e = (MapEntry) {\n\n        .start = offset,\n\n        .length = nb_sectors * BDRV_SECTOR_SIZE,\n\n        .data = !!(ret & BDRV_BLOCK_DATA),\n\n        .zero = !!(ret & BDRV_BLOCK_ZERO),\n\n        .offset = ret & BDRV_BLOCK_OFFSET_MASK,\n\n        .has_offset = has_offset,\n\n        .depth = depth,\n\n        .has_filename = file && has_offset,\n\n        .filename = file && has_offset ? file->filename : NULL,\n\n    };\n\n\n\n    return 0;\n\n}\n", "idx": 24088}
{"project": "qemu", "commit_id": "60dcbcb5b1a0d185be607b03fc7a15bf1bab4bec", "target": 0, "func": "static abi_ulong setup_arg_pages(abi_ulong p, struct linux_binprm *bprm,\n\n                                 struct image_info *info)\n\n{\n\n    abi_ulong stack_base, size, error;\n\n    int i;\n\n\n\n    /* Create enough stack to hold everything.  If we don't use\n\n     * it for args, we'll use it for something else...\n\n     */\n\n    size = guest_stack_size;\n\n    if (size < MAX_ARG_PAGES*TARGET_PAGE_SIZE)\n\n        size = MAX_ARG_PAGES*TARGET_PAGE_SIZE;\n\n    error = target_mmap(0,\n\n                        size + qemu_host_page_size,\n\n                        PROT_READ | PROT_WRITE,\n\n                        MAP_PRIVATE | MAP_ANONYMOUS,\n\n                        -1, 0);\n\n    if (error == -1) {\n\n        perror(\"stk mmap\");\n\n        exit(-1);\n\n    }\n\n    /* we reserve one extra page at the top of the stack as guard */\n\n    target_mprotect(error + size, qemu_host_page_size, PROT_NONE);\n\n\n\n    info->stack_limit = error;\n\n    stack_base = error + size - MAX_ARG_PAGES*TARGET_PAGE_SIZE;\n\n    p += stack_base;\n\n\n\n    for (i = 0 ; i < MAX_ARG_PAGES ; i++) {\n\n        if (bprm->page[i]) {\n\n            info->rss++;\n\n            /* FIXME - check return value of memcpy_to_target() for failure */\n\n            memcpy_to_target(stack_base, bprm->page[i], TARGET_PAGE_SIZE);\n\n            free(bprm->page[i]);\n\n        }\n\n        stack_base += TARGET_PAGE_SIZE;\n\n    }\n\n    return p;\n\n}\n", "idx": 24089}
{"project": "qemu", "commit_id": "bc210eb163b162ff2e94e5c8f4307715731257f8", "target": 0, "func": "static int send_png_rect(VncState *vs, int x, int y, int w, int h,\n\n                         VncPalette *palette)\n\n{\n\n    png_byte color_type;\n\n    png_structp png_ptr;\n\n    png_infop info_ptr;\n\n    png_colorp png_palette = NULL;\n\n    pixman_image_t *linebuf;\n\n    int level = tight_png_conf[vs->tight.compression].png_zlib_level;\n\n    int filters = tight_png_conf[vs->tight.compression].png_filters;\n\n    uint8_t *buf;\n\n    int dy;\n\n\n\n    png_ptr = png_create_write_struct_2(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL,\n\n                                        NULL, vnc_png_malloc, vnc_png_free);\n\n\n\n    if (png_ptr == NULL)\n\n        return -1;\n\n\n\n    info_ptr = png_create_info_struct(png_ptr);\n\n\n\n    if (info_ptr == NULL) {\n\n        png_destroy_write_struct(&png_ptr, NULL);\n\n        return -1;\n\n    }\n\n\n\n    png_set_write_fn(png_ptr, (void *) vs, png_write_data, png_flush_data);\n\n    png_set_compression_level(png_ptr, level);\n\n    png_set_filter(png_ptr, PNG_FILTER_TYPE_DEFAULT, filters);\n\n\n\n    if (palette) {\n\n        color_type = PNG_COLOR_TYPE_PALETTE;\n\n    } else {\n\n        color_type = PNG_COLOR_TYPE_RGB;\n\n    }\n\n\n\n    png_set_IHDR(png_ptr, info_ptr, w, h,\n\n                 8, color_type, PNG_INTERLACE_NONE,\n\n                 PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);\n\n\n\n    if (color_type == PNG_COLOR_TYPE_PALETTE) {\n\n        struct palette_cb_priv priv;\n\n\n\n        png_palette = png_malloc(png_ptr, sizeof(*png_palette) *\n\n                                 palette_size(palette));\n\n\n\n        priv.vs = vs;\n\n        priv.png_palette = png_palette;\n\n        palette_iter(palette, write_png_palette, &priv);\n\n\n\n        png_set_PLTE(png_ptr, info_ptr, png_palette, palette_size(palette));\n\n\n\n        if (vs->client_pf.bytes_per_pixel == 4) {\n\n            tight_encode_indexed_rect32(vs->tight.tight.buffer, w * h, palette);\n\n        } else {\n\n            tight_encode_indexed_rect16(vs->tight.tight.buffer, w * h, palette);\n\n        }\n\n    }\n\n\n\n    png_write_info(png_ptr, info_ptr);\n\n\n\n    buffer_reserve(&vs->tight.png, 2048);\n\n    linebuf = qemu_pixman_linebuf_create(PIXMAN_BE_r8g8b8, w);\n\n    buf = (uint8_t *)pixman_image_get_data(linebuf);\n\n    for (dy = 0; dy < h; dy++)\n\n    {\n\n        if (color_type == PNG_COLOR_TYPE_PALETTE) {\n\n            memcpy(buf, vs->tight.tight.buffer + (dy * w), w);\n\n        } else {\n\n            qemu_pixman_linebuf_fill(linebuf, vs->vd->server, w, dy);\n\n        }\n\n        png_write_row(png_ptr, buf);\n\n    }\n\n    qemu_pixman_image_unref(linebuf);\n\n\n\n    png_write_end(png_ptr, NULL);\n\n\n\n    if (color_type == PNG_COLOR_TYPE_PALETTE) {\n\n        png_free(png_ptr, png_palette);\n\n    }\n\n\n\n    png_destroy_write_struct(&png_ptr, &info_ptr);\n\n\n\n    vnc_write_u8(vs, VNC_TIGHT_PNG << 4);\n\n\n\n    tight_send_compact_size(vs, vs->tight.png.offset);\n\n    vnc_write(vs, vs->tight.png.buffer, vs->tight.png.offset);\n\n    buffer_reset(&vs->tight.png);\n\n    return 1;\n\n}\n", "idx": 24090}
{"project": "qemu", "commit_id": "dd321ecfc2e82e6f9578b986060b1aa3f036bd98", "target": 0, "func": "static void *colo_compare_thread(void *opaque)\n\n{\n\n    CompareState *s = opaque;\n\n    GSource *timeout_source;\n\n\n\n    s->worker_context = g_main_context_new();\n\n\n\n    qemu_chr_fe_set_handlers(&s->chr_pri_in, compare_chr_can_read,\n\n                             compare_pri_chr_in, NULL, NULL,\n\n                             s, s->worker_context, true);\n\n    qemu_chr_fe_set_handlers(&s->chr_sec_in, compare_chr_can_read,\n\n                             compare_sec_chr_in, NULL, NULL,\n\n                             s, s->worker_context, true);\n\n\n\n    s->compare_loop = g_main_loop_new(s->worker_context, FALSE);\n\n\n\n    /* To kick any packets that the secondary doesn't match */\n\n    timeout_source = g_timeout_source_new(REGULAR_PACKET_CHECK_MS);\n\n    g_source_set_callback(timeout_source,\n\n                          (GSourceFunc)check_old_packet_regular, s, NULL);\n\n    g_source_attach(timeout_source, s->worker_context);\n\n\n\n    g_main_loop_run(s->compare_loop);\n\n\n\n    g_source_unref(timeout_source);\n\n    g_main_loop_unref(s->compare_loop);\n\n    g_main_context_unref(s->worker_context);\n\n    return NULL;\n\n}\n", "idx": 24091}
{"project": "qemu", "commit_id": "b192af8acc597a6e8068873434e56e0c7de1b7d3", "target": 0, "func": "static int find_image_format(BlockDriverState *bs, const char *filename,\n\n                             BlockDriver **pdrv, Error **errp)\n\n{\n\n    BlockDriver *drv;\n\n    uint8_t buf[BLOCK_PROBE_BUF_SIZE];\n\n    int ret = 0;\n\n\n\n    /* Return the raw BlockDriver * to scsi-generic devices or empty drives */\n\n    if (bs->sg || !bdrv_is_inserted(bs) || bdrv_getlength(bs) == 0) {\n\n        *pdrv = &bdrv_raw;\n\n        return ret;\n\n    }\n\n\n\n    ret = bdrv_pread(bs, 0, buf, sizeof(buf));\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"Could not read image for determining its \"\n\n                         \"format\");\n\n        *pdrv = NULL;\n\n        return ret;\n\n    }\n\n\n\n    drv = bdrv_probe_all(buf, ret, filename);\n\n    if (!drv) {\n\n        error_setg(errp, \"Could not determine image format: No compatible \"\n\n                   \"driver found\");\n\n        ret = -ENOENT;\n\n    }\n\n    *pdrv = drv;\n\n    return ret;\n\n}\n", "idx": 24092}
{"project": "qemu", "commit_id": "af52fe862fba686713044efdf9158195f84535ab", "target": 0, "func": "static void uart_parameters_setup(UartState *s)\n\n{\n\n    QEMUSerialSetParams ssp;\n\n    unsigned int baud_rate, packet_size;\n\n\n\n    baud_rate = (s->r[R_MR] & UART_MR_CLKS) ?\n\n            UART_INPUT_CLK / 8 : UART_INPUT_CLK;\n\n\n\n    ssp.speed = baud_rate / (s->r[R_BRGR] * (s->r[R_BDIV] + 1));\n\n    packet_size = 1;\n\n\n\n    switch (s->r[R_MR] & UART_MR_PAR) {\n\n    case UART_PARITY_EVEN:\n\n        ssp.parity = 'E';\n\n        packet_size++;\n\n        break;\n\n    case UART_PARITY_ODD:\n\n        ssp.parity = 'O';\n\n        packet_size++;\n\n        break;\n\n    default:\n\n        ssp.parity = 'N';\n\n        break;\n\n    }\n\n\n\n    switch (s->r[R_MR] & UART_MR_CHRL) {\n\n    case UART_DATA_BITS_6:\n\n        ssp.data_bits = 6;\n\n        break;\n\n    case UART_DATA_BITS_7:\n\n        ssp.data_bits = 7;\n\n        break;\n\n    default:\n\n        ssp.data_bits = 8;\n\n        break;\n\n    }\n\n\n\n    switch (s->r[R_MR] & UART_MR_NBSTOP) {\n\n    case UART_STOP_BITS_1:\n\n        ssp.stop_bits = 1;\n\n        break;\n\n    default:\n\n        ssp.stop_bits = 2;\n\n        break;\n\n    }\n\n\n\n    packet_size += ssp.data_bits + ssp.stop_bits;\n\n    s->char_tx_time = (get_ticks_per_sec() / ssp.speed) * packet_size;\n\n    qemu_chr_fe_ioctl(s->chr, CHR_IOCTL_SERIAL_SET_PARAMS, &ssp);\n\n}\n", "idx": 24094}
{"project": "qemu", "commit_id": "9ef91a677110ec200d7b2904fc4bcae5a77329ad", "target": 0, "func": "static size_t handle_aiocb_rw_vector(struct qemu_paiocb *aiocb)\n\n{\n\n    size_t offset = 0;\n\n    ssize_t len;\n\n\n\n    do {\n\n        if (aiocb->aio_type == QEMU_PAIO_WRITE)\n\n            len = qemu_pwritev(aiocb->aio_fildes,\n\n                               aiocb->aio_iov,\n\n                               aiocb->aio_niov,\n\n                               aiocb->aio_offset + offset);\n\n         else\n\n            len = qemu_preadv(aiocb->aio_fildes,\n\n                              aiocb->aio_iov,\n\n                              aiocb->aio_niov,\n\n                              aiocb->aio_offset + offset);\n\n    } while (len == -1 && errno == EINTR);\n\n\n\n    if (len == -1)\n\n        return -errno;\n\n    return len;\n\n}\n", "idx": 24095}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "eth_read(void *opaque, target_phys_addr_t addr, unsigned int size)\n\n{\n\n\tstruct fs_eth *eth = opaque;\n\n\tuint32_t r = 0;\n\n\n\n\taddr >>= 2;\n\n\n\n\tswitch (addr) {\n\n\t\tcase R_STAT:\n\n\t\t\tr = eth->mdio_bus.mdio & 1;\n\n\t\t\tbreak;\n\n\tdefault:\n\n\t\tr = eth->regs[addr];\n\n\t\tD(printf (\"%s %x\\n\", __func__, addr * 4));\n\n\t\tbreak;\n\n\t}\n\n\treturn r;\n\n}\n", "idx": 24096}
{"project": "qemu", "commit_id": "be3512610bdeebfaa40c63ae15d19d9fae991e1b", "target": 0, "func": "int vnc_display_open(DisplayState *ds, const char *display)\n\n{\n\n    VncState *vs = ds ? (VncState *)ds->opaque : vnc_state;\n\n    const char *options;\n\n    int password = 0;\n\n    int reverse = 0;\n\n    int to_port = 0;\n\n#ifdef CONFIG_VNC_TLS\n\n    int tls = 0, x509 = 0;\n\n#endif\n\n\n\n    vnc_display_close(ds);\n\n    if (strcmp(display, \"none\") == 0)\n\n\treturn 0;\n\n\n\n    if (!(vs->display = strdup(display)))\n\n\treturn -1;\n\n\n\n    options = display;\n\n    while ((options = strchr(options, ','))) {\n\n\toptions++;\n\n\tif (strncmp(options, \"password\", 8) == 0) {\n\n\t    password = 1; /* Require password auth */\n\n\t} else if (strncmp(options, \"reverse\", 7) == 0) {\n\n\t    reverse = 1;\n\n\t} else if (strncmp(options, \"to=\", 3) == 0) {\n\n            to_port = atoi(options+3) + 5900;\n\n#ifdef CONFIG_VNC_TLS\n\n\t} else if (strncmp(options, \"tls\", 3) == 0) {\n\n\t    tls = 1; /* Require TLS */\n\n\t} else if (strncmp(options, \"x509\", 4) == 0) {\n\n\t    char *start, *end;\n\n\t    x509 = 1; /* Require x509 certificates */\n\n\t    if (strncmp(options, \"x509verify\", 10) == 0)\n\n\t        vs->x509verify = 1; /* ...and verify client certs */\n\n\n\n\t    /* Now check for 'x509=/some/path' postfix\n\n\t     * and use that to setup x509 certificate/key paths */\n\n\t    start = strchr(options, '=');\n\n\t    end = strchr(options, ',');\n\n\t    if (start && (!end || (start < end))) {\n\n\t\tint len = end ? end-(start+1) : strlen(start+1);\n\n\t\tchar *path = qemu_malloc(len+1);\n\n\n\n                pstrcpy(path, len, start + 1);\n\n\t\tpath[len] = '\\0';\n\n\t\tVNC_DEBUG(\"Trying certificate path '%s'\\n\", path);\n\n\t\tif (vnc_set_x509_credential_dir(vs, path) < 0) {\n\n\t\t    fprintf(stderr, \"Failed to find x509 certificates/keys in %s\\n\", path);\n\n\t\t    qemu_free(path);\n\n\t\t    qemu_free(vs->display);\n\n\t\t    vs->display = NULL;\n\n\t\t    return -1;\n\n\t\t}\n\n\t\tqemu_free(path);\n\n\t    } else {\n\n\t\tfprintf(stderr, \"No certificate path provided\\n\");\n\n\t\tqemu_free(vs->display);\n\n\t\tvs->display = NULL;\n\n\t\treturn -1;\n\n\t    }\n\n#endif\n\n\t}\n\n    }\n\n\n\n    if (password) {\n\n#ifdef CONFIG_VNC_TLS\n\n\tif (tls) {\n\n\t    vs->auth = VNC_AUTH_VENCRYPT;\n\n\t    if (x509) {\n\n\t\tVNC_DEBUG(\"Initializing VNC server with x509 password auth\\n\");\n\n\t\tvs->subauth = VNC_AUTH_VENCRYPT_X509VNC;\n\n\t    } else {\n\n\t\tVNC_DEBUG(\"Initializing VNC server with TLS password auth\\n\");\n\n\t\tvs->subauth = VNC_AUTH_VENCRYPT_TLSVNC;\n\n\t    }\n\n\t} else {\n\n#endif\n\n\t    VNC_DEBUG(\"Initializing VNC server with password auth\\n\");\n\n\t    vs->auth = VNC_AUTH_VNC;\n\n#ifdef CONFIG_VNC_TLS\n\n\t    vs->subauth = VNC_AUTH_INVALID;\n\n\t}\n\n#endif\n\n    } else {\n\n#ifdef CONFIG_VNC_TLS\n\n\tif (tls) {\n\n\t    vs->auth = VNC_AUTH_VENCRYPT;\n\n\t    if (x509) {\n\n\t\tVNC_DEBUG(\"Initializing VNC server with x509 no auth\\n\");\n\n\t\tvs->subauth = VNC_AUTH_VENCRYPT_X509NONE;\n\n\t    } else {\n\n\t\tVNC_DEBUG(\"Initializing VNC server with TLS no auth\\n\");\n\n\t\tvs->subauth = VNC_AUTH_VENCRYPT_TLSNONE;\n\n\t    }\n\n\t} else {\n\n#endif\n\n\t    VNC_DEBUG(\"Initializing VNC server with no auth\\n\");\n\n\t    vs->auth = VNC_AUTH_NONE;\n\n#ifdef CONFIG_VNC_TLS\n\n\t    vs->subauth = VNC_AUTH_INVALID;\n\n\t}\n\n#endif\n\n    }\n\n\n\n    if (reverse) {\n\n        /* connect to viewer */\n\n        if (strncmp(display, \"unix:\", 5) == 0)\n\n            vs->lsock = unix_connect(display+5);\n\n        else\n\n            vs->lsock = inet_connect(display, SOCK_STREAM);\n\n        if (-1 == vs->lsock) {\n\n            free(vs->display);\n\n            vs->display = NULL;\n\n            return -1;\n\n        } else {\n\n            vs->csock = vs->lsock;\n\n            vs->lsock = -1;\n\n            vnc_connect(vs);\n\n        }\n\n        return 0;\n\n\n\n    } else {\n\n        /* listen for connects */\n\n        char *dpy;\n\n        dpy = qemu_malloc(256);\n\n        if (strncmp(display, \"unix:\", 5) == 0) {\n\n            strcpy(dpy, \"unix:\");\n\n            vs->lsock = unix_listen(display, dpy+5, 256-5);\n\n        } else {\n\n            vs->lsock = inet_listen(display, dpy, 256, SOCK_STREAM, 5900);\n\n        }\n\n        if (-1 == vs->lsock) {\n\n            free(dpy);\n\n        } else {\n\n            free(vs->display);\n\n            vs->display = dpy;\n\n        }\n\n    }\n\n\n\n    return qemu_set_fd_handler2(vs->lsock, vnc_listen_poll, vnc_listen_read, NULL, vs);\n\n}\n", "idx": 24097}
{"project": "qemu", "commit_id": "10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b", "target": 0, "func": "static void nabm_writeb (void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    PCIAC97LinkState *d = opaque;\n\n    AC97LinkState *s = &d->ac97;\n\n    AC97BusMasterRegs *r = NULL;\n\n    uint32_t index = addr - s->base[1];\n\n    switch (index) {\n\n    case PI_LVI:\n\n    case PO_LVI:\n\n    case MC_LVI:\n\n        r = &s->bm_regs[GET_BM (index)];\n\n        if ((r->cr & CR_RPBM) && (r->sr & SR_DCH)) {\n\n            r->sr &= ~(SR_DCH | SR_CELV);\n\n            r->civ = r->piv;\n\n            r->piv = (r->piv + 1) % 32;\n\n            fetch_bd (s, r);\n\n        }\n\n        r->lvi = val % 32;\n\n        dolog (\"LVI[%d] <- %#x\\n\", GET_BM (index), val);\n\n        break;\n\n    case PI_CR:\n\n    case PO_CR:\n\n    case MC_CR:\n\n        r = &s->bm_regs[GET_BM (index)];\n\n        if (val & CR_RR) {\n\n            reset_bm_regs (s, r);\n\n        }\n\n        else {\n\n            r->cr = val & CR_VALID_MASK;\n\n            if (!(r->cr & CR_RPBM)) {\n\n                voice_set_active (s, r - s->bm_regs, 0);\n\n                r->sr |= SR_DCH;\n\n            }\n\n            else {\n\n                r->civ = r->piv;\n\n                r->piv = (r->piv + 1) % 32;\n\n                fetch_bd (s, r);\n\n                r->sr &= ~SR_DCH;\n\n                voice_set_active (s, r - s->bm_regs, 1);\n\n            }\n\n        }\n\n        dolog (\"CR[%d] <- %#x (cr %#x)\\n\", GET_BM (index), val, r->cr);\n\n        break;\n\n    case PI_SR:\n\n    case PO_SR:\n\n    case MC_SR:\n\n        r = &s->bm_regs[GET_BM (index)];\n\n        r->sr |= val & ~(SR_RO_MASK | SR_WCLEAR_MASK);\n\n        update_sr (s, r, r->sr & ~(val & SR_WCLEAR_MASK));\n\n        dolog (\"SR[%d] <- %#x (sr %#x)\\n\", GET_BM (index), val, r->sr);\n\n        break;\n\n    default:\n\n        dolog (\"U nabm writeb %#x <- %#x\\n\", addr, val);\n\n        break;\n\n    }\n\n}\n", "idx": 24098}
{"project": "qemu", "commit_id": "a8d411abac9347aadeac87687b8a3c9895ea0fd7", "target": 0, "func": "void helper_xssubqp(CPUPPCState *env, uint32_t opcode)\n\n{\n\n    ppc_vsr_t xt, xa, xb;\n\n    float_status tstat;\n\n\n\n    getVSR(rA(opcode) + 32, &xa, env);\n\n    getVSR(rB(opcode) + 32, &xb, env);\n\n    getVSR(rD(opcode) + 32, &xt, env);\n\n    helper_reset_fpstatus(env);\n\n\n\n    if (unlikely(Rc(opcode) != 0)) {\n\n        /* TODO: Support xssubqp after round-to-odd is implemented */\n\n        abort();\n\n    }\n\n\n\n    tstat = env->fp_status;\n\n    set_float_exception_flags(0, &tstat);\n\n    xt.f128 = float128_sub(xa.f128, xb.f128, &tstat);\n\n    env->fp_status.float_exception_flags |= tstat.float_exception_flags;\n\n\n\n    if (unlikely(tstat.float_exception_flags & float_flag_invalid)) {\n\n        if (float128_is_infinity(xa.f128) && float128_is_infinity(xb.f128)) {\n\n            float_invalid_op_excp(env, POWERPC_EXCP_FP_VXISI, 1);\n\n        } else if (float128_is_signaling_nan(xa.f128, &tstat) ||\n\n                   float128_is_signaling_nan(xb.f128, &tstat)) {\n\n            float_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN, 1);\n\n        }\n\n    }\n\n\n\n    helper_compute_fprf_float128(env, xt.f128);\n\n    putVSR(rD(opcode) + 32, &xt, env);\n\n    float_check_status(env);\n\n}\n", "idx": 24099}
{"project": "qemu", "commit_id": "35c5a52d1d016c632aed6137549754ca53446c92", "target": 0, "func": "void nvdimm_init_acpi_state(AcpiNVDIMMState *state, MemoryRegion *io,\n\n                            FWCfgState *fw_cfg, Object *owner)\n\n{\n\n    memory_region_init_io(&state->io_mr, owner, &nvdimm_dsm_ops, state,\n\n                          \"nvdimm-acpi-io\", NVDIMM_ACPI_IO_LEN);\n\n    memory_region_add_subregion(io, NVDIMM_ACPI_IO_BASE, &state->io_mr);\n\n\n\n    state->dsm_mem = g_array_new(false, true /* clear */, 1);\n\n    acpi_data_push(state->dsm_mem, TARGET_PAGE_SIZE);\n\n    fw_cfg_add_file(fw_cfg, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data,\n\n                    state->dsm_mem->len);\n\n}\n", "idx": 24100}
{"project": "qemu", "commit_id": "560e63965232e37d1916a447125cf91c18a96930", "target": 0, "func": "void acpi_pm1_cnt_init(ACPIREGS *ar, MemoryRegion *parent)\n\n{\n\n    ar->wakeup.notify = acpi_notify_wakeup;\n\n    qemu_register_wakeup_notifier(&ar->wakeup);\n\n    memory_region_init_io(&ar->pm1.cnt.io, &acpi_pm_cnt_ops, ar, \"acpi-cnt\", 2);\n\n    memory_region_add_subregion(parent, 4, &ar->pm1.cnt.io);\n\n}\n", "idx": 24101}
{"project": "qemu", "commit_id": "f5793fd9e1fd89808f4adbfe690235b094176a37", "target": 0, "func": "static void vfio_probe_nvidia_bar0_quirk(VFIOPCIDevice *vdev, int nr)\n\n{\n\n    VFIOQuirk *quirk;\n\n    VFIOConfigMirrorQuirk *mirror;\n\n\n\n    if (!vfio_pci_is(vdev, PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID) ||\n\n        !vfio_is_vga(vdev) || nr != 0) {\n\n        return;\n\n    }\n\n\n\n    quirk = g_malloc0(sizeof(*quirk));\n\n    mirror = quirk->data = g_malloc0(sizeof(*mirror));\n\n    mirror->mem = quirk->mem = g_new0(MemoryRegion, 1);\n\n    quirk->nr_mem = 1;\n\n    mirror->vdev = vdev;\n\n    mirror->offset = 0x88000;\n\n    mirror->bar = nr;\n\n\n\n    memory_region_init_io(mirror->mem, OBJECT(vdev),\n\n                          &vfio_nvidia_mirror_quirk, mirror,\n\n                          \"vfio-nvidia-bar0-88000-mirror-quirk\",\n\n                          PCIE_CONFIG_SPACE_SIZE);\n\n    memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,\n\n                                        mirror->offset, mirror->mem, 1);\n\n\n\n    QLIST_INSERT_HEAD(&vdev->bars[nr].quirks, quirk, next);\n\n\n\n    /* The 0x1800 offset mirror only seems to get used by legacy VGA */\n\n    if (vdev->has_vga) {\n\n        quirk = g_malloc0(sizeof(*quirk));\n\n        mirror = quirk->data = g_malloc0(sizeof(*mirror));\n\n        mirror->mem = quirk->mem = g_new0(MemoryRegion, 1);\n\n        quirk->nr_mem = 1;\n\n        mirror->vdev = vdev;\n\n        mirror->offset = 0x1800;\n\n        mirror->bar = nr;\n\n\n\n        memory_region_init_io(mirror->mem, OBJECT(vdev),\n\n                              &vfio_nvidia_mirror_quirk, mirror,\n\n                              \"vfio-nvidia-bar0-1800-mirror-quirk\",\n\n                              PCI_CONFIG_SPACE_SIZE);\n\n        memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,\n\n                                            mirror->offset, mirror->mem, 1);\n\n\n\n        QLIST_INSERT_HEAD(&vdev->bars[nr].quirks, quirk, next);\n\n    }\n\n\n\n    trace_vfio_quirk_nvidia_bar0_probe(vdev->vbasedev.name);\n\n}\n", "idx": 24102}
{"project": "qemu", "commit_id": "8a5bb1f114c5959cf6b247a737394afb0c518b40", "target": 0, "func": "static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n\n                               BdrvCheckMode fix, bool *rebuild,\n\n                               void **refcount_table, int64_t *nb_clusters)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int64_t i;\n\n    QCowSnapshot *sn;\n\n    int ret;\n\n\n\n    if (!*refcount_table) {\n\n        int64_t old_size = 0;\n\n        ret = realloc_refcount_array(s, refcount_table,\n\n                                     &old_size, *nb_clusters);\n\n        if (ret < 0) {\n\n            res->check_errors++;\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* header */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        0, s->cluster_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* current L1 table */\n\n    ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* snapshots */\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                                 sn->l1_table_offset, sn->l1_size, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->snapshots_offset, s->snapshots_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* refcount data */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->refcount_table_offset,\n\n                        s->refcount_table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* encryption */\n\n    if (s->crypto_header.length) {\n\n        ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                            s->crypto_header.offset,\n\n                            s->crypto_header.length);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    return check_refblocks(bs, res, fix, rebuild, refcount_table, nb_clusters);\n\n}\n", "idx": 24103}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static int v9fs_synth_symlink(FsContext *fs_ctx, const char *oldpath,\n\n                              V9fsPath *newpath, const char *buf, FsCred *credp)\n\n{\n\n    errno = EPERM;\n\n    return -1;\n\n}\n", "idx": 24105}
{"project": "qemu", "commit_id": "8eca6b1bc770982595db2f7207c65051572436cb", "target": 0, "func": "static uint32_t virtio_ioport_read(void *opaque, uint32_t addr)\n\n{\n\n    VirtIODevice *vdev = to_virtio_device(opaque);\n\n    uint32_t ret = 0xFFFFFFFF;\n\n\n\n    addr -= vdev->addr;\n\n\n\n    switch (addr) {\n\n    case VIRTIO_PCI_HOST_FEATURES:\n\n        ret = vdev->get_features(vdev);\n\n        ret |= (1 << VIRTIO_F_NOTIFY_ON_EMPTY);\n\n        break;\n\n    case VIRTIO_PCI_GUEST_FEATURES:\n\n        ret = vdev->features;\n\n        break;\n\n    case VIRTIO_PCI_QUEUE_PFN:\n\n        ret = vdev->vq[vdev->queue_sel].pfn;\n\n        break;\n\n    case VIRTIO_PCI_QUEUE_NUM:\n\n        ret = vdev->vq[vdev->queue_sel].vring.num;\n\n        break;\n\n    case VIRTIO_PCI_QUEUE_SEL:\n\n        ret = vdev->queue_sel;\n\n        break;\n\n    case VIRTIO_PCI_STATUS:\n\n        ret = vdev->status;\n\n        break;\n\n    case VIRTIO_PCI_ISR:\n\n        /* reading from the ISR also clears it. */\n\n        ret = vdev->isr;\n\n        vdev->isr = 0;\n\n        virtio_update_irq(vdev);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 24106}
{"project": "qemu", "commit_id": "e305a16510afa74eec20390479e349402e55ef4c", "target": 1, "func": "static void sb16_realizefn (DeviceState *dev, Error **errp)\n\n{\n\n    ISADevice *isadev = ISA_DEVICE (dev);\n\n    SB16State *s = SB16 (dev);\n\n    IsaDmaClass *k;\n\n\n\n    isa_init_irq (isadev, &s->pic, s->irq);\n\n\n\n    s->mixer_regs[0x80] = magic_of_irq (s->irq);\n\n    s->mixer_regs[0x81] = (1 << s->dma) | (1 << s->hdma);\n\n    s->mixer_regs[0x82] = 2 << 5;\n\n\n\n    s->csp_regs[5] = 1;\n\n    s->csp_regs[9] = 0xf8;\n\n\n\n    reset_mixer (s);\n\n    s->aux_ts = timer_new_ns(QEMU_CLOCK_VIRTUAL, aux_timer, s);\n\n    if (!s->aux_ts) {\n\n        dolog (\"warning: Could not create auxiliary timer\\n\");\n\n    }\n\n\n\n    isa_register_portio_list (isadev, s->port, sb16_ioport_list, s, \"sb16\");\n\n\n\n    s->isa_hdma = isa_get_dma(isa_bus_from_device(isadev), s->hdma);\n\n    k = ISADMA_GET_CLASS(s->isa_hdma);\n\n    k->register_channel(s->isa_hdma, s->hdma, SB_read_DMA, s);\n\n\n\n    s->isa_dma = isa_get_dma(isa_bus_from_device(isadev), s->dma);\n\n    k = ISADMA_GET_CLASS(s->isa_dma);\n\n    k->register_channel(s->isa_dma, s->dma, SB_read_DMA, s);\n\n\n\n    s->can_write = 1;\n\n\n\n    AUD_register_card (\"sb16\", &s->card);\n\n}\n", "idx": 24107}
{"project": "qemu", "commit_id": "0e1cd6576c55269b6e5251dc739a7fc819f9b4a6", "target": 1, "func": "static int slavio_misc_init1(SysBusDevice *sbd)\n\n{\n\n    DeviceState *dev = DEVICE(sbd);\n\n    MiscState *s = SLAVIO_MISC(dev);\n\n\n\n    sysbus_init_irq(sbd, &s->irq);\n\n    sysbus_init_irq(sbd, &s->fdc_tc);\n\n\n\n    /* 8 bit registers */\n\n    /* Slavio control */\n\n    memory_region_init_io(&s->cfg_iomem, OBJECT(s), &slavio_cfg_mem_ops, s,\n\n                          \"configuration\", MISC_SIZE);\n\n    sysbus_init_mmio(sbd, &s->cfg_iomem);\n\n\n\n    /* Diagnostics */\n\n    memory_region_init_io(&s->diag_iomem, OBJECT(s), &slavio_diag_mem_ops, s,\n\n                          \"diagnostic\", MISC_SIZE);\n\n    sysbus_init_mmio(sbd, &s->diag_iomem);\n\n\n\n    /* Modem control */\n\n    memory_region_init_io(&s->mdm_iomem, OBJECT(s), &slavio_mdm_mem_ops, s,\n\n                          \"modem\", MISC_SIZE);\n\n    sysbus_init_mmio(sbd, &s->mdm_iomem);\n\n\n\n    /* 16 bit registers */\n\n    /* ss600mp diag LEDs */\n\n    memory_region_init_io(&s->led_iomem, OBJECT(s), &slavio_led_mem_ops, s,\n\n                          \"leds\", MISC_SIZE);\n\n    sysbus_init_mmio(sbd, &s->led_iomem);\n\n\n\n    /* 32 bit registers */\n\n    /* System control */\n\n    memory_region_init_io(&s->sysctrl_iomem, OBJECT(s), &slavio_sysctrl_mem_ops, s,\n\n                          \"system-control\", MISC_SIZE);\n\n    sysbus_init_mmio(sbd, &s->sysctrl_iomem);\n\n\n\n    /* AUX 1 (Misc System Functions) */\n\n    memory_region_init_io(&s->aux1_iomem, OBJECT(s), &slavio_aux1_mem_ops, s,\n\n                          \"misc-system-functions\", MISC_SIZE);\n\n    sysbus_init_mmio(sbd, &s->aux1_iomem);\n\n\n\n    /* AUX 2 (Software Powerdown Control) */\n\n    memory_region_init_io(&s->aux2_iomem, OBJECT(s), &slavio_aux2_mem_ops, s,\n\n                          \"software-powerdown-control\", MISC_SIZE);\n\n    sysbus_init_mmio(sbd, &s->aux2_iomem);\n\n\n\n    qdev_init_gpio_in(dev, slavio_set_power_fail, 1);\n\n\n\n    return 0;\n\n}\n", "idx": 24108}
{"project": "qemu", "commit_id": "cc1e13913916f755fd2dc5041b8d4bf25d3ea88e", "target": 1, "func": "static QIOChannelSocket *nbd_establish_connection(SocketAddress *saddr,\n\n                                                  Error **errp)\n\n{\n\n    QIOChannelSocket *sioc;\n\n    Error *local_err = NULL;\n\n\n\n    sioc = qio_channel_socket_new();\n\n    qio_channel_set_name(QIO_CHANNEL(sioc), \"nbd-client\");\n\n\n\n    qio_channel_socket_connect_sync(sioc,\n\n                                    saddr,\n\n                                    &local_err);\n\n    if (local_err) {\n\n\n        error_propagate(errp, local_err);\n\n        return NULL;\n\n    }\n\n\n\n    qio_channel_set_delay(QIO_CHANNEL(sioc), false);\n\n\n\n    return sioc;\n\n}", "idx": 24109}
{"project": "qemu", "commit_id": "27bfd83c336283d1f7a5345ee386c4cd7b80db61", "target": 1, "func": "static inline int tcg_temp_new_internal(TCGType type, int temp_local)\n{\n    TCGContext *s = &tcg_ctx;\n    TCGTemp *ts;\n    int idx, k;\n    k = type;\n    if (temp_local)\n        k += TCG_TYPE_COUNT;\n    idx = s->first_free_temp[k];\n    if (idx != -1) {\n        /* There is already an available temp with the\n           right type */\n        ts = &s->temps[idx];\n        s->first_free_temp[k] = ts->next_free_temp;\n        ts->temp_allocated = 1;\n        assert(ts->temp_local == temp_local);\n    } else {\n        idx = s->nb_temps;\n#if TCG_TARGET_REG_BITS == 32\n        if (type == TCG_TYPE_I64) {\n            tcg_temp_alloc(s, s->nb_temps + 2);\n            ts = &s->temps[s->nb_temps];\n            ts->base_type = type;\n            ts->type = TCG_TYPE_I32;\n            ts->temp_allocated = 1;\n            ts->temp_local = temp_local;\n            ts->name = NULL;\n            ts++;\n            ts->base_type = TCG_TYPE_I32;\n            ts->type = TCG_TYPE_I32;\n            ts->temp_allocated = 1;\n            ts->temp_local = temp_local;\n            ts->name = NULL;\n            s->nb_temps += 2;\n        } else\n        {\n            tcg_temp_alloc(s, s->nb_temps + 1);\n            ts = &s->temps[s->nb_temps];\n            ts->base_type = type;\n            ts->type = type;\n            ts->temp_allocated = 1;\n            ts->temp_local = temp_local;\n            ts->name = NULL;\n            s->nb_temps++;\n        }\n    }\n    return idx;\n}", "idx": 24113}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "static VncClientInfo *qmp_query_vnc_client(const VncState *client)\n\n{\n\n    struct sockaddr_storage sa;\n\n    socklen_t salen = sizeof(sa);\n\n    char host[NI_MAXHOST];\n\n    char serv[NI_MAXSERV];\n\n    VncClientInfo *info;\n\n\n\n    if (getpeername(client->csock, (struct sockaddr *)&sa, &salen) < 0) {\n\n        return NULL;\n\n    }\n\n\n\n    if (getnameinfo((struct sockaddr *)&sa, salen,\n\n                    host, sizeof(host),\n\n                    serv, sizeof(serv),\n\n                    NI_NUMERICHOST | NI_NUMERICSERV) < 0) {\n\n        return NULL;\n\n    }\n\n\n\n    info = g_malloc0(sizeof(*info));\n\n    info->base = g_malloc0(sizeof(*info->base));\n\n    info->base->host = g_strdup(host);\n\n    info->base->service = g_strdup(serv);\n\n    info->base->family = inet_netfamily(sa.ss_family);\n\n    info->base->websocket = client->websocket;\n\n\n\n#ifdef CONFIG_VNC_TLS\n\n    if (client->tls.session && client->tls.dname) {\n\n        info->has_x509_dname = true;\n\n        info->x509_dname = g_strdup(client->tls.dname);\n\n    }\n\n#endif\n\n#ifdef CONFIG_VNC_SASL\n\n    if (client->sasl.conn && client->sasl.username) {\n\n        info->has_sasl_username = true;\n\n        info->sasl_username = g_strdup(client->sasl.username);\n\n    }\n\n#endif\n\n\n\n    return info;\n\n}\n", "idx": 24114}
{"project": "qemu", "commit_id": "ea375f9ab8c76686dca0af8cb4f87a4eb569cad3", "target": 1, "func": "int kvm_arch_put_registers(CPUState *env)\n\n{\n\n    struct kvm_regs regs;\n\n    int ret;\n\n    int i;\n\n\n\n    ret = kvm_vcpu_ioctl(env, KVM_GET_REGS, &regs);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    regs.ctr = env->ctr;\n\n    regs.lr  = env->lr;\n\n    regs.xer = env->xer;\n\n    regs.msr = env->msr;\n\n    regs.pc = env->nip;\n\n\n\n    regs.srr0 = env->spr[SPR_SRR0];\n\n    regs.srr1 = env->spr[SPR_SRR1];\n\n\n\n    regs.sprg0 = env->spr[SPR_SPRG0];\n\n    regs.sprg1 = env->spr[SPR_SPRG1];\n\n    regs.sprg2 = env->spr[SPR_SPRG2];\n\n    regs.sprg3 = env->spr[SPR_SPRG3];\n\n    regs.sprg4 = env->spr[SPR_SPRG4];\n\n    regs.sprg5 = env->spr[SPR_SPRG5];\n\n    regs.sprg6 = env->spr[SPR_SPRG6];\n\n    regs.sprg7 = env->spr[SPR_SPRG7];\n\n\n\n    for (i = 0;i < 32; i++)\n\n        regs.gpr[i] = env->gpr[i];\n\n\n\n    ret = kvm_vcpu_ioctl(env, KVM_SET_REGS, &regs);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    return ret;\n\n}\n", "idx": 24117}
{"project": "qemu", "commit_id": "2d528d45ecf5ee3c1a566a9f3d664464925ef830", "target": 1, "func": "static CharDriverState *qemu_chr_open_win_path(const char *filename)\n\n{\n\n    CharDriverState *chr;\n\n    WinCharState *s;\n\n\n\n    chr = qemu_chr_alloc();\n\n    s = g_malloc0(sizeof(WinCharState));\n\n    chr->opaque = s;\n\n    chr->chr_write = win_chr_write;\n\n    chr->chr_close = win_chr_close;\n\n\n\n    if (win_chr_init(chr, filename) < 0) {\n\n        g_free(s);\n\n        g_free(chr);\n\n        return NULL;\n\n    }\n\n    return chr;\n\n}\n", "idx": 24118}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void shix_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    int ret;\n\n    SuperHCPU *cpu;\n\n    struct SH7750State *s;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *rom = g_new(MemoryRegion, 1);\n\n    MemoryRegion *sdram = g_new(MemoryRegion, 2);\n\n    \n\n    if (!cpu_model)\n\n        cpu_model = \"any\";\n\n\n\n    cpu = SUPERH_CPU(cpu_generic_init(TYPE_SUPERH_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Allocate memory space */\n\n    memory_region_init_ram(rom, NULL, \"shix.rom\", 0x4000, &error_fatal);\n\n    memory_region_set_readonly(rom, true);\n\n    memory_region_add_subregion(sysmem, 0x00000000, rom);\n\n    memory_region_init_ram(&sdram[0], NULL, \"shix.sdram1\", 0x01000000,\n\n                           &error_fatal);\n\n    memory_region_add_subregion(sysmem, 0x08000000, &sdram[0]);\n\n    memory_region_init_ram(&sdram[1], NULL, \"shix.sdram2\", 0x01000000,\n\n                           &error_fatal);\n\n    memory_region_add_subregion(sysmem, 0x0c000000, &sdram[1]);\n\n\n\n    /* Load BIOS in 0 (and access it through P2, 0xA0000000) */\n\n    if (bios_name == NULL)\n\n        bios_name = BIOS_FILENAME;\n\n    ret = load_image_targphys(bios_name, 0, 0x4000);\n\n    if (ret < 0 && !qtest_enabled()) {\n\n        error_report(\"Could not load SHIX bios '%s'\", bios_name);\n\n        exit(1);\n\n    }\n\n\n\n    /* Register peripherals */\n\n    s = sh7750_init(cpu, sysmem);\n\n    /* XXXXX Check success */\n\n    tc58128_init(s, \"shix_linux_nand.bin\", NULL);\n\n}\n", "idx": 24121}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "static inline void gen_addr_imm_index (DisasContext *ctx)\n\n{\n\n    target_long simm = SIMM(ctx->opcode);\n\n\n\n    if (rA(ctx->opcode) == 0) {\n\n        gen_op_set_T0(simm);\n\n    } else {\n\n        gen_op_load_gpr_T0(rA(ctx->opcode));\n\n        if (likely(simm != 0))\n\n            gen_op_addi(simm);\n\n    }\n\n}\n", "idx": 24122}
{"project": "qemu", "commit_id": "025b168ca674e42896c573fdbddf3090c6dc0d8f", "target": 1, "func": "static void ehci_trace_qtd(EHCIQueue *q, target_phys_addr_t addr, EHCIqtd *qtd)\n\n{\n\n    trace_usb_ehci_qtd(q, addr, qtd->next, qtd->altnext,\n\n                       get_field(qtd->token, QTD_TOKEN_TBYTES),\n\n                       get_field(qtd->token, QTD_TOKEN_CPAGE),\n\n                       get_field(qtd->token, QTD_TOKEN_CERR),\n\n                       get_field(qtd->token, QTD_TOKEN_PID),\n\n                       (bool)(qtd->token & QTD_TOKEN_IOC),\n\n                       (bool)(qtd->token & QTD_TOKEN_ACTIVE),\n\n                       (bool)(qtd->token & QTD_TOKEN_HALT),\n\n                       (bool)(qtd->token & QTD_TOKEN_BABBLE),\n\n                       (bool)(qtd->token & QTD_TOKEN_XACTERR));\n\n}\n", "idx": 24123}
{"project": "qemu", "commit_id": "f3a06403b82c7f036564e4caf18b52ce6885fcfb", "target": 1, "func": "void qmp_guest_suspend_ram(Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    GuestSuspendMode *mode = g_malloc(sizeof(GuestSuspendMode));\n\n\n\n    *mode = GUEST_SUSPEND_MODE_RAM;\n\n    check_suspend_mode(*mode, &local_err);\n\n    acquire_privilege(SE_SHUTDOWN_NAME, &local_err);\n\n    execute_async(do_suspend, mode, &local_err);\n\n\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        g_free(mode);\n\n    }\n\n}\n", "idx": 24124}
{"project": "qemu", "commit_id": "b946a1533209f61a93e34898aebb5b43154b99c3", "target": 1, "func": "void lance_init(NICInfo *nd, target_phys_addr_t leaddr, void *dma_opaque,\n\n                qemu_irq irq, qemu_irq *reset)\n\n{\n\n    PCNetState *d;\n\n    int lance_io_memory;\n\n\n\n    qemu_check_nic_model(nd, \"lance\");\n\n\n\n    d = qemu_mallocz(sizeof(PCNetState));\n\n\n\n    lance_io_memory =\n\n        cpu_register_io_memory(0, lance_mem_read, lance_mem_write, d);\n\n\n\n    d->dma_opaque = dma_opaque;\n\n\n\n    *reset = *qemu_allocate_irqs(parent_lance_reset, d, 1);\n\n\n\n    cpu_register_physical_memory(leaddr, 4, lance_io_memory);\n\n\n\n    d->irq = irq;\n\n    d->phys_mem_read = ledma_memory_read;\n\n    d->phys_mem_write = ledma_memory_write;\n\n\n\n    pcnet_common_init(d, nd);\n\n}\n", "idx": 24126}
{"project": "qemu", "commit_id": "7372c2b926200db295412efbb53f93773b7f1754", "target": 1, "func": "static inline TCGv gen_load(DisasContext * s, int opsize, TCGv addr, int sign)\n\n{\n\n    TCGv tmp;\n\n    int index = IS_USER(s);\n\n    s->is_mem = 1;\n\n    tmp = tcg_temp_new_i32();\n\n    switch(opsize) {\n\n    case OS_BYTE:\n\n        if (sign)\n\n            tcg_gen_qemu_ld8s(tmp, addr, index);\n\n        else\n\n            tcg_gen_qemu_ld8u(tmp, addr, index);\n\n        break;\n\n    case OS_WORD:\n\n        if (sign)\n\n            tcg_gen_qemu_ld16s(tmp, addr, index);\n\n        else\n\n            tcg_gen_qemu_ld16u(tmp, addr, index);\n\n        break;\n\n    case OS_LONG:\n\n    case OS_SINGLE:\n\n        tcg_gen_qemu_ld32u(tmp, addr, index);\n\n        break;\n\n    default:\n\n        qemu_assert(0, \"bad load size\");\n\n    }\n\n    gen_throws_exception = gen_last_qop;\n\n    return tmp;\n\n}\n", "idx": 24127}
{"project": "qemu", "commit_id": "2034e324dabc55064553aaa07de1536ebf8ea497", "target": 1, "func": "static int virtio_scsi_parse_req(VirtIOSCSIReq *req,\n\n                                 unsigned req_size, unsigned resp_size)\n\n{\n\n    VirtIODevice *vdev = (VirtIODevice *) req->dev;\n\n    size_t in_size, out_size;\n\n\n\n    if (iov_to_buf(req->elem.out_sg, req->elem.out_num, 0,\n\n                   &req->req, req_size) < req_size) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (qemu_iovec_concat_iov(&req->resp_iov,\n\n                              req->elem.in_sg, req->elem.in_num, 0,\n\n                              resp_size) < resp_size) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    req->resp_size = resp_size;\n\n\n\n    /* Old BIOSes left some padding by mistake after the req_size/resp_size.\n\n     * As a workaround, always consider the first buffer as the virtio-scsi\n\n     * request/response, making the payload start at the second element\n\n     * of the iovec.\n\n     *\n\n     * The actual length of the response header, stored in req->resp_size,\n\n     * does not change.\n\n     *\n\n     * TODO: always disable this workaround for virtio 1.0 devices.\n\n     */\n\n    if (!virtio_has_feature(vdev, VIRTIO_F_ANY_LAYOUT)) {\n\n        req_size = req->elem.out_sg[0].iov_len;\n\n        resp_size = req->elem.in_sg[0].iov_len;\n\n    }\n\n\n\n    out_size = qemu_sgl_concat(req, req->elem.out_sg,\n\n                               &req->elem.out_addr[0], req->elem.out_num,\n\n                               req_size);\n\n    in_size = qemu_sgl_concat(req, req->elem.in_sg,\n\n                              &req->elem.in_addr[0], req->elem.in_num,\n\n                              resp_size);\n\n\n\n    if (out_size && in_size) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    if (out_size) {\n\n        req->mode = SCSI_XFER_TO_DEV;\n\n    } else if (in_size) {\n\n        req->mode = SCSI_XFER_FROM_DEV;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24131}
{"project": "qemu", "commit_id": "52c050236eaa4f0b5e1d160cd66dc18106445c4d", "target": 1, "func": "static void virtio_blk_handle_read(VirtIOBlockReq *req)\n\n{\n\n    BlockDriverAIOCB *acb;\n\n    uint64_t sector;\n\n\n\n    sector = ldq_p(&req->out->sector);\n\n\n\n    if (sector & req->dev->sector_mask) {\n\n\n\n\n\n\n\n\n\n\n    acb = bdrv_aio_readv(req->dev->bs, sector, &req->qiov,\n\n                         req->qiov.size / BDRV_SECTOR_SIZE,\n\n                         virtio_blk_rw_complete, req);\n\n    if (!acb) {\n\n\n", "idx": 24133}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static void pc_init1(ram_addr_t ram_size,\n\n                     const char *boot_device,\n\n                     const char *kernel_filename,\n\n                     const char *kernel_cmdline,\n\n                     const char *initrd_filename,\n\n                     const char *cpu_model,\n\n                     int pci_enabled)\n\n{\n\n    char *filename;\n\n    int ret, linux_boot, i;\n\n    ram_addr_t ram_addr, bios_offset, option_rom_offset;\n\n    ram_addr_t below_4g_mem_size, above_4g_mem_size = 0;\n\n    int bios_size, isa_bios_size;\n\n    PCIBus *pci_bus;\n\n    ISADevice *isa_dev;\n\n    int piix3_devfn = -1;\n\n    CPUState *env;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq *isa_irq;\n\n    qemu_irq *i8259;\n\n    IsaIrqState *isa_irq_state;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    DriveInfo *fd[MAX_FD];\n\n    int using_vga = cirrus_vga_enabled || std_vga_enabled || vmsvga_enabled;\n\n    void *fw_cfg;\n\n\n\n    if (ram_size >= 0xe0000000 ) {\n\n        above_4g_mem_size = ram_size - 0xe0000000;\n\n        below_4g_mem_size = 0xe0000000;\n\n    } else {\n\n        below_4g_mem_size = ram_size;\n\n    }\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n#ifdef TARGET_X86_64\n\n        cpu_model = \"qemu64\";\n\n#else\n\n        cpu_model = \"qemu32\";\n\n#endif\n\n    }\n\n\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        env = pc_new_cpu(cpu_model);\n\n    }\n\n\n\n    vmport_init();\n\n\n\n    /* allocate RAM */\n\n    ram_addr = qemu_ram_alloc(0xa0000);\n\n    cpu_register_physical_memory(0, 0xa0000, ram_addr);\n\n\n\n    /* Allocate, even though we won't register, so we don't break the\n\n     * phys_ram_base + PA assumption. This range includes vga (0xa0000 - 0xc0000),\n\n     * and some bios areas, which will be registered later\n\n     */\n\n    ram_addr = qemu_ram_alloc(0x100000 - 0xa0000);\n\n    ram_addr = qemu_ram_alloc(below_4g_mem_size - 0x100000);\n\n    cpu_register_physical_memory(0x100000,\n\n                 below_4g_mem_size - 0x100000,\n\n                 ram_addr);\n\n\n\n    /* above 4giga memory allocation */\n\n    if (above_4g_mem_size > 0) {\n\n#if TARGET_PHYS_ADDR_BITS == 32\n\n        hw_error(\"To much RAM for 32-bit physical address\");\n\n#else\n\n        ram_addr = qemu_ram_alloc(above_4g_mem_size);\n\n        cpu_register_physical_memory(0x100000000ULL,\n\n                                     above_4g_mem_size,\n\n                                     ram_addr);\n\n#endif\n\n    }\n\n\n\n\n\n    /* BIOS load */\n\n    if (bios_name == NULL)\n\n        bios_name = BIOS_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    if (filename) {\n\n        bios_size = get_image_size(filename);\n\n    } else {\n\n        bios_size = -1;\n\n    }\n\n    if (bios_size <= 0 ||\n\n        (bios_size % 65536) != 0) {\n\n        goto bios_error;\n\n    }\n\n    bios_offset = qemu_ram_alloc(bios_size);\n\n    ret = load_image(filename, qemu_get_ram_ptr(bios_offset));\n\n    if (ret != bios_size) {\n\n    bios_error:\n\n        fprintf(stderr, \"qemu: could not load PC BIOS '%s'\\n\", bios_name);\n\n        exit(1);\n\n    }\n\n    if (filename) {\n\n        qemu_free(filename);\n\n    }\n\n    /* map the last 128KB of the BIOS in ISA space */\n\n    isa_bios_size = bios_size;\n\n    if (isa_bios_size > (128 * 1024))\n\n        isa_bios_size = 128 * 1024;\n\n    cpu_register_physical_memory(0x100000 - isa_bios_size,\n\n                                 isa_bios_size,\n\n                                 (bios_offset + bios_size - isa_bios_size) | IO_MEM_ROM);\n\n\n\n\n\n\n\n    option_rom_offset = qemu_ram_alloc(PC_ROM_SIZE);\n\n    cpu_register_physical_memory(PC_ROM_MIN_VGA, PC_ROM_SIZE, option_rom_offset);\n\n\n\n    if (using_vga) {\n\n        /* VGA BIOS load */\n\n        if (cirrus_vga_enabled) {\n\n            rom_add_vga(VGABIOS_CIRRUS_FILENAME);\n\n        } else {\n\n            rom_add_vga(VGABIOS_FILENAME);\n\n        }\n\n    }\n\n\n\n    /* map all the bios at the top of memory */\n\n    cpu_register_physical_memory((uint32_t)(-bios_size),\n\n                                 bios_size, bios_offset | IO_MEM_ROM);\n\n\n\n    fw_cfg = bochs_bios_init();\n\n\n\n    if (linux_boot) {\n\n        load_linux(fw_cfg, kernel_filename, initrd_filename, kernel_cmdline, below_4g_mem_size);\n\n    }\n\n\n\n    for (i = 0; i < nb_option_roms; i++) {\n\n        rom_add_option(option_rom[i]);\n\n    }\n\n\n\n    for (i = 0; i < nb_nics; i++) {\n\n        char nic_oprom[1024];\n\n        const char *model = nd_table[i].model;\n\n\n\n        if (!nd_table[i].bootable)\n\n            continue;\n\n\n\n        if (model == NULL)\n\n            model = \"e1000\";\n\n        snprintf(nic_oprom, sizeof(nic_oprom), \"pxe-%s.bin\", model);\n\n\n\n        rom_add_option(nic_oprom);\n\n    }\n\n\n\n    cpu_irq = qemu_allocate_irqs(pic_irq_request, NULL, 1);\n\n    i8259 = i8259_init(cpu_irq[0]);\n\n    isa_irq_state = qemu_mallocz(sizeof(*isa_irq_state));\n\n    isa_irq_state->i8259 = i8259;\n\n    isa_irq = qemu_allocate_irqs(isa_irq_handler, isa_irq_state, 24);\n\n\n\n    if (pci_enabled) {\n\n        pci_bus = i440fx_init(&i440fx_state, &piix3_devfn, isa_irq);\n\n    } else {\n\n        pci_bus = NULL;\n\n        isa_bus_new(NULL);\n\n    }\n\n    isa_bus_irqs(isa_irq);\n\n\n\n    ferr_irq = isa_reserve_irq(13);\n\n\n\n    /* init basic PC hardware */\n\n    register_ioport_write(0x80, 1, 1, ioport80_write, NULL);\n\n\n\n    register_ioport_write(0xf0, 1, 1, ioportF0_write, NULL);\n\n\n\n    if (cirrus_vga_enabled) {\n\n        if (pci_enabled) {\n\n            pci_cirrus_vga_init(pci_bus);\n\n        } else {\n\n            isa_cirrus_vga_init();\n\n        }\n\n    } else if (vmsvga_enabled) {\n\n        if (pci_enabled)\n\n            pci_vmsvga_init(pci_bus);\n\n        else\n\n            fprintf(stderr, \"%s: vmware_vga: no PCI bus\\n\", __FUNCTION__);\n\n    } else if (std_vga_enabled) {\n\n        if (pci_enabled) {\n\n            pci_vga_init(pci_bus, 0, 0);\n\n        } else {\n\n            isa_vga_init();\n\n        }\n\n    }\n\n\n\n    rtc_state = rtc_init(2000);\n\n\n\n    qemu_register_boot_set(pc_boot_set, rtc_state);\n\n\n\n    register_ioport_read(0x92, 1, 1, ioport92_read, NULL);\n\n    register_ioport_write(0x92, 1, 1, ioport92_write, NULL);\n\n\n\n    if (pci_enabled) {\n\n        isa_irq_state->ioapic = ioapic_init();\n\n    }\n\n    pit = pit_init(0x40, isa_reserve_irq(0));\n\n    pcspk_init(pit);\n\n    if (!no_hpet) {\n\n        hpet_init(isa_irq);\n\n    }\n\n\n\n    for(i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            serial_isa_init(i, serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < MAX_PARALLEL_PORTS; i++) {\n\n        if (parallel_hds[i]) {\n\n            parallel_init(i, parallel_hds[i]);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!pci_enabled || (nd->model && strcmp(nd->model, \"ne2k_isa\") == 0))\n\n            pc_init_ne2k_isa(nd);\n\n        else\n\n            pci_nic_init_nofail(nd, \"e1000\", NULL);\n\n    }\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        hd[i] = drive_get(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n    } else {\n\n        for(i = 0; i < MAX_IDE_BUS; i++) {\n\n            isa_ide_init(ide_iobase[i], ide_iobase2[i], ide_irq[i],\n\n\t                 hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);\n\n        }\n\n    }\n\n\n\n    isa_dev = isa_create_simple(\"i8042\");\n\n    DMA_init(0);\n\n#ifdef HAS_AUDIO\n\n    audio_init(pci_enabled ? pci_bus : NULL, isa_irq);\n\n#endif\n\n\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        fd[i] = drive_get(IF_FLOPPY, 0, i);\n\n    }\n\n    floppy_controller = fdctrl_init_isa(fd);\n\n\n\n    cmos_init(below_4g_mem_size, above_4g_mem_size, boot_device, hd);\n\n\n\n    if (pci_enabled && usb_enabled) {\n\n        usb_uhci_piix3_init(pci_bus, piix3_devfn + 2);\n\n    }\n\n\n\n    if (pci_enabled && acpi_enabled) {\n\n        uint8_t *eeprom_buf = qemu_mallocz(8 * 256); /* XXX: make this persistent */\n\n        i2c_bus *smbus;\n\n\n\n        /* TODO: Populate SPD eeprom data.  */\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100,\n\n                              isa_reserve_irq(9));\n\n        for (i = 0; i < 8; i++) {\n\n            DeviceState *eeprom;\n\n            eeprom = qdev_create((BusState *)smbus, \"smbus-eeprom\");\n\n            qdev_prop_set_uint8(eeprom, \"address\", 0x50 + i);\n\n            qdev_prop_set_ptr(eeprom, \"data\", eeprom_buf + (i * 256));\n\n            qdev_init(eeprom);\n\n        }\n\n        piix4_acpi_system_hot_add_init(pci_bus);\n\n    }\n\n\n\n    if (i440fx_state) {\n\n        i440fx_init_memory_mappings(i440fx_state);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n\tint max_bus;\n\n        int bus;\n\n\n\n        max_bus = drive_get_max_bus(IF_SCSI);\n\n\tfor (bus = 0; bus <= max_bus; bus++) {\n\n            pci_create_simple(pci_bus, -1, \"lsi53c895a\");\n\n        }\n\n    }\n\n\n\n    /* Add virtio console devices */\n\n    if (pci_enabled) {\n\n        for(i = 0; i < MAX_VIRTIO_CONSOLES; i++) {\n\n            if (virtcon_hds[i]) {\n\n                pci_create_simple(pci_bus, -1, \"virtio-console-pci\");\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 24138}
{"project": "qemu", "commit_id": "c2551b47c9b9465962c4000268eda1307f55614a", "target": 1, "func": "static size_t refcount_array_byte_size(BDRVQcow2State *s, uint64_t entries)\n\n{\n\n    /* This assertion holds because there is no way we can address more than\n\n     * 2^(64 - 9) clusters at once (with cluster size 512 = 2^9, and because\n\n     * offsets have to be representable in bytes); due to every cluster\n\n     * corresponding to one refcount entry, we are well below that limit */\n\n    assert(entries < (UINT64_C(1) << (64 - 9)));\n\n\n\n    /* Thanks to the assertion this will not overflow, because\n\n     * s->refcount_order < 7.\n\n     * (note: x << s->refcount_order == x * s->refcount_bits) */\n\n    return DIV_ROUND_UP(entries << s->refcount_order, 8);\n\n}\n", "idx": 24140}
{"project": "qemu", "commit_id": "afea4e1410654154018587dd35c1b250ba4d8ec4", "target": 1, "func": "static void megasas_scsi_uninit(PCIDevice *d)\n\n{\n\n    MegasasState *s = MEGASAS(d);\n\n\n\n    if (megasas_use_msix(s)) {\n\n        msix_uninit(d, &s->mmio_io, &s->mmio_io);\n\n    }\n\n    if (megasas_use_msi(s)) {\n\n        msi_uninit(d);\n\n    }\n\n}\n", "idx": 24141}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static void jpeg_init_destination(j_compress_ptr cinfo)\n\n{\n\n    VncState *vs = cinfo->client_data;\n\n    Buffer *buffer = &vs->tight_jpeg;\n\n\n\n    cinfo->dest->next_output_byte = (JOCTET *)buffer->buffer + buffer->offset;\n\n    cinfo->dest->free_in_buffer = (size_t)(buffer->capacity - buffer->offset);\n\n}\n", "idx": 24149}
{"project": "qemu", "commit_id": "b6dcbe086c77ec683f5ff0b693593cda1d61f3a1", "target": 0, "func": "static void ref405ep_init (ram_addr_t ram_size,\n\n                           const char *boot_device,\n\n                           const char *kernel_filename,\n\n                           const char *kernel_cmdline,\n\n                           const char *initrd_filename,\n\n                           const char *cpu_model)\n\n{\n\n    char *filename;\n\n    ppc4xx_bd_info_t bd;\n\n    CPUPPCState *env;\n\n    qemu_irq *pic;\n\n    ram_addr_t sram_offset, bios_offset, bdloc;\n\n    target_phys_addr_t ram_bases[2], ram_sizes[2];\n\n    target_ulong sram_size;\n\n    long bios_size;\n\n    //int phy_addr = 0;\n\n    //static int phy_addr = 1;\n\n    target_ulong kernel_base, initrd_base;\n\n    long kernel_size, initrd_size;\n\n    int linux_boot;\n\n    int fl_idx, fl_sectors, len;\n\n    DriveInfo *dinfo;\n\n\n\n    /* XXX: fix this */\n\n    ram_bases[0] = qemu_ram_alloc(NULL, \"ef405ep.ram\", 0x08000000);\n\n    ram_sizes[0] = 0x08000000;\n\n    ram_bases[1] = 0x00000000;\n\n    ram_sizes[1] = 0x00000000;\n\n    ram_size = 128 * 1024 * 1024;\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register cpu\\n\", __func__);\n\n#endif\n\n    env = ppc405ep_init(ram_bases, ram_sizes, 33333333, &pic,\n\n                        kernel_filename == NULL ? 0 : 1);\n\n    /* allocate SRAM */\n\n    sram_size = 512 * 1024;\n\n    sram_offset = qemu_ram_alloc(NULL, \"ef405ep.sram\", sram_size);\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register SRAM at offset %08lx\\n\", __func__, sram_offset);\n\n#endif\n\n    cpu_register_physical_memory(0xFFF00000, sram_size,\n\n                                 sram_offset | IO_MEM_RAM);\n\n    /* allocate and load BIOS */\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register BIOS\\n\", __func__);\n\n#endif\n\n    fl_idx = 0;\n\n#ifdef USE_FLASH_BIOS\n\n    dinfo = drive_get(IF_PFLASH, 0, fl_idx);\n\n    if (dinfo) {\n\n        bios_size = bdrv_getlength(dinfo->bdrv);\n\n        bios_offset = qemu_ram_alloc(NULL, \"ef405ep.bios\", bios_size);\n\n        fl_sectors = (bios_size + 65535) >> 16;\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"Register parallel flash %d size %lx\"\n\n               \" at offset %08lx addr %lx '%s' %d\\n\",\n\n               fl_idx, bios_size, bios_offset, -bios_size,\n\n               bdrv_get_device_name(dinfo->bdrv), fl_sectors);\n\n#endif\n\n        pflash_cfi02_register((uint32_t)(-bios_size), bios_offset,\n\n                              dinfo->bdrv, 65536, fl_sectors, 1,\n\n                              2, 0x0001, 0x22DA, 0x0000, 0x0000, 0x555, 0x2AA,\n\n                              1);\n\n        fl_idx++;\n\n    } else\n\n#endif\n\n    {\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"Load BIOS from file\\n\");\n\n#endif\n\n        bios_offset = qemu_ram_alloc(NULL, \"ef405ep.bios\", BIOS_SIZE);\n\n        if (bios_name == NULL)\n\n            bios_name = BIOS_FILENAME;\n\n        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n        if (filename) {\n\n            bios_size = load_image(filename, qemu_get_ram_ptr(bios_offset));\n\n            g_free(filename);\n\n        } else {\n\n            bios_size = -1;\n\n        }\n\n        if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n            fprintf(stderr, \"qemu: could not load PowerPC bios '%s'\\n\",\n\n                    bios_name);\n\n            exit(1);\n\n        }\n\n        bios_size = (bios_size + 0xfff) & ~0xfff;\n\n        cpu_register_physical_memory((uint32_t)(-bios_size),\n\n                                     bios_size, bios_offset | IO_MEM_ROM);\n\n    }\n\n    /* Register FPGA */\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register FPGA\\n\", __func__);\n\n#endif\n\n    ref405ep_fpga_init(0xF0300000);\n\n    /* Register NVRAM */\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register NVRAM\\n\", __func__);\n\n#endif\n\n    m48t59_init(NULL, 0xF0000000, 0, 8192, 8);\n\n    /* Load kernel */\n\n    linux_boot = (kernel_filename != NULL);\n\n    if (linux_boot) {\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"%s: load kernel\\n\", __func__);\n\n#endif\n\n        memset(&bd, 0, sizeof(bd));\n\n        bd.bi_memstart = 0x00000000;\n\n        bd.bi_memsize = ram_size;\n\n        bd.bi_flashstart = -bios_size;\n\n        bd.bi_flashsize = -bios_size;\n\n        bd.bi_flashoffset = 0;\n\n        bd.bi_sramstart = 0xFFF00000;\n\n        bd.bi_sramsize = sram_size;\n\n        bd.bi_bootflags = 0;\n\n        bd.bi_intfreq = 133333333;\n\n        bd.bi_busfreq = 33333333;\n\n        bd.bi_baudrate = 115200;\n\n        bd.bi_s_version[0] = 'Q';\n\n        bd.bi_s_version[1] = 'M';\n\n        bd.bi_s_version[2] = 'U';\n\n        bd.bi_s_version[3] = '\\0';\n\n        bd.bi_r_version[0] = 'Q';\n\n        bd.bi_r_version[1] = 'E';\n\n        bd.bi_r_version[2] = 'M';\n\n        bd.bi_r_version[3] = 'U';\n\n        bd.bi_r_version[4] = '\\0';\n\n        bd.bi_procfreq = 133333333;\n\n        bd.bi_plb_busfreq = 33333333;\n\n        bd.bi_pci_busfreq = 33333333;\n\n        bd.bi_opbfreq = 33333333;\n\n        bdloc = ppc405_set_bootinfo(env, &bd, 0x00000001);\n\n        env->gpr[3] = bdloc;\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n        /* now we can load the kernel */\n\n        kernel_size = load_image_targphys(kernel_filename, kernel_base,\n\n                                          ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n        printf(\"Load kernel size %ld at \" TARGET_FMT_lx,\n\n               kernel_size, kernel_base);\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n        env->gpr[4] = initrd_base;\n\n        env->gpr[5] = initrd_size;\n\n        if (kernel_cmdline != NULL) {\n\n            len = strlen(kernel_cmdline);\n\n            bdloc -= ((len + 255) & ~255);\n\n            cpu_physical_memory_write(bdloc, (void *)kernel_cmdline, len + 1);\n\n            env->gpr[6] = bdloc;\n\n            env->gpr[7] = bdloc + len;\n\n        } else {\n\n            env->gpr[6] = 0;\n\n            env->gpr[7] = 0;\n\n        }\n\n        env->nip = KERNEL_LOAD_ADDR;\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n        bdloc = 0;\n\n    }\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: Done\\n\", __func__);\n\n#endif\n\n    printf(\"bdloc %016lx\\n\", (unsigned long)bdloc);\n\n}\n", "idx": 24150}
{"project": "qemu", "commit_id": "bb593904c18e22ea0671dfa1b02e24982f2bf0ea", "target": 0, "func": "void ppc_store_sdr1 (CPUPPCState *env, target_ulong value)\n\n{\n\n    LOG_MMU(\"%s: \" TARGET_FMT_lx \"\\n\", __func__, value);\n\n    if (env->sdr1 != value) {\n\n        /* XXX: for PowerPC 64, should check that the HTABSIZE value\n\n         *      is <= 28\n\n         */\n\n        env->sdr1 = value;\n\n        tlb_flush(env, 1);\n\n    }\n\n}\n", "idx": 24151}
{"project": "qemu", "commit_id": "b476c99d01519277e3494a10dc0329d07157ae02", "target": 0, "func": "static void memory_region_finalize(Object *obj)\n\n{\n\n    MemoryRegion *mr = MEMORY_REGION(obj);\n\n\n\n    assert(QTAILQ_EMPTY(&mr->subregions));\n\n    assert(memory_region_transaction_depth == 0);\n\n    mr->destructor(mr);\n\n    memory_region_clear_coalescing(mr);\n\n    g_free((char *)mr->name);\n\n    g_free(mr->ioeventfds);\n\n}\n", "idx": 24152}
{"project": "qemu", "commit_id": "b2c98d9d392c87c9b9e975d30f79924719d9cbbe", "target": 0, "func": "static void tgen64_ori(TCGContext *s, TCGReg dest, tcg_target_ulong val)\n\n{\n\n    static const S390Opcode oi_insns[4] = {\n\n        RI_OILL, RI_OILH, RI_OIHL, RI_OIHH\n\n    };\n\n    static const S390Opcode nif_insns[2] = {\n\n        RIL_OILF, RIL_OIHF\n\n    };\n\n\n\n    int i;\n\n\n\n    /* Look for no-op.  */\n\n    if (val == 0) {\n\n        return;\n\n    }\n\n\n\n    if (facilities & FACILITY_EXT_IMM) {\n\n        /* Try all 32-bit insns that can perform it in one go.  */\n\n        for (i = 0; i < 4; i++) {\n\n            tcg_target_ulong mask = (0xffffull << i*16);\n\n            if ((val & mask) != 0 && (val & ~mask) == 0) {\n\n                tcg_out_insn_RI(s, oi_insns[i], dest, val >> i*16);\n\n                return;\n\n            }\n\n        }\n\n\n\n        /* Try all 48-bit insns that can perform it in one go.  */\n\n        for (i = 0; i < 2; i++) {\n\n            tcg_target_ulong mask = (0xffffffffull << i*32);\n\n            if ((val & mask) != 0 && (val & ~mask) == 0) {\n\n                tcg_out_insn_RIL(s, nif_insns[i], dest, val >> i*32);\n\n                return;\n\n            }\n\n        }\n\n\n\n        /* Perform the OR via sequential modifications to the high and\n\n           low parts.  Do this via recursion to handle 16-bit vs 32-bit\n\n           masks in each half.  */\n\n        tgen64_ori(s, dest, val & 0x00000000ffffffffull);\n\n        tgen64_ori(s, dest, val & 0xffffffff00000000ull);\n\n    } else {\n\n        /* With no extended-immediate facility, we don't need to be so\n\n           clever.  Just iterate over the insns and mask in the constant.  */\n\n        for (i = 0; i < 4; i++) {\n\n            tcg_target_ulong mask = (0xffffull << i*16);\n\n            if ((val & mask) != 0) {\n\n                tcg_out_insn_RI(s, oi_insns[i], dest, val >> i*16);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 24153}
{"project": "qemu", "commit_id": "d5b93ddfefe63d5869a8eb97ea3474867d3b105b", "target": 0, "func": "int xen_be_init(void)\n\n{\n\n    xenstore = xs_daemon_open();\n\n    if (!xenstore) {\n\n        xen_be_printf(NULL, 0, \"can't connect to xenstored\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (qemu_set_fd_handler(xs_fileno(xenstore), xenstore_update, NULL, NULL) < 0) {\n\n        goto err;\n\n    }\n\n\n\n    xen_xc = xc_interface_open();\n\n    if (xen_xc == -1) {\n\n        xen_be_printf(NULL, 0, \"can't open xen interface\\n\");\n\n        goto err;\n\n    }\n\n    return 0;\n\n\n\nerr:\n\n    qemu_set_fd_handler(xs_fileno(xenstore), NULL, NULL, NULL);\n\n    xs_daemon_close(xenstore);\n\n    xenstore = NULL;\n\n\n\n    return -1;\n\n}\n", "idx": 24154}
{"project": "qemu", "commit_id": "5b5cb08683b6715a2aca5314168e68ff0665912b", "target": 0, "func": "static void msix_mmio_writel(void *opaque, target_phys_addr_t addr,\n\n                             uint32_t val)\n\n{\n\n    PCIDevice *dev = opaque;\n\n    unsigned int offset = addr & (MSIX_PAGE_SIZE - 1) & ~0x3;\n\n    int vector = offset / MSIX_ENTRY_SIZE;\n\n    pci_set_long(dev->msix_table_page + offset, val);\n\n    if (!msix_is_masked(dev, vector) && msix_is_pending(dev, vector)) {\n\n        msix_clr_pending(dev, vector);\n\n        msix_notify(dev, vector);\n\n    }\n\n}\n", "idx": 24156}
{"project": "qemu", "commit_id": "568c73a4783cd981e9aa6de4f15dcda7829643ad", "target": 0, "func": "static void virtio_input_handle_event(DeviceState *dev, QemuConsole *src,\n\n                                      InputEvent *evt)\n\n{\n\n    VirtIOInput *vinput = VIRTIO_INPUT(dev);\n\n    virtio_input_event event;\n\n    int qcode;\n\n\n\n    switch (evt->kind) {\n\n    case INPUT_EVENT_KIND_KEY:\n\n        qcode = qemu_input_key_value_to_qcode(evt->key->key);\n\n        if (qcode && keymap_qcode[qcode]) {\n\n            event.type  = cpu_to_le16(EV_KEY);\n\n            event.code  = cpu_to_le16(keymap_qcode[qcode]);\n\n            event.value = cpu_to_le32(evt->key->down ? 1 : 0);\n\n            virtio_input_send(vinput, &event);\n\n        } else {\n\n            if (evt->key->down) {\n\n                fprintf(stderr, \"%s: unmapped key: %d [%s]\\n\", __func__,\n\n                        qcode, QKeyCode_lookup[qcode]);\n\n            }\n\n        }\n\n        break;\n\n    case INPUT_EVENT_KIND_BTN:\n\n        if (keymap_button[evt->btn->button]) {\n\n            event.type  = cpu_to_le16(EV_KEY);\n\n            event.code  = cpu_to_le16(keymap_button[evt->btn->button]);\n\n            event.value = cpu_to_le32(evt->btn->down ? 1 : 0);\n\n            virtio_input_send(vinput, &event);\n\n        } else {\n\n            if (evt->btn->down) {\n\n                fprintf(stderr, \"%s: unmapped button: %d [%s]\\n\", __func__,\n\n                        evt->btn->button, InputButton_lookup[evt->btn->button]);\n\n            }\n\n        }\n\n        break;\n\n    case INPUT_EVENT_KIND_REL:\n\n        event.type  = cpu_to_le16(EV_REL);\n\n        event.code  = cpu_to_le16(axismap_rel[evt->rel->axis]);\n\n        event.value = cpu_to_le32(evt->rel->value);\n\n        virtio_input_send(vinput, &event);\n\n        break;\n\n    case INPUT_EVENT_KIND_ABS:\n\n        event.type  = cpu_to_le16(EV_ABS);\n\n        event.code  = cpu_to_le16(axismap_abs[evt->abs->axis]);\n\n        event.value = cpu_to_le32(evt->abs->value);\n\n        virtio_input_send(vinput, &event);\n\n        break;\n\n    default:\n\n        /* keep gcc happy */\n\n        break;\n\n    }\n\n}\n", "idx": 24157}
{"project": "qemu", "commit_id": "883bca776daa43111e9c39008f0038f7c62ae723", "target": 0, "func": "static int uhci_handle_td(UHCIState *s, uint32_t addr, UHCI_TD *td,\n\n                          uint32_t *int_mask, bool queuing)\n\n{\n\n    UHCIAsync *async;\n\n    int len = 0, max_len;\n\n    uint8_t pid;\n\n    USBDevice *dev;\n\n    USBEndpoint *ep;\n\n\n\n    /* Is active ? */\n\n    if (!(td->ctrl & TD_CTRL_ACTIVE))\n\n        return TD_RESULT_NEXT_QH;\n\n\n\n    async = uhci_async_find_td(s, addr, td);\n\n    if (async) {\n\n        /* Already submitted */\n\n        async->queue->valid = 32;\n\n\n\n        if (!async->done)\n\n            return TD_RESULT_ASYNC_CONT;\n\n        if (queuing) {\n\n            /* we are busy filling the queue, we are not prepared\n\n               to consume completed packages then, just leave them\n\n               in async state */\n\n            return TD_RESULT_ASYNC_CONT;\n\n        }\n\n\n\n        uhci_async_unlink(async);\n\n        goto done;\n\n    }\n\n\n\n    /* Allocate new packet */\n\n    async = uhci_async_alloc(uhci_queue_get(s, td), addr);\n\n\n\n    /* valid needs to be large enough to handle 10 frame delay\n\n     * for initial isochronous requests\n\n     */\n\n    async->queue->valid = 32;\n\n    async->isoc = td->ctrl & TD_CTRL_IOS;\n\n\n\n    max_len = ((td->token >> 21) + 1) & 0x7ff;\n\n    pid = td->token & 0xff;\n\n\n\n    dev = uhci_find_device(s, (td->token >> 8) & 0x7f);\n\n    ep = usb_ep_get(dev, pid, (td->token >> 15) & 0xf);\n\n    usb_packet_setup(&async->packet, pid, ep, addr);\n\n    qemu_sglist_add(&async->sgl, td->buffer, max_len);\n\n    usb_packet_map(&async->packet, &async->sgl);\n\n\n\n    switch(pid) {\n\n    case USB_TOKEN_OUT:\n\n    case USB_TOKEN_SETUP:\n\n        len = usb_handle_packet(dev, &async->packet);\n\n        if (len >= 0)\n\n            len = max_len;\n\n        break;\n\n\n\n    case USB_TOKEN_IN:\n\n        len = usb_handle_packet(dev, &async->packet);\n\n        break;\n\n\n\n    default:\n\n        /* invalid pid : frame interrupted */\n\n        uhci_async_free(async);\n\n        s->status |= UHCI_STS_HCPERR;\n\n        uhci_update_irq(s);\n\n        return TD_RESULT_STOP_FRAME;\n\n    }\n\n \n\n    if (len == USB_RET_ASYNC) {\n\n        uhci_async_link(async);\n\n        return TD_RESULT_ASYNC_START;\n\n    }\n\n\n\n    async->packet.result = len;\n\n\n\ndone:\n\n    len = uhci_complete_td(s, td, async, int_mask);\n\n    usb_packet_unmap(&async->packet, &async->sgl);\n\n    uhci_async_free(async);\n\n    return len;\n\n}\n", "idx": 24158}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "static void xen_pt_region_update(XenPCIPassthroughState *s,\n\n                                 MemoryRegionSection *sec, bool adding)\n\n{\n\n    PCIDevice *d = &s->dev;\n\n    MemoryRegion *mr = sec->mr;\n\n    int bar = -1;\n\n    int rc;\n\n    int op = adding ? DPCI_ADD_MAPPING : DPCI_REMOVE_MAPPING;\n\n    struct CheckBarArgs args = {\n\n        .s = s,\n\n        .addr = sec->offset_within_address_space,\n\n        .size = int128_get64(sec->size),\n\n        .rc = false,\n\n    };\n\n\n\n    bar = xen_pt_bar_from_region(s, mr);\n\n    if (bar == -1 && (!s->msix || &s->msix->mmio != mr)) {\n\n        return;\n\n    }\n\n\n\n    if (s->msix && &s->msix->mmio == mr) {\n\n        if (adding) {\n\n            s->msix->mmio_base_addr = sec->offset_within_address_space;\n\n            rc = xen_pt_msix_update_remap(s, s->msix->bar_index);\n\n        }\n\n        return;\n\n    }\n\n\n\n    args.type = d->io_regions[bar].type;\n\n    pci_for_each_device(d->bus, pci_bus_num(d->bus),\n\n                        xen_pt_check_bar_overlap, &args);\n\n    if (args.rc) {\n\n        XEN_PT_WARN(d, \"Region: %d (addr: %#\"FMT_PCIBUS\n\n                    \", len: %#\"FMT_PCIBUS\") is overlapped.\\n\",\n\n                    bar, sec->offset_within_address_space,\n\n                    int128_get64(sec->size));\n\n    }\n\n\n\n    if (d->io_regions[bar].type & PCI_BASE_ADDRESS_SPACE_IO) {\n\n        uint32_t guest_port = sec->offset_within_address_space;\n\n        uint32_t machine_port = s->bases[bar].access.pio_base;\n\n        uint32_t size = int128_get64(sec->size);\n\n        rc = xc_domain_ioport_mapping(xen_xc, xen_domid,\n\n                                      guest_port, machine_port, size,\n\n                                      op);\n\n        if (rc) {\n\n            XEN_PT_ERR(d, \"%s ioport mapping failed! (err: %i)\\n\",\n\n                       adding ? \"create new\" : \"remove old\", errno);\n\n        }\n\n    } else {\n\n        pcibus_t guest_addr = sec->offset_within_address_space;\n\n        pcibus_t machine_addr = s->bases[bar].access.maddr\n\n            + sec->offset_within_region;\n\n        pcibus_t size = int128_get64(sec->size);\n\n        rc = xc_domain_memory_mapping(xen_xc, xen_domid,\n\n                                      XEN_PFN(guest_addr + XC_PAGE_SIZE - 1),\n\n                                      XEN_PFN(machine_addr + XC_PAGE_SIZE - 1),\n\n                                      XEN_PFN(size + XC_PAGE_SIZE - 1),\n\n                                      op);\n\n        if (rc) {\n\n            XEN_PT_ERR(d, \"%s mem mapping failed! (err: %i)\\n\",\n\n                       adding ? \"create new\" : \"remove old\", errno);\n\n        }\n\n    }\n\n}\n", "idx": 24159}
{"project": "qemu", "commit_id": "698feb5e13a2d763369909ce33f2bd7a7c1c11c0", "target": 0, "func": "static void vhost_iommu_region_del(MemoryListener *listener,\n\n                                   MemoryRegionSection *section)\n\n{\n\n    struct vhost_dev *dev = container_of(listener, struct vhost_dev,\n\n                                         iommu_listener);\n\n    struct vhost_iommu *iommu;\n\n\n\n    if (!memory_region_is_iommu(section->mr)) {\n\n        return;\n\n    }\n\n\n\n    QLIST_FOREACH(iommu, &dev->iommu_list, iommu_next) {\n\n        if (iommu->mr == section->mr) {\n\n            memory_region_unregister_iommu_notifier(iommu->mr,\n\n                                                    &iommu->n);\n\n            QLIST_REMOVE(iommu, iommu_next);\n\n            g_free(iommu);\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 24160}
{"project": "qemu", "commit_id": "ba5e6bfa1aee29a8f72c5538c565dfb9889cf273", "target": 0, "func": "static void vfio_vga_quirk_teardown(VFIOPCIDevice *vdev)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < ARRAY_SIZE(vdev->vga.region); i++) {\n\n        while (!QLIST_EMPTY(&vdev->vga.region[i].quirks)) {\n\n            VFIOQuirk *quirk = QLIST_FIRST(&vdev->vga.region[i].quirks);\n\n            memory_region_del_subregion(&vdev->vga.region[i].mem, &quirk->mem);\n\n            object_unparent(OBJECT(&quirk->mem));\n\n            QLIST_REMOVE(quirk, next);\n\n            g_free(quirk);\n\n        }\n\n    }\n\n}\n", "idx": 24161}
{"project": "qemu", "commit_id": "a22313deca720e038ebc5805cf451b3a685d29ce", "target": 0, "func": "static void vfio_platform_eoi(VFIODevice *vbasedev)\n\n{\n\n    VFIOINTp *intp;\n\n    VFIOPlatformDevice *vdev =\n\n        container_of(vbasedev, VFIOPlatformDevice, vbasedev);\n\n\n\n    qemu_mutex_lock(&vdev->intp_mutex);\n\n    QLIST_FOREACH(intp, &vdev->intp_list, next) {\n\n        if (intp->state == VFIO_IRQ_ACTIVE) {\n\n            trace_vfio_platform_eoi(intp->pin,\n\n                                event_notifier_get_fd(&intp->interrupt));\n\n            intp->state = VFIO_IRQ_INACTIVE;\n\n\n\n            /* deassert the virtual IRQ */\n\n            qemu_set_irq(intp->qemuirq, 0);\n\n\n\n            if (intp->flags & VFIO_IRQ_INFO_AUTOMASKED) {\n\n                /* unmasks the physical level-sensitive IRQ */\n\n                vfio_unmask_single_irqindex(vbasedev, intp->pin);\n\n            }\n\n\n\n            /* a single IRQ can be active at a time */\n\n            break;\n\n        }\n\n    }\n\n    /* in case there are pending IRQs, handle the first one */\n\n    if (!QSIMPLEQ_EMPTY(&vdev->pending_intp_queue)) {\n\n        intp = QSIMPLEQ_FIRST(&vdev->pending_intp_queue);\n\n        vfio_intp_inject_pending_lockheld(intp);\n\n        QSIMPLEQ_REMOVE_HEAD(&vdev->pending_intp_queue, pqnext);\n\n    }\n\n    qemu_mutex_unlock(&vdev->intp_mutex);\n\n}\n", "idx": 24162}
{"project": "qemu", "commit_id": "41074f3d3ff0e9a3c6f638627c12ebbf6d757cea", "target": 0, "func": "static void omap_inth_sir_update(struct omap_intr_handler_s *s, int is_fiq)\n\n{\n\n    int i, j, sir_intr, p_intr, p, f;\n\n    uint32_t level;\n\n    sir_intr = 0;\n\n    p_intr = 255;\n\n\n\n    /* Find the interrupt line with the highest dynamic priority.\n\n     * Note: 0 denotes the hightest priority.\n\n     * If all interrupts have the same priority, the default order is IRQ_N,\n\n     * IRQ_N-1,...,IRQ_0. */\n\n    for (j = 0; j < s->nbanks; ++j) {\n\n        level = s->bank[j].irqs & ~s->bank[j].mask &\n\n                (is_fiq ? s->bank[j].fiq : ~s->bank[j].fiq);\n\n        for (f = ffs(level), i = f - 1, level >>= f - 1; f; i += f,\n\n                        level >>= f) {\n\n            p = s->bank[j].priority[i];\n\n            if (p <= p_intr) {\n\n                p_intr = p;\n\n                sir_intr = 32 * j + i;\n\n            }\n\n            f = ffs(level >> 1);\n\n        }\n\n    }\n\n    s->sir_intr[is_fiq] = sir_intr;\n\n}\n", "idx": 24163}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv val)\n\n{\n\n    TCGv tmp;\n\n    tmp = new_tmp();\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rlow, tmp);\n\n    tmp = new_tmp();\n\n    tcg_gen_shri_i64(val, val, 32);\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rhigh, tmp);\n\n}\n", "idx": 24164}
{"project": "qemu", "commit_id": "a03ef88f77af045a2eb9629b5ce774a3fb973c5e", "target": 0, "func": "static int coroutine_fn bdrv_co_do_writev(BdrvChild *child,\n\n    int64_t sector_num, int nb_sectors, QEMUIOVector *qiov,\n\n    BdrvRequestFlags flags)\n\n{\n\n    if (nb_sectors < 0 || nb_sectors > BDRV_REQUEST_MAX_SECTORS) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    return bdrv_co_pwritev(child->bs, sector_num << BDRV_SECTOR_BITS,\n\n                           nb_sectors << BDRV_SECTOR_BITS, qiov, flags);\n\n}\n", "idx": 24165}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static MegasasCmd *megasas_lookup_frame(MegasasState *s,\n\n    target_phys_addr_t frame)\n\n{\n\n    MegasasCmd *cmd = NULL;\n\n    int num = 0, index;\n\n\n\n    index = s->reply_queue_head;\n\n\n\n    while (num < s->fw_cmds) {\n\n        if (s->frames[index].pa && s->frames[index].pa == frame) {\n\n            cmd = &s->frames[index];\n\n            break;\n\n        }\n\n        index = megasas_next_index(s, index, s->fw_cmds);\n\n        num++;\n\n    }\n\n\n\n    return cmd;\n\n}\n", "idx": 24167}
{"project": "qemu", "commit_id": "6dc06f08b3d6c0347df00ac68d9f30e2b233a749", "target": 0, "func": "int scsi_req_get_sense(SCSIRequest *req, uint8_t *buf, int len)\n\n{\n\n    assert(len >= 14);\n\n    if (!req->sense_len) {\n\n        return 0;\n\n    }\n\n    return scsi_build_sense(req->sense, req->sense_len, buf, len, true);\n\n}\n", "idx": 24168}
{"project": "qemu", "commit_id": "791f97758e223de3290592d169f8e6339c281714", "target": 1, "func": "static int ehci_init_transfer(EHCIPacket *p)\n\n{\n\n    uint32_t cpage, offset, bytes, plen;\n\n    dma_addr_t page;\n\n\n\n    cpage  = get_field(p->qtd.token, QTD_TOKEN_CPAGE);\n\n    bytes  = get_field(p->qtd.token, QTD_TOKEN_TBYTES);\n\n    offset = p->qtd.bufptr[0] & ~QTD_BUFPTR_MASK;\n\n    qemu_sglist_init(&p->sgl, p->queue->ehci->device, 5, p->queue->ehci->as);\n\n\n\n    while (bytes > 0) {\n\n        if (cpage > 4) {\n\n            fprintf(stderr, \"cpage out of range (%d)\\n\", cpage);\n\n\n            return -1;\n\n        }\n\n\n\n        page  = p->qtd.bufptr[cpage] & QTD_BUFPTR_MASK;\n\n        page += offset;\n\n        plen  = bytes;\n\n        if (plen > 4096 - offset) {\n\n            plen = 4096 - offset;\n\n            offset = 0;\n\n            cpage++;\n\n        }\n\n\n\n        qemu_sglist_add(&p->sgl, page, plen);\n\n        bytes -= plen;\n\n    }\n\n    return 0;\n\n}", "idx": 24170}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static target_long monitor_get_pc (const struct MonitorDef *md, int val)\n\n{\n\n    CPUState *env = mon_get_cpu();\n\n    if (!env)\n\n        return 0;\n\n    return env->eip + env->segs[R_CS].base;\n\n}\n", "idx": 24171}
{"project": "qemu", "commit_id": "e41029b378b4a65a0b89b5a8dc087aca6b5d012d", "target": 1, "func": "static void gen_stswi(DisasContext *ctx)\n\n{\n\n    TCGv t0;\n\n    TCGv_i32 t1, t2;\n\n    int nb = NB(ctx->opcode);\n\n    gen_set_access_type(ctx, ACCESS_INT);\n\n    /* NIP cannot be restored if the memory exception comes from an helper */\n\n    gen_update_nip(ctx, ctx->nip - 4);\n\n    t0 = tcg_temp_new();\n\n    gen_addr_register(ctx, t0);\n\n    if (nb == 0)\n\n        nb = 32;\n\n    t1 = tcg_const_i32(nb);\n\n    t2 = tcg_const_i32(rS(ctx->opcode));\n\n    gen_helper_stsw(cpu_env, t0, t1, t2);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free_i32(t1);\n\n    tcg_temp_free_i32(t2);\n\n}\n", "idx": 24172}
{"project": "qemu", "commit_id": "b2d1fe67d09d2b6c7da647fbcea6ca0148c206d3", "target": 1, "func": "static void bufp_alloc(USBRedirDevice *dev,\n\n    uint8_t *data, int len, int status, uint8_t ep)\n\n{\n\n    struct buf_packet *bufp;\n\n\n\n    if (!dev->endpoint[EP2I(ep)].bufpq_dropping_packets &&\n\n        dev->endpoint[EP2I(ep)].bufpq_size >\n\n            2 * dev->endpoint[EP2I(ep)].bufpq_target_size) {\n\n        DPRINTF(\"bufpq overflow, dropping packets ep %02X\\n\", ep);\n\n        dev->endpoint[EP2I(ep)].bufpq_dropping_packets = 1;\n\n    }\n\n    /* Since we're interupting the stream anyways, drop enough packets to get\n\n       back to our target buffer size */\n\n    if (dev->endpoint[EP2I(ep)].bufpq_dropping_packets) {\n\n        if (dev->endpoint[EP2I(ep)].bufpq_size >\n\n                dev->endpoint[EP2I(ep)].bufpq_target_size) {\n\n            free(data);\n\n            return;\n\n        }\n\n        dev->endpoint[EP2I(ep)].bufpq_dropping_packets = 0;\n\n    }\n\n\n\n    bufp = g_malloc(sizeof(struct buf_packet));\n\n    bufp->data   = data;\n\n    bufp->len    = len;\n\n    bufp->status = status;\n\n    QTAILQ_INSERT_TAIL(&dev->endpoint[EP2I(ep)].bufpq, bufp, next);\n\n    dev->endpoint[EP2I(ep)].bufpq_size++;\n\n}\n", "idx": 24173}
{"project": "qemu", "commit_id": "7237aecd7e8fcc3ccf7fded77b6c127b4df5d3ac", "target": 1, "func": "static int vmdk_open_vmfs_sparse(BlockDriverState *bs,\n\n                                 BlockDriverState *file,\n\n                                 int flags, Error **errp)\n\n{\n\n    int ret;\n\n    uint32_t magic;\n\n    VMDK3Header header;\n\n    VmdkExtent *extent;\n\n\n\n    ret = bdrv_pread(file, sizeof(magic), &header, sizeof(header));\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret,\n\n                         \"Could not read header from file '%s'\",\n\n                         file->filename);\n\n        return ret;\n\n    }\n\n    ret = vmdk_add_extent(bs, file, false,\n\n                          le32_to_cpu(header.disk_sectors),\n\n                          le32_to_cpu(header.l1dir_offset) << 9,\n\n                          0,\n\n                          le32_to_cpu(header.l1dir_size),\n\n                          4096,\n\n                          le32_to_cpu(header.granularity),\n\n                          &extent,\n\n                          errp);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    ret = vmdk_init_tables(bs, extent, errp);\n\n    if (ret) {\n\n        /* free extent allocated by vmdk_add_extent */\n\n        vmdk_free_last_extent(bs);\n\n    }\n\n    return ret;\n\n}\n", "idx": 24174}
{"project": "qemu", "commit_id": "fc19f8a02e45c4d8ad24dd7eb374330b03dfc28e", "target": 0, "func": "static ssize_t nbd_co_receive_request(NBDRequest *req, struct nbd_request *request)\n\n{\n\n    NBDClient *client = req->client;\n\n    int csock = client->sock;\n\n    ssize_t rc;\n\n\n\n    client->recv_coroutine = qemu_coroutine_self();\n\n    if (nbd_receive_request(csock, request) == -1) {\n\n        rc = -EIO;\n\n        goto out;\n\n    }\n\n\n\n    if (request->len > NBD_BUFFER_SIZE) {\n\n        LOG(\"len (%u) is larger than max len (%u)\",\n\n            request->len, NBD_BUFFER_SIZE);\n\n        rc = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    if ((request->from + request->len) < request->from) {\n\n        LOG(\"integer overflow detected! \"\n\n            \"you're probably being attacked\");\n\n        rc = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    TRACE(\"Decoding type\");\n\n\n\n    if ((request->type & NBD_CMD_MASK_COMMAND) == NBD_CMD_WRITE) {\n\n        TRACE(\"Reading %u byte(s)\", request->len);\n\n\n\n        if (qemu_co_recv(csock, req->data, request->len) != request->len) {\n\n            LOG(\"reading from socket failed\");\n\n            rc = -EIO;\n\n            goto out;\n\n        }\n\n    }\n\n    rc = 0;\n\n\n\nout:\n\n    client->recv_coroutine = NULL;\n\n    return rc;\n\n}\n", "idx": 24176}
{"project": "qemu", "commit_id": "32902772833dbe424f754d5b841d996b90be87b2", "target": 0, "func": "static int pci_vga_initfn(PCIDevice *dev)\n\n{\n\n     PCIVGAState *d = DO_UPCAST(PCIVGAState, dev, dev);\n\n     VGACommonState *s = &d->vga;\n\n     uint8_t *pci_conf = d->dev.config;\n\n\n\n     // vga + console init\n\n     vga_common_init(s, VGA_RAM_SIZE);\n\n     vga_init(s);\n\n\n\n     s->ds = graphic_console_init(s->update, s->invalidate,\n\n                                  s->screen_dump, s->text_update, s);\n\n\n\n     // dummy VGA (same as Bochs ID)\n\n     pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_QEMU);\n\n     pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_QEMU_VGA);\n\n     pci_config_set_class(pci_conf, PCI_CLASS_DISPLAY_VGA);\n\n\n\n     /* XXX: VGA_RAM_SIZE must be a power of two */\n\n     pci_register_bar(&d->dev, 0, VGA_RAM_SIZE,\n\n                      PCI_BASE_ADDRESS_MEM_PREFETCH, vga_map);\n\n\n\n     if (!dev->rom_bar) {\n\n         /* compatibility with pc-0.13 and older */\n\n         vga_init_vbe(s);\n\n     }\n\n\n\n     return 0;\n\n}\n", "idx": 24177}
{"project": "qemu", "commit_id": "4080a13c11398d684668d286da27b6f8ee668e44", "target": 0, "func": "void portio_list_add(PortioList *piolist,\n\n                     MemoryRegion *address_space,\n\n                     uint32_t start)\n\n{\n\n    const MemoryRegionPortio *pio, *pio_start = piolist->ports;\n\n    unsigned int off_low, off_high, off_last, count;\n\n\n\n    piolist->address_space = address_space;\n\n\n\n    /* Handle the first entry specially.  */\n\n    off_last = off_low = pio_start->offset;\n\n    off_high = off_low + pio_start->len;\n\n    count = 1;\n\n\n\n    for (pio = pio_start + 1; pio->size != 0; pio++, count++) {\n\n        /* All entries must be sorted by offset.  */\n\n        assert(pio->offset >= off_last);\n\n        off_last = pio->offset;\n\n\n\n        /* If we see a hole, break the region.  */\n\n        if (off_last > off_high) {\n\n            portio_list_add_1(piolist, pio_start, count, start, off_low,\n\n                              off_high);\n\n            /* ... and start collecting anew.  */\n\n            pio_start = pio;\n\n            off_low = off_last;\n\n            off_high = off_low + pio->len;\n\n            count = 0;\n\n        } else if (off_last + pio->len > off_high) {\n\n            off_high = off_last + pio->len;\n\n        }\n\n    }\n\n\n\n    /* There will always be an open sub-list.  */\n\n    portio_list_add_1(piolist, pio_start, count, start, off_low, off_high);\n\n}\n", "idx": 24178}
{"project": "qemu", "commit_id": "29a6731afb20707ab0c1f9be997bef74cef34665", "target": 0, "func": "static void vararg_number(void)\n\n{\n\n    QObject *obj;\n\n    QInt *qint;\n\n    QFloat *qfloat;\n\n    int value = 0x2342;\n\n    int64_t value64 = 0x2342342343LL;\n\n    double valuef = 2.323423423;\n\n\n\n    obj = qobject_from_jsonf(\"%d\", value);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QINT);\n\n\n\n    qint = qobject_to_qint(obj);\n\n    g_assert(qint_get_int(qint) == value);\n\n\n\n    QDECREF(qint);\n\n\n\n    obj = qobject_from_jsonf(\"%\" PRId64, value64);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QINT);\n\n\n\n    qint = qobject_to_qint(obj);\n\n    g_assert(qint_get_int(qint) == value64);\n\n\n\n    QDECREF(qint);\n\n\n\n    obj = qobject_from_jsonf(\"%f\", valuef);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QFLOAT);\n\n\n\n    qfloat = qobject_to_qfloat(obj);\n\n    g_assert(qfloat_get_double(qfloat) == valuef);\n\n\n\n    QDECREF(qfloat);\n\n}\n", "idx": 24179}
{"project": "qemu", "commit_id": "3bba22de7cb9631452dad492c907affce6a69a3b", "target": 0, "func": "void qemu_console_resize(QEMUConsole *console, int width, int height)\n\n{\n\n    if (console->g_width != width || console->g_height != height) {\n\n        console->g_width = width;\n\n        console->g_height = height;\n\n        if (active_console == console) {\n\n            dpy_resize(console->ds, width, height);\n\n        }\n\n    }\n\n}\n", "idx": 24180}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static void coroutine_fn bdrv_get_block_status_co_entry(void *opaque)\n\n{\n\n    BdrvCoGetBlockStatusData *data = opaque;\n\n    BlockDriverState *bs = data->bs;\n\n\n\n    data->ret = bdrv_co_get_block_status(bs, data->sector_num, data->nb_sectors,\n\n                                         data->pnum);\n\n    data->done = true;\n\n}\n", "idx": 24181}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static uint32_t vmsvga_value_read(void *opaque, uint32_t address)\n\n{\n\n    uint32_t caps;\n\n    struct vmsvga_state_s *s = opaque;\n\n    switch (s->index) {\n\n    case SVGA_REG_ID:\n\n        return s->svgaid;\n\n\n\n    case SVGA_REG_ENABLE:\n\n        return s->enable;\n\n\n\n    case SVGA_REG_WIDTH:\n\n        return s->width;\n\n\n\n    case SVGA_REG_HEIGHT:\n\n        return s->height;\n\n\n\n    case SVGA_REG_MAX_WIDTH:\n\n        return SVGA_MAX_WIDTH;\n\n\n\n    case SVGA_REG_MAX_HEIGHT:\n\n        return SVGA_MAX_HEIGHT;\n\n\n\n    case SVGA_REG_DEPTH:\n\n        return s->depth;\n\n\n\n    case SVGA_REG_BITS_PER_PIXEL:\n\n        return (s->depth + 7) & ~7;\n\n\n\n    case SVGA_REG_PSEUDOCOLOR:\n\n        return 0x0;\n\n\n\n    case SVGA_REG_RED_MASK:\n\n        return s->wred;\n\n    case SVGA_REG_GREEN_MASK:\n\n        return s->wgreen;\n\n    case SVGA_REG_BLUE_MASK:\n\n        return s->wblue;\n\n\n\n    case SVGA_REG_BYTES_PER_LINE:\n\n        return ((s->depth + 7) >> 3) * s->new_width;\n\n\n\n    case SVGA_REG_FB_START: {\n\n        struct pci_vmsvga_state_s *pci_vmsvga\n\n            = container_of(s, struct pci_vmsvga_state_s, chip);\n\n        return pci_get_bar_addr(&pci_vmsvga->card, 1);\n\n    }\n\n\n\n    case SVGA_REG_FB_OFFSET:\n\n        return 0x0;\n\n\n\n    case SVGA_REG_VRAM_SIZE:\n\n        return s->vga.vram_size;\n\n\n\n    case SVGA_REG_FB_SIZE:\n\n        return s->fb_size;\n\n\n\n    case SVGA_REG_CAPABILITIES:\n\n        caps = SVGA_CAP_NONE;\n\n#ifdef HW_RECT_ACCEL\n\n        caps |= SVGA_CAP_RECT_COPY;\n\n#endif\n\n#ifdef HW_FILL_ACCEL\n\n        caps |= SVGA_CAP_RECT_FILL;\n\n#endif\n\n#ifdef HW_MOUSE_ACCEL\n\n        if (dpy_cursor_define_supported(s->vga.ds)) {\n\n            caps |= SVGA_CAP_CURSOR | SVGA_CAP_CURSOR_BYPASS_2 |\n\n                    SVGA_CAP_CURSOR_BYPASS;\n\n        }\n\n#endif\n\n        return caps;\n\n\n\n    case SVGA_REG_MEM_START: {\n\n        struct pci_vmsvga_state_s *pci_vmsvga\n\n            = container_of(s, struct pci_vmsvga_state_s, chip);\n\n        return pci_get_bar_addr(&pci_vmsvga->card, 2);\n\n    }\n\n\n\n    case SVGA_REG_MEM_SIZE:\n\n        return s->fifo_size;\n\n\n\n    case SVGA_REG_CONFIG_DONE:\n\n        return s->config;\n\n\n\n    case SVGA_REG_SYNC:\n\n    case SVGA_REG_BUSY:\n\n        return s->syncing;\n\n\n\n    case SVGA_REG_GUEST_ID:\n\n        return s->guest;\n\n\n\n    case SVGA_REG_CURSOR_ID:\n\n        return s->cursor.id;\n\n\n\n    case SVGA_REG_CURSOR_X:\n\n        return s->cursor.x;\n\n\n\n    case SVGA_REG_CURSOR_Y:\n\n        return s->cursor.x;\n\n\n\n    case SVGA_REG_CURSOR_ON:\n\n        return s->cursor.on;\n\n\n\n    case SVGA_REG_HOST_BITS_PER_PIXEL:\n\n        return (s->depth + 7) & ~7;\n\n\n\n    case SVGA_REG_SCRATCH_SIZE:\n\n        return s->scratch_size;\n\n\n\n    case SVGA_REG_MEM_REGS:\n\n    case SVGA_REG_NUM_DISPLAYS:\n\n    case SVGA_REG_PITCHLOCK:\n\n    case SVGA_PALETTE_BASE ... SVGA_PALETTE_END:\n\n        return 0;\n\n\n\n    default:\n\n        if (s->index >= SVGA_SCRATCH_BASE &&\n\n                s->index < SVGA_SCRATCH_BASE + s->scratch_size)\n\n            return s->scratch[s->index - SVGA_SCRATCH_BASE];\n\n        printf(\"%s: Bad register %02x\\n\", __FUNCTION__, s->index);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24183}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static void qemu_chr_parse_file_out(QemuOpts *opts, ChardevBackend *backend,\n\n                                    Error **errp)\n\n{\n\n    const char *path = qemu_opt_get(opts, \"path\");\n\n    ChardevFile *file;\n\n\n\n    if (path == NULL) {\n\n        error_setg(errp, \"chardev: file: no filename given\");\n\n        return;\n\n    }\n\n    file = backend->u.file = g_new0(ChardevFile, 1);\n\n    qemu_chr_parse_common(opts, qapi_ChardevFile_base(file));\n\n    file->out = g_strdup(path);\n\n\n\n    file->has_append = true;\n\n    file->append = qemu_opt_get_bool(opts, \"append\", false);\n\n}\n", "idx": 24184}
{"project": "qemu", "commit_id": "c2fa30757a2ba1bb5b053883773a9a61fbdd7082", "target": 0, "func": "nvdimm_dsm_write(void *opaque, hwaddr addr, uint64_t val, unsigned size)\n\n{\n\n    AcpiNVDIMMState *state = opaque;\n\n    NvdimmDsmIn *in;\n\n    hwaddr dsm_mem_addr = val;\n\n\n\n    nvdimm_debug(\"dsm memory address %#\" HWADDR_PRIx \".\\n\", dsm_mem_addr);\n\n\n\n    /*\n\n     * The DSM memory is mapped to guest address space so an evil guest\n\n     * can change its content while we are doing DSM emulation. Avoid\n\n     * this by copying DSM memory to QEMU local memory.\n\n     */\n\n    in = g_new(NvdimmDsmIn, 1);\n\n    cpu_physical_memory_read(dsm_mem_addr, in, sizeof(*in));\n\n\n\n    le32_to_cpus(&in->revision);\n\n    le32_to_cpus(&in->function);\n\n    le32_to_cpus(&in->handle);\n\n\n\n    nvdimm_debug(\"Revision %#x Handler %#x Function %#x.\\n\", in->revision,\n\n                 in->handle, in->function);\n\n\n\n    if (in->revision != 0x1 /* Currently we only support DSM Spec Rev1. */) {\n\n        nvdimm_debug(\"Revision %#x is not supported, expect %#x.\\n\",\n\n                     in->revision, 0x1);\n\n        nvdimm_dsm_no_payload(1 /* Not Supported */, dsm_mem_addr);\n\n        goto exit;\n\n    }\n\n\n\n    if (in->handle == NVDIMM_QEMU_RSVD_HANDLE_ROOT) {\n\n        nvdimm_dsm_reserved_root(state, in, dsm_mem_addr);\n\n        goto exit;\n\n    }\n\n\n\n     /* Handle 0 is reserved for NVDIMM Root Device. */\n\n    if (!in->handle) {\n\n        nvdimm_dsm_root(in, dsm_mem_addr);\n\n        goto exit;\n\n    }\n\n\n\n    nvdimm_dsm_device(in, dsm_mem_addr);\n\n\n\nexit:\n\n    g_free(in);\n\n}\n", "idx": 24185}
{"project": "qemu", "commit_id": "c208e8c2d88eea2bbafc2850d8856525637e495d", "target": 0, "func": "static BlockDriverAIOCB *hdev_aio_ioctl(BlockDriverState *bs,\n\n        unsigned long int req, void *buf,\n\n        BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n\n\n    if (fd_open(bs) < 0)\n\n        return NULL;\n\n    return paio_ioctl(bs, s->fd, req, buf, cb, opaque);\n\n}\n", "idx": 24186}
{"project": "qemu", "commit_id": "de1b9b85eff3dca42fe2cabe6e026cd2a2d5c769", "target": 0, "func": "static void qxl_init_ramsize(PCIQXLDevice *qxl)\n\n{\n\n    /* vga mode framebuffer / primary surface (bar 0, first part) */\n\n    if (qxl->vgamem_size_mb < 8) {\n\n        qxl->vgamem_size_mb = 8;\n\n    }\n\n    /* XXX: we round vgamem_size_mb up to a nearest power of two and it must be\n\n     * less than vga_common_init()'s maximum on qxl->vga.vram_size (512 now).\n\n     */\n\n    if (qxl->vgamem_size_mb > 256) {\n\n        qxl->vgamem_size_mb = 256;\n\n    }\n\n    qxl->vgamem_size = qxl->vgamem_size_mb * 1024 * 1024;\n\n\n\n    /* vga ram (bar 0, total) */\n\n    if (qxl->ram_size_mb != -1) {\n\n        qxl->vga.vram_size = qxl->ram_size_mb * 1024 * 1024;\n\n    }\n\n    if (qxl->vga.vram_size < qxl->vgamem_size * 2) {\n\n        qxl->vga.vram_size = qxl->vgamem_size * 2;\n\n    }\n\n\n\n    /* vram32 (surfaces, 32bit, bar 1) */\n\n    if (qxl->vram32_size_mb != -1) {\n\n        qxl->vram32_size = qxl->vram32_size_mb * 1024 * 1024;\n\n    }\n\n    if (qxl->vram32_size < 4096) {\n\n        qxl->vram32_size = 4096;\n\n    }\n\n\n\n    /* vram (surfaces, 64bit, bar 4+5) */\n\n    if (qxl->vram_size_mb != -1) {\n\n        qxl->vram_size = qxl->vram_size_mb * 1024 * 1024;\n\n    }\n\n    if (qxl->vram_size < qxl->vram32_size) {\n\n        qxl->vram_size = qxl->vram32_size;\n\n    }\n\n\n\n    if (qxl->revision == 1) {\n\n        qxl->vram32_size = 4096;\n\n        qxl->vram_size = 4096;\n\n    }\n\n    qxl->vgamem_size = pow2ceil(qxl->vgamem_size);\n\n    qxl->vga.vram_size = pow2ceil(qxl->vga.vram_size);\n\n    qxl->vram32_size = pow2ceil(qxl->vram32_size);\n\n    qxl->vram_size = pow2ceil(qxl->vram_size);\n\n}\n", "idx": 24187}
{"project": "qemu", "commit_id": "eb46c5eda7d8b38c1407dd55f67cf4a6aa3b7b23", "target": 0, "func": "static int rtl8139_config_writable(RTL8139State *s)\n\n{\n\n    if (s->Cfg9346 & Cfg9346_Unlock)\n\n    {\n\n        return 1;\n\n    }\n\n\n\n    DPRINTF(\"Configuration registers are write-protected\\n\");\n\n\n\n    return 0;\n\n}\n", "idx": 24188}
{"project": "qemu", "commit_id": "3356128cd13d7ec7689b7cddd3efbfbc5339a262", "target": 0, "func": "static int vfio_container_do_ioctl(AddressSpace *as, int32_t groupid,\n\n                                   int req, void *param)\n\n{\n\n    VFIOGroup *group;\n\n    VFIOContainer *container;\n\n    int ret = -1;\n\n\n\n    group = vfio_get_group(groupid, as);\n\n    if (!group) {\n\n        error_report(\"vfio: group %d not registered\", groupid);\n\n        return ret;\n\n    }\n\n\n\n    container = group->container;\n\n    if (group->container) {\n\n        ret = ioctl(container->fd, req, param);\n\n        if (ret < 0) {\n\n            error_report(\"vfio: failed to ioctl %d to container: ret=%d, %s\",\n\n                         _IOC_NR(req) - VFIO_BASE, ret, strerror(errno));\n\n        }\n\n    }\n\n\n\n    vfio_put_group(group);\n\n\n\n    return ret;\n\n}\n", "idx": 24189}
{"project": "qemu", "commit_id": "8e9b0d24fb986d4241ae3b77752eca5dab4cb486", "target": 0, "func": "void vnc_flush(VncState *vs)\n\n{\n\n    vnc_lock_output(vs);\n\n    if (vs->csock != -1 && (vs->output.offset\n\n#ifdef CONFIG_VNC_WS\n\n                || vs->ws_output.offset\n\n#endif\n\n                )) {\n\n        vnc_client_write_locked(vs);\n\n    }\n\n    vnc_unlock_output(vs);\n\n}\n", "idx": 24190}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "static float32 roundAndPackFloat32( flag zSign, int16 zExp, bits32 zSig STATUS_PARAM)\n\n{\n\n    int8 roundingMode;\n\n    flag roundNearestEven;\n\n    int8 roundIncrement, roundBits;\n\n    flag isTiny;\n\n\n\n    roundingMode = STATUS(float_rounding_mode);\n\n    roundNearestEven = ( roundingMode == float_round_nearest_even );\n\n    roundIncrement = 0x40;\n\n    if ( ! roundNearestEven ) {\n\n        if ( roundingMode == float_round_to_zero ) {\n\n            roundIncrement = 0;\n\n        }\n\n        else {\n\n            roundIncrement = 0x7F;\n\n            if ( zSign ) {\n\n                if ( roundingMode == float_round_up ) roundIncrement = 0;\n\n            }\n\n            else {\n\n                if ( roundingMode == float_round_down ) roundIncrement = 0;\n\n            }\n\n        }\n\n    }\n\n    roundBits = zSig & 0x7F;\n\n    if ( 0xFD <= (bits16) zExp ) {\n\n        if (    ( 0xFD < zExp )\n\n             || (    ( zExp == 0xFD )\n\n                  && ( (sbits32) ( zSig + roundIncrement ) < 0 ) )\n\n           ) {\n\n            float_raise( float_flag_overflow | float_flag_inexact STATUS_VAR);\n\n            return packFloat32( zSign, 0xFF, 0 ) - ( roundIncrement == 0 );\n\n        }\n\n        if ( zExp < 0 ) {\n\n            isTiny =\n\n                   ( STATUS(float_detect_tininess) == float_tininess_before_rounding )\n\n                || ( zExp < -1 )\n\n                || ( zSig + roundIncrement < 0x80000000 );\n\n            shift32RightJamming( zSig, - zExp, &zSig );\n\n            zExp = 0;\n\n            roundBits = zSig & 0x7F;\n\n            if ( isTiny && roundBits ) float_raise( float_flag_underflow STATUS_VAR);\n\n        }\n\n    }\n\n    if ( roundBits ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n    zSig = ( zSig + roundIncrement )>>7;\n\n    zSig &= ~ ( ( ( roundBits ^ 0x40 ) == 0 ) & roundNearestEven );\n\n    if ( zSig == 0 ) zExp = 0;\n\n    return packFloat32( zSign, zExp, zSig );\n\n\n\n}\n", "idx": 24191}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_lpg_write(void *opaque, target_phys_addr_t addr,\n\n                           uint64_t value, unsigned size)\n\n{\n\n    struct omap_lpg_s *s = (struct omap_lpg_s *) opaque;\n\n    int offset = addr & OMAP_MPUI_REG_MASK;\n\n\n\n    if (size != 1) {\n\n        return omap_badwidth_write8(opaque, addr, value);\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x00:\t/* LCR */\n\n        if (~value & (1 << 6))\t\t\t\t\t/* LPGRES */\n\n            omap_lpg_reset(s);\n\n        s->control = value & 0xff;\n\n        omap_lpg_update(s);\n\n        return;\n\n\n\n    case 0x04:\t/* PMR */\n\n        s->power = value & 0x01;\n\n        omap_lpg_update(s);\n\n        return;\n\n\n\n    default:\n\n        OMAP_BAD_REG(addr);\n\n        return;\n\n    }\n\n}\n", "idx": 24192}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_mpu_timer_read(void *opaque, target_phys_addr_t addr,\n\n                                    unsigned size)\n\n{\n\n    struct omap_mpu_timer_s *s = (struct omap_mpu_timer_s *) opaque;\n\n\n\n    if (size != 4) {\n\n        return omap_badwidth_read32(opaque, addr);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x00:\t/* CNTL_TIMER */\n\n        return (s->enable << 5) | (s->ptv << 2) | (s->ar << 1) | s->st;\n\n\n\n    case 0x04:\t/* LOAD_TIM */\n\n        break;\n\n\n\n    case 0x08:\t/* READ_TIM */\n\n        return omap_timer_read(s);\n\n    }\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 24194}
{"project": "qemu", "commit_id": "b4d02820d95e025e57d82144f7b2ccd677ac2418", "target": 0, "func": "void bdrv_close(BlockDriverState *bs)\n\n{\n\n    BdrvAioNotifier *ban, *ban_next;\n\n\n\n    if (bs->job) {\n\n        block_job_cancel_sync(bs->job);\n\n    }\n\n\n\n    /* Disable I/O limits and drain all pending throttled requests */\n\n    if (bs->io_limits_enabled) {\n\n        bdrv_io_limits_disable(bs);\n\n    }\n\n\n\n    bdrv_drain(bs); /* complete I/O */\n\n    bdrv_flush(bs);\n\n    bdrv_drain(bs); /* in case flush left pending I/O */\n\n    notifier_list_notify(&bs->close_notifiers, bs);\n\n\n\n    if (bs->drv) {\n\n        BdrvChild *child, *next;\n\n\n\n        bs->drv->bdrv_close(bs);\n\n        bs->drv = NULL;\n\n\n\n        bdrv_set_backing_hd(bs, NULL);\n\n\n\n        if (bs->file != NULL) {\n\n            bdrv_unref_child(bs, bs->file);\n\n            bs->file = NULL;\n\n        }\n\n\n\n        QLIST_FOREACH_SAFE(child, &bs->children, next, next) {\n\n            /* TODO Remove bdrv_unref() from drivers' close function and use\n\n             * bdrv_unref_child() here */\n\n            if (child->bs->inherits_from == bs) {\n\n                child->bs->inherits_from = NULL;\n\n            }\n\n            bdrv_detach_child(child);\n\n        }\n\n\n\n        g_free(bs->opaque);\n\n        bs->opaque = NULL;\n\n        bs->copy_on_read = 0;\n\n        bs->backing_file[0] = '\\0';\n\n        bs->backing_format[0] = '\\0';\n\n        bs->total_sectors = 0;\n\n        bs->encrypted = 0;\n\n        bs->valid_key = 0;\n\n        bs->sg = 0;\n\n        bs->zero_beyond_eof = false;\n\n        QDECREF(bs->options);\n\n        bs->options = NULL;\n\n        QDECREF(bs->full_open_options);\n\n        bs->full_open_options = NULL;\n\n    }\n\n\n\n    if (bs->blk) {\n\n        blk_dev_change_media_cb(bs->blk, false);\n\n    }\n\n\n\n    QLIST_FOREACH_SAFE(ban, &bs->aio_notifiers, list, ban_next) {\n\n        g_free(ban);\n\n    }\n\n    QLIST_INIT(&bs->aio_notifiers);\n\n}\n", "idx": 24195}
{"project": "qemu", "commit_id": "8917c3bdba37d6fe4393db0fad3fabbde9530d6b", "target": 0, "func": "void slirp_select_poll(fd_set *readfds, fd_set *writefds,\n\n                       fd_set *xfds, int select_error)\n\n{\n\n}\n", "idx": 24196}
{"project": "qemu", "commit_id": "0919ac787641db11024912651f3bc5764d4f1286", "target": 0, "func": "struct omap_mcbsp_s *omap_mcbsp_init(MemoryRegion *system_memory,\n\n                target_phys_addr_t base,\n\n                qemu_irq *irq, qemu_irq *dma, omap_clk clk)\n\n{\n\n    struct omap_mcbsp_s *s = (struct omap_mcbsp_s *)\n\n            g_malloc0(sizeof(struct omap_mcbsp_s));\n\n\n\n    s->txirq = irq[0];\n\n    s->rxirq = irq[1];\n\n    s->txdrq = dma[0];\n\n    s->rxdrq = dma[1];\n\n    s->sink_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_sink_tick, s);\n\n    s->source_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_source_tick, s);\n\n    omap_mcbsp_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_mcbsp_ops, s, \"omap-mcbsp\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 24197}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "static target_ulong h_rtas(PowerPCCPU *cpu, sPAPREnvironment *spapr,\n\n                           target_ulong opcode, target_ulong *args)\n\n{\n\n    target_ulong rtas_r3 = args[0];\n\n    uint32_t token = ldl_be_phys(rtas_r3);\n\n    uint32_t nargs = ldl_be_phys(rtas_r3 + 4);\n\n    uint32_t nret = ldl_be_phys(rtas_r3 + 8);\n\n\n\n    return spapr_rtas_call(spapr, token, nargs, rtas_r3 + 12,\n\n                           nret, rtas_r3 + 12 + 4*nargs);\n\n}\n", "idx": 24198}
{"project": "qemu", "commit_id": "250a87d5561a7212fe43357b084f69992eced75a", "target": 0, "func": "uint64_t HELPER(popcnt)(uint64_t r2)\n\n{\n\n    uint64_t ret = 0;\n\n    int i;\n\n\n\n    for (i = 0; i < 64; i += 8) {\n\n        uint64_t t = ctpop32((r2 >> i) & 0xff);\n\n        ret |= t << i;\n\n    }\n\n    return ret;\n\n}\n", "idx": 24199}
{"project": "qemu", "commit_id": "95ed56939eb2eaa4e2f349fe6dcd13ca4edfd8fb", "target": 0, "func": "static int ohci_service_ed_list(OHCIState *ohci, uint32_t head, int completion)\n\n{\n\n    struct ohci_ed ed;\n\n    uint32_t next_ed;\n\n    uint32_t cur;\n\n    int active;\n\n\n\n    active = 0;\n\n\n\n    if (head == 0)\n\n        return 0;\n\n\n\n    for (cur = head; cur; cur = next_ed) {\n\n        if (ohci_read_ed(ohci, cur, &ed)) {\n\n            trace_usb_ohci_ed_read_error(cur);\n\n            ohci_die(ohci);\n\n            return 0;\n\n        }\n\n\n\n        next_ed = ed.next & OHCI_DPTR_MASK;\n\n\n\n        if ((ed.head & OHCI_ED_H) || (ed.flags & OHCI_ED_K)) {\n\n            uint32_t addr;\n\n            /* Cancel pending packets for ED that have been paused.  */\n\n            addr = ed.head & OHCI_DPTR_MASK;\n\n            if (ohci->async_td && addr == ohci->async_td) {\n\n                usb_cancel_packet(&ohci->usb_packet);\n\n                ohci->async_td = 0;\n\n                usb_device_ep_stopped(ohci->usb_packet.ep->dev,\n\n                                      ohci->usb_packet.ep);\n\n            }\n\n            continue;\n\n        }\n\n\n\n        while ((ed.head & OHCI_DPTR_MASK) != ed.tail) {\n\n            trace_usb_ohci_ed_pkt(cur, (ed.head & OHCI_ED_H) != 0,\n\n                    (ed.head & OHCI_ED_C) != 0, ed.head & OHCI_DPTR_MASK,\n\n                    ed.tail & OHCI_DPTR_MASK, ed.next & OHCI_DPTR_MASK);\n\n            trace_usb_ohci_ed_pkt_flags(\n\n                    OHCI_BM(ed.flags, ED_FA), OHCI_BM(ed.flags, ED_EN),\n\n                    OHCI_BM(ed.flags, ED_D), (ed.flags & OHCI_ED_S)!= 0,\n\n                    (ed.flags & OHCI_ED_K) != 0, (ed.flags & OHCI_ED_F) != 0,\n\n                    OHCI_BM(ed.flags, ED_MPS));\n\n\n\n            active = 1;\n\n\n\n            if ((ed.flags & OHCI_ED_F) == 0) {\n\n                if (ohci_service_td(ohci, &ed))\n\n                    break;\n\n            } else {\n\n                /* Handle isochronous endpoints */\n\n                if (ohci_service_iso_td(ohci, &ed, completion))\n\n                    break;\n\n            }\n\n        }\n\n\n\n        if (ohci_put_ed(ohci, cur, &ed)) {\n\n            ohci_die(ohci);\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    return active;\n\n}\n", "idx": 24200}
{"project": "qemu", "commit_id": "67d5cd9722b230027d3d4267ae6069c5d8a65463", "target": 0, "func": "void s390_pci_iommu_disable(S390PCIBusDevice *pbdev)\n\n{\n\n    memory_region_del_subregion(&pbdev->mr, &pbdev->iommu_mr);\n\n    object_unparent(OBJECT(&pbdev->iommu_mr));\n\n    pbdev->iommu_enabled = false;\n\n}\n", "idx": 24201}
{"project": "qemu", "commit_id": "cfdf2c40577ed99bb19cdc05d0537e2808d77a78", "target": 0, "func": "static void do_info_balloon(Monitor *mon, QObject **ret_data)\n\n{\n\n    ram_addr_t actual;\n\n\n\n    actual = qemu_balloon_status();\n\n    if (kvm_enabled() && !kvm_has_sync_mmu())\n\n        qemu_error_new(QERR_KVM_MISSING_CAP, \"synchronous MMU\", \"balloon\");\n\n    else if (actual == 0)\n\n        qemu_error_new(QERR_DEVICE_NOT_ACTIVE, \"balloon\");\n\n    else\n\n        *ret_data = qobject_from_jsonf(\"{ 'balloon': %\" PRId64 \"}\",\n\n                                       (int64_t) actual);\n\n}\n", "idx": 24202}
{"project": "qemu", "commit_id": "cd41a671b370a3dd603963432d2b02f1e5990fb7", "target": 0, "func": "static void virtio_scsi_hotplug(SCSIBus *bus, SCSIDevice *dev)\n\n{\n\n    VirtIOSCSI *s = container_of(bus, VirtIOSCSI, bus);\n\n\n\n    if (((s->vdev.guest_features >> VIRTIO_SCSI_F_HOTPLUG) & 1) &&\n\n        (s->vdev.status & VIRTIO_CONFIG_S_DRIVER_OK)) {\n\n        virtio_scsi_push_event(s, dev, VIRTIO_SCSI_T_TRANSPORT_RESET,\n\n                               VIRTIO_SCSI_EVT_RESET_RESCAN);\n\n    }\n\n}\n", "idx": 24203}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "void qio_channel_socket_listen_async(QIOChannelSocket *ioc,\n\n                                     SocketAddressLegacy *addr,\n\n                                     QIOTaskFunc callback,\n\n                                     gpointer opaque,\n\n                                     GDestroyNotify destroy)\n\n{\n\n    QIOTask *task = qio_task_new(\n\n        OBJECT(ioc), callback, opaque, destroy);\n\n    SocketAddressLegacy *addrCopy;\n\n\n\n    addrCopy = QAPI_CLONE(SocketAddressLegacy, addr);\n\n\n\n    /* socket_listen() blocks in DNS lookups, so we must use a thread */\n\n    trace_qio_channel_socket_listen_async(ioc, addr);\n\n    qio_task_run_in_thread(task,\n\n                           qio_channel_socket_listen_worker,\n\n                           addrCopy,\n\n                           (GDestroyNotify)qapi_free_SocketAddressLegacy);\n\n}\n", "idx": 24204}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "uint8_t sd_read_data(SDState *sd)\n\n{\n\n    /* TODO: Append CRCs */\n\n    uint8_t ret;\n\n    int io_len;\n\n\n\n    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable)\n\n        return 0x00;\n\n\n\n    if (sd->state != sd_sendingdata_state) {\n\n        fprintf(stderr, \"sd_read_data: not in Sending-Data state\\n\");\n\n        return 0x00;\n\n    }\n\n\n\n    if (sd->card_status & (ADDRESS_ERROR | WP_VIOLATION))\n\n        return 0x00;\n\n\n\n    io_len = (sd->ocr & (1 << 30)) ? 512 : sd->blk_len;\n\n\n\n    switch (sd->current_cmd) {\n\n    case 6:\t/* CMD6:   SWITCH_FUNCTION */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 64)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 9:\t/* CMD9:   SEND_CSD */\n\n    case 10:\t/* CMD10:  SEND_CID */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 16)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 11:\t/* CMD11:  READ_DAT_UNTIL_STOP */\n\n        if (sd->data_offset == 0)\n\n            BLK_READ_BLOCK(sd->data_start, io_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= io_len) {\n\n            sd->data_start += io_len;\n\n            sd->data_offset = 0;\n\n            if (sd->data_start + io_len > sd->size) {\n\n                sd->card_status |= ADDRESS_ERROR;\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 13:\t/* ACMD13: SD_STATUS */\n\n        ret = sd->sd_status[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= sizeof(sd->sd_status))\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 17:\t/* CMD17:  READ_SINGLE_BLOCK */\n\n        if (sd->data_offset == 0)\n\n            BLK_READ_BLOCK(sd->data_start, io_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= io_len)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 18:\t/* CMD18:  READ_MULTIPLE_BLOCK */\n\n        if (sd->data_offset == 0)\n\n            BLK_READ_BLOCK(sd->data_start, io_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= io_len) {\n\n            sd->data_start += io_len;\n\n            sd->data_offset = 0;\n\n            if (sd->data_start + io_len > sd->size) {\n\n                sd->card_status |= ADDRESS_ERROR;\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 22:\t/* ACMD22: SEND_NUM_WR_BLOCKS */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 4)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 30:\t/* CMD30:  SEND_WRITE_PROT */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 4)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 51:\t/* ACMD51: SEND_SCR */\n\n        ret = sd->scr[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= sizeof(sd->scr))\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 56:\t/* CMD56:  GEN_CMD */\n\n        if (sd->data_offset == 0)\n\n            APP_READ_BLOCK(sd->data_start, sd->blk_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= sd->blk_len)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    default:\n\n        fprintf(stderr, \"sd_read_data: unknown command\\n\");\n\n        return 0x00;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 24206}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void bmdma_write(void *opaque, target_phys_addr_t addr,\n\n                        uint64_t val, unsigned size)\n\n{\n\n    BMDMAState *bm = opaque;\n\n\n\n    if (size != 1) {\n\n        return;\n\n    }\n\n\n\n#ifdef DEBUG_IDE\n\n    printf(\"bmdma: writeb 0x%02x : 0x%02x\\n\", addr, val);\n\n#endif\n\n    switch (addr & 3) {\n\n    case 0:\n\n        bmdma_cmd_writeb(bm, val);\n\n        break;\n\n    case 2:\n\n        bm->status = (val & 0x60) | (bm->status & 1) | (bm->status & ~val & 0x06);\n\n        break;\n\n    default:;\n\n    }\n\n}\n", "idx": 24207}
{"project": "qemu", "commit_id": "84a12e6648444f517055138a7d7f25a22d7e1029", "target": 0, "func": "int bdrv_open(BlockDriverState *bs, const char *filename, int flags,\n\n              BlockDriver *drv)\n\n{\n\n    int ret, open_flags;\n\n    char tmp_filename[PATH_MAX];\n\n    char backing_filename[PATH_MAX];\n\n\n\n    bs->is_temporary = 0;\n\n    bs->encrypted = 0;\n\n    bs->valid_key = 0;\n\n    bs->open_flags = flags;\n\n    /* buffer_alignment defaulted to 512, drivers can change this value */\n\n    bs->buffer_alignment = 512;\n\n\n\n    if (flags & BDRV_O_SNAPSHOT) {\n\n        BlockDriverState *bs1;\n\n        int64_t total_size;\n\n        int is_protocol = 0;\n\n        BlockDriver *bdrv_qcow2;\n\n        QEMUOptionParameter *options;\n\n\n\n        /* if snapshot, we create a temporary backing file and open it\n\n           instead of opening 'filename' directly */\n\n\n\n        /* if there is a backing file, use it */\n\n        bs1 = bdrv_new(\"\");\n\n        ret = bdrv_open(bs1, filename, 0, drv);\n\n        if (ret < 0) {\n\n            bdrv_delete(bs1);\n\n            return ret;\n\n        }\n\n        total_size = bdrv_getlength(bs1) >> BDRV_SECTOR_BITS;\n\n\n\n        if (bs1->drv && bs1->drv->protocol_name)\n\n            is_protocol = 1;\n\n\n\n        bdrv_delete(bs1);\n\n\n\n        get_tmp_filename(tmp_filename, sizeof(tmp_filename));\n\n\n\n        /* Real path is meaningless for protocols */\n\n        if (is_protocol)\n\n            snprintf(backing_filename, sizeof(backing_filename),\n\n                     \"%s\", filename);\n\n        else if (!realpath(filename, backing_filename))\n\n            return -errno;\n\n\n\n        bdrv_qcow2 = bdrv_find_format(\"qcow2\");\n\n        options = parse_option_parameters(\"\", bdrv_qcow2->create_options, NULL);\n\n\n\n        set_option_parameter_int(options, BLOCK_OPT_SIZE, total_size * 512);\n\n        set_option_parameter(options, BLOCK_OPT_BACKING_FILE, backing_filename);\n\n        if (drv) {\n\n            set_option_parameter(options, BLOCK_OPT_BACKING_FMT,\n\n                drv->format_name);\n\n        }\n\n\n\n        ret = bdrv_create(bdrv_qcow2, tmp_filename, options);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        filename = tmp_filename;\n\n        drv = bdrv_qcow2;\n\n        bs->is_temporary = 1;\n\n    }\n\n\n\n    pstrcpy(bs->filename, sizeof(bs->filename), filename);\n\n\n\n    if (!drv) {\n\n        drv = find_hdev_driver(filename);\n\n        if (!drv) {\n\n            drv = find_image_format(filename);\n\n        }\n\n    }\n\n\n\n    if (!drv) {\n\n        ret = -ENOENT;\n\n        goto unlink_and_fail;\n\n    }\n\n    if (use_bdrv_whitelist && !bdrv_is_whitelisted(drv)) {\n\n        ret = -ENOTSUP;\n\n        goto unlink_and_fail;\n\n    }\n\n\n\n    bs->drv = drv;\n\n    bs->opaque = qemu_mallocz(drv->instance_size);\n\n\n\n    /*\n\n     * Yes, BDRV_O_NOCACHE aka O_DIRECT means we have to present a\n\n     * write cache to the guest.  We do need the fdatasync to flush\n\n     * out transactions for block allocations, and we maybe have a\n\n     * volatile write cache in our backing device to deal with.\n\n     */\n\n    if (flags & (BDRV_O_CACHE_WB|BDRV_O_NOCACHE))\n\n        bs->enable_write_cache = 1;\n\n\n\n    /*\n\n     * Clear flags that are internal to the block layer before opening the\n\n     * image.\n\n     */\n\n    open_flags = flags & ~(BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING);\n\n\n\n    /*\n\n     * Snapshots should be writeable.\n\n     */\n\n    if (bs->is_temporary) {\n\n        open_flags |= BDRV_O_RDWR;\n\n    }\n\n\n\n    ret = drv->bdrv_open(bs, filename, open_flags);\n\n    if (ret < 0) {\n\n        goto free_and_fail;\n\n    }\n\n\n\n    bs->keep_read_only = bs->read_only = !(open_flags & BDRV_O_RDWR);\n\n    if (drv->bdrv_getlength) {\n\n        bs->total_sectors = bdrv_getlength(bs) >> BDRV_SECTOR_BITS;\n\n    }\n\n#ifndef _WIN32\n\n    if (bs->is_temporary) {\n\n        unlink(filename);\n\n    }\n\n#endif\n\n    if ((flags & BDRV_O_NO_BACKING) == 0 && bs->backing_file[0] != '\\0') {\n\n        /* if there is a backing file, use it */\n\n        BlockDriver *back_drv = NULL;\n\n        bs->backing_hd = bdrv_new(\"\");\n\n        path_combine(backing_filename, sizeof(backing_filename),\n\n                     filename, bs->backing_file);\n\n        if (bs->backing_format[0] != '\\0')\n\n            back_drv = bdrv_find_format(bs->backing_format);\n\n\n\n        /* backing files always opened read-only */\n\n        open_flags &= ~BDRV_O_RDWR;\n\n\n\n        ret = bdrv_open(bs->backing_hd, backing_filename, open_flags, back_drv);\n\n        if (ret < 0) {\n\n            bdrv_close(bs);\n\n            return ret;\n\n        }\n\n        if (bs->is_temporary) {\n\n            bs->backing_hd->keep_read_only = !(flags & BDRV_O_RDWR);\n\n        } else {\n\n            /* base image inherits from \"parent\" */\n\n            bs->backing_hd->keep_read_only = bs->keep_read_only;\n\n        }\n\n    }\n\n\n\n    if (!bdrv_key_required(bs)) {\n\n        /* call the change callback */\n\n        bs->media_changed = 1;\n\n        if (bs->change_cb)\n\n            bs->change_cb(bs->change_opaque);\n\n    }\n\n    return 0;\n\n\n\nfree_and_fail:\n\n    qemu_free(bs->opaque);\n\n    bs->opaque = NULL;\n\n    bs->drv = NULL;\n\nunlink_and_fail:\n\n    if (bs->is_temporary)\n\n        unlink(filename);\n\n    return ret;\n\n}\n", "idx": 24208}
{"project": "qemu", "commit_id": "92c0bba9a95739c92e959fe478cb1acb92fa5446", "target": 0, "func": "static uint32_t omap_l4_io_readw(void *opaque, target_phys_addr_t addr)\n\n{\n\n    unsigned int i = (addr - OMAP2_L4_BASE) >> TARGET_PAGE_BITS;\n\n\n\n    return omap_l4_io_readw_fn[i](omap_l4_io_opaque[i], addr);\n\n}\n", "idx": 24209}
{"project": "qemu", "commit_id": "3661049fec64ffd7ab008e57e396881c6a4b53a4", "target": 0, "func": "PCIBus *typhoon_init(ram_addr_t ram_size, ISABus **isa_bus,\n\n                     qemu_irq *p_rtc_irq,\n\n                     AlphaCPU *cpus[4], pci_map_irq_fn sys_map_irq)\n\n{\n\n    const uint64_t MB = 1024 * 1024;\n\n    const uint64_t GB = 1024 * MB;\n\n    MemoryRegion *addr_space = get_system_memory();\n\n    DeviceState *dev;\n\n    TyphoonState *s;\n\n    PCIHostState *phb;\n\n    PCIBus *b;\n\n    int i;\n\n\n\n    dev = qdev_create(NULL, TYPE_TYPHOON_PCI_HOST_BRIDGE);\n\n    qdev_init_nofail(dev);\n\n\n\n    s = TYPHOON_PCI_HOST_BRIDGE(dev);\n\n    phb = PCI_HOST_BRIDGE(dev);\n\n\n\n    /* Remember the CPUs so that we can deliver interrupts to them.  */\n\n    for (i = 0; i < 4; i++) {\n\n        AlphaCPU *cpu = cpus[i];\n\n        s->cchip.cpu[i] = cpu;\n\n        if (cpu != NULL) {\n\n            cpu->alarm_timer = qemu_new_timer_ns(rtc_clock,\n\n                                                 typhoon_alarm_timer,\n\n                                                 (void *)((uintptr_t)s + i));\n\n        }\n\n    }\n\n\n\n    *p_rtc_irq = *qemu_allocate_irqs(typhoon_set_timer_irq, s, 1);\n\n\n\n    /* Main memory region, 0x00.0000.0000.  Real hardware supports 32GB,\n\n       but the address space hole reserved at this point is 8TB.  */\n\n    memory_region_init_ram(&s->ram_region, OBJECT(s), \"ram\", ram_size);\n\n    vmstate_register_ram_global(&s->ram_region);\n\n    memory_region_add_subregion(addr_space, 0, &s->ram_region);\n\n\n\n    /* TIGbus, 0x801.0000.0000, 1GB.  */\n\n    /* ??? The TIGbus is used for delivering interrupts, and access to\n\n       the flash ROM.  I'm not sure that we need to implement it at all.  */\n\n\n\n    /* Pchip0 CSRs, 0x801.8000.0000, 256MB.  */\n\n    memory_region_init_io(&s->pchip.region, OBJECT(s), &pchip_ops, s, \"pchip0\",\n\n                          256*MB);\n\n    memory_region_add_subregion(addr_space, 0x80180000000ULL,\n\n                                &s->pchip.region);\n\n\n\n    /* Cchip CSRs, 0x801.A000.0000, 256MB.  */\n\n    memory_region_init_io(&s->cchip.region, OBJECT(s), &cchip_ops, s, \"cchip0\",\n\n                          256*MB);\n\n    memory_region_add_subregion(addr_space, 0x801a0000000ULL,\n\n                                &s->cchip.region);\n\n\n\n    /* Dchip CSRs, 0x801.B000.0000, 256MB.  */\n\n    memory_region_init_io(&s->dchip_region, OBJECT(s), &dchip_ops, s, \"dchip0\",\n\n                          256*MB);\n\n    memory_region_add_subregion(addr_space, 0x801b0000000ULL,\n\n                                &s->dchip_region);\n\n\n\n    /* Pchip0 PCI memory, 0x800.0000.0000, 4GB.  */\n\n    memory_region_init(&s->pchip.reg_mem, OBJECT(s), \"pci0-mem\", 4*GB);\n\n    memory_region_add_subregion(addr_space, 0x80000000000ULL,\n\n                                &s->pchip.reg_mem);\n\n\n\n    /* Pchip0 PCI I/O, 0x801.FC00.0000, 32MB.  */\n\n    memory_region_init(&s->pchip.reg_io, OBJECT(s), \"pci0-io\", 32*MB);\n\n    memory_region_add_subregion(addr_space, 0x801fc000000ULL,\n\n                                &s->pchip.reg_io);\n\n\n\n    b = pci_register_bus(dev, \"pci\",\n\n                         typhoon_set_irq, sys_map_irq, s,\n\n                         &s->pchip.reg_mem, &s->pchip.reg_io,\n\n                         0, 64, TYPE_PCI_BUS);\n\n    phb->bus = b;\n\n\n\n    /* Pchip0 PCI special/interrupt acknowledge, 0x801.F800.0000, 64MB.  */\n\n    memory_region_init_io(&s->pchip.reg_iack, OBJECT(s), &alpha_pci_iack_ops,\n\n                          b, \"pci0-iack\", 64*MB);\n\n    memory_region_add_subregion(addr_space, 0x801f8000000ULL,\n\n                                &s->pchip.reg_iack);\n\n\n\n    /* Pchip0 PCI configuration, 0x801.FE00.0000, 16MB.  */\n\n    memory_region_init_io(&s->pchip.reg_conf, OBJECT(s), &alpha_pci_conf1_ops,\n\n                          b, \"pci0-conf\", 16*MB);\n\n    memory_region_add_subregion(addr_space, 0x801fe000000ULL,\n\n                                &s->pchip.reg_conf);\n\n\n\n    /* For the record, these are the mappings for the second PCI bus.\n\n       We can get away with not implementing them because we indicate\n\n       via the Cchip.CSC<PIP> bit that Pchip1 is not present.  */\n\n    /* Pchip1 PCI memory, 0x802.0000.0000, 4GB.  */\n\n    /* Pchip1 CSRs, 0x802.8000.0000, 256MB.  */\n\n    /* Pchip1 PCI special/interrupt acknowledge, 0x802.F800.0000, 64MB.  */\n\n    /* Pchip1 PCI I/O, 0x802.FC00.0000, 32MB.  */\n\n    /* Pchip1 PCI configuration, 0x802.FE00.0000, 16MB.  */\n\n\n\n    /* Init the ISA bus.  */\n\n    /* ??? Technically there should be a cy82c693ub pci-isa bridge.  */\n\n    {\n\n        qemu_irq isa_pci_irq, *isa_irqs;\n\n\n\n        *isa_bus = isa_bus_new(NULL, &s->pchip.reg_io);\n\n        isa_pci_irq = *qemu_allocate_irqs(typhoon_set_isa_irq, s, 1);\n\n        isa_irqs = i8259_init(*isa_bus, isa_pci_irq);\n\n        isa_bus_irqs(*isa_bus, isa_irqs);\n\n    }\n\n\n\n    return b;\n\n}\n", "idx": 24210}
{"project": "qemu", "commit_id": "7d5e199ade76c53ec316ab6779800581bb47c50a", "target": 0, "func": "static void qmp_output_end_struct(Visitor *v, void **obj)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    QObject *value = qmp_output_pop(qov, obj);\n\n    assert(qobject_type(value) == QTYPE_QDICT);\n\n}\n", "idx": 24211}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_out_int(TestOutputVisitorData *data,\n\n                                 const void *unused)\n\n{\n\n    int64_t value = -42;\n\n    QObject *obj;\n\n\n\n    visit_type_int(data->ov, NULL, &value, &error_abort);\n\n\n\n    obj = visitor_get(data);\n\n    g_assert(qobject_type(obj) == QTYPE_QINT);\n\n    g_assert_cmpint(qint_get_int(qobject_to_qint(obj)), ==, value);\n\n}\n", "idx": 24212}
{"project": "qemu", "commit_id": "9c12a6f24d8bfd0e0d81a4a77f515e32d15547c1", "target": 0, "func": "void net_slirp_hostfwd_remove(Monitor *mon, const char *src_str)\n\n{\n\n    struct in_addr host_addr = { .s_addr = INADDR_ANY };\n\n    int host_port;\n\n    char buf[256] = \"\";\n\n    const char *p = src_str;\n\n    int is_udp = 0;\n\n    int n;\n\n\n\n    if (!slirp_inited) {\n\n        monitor_printf(mon, \"user mode network stack not in use\\n\");\n\n        return;\n\n    }\n\n\n\n    if (!src_str || !src_str[0])\n\n        goto fail_syntax;\n\n\n\n    get_str_sep(buf, sizeof(buf), &p, ':');\n\n\n\n    if (!strcmp(buf, \"tcp\") || buf[0] == '\\0') {\n\n        is_udp = 0;\n\n    } else if (!strcmp(buf, \"udp\")) {\n\n        is_udp = 1;\n\n    } else {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    if (buf[0] != '\\0' && !inet_aton(buf, &host_addr)) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    host_port = atoi(p);\n\n\n\n    n = slirp_remove_hostfwd(is_udp, host_addr, host_port);\n\n\n\n    monitor_printf(mon, \"removed %d host forwarding rules for %s\\n\", n,\n\n                   src_str);\n\n    return;\n\n\n\n fail_syntax:\n\n    monitor_printf(mon, \"invalid format\\n\");\n\n}\n", "idx": 24213}
{"project": "qemu", "commit_id": "6ecd0b6ba0591ef280ed984103924d4bdca5ac32", "target": 0, "func": "static void pmuserenr_write(CPUARMState *env, const ARMCPRegInfo *ri,\n\n                            uint64_t value)\n\n{\n\n    env->cp15.c9_pmuserenr = value & 1;\n\n}\n", "idx": 24214}
{"project": "qemu", "commit_id": "f8b6cc0070aab8b75bd082582c829be1353f395f", "target": 0, "func": "static int parse_drive(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    DriveInfo **ptr = qdev_get_prop_ptr(dev, prop);\n\n\n\n    *ptr = drive_get_by_id(str);\n\n    if (*ptr == NULL)\n\n        return -ENOENT;\n\n    return 0;\n\n}\n", "idx": 24215}
{"project": "qemu", "commit_id": "e4533c7a8cdcc79ccdf695f0aaa2e23a5b926ed0", "target": 0, "func": "void cpu_x86_interrupt(CPUX86State *s)\n\n{\n\n    s->interrupt_request = 1;\n\n}\n", "idx": 24217}
{"project": "qemu", "commit_id": "92fb73b9b0c0ba40d1dbef61dc798bf9499d084a", "target": 0, "func": "static void pxa2xx_lcdc_dma0_redraw_vert(struct pxa2xx_lcdc_s *s,\n\n                uint8_t *fb, int *miny, int *maxy)\n\n{\n\n    int y, src_width, dest_width, dirty[2];\n\n    uint8_t *src, *dest;\n\n    ram_addr_t x, addr, new_addr, start, end;\n\n    drawfn fn = 0;\n\n    if (s->dest_width)\n\n        fn = s->line_fn[s->transp][s->bpp];\n\n    if (!fn)\n\n        return;\n\n\n\n    src = fb;\n\n    src_width = (s->xres + 3) & ~3;     /* Pad to a 4 pixels multiple */\n\n    if (s->bpp == pxa_lcdc_19pbpp || s->bpp == pxa_lcdc_18pbpp)\n\n        src_width *= 3;\n\n    else if (s->bpp > pxa_lcdc_16bpp)\n\n        src_width *= 4;\n\n    else if (s->bpp > pxa_lcdc_8bpp)\n\n        src_width *= 2;\n\n\n\n    dest_width = s->yres * s->dest_width;\n\n    dest = ds_get_data(s->ds) + dest_width * (s->xres - 1);\n\n\n\n    addr = (ram_addr_t) (fb - phys_ram_base);\n\n    start = addr + s->yres * src_width;\n\n    end = addr;\n\n    dirty[0] = dirty[1] = cpu_physical_memory_get_dirty(start, VGA_DIRTY_FLAG);\n\n    for (y = 0; y < s->yres; y ++) {\n\n        new_addr = addr + src_width;\n\n        for (x = addr + TARGET_PAGE_SIZE; x < new_addr;\n\n                        x += TARGET_PAGE_SIZE) {\n\n            dirty[1] = cpu_physical_memory_get_dirty(x, VGA_DIRTY_FLAG);\n\n            dirty[0] |= dirty[1];\n\n        }\n\n        if (dirty[0] || s->invalidated) {\n\n            fn((uint32_t *) s->dma_ch[0].palette,\n\n                            dest, src, s->xres, -dest_width);\n\n            if (addr < start)\n\n                start = addr;\n\n            end = new_addr;\n\n            if (y < *miny)\n\n                *miny = y;\n\n            if (y >= *maxy)\n\n                *maxy = y + 1;\n\n        }\n\n        addr = new_addr;\n\n        dirty[0] = dirty[1];\n\n        src += src_width;\n\n        dest += s->dest_width;\n\n    }\n\n\n\n    if (end > start)\n\n        cpu_physical_memory_reset_dirty(start, end, VGA_DIRTY_FLAG);\n\n}\n", "idx": 24218}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_backspace(void)\n\n{\n\n    if (term_cmd_buf_index > 0) {\n\n        term_backward_char();\n\n        term_delete_char();\n\n    }\n\n}\n", "idx": 24219}
{"project": "qemu", "commit_id": "c83c66c3b58893a4dc056e272822beb88fe9ec7f", "target": 0, "func": "void hmp_block_stream(Monitor *mon, const QDict *qdict)\n\n{\n\n    Error *error = NULL;\n\n    const char *device = qdict_get_str(qdict, \"device\");\n\n    const char *base = qdict_get_try_str(qdict, \"base\");\n\n\n\n    qmp_block_stream(device, base != NULL, base, &error);\n\n\n\n    hmp_handle_error(mon, &error);\n\n}\n", "idx": 24220}
{"project": "qemu", "commit_id": "ab0997e0afdcb272fd04784a280b2df46b0c759f", "target": 1, "func": "static int qcow2_co_readv(BlockDriverState *bs, int64_t sector_num,\n\n                          int remaining_sectors, QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster, n1;\n\n    int ret;\n\n    int cur_nr_sectors; /* number of sectors in current iteration */\n\n    uint64_t cluster_offset = 0;\n\n    uint64_t bytes_done = 0;\n\n    QEMUIOVector hd_qiov;\n\n    uint8_t *cluster_data = NULL;\n\n\n\n    qemu_iovec_init(&hd_qiov, qiov->niov);\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (remaining_sectors != 0) {\n\n\n\n        /* prepare next request */\n\n        cur_nr_sectors = remaining_sectors;\n\n        if (s->crypt_method) {\n\n            cur_nr_sectors = MIN(cur_nr_sectors,\n\n                QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors);\n\n        }\n\n\n\n        ret = qcow2_get_cluster_offset(bs, sector_num << 9,\n\n            &cur_nr_sectors, &cluster_offset);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n\n\n        qemu_iovec_reset(&hd_qiov);\n\n        qemu_iovec_copy(&hd_qiov, qiov, bytes_done,\n\n            cur_nr_sectors * 512);\n\n\n\n        if (!cluster_offset) {\n\n\n\n            if (bs->backing_hd) {\n\n                /* read from the base image */\n\n                n1 = qcow2_backing_read1(bs->backing_hd, &hd_qiov,\n\n                    sector_num, cur_nr_sectors);\n\n                if (n1 > 0) {\n\n                    BLKDBG_EVENT(bs->file, BLKDBG_READ_BACKING_AIO);\n\n                    qemu_co_mutex_unlock(&s->lock);\n\n                    ret = bdrv_co_readv(bs->backing_hd, sector_num,\n\n                                        n1, &hd_qiov);\n\n                    qemu_co_mutex_lock(&s->lock);\n\n                    if (ret < 0) {\n\n                        goto fail;\n\n                    }\n\n                }\n\n            } else {\n\n                /* Note: in this case, no need to wait */\n\n                qemu_iovec_memset(&hd_qiov, 0, 512 * cur_nr_sectors);\n\n            }\n\n        } else if (cluster_offset & QCOW_OFLAG_COMPRESSED) {\n\n            /* add AIO support for compressed blocks ? */\n\n            ret = qcow2_decompress_cluster(bs, cluster_offset);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            qemu_iovec_from_buffer(&hd_qiov,\n\n                s->cluster_cache + index_in_cluster * 512,\n\n                512 * cur_nr_sectors);\n\n        } else {\n\n            if ((cluster_offset & 511) != 0) {\n\n                ret = -EIO;\n\n                goto fail;\n\n            }\n\n\n\n            if (s->crypt_method) {\n\n                /*\n\n                 * For encrypted images, read everything into a temporary\n\n                 * contiguous buffer on which the AES functions can work.\n\n                 */\n\n                if (!cluster_data) {\n\n                    cluster_data =\n\n                        g_malloc0(QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);\n\n                }\n\n\n\n                assert(cur_nr_sectors <=\n\n                    QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors);\n\n                qemu_iovec_reset(&hd_qiov);\n\n                qemu_iovec_add(&hd_qiov, cluster_data,\n\n                    512 * cur_nr_sectors);\n\n            }\n\n\n\n            BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            ret = bdrv_co_readv(bs->file,\n\n                                (cluster_offset >> 9) + index_in_cluster,\n\n                                cur_nr_sectors, &hd_qiov);\n\n            qemu_co_mutex_lock(&s->lock);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n            if (s->crypt_method) {\n\n                qcow2_encrypt_sectors(s, sector_num,  cluster_data,\n\n                    cluster_data, cur_nr_sectors, 0, &s->aes_decrypt_key);\n\n                qemu_iovec_reset(&hd_qiov);\n\n                qemu_iovec_copy(&hd_qiov, qiov, bytes_done,\n\n                    cur_nr_sectors * 512);\n\n                qemu_iovec_from_buffer(&hd_qiov, cluster_data,\n\n                    512 * cur_nr_sectors);\n\n            }\n\n        }\n\n\n\n        remaining_sectors -= cur_nr_sectors;\n\n        sector_num += cur_nr_sectors;\n\n        bytes_done += cur_nr_sectors * 512;\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    qemu_iovec_destroy(&hd_qiov);\n\n\n\n\n    return ret;\n\n}", "idx": 24222}
{"project": "qemu", "commit_id": "728470bea15b11ba7b3e3db54f0d9939908e0e65", "target": 1, "func": "static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)\n\n{\n\n    QEMUFileRDMA *r = g_malloc0(sizeof(QEMUFileRDMA));\n\n\n\n    if (qemu_file_mode_is_not_valid(mode)) {\n\n        return NULL;\n\n    }\n\n\n\n    r->rdma = rdma;\n\n\n\n    if (mode[0] == 'w') {\n\n        r->file = qemu_fopen_ops(r, &rdma_write_ops);\n\n    } else {\n\n        r->file = qemu_fopen_ops(r, &rdma_read_ops);\n\n    }\n\n\n\n    return r->file;\n\n}\n", "idx": 24231}
{"project": "qemu", "commit_id": "e318a60b94b152c1e80125861a8917ae177d845e", "target": 1, "func": "static int disas_neon_ls_insn(CPUState * env, DisasContext *s, uint32_t insn)\n\n{\n\n    int rd, rn, rm;\n\n    int op;\n\n    int nregs;\n\n    int interleave;\n\n    int spacing;\n\n    int stride;\n\n    int size;\n\n    int reg;\n\n    int pass;\n\n    int load;\n\n    int shift;\n\n    int n;\n\n    TCGv addr;\n\n    TCGv tmp;\n\n    TCGv tmp2;\n\n    TCGv_i64 tmp64;\n\n\n\n    if (!s->vfp_enabled)\n\n      return 1;\n\n    VFP_DREG_D(rd, insn);\n\n    rn = (insn >> 16) & 0xf;\n\n    rm = insn & 0xf;\n\n    load = (insn & (1 << 21)) != 0;\n\n    addr = tcg_temp_new_i32();\n\n    if ((insn & (1 << 23)) == 0) {\n\n        /* Load store all elements.  */\n\n        op = (insn >> 8) & 0xf;\n\n        size = (insn >> 6) & 3;\n\n        if (op > 10)\n\n            return 1;\n\n        nregs = neon_ls_element_type[op].nregs;\n\n        interleave = neon_ls_element_type[op].interleave;\n\n        spacing = neon_ls_element_type[op].spacing;\n\n        if (size == 3 && (interleave | spacing) != 1)\n\n            return 1;\n\n        load_reg_var(s, addr, rn);\n\n        stride = (1 << size) * interleave;\n\n        for (reg = 0; reg < nregs; reg++) {\n\n            if (interleave > 2 || (interleave == 2 && nregs == 2)) {\n\n                load_reg_var(s, addr, rn);\n\n                tcg_gen_addi_i32(addr, addr, (1 << size) * reg);\n\n            } else if (interleave == 2 && nregs == 4 && reg == 2) {\n\n                load_reg_var(s, addr, rn);\n\n                tcg_gen_addi_i32(addr, addr, 1 << size);\n\n            }\n\n            if (size == 3) {\n\n                if (load) {\n\n                    tmp64 = gen_ld64(addr, IS_USER(s));\n\n                    neon_store_reg64(tmp64, rd);\n\n                    tcg_temp_free_i64(tmp64);\n\n                } else {\n\n                    tmp64 = tcg_temp_new_i64();\n\n                    neon_load_reg64(tmp64, rd);\n\n                    gen_st64(tmp64, addr, IS_USER(s));\n\n                }\n\n                tcg_gen_addi_i32(addr, addr, stride);\n\n            } else {\n\n                for (pass = 0; pass < 2; pass++) {\n\n                    if (size == 2) {\n\n                        if (load) {\n\n                            tmp = gen_ld32(addr, IS_USER(s));\n\n                            neon_store_reg(rd, pass, tmp);\n\n                        } else {\n\n                            tmp = neon_load_reg(rd, pass);\n\n                            gen_st32(tmp, addr, IS_USER(s));\n\n                        }\n\n                        tcg_gen_addi_i32(addr, addr, stride);\n\n                    } else if (size == 1) {\n\n                        if (load) {\n\n                            tmp = gen_ld16u(addr, IS_USER(s));\n\n                            tcg_gen_addi_i32(addr, addr, stride);\n\n                            tmp2 = gen_ld16u(addr, IS_USER(s));\n\n                            tcg_gen_addi_i32(addr, addr, stride);\n\n                            tcg_gen_shli_i32(tmp2, tmp2, 16);\n\n                            tcg_gen_or_i32(tmp, tmp, tmp2);\n\n                            tcg_temp_free_i32(tmp2);\n\n                            neon_store_reg(rd, pass, tmp);\n\n                        } else {\n\n                            tmp = neon_load_reg(rd, pass);\n\n                            tmp2 = tcg_temp_new_i32();\n\n                            tcg_gen_shri_i32(tmp2, tmp, 16);\n\n                            gen_st16(tmp, addr, IS_USER(s));\n\n                            tcg_gen_addi_i32(addr, addr, stride);\n\n                            gen_st16(tmp2, addr, IS_USER(s));\n\n                            tcg_gen_addi_i32(addr, addr, stride);\n\n                        }\n\n                    } else /* size == 0 */ {\n\n                        if (load) {\n\n                            TCGV_UNUSED(tmp2);\n\n                            for (n = 0; n < 4; n++) {\n\n                                tmp = gen_ld8u(addr, IS_USER(s));\n\n                                tcg_gen_addi_i32(addr, addr, stride);\n\n                                if (n == 0) {\n\n                                    tmp2 = tmp;\n\n                                } else {\n\n                                    tcg_gen_shli_i32(tmp, tmp, n * 8);\n\n                                    tcg_gen_or_i32(tmp2, tmp2, tmp);\n\n                                    tcg_temp_free_i32(tmp);\n\n                                }\n\n                            }\n\n                            neon_store_reg(rd, pass, tmp2);\n\n                        } else {\n\n                            tmp2 = neon_load_reg(rd, pass);\n\n                            for (n = 0; n < 4; n++) {\n\n                                tmp = tcg_temp_new_i32();\n\n                                if (n == 0) {\n\n                                    tcg_gen_mov_i32(tmp, tmp2);\n\n                                } else {\n\n                                    tcg_gen_shri_i32(tmp, tmp2, n * 8);\n\n                                }\n\n                                gen_st8(tmp, addr, IS_USER(s));\n\n                                tcg_gen_addi_i32(addr, addr, stride);\n\n                            }\n\n                            tcg_temp_free_i32(tmp2);\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            rd += spacing;\n\n        }\n\n        stride = nregs * 8;\n\n    } else {\n\n        size = (insn >> 10) & 3;\n\n        if (size == 3) {\n\n            /* Load single element to all lanes.  */\n\n            int a = (insn >> 4) & 1;\n\n            if (!load) {\n\n                return 1;\n\n            }\n\n            size = (insn >> 6) & 3;\n\n            nregs = ((insn >> 8) & 3) + 1;\n\n\n\n            if (size == 3) {\n\n                if (nregs != 4 || a == 0) {\n\n                    return 1;\n\n                }\n\n                /* For VLD4 size==3 a == 1 means 32 bits at 16 byte alignment */\n\n                size = 2;\n\n            }\n\n            if (nregs == 1 && a == 1 && size == 0) {\n\n                return 1;\n\n            }\n\n            if (nregs == 3 && a == 1) {\n\n                return 1;\n\n            }\n\n            load_reg_var(s, addr, rn);\n\n            if (nregs == 1) {\n\n                /* VLD1 to all lanes: bit 5 indicates how many Dregs to write */\n\n                tmp = gen_load_and_replicate(s, addr, size);\n\n                tcg_gen_st_i32(tmp, cpu_env, neon_reg_offset(rd, 0));\n\n                tcg_gen_st_i32(tmp, cpu_env, neon_reg_offset(rd, 1));\n\n                if (insn & (1 << 5)) {\n\n                    tcg_gen_st_i32(tmp, cpu_env, neon_reg_offset(rd + 1, 0));\n\n                    tcg_gen_st_i32(tmp, cpu_env, neon_reg_offset(rd + 1, 1));\n\n                }\n\n                tcg_temp_free_i32(tmp);\n\n            } else {\n\n                /* VLD2/3/4 to all lanes: bit 5 indicates register stride */\n\n                stride = (insn & (1 << 5)) ? 2 : 1;\n\n                for (reg = 0; reg < nregs; reg++) {\n\n                    tmp = gen_load_and_replicate(s, addr, size);\n\n                    tcg_gen_st_i32(tmp, cpu_env, neon_reg_offset(rd, 0));\n\n                    tcg_gen_st_i32(tmp, cpu_env, neon_reg_offset(rd, 1));\n\n                    tcg_temp_free_i32(tmp);\n\n                    tcg_gen_addi_i32(addr, addr, 1 << size);\n\n                    rd += stride;\n\n                }\n\n            }\n\n            stride = (1 << size) * nregs;\n\n        } else {\n\n            /* Single element.  */\n\n            pass = (insn >> 7) & 1;\n\n            switch (size) {\n\n            case 0:\n\n                shift = ((insn >> 5) & 3) * 8;\n\n                stride = 1;\n\n                break;\n\n            case 1:\n\n                shift = ((insn >> 6) & 1) * 16;\n\n                stride = (insn & (1 << 5)) ? 2 : 1;\n\n                break;\n\n            case 2:\n\n                shift = 0;\n\n                stride = (insn & (1 << 6)) ? 2 : 1;\n\n                break;\n\n            default:\n\n                abort();\n\n            }\n\n            nregs = ((insn >> 8) & 3) + 1;\n\n            load_reg_var(s, addr, rn);\n\n            for (reg = 0; reg < nregs; reg++) {\n\n                if (load) {\n\n                    switch (size) {\n\n                    case 0:\n\n                        tmp = gen_ld8u(addr, IS_USER(s));\n\n                        break;\n\n                    case 1:\n\n                        tmp = gen_ld16u(addr, IS_USER(s));\n\n                        break;\n\n                    case 2:\n\n                        tmp = gen_ld32(addr, IS_USER(s));\n\n                        break;\n\n                    default: /* Avoid compiler warnings.  */\n\n                        abort();\n\n                    }\n\n                    if (size != 2) {\n\n                        tmp2 = neon_load_reg(rd, pass);\n\n                        gen_bfi(tmp, tmp2, tmp, shift, size ? 0xffff : 0xff);\n\n                        tcg_temp_free_i32(tmp2);\n\n                    }\n\n                    neon_store_reg(rd, pass, tmp);\n\n                } else { /* Store */\n\n                    tmp = neon_load_reg(rd, pass);\n\n                    if (shift)\n\n                        tcg_gen_shri_i32(tmp, tmp, shift);\n\n                    switch (size) {\n\n                    case 0:\n\n                        gen_st8(tmp, addr, IS_USER(s));\n\n                        break;\n\n                    case 1:\n\n                        gen_st16(tmp, addr, IS_USER(s));\n\n                        break;\n\n                    case 2:\n\n                        gen_st32(tmp, addr, IS_USER(s));\n\n                        break;\n\n                    }\n\n                }\n\n                rd += stride;\n\n                tcg_gen_addi_i32(addr, addr, 1 << size);\n\n            }\n\n            stride = nregs * (1 << size);\n\n        }\n\n    }\n\n    tcg_temp_free_i32(addr);\n\n    if (rm != 15) {\n\n        TCGv base;\n\n\n\n        base = load_reg(s, rn);\n\n        if (rm == 13) {\n\n            tcg_gen_addi_i32(base, base, stride);\n\n        } else {\n\n            TCGv index;\n\n            index = load_reg(s, rm);\n\n            tcg_gen_add_i32(base, base, index);\n\n            tcg_temp_free_i32(index);\n\n        }\n\n        store_reg(s, rn, base);\n\n    }\n\n    return 0;\n\n}\n", "idx": 24233}
{"project": "qemu", "commit_id": "640601c7cb1b6b41d3e1a435b986266c2b71e9bc", "target": 1, "func": "vu_queue_empty(VuDev *dev, VuVirtq *vq)\n\n{\n\n    if (vq->shadow_avail_idx != vq->last_avail_idx) {\n\n        return 0;\n\n    }\n\n\n\n    return vring_avail_idx(vq) == vq->last_avail_idx;\n\n}\n", "idx": 24234}
{"project": "qemu", "commit_id": "3ce6a729b5d78b13283ddc6c529811f67519a62d", "target": 1, "func": "static CURLState *curl_init_state(BlockDriverState *bs, BDRVCURLState *s)\n\n{\n\n    CURLState *state = NULL;\n\n    int i, j;\n\n\n\n    do {\n\n        for (i=0; i<CURL_NUM_STATES; i++) {\n\n            for (j=0; j<CURL_NUM_ACB; j++)\n\n                if (s->states[i].acb[j])\n\n                    continue;\n\n            if (s->states[i].in_use)\n\n                continue;\n\n\n\n            state = &s->states[i];\n\n            state->in_use = 1;\n\n            break;\n\n        }\n\n        if (!state) {\n\n            qemu_mutex_unlock(&s->mutex);\n\n            aio_poll(bdrv_get_aio_context(bs), true);\n\n            qemu_mutex_lock(&s->mutex);\n\n        }\n\n    } while(!state);\n\n\n\n    if (!state->curl) {\n\n        state->curl = curl_easy_init();\n\n        if (!state->curl) {\n\n            return NULL;\n\n        }\n\n        curl_easy_setopt(state->curl, CURLOPT_URL, s->url);\n\n        curl_easy_setopt(state->curl, CURLOPT_SSL_VERIFYPEER,\n\n                         (long) s->sslverify);\n\n        if (s->cookie) {\n\n            curl_easy_setopt(state->curl, CURLOPT_COOKIE, s->cookie);\n\n        }\n\n        curl_easy_setopt(state->curl, CURLOPT_TIMEOUT, (long)s->timeout);\n\n        curl_easy_setopt(state->curl, CURLOPT_WRITEFUNCTION,\n\n                         (void *)curl_read_cb);\n\n        curl_easy_setopt(state->curl, CURLOPT_WRITEDATA, (void *)state);\n\n        curl_easy_setopt(state->curl, CURLOPT_PRIVATE, (void *)state);\n\n        curl_easy_setopt(state->curl, CURLOPT_AUTOREFERER, 1);\n\n        curl_easy_setopt(state->curl, CURLOPT_FOLLOWLOCATION, 1);\n\n        curl_easy_setopt(state->curl, CURLOPT_NOSIGNAL, 1);\n\n        curl_easy_setopt(state->curl, CURLOPT_ERRORBUFFER, state->errmsg);\n\n        curl_easy_setopt(state->curl, CURLOPT_FAILONERROR, 1);\n\n\n\n        if (s->username) {\n\n            curl_easy_setopt(state->curl, CURLOPT_USERNAME, s->username);\n\n        }\n\n        if (s->password) {\n\n            curl_easy_setopt(state->curl, CURLOPT_PASSWORD, s->password);\n\n        }\n\n        if (s->proxyusername) {\n\n            curl_easy_setopt(state->curl,\n\n                             CURLOPT_PROXYUSERNAME, s->proxyusername);\n\n        }\n\n        if (s->proxypassword) {\n\n            curl_easy_setopt(state->curl,\n\n                             CURLOPT_PROXYPASSWORD, s->proxypassword);\n\n        }\n\n\n\n        /* Restrict supported protocols to avoid security issues in the more\n\n         * obscure protocols.  For example, do not allow POP3/SMTP/IMAP see\n\n         * CVE-2013-0249.\n\n         *\n\n         * Restricting protocols is only supported from 7.19.4 upwards.\n\n         */\n\n#if LIBCURL_VERSION_NUM >= 0x071304\n\n        curl_easy_setopt(state->curl, CURLOPT_PROTOCOLS, PROTOCOLS);\n\n        curl_easy_setopt(state->curl, CURLOPT_REDIR_PROTOCOLS, PROTOCOLS);\n\n#endif\n\n\n\n#ifdef DEBUG_VERBOSE\n\n        curl_easy_setopt(state->curl, CURLOPT_VERBOSE, 1);\n\n#endif\n\n    }\n\n\n\n    QLIST_INIT(&state->sockets);\n\n    state->s = s;\n\n\n\n    return state;\n\n}\n", "idx": 24236}
{"project": "qemu", "commit_id": "a9c380db3b8c6af19546a68145c8d1438a09c92b", "target": 1, "func": "static int ssi_sd_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    SSISlave *ss = SSI_SLAVE(opaque);\n\n    ssi_sd_state *s = (ssi_sd_state *)opaque;\n\n    int i;\n\n\n\n    if (version_id != 1)\n\n\n\n\n    s->mode = qemu_get_be32(f);\n\n    s->cmd = qemu_get_be32(f);\n\n    for (i = 0; i < 4; i++)\n\n        s->cmdarg[i] = qemu_get_be32(f);\n\n    for (i = 0; i < 5; i++)\n\n        s->response[i] = qemu_get_be32(f);\n\n    s->arglen = qemu_get_be32(f);\n\n\n\n\n\n    s->response_pos = qemu_get_be32(f);\n\n    s->stopping = qemu_get_be32(f);\n\n\n\n\n\n\n\n\n    ss->cs = qemu_get_be32(f);\n\n\n\n    return 0;\n", "idx": 24237}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static inline uint8_t *ram_chunk_end(const RDMALocalBlock *rdma_ram_block,\n\n                                     uint64_t i)\n\n{\n\n    uint8_t *result = ram_chunk_start(rdma_ram_block, i) +\n\n                                         (1UL << RDMA_REG_CHUNK_SHIFT);\n\n\n\n    if (result > (rdma_ram_block->local_host_addr + rdma_ram_block->length)) {\n\n        result = rdma_ram_block->local_host_addr + rdma_ram_block->length;\n\n    }\n\n\n\n    return result;\n\n}\n", "idx": 24238}
{"project": "qemu", "commit_id": "d87aa138039a4be6d705793fd3e397c69c52405a", "target": 1, "func": "static int colo_packet_compare_udp(Packet *spkt, Packet *ppkt)\n\n{\n\n    int ret;\n\n    int network_header_length = ppkt->ip->ip_hl * 4;\n\n\n\n    trace_colo_compare_main(\"compare udp\");\n\n\n\n    /*\n\n     * Because of ppkt and spkt are both in the same connection,\n\n     * The ppkt's src ip, dst ip, src port, dst port, ip_proto all are\n\n     * same with spkt. In addition, IP header's Identification is a random\n\n     * field, we can handle it in IP fragmentation function later.\n\n     * COLO just concern the response net packet payload from primary guest\n\n     * and secondary guest are same or not, So we ignored all IP header include\n\n     * other field like TOS,TTL,IP Checksum. we only need to compare\n\n     * the ip payload here.\n\n     */\n\n    ret = colo_packet_compare_common(ppkt, spkt,\n\n                                     network_header_length + ETH_HLEN);\n\n\n\n    if (ret) {\n\n        trace_colo_compare_udp_miscompare(\"primary pkt size\", ppkt->size);\n\n        trace_colo_compare_udp_miscompare(\"Secondary pkt size\", spkt->size);\n\n        if (trace_event_get_state(TRACE_COLO_COMPARE_MISCOMPARE)) {\n\n            qemu_hexdump((char *)ppkt->data, stderr, \"colo-compare pri pkt\",\n\n                         ppkt->size);\n\n            qemu_hexdump((char *)spkt->data, stderr, \"colo-compare sec pkt\",\n\n                         spkt->size);\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 24243}
{"project": "qemu", "commit_id": "94ef4f337fb614f18b765a8e0e878a4c23cdedcd", "target": 1, "func": "void vga_mem_writeb(VGACommonState *s, hwaddr addr, uint32_t val)\n\n{\n\n    int memory_map_mode, plane, write_mode, b, func_select, mask;\n\n    uint32_t write_mask, bit_mask, set_mask;\n\n\n\n#ifdef DEBUG_VGA_MEM\n\n    printf(\"vga: [0x\" TARGET_FMT_plx \"] = 0x%02x\\n\", addr, val);\n\n#endif\n\n    /* convert to VGA memory offset */\n\n    memory_map_mode = (s->gr[VGA_GFX_MISC] >> 2) & 3;\n\n    addr &= 0x1ffff;\n\n    switch(memory_map_mode) {\n\n    case 0:\n\n        break;\n\n    case 1:\n\n        if (addr >= 0x10000)\n\n            return;\n\n        addr += s->bank_offset;\n\n        break;\n\n    case 2:\n\n        addr -= 0x10000;\n\n        if (addr >= 0x8000)\n\n            return;\n\n        break;\n\n    default:\n\n    case 3:\n\n        addr -= 0x18000;\n\n        if (addr >= 0x8000)\n\n            return;\n\n        break;\n\n    }\n\n\n\n    if (s->sr[VGA_SEQ_MEMORY_MODE] & VGA_SR04_CHN_4M) {\n\n        /* chain 4 mode : simplest access */\n\n        plane = addr & 3;\n\n        mask = (1 << plane);\n\n        if (s->sr[VGA_SEQ_PLANE_WRITE] & mask) {\n\n            assert(addr < s->vram_size);\n\n            s->vram_ptr[addr] = val;\n\n#ifdef DEBUG_VGA_MEM\n\n            printf(\"vga: chain4: [0x\" TARGET_FMT_plx \"]\\n\", addr);\n\n#endif\n\n            s->plane_updated |= mask; /* only used to detect font change */\n\n            memory_region_set_dirty(&s->vram, addr, 1);\n\n        }\n\n    } else if (s->gr[VGA_GFX_MODE] & 0x10) {\n\n        /* odd/even mode (aka text mode mapping) */\n\n        plane = (s->gr[VGA_GFX_PLANE_READ] & 2) | (addr & 1);\n\n        mask = (1 << plane);\n\n        if (s->sr[VGA_SEQ_PLANE_WRITE] & mask) {\n\n            addr = ((addr & ~1) << 1) | plane;\n\n            if (addr >= s->vram_size) {\n\n                return;\n\n            }\n\n            s->vram_ptr[addr] = val;\n\n#ifdef DEBUG_VGA_MEM\n\n            printf(\"vga: odd/even: [0x\" TARGET_FMT_plx \"]\\n\", addr);\n\n#endif\n\n            s->plane_updated |= mask; /* only used to detect font change */\n\n            memory_region_set_dirty(&s->vram, addr, 1);\n\n        }\n\n    } else {\n\n        /* standard VGA latched access */\n\n        write_mode = s->gr[VGA_GFX_MODE] & 3;\n\n        switch(write_mode) {\n\n        default:\n\n        case 0:\n\n            /* rotate */\n\n            b = s->gr[VGA_GFX_DATA_ROTATE] & 7;\n\n            val = ((val >> b) | (val << (8 - b))) & 0xff;\n\n            val |= val << 8;\n\n            val |= val << 16;\n\n\n\n            /* apply set/reset mask */\n\n            set_mask = mask16[s->gr[VGA_GFX_SR_ENABLE]];\n\n            val = (val & ~set_mask) |\n\n                (mask16[s->gr[VGA_GFX_SR_VALUE]] & set_mask);\n\n            bit_mask = s->gr[VGA_GFX_BIT_MASK];\n\n            break;\n\n        case 1:\n\n            val = s->latch;\n\n            goto do_write;\n\n        case 2:\n\n            val = mask16[val & 0x0f];\n\n            bit_mask = s->gr[VGA_GFX_BIT_MASK];\n\n            break;\n\n        case 3:\n\n            /* rotate */\n\n            b = s->gr[VGA_GFX_DATA_ROTATE] & 7;\n\n            val = (val >> b) | (val << (8 - b));\n\n\n\n            bit_mask = s->gr[VGA_GFX_BIT_MASK] & val;\n\n            val = mask16[s->gr[VGA_GFX_SR_VALUE]];\n\n            break;\n\n        }\n\n\n\n        /* apply logical operation */\n\n        func_select = s->gr[VGA_GFX_DATA_ROTATE] >> 3;\n\n        switch(func_select) {\n\n        case 0:\n\n        default:\n\n            /* nothing to do */\n\n            break;\n\n        case 1:\n\n            /* and */\n\n            val &= s->latch;\n\n            break;\n\n        case 2:\n\n            /* or */\n\n            val |= s->latch;\n\n            break;\n\n        case 3:\n\n            /* xor */\n\n            val ^= s->latch;\n\n            break;\n\n        }\n\n\n\n        /* apply bit mask */\n\n        bit_mask |= bit_mask << 8;\n\n        bit_mask |= bit_mask << 16;\n\n        val = (val & bit_mask) | (s->latch & ~bit_mask);\n\n\n\n    do_write:\n\n        /* mask data according to sr[2] */\n\n        mask = s->sr[VGA_SEQ_PLANE_WRITE];\n\n        s->plane_updated |= mask; /* only used to detect font change */\n\n        write_mask = mask16[mask];\n\n        if (addr * sizeof(uint32_t) >= s->vram_size) {\n\n            return;\n\n        }\n\n        ((uint32_t *)s->vram_ptr)[addr] =\n\n            (((uint32_t *)s->vram_ptr)[addr] & ~write_mask) |\n\n            (val & write_mask);\n\n#ifdef DEBUG_VGA_MEM\n\n        printf(\"vga: latch: [0x\" TARGET_FMT_plx \"] mask=0x%08x val=0x%08x\\n\",\n\n               addr * 4, write_mask, val);\n\n#endif\n\n        memory_region_set_dirty(&s->vram, addr << 2, sizeof(uint32_t));\n\n    }\n\n}\n", "idx": 24245}
{"project": "qemu", "commit_id": "52e38eb0512585a5fadb431a65997b602d44874b", "target": 1, "func": "build_dsdt(GArray *table_data, GArray *linker,\n\n           AcpiPmInfo *pm, AcpiMiscInfo *misc,\n\n           PcPciInfo *pci, MachineState *machine)\n\n{\n\n    CrsRangeEntry *entry;\n\n    Aml *dsdt, *sb_scope, *scope, *dev, *method, *field, *pkg, *crs;\n\n    GPtrArray *mem_ranges = g_ptr_array_new_with_free_func(crs_range_free);\n\n    GPtrArray *io_ranges = g_ptr_array_new_with_free_func(crs_range_free);\n\n    PCMachineState *pcms = PC_MACHINE(machine);\n\n    uint32_t nr_mem = machine->ram_slots;\n\n    int root_bus_limit = 0xFF;\n\n    PCIBus *bus = NULL;\n\n    int i;\n\n\n\n    dsdt = init_aml_allocator();\n\n\n\n    /* Reserve space for header */\n\n    acpi_data_push(dsdt->buf, sizeof(AcpiTableHeader));\n\n\n\n    build_dbg_aml(dsdt);\n\n    if (misc->is_piix4) {\n\n        sb_scope = aml_scope(\"_SB\");\n\n        dev = aml_device(\"PCI0\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A03\")));\n\n        aml_append(dev, aml_name_decl(\"_ADR\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"_UID\", aml_int(1)));\n\n        aml_append(sb_scope, dev);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        build_hpet_aml(dsdt);\n\n        build_piix4_pm(dsdt);\n\n        build_piix4_isa_bridge(dsdt);\n\n        build_isa_devices_aml(dsdt);\n\n        build_piix4_pci_hotplug(dsdt);\n\n        build_piix4_pci0_int(dsdt);\n\n    } else {\n\n        sb_scope = aml_scope(\"_SB\");\n\n        aml_append(sb_scope,\n\n            aml_operation_region(\"PCST\", AML_SYSTEM_IO, aml_int(0xae00), 0x0c));\n\n        aml_append(sb_scope,\n\n            aml_operation_region(\"PCSB\", AML_SYSTEM_IO, aml_int(0xae0c), 0x01));\n\n        field = aml_field(\"PCSB\", AML_ANY_ACC, AML_NOLOCK, AML_WRITE_AS_ZEROS);\n\n        aml_append(field, aml_named_field(\"PCIB\", 8));\n\n        aml_append(sb_scope, field);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        sb_scope = aml_scope(\"_SB\");\n\n        dev = aml_device(\"PCI0\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A08\")));\n\n        aml_append(dev, aml_name_decl(\"_CID\", aml_eisaid(\"PNP0A03\")));\n\n        aml_append(dev, aml_name_decl(\"_ADR\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"_UID\", aml_int(1)));\n\n        aml_append(dev, aml_name_decl(\"SUPP\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"CTRL\", aml_int(0)));\n\n        aml_append(dev, build_q35_osc_method());\n\n        aml_append(sb_scope, dev);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        build_hpet_aml(dsdt);\n\n        build_q35_isa_bridge(dsdt);\n\n        build_isa_devices_aml(dsdt);\n\n        build_q35_pci0_int(dsdt);\n\n    }\n\n\n\n    build_cpu_hotplug_aml(dsdt);\n\n    build_memory_hotplug_aml(dsdt, nr_mem, pm->mem_hp_io_base,\n\n                             pm->mem_hp_io_len);\n\n\n\n    scope =  aml_scope(\"_GPE\");\n\n    {\n\n        aml_append(scope, aml_name_decl(\"_HID\", aml_string(\"ACPI0006\")));\n\n\n\n        aml_append(scope, aml_method(\"_L00\", 0, AML_NOTSERIALIZED));\n\n\n\n        if (misc->is_piix4) {\n\n            method = aml_method(\"_E01\", 0, AML_NOTSERIALIZED);\n\n            aml_append(method,\n\n                aml_acquire(aml_name(\"\\\\_SB.PCI0.BLCK\"), 0xFFFF));\n\n            aml_append(method, aml_call0(\"\\\\_SB.PCI0.PCNT\"));\n\n            aml_append(method, aml_release(aml_name(\"\\\\_SB.PCI0.BLCK\")));\n\n            aml_append(scope, method);\n\n        } else {\n\n            aml_append(scope, aml_method(\"_L01\", 0, AML_NOTSERIALIZED));\n\n        }\n\n\n\n        method = aml_method(\"_E02\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_call0(\"\\\\_SB.\" CPU_SCAN_METHOD));\n\n        aml_append(scope, method);\n\n\n\n        method = aml_method(\"_E03\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_call0(MEMORY_HOTPLUG_HANDLER_PATH));\n\n        aml_append(scope, method);\n\n\n\n        aml_append(scope, aml_method(\"_L04\", 0, AML_NOTSERIALIZED));\n\n        aml_append(scope, aml_method(\"_L05\", 0, AML_NOTSERIALIZED));\n\n        aml_append(scope, aml_method(\"_L06\", 0, AML_NOTSERIALIZED));\n\n        aml_append(scope, aml_method(\"_L07\", 0, AML_NOTSERIALIZED));\n\n        aml_append(scope, aml_method(\"_L08\", 0, AML_NOTSERIALIZED));\n\n        aml_append(scope, aml_method(\"_L09\", 0, AML_NOTSERIALIZED));\n\n        aml_append(scope, aml_method(\"_L0A\", 0, AML_NOTSERIALIZED));\n\n        aml_append(scope, aml_method(\"_L0B\", 0, AML_NOTSERIALIZED));\n\n        aml_append(scope, aml_method(\"_L0C\", 0, AML_NOTSERIALIZED));\n\n        aml_append(scope, aml_method(\"_L0D\", 0, AML_NOTSERIALIZED));\n\n        aml_append(scope, aml_method(\"_L0E\", 0, AML_NOTSERIALIZED));\n\n        aml_append(scope, aml_method(\"_L0F\", 0, AML_NOTSERIALIZED));\n\n    }\n\n    aml_append(dsdt, scope);\n\n\n\n    bus = PC_MACHINE(machine)->bus;\n\n    if (bus) {\n\n        QLIST_FOREACH(bus, &bus->child, sibling) {\n\n            uint8_t bus_num = pci_bus_num(bus);\n\n            uint8_t numa_node = pci_bus_numa_node(bus);\n\n\n\n            /* look only for expander root buses */\n\n            if (!pci_bus_is_root(bus)) {\n\n                continue;\n\n            }\n\n\n\n            if (bus_num < root_bus_limit) {\n\n                root_bus_limit = bus_num - 1;\n\n            }\n\n\n\n            scope = aml_scope(\"\\\\_SB\");\n\n            dev = aml_device(\"PC%.02X\", bus_num);\n\n            aml_append(dev, aml_name_decl(\"_UID\", aml_int(bus_num)));\n\n            aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A03\")));\n\n            aml_append(dev, aml_name_decl(\"_BBN\", aml_int(bus_num)));\n\n\n\n            if (numa_node != NUMA_NODE_UNASSIGNED) {\n\n                aml_append(dev, aml_name_decl(\"_PXM\", aml_int(numa_node)));\n\n            }\n\n\n\n            aml_append(dev, build_prt(false));\n\n            crs = build_crs(PCI_HOST_BRIDGE(BUS(bus)->parent),\n\n                            io_ranges, mem_ranges);\n\n            aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n            aml_append(scope, dev);\n\n            aml_append(dsdt, scope);\n\n        }\n\n    }\n\n\n\n    scope = aml_scope(\"\\\\_SB.PCI0\");\n\n    /* build PCI0._CRS */\n\n    crs = aml_resource_template();\n\n    aml_append(crs,\n\n        aml_word_bus_number(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE,\n\n                            0x0000, 0x0, root_bus_limit,\n\n                            0x0000, root_bus_limit + 1));\n\n    aml_append(crs, aml_io(AML_DECODE16, 0x0CF8, 0x0CF8, 0x01, 0x08));\n\n\n\n    aml_append(crs,\n\n        aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,\n\n                    AML_POS_DECODE, AML_ENTIRE_RANGE,\n\n                    0x0000, 0x0000, 0x0CF7, 0x0000, 0x0CF8));\n\n\n\n    crs_replace_with_free_ranges(io_ranges, 0x0D00, 0xFFFF);\n\n    for (i = 0; i < io_ranges->len; i++) {\n\n        entry = g_ptr_array_index(io_ranges, i);\n\n        aml_append(crs,\n\n            aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,\n\n                        AML_POS_DECODE, AML_ENTIRE_RANGE,\n\n                        0x0000, entry->base, entry->limit,\n\n                        0x0000, entry->limit - entry->base + 1));\n\n    }\n\n\n\n    aml_append(crs,\n\n        aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                         AML_CACHEABLE, AML_READ_WRITE,\n\n                         0, 0x000A0000, 0x000BFFFF, 0, 0x00020000));\n\n\n\n    crs_replace_with_free_ranges(mem_ranges, pci->w32.begin, pci->w32.end - 1);\n\n    for (i = 0; i < mem_ranges->len; i++) {\n\n        entry = g_ptr_array_index(mem_ranges, i);\n\n        aml_append(crs,\n\n            aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                             AML_NON_CACHEABLE, AML_READ_WRITE,\n\n                             0, entry->base, entry->limit,\n\n                             0, entry->limit - entry->base + 1));\n\n    }\n\n\n\n    if (pci->w64.begin) {\n\n        aml_append(crs,\n\n            aml_qword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                             AML_CACHEABLE, AML_READ_WRITE,\n\n                             0, pci->w64.begin, pci->w64.end - 1, 0,\n\n                             pci->w64.end - pci->w64.begin));\n\n    }\n\n\n\n    if (misc->tpm_version != TPM_VERSION_UNSPEC) {\n\n        aml_append(crs, aml_memory32_fixed(TPM_TIS_ADDR_BASE,\n\n                   TPM_TIS_ADDR_SIZE, AML_READ_WRITE));\n\n    }\n\n    aml_append(scope, aml_name_decl(\"_CRS\", crs));\n\n\n\n    /* reserve GPE0 block resources */\n\n    dev = aml_device(\"GPE0\");\n\n    aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"PNP0A06\")));\n\n    aml_append(dev, aml_name_decl(\"_UID\", aml_string(\"GPE0 resources\")));\n\n    /* device present, functioning, decoding, not shown in UI */\n\n    aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n    crs = aml_resource_template();\n\n    aml_append(crs,\n\n        aml_io(AML_DECODE16, pm->gpe0_blk, pm->gpe0_blk, 1, pm->gpe0_blk_len)\n\n    );\n\n    aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n    aml_append(scope, dev);\n\n\n\n    g_ptr_array_free(io_ranges, true);\n\n    g_ptr_array_free(mem_ranges, true);\n\n\n\n    /* reserve PCIHP resources */\n\n    if (pm->pcihp_io_len) {\n\n        dev = aml_device(\"PHPR\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"PNP0A06\")));\n\n        aml_append(dev,\n\n            aml_name_decl(\"_UID\", aml_string(\"PCI Hotplug resources\")));\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, pm->pcihp_io_base, pm->pcihp_io_base, 1,\n\n                   pm->pcihp_io_len)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n        aml_append(scope, dev);\n\n    }\n\n    aml_append(dsdt, scope);\n\n\n\n    /*  create S3_ / S4_ / S5_ packages if necessary */\n\n    scope = aml_scope(\"\\\\\");\n\n    if (!pm->s3_disabled) {\n\n        pkg = aml_package(4);\n\n        aml_append(pkg, aml_int(1)); /* PM1a_CNT.SLP_TYP */\n\n        aml_append(pkg, aml_int(1)); /* PM1b_CNT.SLP_TYP, FIXME: not impl. */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(scope, aml_name_decl(\"_S3\", pkg));\n\n    }\n\n\n\n    if (!pm->s4_disabled) {\n\n        pkg = aml_package(4);\n\n        aml_append(pkg, aml_int(pm->s4_val)); /* PM1a_CNT.SLP_TYP */\n\n        /* PM1b_CNT.SLP_TYP, FIXME: not impl. */\n\n        aml_append(pkg, aml_int(pm->s4_val));\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(scope, aml_name_decl(\"_S4\", pkg));\n\n    }\n\n\n\n    pkg = aml_package(4);\n\n    aml_append(pkg, aml_int(0)); /* PM1a_CNT.SLP_TYP */\n\n    aml_append(pkg, aml_int(0)); /* PM1b_CNT.SLP_TYP not impl. */\n\n    aml_append(pkg, aml_int(0)); /* reserved */\n\n    aml_append(pkg, aml_int(0)); /* reserved */\n\n    aml_append(scope, aml_name_decl(\"_S5\", pkg));\n\n    aml_append(dsdt, scope);\n\n\n\n    /* create fw_cfg node, unconditionally */\n\n    {\n\n        /* when using port i/o, the 8-bit data register *always* overlaps\n\n         * with half of the 16-bit control register. Hence, the total size\n\n         * of the i/o region used is FW_CFG_CTL_SIZE; when using DMA, the\n\n         * DMA control register is located at FW_CFG_DMA_IO_BASE + 4 */\n\n        uint8_t io_size = object_property_get_bool(OBJECT(pcms->fw_cfg),\n\n                                                   \"dma_enabled\", NULL) ?\n\n                          ROUND_UP(FW_CFG_CTL_SIZE, 4) + sizeof(dma_addr_t) :\n\n                          FW_CFG_CTL_SIZE;\n\n\n\n        scope = aml_scope(\"\\\\_SB.PCI0\");\n\n        dev = aml_device(\"FWCF\");\n\n\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"QEMU0002\")));\n\n\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, FW_CFG_IO_BASE, FW_CFG_IO_BASE, 0x01, io_size)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    if (misc->applesmc_io_base) {\n\n        scope = aml_scope(\"\\\\_SB.PCI0.ISA\");\n\n        dev = aml_device(\"SMC\");\n\n\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"APP0001\")));\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, misc->applesmc_io_base, misc->applesmc_io_base,\n\n                   0x01, APPLESMC_MAX_DATA_LENGTH)\n\n        );\n\n        aml_append(crs, aml_irq_no_flags(6));\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    if (misc->pvpanic_port) {\n\n        scope = aml_scope(\"\\\\_SB.PCI0.ISA\");\n\n\n\n        dev = aml_device(\"PEVT\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"QEMU0001\")));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, misc->pvpanic_port, misc->pvpanic_port, 1, 1)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(dev, aml_operation_region(\"PEOR\", AML_SYSTEM_IO,\n\n                                              aml_int(misc->pvpanic_port), 1));\n\n        field = aml_field(\"PEOR\", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);\n\n        aml_append(field, aml_named_field(\"PEPT\", 8));\n\n        aml_append(dev, field);\n\n\n\n        /* device present, functioning, decoding, shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xF)));\n\n\n\n        method = aml_method(\"RDPT\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_store(aml_name(\"PEPT\"), aml_local(0)));\n\n        aml_append(method, aml_return(aml_local(0)));\n\n        aml_append(dev, method);\n\n\n\n        method = aml_method(\"WRPT\", 1, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_store(aml_arg(0), aml_name(\"PEPT\")));\n\n        aml_append(dev, method);\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    sb_scope = aml_scope(\"\\\\_SB\");\n\n    {\n\n        build_processor_devices(sb_scope, machine, pm);\n\n\n\n        build_memory_devices(sb_scope, nr_mem, pm->mem_hp_io_base,\n\n                             pm->mem_hp_io_len);\n\n\n\n        {\n\n            Object *pci_host;\n\n            PCIBus *bus = NULL;\n\n\n\n            pci_host = acpi_get_i386_pci_host();\n\n            if (pci_host) {\n\n                bus = PCI_HOST_BRIDGE(pci_host)->bus;\n\n            }\n\n\n\n            if (bus) {\n\n                Aml *scope = aml_scope(\"PCI0\");\n\n                /* Scan all PCI buses. Generate tables to support hotplug. */\n\n                build_append_pci_bus_devices(scope, bus, pm->pcihp_bridge_en);\n\n\n\n                if (misc->tpm_version != TPM_VERSION_UNSPEC) {\n\n                    dev = aml_device(\"ISA.TPM\");\n\n                    aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0C31\")));\n\n                    aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xF)));\n\n                    crs = aml_resource_template();\n\n                    aml_append(crs, aml_memory32_fixed(TPM_TIS_ADDR_BASE,\n\n                               TPM_TIS_ADDR_SIZE, AML_READ_WRITE));\n\n                    aml_append(crs, aml_irq_no_flags(TPM_TIS_IRQ));\n\n                    aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n                    aml_append(scope, dev);\n\n                }\n\n\n\n                aml_append(sb_scope, scope);\n\n            }\n\n        }\n\n        aml_append(dsdt, sb_scope);\n\n    }\n\n\n\n    /* copy AML table into ACPI tables blob and patch header there */\n\n    g_array_append_vals(table_data, dsdt->buf->data, dsdt->buf->len);\n\n    build_header(linker, table_data,\n\n        (void *)(table_data->data + table_data->len - dsdt->buf->len),\n\n        \"DSDT\", dsdt->buf->len, 1, NULL, NULL);\n\n    free_aml_allocator();\n\n}\n", "idx": 24254}
{"project": "qemu", "commit_id": "d65aaf3773e4be7ae97df9d867cbe9b36e2fb8a1", "target": 1, "func": "static void print_pte(Monitor *mon, uint32_t addr, uint32_t pte, uint32_t mask)\n\n{\n\n    monitor_printf(mon, \"%08x: %08x %c%c%c%c%c%c%c%c\\n\",\n\n                   addr,\n\n                   pte & mask,\n\n                   pte & PG_GLOBAL_MASK ? 'G' : '-',\n\n                   pte & PG_PSE_MASK ? 'P' : '-',\n\n                   pte & PG_DIRTY_MASK ? 'D' : '-',\n\n                   pte & PG_ACCESSED_MASK ? 'A' : '-',\n\n                   pte & PG_PCD_MASK ? 'C' : '-',\n\n                   pte & PG_PWT_MASK ? 'T' : '-',\n\n                   pte & PG_USER_MASK ? 'U' : '-',\n\n                   pte & PG_RW_MASK ? 'W' : '-');\n\n}\n", "idx": 24257}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_load_exclusive(DisasContext *s, int rt, int rt2,\n\n                               TCGv addr, int size)\n\n{\n\n    TCGv tmp;\n\n\n\n    switch (size) {\n\n    case 0:\n\n        tmp = gen_ld8u(addr, IS_USER(s));\n\n        break;\n\n    case 1:\n\n        tmp = gen_ld16u(addr, IS_USER(s));\n\n        break;\n\n    case 2:\n\n    case 3:\n\n        tmp = gen_ld32(addr, IS_USER(s));\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    tcg_gen_mov_i32(cpu_exclusive_val, tmp);\n\n    store_reg(s, rt, tmp);\n\n    if (size == 3) {\n\n        TCGv tmp2 = new_tmp();\n\n        tcg_gen_addi_i32(tmp2, addr, 4);\n\n        tmp = gen_ld32(tmp2, IS_USER(s));\n\n        dead_tmp(tmp2);\n\n        tcg_gen_mov_i32(cpu_exclusive_high, tmp);\n\n        store_reg(s, rt2, tmp);\n\n    }\n\n    tcg_gen_mov_i32(cpu_exclusive_addr, addr);\n\n}\n", "idx": 24260}
{"project": "qemu", "commit_id": "1fd959466574c3d46f4898f2e27cd3b1060338e4", "target": 1, "func": "static inline void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args,\n\n                              const int *const_args)\n\n{\n\n    int c;\n\n\n\n    switch (opc) {\n\n    case INDEX_op_exit_tb:\n\n        tcg_out_movi(s, TCG_TYPE_PTR, TCG_REG_I0, args[0]);\n\n        tcg_out32(s, JMPL | INSN_RD(TCG_REG_G0) | INSN_RS1(TCG_REG_I7) |\n\n                  INSN_IMM13(8));\n\n        tcg_out32(s, RESTORE | INSN_RD(TCG_REG_G0) | INSN_RS1(TCG_REG_G0) |\n\n                      INSN_RS2(TCG_REG_G0));\n\n        break;\n\n    case INDEX_op_goto_tb:\n\n        if (s->tb_jmp_offset) {\n\n            /* direct jump method */\n\n            tcg_out_sethi(s, TCG_REG_I5, args[0] & 0xffffe000);\n\n            tcg_out32(s, JMPL | INSN_RD(TCG_REG_G0) | INSN_RS1(TCG_REG_I5) |\n\n                      INSN_IMM13((args[0] & 0x1fff)));\n\n            s->tb_jmp_offset[args[0]] = s->code_ptr - s->code_buf;\n\n        } else {\n\n            /* indirect jump method */\n\n            tcg_out_ld_ptr(s, TCG_REG_I5, (tcg_target_long)(s->tb_next + args[0]));\n\n            tcg_out32(s, JMPL | INSN_RD(TCG_REG_G0) | INSN_RS1(TCG_REG_I5) |\n\n                      INSN_RS2(TCG_REG_G0));\n\n        }\n\n        tcg_out_nop(s);\n\n        s->tb_next_offset[args[0]] = s->code_ptr - s->code_buf;\n\n        break;\n\n    case INDEX_op_call:\n\n        if (const_args[0])\n\n            tcg_out32(s, CALL | ((((tcg_target_ulong)args[0]\n\n                                   - (tcg_target_ulong)s->code_ptr) >> 2)\n\n                                 & 0x3fffffff));\n\n        else {\n\n            tcg_out_ld_ptr(s, TCG_REG_I5,\n\n                           (tcg_target_long)(s->tb_next + args[0]));\n\n            tcg_out32(s, JMPL | INSN_RD(TCG_REG_O7) | INSN_RS1(TCG_REG_I5) |\n\n                      INSN_RS2(TCG_REG_G0));\n\n        }\n\n        /* delay slot */\n\n        tcg_out_nop(s);\n\n        break;\n\n    case INDEX_op_jmp:\n\n    case INDEX_op_br:\n\n        tcg_out_branch_i32(s, COND_A, args[0]);\n\n        tcg_out_nop(s);\n\n        break;\n\n    case INDEX_op_movi_i32:\n\n        tcg_out_movi(s, TCG_TYPE_I32, args[0], (uint32_t)args[1]);\n\n        break;\n\n\n\n#if TCG_TARGET_REG_BITS == 64\n\n#define OP_32_64(x)                             \\\n\n        glue(glue(case INDEX_op_, x), _i32):    \\\n\n        glue(glue(case INDEX_op_, x), _i64)\n\n#else\n\n#define OP_32_64(x)                             \\\n\n        glue(glue(case INDEX_op_, x), _i32)\n\n#endif\n\n    OP_32_64(ld8u):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDUB);\n\n        break;\n\n    OP_32_64(ld8s):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDSB);\n\n        break;\n\n    OP_32_64(ld16u):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDUH);\n\n        break;\n\n    OP_32_64(ld16s):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDSH);\n\n        break;\n\n    case INDEX_op_ld_i32:\n\n#if TCG_TARGET_REG_BITS == 64\n\n    case INDEX_op_ld32u_i64:\n\n#endif\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDUW);\n\n        break;\n\n    OP_32_64(st8):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], STB);\n\n        break;\n\n    OP_32_64(st16):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], STH);\n\n        break;\n\n    case INDEX_op_st_i32:\n\n#if TCG_TARGET_REG_BITS == 64\n\n    case INDEX_op_st32_i64:\n\n#endif\n\n        tcg_out_ldst(s, args[0], args[1], args[2], STW);\n\n        break;\n\n    OP_32_64(add):\n\n        c = ARITH_ADD;\n\n        goto gen_arith;\n\n    OP_32_64(sub):\n\n        c = ARITH_SUB;\n\n        goto gen_arith;\n\n    OP_32_64(and):\n\n        c = ARITH_AND;\n\n        goto gen_arith;\n\n    OP_32_64(andc):\n\n        c = ARITH_ANDN;\n\n        goto gen_arith;\n\n    OP_32_64(or):\n\n        c = ARITH_OR;\n\n        goto gen_arith;\n\n    OP_32_64(orc):\n\n        c = ARITH_ORN;\n\n        goto gen_arith;\n\n    OP_32_64(xor):\n\n        c = ARITH_XOR;\n\n        goto gen_arith;\n\n    case INDEX_op_shl_i32:\n\n        c = SHIFT_SLL;\n\n        goto gen_arith;\n\n    case INDEX_op_shr_i32:\n\n        c = SHIFT_SRL;\n\n        goto gen_arith;\n\n    case INDEX_op_sar_i32:\n\n        c = SHIFT_SRA;\n\n        goto gen_arith;\n\n    case INDEX_op_mul_i32:\n\n        c = ARITH_UMUL;\n\n        goto gen_arith;\n\n\n\n    OP_32_64(neg):\n\n\tc = ARITH_SUB;\n\n\tgoto gen_arith1;\n\n    OP_32_64(not):\n\n\tc = ARITH_ORN;\n\n\tgoto gen_arith1;\n\n\n\n    case INDEX_op_div_i32:\n\n        tcg_out_div32(s, args[0], args[1], args[2], const_args[2], 0);\n\n        break;\n\n    case INDEX_op_divu_i32:\n\n        tcg_out_div32(s, args[0], args[1], args[2], const_args[2], 1);\n\n        break;\n\n\n\n    case INDEX_op_rem_i32:\n\n    case INDEX_op_remu_i32:\n\n        tcg_out_div32(s, TCG_REG_I5, args[1], args[2], const_args[2],\n\n                      opc == INDEX_op_remu_i32);\n\n        tcg_out_arithc(s, TCG_REG_I5, TCG_REG_I5, args[2], const_args[2],\n\n                       ARITH_UMUL);\n\n        tcg_out_arith(s, args[0], args[1], TCG_REG_I5, ARITH_SUB);\n\n        break;\n\n\n\n    case INDEX_op_brcond_i32:\n\n        tcg_out_brcond_i32(s, args[2], args[0], args[1], const_args[1],\n\n                           args[3]);\n\n        break;\n\n    case INDEX_op_setcond_i32:\n\n        tcg_out_setcond_i32(s, args[3], args[0], args[1],\n\n                            args[2], const_args[2]);\n\n        break;\n\n\n\n#if TCG_TARGET_REG_BITS == 32\n\n    case INDEX_op_brcond2_i32:\n\n        tcg_out_brcond2_i32(s, args[4], args[0], args[1],\n\n                            args[2], const_args[2],\n\n                            args[3], const_args[3], args[5]);\n\n        break;\n\n    case INDEX_op_setcond2_i32:\n\n        tcg_out_setcond2_i32(s, args[5], args[0], args[1], args[2],\n\n                             args[3], const_args[3],\n\n                             args[4], const_args[4]);\n\n        break;\n\n    case INDEX_op_add2_i32:\n\n        tcg_out_arithc(s, args[0], args[2], args[4], const_args[4],\n\n                       ARITH_ADDCC);\n\n        tcg_out_arithc(s, args[1], args[3], args[5], const_args[5],\n\n                       ARITH_ADDX);\n\n        break;\n\n    case INDEX_op_sub2_i32:\n\n        tcg_out_arithc(s, args[0], args[2], args[4], const_args[4],\n\n                       ARITH_SUBCC);\n\n        tcg_out_arithc(s, args[1], args[3], args[5], const_args[5],\n\n                       ARITH_SUBX);\n\n        break;\n\n    case INDEX_op_mulu2_i32:\n\n        tcg_out_arithc(s, args[0], args[2], args[3], const_args[3],\n\n                       ARITH_UMUL);\n\n        tcg_out_rdy(s, args[1]);\n\n        break;\n\n#endif\n\n\n\n    case INDEX_op_qemu_ld8u:\n\n        tcg_out_qemu_ld(s, args, 0);\n\n        break;\n\n    case INDEX_op_qemu_ld8s:\n\n        tcg_out_qemu_ld(s, args, 0 | 4);\n\n        break;\n\n    case INDEX_op_qemu_ld16u:\n\n        tcg_out_qemu_ld(s, args, 1);\n\n        break;\n\n    case INDEX_op_qemu_ld16s:\n\n        tcg_out_qemu_ld(s, args, 1 | 4);\n\n        break;\n\n    case INDEX_op_qemu_ld32:\n\n#if TCG_TARGET_REG_BITS == 64\n\n    case INDEX_op_qemu_ld32u:\n\n#endif\n\n        tcg_out_qemu_ld(s, args, 2);\n\n        break;\n\n#if TCG_TARGET_REG_BITS == 64\n\n    case INDEX_op_qemu_ld32s:\n\n        tcg_out_qemu_ld(s, args, 2 | 4);\n\n        break;\n\n#endif\n\n    case INDEX_op_qemu_ld64:\n\n        tcg_out_qemu_ld(s, args, 3);\n\n        break;\n\n    case INDEX_op_qemu_st8:\n\n        tcg_out_qemu_st(s, args, 0);\n\n        break;\n\n    case INDEX_op_qemu_st16:\n\n        tcg_out_qemu_st(s, args, 1);\n\n        break;\n\n    case INDEX_op_qemu_st32:\n\n        tcg_out_qemu_st(s, args, 2);\n\n        break;\n\n    case INDEX_op_qemu_st64:\n\n        tcg_out_qemu_st(s, args, 3);\n\n        break;\n\n\n\n#if TCG_TARGET_REG_BITS == 64\n\n    case INDEX_op_movi_i64:\n\n        tcg_out_movi(s, TCG_TYPE_I64, args[0], args[1]);\n\n        break;\n\n    case INDEX_op_ld32s_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDSW);\n\n        break;\n\n    case INDEX_op_ld_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDX);\n\n        break;\n\n    case INDEX_op_st_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], STX);\n\n        break;\n\n    case INDEX_op_shl_i64:\n\n        c = SHIFT_SLLX;\n\n        goto gen_arith;\n\n    case INDEX_op_shr_i64:\n\n        c = SHIFT_SRLX;\n\n        goto gen_arith;\n\n    case INDEX_op_sar_i64:\n\n        c = SHIFT_SRAX;\n\n        goto gen_arith;\n\n    case INDEX_op_mul_i64:\n\n        c = ARITH_MULX;\n\n        goto gen_arith;\n\n    case INDEX_op_div_i64:\n\n        c = ARITH_SDIVX;\n\n        goto gen_arith;\n\n    case INDEX_op_divu_i64:\n\n        c = ARITH_UDIVX;\n\n        goto gen_arith;\n\n    case INDEX_op_rem_i64:\n\n    case INDEX_op_remu_i64:\n\n        tcg_out_arithc(s, TCG_REG_I5, args[1], args[2], const_args[2],\n\n                       opc == INDEX_op_rem_i64 ? ARITH_SDIVX : ARITH_UDIVX);\n\n        tcg_out_arithc(s, TCG_REG_I5, TCG_REG_I5, args[2], const_args[2],\n\n                       ARITH_MULX);\n\n        tcg_out_arith(s, args[0], args[1], TCG_REG_I5, ARITH_SUB);\n\n        break;\n\n    case INDEX_op_ext32s_i64:\n\n        if (const_args[1]) {\n\n            tcg_out_movi(s, TCG_TYPE_I64, args[0], (int32_t)args[1]);\n\n        } else {\n\n            tcg_out_arithi(s, args[0], args[1], 0, SHIFT_SRA);\n\n        }\n\n        break;\n\n    case INDEX_op_ext32u_i64:\n\n        if (const_args[1]) {\n\n            tcg_out_movi_imm32(s, args[0], args[1]);\n\n        } else {\n\n            tcg_out_arithi(s, args[0], args[1], 0, SHIFT_SRL);\n\n        }\n\n        break;\n\n\n\n    case INDEX_op_brcond_i64:\n\n        tcg_out_brcond_i64(s, args[2], args[0], args[1], const_args[1],\n\n                           args[3]);\n\n        break;\n\n    case INDEX_op_setcond_i64:\n\n        tcg_out_setcond_i64(s, args[3], args[0], args[1],\n\n                            args[2], const_args[2]);\n\n        break;\n\n\n\n#endif\n\n    gen_arith:\n\n        tcg_out_arithc(s, args[0], args[1], args[2], const_args[2], c);\n\n        break;\n\n\n\n    gen_arith1:\n\n\ttcg_out_arithc(s, args[0], TCG_REG_G0, args[1], const_args[1], c);\n\n\tbreak;\n\n\n\n    default:\n\n        fprintf(stderr, \"unknown opcode 0x%x\\n\", opc);\n\n        tcg_abort();\n\n    }\n\n}\n", "idx": 24262}
{"project": "qemu", "commit_id": "4a41a2d68a684241aca96dba066e0699941b730d", "target": 1, "func": "void nbd_client_session_close(NbdClientSession *client)\n\n{\n\n    if (!client->bs) {\n\n        return;\n\n    }\n\n\n\n    nbd_teardown_connection(client);\n\n    client->bs = NULL;\n\n}\n", "idx": 24264}
{"project": "qemu", "commit_id": "fff39a7ad09da07ef490de05c92c91f22f8002f2", "target": 1, "func": "static void v9fs_rename(void *opaque)\n{\n    int32_t fid;\n    ssize_t err = 0;\n    size_t offset = 7;\n    V9fsString name;\n    int32_t newdirfid;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dds\", &fid, &newdirfid, &name);\n    if (err < 0) {\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n    BUG_ON(fidp->fid_type != P9_FID_NONE);\n    /* if fs driver is not path based, return EOPNOTSUPP */\n    if (!(pdu->s->ctx.export_flags & V9FS_PATHNAME_FSCONTEXT)) {\n        err = -EOPNOTSUPP;\n        goto out;\n    v9fs_path_write_lock(s);\n    err = v9fs_complete_rename(pdu, fidp, newdirfid, &name);\n    v9fs_path_unlock(s);\n    if (!err) {\n        err = offset;\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);", "idx": 24265}
{"project": "qemu", "commit_id": "6e72719e721a40fe1224701ca10edc1caf0cd708", "target": 1, "func": "int qemu_pixman_get_type(int rshift, int gshift, int bshift)\n\n{\n\n    int type = PIXMAN_TYPE_OTHER;\n\n\n\n    if (rshift > gshift && gshift > bshift) {\n\n        if (bshift == 0) {\n\n            type = PIXMAN_TYPE_ARGB;\n\n        } else {\n\n\n            type = PIXMAN_TYPE_RGBA;\n\n\n        }\n\n    } else if (rshift < gshift && gshift < bshift) {\n\n        if (rshift == 0) {\n\n            type = PIXMAN_TYPE_ABGR;\n\n        } else {\n\n\n            type = PIXMAN_TYPE_BGRA;\n\n\n        }\n\n    }\n\n    return type;\n\n}", "idx": 24274}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static int prom_init1(SysBusDevice *dev)\n\n{\n\n    PROMState *s = OPENPROM(dev);\n\n\n\n    memory_region_init_ram(&s->prom, OBJECT(s), \"sun4m.prom\", PROM_SIZE_MAX,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->prom);\n\n    memory_region_set_readonly(&s->prom, true);\n\n    sysbus_init_mmio(dev, &s->prom);\n\n    return 0;\n\n}\n", "idx": 24275}
{"project": "qemu", "commit_id": "488661ee9dd300110a6612d52fe68e2bb3539a5f", "target": 1, "func": "void helper_lswx(CPUPPCState *env, target_ulong addr, uint32_t reg,\n\n                 uint32_t ra, uint32_t rb)\n\n{\n\n    if (likely(xer_bc != 0)) {\n\n        if (unlikely((ra != 0 && reg < ra && (reg + xer_bc) > ra) ||\n\n                     (reg < rb && (reg + xer_bc) > rb))) {\n\n            helper_raise_exception_err(env, POWERPC_EXCP_PROGRAM,\n\n                                       POWERPC_EXCP_INVAL |\n\n                                       POWERPC_EXCP_INVAL_LSWX);\n\n        } else {\n\n            helper_lsw(env, addr, xer_bc, reg);\n\n        }\n\n    }\n\n}\n", "idx": 24276}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "mips_mipssim_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    char *filename;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *isa = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *bios = g_new(MemoryRegion, 1);\n\n    MIPSCPU *cpu;\n\n    CPUMIPSState *env;\n\n    ResetData *reset_info;\n\n    int bios_size;\n\n\n\n    /* Init CPUs. */\n\n    if (cpu_model == NULL) {\n\n#ifdef TARGET_MIPS64\n\n        cpu_model = \"5Kf\";\n\n#else\n\n        cpu_model = \"24Kf\";\n\n#endif\n\n    }\n\n    cpu = cpu_mips_init(cpu_model);\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    reset_info = g_malloc0(sizeof(ResetData));\n\n    reset_info->cpu = cpu;\n\n    reset_info->vector = env->active_tc.PC;\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n\n\n    /* Allocate RAM. */\n\n    memory_region_allocate_system_memory(ram, NULL, \"mips_mipssim.ram\",\n\n                                         ram_size);\n\n    memory_region_init_ram(bios, NULL, \"mips_mipssim.bios\", BIOS_SIZE,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(bios);\n\n    memory_region_set_readonly(bios, true);\n\n\n\n    memory_region_add_subregion(address_space_mem, 0, ram);\n\n\n\n    /* Map the BIOS / boot exception handler. */\n\n    memory_region_add_subregion(address_space_mem, 0x1fc00000LL, bios);\n\n    /* Load a BIOS / boot exception handler image. */\n\n    if (bios_name == NULL)\n\n        bios_name = BIOS_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    if (filename) {\n\n        bios_size = load_image_targphys(filename, 0x1fc00000LL, BIOS_SIZE);\n\n        g_free(filename);\n\n    } else {\n\n        bios_size = -1;\n\n    }\n\n    if ((bios_size < 0 || bios_size > BIOS_SIZE) &&\n\n        !kernel_filename && !qtest_enabled()) {\n\n        /* Bail out if we have neither a kernel image nor boot vector code. */\n\n        error_report(\"Could not load MIPS bios '%s', and no \"\n\n                     \"-kernel argument was specified\", bios_name);\n\n        exit(1);\n\n    } else {\n\n        /* We have a boot vector start address. */\n\n        env->active_tc.PC = (target_long)(int32_t)0xbfc00000;\n\n    }\n\n\n\n    if (kernel_filename) {\n\n        loaderparams.ram_size = ram_size;\n\n        loaderparams.kernel_filename = kernel_filename;\n\n        loaderparams.kernel_cmdline = kernel_cmdline;\n\n        loaderparams.initrd_filename = initrd_filename;\n\n        reset_info->vector = load_kernel();\n\n    }\n\n\n\n    /* Init CPU internal devices. */\n\n    cpu_mips_irq_init_cpu(env);\n\n    cpu_mips_clock_init(env);\n\n\n\n    /* Register 64 KB of ISA IO space at 0x1fd00000. */\n\n    memory_region_init_alias(isa, NULL, \"isa_mmio\",\n\n                             get_system_io(), 0, 0x00010000);\n\n    memory_region_add_subregion(get_system_memory(), 0x1fd00000, isa);\n\n\n\n    /* A single 16450 sits at offset 0x3f8. It is attached to\n\n       MIPS CPU INT2, which is interrupt 4. */\n\n    if (serial_hds[0])\n\n        serial_init(0x3f8, env->irq[4], 115200, serial_hds[0],\n\n                    get_system_io());\n\n\n\n    if (nd_table[0].used)\n\n        /* MIPSnet uses the MIPS CPU INT0, which is interrupt 2. */\n\n        mipsnet_init(0x4200, env->irq[2], &nd_table[0]);\n\n}\n", "idx": 24278}
{"project": "qemu", "commit_id": "794cbc26eb94ce13c75d105eea9ff0afff56e2c2", "target": 1, "func": "SDState *sd_init(BlockDriverState *bs, bool is_spi)\n\n{\n\n    SDState *sd;\n\n\n\n    if (bdrv_is_read_only(bs)) {\n\n        fprintf(stderr, \"sd_init: Cannot use read-only drive\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    sd = (SDState *) g_malloc0(sizeof(SDState));\n\n    sd->buf = qemu_blockalign(bs, 512);\n\n    sd->spi = is_spi;\n\n    sd->enable = true;\n\n    sd_reset(sd, bs);\n\n    if (sd->bdrv) {\n\n        bdrv_attach_dev_nofail(sd->bdrv, sd);\n\n        bdrv_set_dev_ops(sd->bdrv, &sd_block_ops, sd);\n\n    }\n\n    vmstate_register(NULL, -1, &sd_vmstate, sd);\n\n    return sd;\n\n}\n", "idx": 24279}
{"project": "qemu", "commit_id": "f2b58c43758efc61e2a49b899f5e58848489d0dc", "target": 1, "func": "int v9fs_device_realize_common(V9fsState *s, Error **errp)\n\n{\n\n    int i, len;\n\n    struct stat stat;\n\n    FsDriverEntry *fse;\n\n    V9fsPath path;\n\n    int rc = 1;\n\n\n\n    /* initialize pdu allocator */\n\n    QLIST_INIT(&s->free_list);\n\n    QLIST_INIT(&s->active_list);\n\n    for (i = 0; i < (MAX_REQ - 1); i++) {\n\n        QLIST_INSERT_HEAD(&s->free_list, &s->pdus[i], next);\n\n        s->pdus[i].s = s;\n\n        s->pdus[i].idx = i;\n\n    }\n\n\n\n    v9fs_path_init(&path);\n\n\n\n    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);\n\n\n\n    if (!fse) {\n\n        /* We don't have a fsdev identified by fsdev_id */\n\n        error_setg(errp, \"9pfs device couldn't find fsdev with the \"\n\n                   \"id = %s\",\n\n                   s->fsconf.fsdev_id ? s->fsconf.fsdev_id : \"NULL\");\n\n        goto out;\n\n    }\n\n\n\n    if (!s->fsconf.tag) {\n\n        /* we haven't specified a mount_tag */\n\n        error_setg(errp, \"fsdev with id %s needs mount_tag arguments\",\n\n                   s->fsconf.fsdev_id);\n\n        goto out;\n\n    }\n\n\n\n    s->ctx.export_flags = fse->export_flags;\n\n    s->ctx.fs_root = g_strdup(fse->path);\n\n    s->ctx.exops.get_st_gen = NULL;\n\n    len = strlen(s->fsconf.tag);\n\n    if (len > MAX_TAG_LEN - 1) {\n\n        error_setg(errp, \"mount tag '%s' (%d bytes) is longer than \"\n\n                   \"maximum (%d bytes)\", s->fsconf.tag, len, MAX_TAG_LEN - 1);\n\n        goto out;\n\n    }\n\n\n\n    s->tag = g_strdup(s->fsconf.tag);\n\n    s->ctx.uid = -1;\n\n\n\n    s->ops = fse->ops;\n\n\n\n    s->fid_list = NULL;\n\n    qemu_co_rwlock_init(&s->rename_lock);\n\n\n\n    if (s->ops->init(&s->ctx) < 0) {\n\n        error_setg(errp, \"9pfs Failed to initialize fs-driver with id:%s\"\n\n                   \" and export path:%s\", s->fsconf.fsdev_id, s->ctx.fs_root);\n\n        goto out;\n\n    }\n\n\n\n    /*\n\n     * Check details of export path, We need to use fs driver\n\n     * call back to do that. Since we are in the init path, we don't\n\n     * use co-routines here.\n\n     */\n\n    if (s->ops->name_to_path(&s->ctx, NULL, \"/\", &path) < 0) {\n\n        error_setg(errp,\n\n                   \"error in converting name to path %s\", strerror(errno));\n\n        goto out;\n\n    }\n\n    if (s->ops->lstat(&s->ctx, &path, &stat)) {\n\n        error_setg(errp, \"share path %s does not exist\", fse->path);\n\n        goto out;\n\n    } else if (!S_ISDIR(stat.st_mode)) {\n\n        error_setg(errp, \"share path %s is not a directory\", fse->path);\n\n        goto out;\n\n    }\n\n    v9fs_path_free(&path);\n\n\n\n    rc = 0;\n\nout:\n\n    if (rc) {\n\n        if (s->ops->cleanup && s->ctx.private) {\n\n            s->ops->cleanup(&s->ctx);\n\n        }\n\n        g_free(s->tag);\n\n        g_free(s->ctx.fs_root);\n\n        v9fs_path_free(&path);\n\n    }\n\n    return rc;\n\n}\n", "idx": 24280}
{"project": "qemu", "commit_id": "546a7dc40e8b8b6440a052e2b5cdfe9aadcaccf6", "target": 1, "func": "static coroutine_fn int qcow2_co_preadv(BlockDriverState *bs, uint64_t offset,\n\n                                        uint64_t bytes, QEMUIOVector *qiov,\n\n                                        int flags)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int offset_in_cluster, n1;\n\n    int ret;\n\n    unsigned int cur_bytes; /* number of bytes in current iteration */\n\n    uint64_t cluster_offset = 0;\n\n    uint64_t bytes_done = 0;\n\n    QEMUIOVector hd_qiov;\n\n    uint8_t *cluster_data = NULL;\n\n\n\n    qemu_iovec_init(&hd_qiov, qiov->niov);\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (bytes != 0) {\n\n\n\n        /* prepare next request */\n\n        cur_bytes = MIN(bytes, INT_MAX);\n\n        if (s->crypto) {\n\n            cur_bytes = MIN(cur_bytes,\n\n                            QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);\n\n        }\n\n\n\n        ret = qcow2_get_cluster_offset(bs, offset, &cur_bytes, &cluster_offset);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        offset_in_cluster = offset_into_cluster(s, offset);\n\n\n\n        qemu_iovec_reset(&hd_qiov);\n\n        qemu_iovec_concat(&hd_qiov, qiov, bytes_done, cur_bytes);\n\n\n\n        switch (ret) {\n\n        case QCOW2_CLUSTER_UNALLOCATED:\n\n\n\n            if (bs->backing) {\n\n                /* read from the base image */\n\n                n1 = qcow2_backing_read1(bs->backing->bs, &hd_qiov,\n\n                                         offset, cur_bytes);\n\n                if (n1 > 0) {\n\n                    QEMUIOVector local_qiov;\n\n\n\n                    qemu_iovec_init(&local_qiov, hd_qiov.niov);\n\n                    qemu_iovec_concat(&local_qiov, &hd_qiov, 0, n1);\n\n\n\n                    BLKDBG_EVENT(bs->file, BLKDBG_READ_BACKING_AIO);\n\n                    qemu_co_mutex_unlock(&s->lock);\n\n                    ret = bdrv_co_preadv(bs->backing, offset, n1,\n\n                                         &local_qiov, 0);\n\n                    qemu_co_mutex_lock(&s->lock);\n\n\n\n                    qemu_iovec_destroy(&local_qiov);\n\n\n\n                    if (ret < 0) {\n\n                        goto fail;\n\n                    }\n\n                }\n\n            } else {\n\n                /* Note: in this case, no need to wait */\n\n                qemu_iovec_memset(&hd_qiov, 0, 0, cur_bytes);\n\n            }\n\n            break;\n\n\n\n        case QCOW2_CLUSTER_ZERO_PLAIN:\n\n        case QCOW2_CLUSTER_ZERO_ALLOC:\n\n            qemu_iovec_memset(&hd_qiov, 0, 0, cur_bytes);\n\n            break;\n\n\n\n        case QCOW2_CLUSTER_COMPRESSED:\n\n            /* add AIO support for compressed blocks ? */\n\n            ret = qcow2_decompress_cluster(bs, cluster_offset);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            qemu_iovec_from_buf(&hd_qiov, 0,\n\n                                s->cluster_cache + offset_in_cluster,\n\n                                cur_bytes);\n\n            break;\n\n\n\n        case QCOW2_CLUSTER_NORMAL:\n\n            if ((cluster_offset & 511) != 0) {\n\n                ret = -EIO;\n\n                goto fail;\n\n            }\n\n\n\n            if (bs->encrypted) {\n\n                assert(s->crypto);\n\n\n\n                /*\n\n                 * For encrypted images, read everything into a temporary\n\n                 * contiguous buffer on which the AES functions can work.\n\n                 */\n\n                if (!cluster_data) {\n\n                    cluster_data =\n\n                        qemu_try_blockalign(bs->file->bs,\n\n                                            QCOW_MAX_CRYPT_CLUSTERS\n\n                                            * s->cluster_size);\n\n                    if (cluster_data == NULL) {\n\n                        ret = -ENOMEM;\n\n                        goto fail;\n\n                    }\n\n                }\n\n\n\n                assert(cur_bytes <= QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);\n\n                qemu_iovec_reset(&hd_qiov);\n\n                qemu_iovec_add(&hd_qiov, cluster_data, cur_bytes);\n\n            }\n\n\n\n            BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            ret = bdrv_co_preadv(bs->file,\n\n                                 cluster_offset + offset_in_cluster,\n\n                                 cur_bytes, &hd_qiov, 0);\n\n            qemu_co_mutex_lock(&s->lock);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n            if (bs->encrypted) {\n\n                assert(s->crypto);\n\n                assert((offset & (BDRV_SECTOR_SIZE - 1)) == 0);\n\n                assert((cur_bytes & (BDRV_SECTOR_SIZE - 1)) == 0);\n\n                if (qcrypto_block_decrypt(s->crypto,\n\n                                          (s->crypt_physical_offset ?\n\n                                           cluster_offset + offset_in_cluster :\n\n                                           offset),\n\n                                          cluster_data,\n\n                                          cur_bytes,\n\n                                          NULL) < 0) {\n\n                    ret = -EIO;\n\n                    goto fail;\n\n                }\n\n                qemu_iovec_from_buf(qiov, bytes_done, cluster_data, cur_bytes);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            g_assert_not_reached();\n\n            ret = -EIO;\n\n            goto fail;\n\n        }\n\n\n\n        bytes -= cur_bytes;\n\n        offset += cur_bytes;\n\n        bytes_done += cur_bytes;\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    qemu_iovec_destroy(&hd_qiov);\n\n    qemu_vfree(cluster_data);\n\n\n\n    return ret;\n\n}\n", "idx": 24281}
{"project": "qemu", "commit_id": "9745807191a81c45970f780166f44a7f93b18653", "target": 1, "func": "static void gen_div(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)\n\n{\n\n    TCGv sr_ov = tcg_temp_new();\n\n    TCGv t0 = tcg_temp_new();\n\n\n\n    tcg_gen_setcondi_tl(TCG_COND_EQ, sr_ov, srcb, 0);\n\n    /* The result of divide-by-zero is undefined.\n\n       Supress the host-side exception by dividing by 1.  */\n\n    tcg_gen_or_tl(t0, srcb, sr_ov);\n\n    tcg_gen_div_tl(dest, srca, t0);\n\n    tcg_temp_free(t0);\n\n\n\n    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_ov, ctz32(SR_OV), 1);\n\n\n\n    gen_ove_ov(dc, sr_ov);\n\n    tcg_temp_free(sr_ov);\n\n}\n", "idx": 24282}
{"project": "qemu", "commit_id": "a77fd4bb2988c05953fdc9f1524085870ec1c939", "target": 1, "func": "void bdrv_drain(BlockDriverState *bs)\n\n{\n\n    bool busy = true;\n\n\n\n    bdrv_drain_recurse(bs);\n\n\n\n\n\n    while (busy) {\n\n        /* Keep iterating */\n\n         bdrv_flush_io_queue(bs);\n\n         busy = bdrv_requests_pending(bs);\n\n         busy |= aio_poll(bdrv_get_aio_context(bs), busy);\n\n", "idx": 24292}
{"project": "qemu", "commit_id": "25ba3a681213390e9212dbc987d61843c3b41d5b", "target": 1, "func": "static int dump_ppc_insns (CPUPPCState *env)\n\n{\n\n    opc_handler_t **table, *handler;\n\n    uint8_t opc1, opc2, opc3;\n\n\n\n    printf(\"Instructions set:\\n\");\n\n    /* opc1 is 6 bits long */\n\n    for (opc1 = 0x00; opc1 < 0x40; opc1++) {\n\n        table = env->opcodes;\n\n        handler = table[opc1];\n\n        if (is_indirect_opcode(handler)) {\n\n            /* opc2 is 5 bits long */\n\n            for (opc2 = 0; opc2 < 0x20; opc2++) {\n\n                table = env->opcodes;\n\n                handler = env->opcodes[opc1];\n\n                table = ind_table(handler);\n\n                handler = table[opc2];\n\n                if (is_indirect_opcode(handler)) {\n\n                    table = ind_table(handler);\n\n                    /* opc3 is 5 bits long */\n\n                    for (opc3 = 0; opc3 < 0x20; opc3++) {\n\n                        handler = table[opc3];\n\n                        if (handler->handler != &gen_invalid) {\n\n                            printf(\"INSN: %02x %02x %02x (%02d %04d) : %s\\n\",\n\n                                   opc1, opc2, opc3, opc1, (opc3 << 5) | opc2,\n\n                                   handler->oname);\n\n                        }\n\n                    }\n\n                } else {\n\n                    if (handler->handler != &gen_invalid) {\n\n                        printf(\"INSN: %02x %02x -- (%02d %04d) : %s\\n\",\n\n                               opc1, opc2, opc1, opc2, handler->oname);\n\n                    }\n\n                }\n\n            }\n\n        } else {\n\n            if (handler->handler != &gen_invalid) {\n\n                printf(\"INSN: %02x -- -- (%02d ----) : %s\\n\",\n\n                       opc1, opc1, handler->oname);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 24293}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "static void main_loop(void)\n\n{\n\n    bool nonblocking;\n\n    int last_io __attribute__ ((unused)) = 0;\n\n#ifdef CONFIG_PROFILER\n\n    int64_t ti;\n\n#endif\n\n    int r;\n\n\n\n    qemu_main_loop_start();\n\n\n\n    for (;;) {\n\n#ifdef CONFIG_IOTHREAD\n\n        nonblocking = !kvm_enabled() && last_io > 0;\n\n#else\n\n        nonblocking = cpu_exec_all();\n\n        if (vm_request_pending()) {\n\n            nonblocking = true;\n\n        }\n\n#endif\n\n#ifdef CONFIG_PROFILER\n\n        ti = profile_getclock();\n\n#endif\n\n        last_io = main_loop_wait(nonblocking);\n\n#ifdef CONFIG_PROFILER\n\n        dev_time += profile_getclock() - ti;\n\n#endif\n\n\n\n        if (qemu_debug_requested()) {\n\n            vm_stop(VMSTOP_DEBUG);\n\n        }\n\n        if (qemu_shutdown_requested()) {\n\n            qemu_kill_report();\n\n            monitor_protocol_event(QEVENT_SHUTDOWN, NULL);\n\n            if (no_shutdown) {\n\n                vm_stop(VMSTOP_SHUTDOWN);\n\n            } else\n\n                break;\n\n        }\n\n        if (qemu_reset_requested()) {\n\n            pause_all_vcpus();\n\n            cpu_synchronize_all_states();\n\n            qemu_system_reset(VMRESET_REPORT);\n\n            resume_all_vcpus();\n\n        }\n\n        if (qemu_powerdown_requested()) {\n\n            monitor_protocol_event(QEVENT_POWERDOWN, NULL);\n\n            qemu_irq_raise(qemu_system_powerdown);\n\n        }\n\n        if ((r = qemu_vmstop_requested())) {\n\n            vm_stop(r);\n\n        }\n\n    }\n\n    bdrv_close_all();\n\n    pause_all_vcpus();\n\n}\n", "idx": 24294}
{"project": "qemu", "commit_id": "cd0c6f473532bfaf20a095bc90a18e45162981b5", "target": 1, "func": "static inline void do_rfi(CPUPPCState *env, target_ulong nip, target_ulong msr,\n                          target_ulong msrm, int keep_msrh)\n{\n    CPUState *cs = CPU(ppc_env_get_cpu(env));\n#if defined(TARGET_PPC64)\n    if (msr_is_64bit(env, msr)) {\n        nip = (uint64_t)nip;\n        msr &= (uint64_t)msrm;\n    } else {\n        nip = (uint32_t)nip;\n        msr = (uint32_t)(msr & msrm);\n        if (keep_msrh) {\n            msr |= env->msr & ~((uint64_t)0xFFFFFFFF);\n        }\n    }\n#else\n    nip = (uint32_t)nip;\n    msr &= (uint32_t)msrm;\n#endif\n    /* XXX: beware: this is false if VLE is supported */\n    env->nip = nip & ~((target_ulong)0x00000003);\n    hreg_store_msr(env, msr, 1);\n#if defined(DEBUG_OP)\n    cpu_dump_rfi(env->nip, env->msr);\n#endif\n    /* No need to raise an exception here,\n     * as rfi is always the last insn of a TB\n     */\n    cs->interrupt_request |= CPU_INTERRUPT_EXITTB;\n}", "idx": 24297}
{"project": "qemu", "commit_id": "a808c0865b720e22ca2929ec3d362d4610fbad51", "target": 1, "func": "static void mmio_interface_realize(DeviceState *dev, Error **errp)\n\n{\n\n    MMIOInterface *s = MMIO_INTERFACE(dev);\n\n\n\n    DPRINTF(\"realize from 0x%\" PRIX64 \" to 0x%\" PRIX64 \" map host pointer\"\n\n            \" %p\\n\", s->start, s->end, s->host_ptr);\n\n\n\n    if (!s->host_ptr) {\n\n        error_setg(errp, \"host_ptr property must be set\");\n\n\n    }\n\n\n\n    if (!s->subregion) {\n\n        error_setg(errp, \"subregion property must be set\");\n\n\n    }\n\n\n\n    memory_region_init_ram_ptr(&s->ram_mem, OBJECT(s), \"ram\",\n\n                               s->end - s->start + 1, s->host_ptr);\n\n    memory_region_set_readonly(&s->ram_mem, s->ro);\n\n    memory_region_add_subregion(s->subregion, s->start, &s->ram_mem);\n\n}", "idx": 24298}
{"project": "qemu", "commit_id": "b946a1533209f61a93e34898aebb5b43154b99c3", "target": 1, "func": "PCIDevice *pci_ne2000_init(PCIBus *bus, NICInfo *nd, int devfn)\n\n{\n\n    PCINE2000State *d;\n\n    NE2000State *s;\n\n    uint8_t *pci_conf;\n\n\n\n    d = (PCINE2000State *)pci_register_device(bus,\n\n                                              \"NE2000\", sizeof(PCINE2000State),\n\n                                              devfn,\n\n                                              NULL, NULL);\n\n    pci_conf = d->dev.config;\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_REALTEK);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_REALTEK_8029);\n\n    pci_config_set_class(pci_conf, PCI_CLASS_NETWORK_ETHERNET);\n\n    pci_conf[0x0e] = 0x00; // header_type\n\n    pci_conf[0x3d] = 1; // interrupt pin 0\n\n\n\n    pci_register_io_region(&d->dev, 0, 0x100,\n\n                           PCI_ADDRESS_SPACE_IO, ne2000_map);\n\n    s = &d->ne2000;\n\n    s->irq = d->dev.irq[0];\n\n    s->pci_dev = (PCIDevice *)d;\n\n    memcpy(s->macaddr, nd->macaddr, 6);\n\n    ne2000_reset(s);\n\n    s->vc = qemu_new_vlan_client(nd->vlan, nd->model, nd->name,\n\n                                 ne2000_receive, ne2000_can_receive, s);\n\n\n\n    qemu_format_nic_info_str(s->vc, s->macaddr);\n\n\n\n    register_savevm(\"ne2000\", -1, 3, ne2000_save, ne2000_load, s);\n\n\n\n    return (PCIDevice *)d;\n\n}\n", "idx": 24300}
{"project": "qemu", "commit_id": "9e6636c72d8d6f0605e23ed820c8487686882b12", "target": 0, "func": "static int stream_set_speed(BlockJob *job, int64_t value)\n\n{\n\n    StreamBlockJob *s = container_of(job, StreamBlockJob, common);\n\n\n\n    if (value < 0) {\n\n        return -EINVAL;\n\n    }\n\n    ratelimit_set_speed(&s->limit, value / BDRV_SECTOR_SIZE);\n\n    return 0;\n\n}\n", "idx": 24303}
{"project": "qemu", "commit_id": "1dcea8e82b1d7795e6719a8ac8762993fc1ed4b3", "target": 0, "func": "static void cirrus_update_memory_access(CirrusVGAState *s)\n\n{\n\n    unsigned mode;\n\n\n\n    if ((s->sr[0x17] & 0x44) == 0x44) {\n\n        goto generic_io;\n\n    } else if (s->cirrus_srcptr != s->cirrus_srcptr_end) {\n\n        goto generic_io;\n\n    } else {\n\n\tif ((s->gr[0x0B] & 0x14) == 0x14) {\n\n            goto generic_io;\n\n\t} else if (s->gr[0x0B] & 0x02) {\n\n            goto generic_io;\n\n        }\n\n\n\n\tmode = s->gr[0x05] & 0x7;\n\n\tif (mode < 4 || mode > 5 || ((s->gr[0x0B] & 0x4) == 0)) {\n\n            map_linear_vram(s);\n\n            s->cirrus_linear_write[0] = cirrus_linear_mem_writeb;\n\n            s->cirrus_linear_write[1] = cirrus_linear_mem_writew;\n\n            s->cirrus_linear_write[2] = cirrus_linear_mem_writel;\n\n        } else {\n\n        generic_io:\n\n            unmap_linear_vram(s);\n\n            s->cirrus_linear_write[0] = cirrus_linear_writeb;\n\n            s->cirrus_linear_write[1] = cirrus_linear_writew;\n\n            s->cirrus_linear_write[2] = cirrus_linear_writel;\n\n        }\n\n    }\n\n}\n", "idx": 24304}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static void omap_lpg_update(struct omap_lpg_s *s)\n\n{\n\n    int64_t on, period = 1, ticks = 1000;\n\n    static const int per[8] = { 1, 2, 4, 8, 12, 16, 20, 24 };\n\n\n\n    if (~s->control & (1 << 6))\t\t\t\t\t/* LPGRES */\n\n        on = 0;\n\n    else if (s->control & (1 << 7))\t\t\t\t/* PERM_ON */\n\n        on = period;\n\n    else {\n\n        period = muldiv64(ticks, per[s->control & 7],\t\t/* PERCTRL */\n\n                        256 / 32);\n\n        on = (s->clk && s->power) ? muldiv64(ticks,\n\n                        per[(s->control >> 3) & 7], 256) : 0;\t/* ONCTRL */\n\n    }\n\n\n\n    timer_del(s->tm);\n\n    if (on == period && s->on < s->period)\n\n        printf(\"%s: LED is on\\n\", __FUNCTION__);\n\n    else if (on == 0 && s->on)\n\n        printf(\"%s: LED is off\\n\", __FUNCTION__);\n\n    else if (on && (on != s->on || period != s->period)) {\n\n        s->cycle = 0;\n\n        s->on = on;\n\n        s->period = period;\n\n        omap_lpg_tick(s);\n\n        return;\n\n    }\n\n\n\n    s->on = on;\n\n    s->period = period;\n\n}\n", "idx": 24306}
{"project": "qemu", "commit_id": "ef76dc59fa5203d146a2acf85a0ad5a5971a4824", "target": 0, "func": "START_TEST(vararg_number)\n\n{\n\n    QObject *obj;\n\n    QInt *qint;\n\n    QFloat *qfloat;\n\n    int value = 0x2342;\n\n    int64_t value64 = 0x2342342343LL;\n\n    double valuef = 2.323423423;\n\n\n\n    obj = qobject_from_jsonf(\"%d\", value);\n\n    fail_unless(obj != NULL);\n\n    fail_unless(qobject_type(obj) == QTYPE_QINT);\n\n\n\n    qint = qobject_to_qint(obj);\n\n    fail_unless(qint_get_int(qint) == value);\n\n\n\n    QDECREF(qint);\n\n\n\n    obj = qobject_from_jsonf(\"%\" PRId64, value64);\n\n    fail_unless(obj != NULL);\n\n    fail_unless(qobject_type(obj) == QTYPE_QINT);\n\n\n\n    qint = qobject_to_qint(obj);\n\n    fail_unless(qint_get_int(qint) == value64);\n\n\n\n    QDECREF(qint);\n\n\n\n    obj = qobject_from_jsonf(\"%f\", valuef);\n\n    fail_unless(obj != NULL);\n\n    fail_unless(qobject_type(obj) == QTYPE_QFLOAT);\n\n\n\n    qfloat = qobject_to_qfloat(obj);\n\n    fail_unless(qfloat_get_double(qfloat) == valuef);\n\n\n\n    QDECREF(qfloat);\n\n}\n", "idx": 24307}
{"project": "qemu", "commit_id": "b3a62939561e07bc34493444fa926b6137cba4e8", "target": 0, "func": "TCGv_i64 tcg_global_reg_new_i64(int reg, const char *name)\n\n{\n\n    int idx;\n\n\n\n    idx = tcg_global_reg_new_internal(TCG_TYPE_I64, reg, name);\n\n    return MAKE_TCGV_I64(idx);\n\n}\n", "idx": 24308}
{"project": "qemu", "commit_id": "908c67fca4b2c12a9b2336aa9c188f84468b60b7", "target": 0, "func": "static void gen_window_check1(DisasContext *dc, unsigned r1)\n\n{\n\n    if (dc->tb->flags & XTENSA_TBFLAG_EXCM) {\n\n        return;\n\n    }\n\n    if (option_enabled(dc, XTENSA_OPTION_WINDOWED_REGISTER) &&\n\n            r1 / 4 > dc->used_window) {\n\n        TCGv_i32 pc = tcg_const_i32(dc->pc);\n\n        TCGv_i32 w = tcg_const_i32(r1 / 4);\n\n\n\n        dc->used_window = r1 / 4;\n\n        gen_advance_ccount(dc);\n\n        gen_helper_window_check(cpu_env, pc, w);\n\n\n\n        tcg_temp_free(w);\n\n        tcg_temp_free(pc);\n\n    }\n\n}\n", "idx": 24309}
{"project": "qemu", "commit_id": "a0fa2cb8ccf0b73cfd3ac01d557401a2303c0de4", "target": 0, "func": "static int kvm_sclp_service_call(S390CPU *cpu, struct kvm_run *run,\n\n                                 uint16_t ipbh0)\n\n{\n\n    CPUS390XState *env = &cpu->env;\n\n    uint32_t sccb;\n\n    uint64_t code;\n\n    int r = 0;\n\n\n\n    cpu_synchronize_state(CPU(cpu));\n\n    if (env->psw.mask & PSW_MASK_PSTATE) {\n\n        enter_pgmcheck(cpu, PGM_PRIVILEGED);\n\n        return 0;\n\n    }\n\n    sccb = env->regs[ipbh0 & 0xf];\n\n    code = env->regs[(ipbh0 & 0xf0) >> 4];\n\n\n\n    r = sclp_service_call(sccb, code);\n\n    if (r < 0) {\n\n        enter_pgmcheck(cpu, -r);\n\n    }\n\n    setcc(cpu, r);\n\n\n\n    return 0;\n\n}\n", "idx": 24310}
{"project": "qemu", "commit_id": "0928a95ffe91862938cee997c9e30602fa7884ab", "target": 0, "func": "static void bootp_reply(const struct bootp_t *bp)\n\n{\n\n    BOOTPClient *bc = NULL;\n\n    struct mbuf *m;\n\n    struct bootp_t *rbp;\n\n    struct sockaddr_in saddr, daddr;\n\n    struct in_addr dns_addr;\n\n    const struct in_addr *preq_addr;\n\n    int dhcp_msg_type, val;\n\n    uint8_t *q;\n\n\n\n    /* extract exact DHCP msg type */\n\n    dhcp_decode(bp, &dhcp_msg_type, &preq_addr);\n\n    dprintf(\"bootp packet op=%d msgtype=%d\", bp->bp_op, dhcp_msg_type);\n\n    if (preq_addr)\n\n        dprintf(\" req_addr=%08x\\n\", ntohl(preq_addr->s_addr));\n\n    else\n\n        dprintf(\"\\n\");\n\n\n\n    if (dhcp_msg_type == 0)\n\n        dhcp_msg_type = DHCPREQUEST; /* Force reply for old BOOTP clients */\n\n\n\n    if (dhcp_msg_type != DHCPDISCOVER &&\n\n        dhcp_msg_type != DHCPREQUEST)\n\n        return;\n\n    /* XXX: this is a hack to get the client mac address */\n\n    memcpy(client_ethaddr, bp->bp_hwaddr, 6);\n\n\n\n    if ((m = m_get()) == NULL)\n\n        return;\n\n    m->m_data += IF_MAXLINKHDR;\n\n    rbp = (struct bootp_t *)m->m_data;\n\n    m->m_data += sizeof(struct udpiphdr);\n\n    memset(rbp, 0, sizeof(struct bootp_t));\n\n\n\n    if (dhcp_msg_type == DHCPDISCOVER) {\n\n        if (preq_addr) {\n\n            bc = request_addr(preq_addr, client_ethaddr);\n\n            if (bc) {\n\n                daddr.sin_addr = *preq_addr;\n\n            }\n\n        }\n\n        if (!bc) {\n\n         new_addr:\n\n            bc = get_new_addr(&daddr.sin_addr);\n\n            if (!bc) {\n\n                dprintf(\"no address left\\n\");\n\n                return;\n\n            }\n\n        }\n\n        memcpy(bc->macaddr, client_ethaddr, 6);\n\n    } else if (preq_addr) {\n\n        bc = request_addr(preq_addr, client_ethaddr);\n\n        if (bc) {\n\n            daddr.sin_addr = *preq_addr;\n\n            memcpy(bc->macaddr, client_ethaddr, 6);\n\n        } else {\n\n            daddr.sin_addr.s_addr = 0;\n\n        }\n\n    } else {\n\n        bc = find_addr(&daddr.sin_addr, bp->bp_hwaddr);\n\n        if (!bc) {\n\n            /* if never assigned, behaves as if it was already\n\n               assigned (windows fix because it remembers its address) */\n\n            goto new_addr;\n\n        }\n\n    }\n\n\n\n    saddr.sin_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_ALIAS);\n\n    saddr.sin_port = htons(BOOTP_SERVER);\n\n\n\n    daddr.sin_port = htons(BOOTP_CLIENT);\n\n\n\n    rbp->bp_op = BOOTP_REPLY;\n\n    rbp->bp_xid = bp->bp_xid;\n\n    rbp->bp_htype = 1;\n\n    rbp->bp_hlen = 6;\n\n    memcpy(rbp->bp_hwaddr, bp->bp_hwaddr, 6);\n\n\n\n    rbp->bp_yiaddr = daddr.sin_addr; /* Client IP address */\n\n    rbp->bp_siaddr = saddr.sin_addr; /* Server IP address */\n\n\n\n    q = rbp->bp_vend;\n\n    memcpy(q, rfc1533_cookie, 4);\n\n    q += 4;\n\n\n\n    if (bc) {\n\n        dprintf(\"%s addr=%08x\\n\",\n\n                (dhcp_msg_type == DHCPDISCOVER) ? \"offered\" : \"ack'ed\",\n\n                ntohl(daddr.sin_addr.s_addr));\n\n\n\n        if (dhcp_msg_type == DHCPDISCOVER) {\n\n            *q++ = RFC2132_MSG_TYPE;\n\n            *q++ = 1;\n\n            *q++ = DHCPOFFER;\n\n        } else /* DHCPREQUEST */ {\n\n            *q++ = RFC2132_MSG_TYPE;\n\n            *q++ = 1;\n\n            *q++ = DHCPACK;\n\n        }\n\n\n\n        if (bootp_filename)\n\n            snprintf((char *)rbp->bp_file, sizeof(rbp->bp_file), \"%s\",\n\n                     bootp_filename);\n\n\n\n        *q++ = RFC2132_SRV_ID;\n\n        *q++ = 4;\n\n        memcpy(q, &saddr.sin_addr, 4);\n\n        q += 4;\n\n\n\n        *q++ = RFC1533_NETMASK;\n\n        *q++ = 4;\n\n        *q++ = 0xff;\n\n        *q++ = 0xff;\n\n        *q++ = 0xff;\n\n        *q++ = 0x00;\n\n\n\n        if (!slirp_restrict) {\n\n            *q++ = RFC1533_GATEWAY;\n\n            *q++ = 4;\n\n            memcpy(q, &saddr.sin_addr, 4);\n\n            q += 4;\n\n\n\n            *q++ = RFC1533_DNS;\n\n            *q++ = 4;\n\n            dns_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_DNS);\n\n            memcpy(q, &dns_addr, 4);\n\n            q += 4;\n\n        }\n\n\n\n        *q++ = RFC2132_LEASE_TIME;\n\n        *q++ = 4;\n\n        val = htonl(LEASE_TIME);\n\n        memcpy(q, &val, 4);\n\n        q += 4;\n\n\n\n        if (*slirp_hostname) {\n\n            val = strlen(slirp_hostname);\n\n            *q++ = RFC1533_HOSTNAME;\n\n            *q++ = val;\n\n            memcpy(q, slirp_hostname, val);\n\n            q += val;\n\n        }\n\n    } else {\n\n        static const char nak_msg[] = \"requested address not available\";\n\n\n\n        dprintf(\"nak'ed addr=%08x\\n\", ntohl(preq_addr->s_addr));\n\n\n\n        *q++ = RFC2132_MSG_TYPE;\n\n        *q++ = 1;\n\n        *q++ = DHCPNAK;\n\n\n\n        *q++ = RFC2132_MESSAGE;\n\n        *q++ = sizeof(nak_msg) - 1;\n\n        memcpy(q, nak_msg, sizeof(nak_msg) - 1);\n\n        q += sizeof(nak_msg) - 1;\n\n    }\n\n    *q++ = RFC1533_END;\n\n\n\n    daddr.sin_addr.s_addr = 0xffffffffu;\n\n\n\n    m->m_len = sizeof(struct bootp_t) -\n\n        sizeof(struct ip) - sizeof(struct udphdr);\n\n    udp_output2(NULL, m, &saddr, &daddr, IPTOS_LOWDELAY);\n\n}\n", "idx": 24311}
{"project": "qemu", "commit_id": "9a78eead0c74333a394c0f7bbfc4423ac746fcd5", "target": 0, "func": "static void print_features(FILE *f,\n\n                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),\n\n                           uint32_t features, const char *prefix)\n\n{\n\n    unsigned int i;\n\n\n\n    for (i = 0; i < ARRAY_SIZE(feature_name); i++)\n\n        if (feature_name[i] && (features & (1 << i))) {\n\n            if (prefix)\n\n                (*cpu_fprintf)(f, \"%s\", prefix);\n\n            (*cpu_fprintf)(f, \"%s \", feature_name[i]);\n\n        }\n\n}\n", "idx": 24312}
{"project": "qemu", "commit_id": "4534ff5426afeeae5238ba10a696cafa9a0168ee", "target": 0, "func": "static int qcow2_check(BlockDriverState *bs, BdrvCheckResult *result)\n\n{\n\n    return qcow2_check_refcounts(bs, result);\n\n}\n", "idx": 24313}
{"project": "qemu", "commit_id": "56943e8cc14b7eeeab67d1942fa5d8bcafe3e53f", "target": 0, "func": "static void qemu_tcg_init_vcpu(CPUState *cpu)\n\n{\n\n    char thread_name[VCPU_THREAD_NAME_SIZE];\n\n    static QemuCond *tcg_halt_cond;\n\n    static QemuThread *tcg_cpu_thread;\n\n\n\n    tcg_cpu_address_space_init(cpu, cpu->as);\n\n\n\n    /* share a single thread for all cpus with TCG */\n\n    if (!tcg_cpu_thread) {\n\n        cpu->thread = g_malloc0(sizeof(QemuThread));\n\n        cpu->halt_cond = g_malloc0(sizeof(QemuCond));\n\n        qemu_cond_init(cpu->halt_cond);\n\n        tcg_halt_cond = cpu->halt_cond;\n\n        snprintf(thread_name, VCPU_THREAD_NAME_SIZE, \"CPU %d/TCG\",\n\n                 cpu->cpu_index);\n\n        qemu_thread_create(cpu->thread, thread_name, qemu_tcg_cpu_thread_fn,\n\n                           cpu, QEMU_THREAD_JOINABLE);\n\n#ifdef _WIN32\n\n        cpu->hThread = qemu_thread_get_handle(cpu->thread);\n\n#endif\n\n        while (!cpu->created) {\n\n            qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);\n\n        }\n\n        tcg_cpu_thread = cpu->thread;\n\n    } else {\n\n        cpu->thread = tcg_cpu_thread;\n\n        cpu->halt_cond = tcg_halt_cond;\n\n    }\n\n}\n", "idx": 24314}
{"project": "qemu", "commit_id": "1a9353d258aba69afd8a389bf5fb705caab12ce0", "target": 0, "func": "int cpu_x86_gen_code(uint8_t *gen_code_buf, int max_code_size, \n\n                     int *gen_code_size_ptr, uint8_t *pc_start, \n\n                     int flags)\n\n{\n\n    DisasContext dc1, *dc = &dc1;\n\n    uint8_t *gen_code_end, *pc_ptr;\n\n    long ret;\n\n#ifdef DEBUG_DISAS\n\n    struct disassemble_info disasm_info;\n\n#endif\n\n    dc->code32 = (flags >> GEN_FLAG_CODE32_SHIFT) & 1;\n\n    dc->addseg = (flags >> GEN_FLAG_ADDSEG_SHIFT) & 1;\n\n    dc->f_st = (flags >> GEN_FLAG_ST_SHIFT) & 7;\n\n    dc->cc_op = CC_OP_DYNAMIC;\n\n    gen_code_ptr = gen_code_buf;\n\n    gen_code_end = gen_code_buf + max_code_size - 4096;\n\n    gen_start();\n\n\n\n    dc->is_jmp = 0;\n\n    pc_ptr = pc_start;\n\n    do {\n\n        ret = disas_insn(dc, pc_ptr);\n\n        if (ret == -1) \n\n            error(\"unknown instruction at PC=0x%x B=%02x %02x\", \n\n                  pc_ptr, pc_ptr[0], pc_ptr[1]);\n\n        pc_ptr = (void *)ret;\n\n    } while (!dc->is_jmp && gen_code_ptr < gen_code_end);\n\n    /* we must store the eflags state if it is not already done */\n\n    if (dc->cc_op != CC_OP_DYNAMIC)\n\n        gen_op_set_cc_op(dc->cc_op);\n\n    if (dc->is_jmp != 1) {\n\n        /* we add an additionnal jmp to update the simulated PC */\n\n        gen_op_jmp_im(ret);\n\n    }\n\n    gen_end();\n\n    *gen_code_size_ptr = gen_code_ptr - gen_code_buf;\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (loglevel) {\n\n        uint8_t *pc;\n\n        int count;\n\n\n\n        INIT_DISASSEMBLE_INFO(disasm_info, logfile, fprintf);\n\n#if 0        \n\n        disasm_info.flavour = bfd_get_flavour (abfd);\n\n        disasm_info.arch = bfd_get_arch (abfd);\n\n        disasm_info.mach = bfd_get_mach (abfd);\n\n#endif\n\n#ifdef WORDS_BIGENDIAN\n\n        disasm_info.endian = BFD_ENDIAN_BIG;\n\n#else\n\n        disasm_info.endian = BFD_ENDIAN_LITTLE;\n\n#endif        \n\n        fprintf(logfile, \"IN:\\n\");\n\n        disasm_info.buffer = pc_start;\n\n        disasm_info.buffer_vma = (unsigned long)pc_start;\n\n        disasm_info.buffer_length = pc_ptr - pc_start;\n\n        pc = pc_start;\n\n        while (pc < pc_ptr) {\n\n            fprintf(logfile, \"0x%08lx:  \", (long)pc);\n\n            count = print_insn_i386((unsigned long)pc, &disasm_info);\n\n            fprintf(logfile, \"\\n\");\n\n            pc += count;\n\n        }\n\n        fprintf(logfile, \"\\n\");\n\n        \n\n        pc = gen_code_buf;\n\n        disasm_info.buffer = pc;\n\n        disasm_info.buffer_vma = (unsigned long)pc;\n\n        disasm_info.buffer_length = *gen_code_size_ptr;\n\n        fprintf(logfile, \"OUT: [size=%d]\\n\", *gen_code_size_ptr);\n\n        while (pc < gen_code_ptr) {\n\n            fprintf(logfile, \"0x%08lx:  \", (long)pc);\n\n            count = print_insn_i386((unsigned long)pc, &disasm_info);\n\n            fprintf(logfile, \"\\n\");\n\n            pc += count;\n\n        }\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 24315}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_pread(BlockDriverState *bs, int64_t offset, void *buf, int bytes)\n\n{\n\n    QEMUIOVector qiov;\n\n    struct iovec iov = {\n\n        .iov_base = (void *)buf,\n\n        .iov_len = bytes,\n\n    };\n\n    int ret;\n\n\n\n    if (bytes < 0) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    qemu_iovec_init_external(&qiov, &iov, 1);\n\n    ret = bdrv_prwv_co(bs, offset, &qiov, false, 0);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return bytes;\n\n}\n", "idx": 24317}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void aio_notify(AioContext *ctx)\n\n{\n\n    /* Write e.g. bh->scheduled before reading ctx->notify_me.  Pairs\n\n     * with atomic_or in aio_ctx_prepare or atomic_add in aio_poll.\n\n     */\n\n    smp_mb();\n\n    if (ctx->notify_me) {\n\n        event_notifier_set(&ctx->notifier);\n\n        atomic_mb_set(&ctx->notified, true);\n\n    }\n\n}\n", "idx": 24318}
{"project": "qemu", "commit_id": "90f12d735d66ac1196d9a2bced039a432eefc03d", "target": 0, "func": "static void gen_dmtc0(DisasContext *ctx, TCGv arg, int reg, int sel)\n\n{\n\n    const char *rn = \"invalid\";\n\n\n\n    if (sel != 0)\n\n        check_insn(ctx, ISA_MIPS64);\n\n\n\n    if (use_icount)\n\n        gen_io_start();\n\n\n\n    switch (reg) {\n\n    case 0:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_helper_mtc0_index(cpu_env, arg);\n\n            rn = \"Index\";\n\n            break;\n\n        case 1:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_helper_mtc0_mvpcontrol(cpu_env, arg);\n\n            rn = \"MVPControl\";\n\n            break;\n\n        case 2:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            /* ignored */\n\n            rn = \"MVPConf0\";\n\n            break;\n\n        case 3:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            /* ignored */\n\n            rn = \"MVPConf1\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 1:\n\n        switch (sel) {\n\n        case 0:\n\n            /* ignored */\n\n            rn = \"Random\";\n\n            break;\n\n        case 1:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_helper_mtc0_vpecontrol(cpu_env, arg);\n\n            rn = \"VPEControl\";\n\n            break;\n\n        case 2:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_helper_mtc0_vpeconf0(cpu_env, arg);\n\n            rn = \"VPEConf0\";\n\n            break;\n\n        case 3:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_helper_mtc0_vpeconf1(cpu_env, arg);\n\n            rn = \"VPEConf1\";\n\n            break;\n\n        case 4:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_helper_mtc0_yqmask(cpu_env, arg);\n\n            rn = \"YQMask\";\n\n            break;\n\n        case 5:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            tcg_gen_st_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_VPESchedule));\n\n            rn = \"VPESchedule\";\n\n            break;\n\n        case 6:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            tcg_gen_st_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_VPEScheFBack));\n\n            rn = \"VPEScheFBack\";\n\n            break;\n\n        case 7:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_helper_mtc0_vpeopt(cpu_env, arg);\n\n            rn = \"VPEOpt\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 2:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_helper_dmtc0_entrylo0(cpu_env, arg);\n\n            rn = \"EntryLo0\";\n\n            break;\n\n        case 1:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_helper_mtc0_tcstatus(cpu_env, arg);\n\n            rn = \"TCStatus\";\n\n            break;\n\n        case 2:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_helper_mtc0_tcbind(cpu_env, arg);\n\n            rn = \"TCBind\";\n\n            break;\n\n        case 3:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_helper_mtc0_tcrestart(cpu_env, arg);\n\n            rn = \"TCRestart\";\n\n            break;\n\n        case 4:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_helper_mtc0_tchalt(cpu_env, arg);\n\n            rn = \"TCHalt\";\n\n            break;\n\n        case 5:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_helper_mtc0_tccontext(cpu_env, arg);\n\n            rn = \"TCContext\";\n\n            break;\n\n        case 6:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_helper_mtc0_tcschedule(cpu_env, arg);\n\n            rn = \"TCSchedule\";\n\n            break;\n\n        case 7:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_helper_mtc0_tcschefback(cpu_env, arg);\n\n            rn = \"TCScheFBack\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 3:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_helper_dmtc0_entrylo1(cpu_env, arg);\n\n            rn = \"EntryLo1\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 4:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_helper_mtc0_context(cpu_env, arg);\n\n            rn = \"Context\";\n\n            break;\n\n        case 1:\n\n//           gen_helper_mtc0_contextconfig(cpu_env, arg); /* SmartMIPS ASE */\n\n            rn = \"ContextConfig\";\n\n            goto cp0_unimplemented;\n\n//           break;\n\n        case 2:\n\n            CP0_CHECK(ctx->ulri);\n\n            tcg_gen_st_tl(arg, cpu_env,\n\n                          offsetof(CPUMIPSState, active_tc.CP0_UserLocal));\n\n            rn = \"UserLocal\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 5:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_helper_mtc0_pagemask(cpu_env, arg);\n\n            rn = \"PageMask\";\n\n            break;\n\n        case 1:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_helper_mtc0_pagegrain(cpu_env, arg);\n\n            rn = \"PageGrain\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 6:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_helper_mtc0_wired(cpu_env, arg);\n\n            rn = \"Wired\";\n\n            break;\n\n        case 1:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_helper_mtc0_srsconf0(cpu_env, arg);\n\n            rn = \"SRSConf0\";\n\n            break;\n\n        case 2:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_helper_mtc0_srsconf1(cpu_env, arg);\n\n            rn = \"SRSConf1\";\n\n            break;\n\n        case 3:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_helper_mtc0_srsconf2(cpu_env, arg);\n\n            rn = \"SRSConf2\";\n\n            break;\n\n        case 4:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_helper_mtc0_srsconf3(cpu_env, arg);\n\n            rn = \"SRSConf3\";\n\n            break;\n\n        case 5:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_helper_mtc0_srsconf4(cpu_env, arg);\n\n            rn = \"SRSConf4\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 7:\n\n        switch (sel) {\n\n        case 0:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_helper_mtc0_hwrena(cpu_env, arg);\n\n            ctx->bstate = BS_STOP;\n\n            rn = \"HWREna\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 8:\n\n        switch (sel) {\n\n        case 0:\n\n            /* ignored */\n\n            rn = \"BadVAddr\";\n\n            break;\n\n        case 1:\n\n            /* ignored */\n\n            rn = \"BadInstr\";\n\n            break;\n\n        case 2:\n\n            /* ignored */\n\n            rn = \"BadInstrP\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 9:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_helper_mtc0_count(cpu_env, arg);\n\n            rn = \"Count\";\n\n            break;\n\n        /* 6,7 are implementation dependent */\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        /* Stop translation as we may have switched the execution mode */\n\n        ctx->bstate = BS_STOP;\n\n        break;\n\n    case 10:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_helper_mtc0_entryhi(cpu_env, arg);\n\n            rn = \"EntryHi\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 11:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_helper_mtc0_compare(cpu_env, arg);\n\n            rn = \"Compare\";\n\n            break;\n\n        /* 6,7 are implementation dependent */\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        /* Stop translation as we may have switched the execution mode */\n\n        ctx->bstate = BS_STOP;\n\n        break;\n\n    case 12:\n\n        switch (sel) {\n\n        case 0:\n\n            save_cpu_state(ctx, 1);\n\n            gen_helper_mtc0_status(cpu_env, arg);\n\n            /* BS_STOP isn't good enough here, hflags may have changed. */\n\n            gen_save_pc(ctx->pc + 4);\n\n            ctx->bstate = BS_EXCP;\n\n            rn = \"Status\";\n\n            break;\n\n        case 1:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_helper_mtc0_intctl(cpu_env, arg);\n\n            /* Stop translation as we may have switched the execution mode */\n\n            ctx->bstate = BS_STOP;\n\n            rn = \"IntCtl\";\n\n            break;\n\n        case 2:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_helper_mtc0_srsctl(cpu_env, arg);\n\n            /* Stop translation as we may have switched the execution mode */\n\n            ctx->bstate = BS_STOP;\n\n            rn = \"SRSCtl\";\n\n            break;\n\n        case 3:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_mtc0_store32(arg, offsetof(CPUMIPSState, CP0_SRSMap));\n\n            /* Stop translation as we may have switched the execution mode */\n\n            ctx->bstate = BS_STOP;\n\n            rn = \"SRSMap\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 13:\n\n        switch (sel) {\n\n        case 0:\n\n            save_cpu_state(ctx, 1);\n\n            /* Mark as an IO operation because we may trigger a software\n\n               interrupt.  */\n\n            if (use_icount) {\n\n                gen_io_start();\n\n            }\n\n            gen_helper_mtc0_cause(cpu_env, arg);\n\n            if (use_icount) {\n\n                gen_io_end();\n\n            }\n\n            /* Stop translation as we may have triggered an intetrupt */\n\n            ctx->bstate = BS_STOP;\n\n            rn = \"Cause\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 14:\n\n        switch (sel) {\n\n        case 0:\n\n            tcg_gen_st_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_EPC));\n\n            rn = \"EPC\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 15:\n\n        switch (sel) {\n\n        case 0:\n\n            /* ignored */\n\n            rn = \"PRid\";\n\n            break;\n\n        case 1:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_helper_mtc0_ebase(cpu_env, arg);\n\n            rn = \"EBase\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 16:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_helper_mtc0_config0(cpu_env, arg);\n\n            rn = \"Config\";\n\n            /* Stop translation as we may have switched the execution mode */\n\n            ctx->bstate = BS_STOP;\n\n            break;\n\n        case 1:\n\n            /* ignored, read only */\n\n            rn = \"Config1\";\n\n            break;\n\n        case 2:\n\n            gen_helper_mtc0_config2(cpu_env, arg);\n\n            rn = \"Config2\";\n\n            /* Stop translation as we may have switched the execution mode */\n\n            ctx->bstate = BS_STOP;\n\n            break;\n\n        case 3:\n\n            /* ignored */\n\n            rn = \"Config3\";\n\n            break;\n\n        case 4:\n\n            /* currently ignored */\n\n            rn = \"Config4\";\n\n            break;\n\n        case 5:\n\n            gen_helper_mtc0_config5(cpu_env, arg);\n\n            rn = \"Config5\";\n\n            /* Stop translation as we may have switched the execution mode */\n\n            ctx->bstate = BS_STOP;\n\n            break;\n\n        /* 6,7 are implementation dependent */\n\n        default:\n\n            rn = \"Invalid config selector\";\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 17:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_helper_mtc0_lladdr(cpu_env, arg);\n\n            rn = \"LLAddr\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 18:\n\n        switch (sel) {\n\n        case 0 ... 7:\n\n            gen_helper_0e1i(mtc0_watchlo, arg, sel);\n\n            rn = \"WatchLo\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 19:\n\n        switch (sel) {\n\n        case 0 ... 7:\n\n            gen_helper_0e1i(mtc0_watchhi, arg, sel);\n\n            rn = \"WatchHi\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 20:\n\n        switch (sel) {\n\n        case 0:\n\n            check_insn(ctx, ISA_MIPS3);\n\n            gen_helper_mtc0_xcontext(cpu_env, arg);\n\n            rn = \"XContext\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 21:\n\n       /* Officially reserved, but sel 0 is used for R1x000 framemask */\n\n        CP0_CHECK(!(ctx->insn_flags & ISA_MIPS32R6));\n\n        switch (sel) {\n\n        case 0:\n\n            gen_helper_mtc0_framemask(cpu_env, arg);\n\n            rn = \"Framemask\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 22:\n\n        /* ignored */\n\n        rn = \"Diagnostic\"; /* implementation dependent */\n\n        break;\n\n    case 23:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_helper_mtc0_debug(cpu_env, arg); /* EJTAG support */\n\n            /* BS_STOP isn't good enough here, hflags may have changed. */\n\n            gen_save_pc(ctx->pc + 4);\n\n            ctx->bstate = BS_EXCP;\n\n            rn = \"Debug\";\n\n            break;\n\n        case 1:\n\n//            gen_helper_mtc0_tracecontrol(cpu_env, arg); /* PDtrace support */\n\n            /* Stop translation as we may have switched the execution mode */\n\n            ctx->bstate = BS_STOP;\n\n            rn = \"TraceControl\";\n\n//            break;\n\n        case 2:\n\n//            gen_helper_mtc0_tracecontrol2(cpu_env, arg); /* PDtrace support */\n\n            /* Stop translation as we may have switched the execution mode */\n\n            ctx->bstate = BS_STOP;\n\n            rn = \"TraceControl2\";\n\n//            break;\n\n        case 3:\n\n//            gen_helper_mtc0_usertracedata(cpu_env, arg); /* PDtrace support */\n\n            /* Stop translation as we may have switched the execution mode */\n\n            ctx->bstate = BS_STOP;\n\n            rn = \"UserTraceData\";\n\n//            break;\n\n        case 4:\n\n//            gen_helper_mtc0_tracebpc(cpu_env, arg); /* PDtrace support */\n\n            /* Stop translation as we may have switched the execution mode */\n\n            ctx->bstate = BS_STOP;\n\n            rn = \"TraceBPC\";\n\n//            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 24:\n\n        switch (sel) {\n\n        case 0:\n\n            /* EJTAG support */\n\n            tcg_gen_st_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_DEPC));\n\n            rn = \"DEPC\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 25:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_helper_mtc0_performance0(cpu_env, arg);\n\n            rn = \"Performance0\";\n\n            break;\n\n        case 1:\n\n//            gen_helper_mtc0_performance1(cpu_env, arg);\n\n            rn = \"Performance1\";\n\n//            break;\n\n        case 2:\n\n//            gen_helper_mtc0_performance2(cpu_env, arg);\n\n            rn = \"Performance2\";\n\n//            break;\n\n        case 3:\n\n//            gen_helper_mtc0_performance3(cpu_env, arg);\n\n            rn = \"Performance3\";\n\n//            break;\n\n        case 4:\n\n//            gen_helper_mtc0_performance4(cpu_env, arg);\n\n            rn = \"Performance4\";\n\n//            break;\n\n        case 5:\n\n//            gen_helper_mtc0_performance5(cpu_env, arg);\n\n            rn = \"Performance5\";\n\n//            break;\n\n        case 6:\n\n//            gen_helper_mtc0_performance6(cpu_env, arg);\n\n            rn = \"Performance6\";\n\n//            break;\n\n        case 7:\n\n//            gen_helper_mtc0_performance7(cpu_env, arg);\n\n            rn = \"Performance7\";\n\n//            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 26:\n\n        /* ignored */\n\n        rn = \"ECC\";\n\n        break;\n\n    case 27:\n\n        switch (sel) {\n\n        case 0 ... 3:\n\n            /* ignored */\n\n            rn = \"CacheErr\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 28:\n\n        switch (sel) {\n\n        case 0:\n\n        case 2:\n\n        case 4:\n\n        case 6:\n\n            gen_helper_mtc0_taglo(cpu_env, arg);\n\n            rn = \"TagLo\";\n\n            break;\n\n        case 1:\n\n        case 3:\n\n        case 5:\n\n        case 7:\n\n            gen_helper_mtc0_datalo(cpu_env, arg);\n\n            rn = \"DataLo\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 29:\n\n        switch (sel) {\n\n        case 0:\n\n        case 2:\n\n        case 4:\n\n        case 6:\n\n            gen_helper_mtc0_taghi(cpu_env, arg);\n\n            rn = \"TagHi\";\n\n            break;\n\n        case 1:\n\n        case 3:\n\n        case 5:\n\n        case 7:\n\n            gen_helper_mtc0_datahi(cpu_env, arg);\n\n            rn = \"DataHi\";\n\n            break;\n\n        default:\n\n            rn = \"invalid sel\";\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 30:\n\n        switch (sel) {\n\n        case 0:\n\n            tcg_gen_st_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_ErrorEPC));\n\n            rn = \"ErrorEPC\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 31:\n\n        switch (sel) {\n\n        case 0:\n\n            /* EJTAG support */\n\n            gen_mtc0_store32(arg, offsetof(CPUMIPSState, CP0_DESAVE));\n\n            rn = \"DESAVE\";\n\n            break;\n\n        case 2 ... 7:\n\n            CP0_CHECK(ctx->kscrexist & (1 << sel));\n\n            tcg_gen_st_tl(arg, cpu_env,\n\n                          offsetof(CPUMIPSState, CP0_KScratch[sel-2]));\n\n            rn = \"KScratch\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        /* Stop translation as we may have switched the execution mode */\n\n        ctx->bstate = BS_STOP;\n\n        break;\n\n    default:\n\n        goto cp0_unimplemented;\n\n    }\n\n    (void)rn; /* avoid a compiler warning */\n\n    LOG_DISAS(\"dmtc0 %s (reg %d sel %d)\\n\", rn, reg, sel);\n\n    /* For simplicity assume that all writes can cause interrupts.  */\n\n    if (use_icount) {\n\n        gen_io_end();\n\n        ctx->bstate = BS_STOP;\n\n    }\n\n    return;\n\n\n\ncp0_unimplemented:\n\n    LOG_DISAS(\"dmtc0 %s (reg %d sel %d)\\n\", rn, reg, sel);\n\n}\n", "idx": 24319}
{"project": "qemu", "commit_id": "d3c348b6e3af3598bfcb755d59f8f4de80a2228a", "target": 0, "func": "static void xlnx_zynqmp_qspips_reset(DeviceState *d)\n\n{\n\n    XlnxZynqMPQSPIPS *s = XLNX_ZYNQMP_QSPIPS(d);\n\n    int i;\n\n\n\n    xilinx_spips_reset(d);\n\n\n\n    for (i = 0; i < XLNX_ZYNQMP_SPIPS_R_MAX; i++) {\n\n        s->regs[i] = 0;\n\n    }\n\n    fifo8_reset(&s->rx_fifo_g);\n\n    fifo8_reset(&s->rx_fifo_g);\n\n    fifo32_reset(&s->fifo_g);\n\n    s->regs[R_INTR_STATUS] = R_INTR_STATUS_RESET;\n\n    s->regs[R_GPIO] = 1;\n\n    s->regs[R_LPBK_DLY_ADJ] = R_LPBK_DLY_ADJ_RESET;\n\n    s->regs[R_GQSPI_GFIFO_THRESH] = 0x10;\n\n    s->regs[R_MOD_ID] = 0x01090101;\n\n    s->regs[R_GQSPI_IMR] = R_GQSPI_IMR_RESET;\n\n    s->regs[R_GQSPI_TX_THRESH] = 1;\n\n    s->regs[R_GQSPI_RX_THRESH] = 1;\n\n    s->regs[R_GQSPI_GPIO] = 1;\n\n    s->regs[R_GQSPI_LPBK_DLY_ADJ] = R_GQSPI_LPBK_DLY_ADJ_RESET;\n\n    s->regs[R_GQSPI_MOD_ID] = R_GQSPI_MOD_ID_RESET;\n\n    s->regs[R_QSPIDMA_DST_CTRL] = R_QSPIDMA_DST_CTRL_RESET;\n\n    s->regs[R_QSPIDMA_DST_I_MASK] = R_QSPIDMA_DST_I_MASK_RESET;\n\n    s->regs[R_QSPIDMA_DST_CTRL2] = R_QSPIDMA_DST_CTRL2_RESET;\n\n    s->man_start_com_g = false;\n\n    s->gqspi_irqline = 0;\n\n    xlnx_zynqmp_qspips_update_ixr(s);\n\n}\n", "idx": 24320}
{"project": "qemu", "commit_id": "5039d6e23586fe6bbedc5e4fe302b48a66890ade", "target": 0, "func": "void pc_basic_device_init(ISABus *isa_bus, qemu_irq *gsi,\n\n                          ISADevice **rtc_state,\n\n                          bool create_fdctrl,\n\n                          bool no_vmport,\n\n                          uint32 hpet_irqs)\n\n{\n\n    int i;\n\n    DriveInfo *fd[MAX_FD];\n\n    DeviceState *hpet = NULL;\n\n    int pit_isa_irq = 0;\n\n    qemu_irq pit_alt_irq = NULL;\n\n    qemu_irq rtc_irq = NULL;\n\n    qemu_irq *a20_line;\n\n    ISADevice *i8042, *port92, *vmmouse, *pit = NULL;\n\n    qemu_irq *cpu_exit_irq;\n\n    MemoryRegion *ioport80_io = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ioportF0_io = g_new(MemoryRegion, 1);\n\n\n\n    memory_region_init_io(ioport80_io, NULL, &ioport80_io_ops, NULL, \"ioport80\", 1);\n\n    memory_region_add_subregion(isa_bus->address_space_io, 0x80, ioport80_io);\n\n\n\n    memory_region_init_io(ioportF0_io, NULL, &ioportF0_io_ops, NULL, \"ioportF0\", 1);\n\n    memory_region_add_subregion(isa_bus->address_space_io, 0xf0, ioportF0_io);\n\n\n\n    /*\n\n     * Check if an HPET shall be created.\n\n     *\n\n     * Without KVM_CAP_PIT_STATE2, we cannot switch off the in-kernel PIT\n\n     * when the HPET wants to take over. Thus we have to disable the latter.\n\n     */\n\n    if (!no_hpet && (!kvm_irqchip_in_kernel() || kvm_has_pit_state2())) {\n\n        /* In order to set property, here not using sysbus_try_create_simple */\n\n        hpet = qdev_try_create(NULL, TYPE_HPET);\n\n        if (hpet) {\n\n            /* For pc-piix-*, hpet's intcap is always IRQ2. For pc-q35-1.7\n\n             * and earlier, use IRQ2 for compat. Otherwise, use IRQ16~23,\n\n             * IRQ8 and IRQ2.\n\n             */\n\n            uint8_t compat = object_property_get_int(OBJECT(hpet),\n\n                    HPET_INTCAP, NULL);\n\n            if (!compat) {\n\n                qdev_prop_set_uint32(hpet, HPET_INTCAP, hpet_irqs);\n\n            }\n\n            qdev_init_nofail(hpet);\n\n            sysbus_mmio_map(SYS_BUS_DEVICE(hpet), 0, HPET_BASE);\n\n\n\n            for (i = 0; i < GSI_NUM_PINS; i++) {\n\n                sysbus_connect_irq(SYS_BUS_DEVICE(hpet), i, gsi[i]);\n\n            }\n\n            pit_isa_irq = -1;\n\n            pit_alt_irq = qdev_get_gpio_in(hpet, HPET_LEGACY_PIT_INT);\n\n            rtc_irq = qdev_get_gpio_in(hpet, HPET_LEGACY_RTC_INT);\n\n        }\n\n    }\n\n    *rtc_state = rtc_init(isa_bus, 2000, rtc_irq);\n\n\n\n    qemu_register_boot_set(pc_boot_set, *rtc_state);\n\n\n\n    if (!xen_enabled()) {\n\n        if (kvm_irqchip_in_kernel()) {\n\n            pit = kvm_pit_init(isa_bus, 0x40);\n\n        } else {\n\n            pit = pit_init(isa_bus, 0x40, pit_isa_irq, pit_alt_irq);\n\n        }\n\n        if (hpet) {\n\n            /* connect PIT to output control line of the HPET */\n\n            qdev_connect_gpio_out(hpet, 0, qdev_get_gpio_in(DEVICE(pit), 0));\n\n        }\n\n        pcspk_init(isa_bus, pit);\n\n    }\n\n\n\n    serial_hds_isa_init(isa_bus, MAX_SERIAL_PORTS);\n\n    parallel_hds_isa_init(isa_bus, MAX_PARALLEL_PORTS);\n\n\n\n    a20_line = qemu_allocate_irqs(handle_a20_line_change, first_cpu, 2);\n\n    i8042 = isa_create_simple(isa_bus, \"i8042\");\n\n    i8042_setup_a20_line(i8042, &a20_line[0]);\n\n    if (!no_vmport) {\n\n        vmport_init(isa_bus);\n\n        vmmouse = isa_try_create(isa_bus, \"vmmouse\");\n\n    } else {\n\n        vmmouse = NULL;\n\n    }\n\n    if (vmmouse) {\n\n        DeviceState *dev = DEVICE(vmmouse);\n\n        qdev_prop_set_ptr(dev, \"ps2_mouse\", i8042);\n\n        qdev_init_nofail(dev);\n\n    }\n\n    port92 = isa_create_simple(isa_bus, \"port92\");\n\n    port92_init(port92, &a20_line[1]);\n\n\n\n    cpu_exit_irq = qemu_allocate_irqs(cpu_request_exit, NULL, 1);\n\n    DMA_init(0, cpu_exit_irq);\n\n\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        fd[i] = drive_get(IF_FLOPPY, 0, i);\n\n        create_fdctrl |= !!fd[i];\n\n    }\n\n    if (create_fdctrl) {\n\n        fdctrl_init_isa(isa_bus, fd);\n\n    }\n\n}\n", "idx": 24321}
{"project": "qemu", "commit_id": "24897a767bd778fc6a050537d024565f9272cd06", "target": 0, "func": "static int qemu_gluster_parseuri(GlusterConf *gconf, const char *filename)\n\n{\n\n    URI *uri;\n\n    QueryParams *qp = NULL;\n\n    bool is_unix = false;\n\n    int ret = 0;\n\n\n\n    uri = uri_parse(filename);\n\n    if (!uri) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* transport */\n\n    if (!strcmp(uri->scheme, \"gluster\")) {\n\n        gconf->transport = g_strdup(\"tcp\");\n\n    } else if (!strcmp(uri->scheme, \"gluster+tcp\")) {\n\n        gconf->transport = g_strdup(\"tcp\");\n\n    } else if (!strcmp(uri->scheme, \"gluster+unix\")) {\n\n        gconf->transport = g_strdup(\"unix\");\n\n        is_unix = true;\n\n    } else if (!strcmp(uri->scheme, \"gluster+rdma\")) {\n\n        gconf->transport = g_strdup(\"rdma\");\n\n    } else {\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    ret = parse_volume_options(gconf, uri->path);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    qp = query_params_parse(uri->query);\n\n    if (qp->n > 1 || (is_unix && !qp->n) || (!is_unix && qp->n)) {\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    if (is_unix) {\n\n        if (uri->server || uri->port) {\n\n            ret = -EINVAL;\n\n            goto out;\n\n        }\n\n        if (strcmp(qp->p[0].name, \"socket\")) {\n\n            ret = -EINVAL;\n\n            goto out;\n\n        }\n\n        gconf->server = g_strdup(qp->p[0].value);\n\n    } else {\n\n        gconf->server = g_strdup(uri->server);\n\n        gconf->port = uri->port;\n\n    }\n\n\n\nout:\n\n    if (qp) {\n\n        query_params_free(qp);\n\n    }\n\n    uri_free(uri);\n\n    return ret;\n\n}\n", "idx": 24322}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static void omap_prcm_write(void *opaque, hwaddr addr,\n\n                            uint64_t value, unsigned size)\n\n{\n\n    struct omap_prcm_s *s = (struct omap_prcm_s *) opaque;\n\n\n\n    if (size != 4) {\n\n        omap_badwidth_write32(opaque, addr, value);\n\n        return;\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x000:\t/* PRCM_REVISION */\n\n    case 0x054:\t/* PRCM_VOLTST */\n\n    case 0x084:\t/* PRCM_CLKCFG_STATUS */\n\n    case 0x1e4:\t/* PM_PWSTST_MPU */\n\n    case 0x220:\t/* CM_IDLEST1_CORE */\n\n    case 0x224:\t/* CM_IDLEST2_CORE */\n\n    case 0x22c:\t/* CM_IDLEST4_CORE */\n\n    case 0x2c8:\t/* PM_WKDEP_CORE */\n\n    case 0x2e4:\t/* PM_PWSTST_CORE */\n\n    case 0x320:\t/* CM_IDLEST_GFX */\n\n    case 0x3e4:\t/* PM_PWSTST_GFX */\n\n    case 0x420:\t/* CM_IDLEST_WKUP */\n\n    case 0x520:\t/* CM_IDLEST_CKGEN */\n\n    case 0x820:\t/* CM_IDLEST_DSP */\n\n    case 0x8e4:\t/* PM_PWSTST_DSP */\n\n        OMAP_RO_REG(addr);\n\n        return;\n\n\n\n    case 0x010:\t/* PRCM_SYSCONFIG */\n\n        s->sysconfig = value & 1;\n\n        break;\n\n\n\n    case 0x018:\t/* PRCM_IRQSTATUS_MPU */\n\n        s->irqst[0] &= ~value;\n\n        omap_prcm_int_update(s, 0);\n\n        break;\n\n    case 0x01c:\t/* PRCM_IRQENABLE_MPU */\n\n        s->irqen[0] = value & 0x3f;\n\n        omap_prcm_int_update(s, 0);\n\n        break;\n\n\n\n    case 0x050:\t/* PRCM_VOLTCTRL */\n\n        s->voltctrl = value & 0xf1c3;\n\n        break;\n\n\n\n    case 0x060:\t/* PRCM_CLKSRC_CTRL */\n\n        s->clksrc[0] = value & 0xdb;\n\n        /* TODO update clocks */\n\n        break;\n\n\n\n    case 0x070:\t/* PRCM_CLKOUT_CTRL */\n\n        s->clkout[0] = value & 0xbbbb;\n\n        /* TODO update clocks */\n\n        break;\n\n\n\n    case 0x078:\t/* PRCM_CLKEMUL_CTRL */\n\n        s->clkemul[0] = value & 1;\n\n        /* TODO update clocks */\n\n        break;\n\n\n\n    case 0x080:\t/* PRCM_CLKCFG_CTRL */\n\n        break;\n\n\n\n    case 0x090:\t/* PRCM_VOLTSETUP */\n\n        s->setuptime[0] = value & 0xffff;\n\n        break;\n\n    case 0x094:\t/* PRCM_CLKSSETUP */\n\n        s->setuptime[1] = value & 0xffff;\n\n        break;\n\n\n\n    case 0x098:\t/* PRCM_POLCTRL */\n\n        s->clkpol[0] = value & 0x701;\n\n        break;\n\n\n\n    case 0x0b0:\t/* GENERAL_PURPOSE1 */\n\n    case 0x0b4:\t/* GENERAL_PURPOSE2 */\n\n    case 0x0b8:\t/* GENERAL_PURPOSE3 */\n\n    case 0x0bc:\t/* GENERAL_PURPOSE4 */\n\n    case 0x0c0:\t/* GENERAL_PURPOSE5 */\n\n    case 0x0c4:\t/* GENERAL_PURPOSE6 */\n\n    case 0x0c8:\t/* GENERAL_PURPOSE7 */\n\n    case 0x0cc:\t/* GENERAL_PURPOSE8 */\n\n    case 0x0d0:\t/* GENERAL_PURPOSE9 */\n\n    case 0x0d4:\t/* GENERAL_PURPOSE10 */\n\n    case 0x0d8:\t/* GENERAL_PURPOSE11 */\n\n    case 0x0dc:\t/* GENERAL_PURPOSE12 */\n\n    case 0x0e0:\t/* GENERAL_PURPOSE13 */\n\n    case 0x0e4:\t/* GENERAL_PURPOSE14 */\n\n    case 0x0e8:\t/* GENERAL_PURPOSE15 */\n\n    case 0x0ec:\t/* GENERAL_PURPOSE16 */\n\n    case 0x0f0:\t/* GENERAL_PURPOSE17 */\n\n    case 0x0f4:\t/* GENERAL_PURPOSE18 */\n\n    case 0x0f8:\t/* GENERAL_PURPOSE19 */\n\n    case 0x0fc:\t/* GENERAL_PURPOSE20 */\n\n        s->scratch[(addr - 0xb0) >> 2] = value;\n\n        break;\n\n\n\n    case 0x140:\t/* CM_CLKSEL_MPU */\n\n        s->clksel[0] = value & 0x1f;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x148:\t/* CM_CLKSTCTRL_MPU */\n\n        s->clkctrl[0] = value & 0x1f;\n\n        break;\n\n\n\n    case 0x158:\t/* RM_RSTST_MPU */\n\n        s->rst[0] &= ~value;\n\n        break;\n\n    case 0x1c8:\t/* PM_WKDEP_MPU */\n\n        s->wkup[0] = value & 0x15;\n\n        break;\n\n\n\n    case 0x1d4:\t/* PM_EVGENCTRL_MPU */\n\n        s->ev = value & 0x1f;\n\n        break;\n\n    case 0x1d8:\t/* PM_EVEGENONTIM_MPU */\n\n        s->evtime[0] = value;\n\n        break;\n\n    case 0x1dc:\t/* PM_EVEGENOFFTIM_MPU */\n\n        s->evtime[1] = value;\n\n        break;\n\n\n\n    case 0x1e0:\t/* PM_PWSTCTRL_MPU */\n\n        s->power[0] = value & 0xc0f;\n\n        break;\n\n\n\n    case 0x200:\t/* CM_FCLKEN1_CORE */\n\n        s->clken[0] = value & 0xbfffffff;\n\n        /* TODO update clocks */\n\n        /* The EN_EAC bit only gets/puts func_96m_clk.  */\n\n        break;\n\n    case 0x204:\t/* CM_FCLKEN2_CORE */\n\n        s->clken[1] = value & 0x00000007;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x210:\t/* CM_ICLKEN1_CORE */\n\n        s->clken[2] = value & 0xfffffff9;\n\n        /* TODO update clocks */\n\n        /* The EN_EAC bit only gets/puts core_l4_iclk.  */\n\n        break;\n\n    case 0x214:\t/* CM_ICLKEN2_CORE */\n\n        s->clken[3] = value & 0x00000007;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x21c:\t/* CM_ICLKEN4_CORE */\n\n        s->clken[4] = value & 0x0000001f;\n\n        /* TODO update clocks */\n\n        break;\n\n\n\n    case 0x230:\t/* CM_AUTOIDLE1_CORE */\n\n        s->clkidle[0] = value & 0xfffffff9;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x234:\t/* CM_AUTOIDLE2_CORE */\n\n        s->clkidle[1] = value & 0x00000007;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x238:\t/* CM_AUTOIDLE3_CORE */\n\n        s->clkidle[2] = value & 0x00000007;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x23c:\t/* CM_AUTOIDLE4_CORE */\n\n        s->clkidle[3] = value & 0x0000001f;\n\n        /* TODO update clocks */\n\n        break;\n\n\n\n    case 0x240:\t/* CM_CLKSEL1_CORE */\n\n        s->clksel[1] = value & 0x0fffbf7f;\n\n        /* TODO update clocks */\n\n        break;\n\n\n\n    case 0x244:\t/* CM_CLKSEL2_CORE */\n\n        s->clksel[2] = value & 0x00fffffc;\n\n        /* TODO update clocks */\n\n        break;\n\n\n\n    case 0x248:\t/* CM_CLKSTCTRL_CORE */\n\n        s->clkctrl[1] = value & 0x7;\n\n        break;\n\n\n\n    case 0x2a0:\t/* PM_WKEN1_CORE */\n\n        s->wken[0] = value & 0x04667ff8;\n\n        break;\n\n    case 0x2a4:\t/* PM_WKEN2_CORE */\n\n        s->wken[1] = value & 0x00000005;\n\n        break;\n\n\n\n    case 0x2b0:\t/* PM_WKST1_CORE */\n\n        s->wkst[0] &= ~value;\n\n        break;\n\n    case 0x2b4:\t/* PM_WKST2_CORE */\n\n        s->wkst[1] &= ~value;\n\n        break;\n\n\n\n    case 0x2e0:\t/* PM_PWSTCTRL_CORE */\n\n        s->power[1] = (value & 0x00fc3f) | (1 << 2);\n\n        break;\n\n\n\n    case 0x300:\t/* CM_FCLKEN_GFX */\n\n        s->clken[5] = value & 6;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x310:\t/* CM_ICLKEN_GFX */\n\n        s->clken[6] = value & 1;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x340:\t/* CM_CLKSEL_GFX */\n\n        s->clksel[3] = value & 7;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x348:\t/* CM_CLKSTCTRL_GFX */\n\n        s->clkctrl[2] = value & 1;\n\n        break;\n\n    case 0x350:\t/* RM_RSTCTRL_GFX */\n\n        s->rstctrl[0] = value & 1;\n\n        /* TODO: reset */\n\n        break;\n\n    case 0x358:\t/* RM_RSTST_GFX */\n\n        s->rst[1] &= ~value;\n\n        break;\n\n    case 0x3c8:\t/* PM_WKDEP_GFX */\n\n        s->wkup[1] = value & 0x13;\n\n        break;\n\n    case 0x3e0:\t/* PM_PWSTCTRL_GFX */\n\n        s->power[2] = (value & 0x00c0f) | (3 << 2);\n\n        break;\n\n\n\n    case 0x400:\t/* CM_FCLKEN_WKUP */\n\n        s->clken[7] = value & 0xd;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x410:\t/* CM_ICLKEN_WKUP */\n\n        s->clken[8] = value & 0x3f;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x430:\t/* CM_AUTOIDLE_WKUP */\n\n        s->clkidle[4] = value & 0x0000003f;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x440:\t/* CM_CLKSEL_WKUP */\n\n        s->clksel[4] = value & 3;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x450:\t/* RM_RSTCTRL_WKUP */\n\n        /* TODO: reset */\n\n        if (value & 2)\n\n            qemu_system_reset_request(SHUTDOWN_CAUSE_GUEST_RESET);\n\n        break;\n\n    case 0x454:\t/* RM_RSTTIME_WKUP */\n\n        s->rsttime_wkup = value & 0x1fff;\n\n        break;\n\n    case 0x458:\t/* RM_RSTST_WKUP */\n\n        s->rst[2] &= ~value;\n\n        break;\n\n    case 0x4a0:\t/* PM_WKEN_WKUP */\n\n        s->wken[2] = value & 0x00000005;\n\n        break;\n\n    case 0x4b0:\t/* PM_WKST_WKUP */\n\n        s->wkst[2] &= ~value;\n\n        break;\n\n\n\n    case 0x500:\t/* CM_CLKEN_PLL */\n\n        if (value & 0xffffff30)\n\n            fprintf(stderr, \"%s: write 0s in CM_CLKEN_PLL for \"\n\n                            \"future compatibility\\n\", __FUNCTION__);\n\n        if ((s->clken[9] ^ value) & 0xcc) {\n\n            s->clken[9] &= ~0xcc;\n\n            s->clken[9] |= value & 0xcc;\n\n            omap_prcm_apll_update(s);\n\n        }\n\n        if ((s->clken[9] ^ value) & 3) {\n\n            s->clken[9] &= ~3;\n\n            s->clken[9] |= value & 3;\n\n            omap_prcm_dpll_update(s);\n\n        }\n\n        break;\n\n    case 0x530:\t/* CM_AUTOIDLE_PLL */\n\n        s->clkidle[5] = value & 0x000000cf;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x540:\t/* CM_CLKSEL1_PLL */\n\n        if (value & 0xfc4000d7)\n\n            fprintf(stderr, \"%s: write 0s in CM_CLKSEL1_PLL for \"\n\n                            \"future compatibility\\n\", __FUNCTION__);\n\n        if ((s->clksel[5] ^ value) & 0x003fff00) {\n\n            s->clksel[5] = value & 0x03bfff28;\n\n            omap_prcm_dpll_update(s);\n\n        }\n\n        /* TODO update the other clocks */\n\n\n\n        s->clksel[5] = value & 0x03bfff28;\n\n        break;\n\n    case 0x544:\t/* CM_CLKSEL2_PLL */\n\n        if (value & ~3)\n\n            fprintf(stderr, \"%s: write 0s in CM_CLKSEL2_PLL[31:2] for \"\n\n                            \"future compatibility\\n\", __FUNCTION__);\n\n        if (s->clksel[6] != (value & 3)) {\n\n            s->clksel[6] = value & 3;\n\n            omap_prcm_dpll_update(s);\n\n        }\n\n        break;\n\n\n\n    case 0x800:\t/* CM_FCLKEN_DSP */\n\n        s->clken[10] = value & 0x501;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x810:\t/* CM_ICLKEN_DSP */\n\n        s->clken[11] = value & 0x2;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x830:\t/* CM_AUTOIDLE_DSP */\n\n        s->clkidle[6] = value & 0x2;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x840:\t/* CM_CLKSEL_DSP */\n\n        s->clksel[7] = value & 0x3fff;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x848:\t/* CM_CLKSTCTRL_DSP */\n\n        s->clkctrl[3] = value & 0x101;\n\n        break;\n\n    case 0x850:\t/* RM_RSTCTRL_DSP */\n\n        /* TODO: reset */\n\n        break;\n\n    case 0x858:\t/* RM_RSTST_DSP */\n\n        s->rst[3] &= ~value;\n\n        break;\n\n    case 0x8c8:\t/* PM_WKDEP_DSP */\n\n        s->wkup[2] = value & 0x13;\n\n        break;\n\n    case 0x8e0:\t/* PM_PWSTCTRL_DSP */\n\n        s->power[3] = (value & 0x03017) | (3 << 2);\n\n        break;\n\n\n\n    case 0x8f0:\t/* PRCM_IRQSTATUS_DSP */\n\n        s->irqst[1] &= ~value;\n\n        omap_prcm_int_update(s, 1);\n\n        break;\n\n    case 0x8f4:\t/* PRCM_IRQENABLE_DSP */\n\n        s->irqen[1] = value & 0x7;\n\n        omap_prcm_int_update(s, 1);\n\n        break;\n\n\n\n    case 0x8f8:\t/* PRCM_IRQSTATUS_IVA */\n\n        s->irqst[2] &= ~value;\n\n        omap_prcm_int_update(s, 2);\n\n        break;\n\n    case 0x8fc:\t/* PRCM_IRQENABLE_IVA */\n\n        s->irqen[2] = value & 0x7;\n\n        omap_prcm_int_update(s, 2);\n\n        break;\n\n\n\n    default:\n\n        OMAP_BAD_REG(addr);\n\n        return;\n\n    }\n\n}\n", "idx": 24323}
{"project": "qemu", "commit_id": "c3a3a7d356c4df2fe145037172ae52cba5f545a5", "target": 0, "func": "int kvm_arch_init(KVMState *s, int smp_cpus)\n\n{\n\n    int ret;\n\n\n\n    struct utsname utsname;\n\n\n\n    uname(&utsname);\n\n    lm_capable_kernel = strcmp(utsname.machine, \"x86_64\") == 0;\n\n\n\n    /* create vm86 tss.  KVM uses vm86 mode to emulate 16-bit code\n\n     * directly.  In order to use vm86 mode, a TSS is needed.  Since this\n\n     * must be part of guest physical memory, we need to allocate it.  Older\n\n     * versions of KVM just assumed that it would be at the end of physical\n\n     * memory but that doesn't work with more than 4GB of memory.  We simply\n\n     * refuse to work with those older versions of KVM. */\n\n    ret = kvm_check_extension(s, KVM_CAP_SET_TSS_ADDR);\n\n    if (ret <= 0) {\n\n        fprintf(stderr, \"kvm does not support KVM_CAP_SET_TSS_ADDR\\n\");\n\n        return ret;\n\n    }\n\n\n\n    /* this address is 3 pages before the bios, and the bios should present\n\n     * as unavaible memory.  FIXME, need to ensure the e820 map deals with\n\n     * this?\n\n     */\n\n    /*\n\n     * Tell fw_cfg to notify the BIOS to reserve the range.\n\n     */\n\n    if (e820_add_entry(0xfffbc000, 0x4000, E820_RESERVED) < 0) {\n\n        perror(\"e820_add_entry() table is full\");\n\n        exit(1);\n\n    }\n\n    ret = kvm_vm_ioctl(s, KVM_SET_TSS_ADDR, 0xfffbd000);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return kvm_init_identity_map_page(s);\n\n}\n", "idx": 24324}
{"project": "qemu", "commit_id": "5379229a2708df3a1506113315214c3ce5325859", "target": 0, "func": "static void bootp_reply(Slirp *slirp, const struct bootp_t *bp)\n\n{\n\n    BOOTPClient *bc = NULL;\n\n    struct mbuf *m;\n\n    struct bootp_t *rbp;\n\n    struct sockaddr_in saddr, daddr;\n\n    struct in_addr preq_addr;\n\n    int dhcp_msg_type, val;\n\n    uint8_t *q;\n\n    uint8_t client_ethaddr[ETH_ALEN];\n\n\n\n    /* extract exact DHCP msg type */\n\n    dhcp_decode(bp, &dhcp_msg_type, &preq_addr);\n\n    DPRINTF(\"bootp packet op=%d msgtype=%d\", bp->bp_op, dhcp_msg_type);\n\n    if (preq_addr.s_addr != htonl(0L))\n\n        DPRINTF(\" req_addr=%08\" PRIx32 \"\\n\", ntohl(preq_addr.s_addr));\n\n    else\n\n        DPRINTF(\"\\n\");\n\n\n\n    if (dhcp_msg_type == 0)\n\n        dhcp_msg_type = DHCPREQUEST; /* Force reply for old BOOTP clients */\n\n\n\n    if (dhcp_msg_type != DHCPDISCOVER &&\n\n        dhcp_msg_type != DHCPREQUEST)\n\n        return;\n\n\n\n    /* Get client's hardware address from bootp request */\n\n    memcpy(client_ethaddr, bp->bp_hwaddr, ETH_ALEN);\n\n\n\n    m = m_get(slirp);\n\n    if (!m) {\n\n        return;\n\n    }\n\n    m->m_data += IF_MAXLINKHDR;\n\n    rbp = (struct bootp_t *)m->m_data;\n\n    m->m_data += sizeof(struct udpiphdr);\n\n    memset(rbp, 0, sizeof(struct bootp_t));\n\n\n\n    if (dhcp_msg_type == DHCPDISCOVER) {\n\n        if (preq_addr.s_addr != htonl(0L)) {\n\n            bc = request_addr(slirp, &preq_addr, client_ethaddr);\n\n            if (bc) {\n\n                daddr.sin_addr = preq_addr;\n\n            }\n\n        }\n\n        if (!bc) {\n\n         new_addr:\n\n            bc = get_new_addr(slirp, &daddr.sin_addr, client_ethaddr);\n\n            if (!bc) {\n\n                DPRINTF(\"no address left\\n\");\n\n                return;\n\n            }\n\n        }\n\n        memcpy(bc->macaddr, client_ethaddr, ETH_ALEN);\n\n    } else if (preq_addr.s_addr != htonl(0L)) {\n\n        bc = request_addr(slirp, &preq_addr, client_ethaddr);\n\n        if (bc) {\n\n            daddr.sin_addr = preq_addr;\n\n            memcpy(bc->macaddr, client_ethaddr, ETH_ALEN);\n\n        } else {\n\n            /* DHCPNAKs should be sent to broadcast */\n\n            daddr.sin_addr.s_addr = 0xffffffff;\n\n        }\n\n    } else {\n\n        bc = find_addr(slirp, &daddr.sin_addr, bp->bp_hwaddr);\n\n        if (!bc) {\n\n            /* if never assigned, behaves as if it was already\n\n               assigned (windows fix because it remembers its address) */\n\n            goto new_addr;\n\n        }\n\n    }\n\n\n\n    /* Update ARP table for this IP address */\n\n    arp_table_add(slirp, daddr.sin_addr.s_addr, client_ethaddr);\n\n\n\n    saddr.sin_addr = slirp->vhost_addr;\n\n    saddr.sin_port = htons(BOOTP_SERVER);\n\n\n\n    daddr.sin_port = htons(BOOTP_CLIENT);\n\n\n\n    rbp->bp_op = BOOTP_REPLY;\n\n    rbp->bp_xid = bp->bp_xid;\n\n    rbp->bp_htype = 1;\n\n    rbp->bp_hlen = 6;\n\n    memcpy(rbp->bp_hwaddr, bp->bp_hwaddr, ETH_ALEN);\n\n\n\n    rbp->bp_yiaddr = daddr.sin_addr; /* Client IP address */\n\n    rbp->bp_siaddr = saddr.sin_addr; /* Server IP address */\n\n\n\n    q = rbp->bp_vend;\n\n    memcpy(q, rfc1533_cookie, 4);\n\n    q += 4;\n\n\n\n    if (bc) {\n\n        DPRINTF(\"%s addr=%08\" PRIx32 \"\\n\",\n\n                (dhcp_msg_type == DHCPDISCOVER) ? \"offered\" : \"ack'ed\",\n\n                ntohl(daddr.sin_addr.s_addr));\n\n\n\n        if (dhcp_msg_type == DHCPDISCOVER) {\n\n            *q++ = RFC2132_MSG_TYPE;\n\n            *q++ = 1;\n\n            *q++ = DHCPOFFER;\n\n        } else /* DHCPREQUEST */ {\n\n            *q++ = RFC2132_MSG_TYPE;\n\n            *q++ = 1;\n\n            *q++ = DHCPACK;\n\n        }\n\n\n\n        if (slirp->bootp_filename)\n\n            snprintf((char *)rbp->bp_file, sizeof(rbp->bp_file), \"%s\",\n\n                     slirp->bootp_filename);\n\n\n\n        *q++ = RFC2132_SRV_ID;\n\n        *q++ = 4;\n\n        memcpy(q, &saddr.sin_addr, 4);\n\n        q += 4;\n\n\n\n        *q++ = RFC1533_NETMASK;\n\n        *q++ = 4;\n\n        memcpy(q, &slirp->vnetwork_mask, 4);\n\n        q += 4;\n\n\n\n        if (!slirp->restricted) {\n\n            *q++ = RFC1533_GATEWAY;\n\n            *q++ = 4;\n\n            memcpy(q, &saddr.sin_addr, 4);\n\n            q += 4;\n\n\n\n            *q++ = RFC1533_DNS;\n\n            *q++ = 4;\n\n            memcpy(q, &slirp->vnameserver_addr, 4);\n\n            q += 4;\n\n        }\n\n\n\n        *q++ = RFC2132_LEASE_TIME;\n\n        *q++ = 4;\n\n        val = htonl(LEASE_TIME);\n\n        memcpy(q, &val, 4);\n\n        q += 4;\n\n\n\n        if (*slirp->client_hostname) {\n\n            val = strlen(slirp->client_hostname);\n\n            *q++ = RFC1533_HOSTNAME;\n\n            *q++ = val;\n\n            memcpy(q, slirp->client_hostname, val);\n\n            q += val;\n\n        }\n\n\n\n        if (slirp->vdnssearch) {\n\n            size_t spaceleft = sizeof(rbp->bp_vend) - (q - rbp->bp_vend);\n\n            val = slirp->vdnssearch_len;\n\n            if (val + 1 > spaceleft) {\n\n                g_warning(\"DHCP packet size exceeded, \"\n\n                    \"omitting domain-search option.\");\n\n            } else {\n\n                memcpy(q, slirp->vdnssearch, val);\n\n                q += val;\n\n            }\n\n        }\n\n    } else {\n\n        static const char nak_msg[] = \"requested address not available\";\n\n\n\n        DPRINTF(\"nak'ed addr=%08\" PRIx32 \"\\n\", ntohl(preq_addr.s_addr));\n\n\n\n        *q++ = RFC2132_MSG_TYPE;\n\n        *q++ = 1;\n\n        *q++ = DHCPNAK;\n\n\n\n        *q++ = RFC2132_MESSAGE;\n\n        *q++ = sizeof(nak_msg) - 1;\n\n        memcpy(q, nak_msg, sizeof(nak_msg) - 1);\n\n        q += sizeof(nak_msg) - 1;\n\n    }\n\n    *q = RFC1533_END;\n\n\n\n    daddr.sin_addr.s_addr = 0xffffffffu;\n\n\n\n    m->m_len = sizeof(struct bootp_t) -\n\n        sizeof(struct ip) - sizeof(struct udphdr);\n\n    udp_output2(NULL, m, &saddr, &daddr, IPTOS_LOWDELAY);\n\n}\n", "idx": 24325}
{"project": "qemu", "commit_id": "715c54071a43ab978dc12b9da22a5016203ed284", "target": 0, "func": "static void spapr_reset_htab(sPAPRMachineState *spapr)\n\n{\n\n    long shift;\n\n    int index;\n\n\n\n    shift = kvmppc_reset_htab(spapr->htab_shift);\n\n    if (shift < 0) {\n\n        error_setg(&error_abort, \"Failed to reset HTAB\");\n\n    } else if (shift > 0) {\n\n        if (shift != spapr->htab_shift) {\n\n            error_setg(&error_abort, \"Requested HTAB allocation failed during reset\");\n\n        }\n\n\n\n        /* Tell readers to update their file descriptor */\n\n        if (spapr->htab_fd >= 0) {\n\n            spapr->htab_fd_stale = true;\n\n        }\n\n    } else {\n\n        memset(spapr->htab, 0, HTAB_SIZE(spapr));\n\n\n\n        for (index = 0; index < HTAB_SIZE(spapr) / HASH_PTE_SIZE_64; index++) {\n\n            DIRTY_HPTE(HPTE(spapr->htab, index));\n\n        }\n\n    }\n\n\n\n    /* Update the RMA size if necessary */\n\n    if (spapr->vrma_adjust) {\n\n        spapr->rma_size = kvmppc_rma_size(spapr_node0_size(),\n\n                                          spapr->htab_shift);\n\n    }\n\n}\n", "idx": 24326}
{"project": "qemu", "commit_id": "daa76aa416b1e18ab1fac650ff53d966d8f21f68", "target": 1, "func": "static void hmp_logfile(Monitor *mon, const QDict *qdict)\n\n{\n\n    qemu_set_log_filename(qdict_get_str(qdict, \"filename\"));\n\n}\n", "idx": 24327}
{"project": "qemu", "commit_id": "31478f26ab4ed82d35b763bbf259810d0c8b44e1", "target": 1, "func": "static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,\n\n                                            const char *name,\n\n                                            Error **errp)\n\n{\n\n    QObject *qobj;\n\n    QString *qstr;\n\n\n\n    qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    if (!qobj) {\n\n        return NULL;\n\n    }\n\n\n\n    qstr = qobject_to_qstring(qobj);\n\n    if (!qstr) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,\n\n                   full_name(qiv, name), \"string\");\n\n        return NULL;\n\n    }\n\n\n\n    return qstring_get_str(qstr);\n\n}\n", "idx": 24328}
{"project": "qemu", "commit_id": "b20909195745c34a819aed14ae996b60ab0f591f", "target": 1, "func": "iscsi_abort_task_cb(struct iscsi_context *iscsi, int status, void *command_data,\n\n                    void *private_data)\n\n{\n\n    IscsiAIOCB *acb = (IscsiAIOCB *)private_data;\n\n\n\n    scsi_free_scsi_task(acb->task);\n\n    acb->task = NULL;\n\n}\n", "idx": 24329}
{"project": "qemu", "commit_id": "88be7b4be4aa17c88247e162bdd7577ea79db94f", "target": 1, "func": "int bdrv_all_delete_snapshot(const char *name, BlockDriverState **first_bad_bs,\n\n                             Error **err)\n\n{\n\n    int ret = 0;\n\n    BlockDriverState *bs;\n\n    BdrvNextIterator *it = NULL;\n\n    QEMUSnapshotInfo sn1, *snapshot = &sn1;\n\n\n\n    while (ret == 0 && (it = bdrv_next(it, &bs))) {\n\n        AioContext *ctx = bdrv_get_aio_context(bs);\n\n\n\n        aio_context_acquire(ctx);\n\n        if (bdrv_can_snapshot(bs) &&\n\n                bdrv_snapshot_find(bs, snapshot, name) >= 0) {\n\n            ret = bdrv_snapshot_delete_by_id_or_name(bs, name, err);\n\n        }\n\n        aio_context_release(ctx);\n\n    }\n\n\n\n    *first_bad_bs = bs;\n\n    return ret;\n\n}\n", "idx": 24330}
{"project": "qemu", "commit_id": "74b6ce43e3aacbb101018407196fc963e2c39fea", "target": 1, "func": "static void qio_channel_socket_finalize(Object *obj)\n{\n    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(obj);\n    if (ioc->fd != -1) {\n#ifdef WIN32\n        WSAEventSelect(ioc->fd, NULL, 0);\n#endif\n        closesocket(ioc->fd);\n        ioc->fd = -1;", "idx": 24331}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static int nvme_start_ctrl(NvmeCtrl *n)\n\n{\n\n    uint32_t page_bits = NVME_CC_MPS(n->bar.cc) + 12;\n\n    uint32_t page_size = 1 << page_bits;\n\n\n\n    if (n->cq[0] || n->sq[0] || !n->bar.asq || !n->bar.acq ||\n\n            n->bar.asq & (page_size - 1) || n->bar.acq & (page_size - 1) ||\n\n            NVME_CC_MPS(n->bar.cc) < NVME_CAP_MPSMIN(n->bar.cap) ||\n\n            NVME_CC_MPS(n->bar.cc) > NVME_CAP_MPSMAX(n->bar.cap) ||\n\n            NVME_CC_IOCQES(n->bar.cc) < NVME_CTRL_CQES_MIN(n->id_ctrl.cqes) ||\n\n            NVME_CC_IOCQES(n->bar.cc) > NVME_CTRL_CQES_MAX(n->id_ctrl.cqes) ||\n\n            NVME_CC_IOSQES(n->bar.cc) < NVME_CTRL_SQES_MIN(n->id_ctrl.sqes) ||\n\n            NVME_CC_IOSQES(n->bar.cc) > NVME_CTRL_SQES_MAX(n->id_ctrl.sqes) ||\n\n            !NVME_AQA_ASQS(n->bar.aqa) || !NVME_AQA_ACQS(n->bar.aqa)) {\n\n        return -1;\n\n    }\n\n\n\n    n->page_bits = page_bits;\n\n    n->page_size = page_size;\n\n    n->max_prp_ents = n->page_size / sizeof(uint64_t);\n\n    n->cqe_size = 1 << NVME_CC_IOCQES(n->bar.cc);\n\n    n->sqe_size = 1 << NVME_CC_IOSQES(n->bar.cc);\n\n    nvme_init_cq(&n->admin_cq, n, n->bar.acq, 0, 0,\n\n        NVME_AQA_ACQS(n->bar.aqa) + 1, 1);\n\n    nvme_init_sq(&n->admin_sq, n, n->bar.asq, 0, 0,\n\n        NVME_AQA_ASQS(n->bar.aqa) + 1);\n\n\n\n    return 0;\n\n}\n", "idx": 24333}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void load_tco(const TestData *d)\n\n{\n\n    qpci_io_writew(d->dev, d->tco_io_base + TCO_RLD, 4);\n\n}\n", "idx": 24334}
{"project": "qemu", "commit_id": "4bc02e230d1e0fd41d2a892d81dcad56e3b3702d", "target": 1, "func": "target_ulong helper_srad(CPUPPCState *env, target_ulong value,\n\n                         target_ulong shift)\n\n{\n\n    int64_t ret;\n\n\n\n    if (likely(!(shift & 0x40))) {\n\n        if (likely((uint64_t)shift != 0)) {\n\n            shift &= 0x3f;\n\n            ret = (int64_t)value >> shift;\n\n            if (likely(ret >= 0 || (value & ((1 << shift) - 1)) == 0)) {\n\n                env->ca = 0;\n\n            } else {\n\n                env->ca = 1;\n\n            }\n\n        } else {\n\n            ret = (int64_t)value;\n\n            env->ca = 0;\n\n        }\n\n    } else {\n\n        ret = (int64_t)value >> 63;\n\n        env->ca = (ret != 0);\n\n    }\n\n    return ret;\n\n}\n", "idx": 24336}
{"project": "qemu", "commit_id": "baf35cb90204d75404892aa4e52628ae7a00669b", "target": 1, "func": "void qemu_aio_wait_end(void)\n\n{\n\n}\n", "idx": 24337}
{"project": "qemu", "commit_id": "e3cffe6fad29e07d401eabb913a6d88501d5c143", "target": 1, "func": "static target_ulong h_remove(PowerPCCPU *cpu, sPAPRMachineState *spapr,\n\n                             target_ulong opcode, target_ulong *args)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    target_ulong flags = args[0];\n\n    target_ulong pte_index = args[1];\n\n    target_ulong avpn = args[2];\n\n    RemoveResult ret;\n\n\n\n    ret = remove_hpte(cpu, pte_index, avpn, flags,\n\n                      &args[0], &args[1]);\n\n\n\n    switch (ret) {\n\n    case REMOVE_SUCCESS:\n\n        check_tlb_flush(env);\n\n        return H_SUCCESS;\n\n\n\n    case REMOVE_NOT_FOUND:\n\n        return H_NOT_FOUND;\n\n\n\n    case REMOVE_PARM:\n\n        return H_PARAMETER;\n\n\n\n    case REMOVE_HW:\n\n        return H_HARDWARE;\n\n    }\n\n\n\n    g_assert_not_reached();\n\n}\n", "idx": 24339}
{"project": "qemu", "commit_id": "45fe15c25a5c9feea6e0f78434f5e9f632de9d94", "target": 1, "func": "static int pci_ich9_uninit(PCIDevice *dev)\n\n{\n\n    struct AHCIPCIState *d;\n\n    d = DO_UPCAST(struct AHCIPCIState, card, dev);\n\n\n\n    if (msi_enabled(dev)) {\n\n        msi_uninit(dev);\n\n    }\n\n\n\n    qemu_unregister_reset(ahci_reset, d);\n\n    ahci_uninit(&d->ahci);\n\n\n\n    return 0;\n\n}\n", "idx": 24343}
{"project": "qemu", "commit_id": "62a2554ec2630896d1299e1a282a64c7f3b00da0", "target": 1, "func": "void ccw_dstream_init(CcwDataStream *cds, CCW1 const *ccw, ORB const *orb)\n{\n    /*\n     * We don't support MIDA (an optional facility) yet and we\n     * catch this earlier. Just for expressing the precondition.\n     */\n    g_assert(!(orb->ctrl1 & ORB_CTRL1_MASK_MIDAW));\n    cds->flags = (orb->ctrl0 & ORB_CTRL0_MASK_I2K ? CDS_F_I2K : 0) |\n                 (orb->ctrl0 & ORB_CTRL0_MASK_C64 ? CDS_F_C64 : 0) |\n                 (ccw->flags & CCW_FLAG_IDA ? CDS_F_IDA : 0);\n    cds->count = ccw->count;\n    cds->cda_orig = ccw->cda;\n    ccw_dstream_rewind(cds);\n    if (!(cds->flags & CDS_F_IDA)) {\n        cds->op_handler = ccw_dstream_rw_noflags;\n    } else {\n        assert(false);\n    }\n}", "idx": 24345}
{"project": "qemu", "commit_id": "5a693efda84d7df5136cc2bd31c959bb1530b0c9", "target": 1, "func": "static int vnc_update_client(VncState *vs, int has_dirty, bool sync)\n\n{\n\n    vs->has_dirty += has_dirty;\n\n    if (vs->need_update && vs->ioc != NULL) {\n\n        VncDisplay *vd = vs->vd;\n\n        VncJob *job;\n\n        int y;\n\n        int height, width;\n\n        int n = 0;\n\n\n\n        if (vs->output.offset && !vs->audio_cap && !vs->force_update)\n\n            /* kernel send buffers are full -> drop frames to throttle */\n\n            return 0;\n\n\n\n        if (!vs->has_dirty && !vs->audio_cap && !vs->force_update)\n\n            return 0;\n\n\n\n        /*\n\n         * Send screen updates to the vnc client using the server\n\n         * surface and server dirty map.  guest surface updates\n\n         * happening in parallel don't disturb us, the next pass will\n\n         * send them to the client.\n\n         */\n\n        job = vnc_job_new(vs);\n\n\n\n        height = pixman_image_get_height(vd->server);\n\n        width = pixman_image_get_width(vd->server);\n\n\n\n        y = 0;\n\n        for (;;) {\n\n            int x, h;\n\n            unsigned long x2;\n\n            unsigned long offset = find_next_bit((unsigned long *) &vs->dirty,\n\n                                                 height * VNC_DIRTY_BPL(vs),\n\n                                                 y * VNC_DIRTY_BPL(vs));\n\n            if (offset == height * VNC_DIRTY_BPL(vs)) {\n\n                /* no more dirty bits */\n\n                break;\n\n            }\n\n            y = offset / VNC_DIRTY_BPL(vs);\n\n            x = offset % VNC_DIRTY_BPL(vs);\n\n            x2 = find_next_zero_bit((unsigned long *) &vs->dirty[y],\n\n                                    VNC_DIRTY_BPL(vs), x);\n\n            bitmap_clear(vs->dirty[y], x, x2 - x);\n\n            h = find_and_clear_dirty_height(vs, y, x, x2, height);\n\n            x2 = MIN(x2, width / VNC_DIRTY_PIXELS_PER_BIT);\n\n            if (x2 > x) {\n\n                n += vnc_job_add_rect(job, x * VNC_DIRTY_PIXELS_PER_BIT, y,\n\n                                      (x2 - x) * VNC_DIRTY_PIXELS_PER_BIT, h);\n\n            }\n\n            if (!x && x2 == width / VNC_DIRTY_PIXELS_PER_BIT) {\n\n                y += h;\n\n                if (y == height) {\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n        vnc_job_push(job);\n\n        if (sync) {\n\n            vnc_jobs_join(vs);\n\n        }\n\n        vs->force_update = 0;\n\n        vs->has_dirty = 0;\n\n        return n;\n\n    }\n\n\n\n    if (vs->disconnecting) {\n\n        vnc_disconnect_finish(vs);\n\n    } else if (sync) {\n\n        vnc_jobs_join(vs);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24347}
{"project": "qemu", "commit_id": "0bd8246bfec1dfb2eb959f52db535572c0260f4c", "target": 1, "func": "static void vga_invalidate_display(void *opaque)\n\n{\n\n    VGAState *s = (VGAState *)opaque;\n\n\n\n    s->last_width = -1;\n\n    s->last_height = -1;\n\n}\n", "idx": 24349}
{"project": "qemu", "commit_id": "c9262e8a84a29f22fbb5edde5d17f4f6166d5ae1", "target": 1, "func": "static void virtio_setup(uint64_t dev_info)\n\n{\n\n    struct schib schib;\n\n    int ssid;\n\n    bool found = false;\n\n    uint16_t dev_no;\n\n\n\n    /*\n\n     * We unconditionally enable mss support. In every sane configuration,\n\n     * this will succeed; and even if it doesn't, stsch_err() can deal\n\n     * with the consequences.\n\n     */\n\n    enable_mss_facility();\n\n\n\n    if (dev_info != -1) {\n\n        dev_no = dev_info & 0xffff;\n\n        debug_print_int(\"device no. \", dev_no);\n\n        blk_schid.ssid = (dev_info >> 16) & 0x3;\n\n        debug_print_int(\"ssid \", blk_schid.ssid);\n\n        found = find_dev(&schib, dev_no);\n\n    } else {\n\n        for (ssid = 0; ssid < 0x3; ssid++) {\n\n            blk_schid.ssid = ssid;\n\n            found = find_dev(&schib, -1);\n\n            if (found) {\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!found) {\n\n        virtio_panic(\"No virtio-blk device found!\\n\");\n\n    }\n\n\n\n    virtio_setup_block(blk_schid);\n\n\n\n    if (!virtio_ipl_disk_is_valid()) {\n\n        virtio_panic(\"No valid hard disk detected.\\n\");\n\n    }\n\n}\n", "idx": 24350}
{"project": "qemu", "commit_id": "c9add6219514b20223f024584f0464b8842b1ec0", "target": 1, "func": "bool ftrace_init(void)\n\n{\n\n    char mount_point[PATH_MAX];\n\n    char path[PATH_MAX];\n\n    int debugfs_found;\n\n    int trace_fd = -1;\n\n\n\n    debugfs_found = find_mount(mount_point, \"debugfs\");\n\n    if (debugfs_found) {\n\n        snprintf(path, PATH_MAX, \"%s/tracing/tracing_on\", mount_point);\n\n        trace_fd = open(path, O_WRONLY);\n\n        if (trace_fd < 0) {\n\n            if (errno == EACCES) {\n\n                trace_marker_fd = open(\"/dev/null\", O_WRONLY);\n\n                if (trace_marker_fd != -1) {\n\n                    return true;\n\n                }\n\n            }\n\n            perror(\"Could not open ftrace 'tracing_on' file\");\n\n            return false;\n\n        } else {\n\n            if (write(trace_fd, \"1\", 1) < 0) {\n\n                perror(\"Could not write to 'tracing_on' file\");\n\n                close(trace_fd);\n\n                return false;\n\n            }\n\n            close(trace_fd);\n\n        }\n\n        snprintf(path, PATH_MAX, \"%s/tracing/trace_marker\", mount_point);\n\n        trace_marker_fd = open(path, O_WRONLY);\n\n        if (trace_marker_fd < 0) {\n\n            perror(\"Could not open ftrace 'trace_marker' file\");\n\n            return false;\n\n        }\n\n    } else {\n\n        fprintf(stderr, \"debugfs is not mounted\\n\");\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 24351}
{"project": "qemu", "commit_id": "cc2a90432d9cb7546a2c4360ad7200a2fb3af31a", "target": 1, "func": "static void qemu_cleanup_net_client(NetClientState *nc)\n\n{\n\n    QTAILQ_REMOVE(&net_clients, nc, next);\n\n\n\n    nc->info->cleanup(nc);\n\n}\n", "idx": 24352}
{"project": "qemu", "commit_id": "828808f5ece20fd606218e000139799921c89d93", "target": 1, "func": "static void tcg_out_op (TCGContext *s, int opc, const TCGArg *args,\n\n                        const int *const_args)\n\n{\n\n    int c;\n\n\n\n    switch (opc) {\n\n    case INDEX_op_exit_tb:\n\n        tcg_out_movi (s, TCG_TYPE_I64, TCG_REG_R3, args[0]);\n\n        tcg_out_b (s, 0, (tcg_target_long) tb_ret_addr);\n\n        break;\n\n    case INDEX_op_goto_tb:\n\n        if (s->tb_jmp_offset) {\n\n            /* direct jump method */\n\n\n\n            s->tb_jmp_offset[args[0]] = s->code_ptr - s->code_buf;\n\n            s->code_ptr += 28;\n\n        }\n\n        else {\n\n            tcg_abort ();\n\n        }\n\n        s->tb_next_offset[args[0]] = s->code_ptr - s->code_buf;\n\n        break;\n\n    case INDEX_op_br:\n\n        {\n\n            TCGLabel *l = &s->labels[args[0]];\n\n\n\n            if (l->has_value) {\n\n                tcg_out_b (s, 0, l->u.value);\n\n            }\n\n            else {\n\n                uint32_t val = *(uint32_t *) s->code_ptr;\n\n\n\n                /* Thanks to Andrzej Zaborowski */\n\n                tcg_out32 (s, B | (val & 0x3fffffc));\n\n                tcg_out_reloc (s, s->code_ptr - 4, R_PPC_REL24, args[0], 0);\n\n            }\n\n        }\n\n        break;\n\n    case INDEX_op_call:\n\n        tcg_out_call (s, args[0], const_args[0]);\n\n        break;\n\n    case INDEX_op_jmp:\n\n        if (const_args[0]) {\n\n            tcg_out_b (s, 0, args[0]);\n\n        }\n\n        else {\n\n            tcg_out32 (s, MTSPR | RS (args[0]) | CTR);\n\n            tcg_out32 (s, BCCTR | BO_ALWAYS);\n\n        }\n\n        break;\n\n    case INDEX_op_movi_i32:\n\n        tcg_out_movi (s, TCG_TYPE_I32, args[0], args[1]);\n\n        break;\n\n    case INDEX_op_movi_i64:\n\n        tcg_out_movi (s, TCG_TYPE_I64, args[0], args[1]);\n\n        break;\n\n    case INDEX_op_ld8u_i32:\n\n    case INDEX_op_ld8u_i64:\n\n        tcg_out_ldst (s, args[0], args[1], args[2], LBZ, LBZX);\n\n        break;\n\n    case INDEX_op_ld8s_i32:\n\n    case INDEX_op_ld8s_i64:\n\n        tcg_out_ldst (s, args[0], args[1], args[2], LBZ, LBZX);\n\n        tcg_out32 (s, EXTSB | RS (args[0]) | RA (args[0]));\n\n        break;\n\n    case INDEX_op_ld16u_i32:\n\n    case INDEX_op_ld16u_i64:\n\n        tcg_out_ldst (s, args[0], args[1], args[2], LHZ, LHZX);\n\n        break;\n\n    case INDEX_op_ld16s_i32:\n\n    case INDEX_op_ld16s_i64:\n\n        tcg_out_ldst (s, args[0], args[1], args[2], LHA, LHAX);\n\n        break;\n\n    case INDEX_op_ld_i32:\n\n    case INDEX_op_ld32u_i64:\n\n        tcg_out_ldst (s, args[0], args[1], args[2], LWZ, LWZX);\n\n        break;\n\n    case INDEX_op_ld32s_i64:\n\n        tcg_out_ldst (s, args[0], args[1], args[2], LWA, LWAX);\n\n        break;\n\n    case INDEX_op_ld_i64:\n\n        tcg_out_ldst (s, args[0], args[1], args[2], LD, LDX);\n\n        break;\n\n    case INDEX_op_st8_i32:\n\n    case INDEX_op_st8_i64:\n\n        tcg_out_ldst (s, args[0], args[1], args[2], STB, STBX);\n\n        break;\n\n    case INDEX_op_st16_i32:\n\n    case INDEX_op_st16_i64:\n\n        tcg_out_ldst (s, args[0], args[1], args[2], STH, STHX);\n\n        break;\n\n    case INDEX_op_st_i32:\n\n    case INDEX_op_st32_i64:\n\n        tcg_out_ldst (s, args[0], args[1], args[2], STW, STWX);\n\n        break;\n\n    case INDEX_op_st_i64:\n\n        tcg_out_ldst (s, args[0], args[1], args[2], STD, STDX);\n\n        break;\n\n\n\n    case INDEX_op_add_i32:\n\n        if (const_args[2])\n\n            ppc_addi32 (s, args[0], args[1], args[2]);\n\n        else\n\n            tcg_out32 (s, ADD | TAB (args[0], args[1], args[2]));\n\n        break;\n\n    case INDEX_op_sub_i32:\n\n        if (const_args[2])\n\n            ppc_addi32 (s, args[0], args[1], -args[2]);\n\n        else\n\n            tcg_out32 (s, SUBF | TAB (args[0], args[2], args[1]));\n\n        break;\n\n\n\n    case INDEX_op_and_i64:\n\n    case INDEX_op_and_i32:\n\n        if (const_args[2]) {\n\n            if ((args[2] & 0xffff) == args[2])\n\n                tcg_out32 (s, ANDI | RS (args[1]) | RA (args[0]) | args[2]);\n\n            else if ((args[2] & 0xffff0000) == args[2])\n\n                tcg_out32 (s, ANDIS | RS (args[1]) | RA (args[0])\n\n                           | ((args[2] >> 16) & 0xffff));\n\n            else {\n\n                tcg_out_movi (s, (opc == INDEX_op_and_i32\n\n                                  ? TCG_TYPE_I32\n\n                                  : TCG_TYPE_I64),\n\n                              0, args[2]);\n\n                tcg_out32 (s, AND | SAB (args[1], args[0], 0));\n\n            }\n\n        }\n\n        else\n\n            tcg_out32 (s, AND | SAB (args[1], args[0], args[2]));\n\n        break;\n\n    case INDEX_op_or_i64:\n\n    case INDEX_op_or_i32:\n\n        if (const_args[2]) {\n\n            if (args[2] & 0xffff) {\n\n                tcg_out32 (s, ORI | RS (args[1]) | RA (args[0])\n\n                           | (args[2] & 0xffff));\n\n                if (args[2] >> 16)\n\n                    tcg_out32 (s, ORIS | RS (args[0])  | RA (args[0])\n\n                               | ((args[2] >> 16) & 0xffff));\n\n            }\n\n            else {\n\n                tcg_out32 (s, ORIS | RS (args[1])  | RA (args[0])\n\n                           | ((args[2] >> 16) & 0xffff));\n\n            }\n\n        }\n\n        else\n\n            tcg_out32 (s, OR | SAB (args[1], args[0], args[2]));\n\n        break;\n\n    case INDEX_op_xor_i64:\n\n    case INDEX_op_xor_i32:\n\n        if (const_args[2]) {\n\n            if ((args[2] & 0xffff) == args[2])\n\n                tcg_out32 (s, XORI | RS (args[1])  | RA (args[0])\n\n                           | (args[2] & 0xffff));\n\n            else if ((args[2] & 0xffff0000) == args[2])\n\n                tcg_out32 (s, XORIS | RS (args[1])  | RA (args[0])\n\n                           | ((args[2] >> 16) & 0xffff));\n\n            else {\n\n                tcg_out_movi (s, (opc == INDEX_op_and_i32\n\n                                  ? TCG_TYPE_I32\n\n                                  : TCG_TYPE_I64),\n\n                              0, args[2]);\n\n                tcg_out32 (s, XOR | SAB (args[1], args[0], 0));\n\n            }\n\n        }\n\n        else\n\n            tcg_out32 (s, XOR | SAB (args[1], args[0], args[2]));\n\n        break;\n\n\n\n    case INDEX_op_mul_i32:\n\n        if (const_args[2]) {\n\n            if (args[2] == (int16_t) args[2])\n\n                tcg_out32 (s, MULLI | RT (args[0]) | RA (args[1])\n\n                           | (args[2] & 0xffff));\n\n            else {\n\n                tcg_out_movi (s, TCG_TYPE_I32, 0, args[2]);\n\n                tcg_out32 (s, MULLW | TAB (args[0], args[1], 0));\n\n            }\n\n        }\n\n        else\n\n            tcg_out32 (s, MULLW | TAB (args[0], args[1], args[2]));\n\n        break;\n\n\n\n    case INDEX_op_div_i32:\n\n        tcg_out32 (s, DIVW | TAB (args[0], args[1], args[2]));\n\n        break;\n\n\n\n    case INDEX_op_divu_i32:\n\n        tcg_out32 (s, DIVWU | TAB (args[0], args[1], args[2]));\n\n        break;\n\n\n\n    case INDEX_op_rem_i32:\n\n        tcg_out32 (s, DIVW | TAB (0, args[1], args[2]));\n\n        tcg_out32 (s, MULLW | TAB (0, 0, args[2]));\n\n        tcg_out32 (s, SUBF | TAB (args[0], 0, args[1]));\n\n        break;\n\n\n\n    case INDEX_op_remu_i32:\n\n        tcg_out32 (s, DIVWU | TAB (0, args[1], args[2]));\n\n        tcg_out32 (s, MULLW | TAB (0, 0, args[2]));\n\n        tcg_out32 (s, SUBF | TAB (args[0], 0, args[1]));\n\n        break;\n\n\n\n    case INDEX_op_shl_i32:\n\n        if (const_args[2]) {\n\n            tcg_out32 (s, (RLWINM\n\n                           | RA (args[0])\n\n                           | RS (args[1])\n\n                           | SH (args[2])\n\n                           | MB (0)\n\n                           | ME (31 - args[2])\n\n                           )\n\n                );\n\n        }\n\n        else\n\n            tcg_out32 (s, SLW | SAB (args[1], args[0], args[2]));\n\n        break;\n\n    case INDEX_op_shr_i32:\n\n        if (const_args[2]) {\n\n            tcg_out32 (s, (RLWINM\n\n                           | RA (args[0])\n\n                           | RS (args[1])\n\n                           | SH (32 - args[2])\n\n                           | MB (args[2])\n\n                           | ME (31)\n\n                           )\n\n                );\n\n        }\n\n        else\n\n            tcg_out32 (s, SRW | SAB (args[1], args[0], args[2]));\n\n        break;\n\n    case INDEX_op_sar_i32:\n\n        if (const_args[2])\n\n            tcg_out32 (s, SRAWI | RS (args[1]) | RA (args[0]) | SH (args[2]));\n\n        else\n\n            tcg_out32 (s, SRAW | SAB (args[1], args[0], args[2]));\n\n        break;\n\n\n\n    case INDEX_op_brcond_i32:\n\n        tcg_out_brcond (s, args[2], args[0], args[1], const_args[1], args[3], 0);\n\n        break;\n\n\n\n    case INDEX_op_brcond_i64:\n\n        tcg_out_brcond (s, args[2], args[0], args[1], const_args[1], args[3], 1);\n\n        break;\n\n\n\n    case INDEX_op_neg_i32:\n\n    case INDEX_op_neg_i64:\n\n        tcg_out32 (s, NEG | RT (args[0]) | RA (args[1]));\n\n        break;\n\n\n\n    case INDEX_op_add_i64:\n\n        if (const_args[2])\n\n            ppc_addi64 (s, args[0], args[1], args[2]);\n\n        else\n\n            tcg_out32 (s, ADD | TAB (args[0], args[1], args[2]));\n\n        break;\n\n    case INDEX_op_sub_i64:\n\n        if (const_args[2])\n\n            ppc_addi64 (s, args[0], args[1], -args[2]);\n\n        else\n\n            tcg_out32 (s, SUBF | TAB (args[0], args[2], args[1]));\n\n        break;\n\n\n\n    case INDEX_op_shl_i64:\n\n        if (const_args[2])\n\n            tcg_out_rld (s, RLDICR, args[0], args[1], args[2], 63 - args[2]);\n\n        else\n\n            tcg_out32 (s, SLD | SAB (args[1], args[0], args[2]));\n\n        break;\n\n    case INDEX_op_shr_i64:\n\n        if (const_args[2])\n\n            tcg_out_rld (s, RLDICL, args[0], args[1], 64 - args[2], args[2]);\n\n        else\n\n            tcg_out32 (s, SRD | SAB (args[1], args[0], args[2]));\n\n        break;\n\n    case INDEX_op_sar_i64:\n\n        if (const_args[2]) {\n\n            int sh = SH (args[2] & 0x1f) | (((args[2] >> 5) & 1) << 1);\n\n            tcg_out32 (s, SRADI | RA (args[0]) | RS (args[1]) | sh);\n\n        }\n\n        else\n\n            tcg_out32 (s, SRAD | SAB (args[1], args[0], args[2]));\n\n        break;\n\n\n\n    case INDEX_op_mul_i64:\n\n        tcg_out32 (s, MULLD | TAB (args[0], args[1], args[2]));\n\n        break;\n\n    case INDEX_op_div_i64:\n\n        tcg_out32 (s, DIVD | TAB (args[0], args[1], args[2]));\n\n        break;\n\n    case INDEX_op_divu_i64:\n\n        tcg_out32 (s, DIVDU | TAB (args[0], args[1], args[2]));\n\n        break;\n\n    case INDEX_op_rem_i64:\n\n        tcg_out32 (s, DIVD | TAB (0, args[1], args[2]));\n\n        tcg_out32 (s, MULLD | TAB (0, 0, args[2]));\n\n        tcg_out32 (s, SUBF | TAB (args[0], 0, args[1]));\n\n        break;\n\n    case INDEX_op_remu_i64:\n\n        tcg_out32 (s, DIVDU | TAB (0, args[1], args[2]));\n\n        tcg_out32 (s, MULLD | TAB (0, 0, args[2]));\n\n        tcg_out32 (s, SUBF | TAB (args[0], 0, args[1]));\n\n        break;\n\n\n\n    case INDEX_op_qemu_ld8u:\n\n        tcg_out_qemu_ld (s, args, 0);\n\n        break;\n\n    case INDEX_op_qemu_ld8s:\n\n        tcg_out_qemu_ld (s, args, 0 | 4);\n\n        break;\n\n    case INDEX_op_qemu_ld16u:\n\n        tcg_out_qemu_ld (s, args, 1);\n\n        break;\n\n    case INDEX_op_qemu_ld16s:\n\n        tcg_out_qemu_ld (s, args, 1 | 4);\n\n        break;\n\n    case INDEX_op_qemu_ld32u:\n\n        tcg_out_qemu_ld (s, args, 2);\n\n        break;\n\n    case INDEX_op_qemu_ld32s:\n\n        tcg_out_qemu_ld (s, args, 2 | 4);\n\n        break;\n\n    case INDEX_op_qemu_ld64:\n\n        tcg_out_qemu_ld (s, args, 3);\n\n        break;\n\n    case INDEX_op_qemu_st8:\n\n        tcg_out_qemu_st (s, args, 0);\n\n        break;\n\n    case INDEX_op_qemu_st16:\n\n        tcg_out_qemu_st (s, args, 1);\n\n        break;\n\n    case INDEX_op_qemu_st32:\n\n        tcg_out_qemu_st (s, args, 2);\n\n        break;\n\n    case INDEX_op_qemu_st64:\n\n        tcg_out_qemu_st (s, args, 3);\n\n        break;\n\n\n\n    case INDEX_op_ext8s_i32:\n\n    case INDEX_op_ext8s_i64:\n\n        c = EXTSB;\n\n        goto gen_ext;\n\n    case INDEX_op_ext16s_i32:\n\n    case INDEX_op_ext16s_i64:\n\n        c = EXTSH;\n\n        goto gen_ext;\n\n    case INDEX_op_ext32s_i64:\n\n        c = EXTSW;\n\n        goto gen_ext;\n\n    gen_ext:\n\n        tcg_out32 (s, c | RS (args[1]) | RA (args[0]));\n\n        break;\n\n\n\n    default:\n\n        tcg_dump_ops (s, stderr);\n\n        tcg_abort ();\n\n    }\n\n}\n", "idx": 24353}
{"project": "qemu", "commit_id": "f8762027a33e2f5d0915c56a904962b1481f75c1", "target": 1, "func": "static int socket_accept(int sock)\n\n{\n\n    struct sockaddr_un addr;\n\n    socklen_t addrlen;\n\n    int ret;\n\n\n\n    addrlen = sizeof(addr);\n\n    do {\n\n        ret = accept(sock, (struct sockaddr *)&addr, &addrlen);\n\n    } while (ret == -1 && errno == EINTR);\n\n    g_assert_no_errno(ret);\n\n    close(sock);\n\n\n\n    return ret;\n\n}\n", "idx": 24354}
{"project": "qemu", "commit_id": "258133bda9a6f22ba436ef9b63b7c086cc80190b", "target": 1, "func": "ivshmem_server_handle_new_conn(IvshmemServer *server)\n\n{\n\n    IvshmemServerPeer *peer, *other_peer;\n\n    struct sockaddr_un unaddr;\n\n    socklen_t unaddr_len;\n\n    int newfd;\n\n    unsigned i;\n\n\n\n    /* accept the incoming connection */\n\n    unaddr_len = sizeof(unaddr);\n\n    newfd = qemu_accept(server->sock_fd,\n\n                        (struct sockaddr *)&unaddr, &unaddr_len);\n\n\n\n    if (newfd < 0) {\n\n        IVSHMEM_SERVER_DEBUG(server, \"cannot accept() %s\\n\", strerror(errno));\n\n        return -1;\n\n    }\n\n\n\n    qemu_set_nonblock(newfd);\n\n    IVSHMEM_SERVER_DEBUG(server, \"accept()=%d\\n\", newfd);\n\n\n\n    /* allocate new structure for this peer */\n\n    peer = g_malloc0(sizeof(*peer));\n\n    peer->sock_fd = newfd;\n\n\n\n    /* get an unused peer id */\n\n    /* XXX: this could use id allocation such as Linux IDA, or simply\n\n     * a free-list */\n\n    for (i = 0; i < G_MAXUINT16; i++) {\n\n        if (ivshmem_server_search_peer(server, server->cur_id) == NULL) {\n\n            break;\n\n        }\n\n        server->cur_id++;\n\n    }\n\n    if (i == G_MAXUINT16) {\n\n        IVSHMEM_SERVER_DEBUG(server, \"cannot allocate new client id\\n\");\n\n        goto fail;\n\n    }\n\n    peer->id = server->cur_id++;\n\n\n\n    /* create eventfd, one per vector */\n\n    peer->vectors_count = server->n_vectors;\n\n    for (i = 0; i < peer->vectors_count; i++) {\n\n        if (event_notifier_init(&peer->vectors[i], FALSE) < 0) {\n\n            IVSHMEM_SERVER_DEBUG(server, \"cannot create eventfd\\n\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    /* send peer id and shm fd */\n\n    if (ivshmem_server_send_initial_info(server, peer) < 0) {\n\n        IVSHMEM_SERVER_DEBUG(server, \"cannot send initial info\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    /* advertise the new peer to others */\n\n    QTAILQ_FOREACH(other_peer, &server->peer_list, next) {\n\n        for (i = 0; i < peer->vectors_count; i++) {\n\n            ivshmem_server_send_one_msg(other_peer->sock_fd, peer->id,\n\n                                        peer->vectors[i].wfd);\n\n        }\n\n    }\n\n\n\n    /* advertise the other peers to the new one */\n\n    QTAILQ_FOREACH(other_peer, &server->peer_list, next) {\n\n        for (i = 0; i < peer->vectors_count; i++) {\n\n            ivshmem_server_send_one_msg(peer->sock_fd, other_peer->id,\n\n                                        other_peer->vectors[i].wfd);\n\n        }\n\n    }\n\n\n\n    /* advertise the new peer to itself */\n\n    for (i = 0; i < peer->vectors_count; i++) {\n\n        ivshmem_server_send_one_msg(peer->sock_fd, peer->id,\n\n                                    event_notifier_get_fd(&peer->vectors[i]));\n\n    }\n\n\n\n    QTAILQ_INSERT_TAIL(&server->peer_list, peer, next);\n\n    IVSHMEM_SERVER_DEBUG(server, \"new peer id = %\" PRId64 \"\\n\",\n\n                         peer->id);\n\n    return 0;\n\n\n\nfail:\n\n    while (i--) {\n\n        event_notifier_cleanup(&peer->vectors[i]);\n\n    }\n\n    close(newfd);\n\n    g_free(peer);\n\n    return -1;\n\n}\n", "idx": 24355}
{"project": "qemu", "commit_id": "77be4366baface6613cfc312ba281f8e5860997c", "target": 1, "func": "static int multiwrite_req_compare(const void *a, const void *b)\n\n{\n\n    return (((BlockRequest*) a)->sector - ((BlockRequest*) b)->sector);\n\n}\n", "idx": 24359}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void a15_daughterboard_init(const VexpressMachineState *vms,\n\n                                   ram_addr_t ram_size,\n\n                                   const char *cpu_model,\n\n                                   qemu_irq *pic)\n\n{\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *sram = g_new(MemoryRegion, 1);\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"cortex-a15\";\n\n    }\n\n\n\n    {\n\n        /* We have to use a separate 64 bit variable here to avoid the gcc\n\n         * \"comparison is always false due to limited range of data type\"\n\n         * warning if we are on a host where ram_addr_t is 32 bits.\n\n         */\n\n        uint64_t rsz = ram_size;\n\n        if (rsz > (30ULL * 1024 * 1024 * 1024)) {\n\n            fprintf(stderr, \"vexpress-a15: cannot model more than 30GB RAM\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    memory_region_allocate_system_memory(ram, NULL, \"vexpress.highmem\",\n\n                                         ram_size);\n\n    /* RAM is from 0x80000000 upwards; there is no low-memory alias for it. */\n\n    memory_region_add_subregion(sysmem, 0x80000000, ram);\n\n\n\n    /* 0x2c000000 A15MPCore private memory region (GIC) */\n\n    init_cpus(cpu_model, \"a15mpcore_priv\", 0x2c000000, pic, vms->secure);\n\n\n\n    /* A15 daughterboard peripherals: */\n\n\n\n    /* 0x20000000: CoreSight interfaces: not modelled */\n\n    /* 0x2a000000: PL301 AXI interconnect: not modelled */\n\n    /* 0x2a420000: SCC: not modelled */\n\n    /* 0x2a430000: system counter: not modelled */\n\n    /* 0x2b000000: HDLCD controller: not modelled */\n\n    /* 0x2b060000: SP805 watchdog: not modelled */\n\n    /* 0x2b0a0000: PL341 dynamic memory controller: not modelled */\n\n    /* 0x2e000000: system SRAM */\n\n    memory_region_init_ram(sram, NULL, \"vexpress.a15sram\", 0x10000,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(sram);\n\n    memory_region_add_subregion(sysmem, 0x2e000000, sram);\n\n\n\n    /* 0x7ffb0000: DMA330 DMA controller: not modelled */\n\n    /* 0x7ffd0000: PL354 static memory controller: not modelled */\n\n}\n", "idx": 24362}
{"project": "qemu", "commit_id": "3604a76fea6ff37738d4a8f596be38407be74a83", "target": 1, "func": "static void dec_sl(DisasContext *dc)\n\n{\n\n    if (dc->format == OP_FMT_RI) {\n\n        LOG_DIS(\"sli r%d, r%d, %d\\n\", dc->r1, dc->r0, dc->imm5);\n\n    } else {\n\n        LOG_DIS(\"sl r%d, r%d, r%d\\n\", dc->r2, dc->r0, dc->r1);\n\n    }\n\n\n\n    if (!(dc->env->features & LM32_FEATURE_SHIFT)) {\n\n        cpu_abort(dc->env, \"hardware shifter is not available\\n\");\n\n    }\n\n\n\n    if (dc->format == OP_FMT_RI) {\n\n        tcg_gen_shli_tl(cpu_R[dc->r1], cpu_R[dc->r0], dc->imm5);\n\n    } else {\n\n        TCGv t0 = tcg_temp_new();\n\n        tcg_gen_andi_tl(t0, cpu_R[dc->r1], 0x1f);\n\n        tcg_gen_shl_tl(cpu_R[dc->r2], cpu_R[dc->r0], t0);\n\n        tcg_temp_free(t0);\n\n    }\n\n}\n", "idx": 24363}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)\n\n{\n\n    if (!error_is_set(errp)) {\n\n        v->type_int(v, obj, name, errp);\n\n    }\n\n}\n", "idx": 24364}
{"project": "qemu", "commit_id": "e1cf5582644ef63528993fb2b88dd3b43b9914c6", "target": 1, "func": "void qemu_iovec_init(QEMUIOVector *qiov, int alloc_hint)\n\n{\n\n    qiov->iov = g_malloc(alloc_hint * sizeof(struct iovec));\n\n    qiov->niov = 0;\n\n    qiov->nalloc = alloc_hint;\n\n    qiov->size = 0;\n\n}\n", "idx": 24365}
{"project": "qemu", "commit_id": "231bb267644ee3a9ebfd9c7f42d5d41610194b45", "target": 1, "func": "static int write_reftable_entry(BlockDriverState *bs, int rt_index)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t buf[RT_ENTRIES_PER_SECTOR];\n\n    int rt_start_index;\n\n    int i, ret;\n\n\n\n    rt_start_index = rt_index & ~(RT_ENTRIES_PER_SECTOR - 1);\n\n    for (i = 0; i < RT_ENTRIES_PER_SECTOR; i++) {\n\n        buf[i] = cpu_to_be64(s->refcount_table[rt_start_index + i]);\n\n    }\n\n\n\n    ret = qcow2_pre_write_overlap_check(bs,\n\n            QCOW2_OL_DEFAULT & ~QCOW2_OL_REFCOUNT_TABLE,\n\n            s->refcount_table_offset + rt_start_index * sizeof(uint64_t),\n\n            sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_UPDATE);\n\n    ret = bdrv_pwrite_sync(bs->file, s->refcount_table_offset +\n\n            rt_start_index * sizeof(uint64_t), buf, sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24367}
{"project": "qemu", "commit_id": "f8762027a33e2f5d0915c56a904962b1481f75c1", "target": 1, "func": "QTestState *qtest_init(const char *extra_args)\n\n{\n\n    QTestState *s;\n\n    int sock, qmpsock, i;\n\n    gchar *socket_path;\n\n    gchar *qmp_socket_path;\n\n    gchar *command;\n\n    const char *qemu_binary;\n\n    struct sigaction sigact;\n\n\n\n    qemu_binary = getenv(\"QTEST_QEMU_BINARY\");\n\n    g_assert(qemu_binary != NULL);\n\n\n\n    s = g_malloc(sizeof(*s));\n\n\n\n    socket_path = g_strdup_printf(\"/tmp/qtest-%d.sock\", getpid());\n\n    qmp_socket_path = g_strdup_printf(\"/tmp/qtest-%d.qmp\", getpid());\n\n\n\n    sock = init_socket(socket_path);\n\n    qmpsock = init_socket(qmp_socket_path);\n\n\n\n    /* Catch SIGABRT to clean up on g_assert() failure */\n\n    sigact = (struct sigaction){\n\n        .sa_handler = sigabrt_handler,\n\n        .sa_flags = SA_RESETHAND,\n\n    };\n\n    sigemptyset(&sigact.sa_mask);\n\n    sigaction(SIGABRT, &sigact, &s->sigact_old);\n\n\n\n    s->qemu_pid = fork();\n\n    if (s->qemu_pid == 0) {\n\n        command = g_strdup_printf(\"exec %s \"\n\n                                  \"-qtest unix:%s,nowait \"\n\n                                  \"-qtest-log /dev/null \"\n\n                                  \"-qmp unix:%s,nowait \"\n\n                                  \"-machine accel=qtest \"\n\n                                  \"-display none \"\n\n                                  \"%s\", qemu_binary, socket_path,\n\n                                  qmp_socket_path,\n\n                                  extra_args ?: \"\");\n\n        execlp(\"/bin/sh\", \"sh\", \"-c\", command, NULL);\n\n        exit(1);\n\n    }\n\n\n\n    s->fd = socket_accept(sock);\n\n    s->qmp_fd = socket_accept(qmpsock);\n\n    unlink(socket_path);\n\n    unlink(qmp_socket_path);\n\n    g_free(socket_path);\n\n    g_free(qmp_socket_path);\n\n\n\n    s->rx = g_string_new(\"\");\n\n    for (i = 0; i < MAX_IRQ; i++) {\n\n        s->irq_level[i] = false;\n\n    }\n\n\n\n    /* Read the QMP greeting and then do the handshake */\n\n    qtest_qmp_discard_response(s, \"\");\n\n    qtest_qmp_discard_response(s, \"{ 'execute': 'qmp_capabilities' }\");\n\n\n\n    if (getenv(\"QTEST_STOP\")) {\n\n        kill(s->qemu_pid, SIGSTOP);\n\n    }\n\n\n\n    return s;\n\n}\n", "idx": 24376}
{"project": "qemu", "commit_id": "876d516311c1538a7d29f2abec48b7cda0645eea", "target": 1, "func": "static void qxl_init_ramsize(PCIQXLDevice *qxl)\n\n{\n\n    /* vga mode framebuffer / primary surface (bar 0, first part) */\n\n    if (qxl->vgamem_size_mb < 8) {\n\n        qxl->vgamem_size_mb = 8;\n\n\n\n\n\n\n\n\n    qxl->vgamem_size = qxl->vgamem_size_mb * 1024 * 1024;\n\n\n\n    /* vga ram (bar 0, total) */\n\n    if (qxl->ram_size_mb != -1) {\n\n        qxl->vga.vram_size = qxl->ram_size_mb * 1024 * 1024;\n\n\n    if (qxl->vga.vram_size < qxl->vgamem_size * 2) {\n\n        qxl->vga.vram_size = qxl->vgamem_size * 2;\n\n\n\n\n    /* vram32 (surfaces, 32bit, bar 1) */\n\n    if (qxl->vram32_size_mb != -1) {\n\n        qxl->vram32_size = qxl->vram32_size_mb * 1024 * 1024;\n\n\n    if (qxl->vram32_size < 4096) {\n\n        qxl->vram32_size = 4096;\n\n\n\n\n    /* vram (surfaces, 64bit, bar 4+5) */\n\n    if (qxl->vram_size_mb != -1) {\n\n        qxl->vram_size = qxl->vram_size_mb * 1024 * 1024;\n\n\n    if (qxl->vram_size < qxl->vram32_size) {\n\n        qxl->vram_size = qxl->vram32_size;\n\n\n\n\n    if (qxl->revision == 1) {\n\n        qxl->vram32_size = 4096;\n\n        qxl->vram_size = 4096;\n\n\n    qxl->vgamem_size = msb_mask(qxl->vgamem_size * 2 - 1);\n\n    qxl->vga.vram_size = msb_mask(qxl->vga.vram_size * 2 - 1);\n\n    qxl->vram32_size = msb_mask(qxl->vram32_size * 2 - 1);\n\n    qxl->vram_size = msb_mask(qxl->vram_size * 2 - 1);\n", "idx": 24377}
{"project": "qemu", "commit_id": "d3f8d37fe2d0c24ec8bac9c94d5b0e2dc09c0d2a", "target": 1, "func": "int kvm_log_stop(target_phys_addr_t phys_addr, target_phys_addr_t end_addr)\n\n{\n\n        return kvm_dirty_pages_log_change(phys_addr, end_addr,\n\n                                          0,\n\n                                          KVM_MEM_LOG_DIRTY_PAGES);\n\n}\n", "idx": 24381}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "int qemu_strtoll(const char *nptr, const char **endptr, int base,\n\n                 int64_t *result)\n\n{\n\n    char *p;\n\n    int err = 0;\n\n    if (!nptr) {\n\n        if (endptr) {\n\n            *endptr = nptr;\n\n        }\n\n        err = -EINVAL;\n\n    } else {\n\n        errno = 0;\n\n        *result = strtoll(nptr, &p, base);\n\n        err = check_strtox_error(endptr, p, errno);\n\n    }\n\n    return err;\n\n}\n", "idx": 24382}
{"project": "qemu", "commit_id": "4154c7e03fa55b4cf52509a83d50d6c09d743b77", "target": 1, "func": "e1000e_ring_empty(E1000ECore *core, const E1000E_RingInfo *r)\n\n{\n\n    return core->mac[r->dh] == core->mac[r->dt];\n\n}\n", "idx": 24384}
{"project": "qemu", "commit_id": "12f8def0e02232d7c6416ad9b66640f973c531d1", "target": 1, "func": "void qemu_mutex_destroy(QemuMutex *mutex)\n\n{\n\n    assert(mutex->owner == 0);\n\n    DeleteCriticalSection(&mutex->lock);\n\n}\n", "idx": 24386}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int usb_host_handle_iso_data(USBHostDevice *s, USBPacket *p, int in)\n\n{\n\n    AsyncURB *aurb;\n\n    int i, j, ret, max_packet_size, offset, len = 0;\n\n\n\n    max_packet_size = get_max_packet_size(s, p->devep);\n\n    if (max_packet_size == 0)\n\n        return USB_RET_NAK;\n\n\n\n    aurb = get_iso_urb(s, p->devep);\n\n    if (!aurb) {\n\n        aurb = usb_host_alloc_iso(s, p->devep, in);\n\n    }\n\n\n\n    i = get_iso_urb_idx(s, p->devep);\n\n    j = aurb[i].iso_frame_idx;\n\n    if (j >= 0 && j < ISO_FRAME_DESC_PER_URB) {\n\n        if (in) {\n\n            /* Check urb status  */\n\n            if (aurb[i].urb.status) {\n\n                len = urb_status_to_usb_ret(aurb[i].urb.status);\n\n                /* Move to the next urb */\n\n                aurb[i].iso_frame_idx = ISO_FRAME_DESC_PER_URB - 1;\n\n            /* Check frame status */\n\n            } else if (aurb[i].urb.iso_frame_desc[j].status) {\n\n                len = urb_status_to_usb_ret(\n\n                                        aurb[i].urb.iso_frame_desc[j].status);\n\n            /* Check the frame fits */\n\n            } else if (aurb[i].urb.iso_frame_desc[j].actual_length > p->len) {\n\n                printf(\"husb: received iso data is larger then packet\\n\");\n\n                len = USB_RET_NAK;\n\n            /* All good copy data over */\n\n            } else {\n\n                len = aurb[i].urb.iso_frame_desc[j].actual_length;\n\n                memcpy(p->data,\n\n                       aurb[i].urb.buffer +\n\n                           j * aurb[i].urb.iso_frame_desc[0].length,\n\n                       len);\n\n            }\n\n        } else {\n\n            len = p->len;\n\n            offset = (j == 0) ? 0 : get_iso_buffer_used(s, p->devep);\n\n\n\n            /* Check the frame fits */\n\n            if (len > max_packet_size) {\n\n                printf(\"husb: send iso data is larger then max packet size\\n\");\n\n                return USB_RET_NAK;\n\n            }\n\n\n\n            /* All good copy data over */\n\n            memcpy(aurb[i].urb.buffer + offset, p->data, len);\n\n            aurb[i].urb.iso_frame_desc[j].length = len;\n\n            offset += len;\n\n            set_iso_buffer_used(s, p->devep, offset);\n\n\n\n            /* Start the stream once we have buffered enough data */\n\n            if (!is_iso_started(s, p->devep) && i == 1 && j == 8) {\n\n                set_iso_started(s, p->devep);\n\n            }\n\n        }\n\n        aurb[i].iso_frame_idx++;\n\n        if (aurb[i].iso_frame_idx == ISO_FRAME_DESC_PER_URB) {\n\n            i = (i + 1) % s->iso_urb_count;\n\n            set_iso_urb_idx(s, p->devep, i);\n\n        }\n\n    } else {\n\n        if (in) {\n\n            set_iso_started(s, p->devep);\n\n        } else {\n\n            DPRINTF(\"hubs: iso out error no free buffer, dropping packet\\n\");\n\n        }\n\n    }\n\n\n\n    if (is_iso_started(s, p->devep)) {\n\n        /* (Re)-submit all fully consumed / filled urbs */\n\n        for (i = 0; i < s->iso_urb_count; i++) {\n\n            if (aurb[i].iso_frame_idx == ISO_FRAME_DESC_PER_URB) {\n\n                ret = ioctl(s->fd, USBDEVFS_SUBMITURB, &aurb[i]);\n\n                if (ret < 0) {\n\n                    printf(\"husb error submitting iso urb %d: %d\\n\", i, errno);\n\n                    if (!in || len == 0) {\n\n                        switch(errno) {\n\n                        case ETIMEDOUT:\n\n                            len = USB_RET_NAK;\n\n                            break;\n\n                        case EPIPE:\n\n                        default:\n\n                            len = USB_RET_STALL;\n\n                        }\n\n                    }\n\n                    break;\n\n                }\n\n                aurb[i].iso_frame_idx = -1;\n\n                change_iso_inflight(s, p->devep, +1);\n\n            }\n\n        }\n\n    }\n\n\n\n    return len;\n\n}\n", "idx": 24387}
{"project": "qemu", "commit_id": "d659d94013390238961fac741572306c95496bf5", "target": 1, "func": "static void pcie_pci_bridge_realize(PCIDevice *d, Error **errp)\n\n{\n\n    PCIBridge *br = PCI_BRIDGE(d);\n\n    PCIEPCIBridge *pcie_br = PCIE_PCI_BRIDGE_DEV(d);\n\n    int rc, pos;\n\n\n\n    pci_bridge_initfn(d, TYPE_PCI_BUS);\n\n\n\n    d->config[PCI_INTERRUPT_PIN] = 0x1;\n\n    memory_region_init(&pcie_br->shpc_bar, OBJECT(d), \"shpc-bar\",\n\n                       shpc_bar_size(d));\n\n    rc = shpc_init(d, &br->sec_bus, &pcie_br->shpc_bar, 0, errp);\n\n    if (rc) {\n\n        goto error;\n\n    }\n\n\n\n    rc = pcie_cap_init(d, 0, PCI_EXP_TYPE_PCI_BRIDGE, 0, errp);\n\n    if (rc < 0) {\n\n        goto cap_error;\n\n    }\n\n\n\n    pos = pci_add_capability(d, PCI_CAP_ID_PM, 0, PCI_PM_SIZEOF, errp);\n\n    if (pos < 0) {\n\n        goto pm_error;\n\n    }\n\n    d->exp.pm_cap = pos;\n\n    pci_set_word(d->config + pos + PCI_PM_PMC, 0x3);\n\n\n\n    pcie_cap_arifwd_init(d);\n\n    pcie_cap_deverr_init(d);\n\n\n\n    rc = pcie_aer_init(d, PCI_ERR_VER, 0x100, PCI_ERR_SIZEOF, errp);\n\n    if (rc < 0) {\n\n        goto aer_error;\n\n    }\n\n\n\n    if (pcie_br->msi != ON_OFF_AUTO_OFF) {\n\n        rc = msi_init(d, 0, 1, true, true, errp);\n\n        if (rc < 0) {\n\n            goto msi_error;\n\n        }\n\n    }\n\n    pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                     PCI_BASE_ADDRESS_MEM_TYPE_64, &pcie_br->shpc_bar);\n\n    return;\n\n\n\nmsi_error:\n\n    pcie_aer_exit(d);\n\naer_error:\n\npm_error:\n\n    pcie_cap_exit(d);\n\ncap_error:\n\n    shpc_free(d);\n\nerror:\n\n    pci_bridge_exitfn(d);\n\n}\n", "idx": 24388}
{"project": "qemu", "commit_id": "3a661f1eabf7e8db66e28489884d9b54aacb94ea", "target": 1, "func": "static int qcrypto_cipher_init_aes(QCryptoCipher *cipher,\n\n                                   const uint8_t *key, size_t nkey,\n\n                                   Error **errp)\n\n{\n\n    QCryptoCipherBuiltin *ctxt;\n\n\n\n    if (cipher->mode != QCRYPTO_CIPHER_MODE_CBC &&\n\n        cipher->mode != QCRYPTO_CIPHER_MODE_ECB) {\n\n        error_setg(errp, \"Unsupported cipher mode %d\", cipher->mode);\n\n        return -1;\n\n    }\n\n\n\n    ctxt = g_new0(QCryptoCipherBuiltin, 1);\n\n\n\n    if (AES_set_encrypt_key(key, nkey * 8, &ctxt->state.aes.encrypt_key) != 0) {\n\n        error_setg(errp, \"Failed to set encryption key\");\n\n        goto error;\n\n    }\n\n\n\n    if (AES_set_decrypt_key(key, nkey * 8, &ctxt->state.aes.decrypt_key) != 0) {\n\n        error_setg(errp, \"Failed to set decryption key\");\n\n        goto error;\n\n    }\n\n\n\n\n    ctxt->free = qcrypto_cipher_free_aes;\n\n    ctxt->setiv = qcrypto_cipher_setiv_aes;\n\n    ctxt->encrypt = qcrypto_cipher_encrypt_aes;\n\n    ctxt->decrypt = qcrypto_cipher_decrypt_aes;\n\n\n\n    cipher->opaque = ctxt;\n\n\n\n    return 0;\n\n\n\n error:\n\n    g_free(ctxt);\n\n    return -1;\n\n}", "idx": 24389}
{"project": "qemu", "commit_id": "9ed257d1d1c65dbe5a08f207e5106e98384e1860", "target": 1, "func": "void xen_hvm_init(PCMachineState *pcms, MemoryRegion **ram_memory)\n\n{\n\n    int i, rc;\n\n    xen_pfn_t ioreq_pfn;\n\n    xen_pfn_t bufioreq_pfn;\n\n    evtchn_port_t bufioreq_evtchn;\n\n    XenIOState *state;\n\n\n\n    state = g_malloc0(sizeof (XenIOState));\n\n\n\n    state->xce_handle = xenevtchn_open(NULL, 0);\n\n    if (state->xce_handle == NULL) {\n\n        perror(\"xen: event channel open\");\n\n        goto err;\n\n    }\n\n\n\n    state->xenstore = xs_daemon_open();\n\n    if (state->xenstore == NULL) {\n\n        perror(\"xen: xenstore open\");\n\n        goto err;\n\n    }\n\n\n\n    rc = xen_create_ioreq_server(xen_xc, xen_domid, &state->ioservid);\n\n    if (rc < 0) {\n\n        perror(\"xen: ioreq server create\");\n\n        goto err;\n\n    }\n\n\n\n    state->exit.notify = xen_exit_notifier;\n\n    qemu_add_exit_notifier(&state->exit);\n\n\n\n    state->suspend.notify = xen_suspend_notifier;\n\n    qemu_register_suspend_notifier(&state->suspend);\n\n\n\n    state->wakeup.notify = xen_wakeup_notifier;\n\n    qemu_register_wakeup_notifier(&state->wakeup);\n\n\n\n    rc = xen_get_ioreq_server_info(xen_xc, xen_domid, state->ioservid,\n\n                                   &ioreq_pfn, &bufioreq_pfn,\n\n                                   &bufioreq_evtchn);\n\n    if (rc < 0) {\n\n        error_report(\"failed to get ioreq server info: error %d handle=\" XC_INTERFACE_FMT,\n\n                     errno, xen_xc);\n\n        goto err;\n\n    }\n\n\n\n    DPRINTF(\"shared page at pfn %lx\\n\", ioreq_pfn);\n\n    DPRINTF(\"buffered io page at pfn %lx\\n\", bufioreq_pfn);\n\n    DPRINTF(\"buffered io evtchn is %x\\n\", bufioreq_evtchn);\n\n\n\n    state->shared_page = xc_map_foreign_range(xen_xc, xen_domid, XC_PAGE_SIZE,\n\n                                              PROT_READ|PROT_WRITE, ioreq_pfn);\n\n    if (state->shared_page == NULL) {\n\n        error_report(\"map shared IO page returned error %d handle=\" XC_INTERFACE_FMT,\n\n                     errno, xen_xc);\n\n        goto err;\n\n    }\n\n\n\n    rc = xen_get_vmport_regs_pfn(xen_xc, xen_domid, &ioreq_pfn);\n\n    if (!rc) {\n\n        DPRINTF(\"shared vmport page at pfn %lx\\n\", ioreq_pfn);\n\n        state->shared_vmport_page =\n\n            xc_map_foreign_range(xen_xc, xen_domid, XC_PAGE_SIZE,\n\n                                 PROT_READ|PROT_WRITE, ioreq_pfn);\n\n        if (state->shared_vmport_page == NULL) {\n\n            error_report(\"map shared vmport IO page returned error %d handle=\"\n\n                         XC_INTERFACE_FMT, errno, xen_xc);\n\n            goto err;\n\n        }\n\n    } else if (rc != -ENOSYS) {\n\n        error_report(\"get vmport regs pfn returned error %d, rc=%d\",\n\n                     errno, rc);\n\n        goto err;\n\n    }\n\n\n\n    state->buffered_io_page = xc_map_foreign_range(xen_xc, xen_domid,\n\n                                                   XC_PAGE_SIZE,\n\n                                                   PROT_READ|PROT_WRITE,\n\n                                                   bufioreq_pfn);\n\n    if (state->buffered_io_page == NULL) {\n\n        error_report(\"map buffered IO page returned error %d\", errno);\n\n        goto err;\n\n    }\n\n\n\n    /* Note: cpus is empty at this point in init */\n\n    state->cpu_by_vcpu_id = g_malloc0(max_cpus * sizeof(CPUState *));\n\n\n\n    rc = xen_set_ioreq_server_state(xen_xc, xen_domid, state->ioservid, true);\n\n    if (rc < 0) {\n\n        error_report(\"failed to enable ioreq server info: error %d handle=\" XC_INTERFACE_FMT,\n\n                     errno, xen_xc);\n\n        goto err;\n\n    }\n\n\n\n    state->ioreq_local_port = g_malloc0(max_cpus * sizeof (evtchn_port_t));\n\n\n\n    /* FIXME: how about if we overflow the page here? */\n\n    for (i = 0; i < max_cpus; i++) {\n\n        rc = xenevtchn_bind_interdomain(state->xce_handle, xen_domid,\n\n                                        xen_vcpu_eport(state->shared_page, i));\n\n        if (rc == -1) {\n\n            error_report(\"shared evtchn %d bind error %d\", i, errno);\n\n            goto err;\n\n        }\n\n        state->ioreq_local_port[i] = rc;\n\n    }\n\n\n\n    rc = xenevtchn_bind_interdomain(state->xce_handle, xen_domid,\n\n                                    bufioreq_evtchn);\n\n    if (rc == -1) {\n\n        error_report(\"buffered evtchn bind error %d\", errno);\n\n        goto err;\n\n    }\n\n    state->bufioreq_local_port = rc;\n\n\n\n    /* Init RAM management */\n\n    xen_map_cache_init(xen_phys_offset_to_gaddr, state);\n\n    xen_ram_init(pcms, ram_size, ram_memory);\n\n\n\n    qemu_add_vm_change_state_handler(xen_hvm_change_state_handler, state);\n\n\n\n    state->memory_listener = xen_memory_listener;\n\n    QLIST_INIT(&state->physmap);\n\n    memory_listener_register(&state->memory_listener, &address_space_memory);\n\n    state->log_for_dirtybit = NULL;\n\n\n\n    state->io_listener = xen_io_listener;\n\n    memory_listener_register(&state->io_listener, &address_space_io);\n\n\n\n    state->device_listener = xen_device_listener;\n\n    device_listener_register(&state->device_listener);\n\n\n\n    /* Initialize backend core & drivers */\n\n    if (xen_be_init() != 0) {\n\n        error_report(\"xen backend core setup failed\");\n\n        goto err;\n\n    }\n\n    xen_be_register(\"console\", &xen_console_ops);\n\n    xen_be_register(\"vkbd\", &xen_kbdmouse_ops);\n\n    xen_be_register(\"qdisk\", &xen_blkdev_ops);\n\n    xen_read_physmap(state);\n\n    return;\n\n\n\nerr:\n\n    error_report(\"xen hardware virtual machine initialisation failed\");\n\n    exit(1);\n\n}\n", "idx": 24392}
{"project": "qemu", "commit_id": "20784087eb875e22cf0021989e61716304b63c84", "target": 1, "func": "static inline void test_server_connect(TestServer *server)\n\n{\n\n    test_server_create_chr(server, \",reconnect=1\");\n\n}\n", "idx": 24393}
{"project": "qemu", "commit_id": "1a71992376792a0d11ea27688bd1a21cdffd1826", "target": 1, "func": "static void do_io_interrupt(CPUS390XState *env)\n\n{\n\n    S390CPU *cpu = s390_env_get_cpu(env);\n\n    LowCore *lowcore;\n\n    IOIntQueue *q;\n\n    uint8_t isc;\n\n    int disable = 1;\n\n    int found = 0;\n\n\n\n    if (!(env->psw.mask & PSW_MASK_IO)) {\n\n        cpu_abort(CPU(cpu), \"I/O int w/o I/O mask\\n\");\n\n    }\n\n\n\n    for (isc = 0; isc < ARRAY_SIZE(env->io_index); isc++) {\n\n        uint64_t isc_bits;\n\n\n\n        if (env->io_index[isc] < 0) {\n\n            continue;\n\n        }\n\n        if (env->io_index[isc] > MAX_IO_QUEUE) {\n\n            cpu_abort(CPU(cpu), \"I/O queue overrun for isc %d: %d\\n\",\n\n                      isc, env->io_index[isc]);\n\n        }\n\n\n\n        q = &env->io_queue[env->io_index[isc]][isc];\n\n        isc_bits = ISC_TO_ISC_BITS(IO_INT_WORD_ISC(q->word));\n\n        if (!(env->cregs[6] & isc_bits)) {\n\n            disable = 0;\n\n            continue;\n\n        }\n\n        if (!found) {\n\n            uint64_t mask, addr;\n\n\n\n            found = 1;\n\n            lowcore = cpu_map_lowcore(env);\n\n\n\n            lowcore->subchannel_id = cpu_to_be16(q->id);\n\n            lowcore->subchannel_nr = cpu_to_be16(q->nr);\n\n            lowcore->io_int_parm = cpu_to_be32(q->parm);\n\n            lowcore->io_int_word = cpu_to_be32(q->word);\n\n            lowcore->io_old_psw.mask = cpu_to_be64(get_psw_mask(env));\n\n            lowcore->io_old_psw.addr = cpu_to_be64(env->psw.addr);\n\n            mask = be64_to_cpu(lowcore->io_new_psw.mask);\n\n            addr = be64_to_cpu(lowcore->io_new_psw.addr);\n\n\n\n            cpu_unmap_lowcore(lowcore);\n\n\n\n            env->io_index[isc]--;\n\n\n\n            DPRINTF(\"%s: %\" PRIx64 \" %\" PRIx64 \"\\n\", __func__,\n\n                    env->psw.mask, env->psw.addr);\n\n            load_psw(env, mask, addr);\n\n        }\n\n        if (env->io_index[isc] >= 0) {\n\n            disable = 0;\n\n        }\n\n        continue;\n\n    }\n\n\n\n    if (disable) {\n\n        env->pending_int &= ~INTERRUPT_IO;\n\n    }\n\n\n\n}\n", "idx": 24399}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void unix_start_outgoing_migration(MigrationState *s, const char *path, Error **errp)\n\n{\n\n    unix_nonblocking_connect(path, unix_wait_for_connect, s, errp);\n\n}\n", "idx": 24402}
{"project": "qemu", "commit_id": "262a69f4282e44426c7a132138581d400053e0a1", "target": 1, "func": "static void *mptsas_load_request(QEMUFile *f, SCSIRequest *sreq)\n\n{\n\n    SCSIBus *bus = sreq->bus;\n\n    MPTSASState *s = container_of(bus, MPTSASState, bus);\n\n    PCIDevice *pci = PCI_DEVICE(s);\n\n    MPTSASRequest *req;\n\n    int i, n;\n\n\n\n    req = g_new(MPTSASRequest, 1);\n\n    qemu_get_buffer(f, (unsigned char *)&req->scsi_io, sizeof(req->scsi_io));\n\n\n\n    n = qemu_get_be32(f);\n\n    /* TODO: add a way for SCSIBusInfo's load_request to fail,\n\n     * and fail migration instead of asserting here.\n\n     * When we do, we might be able to re-enable NDEBUG below.\n\n     */\n\n#ifdef NDEBUG\n\n#error building with NDEBUG is not supported\n\n#endif\n\n    assert(n >= 0);\n\n\n\n    pci_dma_sglist_init(&req->qsg, pci, n);\n\n    for (i = 0; i < n; i++) {\n\n        uint64_t base = qemu_get_be64(f);\n\n        uint64_t len = qemu_get_be64(f);\n\n        qemu_sglist_add(&req->qsg, base, len);\n\n    }\n\n\n\n    scsi_req_ref(sreq);\n\n    req->sreq = sreq;\n\n    req->dev = s;\n\n\n\n    return req;\n\n}\n", "idx": 24403}
{"project": "qemu", "commit_id": "d861b05ea30e6ac177de9b679da96194ebe21afc", "target": 1, "func": "VLANClientState *qemu_new_vlan_client(VLANState *vlan,\n\n                                      IOReadHandler *fd_read, void *opaque)\n\n{\n\n    VLANClientState *vc, **pvc;\n\n    vc = qemu_mallocz(sizeof(VLANClientState));\n\n    if (!vc)\n\n        return NULL;\n\n    vc->fd_read = fd_read;\n\n    vc->opaque = opaque;\n\n    vc->vlan = vlan;\n\n\n\n    vc->next = NULL;\n\n    pvc = &vlan->first_client;\n\n    while (*pvc != NULL)\n\n        pvc = &(*pvc)->next;\n\n    *pvc = vc;\n\n    return vc;\n\n}\n", "idx": 24405}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void unterminated_escape(void)\n\n{\n\n    QObject *obj = qobject_from_json(\"\\\"abc\\\\\\\"\", NULL);\n\n    g_assert(obj == NULL);\n\n}\n", "idx": 24406}
{"project": "qemu", "commit_id": "b45c03f585ea9bb1af76c73e82195418c294919d", "target": 1, "func": "struct omap_gpmc_s *omap_gpmc_init(struct omap_mpu_state_s *mpu,\n\n                                   hwaddr base,\n\n                                   qemu_irq irq, qemu_irq drq)\n\n{\n\n    int cs;\n\n    struct omap_gpmc_s *s = (struct omap_gpmc_s *)\n\n            g_malloc0(sizeof(struct omap_gpmc_s));\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &omap_gpmc_ops, s, \"omap-gpmc\", 0x1000);\n\n    memory_region_add_subregion(get_system_memory(), base, &s->iomem);\n\n\n\n    s->irq = irq;\n\n    s->drq = drq;\n\n    s->accept_256 = cpu_is_omap3630(mpu);\n\n    s->revision = cpu_class_omap3(mpu) ? 0x50 : 0x20;\n\n    s->lastirq = 0;\n\n    omap_gpmc_reset(s);\n\n\n\n    /* We have to register a different IO memory handler for each\n\n     * chip select region in case a NAND device is mapped there. We\n\n     * make the region the worst-case size of 256MB and rely on the\n\n     * container memory region in cs_map to chop it down to the actual\n\n     * guest-requested size.\n\n     */\n\n    for (cs = 0; cs < 8; cs++) {\n\n        memory_region_init_io(&s->cs_file[cs].nandiomem, NULL,\n\n                              &omap_nand_ops,\n\n                              &s->cs_file[cs],\n\n                              \"omap-nand\",\n\n                              256 * 1024 * 1024);\n\n    }\n\n\n\n    memory_region_init_io(&s->prefetch.iomem, NULL, &omap_prefetch_ops, s,\n\n                          \"omap-gpmc-prefetch\", 256 * 1024 * 1024);\n\n    return s;\n\n}\n", "idx": 24407}
{"project": "qemu", "commit_id": "42ed3727536ccf80c87942b3f04e7378fe90f107", "target": 1, "func": "bool trace_backend_init(const char *events, const char *file)\n\n{\n\n    GThread *thread;\n\n\n\n    if (!g_thread_supported()) {\n\n\n        g_thread_init(NULL);\n\n\n\n\n\n    }\n\n\n\n    trace_available_cond = g_cond_new();\n\n    trace_empty_cond = g_cond_new();\n\n\n\n    thread = trace_thread_create(writeout_thread);\n\n    if (!thread) {\n\n        fprintf(stderr, \"warning: unable to initialize simple trace backend\\n\");\n\n        return false;\n\n    }\n\n\n\n    atexit(st_flush_trace_buffer);\n\n    trace_backend_init_events(events);\n\n    st_set_trace_file(file);\n\n    return true;\n\n}", "idx": 24408}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtol_full_empty(void)\n\n{\n\n    const char *str = \"\";\n\n    long res = 999L;\n\n    int err;\n\n\n\n    err =  qemu_strtol(str, NULL, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 0);\n\n}\n", "idx": 24410}
{"project": "qemu", "commit_id": "f2ba730e89b420903257e543c1bb7f7d945ba36a", "target": 1, "func": "ip_reass(register struct ip *ip, register struct ipq *fp)\n\n{\n\n\tregister struct mbuf *m = dtom(ip);\n\n\tregister struct ipasfrag *q;\n\n\tint hlen = ip->ip_hl << 2;\n\n\tint i, next;\n\n\n\n\tDEBUG_CALL(\"ip_reass\");\n\n\tDEBUG_ARG(\"ip = %lx\", (long)ip);\n\n\tDEBUG_ARG(\"fp = %lx\", (long)fp);\n\n\tDEBUG_ARG(\"m = %lx\", (long)m);\n\n\n\n\t/*\n\n\t * Presence of header sizes in mbufs\n\n\t * would confuse code below.\n\n         * Fragment m_data is concatenated.\n\n\t */\n\n\tm->m_data += hlen;\n\n\tm->m_len -= hlen;\n\n\n\n\t/*\n\n\t * If first fragment to arrive, create a reassembly queue.\n\n\t */\n\n\tif (fp == 0) {\n\n\t  struct mbuf *t;\n\n\t  if ((t = m_get()) == NULL) goto dropfrag;\n\n\t  fp = mtod(t, struct ipq *);\n\n\t  insque(&fp->ip_link, &ipq.ip_link);\n\n\t  fp->ipq_ttl = IPFRAGTTL;\n\n\t  fp->ipq_p = ip->ip_p;\n\n\t  fp->ipq_id = ip->ip_id;\n\n\t  fp->frag_link.next = fp->frag_link.prev = &fp->frag_link;\n\n\t  fp->ipq_src = ip->ip_src;\n\n\t  fp->ipq_dst = ip->ip_dst;\n\n\t  q = (struct ipasfrag *)fp;\n\n\t  goto insert;\n\n\t}\n\n\n\n\t/*\n\n\t * Find a segment which begins after this one does.\n\n\t */\n\n\tfor (q = fp->frag_link.next; q != (struct ipasfrag *)&fp->frag_link;\n\n            q = q->ipf_next)\n\n\t\tif (q->ipf_off > ip->ip_off)\n\n\t\t\tbreak;\n\n\n\n\t/*\n\n\t * If there is a preceding segment, it may provide some of\n\n\t * our data already.  If so, drop the data from the incoming\n\n\t * segment.  If it provides all of our data, drop us.\n\n\t */\n\n\tif (q->ipf_prev != &fp->frag_link) {\n\n        struct ipasfrag *pq = q->ipf_prev;\n\n\t\ti = pq->ipf_off + pq->ipf_len - ip->ip_off;\n\n\t\tif (i > 0) {\n\n\t\t\tif (i >= ip->ip_len)\n\n\t\t\t\tgoto dropfrag;\n\n\t\t\tm_adj(dtom(ip), i);\n\n\t\t\tip->ip_off += i;\n\n\t\t\tip->ip_len -= i;\n\n\t\t}\n\n\t}\n\n\n\n\t/*\n\n\t * While we overlap succeeding segments trim them or,\n\n\t * if they are completely covered, dequeue them.\n\n\t */\n\n\twhile (q != (struct ipasfrag*)&fp->frag_link &&\n\n            ip->ip_off + ip->ip_len > q->ipf_off) {\n\n\t\ti = (ip->ip_off + ip->ip_len) - q->ipf_off;\n\n\t\tif (i < q->ipf_len) {\n\n\t\t\tq->ipf_len -= i;\n\n\t\t\tq->ipf_off += i;\n\n\t\t\tm_adj(dtom(q), i);\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\tq = q->ipf_next;\n\n\t\tm_freem(dtom(q->ipf_prev));\n\n\t\tip_deq(q->ipf_prev);\n\n\t}\n\n\n\ninsert:\n\n\t/*\n\n\t * Stick new segment in its place;\n\n\t * check for complete reassembly.\n\n\t */\n\n\tip_enq(iptofrag(ip), q->ipf_prev);\n\n\tnext = 0;\n\n\tfor (q = fp->frag_link.next; q != (struct ipasfrag*)&fp->frag_link;\n\n            q = q->ipf_next) {\n\n\t\tif (q->ipf_off != next)\n\n\t\t\treturn (0);\n\n\t\tnext += q->ipf_len;\n\n\t}\n\n\tif (((struct ipasfrag *)(q->ipf_prev))->ipf_tos & 1)\n\n\t\treturn (0);\n\n\n\n\t/*\n\n\t * Reassembly is complete; concatenate fragments.\n\n\t */\n\n    q = fp->frag_link.next;\n\n\tm = dtom(q);\n\n\n\n\tq = (struct ipasfrag *) q->ipf_next;\n\n\twhile (q != (struct ipasfrag*)&fp->frag_link) {\n\n\t  struct mbuf *t = dtom(q);\n\n\t  q = (struct ipasfrag *) q->ipf_next;\n\n\t  m_cat(m, t);\n\n\t}\n\n\n\n\t/*\n\n\t * Create header for new ip packet by\n\n\t * modifying header of first packet;\n\n\t * dequeue and discard fragment reassembly header.\n\n\t * Make header visible.\n\n\t */\n\n\tq = fp->frag_link.next;\n\n\n\n\t/*\n\n\t * If the fragments concatenated to an mbuf that's\n\n\t * bigger than the total size of the fragment, then and\n\n\t * m_ext buffer was alloced. But fp->ipq_next points to\n\n\t * the old buffer (in the mbuf), so we must point ip\n\n\t * into the new buffer.\n\n\t */\n\n\tif (m->m_flags & M_EXT) {\n\n\t  int delta;\n\n\t  delta = (char *)ip - m->m_dat;\n\n\t  q = (struct ipasfrag *)(m->m_ext + delta);\n\n\t}\n\n\n\n\t/* DEBUG_ARG(\"ip = %lx\", (long)ip);\n\n\t * ip=(struct ipasfrag *)m->m_data; */\n\n\n\n    ip = fragtoip(q);\n\n\tip->ip_len = next;\n\n\tip->ip_tos &= ~1;\n\n\tip->ip_src = fp->ipq_src;\n\n\tip->ip_dst = fp->ipq_dst;\n\n\tremque(&fp->ip_link);\n\n\t(void) m_free(dtom(fp));\n\n\tm->m_len += (ip->ip_hl << 2);\n\n\tm->m_data -= (ip->ip_hl << 2);\n\n\n\n\treturn ip;\n\n\n\ndropfrag:\n\n\tSTAT(ipstat.ips_fragdropped++);\n\n\tm_freem(m);\n\n\treturn (0);\n\n}\n", "idx": 24411}
{"project": "qemu", "commit_id": "3d90c6254863693a6b13d918d2b8682e08bbc681", "target": 1, "func": "static void vga_draw_graphic(VGACommonState *s, int full_update)\n\n{\n\n    DisplaySurface *surface = qemu_console_surface(s->con);\n\n    int y1, y, update, linesize, y_start, double_scan, mask, depth;\n\n    int width, height, shift_control, line_offset, bwidth, bits;\n\n    ram_addr_t page0, page1;\n\n    DirtyBitmapSnapshot *snap = NULL;\n\n    int disp_width, multi_scan, multi_run;\n\n    uint8_t *d;\n\n    uint32_t v, addr1, addr;\n\n    vga_draw_line_func *vga_draw_line = NULL;\n\n    bool share_surface;\n\n    pixman_format_code_t format;\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n    bool byteswap = !s->big_endian_fb;\n\n#else\n\n    bool byteswap = s->big_endian_fb;\n\n#endif\n\n\n\n    full_update |= update_basic_params(s);\n\n\n\n    s->get_resolution(s, &width, &height);\n\n    disp_width = width;\n\n\n\n    shift_control = (s->gr[VGA_GFX_MODE] >> 5) & 3;\n\n    double_scan = (s->cr[VGA_CRTC_MAX_SCAN] >> 7);\n\n    if (shift_control != 1) {\n\n        multi_scan = (((s->cr[VGA_CRTC_MAX_SCAN] & 0x1f) + 1) << double_scan)\n\n            - 1;\n\n    } else {\n\n        /* in CGA modes, multi_scan is ignored */\n\n        /* XXX: is it correct ? */\n\n        multi_scan = double_scan;\n\n    }\n\n    multi_run = multi_scan;\n\n    if (shift_control != s->shift_control ||\n\n        double_scan != s->double_scan) {\n\n        full_update = 1;\n\n        s->shift_control = shift_control;\n\n        s->double_scan = double_scan;\n\n    }\n\n\n\n    if (shift_control == 0) {\n\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n\n            disp_width <<= 1;\n\n        }\n\n    } else if (shift_control == 1) {\n\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n\n            disp_width <<= 1;\n\n        }\n\n    }\n\n\n\n    depth = s->get_bpp(s);\n\n\n\n    /*\n\n     * Check whether we can share the surface with the backend\n\n     * or whether we need a shadow surface. We share native\n\n     * endian surfaces for 15bpp and above and byteswapped\n\n     * surfaces for 24bpp and above.\n\n     */\n\n    format = qemu_default_pixman_format(depth, !byteswap);\n\n    if (format) {\n\n        share_surface = dpy_gfx_check_format(s->con, format)\n\n            && !s->force_shadow;\n\n    } else {\n\n        share_surface = false;\n\n    }\n\n    if (s->line_offset != s->last_line_offset ||\n\n        disp_width != s->last_width ||\n\n        height != s->last_height ||\n\n        s->last_depth != depth ||\n\n        s->last_byteswap != byteswap ||\n\n        share_surface != is_buffer_shared(surface)) {\n\n        if (share_surface) {\n\n            surface = qemu_create_displaysurface_from(disp_width,\n\n                    height, format, s->line_offset,\n\n                    s->vram_ptr + (s->start_addr * 4));\n\n            dpy_gfx_replace_surface(s->con, surface);\n\n        } else {\n\n            qemu_console_resize(s->con, disp_width, height);\n\n            surface = qemu_console_surface(s->con);\n\n        }\n\n        s->last_scr_width = disp_width;\n\n        s->last_scr_height = height;\n\n        s->last_width = disp_width;\n\n        s->last_height = height;\n\n        s->last_line_offset = s->line_offset;\n\n        s->last_depth = depth;\n\n        s->last_byteswap = byteswap;\n\n        full_update = 1;\n\n    } else if (is_buffer_shared(surface) &&\n\n               (full_update || surface_data(surface) != s->vram_ptr\n\n                + (s->start_addr * 4))) {\n\n        pixman_format_code_t format =\n\n            qemu_default_pixman_format(depth, !byteswap);\n\n        surface = qemu_create_displaysurface_from(disp_width,\n\n                height, format, s->line_offset,\n\n                s->vram_ptr + (s->start_addr * 4));\n\n        dpy_gfx_replace_surface(s->con, surface);\n\n    }\n\n\n\n    if (shift_control == 0) {\n\n        full_update |= update_palette16(s);\n\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n\n            v = VGA_DRAW_LINE4D2;\n\n        } else {\n\n            v = VGA_DRAW_LINE4;\n\n        }\n\n        bits = 4;\n\n    } else if (shift_control == 1) {\n\n        full_update |= update_palette16(s);\n\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n\n            v = VGA_DRAW_LINE2D2;\n\n        } else {\n\n            v = VGA_DRAW_LINE2;\n\n        }\n\n        bits = 4;\n\n    } else {\n\n        switch(s->get_bpp(s)) {\n\n        default:\n\n        case 0:\n\n            full_update |= update_palette256(s);\n\n            v = VGA_DRAW_LINE8D2;\n\n            bits = 4;\n\n            break;\n\n        case 8:\n\n            full_update |= update_palette256(s);\n\n            v = VGA_DRAW_LINE8;\n\n            bits = 8;\n\n            break;\n\n        case 15:\n\n            v = s->big_endian_fb ? VGA_DRAW_LINE15_BE : VGA_DRAW_LINE15_LE;\n\n            bits = 16;\n\n            break;\n\n        case 16:\n\n            v = s->big_endian_fb ? VGA_DRAW_LINE16_BE : VGA_DRAW_LINE16_LE;\n\n            bits = 16;\n\n            break;\n\n        case 24:\n\n            v = s->big_endian_fb ? VGA_DRAW_LINE24_BE : VGA_DRAW_LINE24_LE;\n\n            bits = 24;\n\n            break;\n\n        case 32:\n\n            v = s->big_endian_fb ? VGA_DRAW_LINE32_BE : VGA_DRAW_LINE32_LE;\n\n            bits = 32;\n\n            break;\n\n        }\n\n    }\n\n    vga_draw_line = vga_draw_line_table[v];\n\n\n\n    if (!is_buffer_shared(surface) && s->cursor_invalidate) {\n\n        s->cursor_invalidate(s);\n\n    }\n\n\n\n    line_offset = s->line_offset;\n\n#if 0\n\n    printf(\"w=%d h=%d v=%d line_offset=%d cr[0x09]=0x%02x cr[0x17]=0x%02x linecmp=%d sr[0x01]=0x%02x\\n\",\n\n           width, height, v, line_offset, s->cr[9], s->cr[VGA_CRTC_MODE],\n\n           s->line_compare, sr(s, VGA_SEQ_CLOCK_MODE));\n\n#endif\n\n    addr1 = (s->start_addr * 4);\n\n    bwidth = DIV_ROUND_UP(width * bits, 8);\n\n    y_start = -1;\n\n    d = surface_data(surface);\n\n    linesize = surface_stride(surface);\n\n    y1 = 0;\n\n\n\n    if (!full_update) {\n\n        ram_addr_t region_start = addr1;\n\n        ram_addr_t region_end = addr1 + line_offset * height;\n\n        vga_sync_dirty_bitmap(s);\n\n        if (s->line_compare < height) {\n\n            /* split screen mode */\n\n            region_start = 0;\n\n        }\n\n        snap = memory_region_snapshot_and_clear_dirty(&s->vram, region_start,\n\n                                                      region_end - region_start,\n\n                                                      DIRTY_MEMORY_VGA);\n\n    }\n\n\n\n    for(y = 0; y < height; y++) {\n\n        addr = addr1;\n\n        if (!(s->cr[VGA_CRTC_MODE] & 1)) {\n\n            int shift;\n\n            /* CGA compatibility handling */\n\n            shift = 14 + ((s->cr[VGA_CRTC_MODE] >> 6) & 1);\n\n            addr = (addr & ~(1 << shift)) | ((y1 & 1) << shift);\n\n        }\n\n        if (!(s->cr[VGA_CRTC_MODE] & 2)) {\n\n            addr = (addr & ~0x8000) | ((y1 & 2) << 14);\n\n        }\n\n        update = full_update;\n\n        page0 = addr;\n\n        page1 = addr + bwidth - 1;\n\n        if (full_update) {\n\n            update = 1;\n\n        } else {\n\n            update = memory_region_snapshot_get_dirty(&s->vram, snap,\n\n                                                      page0, page1 - page0);\n\n        }\n\n        /* explicit invalidation for the hardware cursor (cirrus only) */\n\n        update |= vga_scanline_invalidated(s, y);\n\n        if (update) {\n\n            if (y_start < 0)\n\n                y_start = y;\n\n            if (!(is_buffer_shared(surface))) {\n\n                vga_draw_line(s, d, s->vram_ptr + addr, width);\n\n                if (s->cursor_draw_line)\n\n                    s->cursor_draw_line(s, d, y);\n\n            }\n\n        } else {\n\n            if (y_start >= 0) {\n\n                /* flush to display */\n\n                dpy_gfx_update(s->con, 0, y_start,\n\n                               disp_width, y - y_start);\n\n                y_start = -1;\n\n            }\n\n        }\n\n        if (!multi_run) {\n\n            mask = (s->cr[VGA_CRTC_MODE] & 3) ^ 3;\n\n            if ((y1 & mask) == mask)\n\n                addr1 += line_offset;\n\n            y1++;\n\n            multi_run = multi_scan;\n\n        } else {\n\n            multi_run--;\n\n        }\n\n        /* line compare acts on the displayed lines */\n\n        if (y == s->line_compare)\n\n            addr1 = 0;\n\n        d += linesize;\n\n    }\n\n    if (y_start >= 0) {\n\n        /* flush to display */\n\n        dpy_gfx_update(s->con, 0, y_start,\n\n                       disp_width, y - y_start);\n\n    }\n\n    g_free(snap);\n\n    memset(s->invalidated_y_table, 0, sizeof(s->invalidated_y_table));\n\n}\n", "idx": 24415}
{"project": "qemu", "commit_id": "6546d0dba6c211c1a3eac1252a4f50a0c151a08a", "target": 1, "func": "static bool object_create_initial(const char *type)\n{\n    if (g_str_equal(type, \"rng-egd\")) {\n    /*\n     * return false for concrete netfilters since\n     * they depend on netdevs already existing\n    if (g_str_equal(type, \"filter-buffer\") ||\n        g_str_equal(type, \"filter-dump\") ||\n        g_str_equal(type, \"filter-mirror\") ||\n        g_str_equal(type, \"filter-redirector\")) {\n    return true;", "idx": 24417}
{"project": "qemu", "commit_id": "3dd8a6763bcc50dfc3de8da9279b741c0dea9fb1", "target": 1, "func": "static int bochs_open(BlockDriverState *bs, QDict *options, int flags,\n\n                      Error **errp)\n\n{\n\n    BDRVBochsState *s = bs->opaque;\n\n    int i;\n\n    struct bochs_header bochs;\n\n    struct bochs_header_v1 header_v1;\n\n    int ret;\n\n\n\n    bs->read_only = 1; // no write support yet\n\n\n\n    ret = bdrv_pread(bs->file, 0, &bochs, sizeof(bochs));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    if (strcmp(bochs.magic, HEADER_MAGIC) ||\n\n        strcmp(bochs.type, REDOLOG_TYPE) ||\n\n        strcmp(bochs.subtype, GROWING_TYPE) ||\n\n\t((le32_to_cpu(bochs.version) != HEADER_VERSION) &&\n\n\t(le32_to_cpu(bochs.version) != HEADER_V1))) {\n\n        error_setg(errp, \"Image not in Bochs format\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (le32_to_cpu(bochs.version) == HEADER_V1) {\n\n      memcpy(&header_v1, &bochs, sizeof(bochs));\n\n      bs->total_sectors = le64_to_cpu(header_v1.extra.redolog.disk) / 512;\n\n    } else {\n\n      bs->total_sectors = le64_to_cpu(bochs.extra.redolog.disk) / 512;\n\n    }\n\n\n\n    s->catalog_size = le32_to_cpu(bochs.extra.redolog.catalog);\n\n    s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n\n\n\n    ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,\n\n                     s->catalog_size * 4);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    for (i = 0; i < s->catalog_size; i++)\n\n\tle32_to_cpus(&s->catalog_bitmap[i]);\n\n\n\n    s->data_offset = le32_to_cpu(bochs.header) + (s->catalog_size * 4);\n\n\n\n    s->bitmap_blocks = 1 + (le32_to_cpu(bochs.extra.redolog.bitmap) - 1) / 512;\n\n    s->extent_blocks = 1 + (le32_to_cpu(bochs.extra.redolog.extent) - 1) / 512;\n\n\n\n    s->extent_size = le32_to_cpu(bochs.extra.redolog.extent);\n\n\n\n    qemu_co_mutex_init(&s->lock);\n\n    return 0;\n\n\n\nfail:\n\n    g_free(s->catalog_bitmap);\n\n    return ret;\n\n}\n", "idx": 24418}
{"project": "qemu", "commit_id": "72cd500b725fd9a3bbefeb468d54c192fdc28318", "target": 1, "func": "static inline void elf_core_copy_regs(target_elf_gregset_t *regs,\n\n                                      const CPUSH4State *env)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 16; i++) {\n\n        (*regs[i]) = tswapreg(env->gregs[i]);\n\n    }\n\n\n\n    (*regs)[TARGET_REG_PC] = tswapreg(env->pc);\n\n    (*regs)[TARGET_REG_PR] = tswapreg(env->pr);\n\n    (*regs)[TARGET_REG_SR] = tswapreg(env->sr);\n\n    (*regs)[TARGET_REG_GBR] = tswapreg(env->gbr);\n\n    (*regs)[TARGET_REG_MACH] = tswapreg(env->mach);\n\n    (*regs)[TARGET_REG_MACL] = tswapreg(env->macl);\n\n    (*regs)[TARGET_REG_SYSCALL] = 0; /* FIXME */\n\n}\n", "idx": 24420}
{"project": "qemu", "commit_id": "828808f5ece20fd606218e000139799921c89d93", "target": 1, "func": "static void tcg_out_ld (TCGContext *s, TCGType type, int ret, int arg1,\n\n                        tcg_target_long arg2)\n\n{\n\n    if (type == TCG_TYPE_I32)\n\n        tcg_out_ldst (s, ret, arg1, arg2, LWZ, LWZX);\n\n    else\n\n        tcg_out_ldst (s, ret, arg1, arg2, LD, LDX);\n\n}\n", "idx": 24422}
{"project": "qemu", "commit_id": "089da572b956ef0f8f5b8d5917358e07892a77c2", "target": 1, "func": "void fw_cfg_add_i64(FWCfgState *s, uint16_t key, uint64_t value)\n\n{\n\n    uint64_t *copy;\n\n\n\n    copy = g_malloc(sizeof(value));\n\n    *copy = cpu_to_le64(value);\n\n    fw_cfg_add_bytes(s, key, (uint8_t *)copy, sizeof(value));\n\n}\n", "idx": 24423}
{"project": "qemu", "commit_id": "d861b05ea30e6ac177de9b679da96194ebe21afc", "target": 1, "func": "static NetSocketState *net_socket_fd_init_stream(VLANState *vlan, int fd, \n\n                                          int is_connected)\n\n{\n\n    NetSocketState *s;\n\n    s = qemu_mallocz(sizeof(NetSocketState));\n\n    if (!s)\n\n        return NULL;\n\n    s->fd = fd;\n\n    s->vc = qemu_new_vlan_client(vlan, \n\n                                 net_socket_receive, s);\n\n    snprintf(s->vc->info_str, sizeof(s->vc->info_str),\n\n             \"socket: fd=%d\", fd);\n\n    if (is_connected) {\n\n        net_socket_connect(s);\n\n    } else {\n\n        qemu_set_fd_handler(s->fd, NULL, net_socket_connect, s);\n\n    }\n\n    return s;\n\n}\n", "idx": 24425}
{"project": "qemu", "commit_id": "45db7ba681ede57113a67499840e69ee586bcdf2", "target": 0, "func": "static uint32_t nvic_readl(NVICState *s, uint32_t offset)\n\n{\n\n    ARMCPU *cpu = s->cpu;\n\n    uint32_t val;\n\n\n\n    switch (offset) {\n\n    case 4: /* Interrupt Control Type.  */\n\n        return ((s->num_irq - NVIC_FIRST_IRQ) / 32) - 1;\n\n    case 0xd00: /* CPUID Base.  */\n\n        return cpu->midr;\n\n    case 0xd04: /* Interrupt Control State.  */\n\n        /* VECTACTIVE */\n\n        val = cpu->env.v7m.exception;\n\n        /* VECTPENDING */\n\n        val |= (s->vectpending & 0xff) << 12;\n\n        /* ISRPENDING - set if any external IRQ is pending */\n\n        if (nvic_isrpending(s)) {\n\n            val |= (1 << 22);\n\n        }\n\n        /* RETTOBASE - set if only one handler is active */\n\n        if (nvic_rettobase(s)) {\n\n            val |= (1 << 11);\n\n        }\n\n        /* PENDSTSET */\n\n        if (s->vectors[ARMV7M_EXCP_SYSTICK].pending) {\n\n            val |= (1 << 26);\n\n        }\n\n        /* PENDSVSET */\n\n        if (s->vectors[ARMV7M_EXCP_PENDSV].pending) {\n\n            val |= (1 << 28);\n\n        }\n\n        /* NMIPENDSET */\n\n        if (s->vectors[ARMV7M_EXCP_NMI].pending) {\n\n            val |= (1 << 31);\n\n        }\n\n        /* ISRPREEMPT not implemented */\n\n        return val;\n\n    case 0xd08: /* Vector Table Offset.  */\n\n        return cpu->env.v7m.vecbase;\n\n    case 0xd0c: /* Application Interrupt/Reset Control.  */\n\n        return 0xfa050000 | (s->prigroup << 8);\n\n    case 0xd10: /* System Control.  */\n\n        /* TODO: Implement SLEEPONEXIT.  */\n\n        return 0;\n\n    case 0xd14: /* Configuration Control.  */\n\n        return cpu->env.v7m.ccr;\n\n    case 0xd24: /* System Handler Status.  */\n\n        val = 0;\n\n        if (s->vectors[ARMV7M_EXCP_MEM].active) {\n\n            val |= (1 << 0);\n\n        }\n\n        if (s->vectors[ARMV7M_EXCP_BUS].active) {\n\n            val |= (1 << 1);\n\n        }\n\n        if (s->vectors[ARMV7M_EXCP_USAGE].active) {\n\n            val |= (1 << 3);\n\n        }\n\n        if (s->vectors[ARMV7M_EXCP_SVC].active) {\n\n            val |= (1 << 7);\n\n        }\n\n        if (s->vectors[ARMV7M_EXCP_DEBUG].active) {\n\n            val |= (1 << 8);\n\n        }\n\n        if (s->vectors[ARMV7M_EXCP_PENDSV].active) {\n\n            val |= (1 << 10);\n\n        }\n\n        if (s->vectors[ARMV7M_EXCP_SYSTICK].active) {\n\n            val |= (1 << 11);\n\n        }\n\n        if (s->vectors[ARMV7M_EXCP_USAGE].pending) {\n\n            val |= (1 << 12);\n\n        }\n\n        if (s->vectors[ARMV7M_EXCP_MEM].pending) {\n\n            val |= (1 << 13);\n\n        }\n\n        if (s->vectors[ARMV7M_EXCP_BUS].pending) {\n\n            val |= (1 << 14);\n\n        }\n\n        if (s->vectors[ARMV7M_EXCP_SVC].pending) {\n\n            val |= (1 << 15);\n\n        }\n\n        if (s->vectors[ARMV7M_EXCP_MEM].enabled) {\n\n            val |= (1 << 16);\n\n        }\n\n        if (s->vectors[ARMV7M_EXCP_BUS].enabled) {\n\n            val |= (1 << 17);\n\n        }\n\n        if (s->vectors[ARMV7M_EXCP_USAGE].enabled) {\n\n            val |= (1 << 18);\n\n        }\n\n        return val;\n\n    case 0xd28: /* Configurable Fault Status.  */\n\n        return cpu->env.v7m.cfsr;\n\n    case 0xd2c: /* Hard Fault Status.  */\n\n        return cpu->env.v7m.hfsr;\n\n    case 0xd30: /* Debug Fault Status.  */\n\n        return cpu->env.v7m.dfsr;\n\n    case 0xd34: /* MMFAR MemManage Fault Address */\n\n        return cpu->env.v7m.mmfar;\n\n    case 0xd38: /* Bus Fault Address.  */\n\n        return cpu->env.v7m.bfar;\n\n    case 0xd3c: /* Aux Fault Status.  */\n\n        /* TODO: Implement fault status registers.  */\n\n        qemu_log_mask(LOG_UNIMP,\n\n                      \"Aux Fault status registers unimplemented\\n\");\n\n        return 0;\n\n    case 0xd40: /* PFR0.  */\n\n        return 0x00000030;\n\n    case 0xd44: /* PRF1.  */\n\n        return 0x00000200;\n\n    case 0xd48: /* DFR0.  */\n\n        return 0x00100000;\n\n    case 0xd4c: /* AFR0.  */\n\n        return 0x00000000;\n\n    case 0xd50: /* MMFR0.  */\n\n        return 0x00000030;\n\n    case 0xd54: /* MMFR1.  */\n\n        return 0x00000000;\n\n    case 0xd58: /* MMFR2.  */\n\n        return 0x00000000;\n\n    case 0xd5c: /* MMFR3.  */\n\n        return 0x00000000;\n\n    case 0xd60: /* ISAR0.  */\n\n        return 0x01141110;\n\n    case 0xd64: /* ISAR1.  */\n\n        return 0x02111000;\n\n    case 0xd68: /* ISAR2.  */\n\n        return 0x21112231;\n\n    case 0xd6c: /* ISAR3.  */\n\n        return 0x01111110;\n\n    case 0xd70: /* ISAR4.  */\n\n        return 0x01310102;\n\n    /* TODO: Implement debug registers.  */\n\n    case 0xd90: /* MPU_TYPE */\n\n        /* Unified MPU; if the MPU is not present this value is zero */\n\n        return cpu->pmsav7_dregion << 8;\n\n        break;\n\n    case 0xd94: /* MPU_CTRL */\n\n        return cpu->env.v7m.mpu_ctrl;\n\n    case 0xd98: /* MPU_RNR */\n\n        return cpu->env.pmsav7.rnr;\n\n    case 0xd9c: /* MPU_RBAR */\n\n    case 0xda4: /* MPU_RBAR_A1 */\n\n    case 0xdac: /* MPU_RBAR_A2 */\n\n    case 0xdb4: /* MPU_RBAR_A3 */\n\n    {\n\n        int region = cpu->env.pmsav7.rnr;\n\n\n\n        if (arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            /* PMSAv8M handling of the aliases is different from v7M:\n\n             * aliases A1, A2, A3 override the low two bits of the region\n\n             * number in MPU_RNR, and there is no 'region' field in the\n\n             * RBAR register.\n\n             */\n\n            int aliasno = (offset - 0xd9c) / 8; /* 0..3 */\n\n            if (aliasno) {\n\n                region = deposit32(region, 0, 2, aliasno);\n\n            }\n\n            if (region >= cpu->pmsav7_dregion) {\n\n                return 0;\n\n            }\n\n            return cpu->env.pmsav8.rbar[region];\n\n        }\n\n\n\n        if (region >= cpu->pmsav7_dregion) {\n\n            return 0;\n\n        }\n\n        return (cpu->env.pmsav7.drbar[region] & 0x1f) | (region & 0xf);\n\n    }\n\n    case 0xda0: /* MPU_RASR (v7M), MPU_RLAR (v8M) */\n\n    case 0xda8: /* MPU_RASR_A1 (v7M), MPU_RLAR_A1 (v8M) */\n\n    case 0xdb0: /* MPU_RASR_A2 (v7M), MPU_RLAR_A2 (v8M) */\n\n    case 0xdb8: /* MPU_RASR_A3 (v7M), MPU_RLAR_A3 (v8M) */\n\n    {\n\n        int region = cpu->env.pmsav7.rnr;\n\n\n\n        if (arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            /* PMSAv8M handling of the aliases is different from v7M:\n\n             * aliases A1, A2, A3 override the low two bits of the region\n\n             * number in MPU_RNR.\n\n             */\n\n            int aliasno = (offset - 0xda0) / 8; /* 0..3 */\n\n            if (aliasno) {\n\n                region = deposit32(region, 0, 2, aliasno);\n\n            }\n\n            if (region >= cpu->pmsav7_dregion) {\n\n                return 0;\n\n            }\n\n            return cpu->env.pmsav8.rlar[region];\n\n        }\n\n\n\n        if (region >= cpu->pmsav7_dregion) {\n\n            return 0;\n\n        }\n\n        return ((cpu->env.pmsav7.dracr[region] & 0xffff) << 16) |\n\n            (cpu->env.pmsav7.drsr[region] & 0xffff);\n\n    }\n\n    case 0xdc0: /* MPU_MAIR0 */\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        return cpu->env.pmsav8.mair0;\n\n    case 0xdc4: /* MPU_MAIR1 */\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        return cpu->env.pmsav8.mair1;\n\n    default:\n\n    bad_offset:\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"NVIC: Bad read offset 0x%x\\n\", offset);\n\n        return 0;\n\n    }\n\n}\n", "idx": 24436}
{"project": "qemu", "commit_id": "f5438c0500bb22c97b30987d2e0eab953416c7c5", "target": 0, "func": "static void parse_cmdline(const char *cmdline,\n\n                         int *pnb_args, char **args)\n\n{\n\n    const char *p;\n\n    int nb_args, ret;\n\n    char buf[1024];\n\n\n\n    p = cmdline;\n\n    nb_args = 0;\n\n    for(;;) {\n\n        while (qemu_isspace(*p))\n\n            p++;\n\n        if (*p == '\\0')\n\n            break;\n\n        if (nb_args >= MAX_ARGS)\n\n            break;\n\n        ret = get_str(buf, sizeof(buf), &p);\n\n        args[nb_args] = g_strdup(buf);\n\n        nb_args++;\n\n        if (ret < 0)\n\n            break;\n\n    }\n\n    *pnb_args = nb_args;\n\n}\n", "idx": 24437}
{"project": "qemu", "commit_id": "b40acf99bef69fa8ab0f9092ff162fde945eec12", "target": 0, "func": "void portio_list_destroy(PortioList *piolist)\n\n{\n\n    g_free(piolist->regions);\n\n    g_free(piolist->aliases);\n\n}\n", "idx": 24438}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "INLINE flag extractFloat32Sign( float32 a )\n\n{\n\n\n\n    return a>>31;\n\n\n\n}\n", "idx": 24439}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int proxy_mknod(FsContext *fs_ctx, V9fsPath *dir_path,\n\n                       const char *name, FsCred *credp)\n\n{\n\n    int retval;\n\n    V9fsString fullname;\n\n\n\n    v9fs_string_init(&fullname);\n\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);\n\n\n\n    retval = v9fs_request(fs_ctx->private, T_MKNOD, NULL, \"sdqdd\",\n\n                          &fullname, credp->fc_mode, credp->fc_rdev,\n\n                          credp->fc_uid, credp->fc_gid);\n\n    v9fs_string_free(&fullname);\n\n    if (retval < 0) {\n\n        errno = -retval;\n\n        retval = -1;\n\n    }\n\n    return retval;\n\n}\n", "idx": 24440}
{"project": "qemu", "commit_id": "b61359781958759317ee6fd1a45b59be0b7dbbe1", "target": 0, "func": "static bool memory_region_get_may_overlap(Object *obj, Error **errp)\n\n{\n\n    MemoryRegion *mr = MEMORY_REGION(obj);\n\n\n\n    return mr->may_overlap;\n\n}\n", "idx": 24441}
{"project": "qemu", "commit_id": "ad674e53b5cce265fadafbde2c6a4f190345cd00", "target": 0, "func": "static void DBDMA_run (DBDMA_channel *ch)\n\n{\n\n    int channel;\n\n\n\n    for (channel = 0; channel < DBDMA_CHANNELS; channel++, ch++) {\n\n            uint32_t status = be32_to_cpu(ch->regs[DBDMA_STATUS]);\n\n            if (!ch->processing && (status & RUN) && (status & ACTIVE))\n\n                channel_run(ch);\n\n    }\n\n}\n", "idx": 24443}
{"project": "qemu", "commit_id": "7385aed20db5d83979f683b9d0048674411e963c", "target": 0, "func": "void helper_fstoq(CPUSPARCState *env, float32 src)\n\n{\n\n    clear_float_exceptions(env);\n\n    QT0 = float32_to_float128(src, &env->fp_status);\n\n    check_ieee_exceptions(env);\n\n}\n", "idx": 24444}
{"project": "qemu", "commit_id": "4417ab7adf1613799054be5afedf810fc2524ee8", "target": 0, "func": "static void process_incoming_migration_bh(void *opaque)\n\n{\n\n    Error *local_err = NULL;\n\n    MigrationIncomingState *mis = opaque;\n\n\n\n    /* Make sure all file formats flush their mutable metadata.\n\n     * If we get an error here, just don't restart the VM yet. */\n\n    bdrv_invalidate_cache_all(&local_err);\n\n    if (!local_err) {\n\n        blk_resume_after_migration(&local_err);\n\n    }\n\n    if (local_err) {\n\n        error_report_err(local_err);\n\n        local_err = NULL;\n\n        autostart = false;\n\n    }\n\n\n\n    /*\n\n     * This must happen after all error conditions are dealt with and\n\n     * we're sure the VM is going to be running on this host.\n\n     */\n\n    qemu_announce_self();\n\n\n\n    /* If global state section was not received or we are in running\n\n       state, we need to obey autostart. Any other state is set with\n\n       runstate_set. */\n\n\n\n    if (!global_state_received() ||\n\n        global_state_get_runstate() == RUN_STATE_RUNNING) {\n\n        if (autostart) {\n\n            vm_start();\n\n        } else {\n\n            runstate_set(RUN_STATE_PAUSED);\n\n        }\n\n    } else {\n\n        runstate_set(global_state_get_runstate());\n\n    }\n\n    migrate_decompress_threads_join();\n\n    /*\n\n     * This must happen after any state changes since as soon as an external\n\n     * observer sees this event they might start to prod at the VM assuming\n\n     * it's ready to use.\n\n     */\n\n    migrate_set_state(&mis->state, MIGRATION_STATUS_ACTIVE,\n\n                      MIGRATION_STATUS_COMPLETED);\n\n    qemu_bh_delete(mis->bh);\n\n    migration_incoming_state_destroy();\n\n}\n", "idx": 24445}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "int float64_lt_quiet( float64 a, float64 b STATUS_PARAM )\n\n{\n\n    flag aSign, bSign;\n\n\n\n    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )\n\n         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )\n\n       ) {\n\n        if ( float64_is_signaling_nan( a ) || float64_is_signaling_nan( b ) ) {\n\n            float_raise( float_flag_invalid STATUS_VAR);\n\n        }\n\n        return 0;\n\n    }\n\n    aSign = extractFloat64Sign( a );\n\n    bSign = extractFloat64Sign( b );\n\n    if ( aSign != bSign ) return aSign && ( (bits64) ( ( a | b )<<1 ) != 0 );\n\n    return ( a != b ) && ( aSign ^ ( a < b ) );\n\n\n\n}\n", "idx": 24446}
{"project": "qemu", "commit_id": "076b35b5a56bca57c4aa41044ed304fe9c45d6c5", "target": 0, "func": "static void machine_class_init(ObjectClass *oc, void *data)\n\n{\n\n    MachineClass *mc = MACHINE_CLASS(oc);\n\n    QEMUMachine *qm = data;\n\n    mc->name = qm->name;\n\n    mc->desc = qm->desc;\n\n    mc->init = qm->init;\n\n    mc->kvm_type = qm->kvm_type;\n\n    mc->block_default_type = qm->block_default_type;\n\n    mc->max_cpus = qm->max_cpus;\n\n    mc->no_sdcard = qm->no_sdcard;\n\n    mc->has_dynamic_sysbus = qm->has_dynamic_sysbus;\n\n    mc->is_default = qm->is_default;\n\n    mc->default_machine_opts = qm->default_machine_opts;\n\n    mc->default_boot_order = qm->default_boot_order;\n\n}\n", "idx": 24447}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "static int nbd_co_readv(BlockDriverState *bs, int64_t sector_num,\n\n                        int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n\n\n    return nbd_client_session_co_readv(&s->client, sector_num,\n\n                                       nb_sectors, qiov);\n\n}\n", "idx": 24448}
{"project": "qemu", "commit_id": "88c725c78e87eecb061f882177c7a6a2ac1059ad", "target": 0, "func": "int kvm_irqchip_add_msi_route(KVMState *s, int vector, PCIDevice *dev)\n\n{\n\n    struct kvm_irq_routing_entry kroute = {};\n\n    int virq;\n\n    MSIMessage msg = {0, 0};\n\n\n\n    if (dev) {\n\n        msg = pci_get_msi_message(dev, vector);\n\n    }\n\n\n\n    if (kvm_gsi_direct_mapping()) {\n\n        return kvm_arch_msi_data_to_gsi(msg.data);\n\n    }\n\n\n\n    if (!kvm_gsi_routing_enabled()) {\n\n        return -ENOSYS;\n\n    }\n\n\n\n    virq = kvm_irqchip_get_virq(s);\n\n    if (virq < 0) {\n\n        return virq;\n\n    }\n\n\n\n    kroute.gsi = virq;\n\n    kroute.type = KVM_IRQ_ROUTING_MSI;\n\n    kroute.flags = 0;\n\n    kroute.u.msi.address_lo = (uint32_t)msg.address;\n\n    kroute.u.msi.address_hi = msg.address >> 32;\n\n    kroute.u.msi.data = le32_to_cpu(msg.data);\n\n    if (kvm_msi_devid_required()) {\n\n        kroute.flags = KVM_MSI_VALID_DEVID;\n\n        kroute.u.msi.devid = pci_requester_id(dev);\n\n    }\n\n    if (kvm_arch_fixup_msi_route(&kroute, msg.address, msg.data, dev)) {\n\n        kvm_irqchip_release_virq(s, virq);\n\n        return -EINVAL;\n\n    }\n\n\n\n    trace_kvm_irqchip_add_msi_route(dev ? dev->name : (char *)\"N/A\",\n\n                                    vector, virq);\n\n\n\n    kvm_add_routing_entry(s, &kroute);\n\n    kvm_arch_add_msi_route_post(&kroute, vector, dev);\n\n    kvm_irqchip_commit_routes(s);\n\n\n\n    return virq;\n\n}\n", "idx": 24449}
{"project": "qemu", "commit_id": "cd42d5b23691ad73edfd6dbcfc935a960a9c5a65", "target": 0, "func": "gen_intermediate_code_internal(TriCoreCPU *cpu, struct TranslationBlock *tb,\n\n                              int search_pc)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUTriCoreState *env = &cpu->env;\n\n    DisasContext ctx;\n\n    target_ulong pc_start;\n\n    int num_insns;\n\n    uint16_t *gen_opc_end;\n\n\n\n    if (search_pc) {\n\n        qemu_log(\"search pc %d\\n\", search_pc);\n\n    }\n\n\n\n    num_insns = 0;\n\n    pc_start = tb->pc;\n\n    gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE;\n\n    ctx.pc = pc_start;\n\n    ctx.saved_pc = -1;\n\n    ctx.tb = tb;\n\n    ctx.singlestep_enabled = cs->singlestep_enabled;\n\n    ctx.bstate = BS_NONE;\n\n    ctx.mem_idx = cpu_mmu_index(env);\n\n\n\n    tcg_clear_temp_count();\n\n    gen_tb_start();\n\n    while (ctx.bstate == BS_NONE) {\n\n        ctx.opcode = cpu_ldl_code(env, ctx.pc);\n\n        decode_opc(env, &ctx, 0);\n\n\n\n        num_insns++;\n\n\n\n        if (tcg_ctx.gen_opc_ptr >= gen_opc_end) {\n\n            gen_save_pc(ctx.next_pc);\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        }\n\n        if (singlestep) {\n\n            gen_save_pc(ctx.next_pc);\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        }\n\n        ctx.pc = ctx.next_pc;\n\n    }\n\n\n\n    gen_tb_end(tb, num_insns);\n\n    *tcg_ctx.gen_opc_ptr = INDEX_op_end;\n\n    if (search_pc) {\n\n        printf(\"done_generating search pc\\n\");\n\n    } else {\n\n        tb->size = ctx.pc - pc_start;\n\n        tb->icount = num_insns;\n\n    }\n\n    if (tcg_check_temp_count()) {\n\n        printf(\"LEAK at %08x\\n\", env->PC);\n\n    }\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n        log_target_disas(env, pc_start, ctx.pc - pc_start, 0);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n}\n", "idx": 24450}
{"project": "qemu", "commit_id": "65d21bc73bda6515fd9b4ff5b2e90454f7a0b419", "target": 0, "func": "static int raw_pread_aligned(BlockDriverState *bs, int64_t offset,\n\n                     uint8_t *buf, int count)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    int ret;\n\n\n\n    ret = fd_open(bs);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    ret = pread(s->fd, buf, count, offset);\n\n    if (ret == count)\n\n        goto label__raw_read__success;\n\n\n\n    /* Allow reads beyond the end (needed for pwrite) */\n\n    if ((ret == 0) && bs->growable) {\n\n        int64_t size = raw_getlength(bs);\n\n        if (offset >= size) {\n\n            memset(buf, 0, count);\n\n            ret = count;\n\n            goto label__raw_read__success;\n\n        }\n\n    }\n\n\n\n    DEBUG_BLOCK_PRINT(\"raw_pread(%d:%s, %\" PRId64 \", %p, %d) [%\" PRId64\n\n                      \"] read failed %d : %d = %s\\n\",\n\n                      s->fd, bs->filename, offset, buf, count,\n\n                      bs->total_sectors, ret, errno, strerror(errno));\n\n\n\n    /* Try harder for CDrom. */\n\n    if (bs->type == BDRV_TYPE_CDROM) {\n\n        ret = pread(s->fd, buf, count, offset);\n\n        if (ret == count)\n\n            goto label__raw_read__success;\n\n        ret = pread(s->fd, buf, count, offset);\n\n        if (ret == count)\n\n            goto label__raw_read__success;\n\n\n\n        DEBUG_BLOCK_PRINT(\"raw_pread(%d:%s, %\" PRId64 \", %p, %d) [%\" PRId64\n\n                          \"] retry read failed %d : %d = %s\\n\",\n\n                          s->fd, bs->filename, offset, buf, count,\n\n                          bs->total_sectors, ret, errno, strerror(errno));\n\n    }\n\n\n\nlabel__raw_read__success:\n\n\n\n    return  (ret < 0) ? -errno : ret;\n\n}\n", "idx": 24451}
{"project": "qemu", "commit_id": "c878da3b27ceeed953c9f9a1eb002d59e9dcb4c6", "target": 0, "func": "static void tcg_out_qemu_st_slow_path (TCGContext *s, TCGLabelQemuLdst *label)\n\n{\n\n    int s_bits;\n\n    int ir;\n\n    int opc = label->opc;\n\n    int mem_index = label->mem_index;\n\n    int data_reg = label->datalo_reg;\n\n    int data_reg2 = label->datahi_reg;\n\n    int addr_reg = label->addrlo_reg;\n\n    uint8_t *raddr = label->raddr;\n\n    uint8_t **label_ptr = &label->label_ptr[0];\n\n\n\n    s_bits = opc & 3;\n\n\n\n    /* resolve label address */\n\n    reloc_pc14 (label_ptr[0], (tcg_target_long) s->code_ptr);\n\n\n\n    /* slow path */\n\n    ir = 3;\n\n    tcg_out_mov (s, TCG_TYPE_I32, ir++, TCG_AREG0);\n\n#if TARGET_LONG_BITS == 32\n\n    tcg_out_mov (s, TCG_TYPE_I32, ir++, addr_reg);\n\n#else\n\n#ifdef TCG_TARGET_CALL_ALIGN_ARGS\n\n    ir |= 1;\n\n#endif\n\n    tcg_out_mov (s, TCG_TYPE_I32, ir++, label->addrhi_reg);\n\n    tcg_out_mov (s, TCG_TYPE_I32, ir++, addr_reg);\n\n#endif\n\n\n\n    switch (opc) {\n\n    case 0:\n\n        tcg_out32 (s, (RLWINM\n\n                       | RA (ir)\n\n                       | RS (data_reg)\n\n                       | SH (0)\n\n                       | MB (24)\n\n                       | ME (31)));\n\n        break;\n\n    case 1:\n\n        tcg_out32 (s, (RLWINM\n\n                       | RA (ir)\n\n                       | RS (data_reg)\n\n                       | SH (0)\n\n                       | MB (16)\n\n                       | ME (31)));\n\n        break;\n\n    case 2:\n\n        tcg_out_mov (s, TCG_TYPE_I32, ir, data_reg);\n\n        break;\n\n    case 3:\n\n#ifdef TCG_TARGET_CALL_ALIGN_ARGS\n\n        ir |= 1;\n\n#endif\n\n        tcg_out_mov (s, TCG_TYPE_I32, ir++, data_reg2);\n\n        tcg_out_mov (s, TCG_TYPE_I32, ir, data_reg);\n\n        break;\n\n    }\n\n    ir++;\n\n\n\n    tcg_out_movi (s, TCG_TYPE_I32, ir, mem_index);\n\n    tcg_out_call (s, (tcg_target_long) qemu_st_helpers[opc], 1);\n\n    tcg_out32 (s, B | 8);\n\n    tcg_out32 (s, (tcg_target_long) raddr);\n\n    tcg_out_b (s, 0, (tcg_target_long) raddr);\n\n}\n", "idx": 24452}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void dead_tmp(TCGv tmp)\n\n{\n\n    int i;\n\n    num_temps--;\n\n    i = num_temps;\n\n    if (GET_TCGV(temps[i]) == GET_TCGV(tmp))\n\n        return;\n\n\n\n    /* Shuffle this temp to the last slot.  */\n\n    while (GET_TCGV(temps[i]) != GET_TCGV(tmp))\n\n        i--;\n\n    while (i < num_temps) {\n\n        temps[i] = temps[i + 1];\n\n        i++;\n\n    }\n\n    temps[i] = tmp;\n\n}\n", "idx": 24455}
{"project": "qemu", "commit_id": "269fe4c3ab0cf29329317eb868f8ec90ac761b41", "target": 0, "func": "pvscsi_update_irq_status(PVSCSIState *s)\n\n{\n\n    PCIDevice *d = PCI_DEVICE(s);\n\n    bool should_raise = s->reg_interrupt_enabled & s->reg_interrupt_status;\n\n\n\n    trace_pvscsi_update_irq_level(should_raise, s->reg_interrupt_enabled,\n\n                                  s->reg_interrupt_status);\n\n\n\n    if (s->msi_used && msi_enabled(d)) {\n\n        if (should_raise) {\n\n            trace_pvscsi_update_irq_msi();\n\n            msi_notify(d, PVSCSI_VECTOR_COMPLETION);\n\n        }\n\n        return;\n\n    }\n\n\n\n    pci_set_irq(d, !!should_raise);\n\n}\n", "idx": 24456}
{"project": "qemu", "commit_id": "81cf8d8adc64203567e03326c13ea4abec9fe5df", "target": 0, "func": "static inline void check_io(CPUX86State *env, int addr, int size)\n\n{\n\n    int io_offset, val, mask;\n\n\n\n    /* TSS must be a valid 32 bit one */\n\n    if (!(env->tr.flags & DESC_P_MASK) ||\n\n        ((env->tr.flags >> DESC_TYPE_SHIFT) & 0xf) != 9 ||\n\n        env->tr.limit < 103) {\n\n        goto fail;\n\n    }\n\n    io_offset = cpu_lduw_kernel(env, env->tr.base + 0x66);\n\n    io_offset += (addr >> 3);\n\n    /* Note: the check needs two bytes */\n\n    if ((io_offset + 1) > env->tr.limit) {\n\n        goto fail;\n\n    }\n\n    val = cpu_lduw_kernel(env, env->tr.base + io_offset);\n\n    val >>= (addr & 7);\n\n    mask = (1 << size) - 1;\n\n    /* all bits must be zero to allow the I/O */\n\n    if ((val & mask) != 0) {\n\n    fail:\n\n        raise_exception_err(env, EXCP0D_GPF, 0);\n\n    }\n\n}\n", "idx": 24457}
{"project": "qemu", "commit_id": "376a790970de7e84170ee9360b6ff53ecfa4a1be", "target": 0, "func": "void page_set_flags(target_ulong start, target_ulong end, int flags)\n\n{\n\n    PageDesc *p;\n\n    target_ulong addr;\n\n\n\n    /* mmap_lock should already be held.  */\n\n    start = start & TARGET_PAGE_MASK;\n\n    end = TARGET_PAGE_ALIGN(end);\n\n    if (flags & PAGE_WRITE)\n\n        flags |= PAGE_WRITE_ORG;\n\n    for(addr = start; addr < end; addr += TARGET_PAGE_SIZE) {\n\n        p = page_find_alloc(addr >> TARGET_PAGE_BITS);\n\n        /* We may be called for host regions that are outside guest\n\n           address space.  */\n\n        if (!p)\n\n            return;\n\n        /* if the write protection is set, then we invalidate the code\n\n           inside */\n\n        if (!(p->flags & PAGE_WRITE) &&\n\n            (flags & PAGE_WRITE) &&\n\n            p->first_tb) {\n\n            tb_invalidate_phys_page(addr, 0, NULL);\n\n        }\n\n        p->flags = flags;\n\n    }\n\n}\n", "idx": 24458}
{"project": "qemu", "commit_id": "d09acb9b5ef0bb4fa94d3d459919a6ebaf8804bc", "target": 1, "func": "static void fw_cfg_bootsplash(FWCfgState *s)\n\n{\n\n    int boot_splash_time = -1;\n\n    const char *boot_splash_filename = NULL;\n\n    char *p;\n\n    char *filename, *file_data;\n\n    int file_size;\n\n    int file_type = -1;\n\n    const char *temp;\n\n\n\n    /* get user configuration */\n\n    QemuOptsList *plist = qemu_find_opts(\"boot-opts\");\n\n    QemuOpts *opts = QTAILQ_FIRST(&plist->head);\n\n    if (opts != NULL) {\n\n        temp = qemu_opt_get(opts, \"splash\");\n\n        if (temp != NULL) {\n\n            boot_splash_filename = temp;\n\n        }\n\n        temp = qemu_opt_get(opts, \"splash-time\");\n\n        if (temp != NULL) {\n\n            p = (char *)temp;\n\n            boot_splash_time = strtol(p, (char **)&p, 10);\n\n        }\n\n    }\n\n\n\n    /* insert splash time if user configurated */\n\n    if (boot_splash_time >= 0) {\n\n        /* validate the input */\n\n        if (boot_splash_time > 0xffff) {\n\n            error_report(\"splash time is big than 65535, force it to 65535.\");\n\n            boot_splash_time = 0xffff;\n\n        }\n\n        /* use little endian format */\n\n        qemu_extra_params_fw[0] = (uint8_t)(boot_splash_time & 0xff);\n\n        qemu_extra_params_fw[1] = (uint8_t)((boot_splash_time >> 8) & 0xff);\n\n        fw_cfg_add_file(s, \"etc/boot-menu-wait\", qemu_extra_params_fw, 2);\n\n    }\n\n\n\n    /* insert splash file if user configurated */\n\n    if (boot_splash_filename != NULL) {\n\n        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, boot_splash_filename);\n\n        if (filename == NULL) {\n\n            error_report(\"failed to find file '%s'.\", boot_splash_filename);\n\n            return;\n\n        }\n\n\n\n        /* loading file data */\n\n        file_data = read_splashfile(filename, &file_size, &file_type);\n\n        if (file_data == NULL) {\n\n            g_free(filename);\n\n            return;\n\n        }\n\n        if (boot_splash_filedata != NULL) {\n\n            g_free(boot_splash_filedata);\n\n        }\n\n        boot_splash_filedata = (uint8_t *)file_data;\n\n        boot_splash_filedata_size = file_size;\n\n\n\n        /* insert data */\n\n        if (file_type == JPG_FILE) {\n\n            fw_cfg_add_file(s, \"bootsplash.jpg\",\n\n                    boot_splash_filedata, boot_splash_filedata_size);\n\n        } else {\n\n            fw_cfg_add_file(s, \"bootsplash.bmp\",\n\n                    boot_splash_filedata, boot_splash_filedata_size);\n\n        }\n\n        g_free(filename);\n\n    }\n\n}\n", "idx": 24461}
{"project": "qemu", "commit_id": "50d4a858e62b1d864227d13f07d2c79c118d046a", "target": 1, "func": "static ssize_t handle_aiocb_rw(RawPosixAIOData *aiocb)\n\n{\n\n    ssize_t nbytes;\n\n    char *buf;\n\n\n\n    if (!(aiocb->aio_type & QEMU_AIO_MISALIGNED)) {\n\n        /*\n\n         * If there is just a single buffer, and it is properly aligned\n\n         * we can just use plain pread/pwrite without any problems.\n\n         */\n\n        if (aiocb->aio_niov == 1) {\n\n             return handle_aiocb_rw_linear(aiocb, aiocb->aio_iov->iov_base);\n\n        }\n\n        /*\n\n         * We have more than one iovec, and all are properly aligned.\n\n         *\n\n         * Try preadv/pwritev first and fall back to linearizing the\n\n         * buffer if it's not supported.\n\n         */\n\n        if (preadv_present) {\n\n            nbytes = handle_aiocb_rw_vector(aiocb);\n\n            if (nbytes == aiocb->aio_nbytes ||\n\n                (nbytes < 0 && nbytes != -ENOSYS)) {\n\n                return nbytes;\n\n            }\n\n            preadv_present = false;\n\n        }\n\n\n\n        /*\n\n         * XXX(hch): short read/write.  no easy way to handle the reminder\n\n         * using these interfaces.  For now retry using plain\n\n         * pread/pwrite?\n\n         */\n\n    }\n\n\n\n    /*\n\n     * Ok, we have to do it the hard way, copy all segments into\n\n     * a single aligned buffer.\n\n     */\n\n    buf = qemu_blockalign(aiocb->bs, aiocb->aio_nbytes);\n\n    if (aiocb->aio_type & QEMU_AIO_WRITE) {\n\n        char *p = buf;\n\n        int i;\n\n\n\n        for (i = 0; i < aiocb->aio_niov; ++i) {\n\n            memcpy(p, aiocb->aio_iov[i].iov_base, aiocb->aio_iov[i].iov_len);\n\n            p += aiocb->aio_iov[i].iov_len;\n\n        }\n\n        assert(p - buf == aiocb->aio_nbytes);\n\n    }\n\n\n\n    nbytes = handle_aiocb_rw_linear(aiocb, buf);\n\n    if (!(aiocb->aio_type & QEMU_AIO_WRITE)) {\n\n        char *p = buf;\n\n        size_t count = aiocb->aio_nbytes, copy;\n\n        int i;\n\n\n\n        for (i = 0; i < aiocb->aio_niov && count; ++i) {\n\n            copy = count;\n\n            if (copy > aiocb->aio_iov[i].iov_len) {\n\n                copy = aiocb->aio_iov[i].iov_len;\n\n            }\n\n            memcpy(aiocb->aio_iov[i].iov_base, p, copy);\n\n            assert(count >= copy);\n\n            p     += copy;\n\n            count -= copy;\n\n        }\n\n        assert(count == 0);\n\n    }\n\n    qemu_vfree(buf);\n\n\n\n    return nbytes;\n\n}\n", "idx": 24462}
{"project": "qemu", "commit_id": "f53671c054ba0b5d5b10e2a7294786fa2f73479e", "target": 1, "func": "static inline void set_txint(ChannelState *s)\n\n{\n\n    s->txint = 1;\n\n    if (!s->rxint_under_svc) {\n\n        s->txint_under_svc = 1;\n\n        if (s->chn == chn_a) {\n\n            s->rregs[R_INTR] |= INTR_TXINTA;\n\n            if (s->wregs[W_MINTR] & MINTR_STATUSHI)\n\n                s->otherchn->rregs[R_IVEC] = IVEC_HITXINTA;\n\n            else\n\n                s->otherchn->rregs[R_IVEC] = IVEC_LOTXINTA;\n\n        } else {\n\n            s->rregs[R_IVEC] = IVEC_TXINTB;\n\n            s->otherchn->rregs[R_INTR] |= INTR_TXINTB;\n\n        }\n\n    escc_update_irq(s);\n\n    }\n\n}\n", "idx": 24463}
{"project": "qemu", "commit_id": "7174970a94df10ee84143edc7c94a2472d654604", "target": 1, "func": "static inline abi_long host_to_target_cmsg(struct target_msghdr *target_msgh,\n\n                                           struct msghdr *msgh)\n\n{\n\n    struct cmsghdr *cmsg = CMSG_FIRSTHDR(msgh);\n\n    abi_long msg_controllen;\n\n    abi_ulong target_cmsg_addr;\n\n    struct target_cmsghdr *target_cmsg, *target_cmsg_start;\n\n    socklen_t space = 0;\n\n\n\n    msg_controllen = tswapal(target_msgh->msg_controllen);\n\n    if (msg_controllen < sizeof (struct target_cmsghdr)) \n\n        goto the_end;\n\n    target_cmsg_addr = tswapal(target_msgh->msg_control);\n\n    target_cmsg = lock_user(VERIFY_WRITE, target_cmsg_addr, msg_controllen, 0);\n\n    target_cmsg_start = target_cmsg;\n\n    if (!target_cmsg)\n\n        return -TARGET_EFAULT;\n\n\n\n    while (cmsg && target_cmsg) {\n\n        void *data = CMSG_DATA(cmsg);\n\n        void *target_data = TARGET_CMSG_DATA(target_cmsg);\n\n\n\n        int len = cmsg->cmsg_len - CMSG_ALIGN(sizeof (struct cmsghdr));\n\n        int tgt_len, tgt_space;\n\n\n\n        /* We never copy a half-header but may copy half-data;\n\n         * this is Linux's behaviour in put_cmsg(). Note that\n\n         * truncation here is a guest problem (which we report\n\n         * to the guest via the CTRUNC bit), unlike truncation\n\n         * in target_to_host_cmsg, which is a QEMU bug.\n\n         */\n\n        if (msg_controllen < sizeof(struct cmsghdr)) {\n\n            target_msgh->msg_flags |= tswap32(MSG_CTRUNC);\n\n            break;\n\n        }\n\n\n\n        if (cmsg->cmsg_level == SOL_SOCKET) {\n\n            target_cmsg->cmsg_level = tswap32(TARGET_SOL_SOCKET);\n\n        } else {\n\n            target_cmsg->cmsg_level = tswap32(cmsg->cmsg_level);\n\n        }\n\n        target_cmsg->cmsg_type = tswap32(cmsg->cmsg_type);\n\n\n\n        tgt_len = TARGET_CMSG_LEN(len);\n\n\n\n        /* Payload types which need a different size of payload on\n\n         * the target must adjust tgt_len here.\n\n         */\n\n        switch (cmsg->cmsg_level) {\n\n        case SOL_SOCKET:\n\n            switch (cmsg->cmsg_type) {\n\n            case SO_TIMESTAMP:\n\n                tgt_len = sizeof(struct target_timeval);\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n        default:\n\n            break;\n\n        }\n\n\n\n        if (msg_controllen < tgt_len) {\n\n            target_msgh->msg_flags |= tswap32(MSG_CTRUNC);\n\n            tgt_len = msg_controllen;\n\n        }\n\n\n\n        /* We must now copy-and-convert len bytes of payload\n\n         * into tgt_len bytes of destination space. Bear in mind\n\n         * that in both source and destination we may be dealing\n\n         * with a truncated value!\n\n         */\n\n        switch (cmsg->cmsg_level) {\n\n        case SOL_SOCKET:\n\n            switch (cmsg->cmsg_type) {\n\n            case SCM_RIGHTS:\n\n            {\n\n                int *fd = (int *)data;\n\n                int *target_fd = (int *)target_data;\n\n                int i, numfds = tgt_len / sizeof(int);\n\n\n\n                for (i = 0; i < numfds; i++) {\n\n                    __put_user(fd[i], target_fd + i);\n\n                }\n\n                break;\n\n            }\n\n            case SO_TIMESTAMP:\n\n            {\n\n                struct timeval *tv = (struct timeval *)data;\n\n                struct target_timeval *target_tv =\n\n                    (struct target_timeval *)target_data;\n\n\n\n                if (len != sizeof(struct timeval) ||\n\n                    tgt_len != sizeof(struct target_timeval)) {\n\n                    goto unimplemented;\n\n                }\n\n\n\n                /* copy struct timeval to target */\n\n                __put_user(tv->tv_sec, &target_tv->tv_sec);\n\n                __put_user(tv->tv_usec, &target_tv->tv_usec);\n\n                break;\n\n            }\n\n            case SCM_CREDENTIALS:\n\n            {\n\n                struct ucred *cred = (struct ucred *)data;\n\n                struct target_ucred *target_cred =\n\n                    (struct target_ucred *)target_data;\n\n\n\n                __put_user(cred->pid, &target_cred->pid);\n\n                __put_user(cred->uid, &target_cred->uid);\n\n                __put_user(cred->gid, &target_cred->gid);\n\n                break;\n\n            }\n\n            default:\n\n                goto unimplemented;\n\n            }\n\n            break;\n\n\n\n        case SOL_IP:\n\n            switch (cmsg->cmsg_type) {\n\n            case IP_TTL:\n\n            {\n\n                uint32_t *v = (uint32_t *)data;\n\n                uint32_t *t_int = (uint32_t *)target_data;\n\n\n\n                __put_user(*v, t_int);\n\n                break;\n\n            }\n\n            case IP_RECVERR:\n\n            {\n\n                struct errhdr_t {\n\n                   struct sock_extended_err ee;\n\n                   struct sockaddr_in offender;\n\n                };\n\n                struct errhdr_t *errh = (struct errhdr_t *)data;\n\n                struct errhdr_t *target_errh =\n\n                    (struct errhdr_t *)target_data;\n\n\n\n                __put_user(errh->ee.ee_errno, &target_errh->ee.ee_errno);\n\n                __put_user(errh->ee.ee_origin, &target_errh->ee.ee_origin);\n\n                __put_user(errh->ee.ee_type,  &target_errh->ee.ee_type);\n\n                __put_user(errh->ee.ee_code, &target_errh->ee.ee_code);\n\n                __put_user(errh->ee.ee_pad, &target_errh->ee.ee_pad);\n\n                __put_user(errh->ee.ee_info, &target_errh->ee.ee_info);\n\n                __put_user(errh->ee.ee_data, &target_errh->ee.ee_data);\n\n                host_to_target_sockaddr((unsigned long) &target_errh->offender,\n\n                    (void *) &errh->offender, sizeof(errh->offender));\n\n                break;\n\n            }\n\n            default:\n\n                goto unimplemented;\n\n            }\n\n            break;\n\n\n\n        case SOL_IPV6:\n\n            switch (cmsg->cmsg_type) {\n\n            case IPV6_HOPLIMIT:\n\n            {\n\n                uint32_t *v = (uint32_t *)data;\n\n                uint32_t *t_int = (uint32_t *)target_data;\n\n\n\n                __put_user(*v, t_int);\n\n                break;\n\n            }\n\n            case IPV6_RECVERR:\n\n            {\n\n                struct errhdr6_t {\n\n                   struct sock_extended_err ee;\n\n                   struct sockaddr_in6 offender;\n\n                };\n\n                struct errhdr6_t *errh = (struct errhdr6_t *)data;\n\n                struct errhdr6_t *target_errh =\n\n                    (struct errhdr6_t *)target_data;\n\n\n\n                __put_user(errh->ee.ee_errno, &target_errh->ee.ee_errno);\n\n                __put_user(errh->ee.ee_origin, &target_errh->ee.ee_origin);\n\n                __put_user(errh->ee.ee_type,  &target_errh->ee.ee_type);\n\n                __put_user(errh->ee.ee_code, &target_errh->ee.ee_code);\n\n                __put_user(errh->ee.ee_pad, &target_errh->ee.ee_pad);\n\n                __put_user(errh->ee.ee_info, &target_errh->ee.ee_info);\n\n                __put_user(errh->ee.ee_data, &target_errh->ee.ee_data);\n\n                host_to_target_sockaddr((unsigned long) &target_errh->offender,\n\n                    (void *) &errh->offender, sizeof(errh->offender));\n\n                break;\n\n            }\n\n            default:\n\n                goto unimplemented;\n\n            }\n\n            break;\n\n\n\n        default:\n\n        unimplemented:\n\n            gemu_log(\"Unsupported ancillary data: %d/%d\\n\",\n\n                                        cmsg->cmsg_level, cmsg->cmsg_type);\n\n            memcpy(target_data, data, MIN(len, tgt_len));\n\n            if (tgt_len > len) {\n\n                memset(target_data + len, 0, tgt_len - len);\n\n            }\n\n        }\n\n\n\n        target_cmsg->cmsg_len = tswapal(tgt_len);\n\n        tgt_space = TARGET_CMSG_SPACE(len);\n\n        if (msg_controllen < tgt_space) {\n\n            tgt_space = msg_controllen;\n\n        }\n\n        msg_controllen -= tgt_space;\n\n        space += tgt_space;\n\n        cmsg = CMSG_NXTHDR(msgh, cmsg);\n\n        target_cmsg = TARGET_CMSG_NXTHDR(target_msgh, target_cmsg,\n\n                                         target_cmsg_start);\n\n    }\n\n    unlock_user(target_cmsg, target_cmsg_addr, space);\n\n the_end:\n\n    target_msgh->msg_controllen = tswapal(space);\n\n    return 0;\n\n}\n", "idx": 24470}
{"project": "qemu", "commit_id": "09aaa1602f9381c0e0fb539390b1793e51bdfc7b", "target": 1, "func": "static void ib700_pc_init(PCIBus *unused)\n\n{\n\n    register_savevm(\"ib700_wdt\", -1, 0, ib700_save, ib700_load, NULL);\n\n\n\n    register_ioport_write(0x441, 2, 1, ib700_write_disable_reg, NULL);\n\n    register_ioport_write(0x443, 2, 1, ib700_write_enable_reg, NULL);\n\n}\n", "idx": 24473}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "static int vscsi_srp_indirect_data(VSCSIState *s, vscsi_req *req,\n\n                                   uint8_t *buf, uint32_t len)\n\n{\n\n    struct srp_direct_buf *td = &req->ind_desc->table_desc;\n\n    struct srp_direct_buf *md = req->cur_desc;\n\n    int rc = 0;\n\n    uint32_t llen, total = 0;\n\n\n\n    dprintf(\"VSCSI: indirect segment 0x%x bytes, td va=0x%llx len=0x%x\\n\",\n\n            len, (unsigned long long)td->va, td->len);\n\n\n\n    /* While we have data ... */\n\n    while (len) {\n\n        /* If we have a descriptor but it's empty, go fetch a new one */\n\n        if (md && md->len == 0) {\n\n            /* More local available, use one */\n\n            if (req->local_desc) {\n\n                md = ++req->cur_desc;\n\n                --req->local_desc;\n\n                --req->total_desc;\n\n                td->va += sizeof(struct srp_direct_buf);\n\n            } else {\n\n                md = req->cur_desc = NULL;\n\n            }\n\n        }\n\n        /* No descriptor at hand, fetch one */\n\n        if (!md) {\n\n            if (!req->total_desc) {\n\n                dprintf(\"VSCSI:   Out of descriptors !\\n\");\n\n                break;\n\n            }\n\n            md = req->cur_desc = &req->ext_desc;\n\n            dprintf(\"VSCSI:   Reading desc from 0x%llx\\n\",\n\n                    (unsigned long long)td->va);\n\n            rc = spapr_tce_dma_read(&s->vdev, td->va, md,\n\n                                    sizeof(struct srp_direct_buf));\n\n            if (rc) {\n\n                dprintf(\"VSCSI: tce_dma_read -> %d reading ext_desc\\n\", rc);\n\n                break;\n\n            }\n\n            vscsi_swap_desc(md);\n\n            td->va += sizeof(struct srp_direct_buf);\n\n            --req->total_desc;\n\n        }\n\n        dprintf(\"VSCSI:   [desc va=0x%llx,len=0x%x] remaining=0x%x\\n\",\n\n                (unsigned long long)md->va, md->len, len);\n\n\n\n        /* Perform transfer */\n\n        llen = MIN(len, md->len);\n\n        if (req->writing) { /* writing = to device = reading from memory */\n\n            rc = spapr_tce_dma_read(&s->vdev, md->va, buf, llen);\n\n        } else {\n\n            rc = spapr_tce_dma_write(&s->vdev, md->va, buf, llen);\n\n        }\n\n        if (rc) {\n\n            dprintf(\"VSCSI: tce_dma_r/w(%d) -> %d\\n\", req->writing, rc);\n\n            break;\n\n        }\n\n        dprintf(\"VSCSI:     data: %02x %02x %02x %02x...\\n\",\n\n                buf[0], buf[1], buf[2], buf[3]);\n\n\n\n        len -= llen;\n\n        buf += llen;\n\n        total += llen;\n\n        md->va += llen;\n\n        md->len -= llen;\n\n    }\n\n    return rc ? -1 : total;\n\n}\n", "idx": 24474}
{"project": "qemu", "commit_id": "b8afb520e479e693c227aa39c2fb7670743e104f", "target": 1, "func": "static void mirror_start_job(BlockDriverState *bs, BlockDriverState *target,\n\n                            int64_t speed, int64_t granularity,\n\n                            int64_t buf_size,\n\n                            BlockdevOnError on_source_error,\n\n                            BlockdevOnError on_target_error,\n\n                            BlockDriverCompletionFunc *cb,\n\n                            void *opaque, Error **errp,\n\n                            const BlockJobDriver *driver,\n\n                            bool is_none_mode, BlockDriverState *base)\n\n{\n\n    MirrorBlockJob *s;\n\n\n\n    if (granularity == 0) {\n\n        /* Choose the default granularity based on the target file's cluster\n\n         * size, clamped between 4k and 64k.  */\n\n        BlockDriverInfo bdi;\n\n        if (bdrv_get_info(target, &bdi) >= 0 && bdi.cluster_size != 0) {\n\n            granularity = MAX(4096, bdi.cluster_size);\n\n            granularity = MIN(65536, granularity);\n\n        } else {\n\n            granularity = 65536;\n\n        }\n\n    }\n\n\n\n    assert ((granularity & (granularity - 1)) == 0);\n\n\n\n    if ((on_source_error == BLOCKDEV_ON_ERROR_STOP ||\n\n         on_source_error == BLOCKDEV_ON_ERROR_ENOSPC) &&\n\n        !bdrv_iostatus_is_enabled(bs)) {\n\n        error_set(errp, QERR_INVALID_PARAMETER, \"on-source-error\");\n\n        return;\n\n    }\n\n\n\n\n\n    s = block_job_create(driver, bs, speed, cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->on_source_error = on_source_error;\n\n    s->on_target_error = on_target_error;\n\n    s->target = target;\n\n    s->is_none_mode = is_none_mode;\n\n    s->base = base;\n\n    s->granularity = granularity;\n\n    s->buf_size = MAX(buf_size, granularity);\n\n\n\n    s->dirty_bitmap = bdrv_create_dirty_bitmap(bs, granularity);\n\n    bdrv_set_enable_write_cache(s->target, true);\n\n    bdrv_set_on_error(s->target, on_target_error, on_target_error);\n\n    bdrv_iostatus_enable(s->target);\n\n    s->common.co = qemu_coroutine_create(mirror_run);\n\n    trace_mirror_start(bs, s, s->common.co, opaque);\n\n    qemu_coroutine_enter(s->common.co, s);\n\n}\n", "idx": 24482}
{"project": "qemu", "commit_id": "240ce26a0533a6e5ee472789fbfbd9f7f939197e", "target": 1, "func": "static void gen_pool16c_insn(DisasContext *ctx, int *is_branch)\n\n{\n\n    int rd = mmreg((ctx->opcode >> 3) & 0x7);\n\n    int rs = mmreg(ctx->opcode & 0x7);\n\n    int opc;\n\n\n\n    switch (((ctx->opcode) >> 4) & 0x3f) {\n\n    case NOT16 + 0:\n\n    case NOT16 + 1:\n\n    case NOT16 + 2:\n\n    case NOT16 + 3:\n\n        gen_logic(ctx, OPC_NOR, rd, rs, 0);\n\n        break;\n\n    case XOR16 + 0:\n\n    case XOR16 + 1:\n\n    case XOR16 + 2:\n\n    case XOR16 + 3:\n\n        gen_logic(ctx, OPC_XOR, rd, rd, rs);\n\n        break;\n\n    case AND16 + 0:\n\n    case AND16 + 1:\n\n    case AND16 + 2:\n\n    case AND16 + 3:\n\n        gen_logic(ctx, OPC_AND, rd, rd, rs);\n\n        break;\n\n    case OR16 + 0:\n\n    case OR16 + 1:\n\n    case OR16 + 2:\n\n    case OR16 + 3:\n\n        gen_logic(ctx, OPC_OR, rd, rd, rs);\n\n        break;\n\n    case LWM16 + 0:\n\n    case LWM16 + 1:\n\n    case LWM16 + 2:\n\n    case LWM16 + 3:\n\n        {\n\n            static const int lwm_convert[] = { 0x11, 0x12, 0x13, 0x14 };\n\n            int offset = ZIMM(ctx->opcode, 0, 4);\n\n\n\n            gen_ldst_multiple(ctx, LWM32, lwm_convert[(ctx->opcode >> 4) & 0x3],\n\n                              29, offset << 2);\n\n        }\n\n        break;\n\n    case SWM16 + 0:\n\n    case SWM16 + 1:\n\n    case SWM16 + 2:\n\n    case SWM16 + 3:\n\n        {\n\n            static const int swm_convert[] = { 0x11, 0x12, 0x13, 0x14 };\n\n            int offset = ZIMM(ctx->opcode, 0, 4);\n\n\n\n            gen_ldst_multiple(ctx, SWM32, swm_convert[(ctx->opcode >> 4) & 0x3],\n\n                              29, offset << 2);\n\n        }\n\n        break;\n\n    case JR16 + 0:\n\n    case JR16 + 1:\n\n        {\n\n            int reg = ctx->opcode & 0x1f;\n\n\n\n            gen_compute_branch(ctx, OPC_JR, 2, reg, 0, 0);\n\n        }\n\n        *is_branch = 1;\n\n        break;\n\n    case JRC16 + 0:\n\n    case JRC16 + 1:\n\n        {\n\n            int reg = ctx->opcode & 0x1f;\n\n\n\n            gen_compute_branch(ctx, OPC_JR, 2, reg, 0, 0);\n\n            /* Let normal delay slot handling in our caller take us\n\n               to the branch target.  */\n\n        }\n\n        break;\n\n    case JALR16 + 0:\n\n    case JALR16 + 1:\n\n        opc = OPC_JALR;\n\n        goto do_jalr;\n\n    case JALR16S + 0:\n\n    case JALR16S + 1:\n\n        opc = OPC_JALRS;\n\n    do_jalr:\n\n        {\n\n            int reg = ctx->opcode & 0x1f;\n\n\n\n            gen_compute_branch(ctx, opc, 2, reg, 31, 0);\n\n        }\n\n        *is_branch = 1;\n\n        break;\n\n    case MFHI16 + 0:\n\n    case MFHI16 + 1:\n\n        gen_HILO(ctx, OPC_MFHI, 0, uMIPS_RS5(ctx->opcode));\n\n        break;\n\n    case MFLO16 + 0:\n\n    case MFLO16 + 1:\n\n        gen_HILO(ctx, OPC_MFLO, 0, uMIPS_RS5(ctx->opcode));\n\n        break;\n\n    case BREAK16:\n\n        generate_exception(ctx, EXCP_BREAK);\n\n        break;\n\n    case SDBBP16:\n\n        /* XXX: not clear which exception should be raised\n\n         *      when in debug mode...\n\n         */\n\n        check_insn(ctx, ISA_MIPS32);\n\n        if (!(ctx->hflags & MIPS_HFLAG_DM)) {\n\n            generate_exception(ctx, EXCP_DBp);\n\n        } else {\n\n            generate_exception(ctx, EXCP_DBp);\n\n        }\n\n        break;\n\n    case JRADDIUSP + 0:\n\n    case JRADDIUSP + 1:\n\n        {\n\n            int imm = ZIMM(ctx->opcode, 0, 5);\n\n\n\n            gen_compute_branch(ctx, OPC_JR, 2, 31, 0, 0);\n\n            gen_arith_imm(ctx, OPC_ADDIU, 29, 29, imm << 2);\n\n            /* Let normal delay slot handling in our caller take us\n\n               to the branch target.  */\n\n        }\n\n        break;\n\n    default:\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    }\n\n}\n", "idx": 24483}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "static ssize_t vnc_tls_push(gnutls_transport_ptr_t transport,\n\n                            const void *data,\n\n                            size_t len) {\n\n    VncState *vs = (VncState *)transport;\n\n    int ret;\n\n\n\n retry:\n\n    ret = send(vs->csock, data, len, 0);\n\n    if (ret < 0) {\n\n        if (errno == EINTR)\n\n            goto retry;\n\n        return -1;\n\n    }\n\n    return ret;\n\n}\n", "idx": 24485}
{"project": "qemu", "commit_id": "4715d42efe8632b0f9d2594a80e917de45e4ef88", "target": 1, "func": "static void property_set_enum(Object *obj, Visitor *v, void *opaque,\n\n                              const char *name, Error **errp)\n\n{\n\n    EnumProperty *prop = opaque;\n\n    int value;\n\n\n\n    visit_type_enum(v, &value, prop->strings, NULL, name, errp);\n\n    prop->set(obj, value, errp);\n\n}\n", "idx": 24486}
{"project": "qemu", "commit_id": "0e321191224c8cd137eef41da3257e096965c3d6", "target": 1, "func": "bool hbitmap_get(const HBitmap *hb, uint64_t item)\n\n{\n\n    /* Compute position and bit in the last layer.  */\n\n    uint64_t pos = item >> hb->granularity;\n\n    unsigned long bit = 1UL << (pos & (BITS_PER_LONG - 1));\n\n\n\n\n    return (hb->levels[HBITMAP_LEVELS - 1][pos >> BITS_PER_LEVEL] & bit) != 0;\n\n}", "idx": 24490}
{"project": "qemu", "commit_id": "4cad3867b6df2c0826ae508a9fe15dd0b9d8936a", "target": 1, "func": "int fw_cfg_add_bytes(FWCfgState *s, uint16_t key, uint8_t *data, uint32_t len)\n\n{\n\n    int arch = !!(key & FW_CFG_ARCH_LOCAL);\n\n\n\n    key &= FW_CFG_ENTRY_MASK;\n\n\n\n    if (key >= FW_CFG_MAX_ENTRY)\n\n        return 0;\n\n\n\n    s->entries[arch][key].data = data;\n\n    s->entries[arch][key].len = len;\n\n\n\n    return 1;\n\n}\n", "idx": 24492}
{"project": "qemu", "commit_id": "8336aafae1451d54c81dd2b187b45f7c45d2428e", "target": 1, "func": "static void qcow2_invalidate_cache(BlockDriverState *bs, Error **errp)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int flags = s->flags;\n\n    AES_KEY aes_encrypt_key;\n\n    AES_KEY aes_decrypt_key;\n\n    uint32_t crypt_method = 0;\n\n    QDict *options;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    /*\n\n     * Backing files are read-only which makes all of their metadata immutable,\n\n     * that means we don't have to worry about reopening them here.\n\n     */\n\n\n\n    if (s->crypt_method) {\n\n        crypt_method = s->crypt_method;\n\n        memcpy(&aes_encrypt_key, &s->aes_encrypt_key, sizeof(aes_encrypt_key));\n\n        memcpy(&aes_decrypt_key, &s->aes_decrypt_key, sizeof(aes_decrypt_key));\n\n    }\n\n\n\n    qcow2_close(bs);\n\n\n\n    bdrv_invalidate_cache(bs->file, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    memset(s, 0, sizeof(BDRVQcowState));\n\n    options = qdict_clone_shallow(bs->options);\n\n\n\n    ret = qcow2_open(bs, options, flags, &local_err);\n\n    QDECREF(options);\n\n    if (local_err) {\n\n        error_setg(errp, \"Could not reopen qcow2 layer: %s\",\n\n                   error_get_pretty(local_err));\n\n        error_free(local_err);\n\n        return;\n\n    } else if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"Could not reopen qcow2 layer\");\n\n        return;\n\n    }\n\n\n\n    if (crypt_method) {\n\n        s->crypt_method = crypt_method;\n\n        memcpy(&s->aes_encrypt_key, &aes_encrypt_key, sizeof(aes_encrypt_key));\n\n        memcpy(&s->aes_decrypt_key, &aes_decrypt_key, sizeof(aes_decrypt_key));\n\n    }\n\n}\n", "idx": 24493}
{"project": "qemu", "commit_id": "07caea315a85ebfe90851f9c2e4ef3fdd24117b5", "target": 1, "func": "static void ppc_prep_init (ram_addr_t ram_size,\n\n                           const char *boot_device,\n\n                           const char *kernel_filename,\n\n                           const char *kernel_cmdline,\n\n                           const char *initrd_filename,\n\n                           const char *cpu_model)\n\n{\n\n    CPUState *env = NULL, *envs[MAX_CPUS];\n\n    char *filename;\n\n    nvram_t nvram;\n\n    m48t59_t *m48t59;\n\n    int PPC_io_memory;\n\n    int linux_boot, i, nb_nics1, bios_size;\n\n    ram_addr_t ram_offset, bios_offset;\n\n    uint32_t kernel_base, kernel_size, initrd_base, initrd_size;\n\n    PCIBus *pci_bus;\n\n    qemu_irq *i8259;\n\n    int ppc_boot_device;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    DriveInfo *fd[MAX_FD];\n\n\n\n    sysctrl = qemu_mallocz(sizeof(sysctrl_t));\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL)\n\n        cpu_model = \"602\";\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        if (env->flags & POWERPC_FLAG_RTC_CLK) {\n\n            /* POWER / PowerPC 601 RTC clock frequency is 7.8125 MHz */\n\n            cpu_ppc_tb_init(env, 7812500UL);\n\n        } else {\n\n            /* Set time-base frequency to 100 Mhz */\n\n            cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);\n\n        }\n\n        qemu_register_reset(&cpu_ppc_reset, env);\n\n        envs[i] = env;\n\n    }\n\n\n\n    /* allocate RAM */\n\n    ram_offset = qemu_ram_alloc(ram_size);\n\n    cpu_register_physical_memory(0, ram_size, ram_offset);\n\n\n\n    /* allocate and load BIOS */\n\n    bios_offset = qemu_ram_alloc(BIOS_SIZE);\n\n    if (bios_name == NULL)\n\n        bios_name = BIOS_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    if (filename) {\n\n        bios_size = get_image_size(filename);\n\n    } else {\n\n        bios_size = -1;\n\n    }\n\n    if (bios_size > 0 && bios_size <= BIOS_SIZE) {\n\n        target_phys_addr_t bios_addr;\n\n        bios_size = (bios_size + 0xfff) & ~0xfff;\n\n        bios_addr = (uint32_t)(-bios_size);\n\n        cpu_register_physical_memory(bios_addr, bios_size,\n\n                                     bios_offset | IO_MEM_ROM);\n\n        bios_size = load_image_targphys(filename, bios_addr, bios_size);\n\n    }\n\n    if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n        hw_error(\"qemu: could not load PPC PREP bios '%s'\\n\", bios_name);\n\n    }\n\n    if (filename) {\n\n        qemu_free(filename);\n\n    }\n\n    if (env->nip < 0xFFF80000 && bios_size < 0x00100000) {\n\n        hw_error(\"PowerPC 601 / 620 / 970 need a 1MB BIOS\\n\");\n\n    }\n\n\n\n    if (linux_boot) {\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n        /* now we can load the kernel */\n\n        kernel_size = load_image_targphys(kernel_filename, kernel_base,\n\n                                          ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            hw_error(\"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                hw_error(\"qemu: could not load initial ram disk '%s'\\n\",\n\n                          initrd_filename);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n        ppc_boot_device = 'm';\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n        ppc_boot_device = '\\0';\n\n        /* For now, OHW cannot boot from the network. */\n\n        for (i = 0; boot_device[i] != '\\0'; i++) {\n\n            if (boot_device[i] >= 'a' && boot_device[i] <= 'f') {\n\n                ppc_boot_device = boot_device[i];\n\n                break;\n\n            }\n\n        }\n\n        if (ppc_boot_device == '\\0') {\n\n            fprintf(stderr, \"No valid boot device for Mac99 machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    isa_mem_base = 0xc0000000;\n\n    if (PPC_INPUT(env) != PPC_FLAGS_INPUT_6xx) {\n\n        hw_error(\"Only 6xx bus is supported on PREP machine\\n\");\n\n    }\n\n    i8259 = i8259_init(first_cpu->irq_inputs[PPC6xx_INPUT_INT]);\n\n    pci_bus = pci_prep_init(i8259);\n\n    /* Hmm, prep has no pci-isa bridge ??? */\n\n    isa_bus_new(NULL);\n\n    isa_bus_irqs(i8259);\n\n    //    pci_bus = i440fx_init();\n\n    /* Register 8 MB of ISA IO space (needed for non-contiguous map) */\n\n    PPC_io_memory = cpu_register_io_memory(PPC_prep_io_read,\n\n                                           PPC_prep_io_write, sysctrl);\n\n    cpu_register_physical_memory(0x80000000, 0x00800000, PPC_io_memory);\n\n\n\n    /* init basic PC hardware */\n\n    pci_vga_init(pci_bus, 0, 0);\n\n    //    openpic = openpic_init(0x00000000, 0xF0000000, 1);\n\n    //    pit = pit_init(0x40, i8259[0]);\n\n    rtc_init(2000);\n\n\n\n    if (serial_hds[0])\n\n        serial_isa_init(0, serial_hds[0]);\n\n    nb_nics1 = nb_nics;\n\n    if (nb_nics1 > NE2000_NB_MAX)\n\n        nb_nics1 = NE2000_NB_MAX;\n\n    for(i = 0; i < nb_nics1; i++) {\n\n        if (nd_table[i].model == NULL) {\n\n\t    nd_table[i].model = \"ne2k_isa\";\n\n        }\n\n        if (strcmp(nd_table[i].model, \"ne2k_isa\") == 0) {\n\n            isa_ne2000_init(ne2000_io[i], ne2000_irq[i], &nd_table[i]);\n\n        } else {\n\n            pci_nic_init(&nd_table[i], \"ne2k_pci\", NULL);\n\n        }\n\n    }\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        hd[i] = drive_get(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);\n\n    }\n\n\n\n    for(i = 0; i < MAX_IDE_BUS; i++) {\n\n        isa_ide_init(ide_iobase[i], ide_iobase2[i], ide_irq[i],\n\n                     hd[2 * i],\n\n\t\t     hd[2 * i + 1]);\n\n    }\n\n    isa_create_simple(\"i8042\");\n\n    DMA_init(1);\n\n    //    SB16_init();\n\n\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        fd[i] = drive_get(IF_FLOPPY, 0, i);\n\n    }\n\n    fdctrl_init_isa(fd);\n\n\n\n    /* Register speaker port */\n\n    register_ioport_read(0x61, 1, 1, speaker_ioport_read, NULL);\n\n    register_ioport_write(0x61, 1, 1, speaker_ioport_write, NULL);\n\n    /* Register fake IO ports for PREP */\n\n    sysctrl->reset_irq = first_cpu->irq_inputs[PPC6xx_INPUT_HRESET];\n\n    register_ioport_read(0x398, 2, 1, &PREP_io_read, sysctrl);\n\n    register_ioport_write(0x398, 2, 1, &PREP_io_write, sysctrl);\n\n    /* System control ports */\n\n    register_ioport_read(0x0092, 0x01, 1, &PREP_io_800_readb, sysctrl);\n\n    register_ioport_write(0x0092, 0x01, 1, &PREP_io_800_writeb, sysctrl);\n\n    register_ioport_read(0x0800, 0x52, 1, &PREP_io_800_readb, sysctrl);\n\n    register_ioport_write(0x0800, 0x52, 1, &PREP_io_800_writeb, sysctrl);\n\n    /* PCI intack location */\n\n    PPC_io_memory = cpu_register_io_memory(PPC_intack_read,\n\n                                           PPC_intack_write, NULL);\n\n    cpu_register_physical_memory(0xBFFFFFF0, 0x4, PPC_io_memory);\n\n    /* PowerPC control and status register group */\n\n#if 0\n\n    PPC_io_memory = cpu_register_io_memory(PPC_XCSR_read, PPC_XCSR_write,\n\n                                           NULL);\n\n    cpu_register_physical_memory(0xFEFF0000, 0x1000, PPC_io_memory);\n\n#endif\n\n\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, -1);\n\n    }\n\n\n\n    m48t59 = m48t59_init(i8259[8], 0, 0x0074, NVRAM_SIZE, 59);\n\n    if (m48t59 == NULL)\n\n        return;\n\n    sysctrl->nvram = m48t59;\n\n\n\n    /* Initialise NVRAM */\n\n    nvram.opaque = m48t59;\n\n    nvram.read_fn = &m48t59_read;\n\n    nvram.write_fn = &m48t59_write;\n\n    PPC_NVRAM_set_params(&nvram, NVRAM_SIZE, \"PREP\", ram_size, ppc_boot_device,\n\n                         kernel_base, kernel_size,\n\n                         kernel_cmdline,\n\n                         initrd_base, initrd_size,\n\n                         /* XXX: need an option to load a NVRAM image */\n\n                         0,\n\n                         graphic_width, graphic_height, graphic_depth);\n\n\n\n    /* Special port to get debug messages from Open-Firmware */\n\n    register_ioport_write(0x0F00, 4, 1, &PPC_debug_write, NULL);\n\n}\n", "idx": 24494}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void glib_pollfds_poll(void)\n\n{\n\n    GMainContext *context = g_main_context_default();\n\n    GPollFD *pfds = &g_array_index(gpollfds, GPollFD, glib_pollfds_idx);\n\n\n\n    if (g_main_context_check(context, max_priority, pfds, glib_n_poll_fds)) {\n\n        g_main_context_dispatch(context);\n\n    }\n\n}\n", "idx": 24498}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int parse_drive(DeviceState *dev, const char *str, void **ptr)\n\n{\n\n    BlockDriverState *bs;\n\n\n\n    bs = bdrv_find(str);\n\n    if (bs == NULL) {\n\n        return -ENOENT;\n\n    }\n\n    if (bdrv_attach_dev(bs, dev) < 0) {\n\n        return -EEXIST;\n\n    }\n\n    *ptr = bs;\n\n    return 0;\n\n}\n", "idx": 24499}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static void hda_audio_exit(HDACodecDevice *hda)\n\n{\n\n    HDAAudioState *a = HDA_AUDIO(hda);\n\n    HDAAudioStream *st;\n\n    int i;\n\n\n\n    dprint(a, 1, \"%s\\n\", __FUNCTION__);\n\n    for (i = 0; i < ARRAY_SIZE(a->st); i++) {\n\n        st = a->st + i;\n\n        if (st->node == NULL) {\n\n            continue;\n\n        }\n\n        if (st->output) {\n\n            AUD_close_out(&a->card, st->voice.out);\n\n        } else {\n\n            AUD_close_in(&a->card, st->voice.in);\n\n        }\n\n    }\n\n    AUD_remove_card(&a->card);\n\n}\n", "idx": 24500}
{"project": "qemu", "commit_id": "bf18bee547d19fde314e7b6b81f21f68b46c8a92", "target": 0, "func": "void qmp_eject(const char *device, bool has_force, bool force, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    int rc;\n\n\n\n    if (!has_force) {\n\n        force = false;\n\n    }\n\n\n\n    rc = do_open_tray(device, force, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    if (rc == EINPROGRESS) {\n\n        error_setg(errp, \"Device '%s' is locked and force was not specified, \"\n\n                   \"wait for tray to open and try again\", device);\n\n        return;\n\n    }\n\n\n\n    qmp_x_blockdev_remove_medium(device, errp);\n\n}\n", "idx": 24501}
{"project": "qemu", "commit_id": "de08c606f9ddafe647b6843e2b10a6d6030b0fc0", "target": 0, "func": "int bdrv_snapshot_list(BlockDriverState *bs,\n\n                       QEMUSnapshotInfo **psn_info)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n    if (drv->bdrv_snapshot_list)\n\n        return drv->bdrv_snapshot_list(bs, psn_info);\n\n    if (bs->file)\n\n        return bdrv_snapshot_list(bs->file, psn_info);\n\n    return -ENOTSUP;\n\n}\n", "idx": 24502}
{"project": "qemu", "commit_id": "23dce3873f3aee6ee7d4a1c17dd26fb5f453bc5a", "target": 0, "func": "static void curl_block_init(void)\n\n{\n\n    bdrv_register(&bdrv_http);\n\n    bdrv_register(&bdrv_https);\n\n    bdrv_register(&bdrv_ftp);\n\n    bdrv_register(&bdrv_ftps);\n\n    bdrv_register(&bdrv_tftp);\n\n}\n", "idx": 24503}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static always_inline void gen_fcmov (void *func,\n\n                                     int ra, int rb, int rc)\n\n{\n\n    int l1;\n\n    TCGv tmp;\n\n\n\n    if (unlikely(rc == 31))\n\n        return;\n\n\n\n    l1 = gen_new_label();\n\n    tmp = tcg_temp_new(TCG_TYPE_I64);\n\n    if (ra != 31) {\n\n        tmp = tcg_temp_new(TCG_TYPE_I64);\n\n        tcg_gen_helper_1_1(func, tmp, cpu_fir[ra]);\n\n    } else  {\n\n        tmp = tcg_const_i64(0);\n\n        tcg_gen_helper_1_1(func, tmp, tmp);\n\n    }\n\n    tcg_gen_brcondi_i64(TCG_COND_EQ, tmp, 0, l1);\n\n    if (rb != 31)\n\n        tcg_gen_mov_i64(cpu_fir[rc], cpu_fir[ra]);\n\n    else\n\n        tcg_gen_movi_i64(cpu_fir[rc], 0);\n\n    gen_set_label(l1);\n\n}\n", "idx": 24504}
{"project": "qemu", "commit_id": "6e0d8677cb443e7408c0b7a25a93c6596d7fa380", "target": 0, "func": "static inline void gen_outs(DisasContext *s, int ot)\n\n{\n\n    gen_string_movl_A0_ESI(s);\n\n    gen_op_ld_T0_A0(ot + s->mem_index);\n\n\n\n    gen_op_mov_TN_reg(OT_WORD, 1, R_EDX);\n\n    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[1]);\n\n    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);\n\n    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);\n\n    tcg_gen_helper_0_2(helper_out_func[ot], cpu_tmp2_i32, cpu_tmp3_i32);\n\n\n\n    gen_op_movl_T0_Dshift[ot]();\n\n#ifdef TARGET_X86_64\n\n    if (s->aflag == 2) {\n\n        gen_op_addq_ESI_T0();\n\n    } else\n\n#endif\n\n    if (s->aflag) {\n\n        gen_op_addl_ESI_T0();\n\n    } else {\n\n        gen_op_addw_ESI_T0();\n\n    }\n\n}\n", "idx": 24505}
{"project": "qemu", "commit_id": "f5b6ffcf2a94337df31e801dd11b34896bd4fe2b", "target": 0, "func": "static void vscsi_command_complete(SCSIRequest *sreq, uint32_t status)\n\n{\n\n    VSCSIState *s = DO_UPCAST(VSCSIState, vdev.qdev, sreq->bus->qbus.parent);\n\n    vscsi_req *req = sreq->hba_private;\n\n    int32_t res_in = 0, res_out = 0;\n\n\n\n    dprintf(\"VSCSI: SCSI cmd complete, r=0x%x tag=0x%x status=0x%x, req=%p\\n\",\n\n            reason, sreq->tag, status, req);\n\n    if (req == NULL) {\n\n        fprintf(stderr, \"VSCSI: Can't find request for tag 0x%x\\n\", sreq->tag);\n\n        return;\n\n    }\n\n\n\n    if (status == CHECK_CONDITION) {\n\n        req->senselen = scsi_req_get_sense(req->sreq, req->sense,\n\n                                           sizeof(req->sense));\n\n        status = 0;\n\n        dprintf(\"VSCSI: Sense data, %d bytes:\\n\", len);\n\n        dprintf(\"       %02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x\\n\",\n\n                req->sense[0], req->sense[1], req->sense[2], req->sense[3],\n\n                req->sense[4], req->sense[5], req->sense[6], req->sense[7]);\n\n        dprintf(\"       %02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x\\n\",\n\n                req->sense[8], req->sense[9], req->sense[10], req->sense[11],\n\n                req->sense[12], req->sense[13], req->sense[14], req->sense[15]);\n\n    }\n\n\n\n    dprintf(\"VSCSI: Command complete err=%d\\n\", status);\n\n    if (status == 0) {\n\n        /* We handle overflows, not underflows for normal commands,\n\n         * but hopefully nobody cares\n\n         */\n\n        if (req->writing) {\n\n            res_out = req->data_len;\n\n        } else {\n\n            res_in = req->data_len;\n\n        }\n\n    }\n\n    vscsi_send_rsp(s, req, status, res_in, res_out);\n\n    vscsi_put_req(req);\n\n}\n", "idx": 24507}
{"project": "qemu", "commit_id": "496272a7018ba01aa2b87a1a5ed866ff85133401", "target": 0, "func": "int check_prot(int prot, int rw, int access_type)\n\n{\n\n    int ret;\n\n\n\n    if (access_type == ACCESS_CODE) {\n\n        if (prot & PAGE_EXEC) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    } else if (rw) {\n\n        if (prot & PAGE_WRITE) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    } else {\n\n        if (prot & PAGE_READ) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 24508}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void virtio_blk_flush_complete(void *opaque, int ret)\n\n{\n\n    VirtIOBlockReq *req = opaque;\n\n\n\n    if (ret) {\n\n        if (virtio_blk_handle_rw_error(req, -ret, 0)) {\n\n            return;\n\n        }\n\n    }\n\n\n\n    virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);\n\n    block_acct_done(bdrv_get_stats(req->dev->bs), &req->acct);\n\n    virtio_blk_free_request(req);\n\n}\n", "idx": 24509}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "void ppc_hw_interrupt (CPUState *env)\n\n{\n\n    env->exception_index = -1;\n\n}\n", "idx": 24510}
{"project": "qemu", "commit_id": "97f90cbfe810bb153fc44bde732d9639610783bb", "target": 0, "func": "static void dec_store(DisasContext *dc)\n\n{\n\n    TCGv t, *addr;\n\n    unsigned int size;\n\n\n\n    size = 1 << (dc->opcode & 3);\n\n\n\n    if (size > 4 && (dc->tb_flags & MSR_EE_FLAG)\n\n          && !(dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)) {\n\n        tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP);\n\n        t_gen_raise_exception(dc, EXCP_HW_EXCP);\n\n        return;\n\n    }\n\n\n\n    LOG_DIS(\"s%d%s\\n\", size, dc->type_b ? \"i\" : \"\");\n\n    t_sync_flags(dc);\n\n    /* If we get a fault on a dslot, the jmpstate better be in sync.  */\n\n    sync_jmpstate(dc);\n\n    addr = compute_ldst_addr(dc, &t);\n\n\n\n    /* Verify alignment if needed.  */\n\n    if ((dc->env->pvr.regs[2] & PVR2_UNALIGNED_EXC_MASK) && size > 1) {\n\n        gen_helper_memalign(*addr, tcg_const_tl(dc->rd),\n\n                            tcg_const_tl(1), tcg_const_tl(size - 1));\n\n    }\n\n\n\n    gen_store(dc, *addr, cpu_R[dc->rd], size);\n\n    if (addr == &t)\n\n        tcg_temp_free(t);\n\n}\n", "idx": 24511}
{"project": "qemu", "commit_id": "e9cf2fe07ff70e939f80c624b44c10a4442eef0b", "target": 0, "func": "void qmp_ringbuf_write(const char *device, const char *data,\n\n                       bool has_format, enum DataFormat format,\n\n                       Error **errp)\n\n{\n\n    CharDriverState *chr;\n\n    const uint8_t *write_data;\n\n    int ret;\n\n    gsize write_count;\n\n\n\n    chr = qemu_chr_find(device);\n\n    if (!chr) {\n\n        error_setg(errp, \"Device '%s' not found\", device);\n\n        return;\n\n    }\n\n\n\n    if (!chr_is_ringbuf(chr)) {\n\n        error_setg(errp,\"%s is not a ringbuf device\", device);\n\n        return;\n\n    }\n\n\n\n    if (has_format && (format == DATA_FORMAT_BASE64)) {\n\n        write_data = g_base64_decode(data, &write_count);\n\n    } else {\n\n        write_data = (uint8_t *)data;\n\n        write_count = strlen(data);\n\n    }\n\n\n\n    ret = ringbuf_chr_write(chr, write_data, write_count);\n\n\n\n    if (write_data != (uint8_t *)data) {\n\n        g_free((void *)write_data);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to write to device %s\", device);\n\n        return;\n\n    }\n\n}\n", "idx": 24512}
{"project": "qemu", "commit_id": "e1c37d0e94048502f9874e6356ce7136d4b05bdb", "target": 0, "func": "int do_migrate(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    MigrationState *s = migrate_get_current();\n\n    const char *p;\n\n    int detach = qdict_get_try_bool(qdict, \"detach\", 0);\n\n    int blk = qdict_get_try_bool(qdict, \"blk\", 0);\n\n    int inc = qdict_get_try_bool(qdict, \"inc\", 0);\n\n    const char *uri = qdict_get_str(qdict, \"uri\");\n\n    int ret;\n\n\n\n    if (s->state == MIG_STATE_ACTIVE) {\n\n        monitor_printf(mon, \"migration already in progress\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (qemu_savevm_state_blocked(mon)) {\n\n        return -1;\n\n    }\n\n\n\n    if (migration_blockers) {\n\n        Error *err = migration_blockers->data;\n\n        qerror_report_err(err);\n\n        return -1;\n\n    }\n\n\n\n    s = migrate_init(mon, detach, blk, inc);\n\n\n\n    if (strstart(uri, \"tcp:\", &p)) {\n\n        ret = tcp_start_outgoing_migration(s, p);\n\n#if !defined(WIN32)\n\n    } else if (strstart(uri, \"exec:\", &p)) {\n\n        ret = exec_start_outgoing_migration(s, p);\n\n    } else if (strstart(uri, \"unix:\", &p)) {\n\n        ret = unix_start_outgoing_migration(s, p);\n\n    } else if (strstart(uri, \"fd:\", &p)) {\n\n        ret = fd_start_outgoing_migration(s, p);\n\n#endif\n\n    } else {\n\n        monitor_printf(mon, \"unknown migration protocol: %s\\n\", uri);\n\n        ret  = -EINVAL;\n\n    }\n\n\n\n    if (ret < 0) {\n\n        monitor_printf(mon, \"migration failed: %s\\n\", strerror(-ret));\n\n        return ret;\n\n    }\n\n\n\n    if (detach) {\n\n        s->mon = NULL;\n\n    }\n\n\n\n    notifier_list_notify(&migration_state_notifiers, s);\n\n    return 0;\n\n}\n", "idx": 24513}
{"project": "qemu", "commit_id": "8360544a6d3a54df1fce80f55ba4ad075a8ded54", "target": 0, "func": "static void qpci_spapr_io_writew(QPCIBus *bus, void *addr, uint16_t value)\n\n{\n\n    QPCIBusSPAPR *s = container_of(bus, QPCIBusSPAPR, bus);\n\n    uint64_t port = (uintptr_t)addr;\n\n    value = bswap16(value);\n\n    if (port < s->pio.size) {\n\n        writew(s->pio_cpu_base + port, value);\n\n    } else {\n\n        writew(s->mmio_cpu_base + port, value);\n\n    }\n\n}\n", "idx": 24514}
{"project": "qemu", "commit_id": "384acbf46b70edf0d2c1648aa1a92a90bcf7057d", "target": 0, "func": "void *laio_init(void)\n\n{\n\n    struct qemu_laio_state *s;\n\n\n\n    s = qemu_mallocz(sizeof(*s));\n\n    QLIST_INIT(&s->completed_reqs);\n\n    s->efd = eventfd(0, 0);\n\n    if (s->efd == -1)\n\n        goto out_free_state;\n\n    fcntl(s->efd, F_SETFL, O_NONBLOCK);\n\n\n\n    if (io_setup(MAX_EVENTS, &s->ctx) != 0)\n\n        goto out_close_efd;\n\n\n\n    qemu_aio_set_fd_handler(s->efd, qemu_laio_completion_cb, NULL,\n\n        qemu_laio_flush_cb, qemu_laio_process_requests, s);\n\n\n\n    return s;\n\n\n\nout_close_efd:\n\n    close(s->efd);\n\nout_free_state:\n\n    qemu_free(s);\n\n    return NULL;\n\n}\n", "idx": 24515}
{"project": "qemu", "commit_id": "dd8070d865ad1b32876931f812a80645f97112ff", "target": 0, "func": "static TileExcp decode_x1(DisasContext *dc, tilegx_bundle_bits bundle)\n\n{\n\n    unsigned opc = get_Opcode_X1(bundle);\n\n    unsigned dest = get_Dest_X1(bundle);\n\n    unsigned srca = get_SrcA_X1(bundle);\n\n    unsigned ext, srcb;\n\n    int imm;\n\n\n\n    switch (opc) {\n\n    case RRR_0_OPCODE_X1:\n\n        ext = get_RRROpcodeExtension_X1(bundle);\n\n        srcb = get_SrcB_X1(bundle);\n\n        switch (ext) {\n\n        case UNARY_RRR_0_OPCODE_X1:\n\n            ext = get_UnaryOpcodeExtension_X1(bundle);\n\n            return gen_rr_opcode(dc, OE(opc, ext, X1), dest, srca);\n\n        case ST1_RRR_0_OPCODE_X1:\n\n            return gen_st_opcode(dc, dest, srca, srcb, MO_UB, \"st1\");\n\n        case ST2_RRR_0_OPCODE_X1:\n\n            return gen_st_opcode(dc, dest, srca, srcb, MO_TEUW, \"st2\");\n\n        case ST4_RRR_0_OPCODE_X1:\n\n            return gen_st_opcode(dc, dest, srca, srcb, MO_TEUL, \"st4\");\n\n        case STNT1_RRR_0_OPCODE_X1:\n\n            return gen_st_opcode(dc, dest, srca, srcb, MO_UB, \"stnt1\");\n\n        case STNT2_RRR_0_OPCODE_X1:\n\n            return gen_st_opcode(dc, dest, srca, srcb, MO_TEUW, \"stnt2\");\n\n        case STNT4_RRR_0_OPCODE_X1:\n\n            return gen_st_opcode(dc, dest, srca, srcb, MO_TEUL, \"stnt4\");\n\n        case STNT_RRR_0_OPCODE_X1:\n\n            return gen_st_opcode(dc, dest, srca, srcb, MO_TEQ, \"stnt\");\n\n        case ST_RRR_0_OPCODE_X1:\n\n            return gen_st_opcode(dc, dest, srca, srcb, MO_TEQ, \"st\");\n\n        }\n\n        return gen_rrr_opcode(dc, OE(opc, ext, X1), dest, srca, srcb);\n\n\n\n    case SHIFT_OPCODE_X1:\n\n        ext = get_ShiftOpcodeExtension_X1(bundle);\n\n        imm = get_ShAmt_X1(bundle);\n\n        return gen_rri_opcode(dc, OE(opc, ext, X1), dest, srca, imm);\n\n\n\n    case IMM8_OPCODE_X1:\n\n        ext = get_Imm8OpcodeExtension_X1(bundle);\n\n        imm = (int8_t)get_Dest_Imm8_X1(bundle);\n\n        srcb = get_SrcB_X1(bundle);\n\n        switch (ext) {\n\n        case ST1_ADD_IMM8_OPCODE_X1:\n\n            return gen_st_add_opcode(dc, srca, srcb, imm, MO_UB, \"st1_add\");\n\n        case ST2_ADD_IMM8_OPCODE_X1:\n\n            return gen_st_add_opcode(dc, srca, srcb, imm, MO_TEUW, \"st2_add\");\n\n        case ST4_ADD_IMM8_OPCODE_X1:\n\n            return gen_st_add_opcode(dc, srca, srcb, imm, MO_TEUL, \"st4_add\");\n\n        case STNT1_ADD_IMM8_OPCODE_X1:\n\n            return gen_st_add_opcode(dc, srca, srcb, imm, MO_UB, \"stnt1_add\");\n\n        case STNT2_ADD_IMM8_OPCODE_X1:\n\n            return gen_st_add_opcode(dc, srca, srcb, imm, MO_TEUW, \"stnt2_add\");\n\n        case STNT4_ADD_IMM8_OPCODE_X1:\n\n            return gen_st_add_opcode(dc, srca, srcb, imm, MO_TEUL, \"stnt4_add\");\n\n        case STNT_ADD_IMM8_OPCODE_X1:\n\n            return gen_st_add_opcode(dc, srca, srcb, imm, MO_TEQ, \"stnt_add\");\n\n        case ST_ADD_IMM8_OPCODE_X1:\n\n            return gen_st_add_opcode(dc, srca, srcb, imm, MO_TEQ, \"st_add\");\n\n        case MFSPR_IMM8_OPCODE_X1:\n\n            return gen_mfspr_x1(dc, dest, get_MF_Imm14_X1(bundle));\n\n        case MTSPR_IMM8_OPCODE_X1:\n\n            return gen_mtspr_x1(dc, get_MT_Imm14_X1(bundle), srca);\n\n        }\n\n        imm = (int8_t)get_Imm8_X1(bundle);\n\n        return gen_rri_opcode(dc, OE(opc, ext, X1), dest, srca, imm);\n\n\n\n    case BRANCH_OPCODE_X1:\n\n        ext = get_BrType_X1(bundle);\n\n        imm = sextract32(get_BrOff_X1(bundle), 0, 17);\n\n        return gen_branch_opcode_x1(dc, ext, srca, imm);\n\n\n\n    case JUMP_OPCODE_X1:\n\n        ext = get_JumpOpcodeExtension_X1(bundle);\n\n        imm = sextract32(get_JumpOff_X1(bundle), 0, 27);\n\n        return gen_jump_opcode_x1(dc, ext, imm);\n\n\n\n    case ADDLI_OPCODE_X1:\n\n    case SHL16INSLI_OPCODE_X1:\n\n    case ADDXLI_OPCODE_X1:\n\n        imm = (int16_t)get_Imm16_X1(bundle);\n\n        return gen_rri_opcode(dc, OE(opc, 0, X1), dest, srca, imm);\n\n\n\n    default:\n\n        return TILEGX_EXCP_OPCODE_UNIMPLEMENTED;\n\n    }\n\n}\n", "idx": 24516}
{"project": "qemu", "commit_id": "cc05c43ad942165ecc6ffd39e41991bee43af044", "target": 1, "func": "static bool memory_region_dispatch_write(MemoryRegion *mr,\n\n                                         hwaddr addr,\n\n                                         uint64_t data,\n\n                                         unsigned size)\n\n{\n\n    if (!memory_region_access_valid(mr, addr, size, true)) {\n\n        unassigned_mem_write(mr, addr, data, size);\n\n        return true;\n\n    }\n\n\n\n    adjust_endianness(mr, &data, size);\n\n\n\n    if (mr->ops->write) {\n\n        access_with_adjusted_size(addr, &data, size,\n\n                                  mr->ops->impl.min_access_size,\n\n                                  mr->ops->impl.max_access_size,\n\n                                  memory_region_write_accessor, mr);\n\n    } else {\n\n        access_with_adjusted_size(addr, &data, size, 1, 4,\n\n                                  memory_region_oldmmio_write_accessor, mr);\n\n    }\n\n    return false;\n\n}\n", "idx": 24523}
{"project": "qemu", "commit_id": "c572f23a3e7180dbeab5e86583e43ea2afed6271", "target": 1, "func": "static void complete_pdu(V9fsState *s, V9fsPDU *pdu, ssize_t len)\n\n{\n\n    int8_t id = pdu->id + 1; /* Response */\n\n\n\n    if (len < 0) {\n\n        int err = -len;\n\n        len = 7;\n\n\n\n        if (s->proto_version != V9FS_PROTO_2000L) {\n\n            V9fsString str;\n\n\n\n            str.data = strerror(err);\n\n            str.size = strlen(str.data);\n\n\n\n            len += pdu_marshal(pdu, len, \"s\", &str);\n\n            id = P9_RERROR;\n\n        }\n\n\n\n        len += pdu_marshal(pdu, len, \"d\", err);\n\n\n\n        if (s->proto_version == V9FS_PROTO_2000L) {\n\n            id = P9_RLERROR;\n\n        }\n\n\n    }\n\n\n\n    /* fill out the header */\n\n    pdu_marshal(pdu, 0, \"dbw\", (int32_t)len, id, pdu->tag);\n\n\n\n    /* keep these in sync */\n\n    pdu->size = len;\n\n    pdu->id = id;\n\n\n\n    /* push onto queue and notify */\n\n    virtqueue_push(s->vq, &pdu->elem, len);\n\n\n\n    /* FIXME: we should batch these completions */\n\n    virtio_notify(&s->vdev, s->vq);\n\n\n\n    /* Now wakeup anybody waiting in flush for this request */\n\n    qemu_co_queue_next(&pdu->complete);\n\n\n\n    free_pdu(s, pdu);\n\n}", "idx": 24525}
{"project": "qemu", "commit_id": "fe0bd475aa31e60674f7f53b85dc293108026202", "target": 1, "func": "static void gen_rsr(DisasContext *dc, TCGv_i32 d, uint32_t sr)\n\n{\n\n    static void (* const rsr_handler[256])(DisasContext *dc,\n\n            TCGv_i32 d, uint32_t sr) = {\n\n        [CCOUNT] = gen_rsr_ccount,\n\n        [PTEVADDR] = gen_rsr_ptevaddr,\n\n    };\n\n\n\n    if (sregnames[sr]) {\n\n        if (rsr_handler[sr]) {\n\n            rsr_handler[sr](dc, d, sr);\n\n        } else {\n\n            tcg_gen_mov_i32(d, cpu_SR[sr]);\n\n        }\n\n    } else {\n\n        qemu_log(\"RSR %d not implemented, \", sr);\n\n    }\n\n}\n", "idx": 24526}
{"project": "qemu", "commit_id": "5b185639c5740998de403415c749ac98e13418fd", "target": 1, "func": "static inline uint64_t cksm_overflow(uint64_t cksm)\n\n{\n\n    if (cksm > 0xffffffffULL) {\n\n        cksm &= 0xffffffffULL;\n\n        cksm++;\n\n    }\n\n    return cksm;\n\n}\n", "idx": 24527}
{"project": "qemu", "commit_id": "540c79fec9e8b6a6582ec4c65aa2c4c5366e4b89", "target": 1, "func": "int tcp_start_outgoing_migration(MigrationState *s, const char *host_port,\n\n                                 Error **errp)\n\n{\n\n    s->get_error = socket_errno;\n\n    s->write = socket_write;\n\n    s->close = tcp_close;\n\n\n\n    s->fd = inet_connect(host_port, false, NULL, errp);\n\n\n\n    if (!error_is_set(errp)) {\n\n        migrate_fd_connect(s);\n\n    } else if (error_is_type(*errp, QERR_SOCKET_CONNECT_IN_PROGRESS)) {\n\n        DPRINTF(\"connect in progress\\n\");\n\n        qemu_set_fd_handler2(s->fd, NULL, NULL, tcp_wait_for_connect, s);\n\n    } else if (error_is_type(*errp, QERR_SOCKET_CREATE_FAILED)) {\n\n        DPRINTF(\"connect failed\\n\");\n\n        return -1;\n\n    } else if (error_is_type(*errp, QERR_SOCKET_CONNECT_FAILED)) {\n\n        DPRINTF(\"connect failed\\n\");\n\n        migrate_fd_error(s);\n\n        return -1;\n\n    } else {\n\n        DPRINTF(\"unknown error\\n\");\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24528}
{"project": "qemu", "commit_id": "4be23939ab0d7019c7e59a37485b416fbbf0f073", "target": 1, "func": "static void ehci_advance_async_state(EHCIState *ehci)\n\n{\n\n    const int async = 1;\n\n\n\n    switch(ehci_get_state(ehci, async)) {\n\n    case EST_INACTIVE:\n\n        if (!(ehci->usbcmd & USBCMD_ASE)) {\n\n            break;\n\n        }\n\n        ehci_set_usbsts(ehci, USBSTS_ASS);\n\n        ehci_set_state(ehci, async, EST_ACTIVE);\n\n        // No break, fall through to ACTIVE\n\n\n\n    case EST_ACTIVE:\n\n        if ( !(ehci->usbcmd & USBCMD_ASE)) {\n\n            ehci_clear_usbsts(ehci, USBSTS_ASS);\n\n            ehci_set_state(ehci, async, EST_INACTIVE);\n\n            break;\n\n        }\n\n\n\n        /* If the doorbell is set, the guest wants to make a change to the\n\n         * schedule. The host controller needs to release cached data.\n\n         * (section 4.8.2)\n\n         */\n\n        if (ehci->usbcmd & USBCMD_IAAD) {\n\n            DPRINTF(\"ASYNC: doorbell request acknowledged\\n\");\n\n            ehci->usbcmd &= ~USBCMD_IAAD;\n\n            ehci_set_interrupt(ehci, USBSTS_IAA);\n\n            break;\n\n        }\n\n\n\n        /* make sure guest has acknowledged */\n\n        /* TO-DO: is this really needed? */\n\n        if (ehci->usbsts & USBSTS_IAA) {\n\n            DPRINTF(\"IAA status bit still set.\\n\");\n\n            break;\n\n        }\n\n\n\n        /* check that address register has been set */\n\n        if (ehci->asynclistaddr == 0) {\n\n            break;\n\n        }\n\n\n\n        ehci_set_state(ehci, async, EST_WAITLISTHEAD);\n\n        ehci_advance_state(ehci, async);\n\n        break;\n\n\n\n    default:\n\n        /* this should only be due to a developer mistake */\n\n        fprintf(stderr, \"ehci: Bad asynchronous state %d. \"\n\n                \"Resetting to active\\n\", ehci->astate);\n\n        assert(0);\n\n    }\n\n}\n", "idx": 24530}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(subfeo)\n\n{\n\n    do_subfeo();\n\n    RETURN();\n\n}\n", "idx": 24532}
{"project": "qemu", "commit_id": "fafc0b6afed9d913ddbcd2da87e5d39da9bf04c5", "target": 1, "func": "int kvm_arch_get_registers(CPUState *env)\n\n{\n\n    struct kvm_regs regs;\n\n    struct kvm_sregs sregs;\n\n    uint32_t cr;\n\n    int i, ret;\n\n\n\n    ret = kvm_vcpu_ioctl(env, KVM_GET_REGS, &regs);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    cr = regs.cr;\n\n    for (i = 7; i >= 0; i--) {\n\n        env->crf[i] = cr & 15;\n\n        cr >>= 4;\n\n    }\n\n\n\n    env->ctr = regs.ctr;\n\n    env->lr = regs.lr;\n\n    env->xer = regs.xer;\n\n    env->msr = regs.msr;\n\n    env->nip = regs.pc;\n\n\n\n    env->spr[SPR_SRR0] = regs.srr0;\n\n    env->spr[SPR_SRR1] = regs.srr1;\n\n\n\n    env->spr[SPR_SPRG0] = regs.sprg0;\n\n    env->spr[SPR_SPRG1] = regs.sprg1;\n\n    env->spr[SPR_SPRG2] = regs.sprg2;\n\n    env->spr[SPR_SPRG3] = regs.sprg3;\n\n    env->spr[SPR_SPRG4] = regs.sprg4;\n\n    env->spr[SPR_SPRG5] = regs.sprg5;\n\n    env->spr[SPR_SPRG6] = regs.sprg6;\n\n    env->spr[SPR_SPRG7] = regs.sprg7;\n\n\n\n    env->spr[SPR_BOOKE_PID] = regs.pid;\n\n\n\n    for (i = 0;i < 32; i++)\n\n        env->gpr[i] = regs.gpr[i];\n\n\n\n#ifdef KVM_CAP_PPC_BOOKE_SREGS\n\n    if (cap_booke_sregs) {\n\n        ret = kvm_vcpu_ioctl(env, KVM_GET_SREGS, &sregs);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        if (sregs.u.e.features & KVM_SREGS_E_BASE) {\n\n            env->spr[SPR_BOOKE_CSRR0] = sregs.u.e.csrr0;\n\n            env->spr[SPR_BOOKE_CSRR1] = sregs.u.e.csrr1;\n\n            env->spr[SPR_BOOKE_ESR] = sregs.u.e.esr;\n\n            env->spr[SPR_BOOKE_DEAR] = sregs.u.e.dear;\n\n            env->spr[SPR_BOOKE_MCSR] = sregs.u.e.mcsr;\n\n            env->spr[SPR_BOOKE_TSR] = sregs.u.e.tsr;\n\n            env->spr[SPR_BOOKE_TCR] = sregs.u.e.tcr;\n\n            env->spr[SPR_DECR] = sregs.u.e.dec;\n\n            env->spr[SPR_TBL] = sregs.u.e.tb & 0xffffffff;\n\n            env->spr[SPR_TBU] = sregs.u.e.tb >> 32;\n\n            env->spr[SPR_VRSAVE] = sregs.u.e.vrsave;\n\n        }\n\n\n\n        if (sregs.u.e.features & KVM_SREGS_E_ARCH206) {\n\n            env->spr[SPR_BOOKE_PIR] = sregs.u.e.pir;\n\n            env->spr[SPR_BOOKE_MCSRR0] = sregs.u.e.mcsrr0;\n\n            env->spr[SPR_BOOKE_MCSRR1] = sregs.u.e.mcsrr1;\n\n            env->spr[SPR_BOOKE_DECAR] = sregs.u.e.decar;\n\n            env->spr[SPR_BOOKE_IVPR] = sregs.u.e.ivpr;\n\n        }\n\n\n\n        if (sregs.u.e.features & KVM_SREGS_E_64) {\n\n            env->spr[SPR_BOOKE_EPCR] = sregs.u.e.epcr;\n\n        }\n\n\n\n        if (sregs.u.e.features & KVM_SREGS_E_SPRG8) {\n\n            env->spr[SPR_BOOKE_SPRG8] = sregs.u.e.sprg8;\n\n        }\n\n\n\n        if (sregs.u.e.features & KVM_SREGS_E_IVOR) {\n\n            env->spr[SPR_BOOKE_IVOR0] = sregs.u.e.ivor_low[0];\n\n            env->spr[SPR_BOOKE_IVOR1] = sregs.u.e.ivor_low[1];\n\n            env->spr[SPR_BOOKE_IVOR2] = sregs.u.e.ivor_low[2];\n\n            env->spr[SPR_BOOKE_IVOR3] = sregs.u.e.ivor_low[3];\n\n            env->spr[SPR_BOOKE_IVOR4] = sregs.u.e.ivor_low[4];\n\n            env->spr[SPR_BOOKE_IVOR5] = sregs.u.e.ivor_low[5];\n\n            env->spr[SPR_BOOKE_IVOR6] = sregs.u.e.ivor_low[6];\n\n            env->spr[SPR_BOOKE_IVOR7] = sregs.u.e.ivor_low[7];\n\n            env->spr[SPR_BOOKE_IVOR8] = sregs.u.e.ivor_low[8];\n\n            env->spr[SPR_BOOKE_IVOR9] = sregs.u.e.ivor_low[9];\n\n            env->spr[SPR_BOOKE_IVOR10] = sregs.u.e.ivor_low[10];\n\n            env->spr[SPR_BOOKE_IVOR11] = sregs.u.e.ivor_low[11];\n\n            env->spr[SPR_BOOKE_IVOR12] = sregs.u.e.ivor_low[12];\n\n            env->spr[SPR_BOOKE_IVOR13] = sregs.u.e.ivor_low[13];\n\n            env->spr[SPR_BOOKE_IVOR14] = sregs.u.e.ivor_low[14];\n\n            env->spr[SPR_BOOKE_IVOR15] = sregs.u.e.ivor_low[15];\n\n\n\n            if (sregs.u.e.features & KVM_SREGS_E_SPE) {\n\n                env->spr[SPR_BOOKE_IVOR32] = sregs.u.e.ivor_high[0];\n\n                env->spr[SPR_BOOKE_IVOR33] = sregs.u.e.ivor_high[1];\n\n                env->spr[SPR_BOOKE_IVOR34] = sregs.u.e.ivor_high[2];\n\n            }\n\n\n\n            if (sregs.u.e.features & KVM_SREGS_E_PM) {\n\n                env->spr[SPR_BOOKE_IVOR35] = sregs.u.e.ivor_high[3];\n\n            }\n\n\n\n            if (sregs.u.e.features & KVM_SREGS_E_PC) {\n\n                env->spr[SPR_BOOKE_IVOR36] = sregs.u.e.ivor_high[4];\n\n                env->spr[SPR_BOOKE_IVOR37] = sregs.u.e.ivor_high[5];\n\n            }\n\n        }\n\n\n\n        if (sregs.u.e.features & KVM_SREGS_E_ARCH206_MMU) {\n\n            env->spr[SPR_BOOKE_MAS0] = sregs.u.e.mas0;\n\n            env->spr[SPR_BOOKE_MAS1] = sregs.u.e.mas1;\n\n            env->spr[SPR_BOOKE_MAS2] = sregs.u.e.mas2;\n\n            env->spr[SPR_BOOKE_MAS3] = sregs.u.e.mas7_3 & 0xffffffff;\n\n            env->spr[SPR_BOOKE_MAS4] = sregs.u.e.mas4;\n\n            env->spr[SPR_BOOKE_MAS6] = sregs.u.e.mas6;\n\n            env->spr[SPR_BOOKE_MAS7] = sregs.u.e.mas7_3 >> 32;\n\n            env->spr[SPR_MMUCFG] = sregs.u.e.mmucfg;\n\n            env->spr[SPR_BOOKE_TLB0CFG] = sregs.u.e.tlbcfg[0];\n\n            env->spr[SPR_BOOKE_TLB1CFG] = sregs.u.e.tlbcfg[1];\n\n        }\n\n\n\n        if (sregs.u.e.features & KVM_SREGS_EXP) {\n\n            env->spr[SPR_BOOKE_EPR] = sregs.u.e.epr;\n\n        }\n\n\n\n        if (sregs.u.e.features & KVM_SREGS_E_PD) {\n\n            env->spr[SPR_BOOKE_EPLC] = sregs.u.e.eplc;\n\n            env->spr[SPR_BOOKE_EPSC] = sregs.u.e.epsc;\n\n        }\n\n\n\n        if (sregs.u.e.impl_id == KVM_SREGS_E_IMPL_FSL) {\n\n            env->spr[SPR_E500_SVR] = sregs.u.e.impl.fsl.svr;\n\n            env->spr[SPR_Exxx_MCAR] = sregs.u.e.impl.fsl.mcar;\n\n            env->spr[SPR_HID0] = sregs.u.e.impl.fsl.hid0;\n\n\n\n            if (sregs.u.e.impl.fsl.features & KVM_SREGS_E_FSL_PIDn) {\n\n                env->spr[SPR_BOOKE_PID1] = sregs.u.e.impl.fsl.pid1;\n\n                env->spr[SPR_BOOKE_PID2] = sregs.u.e.impl.fsl.pid2;\n\n            }\n\n        }\n\n    }\n\n#endif\n\n\n\n#ifdef KVM_CAP_PPC_SEGSTATE\n\n    if (cap_segstate) {\n\n        ret = kvm_vcpu_ioctl(env, KVM_GET_SREGS, &sregs);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        ppc_store_sdr1(env, sregs.u.s.sdr1);\n\n\n\n        /* Sync SLB */\n\n#ifdef TARGET_PPC64\n\n        for (i = 0; i < 64; i++) {\n\n            ppc_store_slb(env, sregs.u.s.ppc64.slb[i].slbe,\n\n                               sregs.u.s.ppc64.slb[i].slbv);\n\n        }\n\n#endif\n\n\n\n        /* Sync SRs */\n\n        for (i = 0; i < 16; i++) {\n\n            env->sr[i] = sregs.u.s.ppc32.sr[i];\n\n        }\n\n\n\n        /* Sync BATs */\n\n        for (i = 0; i < 8; i++) {\n\n            env->DBAT[0][i] = sregs.u.s.ppc32.dbat[i] & 0xffffffff;\n\n            env->DBAT[1][i] = sregs.u.s.ppc32.dbat[i] >> 32;\n\n            env->IBAT[0][i] = sregs.u.s.ppc32.ibat[i] & 0xffffffff;\n\n            env->IBAT[1][i] = sregs.u.s.ppc32.ibat[i] >> 32;\n\n        }\n\n    }\n\n#endif\n\n\n\n    return 0;\n\n}\n", "idx": 24533}
{"project": "qemu", "commit_id": "0fbf50b6ec126600dca115adb1563c657cc27695", "target": 1, "func": "static void pci_bus_init(PCIBus *bus, DeviceState *parent,\n\n                         const char *name,\n\n                         MemoryRegion *address_space_mem,\n\n                         MemoryRegion *address_space_io,\n\n                         uint8_t devfn_min)\n\n{\n\n    assert(PCI_FUNC(devfn_min) == 0);\n\n    bus->devfn_min = devfn_min;\n\n    bus->address_space_mem = address_space_mem;\n\n    bus->address_space_io = address_space_io;\n\n\n\n\n\n    memory_region_init_io(&bus->master_abort_mem, OBJECT(bus),\n\n                          &master_abort_mem_ops, bus, \"pci-master-abort\",\n\n                          memory_region_size(bus->address_space_mem));\n\n    memory_region_add_subregion_overlap(bus->address_space_mem,\n\n                                        0, &bus->master_abort_mem,\n\n                                        MASTER_ABORT_MEM_PRIORITY);\n\n\n\n    /* host bridge */\n\n    QLIST_INIT(&bus->child);\n\n\n\n    pci_host_bus_register(bus, parent);\n\n\n\n    vmstate_register(NULL, -1, &vmstate_pcibus, bus);\n\n}\n", "idx": 24534}
{"project": "qemu", "commit_id": "e3442099a2794925dfbe83711cd204caf80eae60", "target": 1, "func": "void qmp_change_blockdev(const char *device, const char *filename,\n\n                         const char *format, Error **errp)\n\n{\n\n    BlockBackend *blk;\n\n    BlockDriverState *bs;\n\n    BlockDriver *drv = NULL;\n\n    int bdrv_flags;\n\n    Error *err = NULL;\n\n\n\n    blk = blk_by_name(device);\n\n    if (!blk) {\n\n        error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n\n        return;\n\n    }\n\n    bs = blk_bs(blk);\n\n\n\n    if (format) {\n\n        drv = bdrv_find_whitelisted_format(format, bs->read_only);\n\n        if (!drv) {\n\n            error_set(errp, QERR_INVALID_BLOCK_FORMAT, format);\n\n            return;\n\n        }\n\n    }\n\n\n\n    eject_device(blk, 0, &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n\n\n    bdrv_flags = bdrv_is_read_only(bs) ? 0 : BDRV_O_RDWR;\n\n    bdrv_flags |= bdrv_is_snapshot(bs) ? BDRV_O_SNAPSHOT : 0;\n\n\n\n    qmp_bdrv_open_encrypted(bs, filename, bdrv_flags, drv, NULL, errp);\n\n}\n", "idx": 24535}
{"project": "qemu", "commit_id": "3604a76fea6ff37738d4a8f596be38407be74a83", "target": 1, "func": "static void dec_sexth(DisasContext *dc)\n\n{\n\n    LOG_DIS(\"sexth r%d, r%d\\n\", dc->r2, dc->r0);\n\n\n\n    if (!(dc->env->features & LM32_FEATURE_SIGN_EXTEND)) {\n\n        cpu_abort(dc->env, \"hardware sign extender is not available\\n\");\n\n    }\n\n\n\n    tcg_gen_ext16s_tl(cpu_R[dc->r2], cpu_R[dc->r0]);\n\n}\n", "idx": 24539}
{"project": "qemu", "commit_id": "4545d4f4af8b29ba3b38dfb74d6f45342e15a62d", "target": 1, "func": "static int vmdk_write_extent(VmdkExtent *extent, int64_t cluster_offset,\n\n                            int64_t offset_in_cluster, QEMUIOVector *qiov,\n\n                            uint64_t qiov_offset, uint64_t n_bytes,\n\n                            uint64_t offset)\n\n{\n\n    int ret;\n\n    VmdkGrainMarker *data = NULL;\n\n    uLongf buf_len;\n\n    QEMUIOVector local_qiov;\n\n    struct iovec iov;\n\n    int64_t write_offset;\n\n    int64_t write_end_sector;\n\n\n\n    if (extent->compressed) {\n\n        void *compressed_data;\n\n\n\n        if (!extent->has_marker) {\n\n            ret = -EINVAL;\n\n            goto out;\n\n        }\n\n        buf_len = (extent->cluster_sectors << 9) * 2;\n\n        data = g_malloc(buf_len + sizeof(VmdkGrainMarker));\n\n\n\n        compressed_data = g_malloc(n_bytes);\n\n        qemu_iovec_to_buf(qiov, qiov_offset, compressed_data, n_bytes);\n\n        ret = compress(data->data, &buf_len, compressed_data, n_bytes);\n\n        g_free(compressed_data);\n\n\n\n        if (ret != Z_OK || buf_len == 0) {\n\n            ret = -EINVAL;\n\n            goto out;\n\n        }\n\n\n\n        data->lba = offset >> BDRV_SECTOR_BITS;\n\n        data->size = buf_len;\n\n\n\n        n_bytes = buf_len + sizeof(VmdkGrainMarker);\n\n        iov = (struct iovec) {\n\n            .iov_base   = data,\n\n            .iov_len    = n_bytes,\n\n        };\n\n        qemu_iovec_init_external(&local_qiov, &iov, 1);\n\n    } else {\n\n        qemu_iovec_init(&local_qiov, qiov->niov);\n\n        qemu_iovec_concat(&local_qiov, qiov, qiov_offset, n_bytes);\n\n    }\n\n\n\n    write_offset = cluster_offset + offset_in_cluster,\n\n    ret = bdrv_co_pwritev(extent->file, write_offset, n_bytes,\n\n                          &local_qiov, 0);\n\n\n\n    write_end_sector = DIV_ROUND_UP(write_offset + n_bytes, BDRV_SECTOR_SIZE);\n\n\n\n    if (extent->compressed) {\n\n        extent->next_cluster_sector = write_end_sector;\n\n    } else {\n\n        extent->next_cluster_sector = MAX(extent->next_cluster_sector,\n\n                                          write_end_sector);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n    ret = 0;\n\n out:\n\n    g_free(data);\n\n    if (!extent->compressed) {\n\n        qemu_iovec_destroy(&local_qiov);\n\n    }\n\n    return ret;\n\n}\n", "idx": 24540}
{"project": "qemu", "commit_id": "3baf720e6b920d583ce2834d05e5a4e9603a1d56", "target": 1, "func": "static int cdrom_probe_device(const char *filename)\n\n{\n\n    if (strstart(filename, \"/dev/cd\", NULL))\n\n        return 100;\n\n    return 0;\n\n}\n", "idx": 24543}
{"project": "qemu", "commit_id": "937470bb5470825e781ae50e92ff973a6b54d80f", "target": 1, "func": "static int qio_channel_socket_listen_worker(QIOTask *task,\n\n                                            Error **errp,\n\n                                            gpointer opaque)\n\n{\n\n    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(qio_task_get_source(task));\n\n    SocketAddress *addr = opaque;\n\n    int ret;\n\n\n\n    ret = qio_channel_socket_listen_sync(ioc,\n\n                                         addr,\n\n                                         errp);\n\n\n\n    object_unref(OBJECT(ioc));\n\n    return ret;\n\n}\n", "idx": 24544}
{"project": "qemu", "commit_id": "f1710638edb2e98008c2a733ffda63ef32b50411", "target": 1, "func": "QCryptoHmac *qcrypto_hmac_new(QCryptoHashAlgorithm alg,\n\n                              const uint8_t *key, size_t nkey,\n\n                              Error **errp)\n\n{\n\n    QCryptoHmac *hmac;\n\n    void *ctx = NULL;\n\n    Error *err2 = NULL;\n\n    QCryptoHmacDriver *drv = NULL;\n\n\n\n#ifdef CONFIG_AF_ALG\n\n    ctx = qcrypto_afalg_hmac_ctx_new(alg, key, nkey, &err2);\n\n    if (ctx) {\n\n        drv = &qcrypto_hmac_afalg_driver;\n\n    }\n\n#endif\n\n\n\n    if (!ctx) {\n\n        ctx = qcrypto_hmac_ctx_new(alg, key, nkey, errp);\n\n        if (!ctx) {\n\n            return NULL;\n\n        }\n\n\n\n        drv = &qcrypto_hmac_lib_driver;\n\n        error_free(err2);\n\n    }\n\n\n\n    hmac = g_new0(QCryptoHmac, 1);\n\n    hmac->alg = alg;\n\n    hmac->opaque = ctx;\n\n    hmac->driver = (void *)drv;\n\n\n\n    return hmac;\n\n}\n", "idx": 24546}
{"project": "qemu", "commit_id": "f2ad97ff81da51c064b9e87720ff48a0874f45d4", "target": 1, "func": "static USBPort *xhci_lookup_uport(XHCIState *xhci, uint32_t *slot_ctx)\n\n{\n\n    USBPort *uport;\n\n    char path[32];\n\n    int i, pos, port;\n\n\n\n    port = (slot_ctx[1]>>16) & 0xFF;\n\n\n\n\n    port = xhci->ports[port-1].uport->index+1;\n\n    pos = snprintf(path, sizeof(path), \"%d\", port);\n\n    for (i = 0; i < 5; i++) {\n\n        port = (slot_ctx[0] >> 4*i) & 0x0f;\n\n        if (!port) {\n\n            break;\n\n\n        pos += snprintf(path + pos, sizeof(path) - pos, \".%d\", port);\n\n\n\n\n    QTAILQ_FOREACH(uport, &xhci->bus.used, next) {\n\n        if (strcmp(uport->path, path) == 0) {\n\n            return uport;\n\n\n\n", "idx": 24547}
{"project": "qemu", "commit_id": "2b316774f60291f57ca9ecb6a9f0712c532cae34", "target": 1, "func": "static void io_watch_poll_finalize(GSource *source)\n\n{\n\n    IOWatchPoll *iwp = io_watch_poll_from_source(source);\n\n    if (iwp->src) {\n\n        g_source_destroy(iwp->src);\n\n        g_source_unref(iwp->src);\n\n        iwp->src = NULL;\n\n    }\n\n}\n", "idx": 24548}
{"project": "qemu", "commit_id": "25ba3a681213390e9212dbc987d61843c3b41d5b", "target": 1, "func": "target_ulong do_load_msr (CPUPPCState *env)\n\n{\n\n    return\n\n#if defined (TARGET_PPC64)\n\n        ((target_ulong)msr_sf   << MSR_SF)   |\n\n        ((target_ulong)msr_isf  << MSR_ISF)  |\n\n        ((target_ulong)msr_hv   << MSR_HV)   |\n\n#endif\n\n        ((target_ulong)msr_ucle << MSR_UCLE) |\n\n        ((target_ulong)msr_vr   << MSR_VR)   | /* VR / SPE */\n\n        ((target_ulong)msr_ap   << MSR_AP)   |\n\n        ((target_ulong)msr_sa   << MSR_SA)   |\n\n        ((target_ulong)msr_key  << MSR_KEY)  |\n\n        ((target_ulong)msr_pow  << MSR_POW)  | /* POW / WE */\n\n        ((target_ulong)msr_tgpr << MSR_TGPR) | /* TGPR / CE */\n\n        ((target_ulong)msr_ile  << MSR_ILE)  |\n\n        ((target_ulong)msr_ee   << MSR_EE)   |\n\n        ((target_ulong)msr_pr   << MSR_PR)   |\n\n        ((target_ulong)msr_fp   << MSR_FP)   |\n\n        ((target_ulong)msr_me   << MSR_ME)   |\n\n        ((target_ulong)msr_fe0  << MSR_FE0)  |\n\n        ((target_ulong)msr_se   << MSR_SE)   | /* SE / DWE / UBLE */\n\n        ((target_ulong)msr_be   << MSR_BE)   | /* BE / DE */\n\n        ((target_ulong)msr_fe1  << MSR_FE1)  |\n\n        ((target_ulong)msr_al   << MSR_AL)   |\n\n        ((target_ulong)msr_ip   << MSR_IP)   |\n\n        ((target_ulong)msr_ir   << MSR_IR)   | /* IR / IS */\n\n        ((target_ulong)msr_dr   << MSR_DR)   | /* DR / DS */\n\n        ((target_ulong)msr_pe   << MSR_PE)   | /* PE / EP */\n\n        ((target_ulong)msr_px   << MSR_PX)   | /* PX / PMM */\n\n        ((target_ulong)msr_ri   << MSR_RI)   |\n\n        ((target_ulong)msr_le   << MSR_LE);\n\n}\n", "idx": 24549}
{"project": "qemu", "commit_id": "778358d0a8f74a76488daea3c1b6fb327d8135b4", "target": 1, "func": "bool desc_ring_set_size(DescRing *ring, uint32_t size)\n\n{\n\n    int i;\n\n\n\n    if (size < 2 || size > 0x10000 || (size & (size - 1))) {\n\n        DPRINTF(\"ERROR: ring[%d] size (%d) not a power of 2 \"\n\n                \"or in range [2, 64K]\\n\", ring->index, size);\n\n        return false;\n\n    }\n\n\n\n    for (i = 0; i < ring->size; i++) {\n\n        g_free(ring->info[i].buf);\n\n    }\n\n\n\n    ring->size = size;\n\n    ring->head = ring->tail = 0;\n\n\n\n    ring->info = g_realloc(ring->info, size * sizeof(DescInfo));\n\n    if (!ring->info) {\n\n        return false;\n\n    }\n\n\n\n    memset(ring->info, 0, size * sizeof(DescInfo));\n\n\n\n    for (i = 0; i < size; i++) {\n\n        ring->info[i].ring = ring;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 24551}
{"project": "qemu", "commit_id": "2db59a76c421cdd1039d10e32a9798952d3ff5ba", "target": 1, "func": "static void gen_wsr_windowstart(DisasContext *dc, uint32_t sr, TCGv_i32 v)\n\n{\n\n    tcg_gen_andi_i32(cpu_SR[sr], v, (1 << dc->config->nareg / 4) - 1);\n\n    reset_used_window(dc);\n\n}\n", "idx": 24552}
{"project": "qemu", "commit_id": "fe121b9d3c4258e41f7efa4976bf79151b2d5dbb", "target": 1, "func": "static void qemu_laio_process_completion(struct qemu_laiocb *laiocb)\n\n{\n\n    int ret;\n\n\n\n    ret = laiocb->ret;\n\n    if (ret != -ECANCELED) {\n\n        if (ret == laiocb->nbytes) {\n\n            ret = 0;\n\n        } else if (ret >= 0) {\n\n            /* Short reads mean EOF, pad with zeros. */\n\n            if (laiocb->is_read) {\n\n                qemu_iovec_memset(laiocb->qiov, ret, 0,\n\n                    laiocb->qiov->size - ret);\n\n            } else {\n\n                ret = -ENOSPC;\n\n            }\n\n        }\n\n    }\n\n\n\n    laiocb->ret = ret;\n\n    if (laiocb->co) {\n\n        /* Jump and continue completion for foreign requests, don't do\n\n         * anything for current request, it will be completed shortly. */\n\n        if (laiocb->co != qemu_coroutine_self()) {\n\n            qemu_coroutine_enter(laiocb->co);\n\n        }\n\n    } else {\n\n        laiocb->common.cb(laiocb->common.opaque, ret);\n\n        qemu_aio_unref(laiocb);\n\n    }\n\n}\n", "idx": 24553}
{"project": "qemu", "commit_id": "76f5159d7fc4cdea9574dfbb54307735b280bc66", "target": 1, "func": "static uint32_t msix_mmio_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    PCIDevice *dev = opaque;\n\n    unsigned int offset = addr & (MSIX_PAGE_SIZE - 1);\n\n    void *page = dev->msix_table_page;\n\n    uint32_t val = 0;\n\n\n\n    memcpy(&val, (void *)((char *)page + offset), 4);\n\n\n\n    return val;\n\n}\n", "idx": 24554}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static int get_monitor_def(target_long *pval, const char *name)\n\n{\n\n    const MonitorDef *md;\n\n    void *ptr;\n\n\n\n    for(md = monitor_defs; md->name != NULL; md++) {\n\n        if (compare_cmd(name, md->name)) {\n\n            if (md->get_value) {\n\n                *pval = md->get_value(md, md->offset);\n\n            } else {\n\n                CPUState *env = mon_get_cpu();\n\n                if (!env)\n\n                    return -2;\n\n                ptr = (uint8_t *)env + md->offset;\n\n                switch(md->type) {\n\n                case MD_I32:\n\n                    *pval = *(int32_t *)ptr;\n\n                    break;\n\n                case MD_TLONG:\n\n                    *pval = *(target_long *)ptr;\n\n                    break;\n\n                default:\n\n                    *pval = 0;\n\n                    break;\n\n                }\n\n            }\n\n            return 0;\n\n        }\n\n    }\n\n    return -1;\n\n}\n", "idx": 24559}
{"project": "qemu", "commit_id": "51b58561c1dacdb0ce999ada94912caaed157f83", "target": 1, "func": "static ssize_t gunzip(void *dst, size_t dstlen, uint8_t *src,\n\n                      size_t srclen)\n\n{\n\n    z_stream s;\n\n    ssize_t dstbytes;\n\n    int r, i, flags;\n\n\n\n    /* skip header */\n\n    i = 10;\n\n    flags = src[3];\n\n    if (src[2] != DEFLATED || (flags & RESERVED) != 0) {\n\n        puts (\"Error: Bad gzipped data\\n\");\n\n        return -1;\n\n    }\n\n    if ((flags & EXTRA_FIELD) != 0)\n\n        i = 12 + src[10] + (src[11] << 8);\n\n    if ((flags & ORIG_NAME) != 0)\n\n        while (src[i++] != 0)\n\n            ;\n\n    if ((flags & COMMENT) != 0)\n\n        while (src[i++] != 0)\n\n            ;\n\n    if ((flags & HEAD_CRC) != 0)\n\n        i += 2;\n\n    if (i >= srclen) {\n\n        puts (\"Error: gunzip out of data in header\\n\");\n\n        return -1;\n\n    }\n\n\n\n    s.zalloc = zalloc;\n\n    s.zfree = zfree;\n\n\n\n    r = inflateInit2(&s, -MAX_WBITS);\n\n    if (r != Z_OK) {\n\n        printf (\"Error: inflateInit2() returned %d\\n\", r);\n\n        return (-1);\n\n    }\n\n    s.next_in = src + i;\n\n    s.avail_in = srclen - i;\n\n    s.next_out = dst;\n\n    s.avail_out = dstlen;\n\n    r = inflate(&s, Z_FINISH);\n\n    if (r != Z_OK && r != Z_STREAM_END) {\n\n        printf (\"Error: inflate() returned %d\\n\", r);\n\n        return -1;\n\n    }\n\n    dstbytes = s.next_out - (unsigned char *) dst;\n\n    inflateEnd(&s);\n\n\n\n    return dstbytes;\n\n}\n", "idx": 24560}
