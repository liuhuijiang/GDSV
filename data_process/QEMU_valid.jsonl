{"project": "qemu", "commit_id": "d0bce760e04b1658a3b4ac95be2839ae20fd86db", "target": 1, "func": "static void omap_i2c_recv(I2CAdapter *i2c, uint8_t addr,\n\n                          uint8_t *buf, uint16_t len)\n\n{\n\n    OMAPI2C *s = (OMAPI2C *)i2c;\n\n    uint16_t data, stat;\n\n\n\n    omap_i2c_set_slave_addr(s, addr);\n\n\n\n    data = len;\n\n    memwrite(s->addr + OMAP_I2C_CNT, &data, 2);\n\n\n\n    data = OMAP_I2C_CON_I2C_EN |\n\n           OMAP_I2C_CON_MST |\n\n           OMAP_I2C_CON_STT |\n\n           OMAP_I2C_CON_STP;\n\n    memwrite(s->addr + OMAP_I2C_CON, &data, 2);\n\n    memread(s->addr + OMAP_I2C_CON, &data, 2);\n\n    g_assert((data & OMAP_I2C_CON_STP) == 0);\n\n\n\n    memread(s->addr + OMAP_I2C_STAT, &data, 2);\n\n    g_assert((data & OMAP_I2C_STAT_NACK) == 0);\n\n\n\n    memread(s->addr + OMAP_I2C_CNT, &data, 2);\n\n    g_assert_cmpuint(data, ==, len);\n\n\n\n    while (len > 0) {\n\n        memread(s->addr + OMAP_I2C_STAT, &data, 2);\n\n        g_assert((data & OMAP_I2C_STAT_RRDY) != 0);\n\n        g_assert((data & OMAP_I2C_STAT_ROVR) == 0);\n\n\n\n        memread(s->addr + OMAP_I2C_DATA, &data, 2);\n\n\n\n        memread(s->addr + OMAP_I2C_STAT, &stat, 2);\n\n        if (unlikely(len == 1)) {\n\n            *buf = data & 0xf;\n\n            buf++;\n\n            len--;\n\n        } else {\n\n            memcpy(buf, &data, 2);\n\n            buf += 2;\n\n            len -= 2;\n\n        }\n\n    }\n\n\n\n    memread(s->addr + OMAP_I2C_CON, &data, 2);\n\n    g_assert((data & OMAP_I2C_CON_STP) == 0);\n\n}\n", "idx": 24562}
{"project": "qemu", "commit_id": "7696414729b2d0f870c80ad1dd637d854bc78847", "target": 1, "func": "static void gen_ld(DisasContext *ctx, uint32_t opc,\n\n                   int rt, int base, int16_t offset)\n\n{\n\n    TCGv t0, t1, t2;\n\n    int mem_idx = ctx->mem_idx;\n\n\n\n    if (rt == 0 && ctx->insn_flags & (INSN_LOONGSON2E | INSN_LOONGSON2F)) {\n\n        /* Loongson CPU uses a load to zero register for prefetch.\n\n           We emulate it as a NOP. On other CPU we must perform the\n\n           actual memory access. */\n\n        return;\n\n    }\n\n\n\n    t0 = tcg_temp_new();\n\n    gen_base_offset_addr(ctx, t0, base, offset);\n\n\n\n    switch (opc) {\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_LWU:\n\n        tcg_gen_qemu_ld_tl(t0, t0, mem_idx, MO_TEUL |\n\n                           ctx->default_tcg_memop_mask);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case OPC_LD:\n\n        tcg_gen_qemu_ld_tl(t0, t0, mem_idx, MO_TEQ |\n\n                           ctx->default_tcg_memop_mask);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case OPC_LLD:\n\n    case R6_OPC_LLD:\n\n        op_ld_lld(t0, t0, mem_idx, ctx);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case OPC_LDL:\n\n        t1 = tcg_temp_new();\n\n        /* Do a byte access to possibly trigger a page\n\n           fault with the unaligned address.  */\n\n        tcg_gen_qemu_ld_tl(t1, t0, mem_idx, MO_UB);\n\n        tcg_gen_andi_tl(t1, t0, 7);\n\n#ifndef TARGET_WORDS_BIGENDIAN\n\n        tcg_gen_xori_tl(t1, t1, 7);\n\n#endif\n\n        tcg_gen_shli_tl(t1, t1, 3);\n\n        tcg_gen_andi_tl(t0, t0, ~7);\n\n        tcg_gen_qemu_ld_tl(t0, t0, mem_idx, MO_TEQ);\n\n        tcg_gen_shl_tl(t0, t0, t1);\n\n        t2 = tcg_const_tl(-1);\n\n        tcg_gen_shl_tl(t2, t2, t1);\n\n        gen_load_gpr(t1, rt);\n\n        tcg_gen_andc_tl(t1, t1, t2);\n\n        tcg_temp_free(t2);\n\n        tcg_gen_or_tl(t0, t0, t1);\n\n        tcg_temp_free(t1);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case OPC_LDR:\n\n        t1 = tcg_temp_new();\n\n        /* Do a byte access to possibly trigger a page\n\n           fault with the unaligned address.  */\n\n        tcg_gen_qemu_ld_tl(t1, t0, mem_idx, MO_UB);\n\n        tcg_gen_andi_tl(t1, t0, 7);\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n        tcg_gen_xori_tl(t1, t1, 7);\n\n#endif\n\n        tcg_gen_shli_tl(t1, t1, 3);\n\n        tcg_gen_andi_tl(t0, t0, ~7);\n\n        tcg_gen_qemu_ld_tl(t0, t0, mem_idx, MO_TEQ);\n\n        tcg_gen_shr_tl(t0, t0, t1);\n\n        tcg_gen_xori_tl(t1, t1, 63);\n\n        t2 = tcg_const_tl(0xfffffffffffffffeull);\n\n        tcg_gen_shl_tl(t2, t2, t1);\n\n        gen_load_gpr(t1, rt);\n\n        tcg_gen_and_tl(t1, t1, t2);\n\n        tcg_temp_free(t2);\n\n        tcg_gen_or_tl(t0, t0, t1);\n\n        tcg_temp_free(t1);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case OPC_LDPC:\n\n        t1 = tcg_const_tl(pc_relative_pc(ctx));\n\n        gen_op_addr_add(ctx, t0, t0, t1);\n\n        tcg_temp_free(t1);\n\n        tcg_gen_qemu_ld_tl(t0, t0, mem_idx, MO_TEQ);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n#endif\n\n    case OPC_LWPC:\n\n        t1 = tcg_const_tl(pc_relative_pc(ctx));\n\n        gen_op_addr_add(ctx, t0, t0, t1);\n\n        tcg_temp_free(t1);\n\n        tcg_gen_qemu_ld_tl(t0, t0, mem_idx, MO_TESL);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case OPC_LWE:\n\n\n\n    case OPC_LW:\n\n        tcg_gen_qemu_ld_tl(t0, t0, mem_idx, MO_TESL |\n\n                           ctx->default_tcg_memop_mask);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case OPC_LHE:\n\n\n\n    case OPC_LH:\n\n        tcg_gen_qemu_ld_tl(t0, t0, mem_idx, MO_TESW |\n\n                           ctx->default_tcg_memop_mask);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case OPC_LHUE:\n\n\n\n    case OPC_LHU:\n\n        tcg_gen_qemu_ld_tl(t0, t0, mem_idx, MO_TEUW |\n\n                           ctx->default_tcg_memop_mask);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case OPC_LBE:\n\n\n\n    case OPC_LB:\n\n        tcg_gen_qemu_ld_tl(t0, t0, mem_idx, MO_SB);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case OPC_LBUE:\n\n\n\n    case OPC_LBU:\n\n        tcg_gen_qemu_ld_tl(t0, t0, mem_idx, MO_UB);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case OPC_LWLE:\n\n\n\n    case OPC_LWL:\n\n        t1 = tcg_temp_new();\n\n        /* Do a byte access to possibly trigger a page\n\n           fault with the unaligned address.  */\n\n        tcg_gen_qemu_ld_tl(t1, t0, mem_idx, MO_UB);\n\n        tcg_gen_andi_tl(t1, t0, 3);\n\n#ifndef TARGET_WORDS_BIGENDIAN\n\n        tcg_gen_xori_tl(t1, t1, 3);\n\n#endif\n\n        tcg_gen_shli_tl(t1, t1, 3);\n\n        tcg_gen_andi_tl(t0, t0, ~3);\n\n        tcg_gen_qemu_ld_tl(t0, t0, mem_idx, MO_TEUL);\n\n        tcg_gen_shl_tl(t0, t0, t1);\n\n        t2 = tcg_const_tl(-1);\n\n        tcg_gen_shl_tl(t2, t2, t1);\n\n        gen_load_gpr(t1, rt);\n\n        tcg_gen_andc_tl(t1, t1, t2);\n\n        tcg_temp_free(t2);\n\n        tcg_gen_or_tl(t0, t0, t1);\n\n        tcg_temp_free(t1);\n\n        tcg_gen_ext32s_tl(t0, t0);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n\n\n\n    case OPC_LWR:\n\n        t1 = tcg_temp_new();\n\n        /* Do a byte access to possibly trigger a page\n\n           fault with the unaligned address.  */\n\n        tcg_gen_qemu_ld_tl(t1, t0, mem_idx, MO_UB);\n\n        tcg_gen_andi_tl(t1, t0, 3);\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n        tcg_gen_xori_tl(t1, t1, 3);\n\n#endif\n\n        tcg_gen_shli_tl(t1, t1, 3);\n\n        tcg_gen_andi_tl(t0, t0, ~3);\n\n        tcg_gen_qemu_ld_tl(t0, t0, mem_idx, MO_TEUL);\n\n        tcg_gen_shr_tl(t0, t0, t1);\n\n        tcg_gen_xori_tl(t1, t1, 31);\n\n        t2 = tcg_const_tl(0xfffffffeull);\n\n        tcg_gen_shl_tl(t2, t2, t1);\n\n        gen_load_gpr(t1, rt);\n\n        tcg_gen_and_tl(t1, t1, t2);\n\n        tcg_temp_free(t2);\n\n        tcg_gen_or_tl(t0, t0, t1);\n\n        tcg_temp_free(t1);\n\n        tcg_gen_ext32s_tl(t0, t0);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case OPC_LLE:\n\n\n\n    case OPC_LL:\n\n    case R6_OPC_LL:\n\n        op_ld_ll(t0, t0, mem_idx, ctx);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    }\n\n    tcg_temp_free(t0);\n\n}", "idx": 24565}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void network_to_caps(RDMACapabilities *cap)\n\n{\n\n    cap->version = ntohl(cap->version);\n\n    cap->flags = ntohl(cap->flags);\n\n}\n", "idx": 24567}
{"project": "qemu", "commit_id": "b946a1533209f61a93e34898aebb5b43154b99c3", "target": 1, "func": "static void pcnet_common_init(PCNetState *d, NICInfo *nd)\n\n{\n\n    d->poll_timer = qemu_new_timer(vm_clock, pcnet_poll_timer, d);\n\n\n\n    d->nd = nd;\n\n\n\n    if (nd && nd->vlan) {\n\n        d->vc = qemu_new_vlan_client(nd->vlan, nd->model, nd->name,\n\n                                     pcnet_receive, pcnet_can_receive, d);\n\n\n\n        qemu_format_nic_info_str(d->vc, d->nd->macaddr);\n\n    } else {\n\n        d->vc = NULL;\n\n    }\n\n    pcnet_h_reset(d);\n\n    register_savevm(\"pcnet\", -1, 2, pcnet_save, pcnet_load, d);\n\n}\n", "idx": 24569}
{"project": "qemu", "commit_id": "7f763a5d994bbddb50705d2e50decdf52937521f", "target": 1, "func": "static void *spapr_create_fdt_skel(const char *cpu_model,\n\n                                   target_phys_addr_t rma_size,\n\n                                   target_phys_addr_t initrd_base,\n\n                                   target_phys_addr_t initrd_size,\n\n                                   target_phys_addr_t kernel_size,\n\n                                   const char *boot_device,\n\n                                   const char *kernel_cmdline,\n\n                                   long hash_shift)\n\n{\n\n    void *fdt;\n\n    CPUPPCState *env;\n\n    uint64_t mem_reg_property[2];\n\n    uint32_t start_prop = cpu_to_be32(initrd_base);\n\n    uint32_t end_prop = cpu_to_be32(initrd_base + initrd_size);\n\n    uint32_t pft_size_prop[] = {0, cpu_to_be32(hash_shift)};\n\n    char hypertas_prop[] = \"hcall-pft\\0hcall-term\\0hcall-dabr\\0hcall-interrupt\"\n\n        \"\\0hcall-tce\\0hcall-vio\\0hcall-splpar\\0hcall-bulk\";\n\n    char qemu_hypertas_prop[] = \"hcall-memop1\";\n\n    uint32_t interrupt_server_ranges_prop[] = {0, cpu_to_be32(smp_cpus)};\n\n    int i;\n\n    char *modelname;\n\n    int smt = kvmppc_smt_threads();\n\n    unsigned char vec5[] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x80};\n\n    uint32_t refpoints[] = {cpu_to_be32(0x4), cpu_to_be32(0x4)};\n\n    uint32_t associativity[] = {cpu_to_be32(0x4), cpu_to_be32(0x0),\n\n                                cpu_to_be32(0x0), cpu_to_be32(0x0),\n\n                                cpu_to_be32(0x0)};\n\n    char mem_name[32];\n\n    target_phys_addr_t node0_size, mem_start;\n\n\n\n#define _FDT(exp) \\\n\n    do { \\\n\n        int ret = (exp);                                           \\\n\n        if (ret < 0) {                                             \\\n\n            fprintf(stderr, \"qemu: error creating device tree: %s: %s\\n\", \\\n\n                    #exp, fdt_strerror(ret));                      \\\n\n            exit(1);                                               \\\n\n        }                                                          \\\n\n    } while (0)\n\n\n\n    fdt = g_malloc0(FDT_MAX_SIZE);\n\n    _FDT((fdt_create(fdt, FDT_MAX_SIZE)));\n\n\n\n    if (kernel_size) {\n\n        _FDT((fdt_add_reservemap_entry(fdt, KERNEL_LOAD_ADDR, kernel_size)));\n\n    }\n\n    if (initrd_size) {\n\n        _FDT((fdt_add_reservemap_entry(fdt, initrd_base, initrd_size)));\n\n    }\n\n    _FDT((fdt_finish_reservemap(fdt)));\n\n\n\n    /* Root node */\n\n    _FDT((fdt_begin_node(fdt, \"\")));\n\n    _FDT((fdt_property_string(fdt, \"device_type\", \"chrp\")));\n\n    _FDT((fdt_property_string(fdt, \"model\", \"IBM pSeries (emulated by qemu)\")));\n\n\n\n    _FDT((fdt_property_cell(fdt, \"#address-cells\", 0x2)));\n\n    _FDT((fdt_property_cell(fdt, \"#size-cells\", 0x2)));\n\n\n\n    /* /chosen */\n\n    _FDT((fdt_begin_node(fdt, \"chosen\")));\n\n\n\n    /* Set Form1_affinity */\n\n    _FDT((fdt_property(fdt, \"ibm,architecture-vec-5\", vec5, sizeof(vec5))));\n\n\n\n    _FDT((fdt_property_string(fdt, \"bootargs\", kernel_cmdline)));\n\n    _FDT((fdt_property(fdt, \"linux,initrd-start\",\n\n                       &start_prop, sizeof(start_prop))));\n\n    _FDT((fdt_property(fdt, \"linux,initrd-end\",\n\n                       &end_prop, sizeof(end_prop))));\n\n    if (kernel_size) {\n\n        uint64_t kprop[2] = { cpu_to_be64(KERNEL_LOAD_ADDR),\n\n                              cpu_to_be64(kernel_size) };\n\n\n\n        _FDT((fdt_property(fdt, \"qemu,boot-kernel\", &kprop, sizeof(kprop))));\n\n    }\n\n    _FDT((fdt_property_string(fdt, \"qemu,boot-device\", boot_device)));\n\n    _FDT((fdt_property_cell(fdt, \"qemu,graphic-width\", graphic_width)));\n\n    _FDT((fdt_property_cell(fdt, \"qemu,graphic-height\", graphic_height)));\n\n    _FDT((fdt_property_cell(fdt, \"qemu,graphic-depth\", graphic_depth)));\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* memory node(s) */\n\n    node0_size = (nb_numa_nodes > 1) ? node_mem[0] : ram_size;\n\n    if (rma_size > node0_size) {\n\n        rma_size = node0_size;\n\n    }\n\n\n\n    /* RMA */\n\n    mem_reg_property[0] = 0;\n\n    mem_reg_property[1] = cpu_to_be64(rma_size);\n\n    _FDT((fdt_begin_node(fdt, \"memory@0\")));\n\n    _FDT((fdt_property_string(fdt, \"device_type\", \"memory\")));\n\n    _FDT((fdt_property(fdt, \"reg\", mem_reg_property,\n\n        sizeof(mem_reg_property))));\n\n    _FDT((fdt_property(fdt, \"ibm,associativity\", associativity,\n\n        sizeof(associativity))));\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* RAM: Node 0 */\n\n    if (node0_size > rma_size) {\n\n        mem_reg_property[0] = cpu_to_be64(rma_size);\n\n        mem_reg_property[1] = cpu_to_be64(node0_size - rma_size);\n\n\n\n        sprintf(mem_name, \"memory@\" TARGET_FMT_lx, rma_size);\n\n        _FDT((fdt_begin_node(fdt, mem_name)));\n\n        _FDT((fdt_property_string(fdt, \"device_type\", \"memory\")));\n\n        _FDT((fdt_property(fdt, \"reg\", mem_reg_property,\n\n                           sizeof(mem_reg_property))));\n\n        _FDT((fdt_property(fdt, \"ibm,associativity\", associativity,\n\n                           sizeof(associativity))));\n\n        _FDT((fdt_end_node(fdt)));\n\n    }\n\n\n\n    /* RAM: Node 1 and beyond */\n\n    mem_start = node0_size;\n\n    for (i = 1; i < nb_numa_nodes; i++) {\n\n        mem_reg_property[0] = cpu_to_be64(mem_start);\n\n        mem_reg_property[1] = cpu_to_be64(node_mem[i]);\n\n        associativity[3] = associativity[4] = cpu_to_be32(i);\n\n        sprintf(mem_name, \"memory@\" TARGET_FMT_lx, mem_start);\n\n        _FDT((fdt_begin_node(fdt, mem_name)));\n\n        _FDT((fdt_property_string(fdt, \"device_type\", \"memory\")));\n\n        _FDT((fdt_property(fdt, \"reg\", mem_reg_property,\n\n            sizeof(mem_reg_property))));\n\n        _FDT((fdt_property(fdt, \"ibm,associativity\", associativity,\n\n            sizeof(associativity))));\n\n        _FDT((fdt_end_node(fdt)));\n\n        mem_start += node_mem[i];\n\n    }\n\n\n\n    /* cpus */\n\n    _FDT((fdt_begin_node(fdt, \"cpus\")));\n\n\n\n    _FDT((fdt_property_cell(fdt, \"#address-cells\", 0x1)));\n\n    _FDT((fdt_property_cell(fdt, \"#size-cells\", 0x0)));\n\n\n\n    modelname = g_strdup(cpu_model);\n\n\n\n    for (i = 0; i < strlen(modelname); i++) {\n\n        modelname[i] = toupper(modelname[i]);\n\n    }\n\n\n\n    /* This is needed during FDT finalization */\n\n    spapr->cpu_model = g_strdup(modelname);\n\n\n\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n\n        int index = env->cpu_index;\n\n        uint32_t servers_prop[smp_threads];\n\n        uint32_t gservers_prop[smp_threads * 2];\n\n        char *nodename;\n\n        uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40),\n\n                           0xffffffff, 0xffffffff};\n\n        uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq() : TIMEBASE_FREQ;\n\n        uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000;\n\n        uint32_t page_sizes_prop[64];\n\n        size_t page_sizes_prop_size;\n\n\n\n        if ((index % smt) != 0) {\n\n            continue;\n\n        }\n\n\n\n        if (asprintf(&nodename, \"%s@%x\", modelname, index) < 0) {\n\n            fprintf(stderr, \"Allocation failure\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        _FDT((fdt_begin_node(fdt, nodename)));\n\n\n\n        free(nodename);\n\n\n\n        _FDT((fdt_property_cell(fdt, \"reg\", index)));\n\n        _FDT((fdt_property_string(fdt, \"device_type\", \"cpu\")));\n\n\n\n        _FDT((fdt_property_cell(fdt, \"cpu-version\", env->spr[SPR_PVR])));\n\n        _FDT((fdt_property_cell(fdt, \"dcache-block-size\",\n\n                                env->dcache_line_size)));\n\n        _FDT((fdt_property_cell(fdt, \"icache-block-size\",\n\n                                env->icache_line_size)));\n\n        _FDT((fdt_property_cell(fdt, \"timebase-frequency\", tbfreq)));\n\n        _FDT((fdt_property_cell(fdt, \"clock-frequency\", cpufreq)));\n\n        _FDT((fdt_property_cell(fdt, \"ibm,slb-size\", env->slb_nr)));\n\n        _FDT((fdt_property(fdt, \"ibm,pft-size\",\n\n                           pft_size_prop, sizeof(pft_size_prop))));\n\n        _FDT((fdt_property_string(fdt, \"status\", \"okay\")));\n\n        _FDT((fdt_property(fdt, \"64-bit\", NULL, 0)));\n\n\n\n        /* Build interrupt servers and gservers properties */\n\n        for (i = 0; i < smp_threads; i++) {\n\n            servers_prop[i] = cpu_to_be32(index + i);\n\n            /* Hack, direct the group queues back to cpu 0 */\n\n            gservers_prop[i*2] = cpu_to_be32(index + i);\n\n            gservers_prop[i*2 + 1] = 0;\n\n        }\n\n        _FDT((fdt_property(fdt, \"ibm,ppc-interrupt-server#s\",\n\n                           servers_prop, sizeof(servers_prop))));\n\n        _FDT((fdt_property(fdt, \"ibm,ppc-interrupt-gserver#s\",\n\n                           gservers_prop, sizeof(gservers_prop))));\n\n\n\n        if (env->mmu_model & POWERPC_MMU_1TSEG) {\n\n            _FDT((fdt_property(fdt, \"ibm,processor-segment-sizes\",\n\n                               segs, sizeof(segs))));\n\n        }\n\n\n\n        /* Advertise VMX/VSX (vector extensions) if available\n\n         *   0 / no property == no vector extensions\n\n         *   1               == VMX / Altivec available\n\n         *   2               == VSX available */\n\n        if (env->insns_flags & PPC_ALTIVEC) {\n\n            uint32_t vmx = (env->insns_flags2 & PPC2_VSX) ? 2 : 1;\n\n\n\n            _FDT((fdt_property_cell(fdt, \"ibm,vmx\", vmx)));\n\n        }\n\n\n\n        /* Advertise DFP (Decimal Floating Point) if available\n\n         *   0 / no property == no DFP\n\n         *   1               == DFP available */\n\n        if (env->insns_flags2 & PPC2_DFP) {\n\n            _FDT((fdt_property_cell(fdt, \"ibm,dfp\", 1)));\n\n        }\n\n\n\n        page_sizes_prop_size = create_page_sizes_prop(env, page_sizes_prop,\n\n                                                      sizeof(page_sizes_prop));\n\n        if (page_sizes_prop_size) {\n\n            _FDT((fdt_property(fdt, \"ibm,segment-page-sizes\",\n\n                               page_sizes_prop, page_sizes_prop_size)));\n\n        }\n\n\n\n        _FDT((fdt_end_node(fdt)));\n\n    }\n\n\n\n    g_free(modelname);\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* RTAS */\n\n    _FDT((fdt_begin_node(fdt, \"rtas\")));\n\n\n\n    _FDT((fdt_property(fdt, \"ibm,hypertas-functions\", hypertas_prop,\n\n                       sizeof(hypertas_prop))));\n\n    _FDT((fdt_property(fdt, \"qemu,hypertas-functions\", qemu_hypertas_prop,\n\n                       sizeof(qemu_hypertas_prop))));\n\n\n\n    _FDT((fdt_property(fdt, \"ibm,associativity-reference-points\",\n\n        refpoints, sizeof(refpoints))));\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* interrupt controller */\n\n    _FDT((fdt_begin_node(fdt, \"interrupt-controller\")));\n\n\n\n    _FDT((fdt_property_string(fdt, \"device_type\",\n\n                              \"PowerPC-External-Interrupt-Presentation\")));\n\n    _FDT((fdt_property_string(fdt, \"compatible\", \"IBM,ppc-xicp\")));\n\n    _FDT((fdt_property(fdt, \"interrupt-controller\", NULL, 0)));\n\n    _FDT((fdt_property(fdt, \"ibm,interrupt-server-ranges\",\n\n                       interrupt_server_ranges_prop,\n\n                       sizeof(interrupt_server_ranges_prop))));\n\n    _FDT((fdt_property_cell(fdt, \"#interrupt-cells\", 2)));\n\n    _FDT((fdt_property_cell(fdt, \"linux,phandle\", PHANDLE_XICP)));\n\n    _FDT((fdt_property_cell(fdt, \"phandle\", PHANDLE_XICP)));\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* vdevice */\n\n    _FDT((fdt_begin_node(fdt, \"vdevice\")));\n\n\n\n    _FDT((fdt_property_string(fdt, \"device_type\", \"vdevice\")));\n\n    _FDT((fdt_property_string(fdt, \"compatible\", \"IBM,vdevice\")));\n\n    _FDT((fdt_property_cell(fdt, \"#address-cells\", 0x1)));\n\n    _FDT((fdt_property_cell(fdt, \"#size-cells\", 0x0)));\n\n    _FDT((fdt_property_cell(fdt, \"#interrupt-cells\", 0x2)));\n\n    _FDT((fdt_property(fdt, \"interrupt-controller\", NULL, 0)));\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    _FDT((fdt_end_node(fdt))); /* close root node */\n\n    _FDT((fdt_finish(fdt)));\n\n\n\n    return fdt;\n\n}\n", "idx": 24576}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "void arm_sysctl_init(uint32_t base, uint32_t sys_id)\n\n{\n\n    arm_sysctl_state *s;\n\n    int iomemtype;\n\n\n\n    s = (arm_sysctl_state *)qemu_mallocz(sizeof(arm_sysctl_state));\n\n    if (!s)\n\n        return;\n\n    s->base = base;\n\n    s->sys_id = sys_id;\n\n    iomemtype = cpu_register_io_memory(0, arm_sysctl_readfn,\n\n                                       arm_sysctl_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n    /* ??? Save/restore.  */\n\n}\n", "idx": 24577}
{"project": "qemu", "commit_id": "5f9099d9cee0e9ed377aee705ca9f4db75e8948d", "target": 1, "func": "static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,\n                                 struct target_ucontext_v2 *uc)\n{\n    sigset_t host_set;\n    abi_ulong *regspace;\n    target_to_host_sigset(&host_set, &uc->tuc_sigmask);\n    sigprocmask(SIG_SETMASK, &host_set, NULL);\n    if (restore_sigcontext(env, &uc->tuc_mcontext))\n    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)\n#if 0\n    /* Send SIGTRAP if we're single-stepping */\n    if (ptrace_cancel_bpt(current))\n            send_sig(SIGTRAP, current, 1);\n#endif\n    return 0;", "idx": 24578}
{"project": "qemu", "commit_id": "a9fc37f6bc3f2ab90585cb16493da9f6dcfbfbcf", "target": 1, "func": "static void qobject_input_type_uint64(Visitor *v, const char *name,\n\n                                      uint64_t *obj, Error **errp)\n\n{\n\n    /* FIXME: qobject_to_qint mishandles values over INT64_MAX */\n\n    QObjectInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    QInt *qint;\n\n\n\n    if (!qobj) {\n\n        return;\n\n    }\n\n    qint = qobject_to_qint(qobj);\n\n    if (!qint) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"integer\");\n\n        return;\n\n    }\n\n\n\n    *obj = qint_get_int(qint);\n\n}\n", "idx": 24579}
{"project": "qemu", "commit_id": "67fc07d3fba681f3362f7644a69b7a581a2670e8", "target": 1, "func": "void mulu64(uint64_t *phigh, uint64_t *plow, uint64_t a, uint64_t b)\n\n{\n\n#if defined(__x86_64__)\n\n    __asm__ (\"mul %0\\n\\t\"\n\n             : \"=d\" (*phigh), \"=a\" (*plow)\n\n             : \"a\" (a), \"0\" (b)\n\n            );\n\n#else\n\n    uint64_t ph, pm1, pm2, pl;\n\n\n\n    pl = (uint64_t)((uint32_t)a) * (uint64_t)((uint32_t)b);\n\n    pm1 = (a >> 32) * (uint32_t)b;\n\n    pm2 = (uint32_t)a * (b >> 32);\n\n    ph = (a >> 32) * (b >> 32);\n\n\n\n    ph += pm1 >> 32;\n\n    pm1 = (uint64_t)((uint32_t)pm1) + pm2 + (pl >> 32);\n\n\n\n    *phigh = ph + (pm1 >> 32);\n\n    *plow = (pm1 << 32) + (uint32_t)pl;\n\n#endif\n\n}\n", "idx": 24580}
{"project": "qemu", "commit_id": "e7b921c2d9efc249f99b9feb0e7dca82c96aa5c4", "target": 1, "func": "static inline int get_a32_user_mem_index(DisasContext *s)\n\n{\n\n    /* Return the core mmu_idx to use for A32/T32 \"unprivileged load/store\"\n\n     * insns:\n\n     *  if PL2, UNPREDICTABLE (we choose to implement as if PL0)\n\n     *  otherwise, access as if at PL0.\n\n     */\n\n    switch (s->mmu_idx) {\n\n    case ARMMMUIdx_S1E2:        /* this one is UNPREDICTABLE */\n\n    case ARMMMUIdx_S12NSE0:\n\n    case ARMMMUIdx_S12NSE1:\n\n        return arm_to_core_mmu_idx(ARMMMUIdx_S12NSE0);\n\n    case ARMMMUIdx_S1E3:\n\n    case ARMMMUIdx_S1SE0:\n\n    case ARMMMUIdx_S1SE1:\n\n        return arm_to_core_mmu_idx(ARMMMUIdx_S1SE0);\n\n\n\n\n    case ARMMMUIdx_S2NS:\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n}", "idx": 24582}
{"project": "qemu", "commit_id": "184bd0484533b725194fa517ddc271ffd74da7c9", "target": 1, "func": "static uint32_t virtio_net_bad_features(VirtIODevice *vdev)\n\n{\n\n    uint32_t features = 0;\n\n\n\n    /* Linux kernel 2.6.25.  It understood MAC (as everyone must),\n\n     * but also these: */\n\n    features |= (1 << VIRTIO_NET_F_MAC);\n\n    features |= (1 << VIRTIO_NET_F_GUEST_CSUM);\n\n    features |= (1 << VIRTIO_NET_F_GUEST_TSO4);\n\n    features |= (1 << VIRTIO_NET_F_GUEST_TSO6);\n\n    features |= (1 << VIRTIO_NET_F_GUEST_ECN);\n\n\n\n    return features & virtio_net_get_features(vdev);\n\n}\n", "idx": 24583}
{"project": "qemu", "commit_id": "4a998740b22aa673ea475060c787da7c545588cf", "target": 0, "func": "void qemu_get_timer(QEMUFile *f, QEMUTimer *ts)\n\n{\n\n    uint64_t expire_time;\n\n\n\n    expire_time = qemu_get_be64(f);\n\n    if (expire_time != -1) {\n\n        qemu_mod_timer(ts, expire_time);\n\n    } else {\n\n        qemu_del_timer(ts);\n\n    }\n\n}\n", "idx": 24584}
{"project": "qemu", "commit_id": "28f082469650a0f4c0e37b4ccd6f9514b1a0698d", "target": 0, "func": "static void qemu_co_queue_next_bh(void *opaque)\n\n{\n\n    Coroutine *next;\n\n\n\n    trace_qemu_co_queue_next_bh();\n\n    while ((next = QTAILQ_FIRST(&unlock_bh_queue))) {\n\n        QTAILQ_REMOVE(&unlock_bh_queue, next, co_queue_next);\n\n        qemu_coroutine_enter(next, NULL);\n\n    }\n\n}\n", "idx": 24585}
{"project": "qemu", "commit_id": "e3ff9f0e57472e6411dc446b41789cbd9e2cf887", "target": 0, "func": "static void test_to_from_buf_1(void)\n\n{\n\n     unsigned niov;\n\n     struct iovec *iov;\n\n     size_t sz;\n\n     unsigned char *ibuf, *obuf;\n\n     unsigned i, j, n;\n\n\n\n     iov_random(&iov, &niov);\n\n\n\n     sz = iov_size(iov, niov);\n\n\n\n     ibuf = g_malloc(sz + 8) + 4;\n\n     memcpy(ibuf-4, \"aaaa\", 4); memcpy(ibuf + sz, \"bbbb\", 4);\n\n     obuf = g_malloc(sz + 8) + 4;\n\n     memcpy(obuf-4, \"xxxx\", 4); memcpy(obuf + sz, \"yyyy\", 4);\n\n\n\n     /* fill in ibuf with 0123456... */\n\n     for (i = 0; i < sz; ++i) {\n\n         ibuf[i] = i & 255;\n\n     }\n\n\n\n     for (i = 0; i <= sz; ++i) {\n\n\n\n         /* Test from/to buf for offset(i) in [0..sz] up to the end of buffer.\n\n          * For last iteration with offset == sz, the procedure should\n\n          * skip whole vector and process exactly 0 bytes */\n\n\n\n         /* first set bytes [i..sz) to some \"random\" value */\n\n         n = iov_memset(iov, niov, 0, 0xff, -1);\n\n         g_assert(n == sz);\n\n\n\n         /* next copy bytes [i..sz) from ibuf to iovec */\n\n         n = iov_from_buf(iov, niov, i, ibuf + i, -1);\n\n         g_assert(n == sz - i);\n\n\n\n         /* clear part of obuf */\n\n         memset(obuf + i, 0, sz - i);\n\n         /* and set this part of obuf to values from iovec */\n\n         n = iov_to_buf(iov, niov, i, obuf + i, -1);\n\n         g_assert(n == sz - i);\n\n\n\n         /* now compare resulting buffers */\n\n         g_assert(memcmp(ibuf, obuf, sz) == 0);\n\n\n\n         /* test just one char */\n\n         n = iov_to_buf(iov, niov, i, obuf + i, 1);\n\n         g_assert(n == (i < sz));\n\n         if (n) {\n\n             g_assert(obuf[i] == (i & 255));\n\n         }\n\n\n\n         for (j = i; j <= sz; ++j) {\n\n             /* now test num of bytes cap up to byte no. j,\n\n              * with j in [i..sz]. */\n\n\n\n             /* clear iovec */\n\n             n = iov_memset(iov, niov, 0, 0xff, -1);\n\n             g_assert(n == sz);\n\n\n\n             /* copy bytes [i..j) from ibuf to iovec */\n\n             n = iov_from_buf(iov, niov, i, ibuf + i, j - i);\n\n             g_assert(n == j - i);\n\n\n\n             /* clear part of obuf */\n\n             memset(obuf + i, 0, j - i);\n\n\n\n             /* copy bytes [i..j) from iovec to obuf */\n\n             n = iov_to_buf(iov, niov, i, obuf + i, j - i);\n\n             g_assert(n == j - i);\n\n\n\n             /* verify result */\n\n             g_assert(memcmp(ibuf, obuf, sz) == 0);\n\n\n\n             /* now actually check if the iovec contains the right data */\n\n             test_iov_bytes(iov, niov, i, j - i);\n\n         }\n\n    }\n\n    g_assert(!memcmp(ibuf-4, \"aaaa\", 4) && !memcmp(ibuf+sz, \"bbbb\", 4));\n\n    g_free(ibuf-4);\n\n    g_assert(!memcmp(obuf-4, \"xxxx\", 4) && !memcmp(obuf+sz, \"yyyy\", 4));\n\n    g_free(obuf-4);\n\n    iov_free(iov, niov);\n\n}\n", "idx": 24586}
{"project": "qemu", "commit_id": "619d11e4631000f20318dec90b87f314272bfa4a", "target": 0, "func": "FWCfgState *pc_memory_init(MemoryRegion *system_memory,\n\n                           const char *kernel_filename,\n\n                           const char *kernel_cmdline,\n\n                           const char *initrd_filename,\n\n                           ram_addr_t below_4g_mem_size,\n\n                           ram_addr_t above_4g_mem_size,\n\n                           MemoryRegion *rom_memory,\n\n                           MemoryRegion **ram_memory,\n\n                           PcGuestInfo *guest_info)\n\n{\n\n    int linux_boot, i;\n\n    MemoryRegion *ram, *option_rom_mr;\n\n    MemoryRegion *ram_below_4g, *ram_above_4g;\n\n    FWCfgState *fw_cfg;\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* Allocate RAM.  We allocate it as a single memory region and use\n\n     * aliases to address portions of it, mostly for backwards compatibility\n\n     * with older qemus that used qemu_ram_alloc().\n\n     */\n\n    ram = g_malloc(sizeof(*ram));\n\n    memory_region_init_ram(ram, NULL, \"pc.ram\",\n\n                           below_4g_mem_size + above_4g_mem_size);\n\n    vmstate_register_ram_global(ram);\n\n    *ram_memory = ram;\n\n    ram_below_4g = g_malloc(sizeof(*ram_below_4g));\n\n    memory_region_init_alias(ram_below_4g, NULL, \"ram-below-4g\", ram,\n\n                             0, below_4g_mem_size);\n\n    memory_region_add_subregion(system_memory, 0, ram_below_4g);\n\n    e820_add_entry(0, below_4g_mem_size, E820_RAM);\n\n    if (above_4g_mem_size > 0) {\n\n        ram_above_4g = g_malloc(sizeof(*ram_above_4g));\n\n        memory_region_init_alias(ram_above_4g, NULL, \"ram-above-4g\", ram,\n\n                                 below_4g_mem_size, above_4g_mem_size);\n\n        memory_region_add_subregion(system_memory, 0x100000000ULL,\n\n                                    ram_above_4g);\n\n        e820_add_entry(0x100000000ULL, above_4g_mem_size, E820_RAM);\n\n    }\n\n\n\n\n\n    /* Initialize PC system firmware */\n\n    pc_system_firmware_init(rom_memory, guest_info->isapc_ram_fw);\n\n\n\n    option_rom_mr = g_malloc(sizeof(*option_rom_mr));\n\n    memory_region_init_ram(option_rom_mr, NULL, \"pc.rom\", PC_ROM_SIZE);\n\n    vmstate_register_ram_global(option_rom_mr);\n\n    memory_region_add_subregion_overlap(rom_memory,\n\n                                        PC_ROM_MIN_VGA,\n\n                                        option_rom_mr,\n\n                                        1);\n\n\n\n    fw_cfg = bochs_bios_init();\n\n    rom_set_fw(fw_cfg);\n\n\n\n    if (linux_boot) {\n\n        load_linux(fw_cfg, kernel_filename, initrd_filename, kernel_cmdline, below_4g_mem_size);\n\n    }\n\n\n\n    for (i = 0; i < nb_option_roms; i++) {\n\n        rom_add_option(option_rom[i].name, option_rom[i].bootindex);\n\n    }\n\n    guest_info->fw_cfg = fw_cfg;\n\n    return fw_cfg;\n\n}\n", "idx": 24588}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t exynos4210_i2c_read(void *opaque, target_phys_addr_t offset,\n\n                                 unsigned size)\n\n{\n\n    Exynos4210I2CState *s = (Exynos4210I2CState *)opaque;\n\n    uint8_t value;\n\n\n\n    switch (offset) {\n\n    case I2CCON_ADDR:\n\n        value = s->i2ccon;\n\n        break;\n\n    case I2CSTAT_ADDR:\n\n        value = s->i2cstat;\n\n        break;\n\n    case I2CADD_ADDR:\n\n        value = s->i2cadd;\n\n        break;\n\n    case I2CDS_ADDR:\n\n        value = s->i2cds;\n\n        s->scl_free = true;\n\n        if (EXYNOS4_I2C_MODE(s->i2cstat) == I2CMODE_MASTER_Rx &&\n\n               (s->i2cstat & I2CSTAT_START_BUSY) &&\n\n               !(s->i2ccon & I2CCON_INT_PEND)) {\n\n            exynos4210_i2c_data_receive(s);\n\n        }\n\n        break;\n\n    case I2CLC_ADDR:\n\n        value = s->i2clc;\n\n        break;\n\n    default:\n\n        value = 0;\n\n        DPRINT(\"ERROR: Bad read offset 0x%x\\n\", (unsigned int)offset);\n\n        break;\n\n    }\n\n\n\n    DPRINT(\"read %s [0x%02x] -> 0x%02x\\n\", exynos4_i2c_get_regname(offset),\n\n            (unsigned int)offset, value);\n\n    return value;\n\n}\n", "idx": 24589}
{"project": "qemu", "commit_id": "537b41f5013e1951fa15e8f18855b18d76124ce4", "target": 0, "func": "int unix_socket_incoming(const char *path)\n\n{\n\n    Error *local_err = NULL;\n\n    int fd = unix_listen(path, NULL, 0, &local_err);\n\n\n\n    if (local_err != NULL) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n    }\n\n    return fd;\n\n}\n", "idx": 24590}
{"project": "qemu", "commit_id": "43ae8fb10c5f6ca78f242624c1f446e0050a9d43", "target": 0, "func": "static int iscsi_reopen_prepare(BDRVReopenState *state,\n\n                                BlockReopenQueue *queue, Error **errp)\n\n{\n\n    /* NOP */\n\n    return 0;\n\n}\n", "idx": 24591}
{"project": "qemu", "commit_id": "a5b8dd2ce83208cd7d6eb4562339ecf5aae13574", "target": 0, "func": "static void raw_probe_alignment(BlockDriverState *bs, Error **errp)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    DWORD sectorsPerCluster, freeClusters, totalClusters, count;\n\n    DISK_GEOMETRY_EX dg;\n\n    BOOL status;\n\n\n\n    if (s->type == FTYPE_CD) {\n\n        bs->request_alignment = 2048;\n\n        return;\n\n    }\n\n    if (s->type == FTYPE_HARDDISK) {\n\n        status = DeviceIoControl(s->hfile, IOCTL_DISK_GET_DRIVE_GEOMETRY_EX,\n\n                                 NULL, 0, &dg, sizeof(dg), &count, NULL);\n\n        if (status != 0) {\n\n            bs->request_alignment = dg.Geometry.BytesPerSector;\n\n            return;\n\n        }\n\n        /* try GetDiskFreeSpace too */\n\n    }\n\n\n\n    if (s->drive_path[0]) {\n\n        GetDiskFreeSpace(s->drive_path, &sectorsPerCluster,\n\n                         &dg.Geometry.BytesPerSector,\n\n                         &freeClusters, &totalClusters);\n\n        bs->request_alignment = dg.Geometry.BytesPerSector;\n\n    }\n\n}\n", "idx": 24592}
{"project": "qemu", "commit_id": "f57f5878578af19f72344439154234c6d6ba8ccc", "target": 0, "func": "static int local_name_to_path(FsContext *ctx, V9fsPath *dir_path,\n\n                              const char *name, V9fsPath *target)\n\n{\n\n    if (ctx->export_flags & V9FS_SM_MAPPED_FILE &&\n\n        local_is_mapped_file_metadata(ctx, name)) {\n\n        errno = EINVAL;\n\n        return -1;\n\n    }\n\n\n\n    if (dir_path) {\n\n        v9fs_path_sprintf(target, \"%s/%s\", dir_path->data, name);\n\n    } else if (strcmp(name, \"/\")) {\n\n        v9fs_path_sprintf(target, \"%s\", name);\n\n    } else {\n\n        /* We want the path of the export root to be relative, otherwise\n\n         * \"*at()\" syscalls would treat it as \"/\" in the host.\n\n         */\n\n        v9fs_path_sprintf(target, \"%s\", \".\");\n\n    }\n\n    return 0;\n\n}\n", "idx": 24593}
{"project": "qemu", "commit_id": "7385aed20db5d83979f683b9d0048674411e963c", "target": 0, "func": "static inline void gen_op_fcmpes(int fccno, TCGv r_rs1, TCGv r_rs2)\n\n{\n\n    gen_helper_fcmpes(cpu_env, r_rs1, r_rs2);\n\n}\n", "idx": 24594}
{"project": "qemu", "commit_id": "1c275925bfbbc2de84a8f0e09d1dd70bbefb6da3", "target": 0, "func": "long do_sigreturn(CPUMIPSState *regs)\n\n{\n\n    struct sigframe *frame;\n\n    abi_ulong frame_addr;\n\n    sigset_t blocked;\n\n    target_sigset_t target_set;\n\n    int i;\n\n\n\n#if defined(DEBUG_SIGNAL)\n\n    fprintf(stderr, \"do_sigreturn\\n\");\n\n#endif\n\n    frame_addr = regs->active_tc.gpr[29];\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))\n\n   \tgoto badframe;\n\n\n\n    for(i = 0; i < TARGET_NSIG_WORDS; i++) {\n\n   \tif(__get_user(target_set.sig[i], &frame->sf_mask.sig[i]))\n\n\t    goto badframe;\n\n    }\n\n\n\n    target_to_host_sigset_internal(&blocked, &target_set);\n\n    sigprocmask(SIG_SETMASK, &blocked, NULL);\n\n\n\n    if (restore_sigcontext(regs, &frame->sf_sc))\n\n   \tgoto badframe;\n\n\n\n#if 0\n\n    /*\n\n     * Don't let your children do this ...\n\n     */\n\n    __asm__ __volatile__(\n\n   \t\"move\\t$29, %0\\n\\t\"\n\n   \t\"j\\tsyscall_exit\"\n\n   \t:/* no outputs */\n\n   \t:\"r\" (&regs));\n\n    /* Unreached */\n\n#endif\n\n\n\n    regs->active_tc.PC = regs->CP0_EPC;\n\n    mips_set_hflags_isa_mode_from_pc(regs);\n\n    /* I am not sure this is right, but it seems to work\n\n    * maybe a problem with nested signals ? */\n\n    regs->CP0_EPC = 0;\n\n    return -TARGET_QEMU_ESIGRETURN;\n\n\n\nbadframe:\n\n    force_sig(TARGET_SIGSEGV/*, current*/);\n\n    return 0;\n\n}\n", "idx": 24595}
{"project": "qemu", "commit_id": "0f51726adcdb620214405a88b2601d9edd059db4", "target": 0, "func": "static int con_init(struct XenDevice *xendev)\n\n{\n\n    struct XenConsole *con = container_of(xendev, struct XenConsole, xendev);\n\n    char *type, *dom;\n\n    int ret = 0;\n\n\n\n    /* setup */\n\n    dom = xs_get_domain_path(xenstore, con->xendev.dom);\n\n    snprintf(con->console, sizeof(con->console), \"%s/console\", dom);\n\n    free(dom);\n\n\n\n    type = xenstore_read_str(con->console, \"type\");\n\n    if (!type || strcmp(type, \"ioemu\") != 0) {\n\n\txen_be_printf(xendev, 1, \"not for me (type=%s)\\n\", type);\n\n        ret = -1;\n\n        goto out;\n\n    }\n\n\n\n    if (!serial_hds[con->xendev.dev])\n\n\txen_be_printf(xendev, 1, \"WARNING: serial line %d not configured\\n\",\n\n                      con->xendev.dev);\n\n    else\n\n        con->chr = serial_hds[con->xendev.dev];\n\n\n\nout:\n\n    qemu_free(type);\n\n    return ret;\n\n}\n", "idx": 24596}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void bmdma_addr_write(void *opaque, target_phys_addr_t addr,\n\n                             uint64_t data, unsigned width)\n\n{\n\n    BMDMAState *bm = opaque;\n\n    int shift = addr * 8;\n\n    uint32_t mask = (1ULL << (width * 8)) - 1;\n\n\n\n#ifdef DEBUG_IDE\n\n    printf(\"%s: 0x%08x\\n\", __func__, (unsigned)data);\n\n#endif\n\n    bm->addr &= ~(mask << shift);\n\n    bm->addr |= ((data & mask) << shift) & ~3;\n\n}\n", "idx": 24597}
{"project": "qemu", "commit_id": "e7ca56562990991bc614a43b9351ee0737f3045d", "target": 0, "func": "static void string_output_free(Visitor *v)\n\n{\n\n    StringOutputVisitor *sov = to_sov(v);\n\n\n\n    string_output_visitor_cleanup(sov);\n\n}\n", "idx": 24599}
{"project": "qemu", "commit_id": "6f1de6b70d857d5e316ae6fd908f52818b827b08", "target": 0, "func": "int qemu_chr_fe_add_watch(CharDriverState *s, GIOCondition cond,\n\n                          GIOFunc func, void *user_data)\n\n{\n\n    GSource *src;\n\n    guint tag;\n\n\n\n    if (s->chr_add_watch == NULL) {\n\n        return -ENOSYS;\n\n    }\n\n\n\n    src = s->chr_add_watch(s, cond);\n\n    if (!src) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    g_source_set_callback(src, (GSourceFunc)func, user_data, NULL);\n\n    tag = g_source_attach(src, NULL);\n\n    g_source_unref(src);\n\n\n\n    return tag;\n\n}\n", "idx": 24600}
{"project": "qemu", "commit_id": "067acf28d1d726059f994356f25e054ce2926acf", "target": 0, "func": "static void external_snapshot_abort(BlkActionState *common)\n\n{\n\n    ExternalSnapshotState *state =\n\n                             DO_UPCAST(ExternalSnapshotState, common, common);\n\n    if (state->new_bs) {\n\n        if (state->new_bs->backing) {\n\n            bdrv_replace_in_backing_chain(state->new_bs, state->old_bs);\n\n        }\n\n    }\n\n}\n", "idx": 24601}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "uint64_t ldq_phys(target_phys_addr_t addr)\n\n{\n\n    return ldq_phys_internal(addr, DEVICE_NATIVE_ENDIAN);\n\n}\n", "idx": 24602}
{"project": "qemu", "commit_id": "c5ce83334465ee5acb6789a2f22d125273761c9e", "target": 0, "func": "static void press_key(VncState *vs, int keysym)\n\n{\n\n    int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;\n\n    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);\n\n    qemu_input_event_send_key_delay(0);\n\n    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);\n\n    qemu_input_event_send_key_delay(0);\n\n}\n", "idx": 24603}
{"project": "qemu", "commit_id": "b1914b824ade1706847428e64ef5637ffc0ae238", "target": 0, "func": "static void virtio_ccw_device_plugged(DeviceState *d, Error **errp)\n\n{\n\n    VirtioCcwDevice *dev = VIRTIO_CCW_DEVICE(d);\n\n    VirtIODevice *vdev = virtio_bus_get_device(&dev->bus);\n\n    CcwDevice *ccw_dev = CCW_DEVICE(d);\n\n    SubchDev *sch = ccw_dev->sch;\n\n    int n = virtio_get_num_queues(vdev);\n\n    S390FLICState *flic = s390_get_flic();\n\n\n\n    if (!virtio_has_feature(vdev->host_features, VIRTIO_F_VERSION_1)) {\n\n        dev->max_rev = 0;\n\n    }\n\n\n\n    if (virtio_get_num_queues(vdev) > VIRTIO_CCW_QUEUE_MAX) {\n\n        error_setg(errp, \"The number of virtqueues %d \"\n\n                   \"exceeds ccw limit %d\", n,\n\n                   VIRTIO_CCW_QUEUE_MAX);\n\n        return;\n\n    }\n\n    if (virtio_get_num_queues(vdev) > flic->adapter_routes_max_batch) {\n\n        error_setg(errp, \"The number of virtqueues %d \"\n\n                   \"exceeds flic adapter route limit %d\", n,\n\n                   flic->adapter_routes_max_batch);\n\n        return;\n\n    }\n\n\n\n    sch->id.cu_model = virtio_bus_get_vdev_id(&dev->bus);\n\n\n\n\n\n    css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,\n\n                          d->hotplugged, 1);\n\n}\n", "idx": 24604}
{"project": "qemu", "commit_id": "adc370a48fd26b92188fa4848dfb088578b1936c", "target": 0, "func": "HELPER_LD(lbu, ldub, uint8_t)\n\nHELPER_LD(lhu, lduw, uint16_t)\n\nHELPER_LD(lw, ldl, int32_t)\n\nHELPER_LD(ld, ldq, int64_t)\n\n#undef HELPER_LD\n\n\n\n#if defined(CONFIG_USER_ONLY)\n\n#define HELPER_ST(name, insn, type)                                     \\\n\nstatic inline void do_##name(CPUMIPSState *env, target_ulong addr,      \\\n\n                             type val, int mem_idx)                     \\\n\n{                                                                       \\\n\n    cpu_##insn##_data(env, addr, val);                                  \\\n\n}\n\n#else\n\n#define HELPER_ST(name, insn, type)                                     \\\n\nstatic inline void do_##name(CPUMIPSState *env, target_ulong addr,      \\\n\n                             type val, int mem_idx)                     \\\n\n{                                                                       \\\n\n    switch (mem_idx)                                                    \\\n\n    {                                                                   \\\n\n    case 0: cpu_##insn##_kernel(env, addr, val); break;                 \\\n\n    case 1: cpu_##insn##_super(env, addr, val); break;                  \\\n\n    default:                                                            \\\n\n    case 2: cpu_##insn##_user(env, addr, val); break;                   \\\n\n    }                                                                   \\\n\n}\n\n#endif\n\nHELPER_ST(sb, stb, uint8_t)\n\nHELPER_ST(sh, stw, uint16_t)\n\nHELPER_ST(sw, stl, uint32_t)\n\nHELPER_ST(sd, stq, uint64_t)\n\n#undef HELPER_ST\n\n\n\ntarget_ulong helper_clo (target_ulong arg1)\n\n{\n\n    return clo32(arg1);\n\n}\n", "idx": 24605}
{"project": "qemu", "commit_id": "8172539d21a03e982aa7f139ddc1607dc1422045", "target": 0, "func": "static void s390_virtio_device_sync(VirtIOS390Device *dev)\n\n{\n\n    VirtIOS390Bus *bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);\n\n    ram_addr_t cur_offs;\n\n    uint8_t num_vq;\n\n    int i;\n\n\n\n    virtio_reset(dev->vdev);\n\n\n\n    /* Sync dev space */\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_TYPE, dev->vdev->device_id);\n\n\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_NUM_VQ, s390_virtio_device_num_vq(dev));\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_FEATURE_LEN, dev->feat_len);\n\n\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_CONFIG_LEN, dev->vdev->config_len);\n\n\n\n    num_vq = s390_virtio_device_num_vq(dev);\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_NUM_VQ, num_vq);\n\n\n\n    /* Sync virtqueues */\n\n    for (i = 0; i < num_vq; i++) {\n\n        ram_addr_t vq = (dev->dev_offs + VIRTIO_DEV_OFFS_CONFIG) +\n\n                        (i * VIRTIO_VQCONFIG_LEN);\n\n        ram_addr_t vring;\n\n\n\n        vring = s390_virtio_next_ring(bus);\n\n        virtio_queue_set_addr(dev->vdev, i, vring);\n\n        virtio_queue_set_vector(dev->vdev, i, i);\n\n        stq_phys(vq + VIRTIO_VQCONFIG_OFFS_ADDRESS, vring);\n\n        stw_phys(vq + VIRTIO_VQCONFIG_OFFS_NUM, virtio_queue_get_num(dev->vdev, i));\n\n    }\n\n\n\n    cur_offs = dev->dev_offs;\n\n    cur_offs += VIRTIO_DEV_OFFS_CONFIG;\n\n    cur_offs += num_vq * VIRTIO_VQCONFIG_LEN;\n\n\n\n    /* Sync feature bitmap */\n\n    if (dev->vdev->get_features) {\n\n        stl_phys(cur_offs, dev->vdev->get_features(dev->vdev));\n\n    }\n\n\n\n    dev->feat_offs = cur_offs + dev->feat_len;\n\n    cur_offs += dev->feat_len * 2;\n\n\n\n    /* Sync config space */\n\n    if (dev->vdev->get_config) {\n\n        dev->vdev->get_config(dev->vdev, dev->vdev->config);\n\n    }\n\n\n\n    cpu_physical_memory_rw(cur_offs, dev->vdev->config, dev->vdev->config_len, 1);\n\n    cur_offs += dev->vdev->config_len;\n\n}\n", "idx": 24606}
{"project": "qemu", "commit_id": "8b3b720620a1137a1b794fc3ed64734236f94e06", "target": 1, "func": "int qcow2_grow_l1_table(BlockDriverState *bs, int min_size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int new_l1_size, new_l1_size2, ret, i;\n\n    uint64_t *new_l1_table;\n\n    int64_t new_l1_table_offset;\n\n    uint8_t data[12];\n\n\n\n    new_l1_size = s->l1_size;\n\n    if (min_size <= new_l1_size)\n\n        return 0;\n\n    if (new_l1_size == 0) {\n\n        new_l1_size = 1;\n\n    }\n\n    while (min_size > new_l1_size) {\n\n        new_l1_size = (new_l1_size * 3 + 1) / 2;\n\n    }\n\n#ifdef DEBUG_ALLOC2\n\n    printf(\"grow l1_table from %d to %d\\n\", s->l1_size, new_l1_size);\n\n#endif\n\n\n\n    new_l1_size2 = sizeof(uint64_t) * new_l1_size;\n\n    new_l1_table = qemu_mallocz(align_offset(new_l1_size2, 512));\n\n    memcpy(new_l1_table, s->l1_table, s->l1_size * sizeof(uint64_t));\n\n\n\n    /* write new table (align to cluster) */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_ALLOC_TABLE);\n\n    new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);\n\n    if (new_l1_table_offset < 0) {\n\n        qemu_free(new_l1_table);\n\n        return new_l1_table_offset;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_WRITE_TABLE);\n\n    for(i = 0; i < s->l1_size; i++)\n\n        new_l1_table[i] = cpu_to_be64(new_l1_table[i]);\n\n    ret = bdrv_pwrite(bs->file, new_l1_table_offset, new_l1_table, new_l1_size2);\n\n    if (ret != new_l1_size2)\n\n        goto fail;\n\n    for(i = 0; i < s->l1_size; i++)\n\n        new_l1_table[i] = be64_to_cpu(new_l1_table[i]);\n\n\n\n    /* set new table */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_ACTIVATE_TABLE);\n\n    cpu_to_be32w((uint32_t*)data, new_l1_size);\n\n    cpu_to_be64w((uint64_t*)(data + 4), new_l1_table_offset);\n\n    ret = bdrv_pwrite(bs->file, offsetof(QCowHeader, l1_size), data,sizeof(data));\n\n    if (ret != sizeof(data)) {\n\n        goto fail;\n\n    }\n\n    qemu_free(s->l1_table);\n\n    qcow2_free_clusters(bs, s->l1_table_offset, s->l1_size * sizeof(uint64_t));\n\n    s->l1_table_offset = new_l1_table_offset;\n\n    s->l1_table = new_l1_table;\n\n    s->l1_size = new_l1_size;\n\n    return 0;\n\n fail:\n\n    qemu_free(new_l1_table);\n\n    qcow2_free_clusters(bs, new_l1_table_offset, new_l1_size2);\n\n    return ret < 0 ? ret : -EIO;\n\n}\n", "idx": 24610}
{"project": "qemu", "commit_id": "56ad3e54dad6cdcee8668d170df161d89581846f", "target": 1, "func": "static ssize_t mp_dacl_getxattr(FsContext *ctx, const char *path,\n\n                                const char *name, void *value, size_t size)\n\n{\n\n    char *buffer;\n\n    ssize_t ret;\n\n\n\n    buffer = rpath(ctx, path);\n\n    ret = lgetxattr(buffer, MAP_ACL_DEFAULT, value, size);\n\n    g_free(buffer);\n\n    return ret;\n\n}\n", "idx": 24611}
{"project": "qemu", "commit_id": "4f298a4b2957b7833bc607c951ca27c458d98d88", "target": 1, "func": "static void clr_msg_flags(IPMIBmcSim *ibs,\n\n                          uint8_t *cmd, unsigned int cmd_len,\n\n                          uint8_t *rsp, unsigned int *rsp_len,\n\n                          unsigned int max_rsp_len)\n\n{\n\n    IPMIInterface *s = ibs->parent.intf;\n\n    IPMIInterfaceClass *k = IPMI_INTERFACE_GET_CLASS(s);\n\n\n\n    IPMI_CHECK_CMD_LEN(3);\n\n    ibs->msg_flags &= ~cmd[2];\n\n    k->set_atn(s, attn_set(ibs), attn_irq_enabled(ibs));\n\n}\n", "idx": 24613}
{"project": "qemu", "commit_id": "69c8944f17cb6c084567a16c080cfa7bc780e668", "target": 1, "func": "static int pci_ich9_ahci_init(PCIDevice *dev)\n\n{\n\n    struct AHCIPCIState *d;\n\n    d = DO_UPCAST(struct AHCIPCIState, card, dev);\n\n\n\n    pci_config_set_vendor_id(d->card.config, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(d->card.config, PCI_DEVICE_ID_INTEL_82801IR);\n\n\n\n    pci_config_set_class(d->card.config, PCI_CLASS_STORAGE_SATA);\n\n    pci_config_set_revision(d->card.config, 0x02);\n\n    pci_config_set_prog_interface(d->card.config, AHCI_PROGMODE_MAJOR_REV_1);\n\n\n\n    d->card.config[PCI_CACHE_LINE_SIZE] = 0x08;  /* Cache line size */\n\n    d->card.config[PCI_LATENCY_TIMER]   = 0x00;  /* Latency timer */\n\n    pci_config_set_interrupt_pin(d->card.config, 1);\n\n\n\n    /* XXX Software should program this register */\n\n    d->card.config[0x90]   = 1 << 6; /* Address Map Register - AHCI mode */\n\n\n\n    qemu_register_reset(ahci_reset, d);\n\n\n\n    /* XXX BAR size should be 1k, but that breaks, so bump it to 4k for now */\n\n    pci_register_bar_simple(&d->card, 5, 0x1000, 0, d->ahci.mem);\n\n\n\n    msi_init(dev, 0x50, 1, true, false);\n\n\n\n    ahci_init(&d->ahci, &dev->qdev, 6);\n\n    d->ahci.irq = d->card.irq[0];\n\n\n\n    return 0;\n\n}\n", "idx": 24614}
{"project": "qemu", "commit_id": "5712db6ae5101db645f71edc393368cd59bfd314", "target": 1, "func": "static void fw_cfg_realize(DeviceState *dev, Error **errp)\n\n{\n\n    FWCfgState *s = FW_CFG(dev);\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);\n\n\n\n    if (s->ctl_iobase + 1 == s->data_iobase) {\n\n        sysbus_add_io(sbd, s->ctl_iobase, &s->comb_iomem);\n\n    } else {\n\n        if (s->ctl_iobase) {\n\n            sysbus_add_io(sbd, s->ctl_iobase, &s->ctl_iomem);\n\n        }\n\n        if (s->data_iobase) {\n\n            sysbus_add_io(sbd, s->data_iobase, &s->data_iomem);\n\n        }\n\n    }\n\n}\n", "idx": 24615}
{"project": "qemu", "commit_id": "895b00f62a7e86724dc7352d67c7808d37366130", "target": 1, "func": "struct GuestFileSeek *qmp_guest_file_seek(int64_t handle, int64_t offset,\n\n                                          int64_t whence, Error **errp)\n\n{\n\n    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);\n\n    GuestFileSeek *seek_data = NULL;\n\n    FILE *fh;\n\n    int ret;\n\n\n\n    if (!gfh) {\n\n        return NULL;\n\n\n\n\n    fh = gfh->fh;\n\n    ret = fseek(fh, offset, whence);\n\n    if (ret == -1) {\n\n        error_setg_errno(errp, errno, \"failed to seek file\");\n\n\n\n\n\n    } else {\n\n        seek_data = g_new0(GuestFileSeek, 1);\n\n        seek_data->position = ftell(fh);\n\n        seek_data->eof = feof(fh);\n\n\n\n    clearerr(fh);\n\n\n\n    return seek_data;\n", "idx": 24618}
{"project": "qemu", "commit_id": "21cb1e63a594e36ff350fba41600190fb0a1f42b", "target": 1, "func": "static void tpm_passthrough_cancel_cmd(TPMBackend *tb)\n\n{\n\n    TPMPassthruState *tpm_pt = TPM_PASSTHROUGH(tb);\n\n    int n;\n\n\n\n    /*\n\n     * As of Linux 3.7 the tpm_tis driver does not properly cancel\n\n     * commands on all TPM manufacturers' TPMs.\n\n     * Only cancel if we're busy so we don't cancel someone else's\n\n     * command, e.g., a command executed on the host.\n\n     */\n\n    if (tpm_pt->tpm_executing) {\n\n        if (tpm_pt->cancel_fd >= 0) {\n\n            n = write(tpm_pt->cancel_fd, \"-\", 1);\n\n            if (n != 1) {\n\n                error_report(\"Canceling TPM command failed: %s\",\n\n                             strerror(errno));\n\n            } else {\n\n                tpm_pt->tpm_op_canceled = true;\n\n            }\n\n        } else {\n\n            error_report(\"Cannot cancel TPM command due to missing \"\n\n                         \"TPM sysfs cancel entry\");\n\n        }\n\n    }\n\n}\n", "idx": 24619}
{"project": "qemu", "commit_id": "a4d8e8daee324e230b0155915f562743f4fff5d8", "target": 1, "func": "static void vscsi_got_payload(VSCSIState *s, vscsi_crq *crq)\n\n{\n\n    vscsi_req *req;\n\n    int done;\n\n\n\n    req = vscsi_get_req(s);\n\n    if (req == NULL) {\n\n        fprintf(stderr, \"VSCSI: Failed to get a request !\\n\");\n\n        return;\n\n    }\n\n\n\n    /* We only support a limited number of descriptors, we know\n\n     * the ibmvscsi driver uses up to 10 max, so it should fit\n\n     * in our 256 bytes IUs. If not we'll have to increase the size\n\n     * of the structure.\n\n     */\n\n    if (crq->s.IU_length > sizeof(union viosrp_iu)) {\n\n        fprintf(stderr, \"VSCSI: SRP IU too long (%d bytes) !\\n\",\n\n                crq->s.IU_length);\n\n        return;\n\n    }\n\n\n\n    /* XXX Handle failure differently ? */\n\n    if (spapr_tce_dma_read(&s->vdev, crq->s.IU_data_ptr, &req->iu,\n\n                           crq->s.IU_length)) {\n\n        fprintf(stderr, \"vscsi_got_payload: DMA read failure !\\n\");\n\n        g_free(req);\n\n    }\n\n    memcpy(&req->crq, crq, sizeof(vscsi_crq));\n\n\n\n    if (crq->s.format == VIOSRP_MAD_FORMAT) {\n\n        done = vscsi_handle_mad_req(s, req);\n\n    } else {\n\n        done = vscsi_handle_srp_req(s, req);\n\n    }\n\n\n\n    if (done) {\n\n        vscsi_put_req(req);\n\n    }\n\n}\n", "idx": 24620}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "TC6393xbState *tc6393xb_init(MemoryRegion *sysmem, uint32_t base, qemu_irq irq)\n\n{\n\n    TC6393xbState *s;\n\n    DriveInfo *nand;\n\n    static const MemoryRegionOps tc6393xb_ops = {\n\n        .read = tc6393xb_readb,\n\n        .write = tc6393xb_writeb,\n\n        .endianness = DEVICE_NATIVE_ENDIAN,\n\n        .impl = {\n\n            .min_access_size = 1,\n\n            .max_access_size = 1,\n\n        },\n\n    };\n\n\n\n    s = (TC6393xbState *) g_malloc0(sizeof(TC6393xbState));\n\n    s->irq = irq;\n\n    s->gpio_in = qemu_allocate_irqs(tc6393xb_gpio_set, s, TC6393XB_GPIOS);\n\n\n\n    s->l3v = qemu_allocate_irq(tc6393xb_l3v, s, 0);\n\n    s->blanked = 1;\n\n\n\n    s->sub_irqs = qemu_allocate_irqs(tc6393xb_sub_irq, s, TC6393XB_NR_IRQS);\n\n\n\n    nand = drive_get(IF_MTD, 0, 0);\n\n    s->flash = nand_init(nand ? blk_by_legacy_dinfo(nand) : NULL,\n\n                         NAND_MFR_TOSHIBA, 0x76);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &tc6393xb_ops, s, \"tc6393xb\", 0x10000);\n\n    memory_region_add_subregion(sysmem, base, &s->iomem);\n\n\n\n    memory_region_init_ram(&s->vram, NULL, \"tc6393xb.vram\", 0x100000,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->vram);\n\n    s->vram_ptr = memory_region_get_ram_ptr(&s->vram);\n\n    memory_region_add_subregion(sysmem, base + 0x100000, &s->vram);\n\n    s->scr_width = 480;\n\n    s->scr_height = 640;\n\n    s->con = graphic_console_init(NULL, 0, &tc6393xb_gfx_ops, s);\n\n\n\n    return s;\n\n}\n", "idx": 24624}
{"project": "qemu", "commit_id": "164a101f28a53cd3db60ed874e7c3630e7988ed8", "target": 1, "func": "void aio_set_event_notifier(AioContext *ctx,\n\n                            EventNotifier *e,\n\n                            EventNotifierHandler *io_notify,\n\n                            AioFlushEventNotifierHandler *io_flush)\n\n{\n\n    AioHandler *node;\n\n\n\n    QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n        if (node->e == e && !node->deleted) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* Are we deleting the fd handler? */\n\n    if (!io_notify) {\n\n        if (node) {\n\n            g_source_remove_poll(&ctx->source, &node->pfd);\n\n\n\n            /* If the lock is held, just mark the node as deleted */\n\n            if (ctx->walking_handlers) {\n\n                node->deleted = 1;\n\n                node->pfd.revents = 0;\n\n            } else {\n\n                /* Otherwise, delete it for real.  We can't just mark it as\n\n                 * deleted because deleted nodes are only cleaned up after\n\n                 * releasing the walking_handlers lock.\n\n                 */\n\n                QLIST_REMOVE(node, node);\n\n                g_free(node);\n\n            }\n\n        }\n\n    } else {\n\n        if (node == NULL) {\n\n            /* Alloc and insert if it's not already there */\n\n            node = g_malloc0(sizeof(AioHandler));\n\n            node->e = e;\n\n            node->pfd.fd = (uintptr_t)event_notifier_get_handle(e);\n\n            node->pfd.events = G_IO_IN;\n\n            QLIST_INSERT_HEAD(&ctx->aio_handlers, node, node);\n\n\n\n            g_source_add_poll(&ctx->source, &node->pfd);\n\n        }\n\n        /* Update handler with latest information */\n\n        node->io_notify = io_notify;\n\n        node->io_flush = io_flush;\n\n    }\n\n\n\n    aio_notify(ctx);\n\n}\n", "idx": 24626}
{"project": "qemu", "commit_id": "eb8b9530b0c618d4f2e728eae10d89239d35b0c0", "target": 1, "func": "static void kvm_arm_gic_get(GICState *s)\n\n{\n\n    uint32_t reg;\n\n    int i;\n\n    int cpu;\n\n\n\n    if (!kvm_arm_gic_can_save_restore(s)) {\n\n            DPRINTF(\"Cannot get kernel gic state, no kernel interface\");\n\n            return;\n\n    }\n\n\n\n    /*****************************************************************\n\n     * Distributor State\n\n     */\n\n\n\n    /* GICD_CTLR -> s->enabled */\n\n    kvm_gicd_access(s, 0x0, 0, &reg, false);\n\n    s->enabled = reg & 1;\n\n\n\n    /* Sanity checking on GICD_TYPER -> s->num_irq, s->num_cpu */\n\n    kvm_gicd_access(s, 0x4, 0, &reg, false);\n\n    s->num_irq = ((reg & 0x1f) + 1) * 32;\n\n    s->num_cpu = ((reg & 0xe0) >> 5) + 1;\n\n\n\n    if (s->num_irq > GIC_MAXIRQ) {\n\n            fprintf(stderr, \"Too many IRQs reported from the kernel: %d\\n\",\n\n                    s->num_irq);\n\n            abort();\n\n    }\n\n\n\n    /* GICD_IIDR -> ? */\n\n    kvm_gicd_access(s, 0x8, 0, &reg, false);\n\n\n\n    /* Verify no GROUP 1 interrupts configured in the kernel */\n\n    for_each_irq_reg(i, s->num_irq, 1) {\n\n        kvm_gicd_access(s, 0x80 + (i * 4), 0, &reg, false);\n\n        if (reg != 0) {\n\n            fprintf(stderr, \"Unsupported GICD_IGROUPRn value: %08x\\n\",\n\n                    reg);\n\n            abort();\n\n        }\n\n    }\n\n\n\n    /* Clear all the IRQ settings */\n\n    for (i = 0; i < s->num_irq; i++) {\n\n        memset(&s->irq_state[i], 0, sizeof(s->irq_state[0]));\n\n    }\n\n\n\n    /* GICD_ISENABLERn -> irq_state[n].enabled */\n\n    kvm_dist_get(s, 0x100, 1, s->num_irq, translate_enabled);\n\n\n\n    /* GICD_ISPENDRn -> irq_state[n].pending + irq_state[n].level */\n\n    kvm_dist_get(s, 0x200, 1, s->num_irq, translate_pending);\n\n\n\n    /* GICD_ISACTIVERn -> irq_state[n].active */\n\n    kvm_dist_get(s, 0x300, 1, s->num_irq, translate_active);\n\n\n\n    /* GICD_ICFRn -> irq_state[n].trigger */\n\n    kvm_dist_get(s, 0xc00, 2, s->num_irq, translate_trigger);\n\n\n\n    /* GICD_IPRIORITYRn -> s->priorityX[irq] */\n\n    kvm_dist_get(s, 0x400, 8, s->num_irq, translate_priority);\n\n\n\n    /* GICD_ITARGETSRn -> s->irq_target[irq] */\n\n    kvm_dist_get(s, 0x800, 8, s->num_irq, translate_targets);\n\n\n\n    /* GICD_CPENDSGIRn -> s->sgi_pending */\n\n    kvm_dist_get(s, 0xf10, 8, GIC_NR_SGIS, translate_sgisource);\n\n\n\n\n\n    /*****************************************************************\n\n     * CPU Interface(s) State\n\n     */\n\n\n\n    for (cpu = 0; cpu < s->num_cpu; cpu++) {\n\n        /* GICC_CTLR -> s->cpu_enabled[cpu] */\n\n        kvm_gicc_access(s, 0x00, cpu, &reg, false);\n\n        s->cpu_enabled[cpu] = (reg & 1);\n\n\n\n        /* GICC_PMR -> s->priority_mask[cpu] */\n\n        kvm_gicc_access(s, 0x04, cpu, &reg, false);\n\n        s->priority_mask[cpu] = (reg & 0xff);\n\n\n\n        /* GICC_BPR -> s->bpr[cpu] */\n\n        kvm_gicc_access(s, 0x08, cpu, &reg, false);\n\n        s->bpr[cpu] = (reg & 0x7);\n\n\n\n        /* GICC_ABPR -> s->abpr[cpu] */\n\n        kvm_gicc_access(s, 0x1c, cpu, &reg, false);\n\n        s->abpr[cpu] = (reg & 0x7);\n\n\n\n        /* GICC_APRn -> s->apr[n][cpu] */\n\n        for (i = 0; i < 4; i++) {\n\n            kvm_gicc_access(s, 0xd0 + i * 4, cpu, &reg, false);\n\n            s->apr[i][cpu] = reg;\n\n        }\n\n    }\n\n}\n", "idx": 24630}
{"project": "qemu", "commit_id": "8a5865f331028e66b4ed233129d7a914c2d5bfc7", "target": 1, "func": "static MTPData *usb_mtp_get_object_info(MTPState *s, MTPControl *c,\n\n                                        MTPObject *o)\n\n{\n\n    MTPData *d = usb_mtp_data_alloc(c);\n\n\n\n    trace_usb_mtp_op_get_object_info(s->dev.addr, o->handle, o->path);\n\n\n\n    usb_mtp_add_u32(d, QEMU_STORAGE_ID);\n\n    usb_mtp_add_u16(d, o->format);\n\n    usb_mtp_add_u16(d, 0);\n\n    usb_mtp_add_u32(d, o->stat.st_size);\n\n\n\n    usb_mtp_add_u16(d, 0);\n\n    usb_mtp_add_u32(d, 0);\n\n    usb_mtp_add_u32(d, 0);\n\n    usb_mtp_add_u32(d, 0);\n\n    usb_mtp_add_u32(d, 0);\n\n    usb_mtp_add_u32(d, 0);\n\n    usb_mtp_add_u32(d, 0);\n\n\n\n    if (o->parent) {\n\n        usb_mtp_add_u32(d, o->parent->handle);\n\n    } else {\n\n        usb_mtp_add_u32(d, 0);\n\n    }\n\n    if (o->format == FMT_ASSOCIATION) {\n\n        usb_mtp_add_u16(d, 0x0001);\n\n        usb_mtp_add_u32(d, 0x00000001);\n\n        usb_mtp_add_u32(d, 0);\n\n    } else {\n\n        usb_mtp_add_u16(d, 0);\n\n        usb_mtp_add_u32(d, 0);\n\n        usb_mtp_add_u32(d, 0);\n\n    }\n\n\n\n    usb_mtp_add_str(d, o->name);\n\n    usb_mtp_add_time(d, o->stat.st_ctime);\n\n    usb_mtp_add_time(d, o->stat.st_mtime);\n\n    usb_mtp_add_wstr(d, L\"\");\n\n\n\n    return d;\n\n}\n", "idx": 24632}
{"project": "qemu", "commit_id": "2a7e12455c1d388e41f4c8d2231fb48a968792cd", "target": 1, "func": "print_syscall_ret_addr(const struct syscallname *name, abi_long ret)\n\n{\n\n    char *errstr = NULL;\n\n\n\n    if (ret == -1) {\n\n        errstr = target_strerror(errno);\n\n    }\n\n    if ((ret == -1) && errstr) {\n\n        gemu_log(\" = -1 errno=%d (%s)\\n\", errno, errstr);\n\n    } else {\n\n        gemu_log(\" = 0x\" TARGET_ABI_FMT_lx \"\\n\", ret);\n\n    }\n\n}\n", "idx": 24634}
{"project": "qemu", "commit_id": "1b57bd4f2f4993104a5cb48912435396faa10d58", "target": 1, "func": "static inline bool rom_order_compare(Rom *rom, Rom *item)\n\n{\n\n    return (rom->as > item->as) ||\n\n           (rom->as == item->as && rom->addr >= item->addr);\n\n}\n", "idx": 24635}
{"project": "qemu", "commit_id": "6cec5487990bf3f1f22b3fcb871978255e92ae0d", "target": 1, "func": "static void send_framebuffer_update_hextile(VncState *vs, int x, int y, int w, int h)\n\n{\n\n    int i, j;\n\n    int has_fg, has_bg;\n\n    uint8_t *last_fg, *last_bg;\n\n\n\n    vnc_framebuffer_update(vs, x, y, w, h, 5);\n\n\n\n    last_fg = (uint8_t *) malloc(vs->depth);\n\n    last_bg = (uint8_t *) malloc(vs->depth);\n\n    has_fg = has_bg = 0;\n\n    for (j = y; j < (y + h); j += 16) {\n\n\tfor (i = x; i < (x + w); i += 16) {\n\n            vs->send_hextile_tile(vs, i, j,\n\n                                  MIN(16, x + w - i), MIN(16, y + h - j),\n\n                                  last_bg, last_fg, &has_bg, &has_fg);\n\n\t}\n\n    }\n\n    free(last_fg);\n\n    free(last_bg);\n\n\n\n}\n", "idx": 24637}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void ppc405_ocm_init(CPUPPCState *env)\n\n{\n\n    ppc405_ocm_t *ocm;\n\n\n\n    ocm = g_malloc0(sizeof(ppc405_ocm_t));\n\n    /* XXX: Size is 4096 or 0x04000000 */\n\n    memory_region_init_ram(&ocm->isarc_ram, NULL, \"ppc405.ocm\", 4096,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&ocm->isarc_ram);\n\n    memory_region_init_alias(&ocm->dsarc_ram, NULL, \"ppc405.dsarc\", &ocm->isarc_ram,\n\n                             0, 4096);\n\n    qemu_register_reset(&ocm_reset, ocm);\n\n    ppc_dcr_register(env, OCM0_ISARC,\n\n                     ocm, &dcr_read_ocm, &dcr_write_ocm);\n\n    ppc_dcr_register(env, OCM0_ISACNTL,\n\n                     ocm, &dcr_read_ocm, &dcr_write_ocm);\n\n    ppc_dcr_register(env, OCM0_DSARC,\n\n                     ocm, &dcr_read_ocm, &dcr_write_ocm);\n\n    ppc_dcr_register(env, OCM0_DSACNTL,\n\n                     ocm, &dcr_read_ocm, &dcr_write_ocm);\n\n}\n", "idx": 24639}
{"project": "qemu", "commit_id": "81174dae3f9189519cd60c7b79e91c291b021bbe", "target": 1, "func": "static int serial_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    SerialState *s = opaque;\n\n\n\n    if(version_id > 2)\n\n        return -EINVAL;\n\n\n\n    if (version_id >= 2)\n\n        qemu_get_be16s(f, &s->divider);\n\n    else\n\n        s->divider = qemu_get_byte(f);\n\n    qemu_get_8s(f,&s->rbr);\n\n    qemu_get_8s(f,&s->ier);\n\n    qemu_get_8s(f,&s->iir);\n\n    qemu_get_8s(f,&s->lcr);\n\n    qemu_get_8s(f,&s->mcr);\n\n    qemu_get_8s(f,&s->lsr);\n\n    qemu_get_8s(f,&s->msr);\n\n    qemu_get_8s(f,&s->scr);\n\n\n\n    return 0;\n\n}\n", "idx": 24640}
{"project": "qemu", "commit_id": "a8fbaf96e0791d72078d22b75c5f3c1f1d1ee45d", "target": 1, "func": "static inline void vmsvga_update_rect(struct vmsvga_state_s *s,\n\n                int x, int y, int w, int h)\n\n{\n\n#ifndef DIRECT_VRAM\n\n    int line = h;\n\n    int bypl = s->bypp * s->width;\n\n    int width = s->bypp * w;\n\n    int start = s->bypp * x + bypl * y;\n\n    uint8_t *src = s->vram + start;\n\n    uint8_t *dst = s->ds->data + start;\n\n\n\n    for (; line > 0; line --, src += bypl, dst += bypl)\n\n        memcpy(dst, src, width);\n\n#endif\n\n\n\n    dpy_update(s->ds, x, y, w, h);\n\n}\n", "idx": 24642}
{"project": "qemu", "commit_id": "134a03e0b3d34b01b68107104c525c3bff1211d4", "target": 1, "func": "static int os_host_main_loop_wait(uint32_t timeout)\n\n{\n\n    GMainContext *context = g_main_context_default();\n\n    int select_ret, g_poll_ret, ret, i;\n\n    PollingEntry *pe;\n\n    WaitObjects *w = &wait_objects;\n\n    gint poll_timeout;\n\n    static struct timeval tv0;\n\n\n\n    /* XXX: need to suppress polling by better using win32 events */\n\n    ret = 0;\n\n    for (pe = first_polling_entry; pe != NULL; pe = pe->next) {\n\n        ret |= pe->func(pe->opaque);\n\n    }\n\n    if (ret != 0) {\n\n        return ret;\n\n    }\n\n\n\n    g_main_context_prepare(context, &max_priority);\n\n    n_poll_fds = g_main_context_query(context, max_priority, &poll_timeout,\n\n                                      poll_fds, ARRAY_SIZE(poll_fds));\n\n    g_assert(n_poll_fds <= ARRAY_SIZE(poll_fds));\n\n\n\n    for (i = 0; i < w->num; i++) {\n\n        poll_fds[n_poll_fds + i].fd = (DWORD_PTR)w->events[i];\n\n        poll_fds[n_poll_fds + i].events = G_IO_IN;\n\n    }\n\n\n\n    if (poll_timeout < 0 || timeout < poll_timeout) {\n\n        poll_timeout = timeout;\n\n    }\n\n\n\n    qemu_mutex_unlock_iothread();\n\n    g_poll_ret = g_poll(poll_fds, n_poll_fds + w->num, poll_timeout);\n\n    qemu_mutex_lock_iothread();\n\n    if (g_poll_ret > 0) {\n\n        for (i = 0; i < w->num; i++) {\n\n            w->revents[i] = poll_fds[n_poll_fds + i].revents;\n\n        }\n\n        for (i = 0; i < w->num; i++) {\n\n            if (w->revents[i] && w->func[i]) {\n\n                w->func[i](w->opaque[i]);\n\n            }\n\n        }\n\n    }\n\n\n\n    if (g_main_context_check(context, max_priority, poll_fds, n_poll_fds)) {\n\n        g_main_context_dispatch(context);\n\n    }\n\n\n\n    /* Call select after g_poll to avoid a useless iteration and therefore\n\n     * improve socket latency.\n\n     */\n\n\n\n    if (nfds >= 0) {\n\n        select_ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv0);\n\n        if (select_ret != 0) {\n\n            timeout = 0;\n\n        }\n\n    }\n\n\n\n    return select_ret || g_poll_ret;\n\n}\n", "idx": 24643}
{"project": "qemu", "commit_id": "12de9a396acbc95e25c5d60ed097cc55777eaaed", "target": 1, "func": "static int slb_lookup (CPUState *env, target_ulong eaddr,\n\n                       target_ulong *vsid, target_ulong *page_mask, int *attr)\n\n{\n\n    target_phys_addr_t sr_base;\n\n    target_ulong mask;\n\n    uint64_t tmp64;\n\n    uint32_t tmp;\n\n    int n, ret;\n\n    int slb_nr;\n\n\n\n    ret = -5;\n\n    sr_base = env->spr[SPR_ASR];\n\n    mask = 0x0000000000000000ULL; /* Avoid gcc warning */\n\n#if 0 /* XXX: Fix this */\n\n    slb_nr = env->slb_nr;\n\n#else\n\n    slb_nr = 32;\n\n#endif\n\n    for (n = 0; n < slb_nr; n++) {\n\n        tmp64 = ldq_phys(sr_base);\n\n        if (tmp64 & 0x0000000008000000ULL) {\n\n            /* SLB entry is valid */\n\n            switch (tmp64 & 0x0000000006000000ULL) {\n\n            case 0x0000000000000000ULL:\n\n                /* 256 MB segment */\n\n                mask = 0xFFFFFFFFF0000000ULL;\n\n                break;\n\n            case 0x0000000002000000ULL:\n\n                /* 1 TB segment */\n\n                mask = 0xFFFF000000000000ULL;\n\n                break;\n\n            case 0x0000000004000000ULL:\n\n            case 0x0000000006000000ULL:\n\n                /* Reserved => segment is invalid */\n\n                continue;\n\n            }\n\n            if ((eaddr & mask) == (tmp64 & mask)) {\n\n                /* SLB match */\n\n                tmp = ldl_phys(sr_base + 8);\n\n                *vsid = ((tmp64 << 24) | (tmp >> 8)) & 0x0003FFFFFFFFFFFFULL;\n\n                *page_mask = ~mask;\n\n                *attr = tmp & 0xFF;\n\n                ret = 0;\n\n                break;\n\n            }\n\n        }\n\n        sr_base += 12;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 24644}
{"project": "qemu", "commit_id": "4d8d5467cd6e324fb49ae97b9d5dcee3973d9a19", "target": 1, "func": "static void *spapr_create_fdt_skel(const char *cpu_model,\n\n                                   target_phys_addr_t rma_size,\n\n                                   target_phys_addr_t initrd_base,\n\n                                   target_phys_addr_t initrd_size,\n\n                                   const char *boot_device,\n\n                                   const char *kernel_cmdline,\n\n                                   long hash_shift)\n\n{\n\n    void *fdt;\n\n    CPUState *env;\n\n    uint64_t mem_reg_property[2];\n\n    uint32_t start_prop = cpu_to_be32(initrd_base);\n\n    uint32_t end_prop = cpu_to_be32(initrd_base + initrd_size);\n\n    uint32_t pft_size_prop[] = {0, cpu_to_be32(hash_shift)};\n\n    char hypertas_prop[] = \"hcall-pft\\0hcall-term\\0hcall-dabr\\0hcall-interrupt\"\n\n        \"\\0hcall-tce\\0hcall-vio\\0hcall-splpar\\0hcall-bulk\";\n\n    uint32_t interrupt_server_ranges_prop[] = {0, cpu_to_be32(smp_cpus)};\n\n    int i;\n\n    char *modelname;\n\n    int smt = kvmppc_smt_threads();\n\n    unsigned char vec5[] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x80};\n\n    uint32_t refpoints[] = {cpu_to_be32(0x4), cpu_to_be32(0x4)};\n\n    uint32_t associativity[] = {cpu_to_be32(0x4), cpu_to_be32(0x0),\n\n                                cpu_to_be32(0x0), cpu_to_be32(0x0),\n\n                                cpu_to_be32(0x0)};\n\n    char mem_name[32];\n\n    target_phys_addr_t node0_size, mem_start;\n\n\n\n#define _FDT(exp) \\\n\n    do { \\\n\n        int ret = (exp);                                           \\\n\n        if (ret < 0) {                                             \\\n\n            fprintf(stderr, \"qemu: error creating device tree: %s: %s\\n\", \\\n\n                    #exp, fdt_strerror(ret));                      \\\n\n            exit(1);                                               \\\n\n        }                                                          \\\n\n    } while (0)\n\n\n\n    fdt = g_malloc0(FDT_MAX_SIZE);\n\n    _FDT((fdt_create(fdt, FDT_MAX_SIZE)));\n\n\n\n    _FDT((fdt_finish_reservemap(fdt)));\n\n\n\n    /* Root node */\n\n    _FDT((fdt_begin_node(fdt, \"\")));\n\n    _FDT((fdt_property_string(fdt, \"device_type\", \"chrp\")));\n\n    _FDT((fdt_property_string(fdt, \"model\", \"IBM pSeries (emulated by qemu)\")));\n\n\n\n    _FDT((fdt_property_cell(fdt, \"#address-cells\", 0x2)));\n\n    _FDT((fdt_property_cell(fdt, \"#size-cells\", 0x2)));\n\n\n\n    /* /chosen */\n\n    _FDT((fdt_begin_node(fdt, \"chosen\")));\n\n\n\n    /* Set Form1_affinity */\n\n    _FDT((fdt_property(fdt, \"ibm,architecture-vec-5\", vec5, sizeof(vec5))));\n\n\n\n    _FDT((fdt_property_string(fdt, \"bootargs\", kernel_cmdline)));\n\n    _FDT((fdt_property(fdt, \"linux,initrd-start\",\n\n                       &start_prop, sizeof(start_prop))));\n\n    _FDT((fdt_property(fdt, \"linux,initrd-end\",\n\n                       &end_prop, sizeof(end_prop))));\n\n    _FDT((fdt_property_string(fdt, \"qemu,boot-device\", boot_device)));\n\n\n\n    /*\n\n     * Because we don't always invoke any firmware, we can't rely on\n\n     * that to do BAR allocation.  Long term, we should probably do\n\n     * that ourselves, but for now, this setting (plus advertising the\n\n     * current BARs as 0) causes sufficiently recent kernels to to the\n\n     * BAR assignment themselves */\n\n    _FDT((fdt_property_cell(fdt, \"linux,pci-probe-only\", 0)));\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* memory node(s) */\n\n    node0_size = (nb_numa_nodes > 1) ? node_mem[0] : ram_size;\n\n    if (rma_size > node0_size) {\n\n        rma_size = node0_size;\n\n    }\n\n\n\n    /* RMA */\n\n    mem_reg_property[0] = 0;\n\n    mem_reg_property[1] = cpu_to_be64(rma_size);\n\n    _FDT((fdt_begin_node(fdt, \"memory@0\")));\n\n    _FDT((fdt_property_string(fdt, \"device_type\", \"memory\")));\n\n    _FDT((fdt_property(fdt, \"reg\", mem_reg_property,\n\n        sizeof(mem_reg_property))));\n\n    _FDT((fdt_property(fdt, \"ibm,associativity\", associativity,\n\n        sizeof(associativity))));\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* RAM: Node 0 */\n\n    if (node0_size > rma_size) {\n\n        mem_reg_property[0] = cpu_to_be64(rma_size);\n\n        mem_reg_property[1] = cpu_to_be64(node0_size - rma_size);\n\n\n\n        sprintf(mem_name, \"memory@\" TARGET_FMT_lx, rma_size);\n\n        _FDT((fdt_begin_node(fdt, mem_name)));\n\n        _FDT((fdt_property_string(fdt, \"device_type\", \"memory\")));\n\n        _FDT((fdt_property(fdt, \"reg\", mem_reg_property,\n\n                           sizeof(mem_reg_property))));\n\n        _FDT((fdt_property(fdt, \"ibm,associativity\", associativity,\n\n                           sizeof(associativity))));\n\n        _FDT((fdt_end_node(fdt)));\n\n    }\n\n\n\n    /* RAM: Node 1 and beyond */\n\n    mem_start = node0_size;\n\n    for (i = 1; i < nb_numa_nodes; i++) {\n\n        mem_reg_property[0] = cpu_to_be64(mem_start);\n\n        mem_reg_property[1] = cpu_to_be64(node_mem[i]);\n\n        associativity[3] = associativity[4] = cpu_to_be32(i);\n\n        sprintf(mem_name, \"memory@\" TARGET_FMT_lx, mem_start);\n\n        _FDT((fdt_begin_node(fdt, mem_name)));\n\n        _FDT((fdt_property_string(fdt, \"device_type\", \"memory\")));\n\n        _FDT((fdt_property(fdt, \"reg\", mem_reg_property,\n\n            sizeof(mem_reg_property))));\n\n        _FDT((fdt_property(fdt, \"ibm,associativity\", associativity,\n\n            sizeof(associativity))));\n\n        _FDT((fdt_end_node(fdt)));\n\n        mem_start += node_mem[i];\n\n    }\n\n\n\n    /* cpus */\n\n    _FDT((fdt_begin_node(fdt, \"cpus\")));\n\n\n\n    _FDT((fdt_property_cell(fdt, \"#address-cells\", 0x1)));\n\n    _FDT((fdt_property_cell(fdt, \"#size-cells\", 0x0)));\n\n\n\n    modelname = g_strdup(cpu_model);\n\n\n\n    for (i = 0; i < strlen(modelname); i++) {\n\n        modelname[i] = toupper(modelname[i]);\n\n    }\n\n\n\n    /* This is needed during FDT finalization */\n\n    spapr->cpu_model = g_strdup(modelname);\n\n\n\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n\n        int index = env->cpu_index;\n\n        uint32_t servers_prop[smp_threads];\n\n        uint32_t gservers_prop[smp_threads * 2];\n\n        char *nodename;\n\n        uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40),\n\n                           0xffffffff, 0xffffffff};\n\n        uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq() : TIMEBASE_FREQ;\n\n        uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000;\n\n\n\n        if ((index % smt) != 0) {\n\n            continue;\n\n        }\n\n\n\n        if (asprintf(&nodename, \"%s@%x\", modelname, index) < 0) {\n\n            fprintf(stderr, \"Allocation failure\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        _FDT((fdt_begin_node(fdt, nodename)));\n\n\n\n        free(nodename);\n\n\n\n        _FDT((fdt_property_cell(fdt, \"reg\", index)));\n\n        _FDT((fdt_property_string(fdt, \"device_type\", \"cpu\")));\n\n\n\n        _FDT((fdt_property_cell(fdt, \"cpu-version\", env->spr[SPR_PVR])));\n\n        _FDT((fdt_property_cell(fdt, \"dcache-block-size\",\n\n                                env->dcache_line_size)));\n\n        _FDT((fdt_property_cell(fdt, \"icache-block-size\",\n\n                                env->icache_line_size)));\n\n        _FDT((fdt_property_cell(fdt, \"timebase-frequency\", tbfreq)));\n\n        _FDT((fdt_property_cell(fdt, \"clock-frequency\", cpufreq)));\n\n        _FDT((fdt_property_cell(fdt, \"ibm,slb-size\", env->slb_nr)));\n\n        _FDT((fdt_property(fdt, \"ibm,pft-size\",\n\n                           pft_size_prop, sizeof(pft_size_prop))));\n\n        _FDT((fdt_property_string(fdt, \"status\", \"okay\")));\n\n        _FDT((fdt_property(fdt, \"64-bit\", NULL, 0)));\n\n\n\n        /* Build interrupt servers and gservers properties */\n\n        for (i = 0; i < smp_threads; i++) {\n\n            servers_prop[i] = cpu_to_be32(index + i);\n\n            /* Hack, direct the group queues back to cpu 0 */\n\n            gservers_prop[i*2] = cpu_to_be32(index + i);\n\n            gservers_prop[i*2 + 1] = 0;\n\n        }\n\n        _FDT((fdt_property(fdt, \"ibm,ppc-interrupt-server#s\",\n\n                           servers_prop, sizeof(servers_prop))));\n\n        _FDT((fdt_property(fdt, \"ibm,ppc-interrupt-gserver#s\",\n\n                           gservers_prop, sizeof(gservers_prop))));\n\n\n\n        if (env->mmu_model & POWERPC_MMU_1TSEG) {\n\n            _FDT((fdt_property(fdt, \"ibm,processor-segment-sizes\",\n\n                               segs, sizeof(segs))));\n\n        }\n\n\n\n        /* Advertise VMX/VSX (vector extensions) if available\n\n         *   0 / no property == no vector extensions\n\n         *   1               == VMX / Altivec available\n\n         *   2               == VSX available */\n\n        if (env->insns_flags & PPC_ALTIVEC) {\n\n            uint32_t vmx = (env->insns_flags2 & PPC2_VSX) ? 2 : 1;\n\n\n\n            _FDT((fdt_property_cell(fdt, \"ibm,vmx\", vmx)));\n\n        }\n\n\n\n        /* Advertise DFP (Decimal Floating Point) if available\n\n         *   0 / no property == no DFP\n\n         *   1               == DFP available */\n\n        if (env->insns_flags2 & PPC2_DFP) {\n\n            _FDT((fdt_property_cell(fdt, \"ibm,dfp\", 1)));\n\n        }\n\n\n\n        _FDT((fdt_end_node(fdt)));\n\n    }\n\n\n\n    g_free(modelname);\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* RTAS */\n\n    _FDT((fdt_begin_node(fdt, \"rtas\")));\n\n\n\n    _FDT((fdt_property(fdt, \"ibm,hypertas-functions\", hypertas_prop,\n\n                       sizeof(hypertas_prop))));\n\n\n\n    _FDT((fdt_property(fdt, \"ibm,associativity-reference-points\",\n\n        refpoints, sizeof(refpoints))));\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* interrupt controller */\n\n    _FDT((fdt_begin_node(fdt, \"interrupt-controller\")));\n\n\n\n    _FDT((fdt_property_string(fdt, \"device_type\",\n\n                              \"PowerPC-External-Interrupt-Presentation\")));\n\n    _FDT((fdt_property_string(fdt, \"compatible\", \"IBM,ppc-xicp\")));\n\n    _FDT((fdt_property(fdt, \"interrupt-controller\", NULL, 0)));\n\n    _FDT((fdt_property(fdt, \"ibm,interrupt-server-ranges\",\n\n                       interrupt_server_ranges_prop,\n\n                       sizeof(interrupt_server_ranges_prop))));\n\n    _FDT((fdt_property_cell(fdt, \"#interrupt-cells\", 2)));\n\n    _FDT((fdt_property_cell(fdt, \"linux,phandle\", PHANDLE_XICP)));\n\n    _FDT((fdt_property_cell(fdt, \"phandle\", PHANDLE_XICP)));\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* vdevice */\n\n    _FDT((fdt_begin_node(fdt, \"vdevice\")));\n\n\n\n    _FDT((fdt_property_string(fdt, \"device_type\", \"vdevice\")));\n\n    _FDT((fdt_property_string(fdt, \"compatible\", \"IBM,vdevice\")));\n\n    _FDT((fdt_property_cell(fdt, \"#address-cells\", 0x1)));\n\n    _FDT((fdt_property_cell(fdt, \"#size-cells\", 0x0)));\n\n    _FDT((fdt_property_cell(fdt, \"#interrupt-cells\", 0x2)));\n\n    _FDT((fdt_property(fdt, \"interrupt-controller\", NULL, 0)));\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    _FDT((fdt_end_node(fdt))); /* close root node */\n\n    _FDT((fdt_finish(fdt)));\n\n\n\n    return fdt;\n\n}\n", "idx": 24645}
{"project": "qemu", "commit_id": "e957f6a9b92439a222ecd4ff1c8cdc9700710c72", "target": 1, "func": "static void spapr_populate_cpu_dt(CPUState *cs, void *fdt, int offset,\n\n                                  sPAPRMachineState *spapr)\n\n{\n\n    PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n    CPUPPCState *env = &cpu->env;\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cs);\n\n    int index = ppc_get_vcpu_dt_id(cpu);\n\n    uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40),\n\n                       0xffffffff, 0xffffffff};\n\n    uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq()\n\n        : SPAPR_TIMEBASE_FREQ;\n\n    uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000;\n\n    uint32_t page_sizes_prop[64];\n\n    size_t page_sizes_prop_size;\n\n    uint32_t vcpus_per_socket = smp_threads * smp_cores;\n\n    uint32_t pft_size_prop[] = {0, cpu_to_be32(spapr->htab_shift)};\n\n    int compat_smt = MIN(smp_threads, ppc_compat_max_threads(cpu));\n\n    sPAPRDRConnector *drc;\n\n    sPAPRDRConnectorClass *drck;\n\n    int drc_index;\n\n    uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ];\n\n    int i;\n\n\n\n    drc = spapr_dr_connector_by_id(SPAPR_DR_CONNECTOR_TYPE_CPU, index);\n\n    if (drc) {\n\n        drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n        drc_index = drck->get_index(drc);\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,my-drc-index\", drc_index)));\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"reg\", index)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"device_type\", \"cpu\")));\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"cpu-version\", env->spr[SPR_PVR])));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-block-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-line-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-block-size\",\n\n                           env->icache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-line-size\",\n\n                           env->icache_line_size)));\n\n\n\n    if (pcc->l1_dcache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-size\",\n\n                               pcc->l1_dcache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 dcache size for cpu\");\n\n    }\n\n    if (pcc->l1_icache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-size\",\n\n                               pcc->l1_icache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 icache size for cpu\");\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"timebase-frequency\", tbfreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"clock-frequency\", cpufreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"status\", \"okay\")));\n\n    _FDT((fdt_setprop(fdt, offset, \"64-bit\", NULL, 0)));\n\n\n\n    if (env->spr_cb[SPR_PURR].oea_read) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,purr\", NULL, 0)));\n\n    }\n\n\n\n    if (env->mmu_model & POWERPC_MMU_1TSEG) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-segment-sizes\",\n\n                          segs, sizeof(segs))));\n\n    }\n\n\n\n    /* Advertise VMX/VSX (vector extensions) if available\n\n     *   0 / no property == no vector extensions\n\n     *   1               == VMX / Altivec available\n\n     *   2               == VSX available */\n\n    if (env->insns_flags & PPC_ALTIVEC) {\n\n        uint32_t vmx = (env->insns_flags2 & PPC2_VSX) ? 2 : 1;\n\n\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,vmx\", vmx)));\n\n    }\n\n\n\n    /* Advertise DFP (Decimal Floating Point) if available\n\n     *   0 / no property == no DFP\n\n     *   1               == DFP available */\n\n    if (env->insns_flags2 & PPC2_DFP) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,dfp\", 1)));\n\n    }\n\n\n\n    page_sizes_prop_size = ppc_create_page_sizes_prop(env, page_sizes_prop,\n\n                                                  sizeof(page_sizes_prop));\n\n    if (page_sizes_prop_size) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,segment-page-sizes\",\n\n                          page_sizes_prop, page_sizes_prop_size)));\n\n    }\n\n\n\n    spapr_populate_pa_features(env, fdt, offset);\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,chip-id\",\n\n                           cs->cpu_index / vcpus_per_socket)));\n\n\n\n    _FDT((fdt_setprop(fdt, offset, \"ibm,pft-size\",\n\n                      pft_size_prop, sizeof(pft_size_prop))));\n\n\n\n    _FDT(spapr_fixup_cpu_numa_dt(fdt, offset, cs));\n\n\n\n    _FDT(spapr_fixup_cpu_smt_dt(fdt, offset, cpu, compat_smt));\n\n\n\n    if (pcc->radix_page_info) {\n\n        for (i = 0; i < pcc->radix_page_info->count; i++) {\n\n            radix_AP_encodings[i] =\n\n                cpu_to_be32(pcc->radix_page_info->entries[i]);\n\n        }\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-radix-AP-encodings\",\n\n                          radix_AP_encodings,\n\n                          pcc->radix_page_info->count *\n\n                          sizeof(radix_AP_encodings[0]))));\n\n    }\n\n}\n", "idx": 24648}
{"project": "qemu", "commit_id": "6c8d56a2e95712a6206a2671d2b04b2e59cabc0b", "target": 1, "func": "static uint8_t fw_cfg_read(FWCfgState *s)\n\n{\n\n    int arch = !!(s->cur_entry & FW_CFG_ARCH_LOCAL);\n\n    FWCfgEntry *e = (s->cur_entry == FW_CFG_INVALID) ? NULL :\n\n                    &s->entries[arch][s->cur_entry & FW_CFG_ENTRY_MASK];\n\n    uint8_t ret;\n\n\n\n    if (s->cur_entry == FW_CFG_INVALID || !e->data || s->cur_offset >= e->len)\n\n        ret = 0;\n\n    else {\n\n        ret = e->data[s->cur_offset++];\n\n    }\n\n\n\n    trace_fw_cfg_read(s, ret);\n\n    return ret;\n\n}\n", "idx": 24649}
{"project": "qemu", "commit_id": "698bdfa07d66b5ec218a60229e58eae1dcde00e5", "target": 1, "func": "void qmp_block_resize(bool has_device, const char *device,\n\n                      bool has_node_name, const char *node_name,\n\n                      int64_t size, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    BlockBackend *blk = NULL;\n\n    BlockDriverState *bs;\n\n    AioContext *aio_context;\n\n    int ret;\n\n\n\n    bs = bdrv_lookup_bs(has_device ? device : NULL,\n\n                        has_node_name ? node_name : NULL,\n\n                        &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n\n\n    if (!bdrv_is_first_non_filter(bs)) {\n\n        error_setg(errp, QERR_FEATURE_DISABLED, \"resize\");\n\n        goto out;\n\n    }\n\n\n\n    if (size < 0) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"size\", \"a >0 size\");\n\n        goto out;\n\n    }\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_RESIZE, NULL)) {\n\n        error_setg(errp, QERR_DEVICE_IN_USE, device);\n\n        goto out;\n\n    }\n\n\n\n    blk = blk_new(BLK_PERM_RESIZE, BLK_PERM_ALL);\n\n    ret = blk_insert_bs(blk, bs, errp);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    /* complete all in-flight operations before resizing the device */\n\n    bdrv_drain_all();\n\n\n\n    ret = blk_truncate(blk, size, errp);\n\n\n\nout:\n\n    blk_unref(blk);\n\n    aio_context_release(aio_context);\n\n}\n", "idx": 24650}
{"project": "qemu", "commit_id": "e61da14d60ba1cceacad8396adcb9662c7f690af", "target": 1, "func": "static void handle_control_message(VirtIOSerial *vser, void *buf)\n\n{\n\n    struct VirtIOSerialPort *port;\n\n    struct virtio_console_control cpkt, *gcpkt;\n\n    uint8_t *buffer;\n\n    size_t buffer_len;\n\n\n\n    gcpkt = buf;\n\n\n\n    cpkt.event = lduw_p(&gcpkt->event);\n\n    cpkt.value = lduw_p(&gcpkt->value);\n\n\n\n    port = find_port_by_id(vser, ldl_p(&gcpkt->id));\n\n    if (!port && cpkt.event != VIRTIO_CONSOLE_DEVICE_READY)\n\n        return;\n\n\n\n    switch(cpkt.event) {\n\n    case VIRTIO_CONSOLE_DEVICE_READY:\n\n        if (!cpkt.value) {\n\n            error_report(\"virtio-serial-bus: Guest failure in adding device %s\\n\",\n\n                         vser->bus->qbus.name);\n\n            break;\n\n        }\n\n        /*\n\n         * The device is up, we can now tell the device about all the\n\n         * ports we have here.\n\n         */\n\n        QTAILQ_FOREACH(port, &vser->ports, next) {\n\n            send_control_event(port, VIRTIO_CONSOLE_PORT_ADD, 1);\n\n        }\n\n        break;\n\n\n\n    case VIRTIO_CONSOLE_PORT_READY:\n\n        if (!cpkt.value) {\n\n            error_report(\"virtio-serial-bus: Guest failure in adding port %u for device %s\\n\",\n\n                         port->id, vser->bus->qbus.name);\n\n            break;\n\n        }\n\n        /*\n\n         * Now that we know the guest asked for the port name, we're\n\n         * sure the guest has initialised whatever state is necessary\n\n         * for this port. Now's a good time to let the guest know if\n\n         * this port is a console port so that the guest can hook it\n\n         * up to hvc.\n\n         */\n\n        if (port->is_console) {\n\n            send_control_event(port, VIRTIO_CONSOLE_CONSOLE_PORT, 1);\n\n        }\n\n\n\n        if (port->name) {\n\n            stw_p(&cpkt.event, VIRTIO_CONSOLE_PORT_NAME);\n\n            stw_p(&cpkt.value, 1);\n\n\n\n            buffer_len = sizeof(cpkt) + strlen(port->name) + 1;\n\n            buffer = qemu_malloc(buffer_len);\n\n\n\n            memcpy(buffer, &cpkt, sizeof(cpkt));\n\n            memcpy(buffer + sizeof(cpkt), port->name, strlen(port->name));\n\n            buffer[buffer_len - 1] = 0;\n\n\n\n            send_control_msg(port, buffer, buffer_len);\n\n            qemu_free(buffer);\n\n        }\n\n\n\n        if (port->host_connected) {\n\n            send_control_event(port, VIRTIO_CONSOLE_PORT_OPEN, 1);\n\n        }\n\n\n\n        /*\n\n         * When the guest has asked us for this information it means\n\n         * the guest is all setup and has its virtqueues\n\n         * initialised. If some app is interested in knowing about\n\n         * this event, let it know.\n\n         */\n\n        if (port->info->guest_ready) {\n\n            port->info->guest_ready(port);\n\n        }\n\n        break;\n\n\n\n    case VIRTIO_CONSOLE_PORT_OPEN:\n\n        port->guest_connected = cpkt.value;\n\n        if (cpkt.value && port->info->guest_open) {\n\n            /* Send the guest opened notification if an app is interested */\n\n            port->info->guest_open(port);\n\n        }\n\n\n\n        if (!cpkt.value && port->info->guest_close) {\n\n            /* Send the guest closed notification if an app is interested */\n\n            port->info->guest_close(port);\n\n        }\n\n        break;\n\n    }\n\n}\n", "idx": 24652}
{"project": "qemu", "commit_id": "acaa75507b34f7b588924a09c76c6848d209e08c", "target": 1, "func": "static void set_seg(struct kvm_segment *lhs, const SegmentCache *rhs)\n\n{\n\n    unsigned flags = rhs->flags;\n\n    lhs->selector = rhs->selector;\n\n    lhs->base = rhs->base;\n\n    lhs->limit = rhs->limit;\n\n    lhs->type = (flags >> DESC_TYPE_SHIFT) & 15;\n\n    lhs->present = (flags & DESC_P_MASK) != 0;\n\n    lhs->dpl = rhs->selector & 3;\n\n    lhs->db = (flags >> DESC_B_SHIFT) & 1;\n\n    lhs->s = (flags & DESC_S_MASK) != 0;\n\n    lhs->l = (flags >> DESC_L_SHIFT) & 1;\n\n    lhs->g = (flags & DESC_G_MASK) != 0;\n\n    lhs->avl = (flags & DESC_AVL_MASK) != 0;\n\n    lhs->unusable = 0;\n\n}\n", "idx": 24656}
{"project": "qemu", "commit_id": "de82815db1c89da058b7fb941dab137d6d9ab738", "target": 1, "func": "int qcow2_grow_l1_table(BlockDriverState *bs, uint64_t min_size,\n\n                        bool exact_size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int new_l1_size2, ret, i;\n\n    uint64_t *new_l1_table;\n\n    int64_t old_l1_table_offset, old_l1_size;\n\n    int64_t new_l1_table_offset, new_l1_size;\n\n    uint8_t data[12];\n\n\n\n    if (min_size <= s->l1_size)\n\n        return 0;\n\n\n\n    /* Do a sanity check on min_size before trying to calculate new_l1_size\n\n     * (this prevents overflows during the while loop for the calculation of\n\n     * new_l1_size) */\n\n    if (min_size > INT_MAX / sizeof(uint64_t)) {\n\n        return -EFBIG;\n\n    }\n\n\n\n    if (exact_size) {\n\n        new_l1_size = min_size;\n\n    } else {\n\n        /* Bump size up to reduce the number of times we have to grow */\n\n        new_l1_size = s->l1_size;\n\n        if (new_l1_size == 0) {\n\n            new_l1_size = 1;\n\n        }\n\n        while (min_size > new_l1_size) {\n\n            new_l1_size = (new_l1_size * 3 + 1) / 2;\n\n        }\n\n    }\n\n\n\n    if (new_l1_size > INT_MAX / sizeof(uint64_t)) {\n\n        return -EFBIG;\n\n    }\n\n\n\n#ifdef DEBUG_ALLOC2\n\n    fprintf(stderr, \"grow l1_table from %d to %\" PRId64 \"\\n\",\n\n            s->l1_size, new_l1_size);\n\n#endif\n\n\n\n    new_l1_size2 = sizeof(uint64_t) * new_l1_size;\n\n    new_l1_table = g_malloc0(align_offset(new_l1_size2, 512));\n\n    memcpy(new_l1_table, s->l1_table, s->l1_size * sizeof(uint64_t));\n\n\n\n    /* write new table (align to cluster) */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_ALLOC_TABLE);\n\n    new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);\n\n    if (new_l1_table_offset < 0) {\n\n        g_free(new_l1_table);\n\n        return new_l1_table_offset;\n\n    }\n\n\n\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* the L1 position has not yet been updated, so these clusters must\n\n     * indeed be completely free */\n\n    ret = qcow2_pre_write_overlap_check(bs, 0, new_l1_table_offset,\n\n                                        new_l1_size2);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_WRITE_TABLE);\n\n    for(i = 0; i < s->l1_size; i++)\n\n        new_l1_table[i] = cpu_to_be64(new_l1_table[i]);\n\n    ret = bdrv_pwrite_sync(bs->file, new_l1_table_offset, new_l1_table, new_l1_size2);\n\n    if (ret < 0)\n\n        goto fail;\n\n    for(i = 0; i < s->l1_size; i++)\n\n        new_l1_table[i] = be64_to_cpu(new_l1_table[i]);\n\n\n\n    /* set new table */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_ACTIVATE_TABLE);\n\n    cpu_to_be32w((uint32_t*)data, new_l1_size);\n\n    stq_be_p(data + 4, new_l1_table_offset);\n\n    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, l1_size), data,sizeof(data));\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n    g_free(s->l1_table);\n\n    old_l1_table_offset = s->l1_table_offset;\n\n    s->l1_table_offset = new_l1_table_offset;\n\n    s->l1_table = new_l1_table;\n\n    old_l1_size = s->l1_size;\n\n    s->l1_size = new_l1_size;\n\n    qcow2_free_clusters(bs, old_l1_table_offset, old_l1_size * sizeof(uint64_t),\n\n                        QCOW2_DISCARD_OTHER);\n\n    return 0;\n\n fail:\n\n    g_free(new_l1_table);\n\n    qcow2_free_clusters(bs, new_l1_table_offset, new_l1_size2,\n\n                        QCOW2_DISCARD_OTHER);\n\n    return ret;\n\n}\n", "idx": 24661}
{"project": "qemu", "commit_id": "07caea315a85ebfe90851f9c2e4ef3fdd24117b5", "target": 1, "func": "static void r2d_init(ram_addr_t ram_size,\n\n              const char *boot_device,\n\n\t      const char *kernel_filename, const char *kernel_cmdline,\n\n\t      const char *initrd_filename, const char *cpu_model)\n\n{\n\n    CPUState *env;\n\n    struct SH7750State *s;\n\n    ram_addr_t sdram_addr;\n\n    qemu_irq *irq;\n\n    PCIBus *pci;\n\n    DriveInfo *dinfo;\n\n    int i;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"SH7751R\";\n\n\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Allocate memory space */\n\n    sdram_addr = qemu_ram_alloc(SDRAM_SIZE);\n\n    cpu_register_physical_memory(SDRAM_BASE, SDRAM_SIZE, sdram_addr);\n\n    /* Register peripherals */\n\n    s = sh7750_init(env);\n\n    irq = r2d_fpga_init(0x04000000, sh7750_irl(s));\n\n    pci = sh_pci_register_bus(r2d_pci_set_irq, r2d_pci_map_irq, irq, 0, 4);\n\n\n\n    sm501_init(0x10000000, SM501_VRAM_SIZE, irq[SM501], serial_hds[2]);\n\n\n\n    /* onboard CF (True IDE mode, Master only). */\n\n    if ((dinfo = drive_get(IF_IDE, 0, 0)) != NULL)\n\n\tmmio_ide_init(0x14001000, 0x1400080c, irq[CF_IDE], 1,\n\n\t\t      dinfo, NULL);\n\n\n\n    /* NIC: rtl8139 on-board, and 2 slots. */\n\n    for (i = 0; i < nb_nics; i++)\n\n        pci_nic_init(&nd_table[i], \"rtl8139\", i==0 ? \"2\" : NULL);\n\n\n\n    /* Todo: register on board registers */\n\n    if (kernel_filename) {\n\n      int kernel_size;\n\n      /* initialization which should be done by firmware */\n\n      stl_phys(SH7750_BCR1, 1<<3); /* cs3 SDRAM */\n\n      stw_phys(SH7750_BCR2, 3<<(3*2)); /* cs3 32bit */\n\n\n\n      if (kernel_cmdline) {\n\n          kernel_size = load_image_targphys(kernel_filename,\n\n\t\t\t\t   SDRAM_BASE + LINUX_LOAD_OFFSET,\n\n\t\t\t\t   SDRAM_SIZE - LINUX_LOAD_OFFSET);\n\n          env->pc = (SDRAM_BASE + LINUX_LOAD_OFFSET) | 0xa0000000;\n\n          pstrcpy_targphys(SDRAM_BASE + 0x10100, 256, kernel_cmdline);\n\n      } else {\n\n          kernel_size = load_image_targphys(kernel_filename, SDRAM_BASE, SDRAM_SIZE);\n\n          env->pc = SDRAM_BASE | 0xa0000000; /* Start from P2 area */\n\n      }\n\n\n\n      if (kernel_size < 0) {\n\n        fprintf(stderr, \"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n        exit(1);\n\n      }\n\n    }\n\n}\n", "idx": 24662}
{"project": "qemu", "commit_id": "3dcfb74fd4e4ab31508c80e6965a0cd477510234", "target": 1, "func": "void ppc_tlb_invalidate_one(CPUPPCState *env, target_ulong addr)\n\n{\n\n#if !defined(FLUSH_ALL_TLBS)\n\n    PowerPCCPU *cpu = ppc_env_get_cpu(env);\n\n    CPUState *cs;\n\n\n\n    addr &= TARGET_PAGE_MASK;\n\n    switch (env->mmu_model) {\n\n    case POWERPC_MMU_SOFT_6xx:\n\n    case POWERPC_MMU_SOFT_74xx:\n\n        ppc6xx_tlb_invalidate_virt(env, addr, 0);\n\n        if (env->id_tlbs == 1) {\n\n            ppc6xx_tlb_invalidate_virt(env, addr, 1);\n\n        }\n\n        break;\n\n    case POWERPC_MMU_32B:\n\n    case POWERPC_MMU_601:\n\n        /* tlbie invalidate TLBs for all segments */\n\n        addr &= ~((target_ulong)-1ULL << 28);\n\n        cs = CPU(cpu);\n\n        /* XXX: this case should be optimized,\n\n         * giving a mask to tlb_flush_page\n\n         */\n\n        /* This is broken, some CPUs invalidate a whole congruence\n\n         * class on an even smaller subset of bits and some OSes take\n\n         * advantage of this. Just blow the whole thing away.\n\n         */\n\n#if 0\n\n        tlb_flush_page(cs, addr | (0x0 << 28));\n\n        tlb_flush_page(cs, addr | (0x1 << 28));\n\n        tlb_flush_page(cs, addr | (0x2 << 28));\n\n        tlb_flush_page(cs, addr | (0x3 << 28));\n\n        tlb_flush_page(cs, addr | (0x4 << 28));\n\n        tlb_flush_page(cs, addr | (0x5 << 28));\n\n        tlb_flush_page(cs, addr | (0x6 << 28));\n\n        tlb_flush_page(cs, addr | (0x7 << 28));\n\n        tlb_flush_page(cs, addr | (0x8 << 28));\n\n        tlb_flush_page(cs, addr | (0x9 << 28));\n\n        tlb_flush_page(cs, addr | (0xA << 28));\n\n        tlb_flush_page(cs, addr | (0xB << 28));\n\n        tlb_flush_page(cs, addr | (0xC << 28));\n\n        tlb_flush_page(cs, addr | (0xD << 28));\n\n        tlb_flush_page(cs, addr | (0xE << 28));\n\n        tlb_flush_page(cs, addr | (0xF << 28));\n\n\n\n\n        break;\n\n#if defined(TARGET_PPC64)\n\n    case POWERPC_MMU_64B:\n\n    case POWERPC_MMU_2_03:\n\n    case POWERPC_MMU_2_06:\n\n    case POWERPC_MMU_2_06a:\n\n    case POWERPC_MMU_2_07:\n\n    case POWERPC_MMU_2_07a:\n\n        /* tlbie invalidate TLBs for all segments */\n\n        /* XXX: given the fact that there are too many segments to invalidate,\n\n         *      and we still don't have a tlb_flush_mask(env, n, mask) in QEMU,\n\n         *      we just invalidate all TLBs\n\n         */\n\n        env->tlb_need_flush = 1;\n\n        break;\n\n#endif /* defined(TARGET_PPC64) */\n\n    default:\n\n        /* Should never reach here with other MMU models */\n\n        assert(0);\n\n    }\n\n\n    ppc_tlb_invalidate_all(env);\n\n\n}", "idx": 24663}
{"project": "qemu", "commit_id": "ea9ebc2ce69198f7aca4b43652824c5d621ac978", "target": 1, "func": "static int qpa_init_in (HWVoiceIn *hw, struct audsettings *as)\n\n{\n\n    int error;\n\n    static pa_sample_spec ss;\n\n    struct audsettings obt_as = *as;\n\n    PAVoiceIn *pa = (PAVoiceIn *) hw;\n\n\n\n    ss.format = audfmt_to_pa (as->fmt, as->endianness);\n\n    ss.channels = as->nchannels;\n\n    ss.rate = as->freq;\n\n\n\n    obt_as.fmt = pa_to_audfmt (ss.format, &obt_as.endianness);\n\n\n\n    pa->s = pa_simple_new (\n\n        conf.server,\n\n        \"qemu\",\n\n        PA_STREAM_RECORD,\n\n        conf.source,\n\n        \"pcm.capture\",\n\n        &ss,\n\n        NULL,                   /* channel map */\n\n        NULL,                   /* buffering attributes */\n\n        &error\n\n        );\n\n    if (!pa->s) {\n\n        qpa_logerr (error, \"pa_simple_new for capture failed\\n\");\n\n        goto fail1;\n\n    }\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n    hw->samples = conf.samples;\n\n    pa->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);\n\n    pa->wpos = hw->wpos;\n\n    if (!pa->pcm_buf) {\n\n        dolog (\"Could not allocate buffer (%d bytes)\\n\",\n\n               hw->samples << hw->info.shift);\n\n        goto fail2;\n\n    }\n\n\n\n    if (audio_pt_init (&pa->pt, qpa_thread_in, hw, AUDIO_CAP, AUDIO_FUNC)) {\n\n        goto fail3;\n\n    }\n\n\n\n    return 0;\n\n\n\n fail3:\n\n    g_free (pa->pcm_buf);\n\n    pa->pcm_buf = NULL;\n\n fail2:\n\n    pa_simple_free (pa->s);\n\n    pa->s = NULL;\n\n fail1:\n\n    return -1;\n\n}\n", "idx": 24665}
{"project": "qemu", "commit_id": "02c4f26b1517d9e403ec10d6f6ca3c0276d19e43", "target": 1, "func": "int qed_check(BDRVQEDState *s, BdrvCheckResult *result, bool fix)\n\n{\n\n    QEDCheck check = {\n\n        .s = s,\n\n        .result = result,\n\n        .nclusters = qed_bytes_to_clusters(s, s->file_size),\n\n        .request = { .l2_table = NULL },\n\n        .fix = fix,\n\n    };\n\n    int ret;\n\n\n\n    check.used_clusters = g_try_malloc0(((check.nclusters + 31) / 32) *\n\n                                        sizeof(check.used_clusters[0]));\n\n    if (check.nclusters && check.used_clusters == NULL) {\n\n        return -ENOMEM;\n\n    }\n\n\n\n    check.result->bfi.total_clusters =\n\n        (s->header.image_size + s->header.cluster_size - 1) /\n\n            s->header.cluster_size;\n\n    ret = qed_check_l1_table(&check, s->l1_table);\n\n    if (ret == 0) {\n\n        /* Only check for leaks if entire image was scanned successfully */\n\n        qed_check_for_leaks(&check);\n\n\n\n        if (fix) {\n\n            qed_check_mark_clean(s, result);\n\n        }\n\n    }\n\n\n\n    g_free(check.used_clusters);\n\n    return ret;\n\n}\n", "idx": 24667}
{"project": "qemu", "commit_id": "c3109ba1b109f84929abbfe0462d910d5aa8617c", "target": 0, "func": "int load_flt_binary(struct linux_binprm * bprm, struct target_pt_regs * regs,\n\n                    struct image_info * info)\n\n{\n\n    struct lib_info libinfo[MAX_SHARED_LIBS];\n\n    abi_ulong p = bprm->p;\n\n    abi_ulong stack_len;\n\n    abi_ulong start_addr;\n\n    abi_ulong sp;\n\n    int res;\n\n    int i, j;\n\n\n\n    memset(libinfo, 0, sizeof(libinfo));\n\n    /*\n\n     * We have to add the size of our arguments to our stack size\n\n     * otherwise it's too easy for users to create stack overflows\n\n     * by passing in a huge argument list.  And yes,  we have to be\n\n     * pedantic and include space for the argv/envp array as it may have\n\n     * a lot of entries.\n\n     */\n\n    stack_len = 0;\n\n    for (i = 0; i < bprm->argc; ++i) {\n\n        /* the argv strings */\n\n        stack_len += strlen(bprm->argv[i]);\n\n    }\n\n    for (i = 0; i < bprm->envc; ++i) {\n\n        /* the envp strings */\n\n        stack_len += strlen(bprm->envp[i]);\n\n    }\n\n    stack_len += (bprm->argc + 1) * 4; /* the argv array */\n\n    stack_len += (bprm->envc + 1) * 4; /* the envp array */\n\n\n\n\n\n    res = load_flat_file(bprm, libinfo, 0, &stack_len);\n\n    if (res > (unsigned long)-4096)\n\n            return res;\n\n\n\n    /* Update data segment pointers for all libraries */\n\n    for (i=0; i<MAX_SHARED_LIBS; i++) {\n\n        if (libinfo[i].loaded) {\n\n            abi_ulong p;\n\n            p = libinfo[i].start_data;\n\n            for (j=0; j<MAX_SHARED_LIBS; j++) {\n\n                p -= 4;\n\n                /* FIXME - handle put_user() failures */\n\n                if (put_user_ual(libinfo[j].loaded\n\n                                 ? libinfo[j].start_data\n\n                                 : UNLOADED_LIB,\n\n                                 p))\n\n                    return -EFAULT;\n\n            }\n\n        }\n\n    }\n\n\n\n    p = ((libinfo[0].start_brk + stack_len + 3) & ~3) - 4;\n\n    DBG_FLT(\"p=%x\\n\", (int)p);\n\n\n\n    /* Copy argv/envp.  */\n\n    p = copy_strings(p, bprm->envc, bprm->envp);\n\n    p = copy_strings(p, bprm->argc, bprm->argv);\n\n    /* Align stack.  */\n\n    sp = p & ~(abi_ulong)(sizeof(abi_ulong) - 1);\n\n    /* Enforce final stack alignment of 16 bytes.  This is sufficient\n\n       for all current targets, and excess alignment is harmless.  */\n\n    stack_len = bprm->envc + bprm->argc + 2;\n\n    stack_len += 3;\t/* argc, arvg, argp */\n\n    stack_len *= sizeof(abi_ulong);\n\n    if ((sp + stack_len) & 15)\n\n        sp -= 16 - ((sp + stack_len) & 15);\n\n    sp = loader_build_argptr(bprm->envc, bprm->argc, sp, p, 1);\n\n\n\n    /* Fake some return addresses to ensure the call chain will\n\n     * initialise library in order for us.  We are required to call\n\n     * lib 1 first, then 2, ... and finally the main program (id 0).\n\n     */\n\n    start_addr = libinfo[0].entry;\n\n\n\n#ifdef CONFIG_BINFMT_SHARED_FLAT\n\n#error here\n\n    for (i = MAX_SHARED_LIBS-1; i>0; i--) {\n\n            if (libinfo[i].loaded) {\n\n                    /* Push previos first to call address */\n\n                    --sp;\n\n                    if (put_user_ual(start_addr, sp))\n\n                        return -EFAULT;\n\n                    start_addr = libinfo[i].entry;\n\n            }\n\n    }\n\n#endif\n\n\n\n    /* Stash our initial stack pointer into the mm structure */\n\n    info->start_code = libinfo[0].start_code;\n\n    info->end_code = libinfo[0].start_code = libinfo[0].text_len;\n\n    info->start_data = libinfo[0].start_data;\n\n    info->end_data = libinfo[0].end_data;\n\n    info->start_brk = libinfo[0].start_brk;\n\n    info->start_stack = sp;\n\n    info->stack_limit = libinfo[0].start_brk;\n\n    info->entry = start_addr;\n\n    info->code_offset = info->start_code;\n\n    info->data_offset = info->start_data - libinfo[0].text_len;\n\n\n\n    DBG_FLT(\"start_thread(entry=0x%x, start_stack=0x%x)\\n\",\n\n            (int)info->entry, (int)info->start_stack);\n\n\n\n    return 0;\n\n}\n", "idx": 24676}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static always_inline void gen_farith2 (void *helper,\n\n                                       int rb, int rc)\n\n{\n\n    if (unlikely(rc == 31))\n\n      return;\n\n\n\n    if (rb != 31)\n\n        tcg_gen_helper_1_1(helper, cpu_fir[rc], cpu_fir[rb]);\n\n    else {\n\n        TCGv tmp = tcg_const_i64(0);\n\n        tcg_gen_helper_1_1(helper, cpu_fir[rc], tmp);\n\n        tcg_temp_free(tmp);\n\n    }\n\n}\n", "idx": 24678}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static void qio_channel_socket_connect_worker(QIOTask *task,\n\n                                              gpointer opaque)\n\n{\n\n    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(qio_task_get_source(task));\n\n    SocketAddress *addr = opaque;\n\n    Error *err = NULL;\n\n\n\n    qio_channel_socket_connect_sync(ioc, addr, &err);\n\n\n\n    qio_task_set_error(task, err);\n\n}\n", "idx": 24679}
{"project": "qemu", "commit_id": "e1f8c729fa890c67bb4532f22c22ace6fb0e1aaf", "target": 0, "func": "void pxa27x_timer_init(target_phys_addr_t base,\n\n                qemu_irq *irqs, qemu_irq irq4)\n\n{\n\n    pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);\n\n    int i;\n\n    s->freq = PXA27X_FREQ;\n\n    s->tm4 = (PXA2xxTimer4 *) qemu_mallocz(8 *\n\n                    sizeof(PXA2xxTimer4));\n\n    for (i = 0; i < 8; i ++) {\n\n        s->tm4[i].tm.value = 0;\n\n        s->tm4[i].tm.irq = irq4;\n\n        s->tm4[i].tm.info = s;\n\n        s->tm4[i].tm.num = i + 4;\n\n        s->tm4[i].tm.level = 0;\n\n        s->tm4[i].freq = 0;\n\n        s->tm4[i].control = 0x0;\n\n        s->tm4[i].tm.qtimer = qemu_new_timer(vm_clock,\n\n                        pxa2xx_timer_tick4, &s->tm4[i]);\n\n    }\n\n}\n", "idx": 24680}
{"project": "qemu", "commit_id": "c169998802505c244b8bcad562633f29de7d74a4", "target": 0, "func": "static void serial_init_core(SerialState *s)\n\n{\n\n    if (!s->chr) {\n\n        fprintf(stderr, \"Can't create serial device, empty char device\\n\");\n\n\texit(1);\n\n    }\n\n\n\n    s->modem_status_poll = qemu_new_timer(vm_clock, (QEMUTimerCB *) serial_update_msl, s);\n\n\n\n    s->fifo_timeout_timer = qemu_new_timer(vm_clock, (QEMUTimerCB *) fifo_timeout_int, s);\n\n    s->transmit_timer = qemu_new_timer(vm_clock, (QEMUTimerCB *) serial_xmit, s);\n\n\n\n    qemu_register_reset(serial_reset, s);\n\n    serial_reset(s);\n\n\n\n    qemu_chr_add_handlers(s->chr, serial_can_receive1, serial_receive1,\n\n                          serial_event, s);\n\n}\n", "idx": 24681}
{"project": "qemu", "commit_id": "550830f9351291c585c963204ad9127998b1c1ce", "target": 0, "func": "static int cow_update_bitmap(BlockDriverState *bs, int64_t sector_num,\n\n        int nb_sectors)\n\n{\n\n    int64_t bitnum = sector_num + sizeof(struct cow_header_v2) * 8;\n\n    uint64_t offset = (bitnum / 8) & -BDRV_SECTOR_SIZE;\n\n    bool first = true;\n\n    int sector_bits;\n\n\n\n    for ( ; nb_sectors;\n\n            bitnum += sector_bits,\n\n            nb_sectors -= sector_bits,\n\n            offset += BDRV_SECTOR_SIZE) {\n\n        int ret, set;\n\n        uint8_t bitmap[BDRV_SECTOR_SIZE];\n\n\n\n        bitnum &= BITS_PER_BITMAP_SECTOR - 1;\n\n        sector_bits = MIN(nb_sectors, BITS_PER_BITMAP_SECTOR - bitnum);\n\n\n\n        ret = bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap));\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        /* Skip over any already set bits */\n\n        set = cow_find_streak(bitmap, 1, bitnum, sector_bits);\n\n        bitnum += set;\n\n        sector_bits -= set;\n\n        nb_sectors -= set;\n\n        if (!sector_bits) {\n\n            continue;\n\n        }\n\n\n\n        if (first) {\n\n            ret = bdrv_flush(bs->file);\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n            first = false;\n\n        }\n\n\n\n        cow_set_bits(bitmap, bitnum, sector_bits);\n\n\n\n        ret = bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap));\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24682}
{"project": "qemu", "commit_id": "16905d717507d3daffa714c7f0fd5403873807b2", "target": 0, "func": "int bdrv_create_file(const char* filename, QEMUOptionParameter *options)\n\n{\n\n    BlockDriver *drv;\n\n\n\n    drv = bdrv_find_protocol(filename);\n\n    if (drv == NULL) {\n\n        drv = bdrv_find_format(\"file\");\n\n    }\n\n\n\n    return bdrv_create(drv, filename, options);\n\n}\n", "idx": 24683}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_acl_append(qemu_acl *acl,\n\n                    int deny,\n\n                    const char *match)\n\n{\n\n    qemu_acl_entry *entry;\n\n\n\n    entry = qemu_malloc(sizeof(*entry));\n\n    entry->match = qemu_strdup(match);\n\n    entry->deny = deny;\n\n\n\n    TAILQ_INSERT_TAIL(&acl->entries, entry, next);\n\n    acl->nentries++;\n\n\n\n    return acl->nentries;\n\n}\n", "idx": 24684}
{"project": "qemu", "commit_id": "0ba1f53191221b541b938df86a39eeccfb87f996", "target": 0, "func": "void virtio_scsi_common_realize(DeviceState *dev, Error **errp,\n\n                                HandleOutput ctrl, HandleOutput evt,\n\n                                HandleOutput cmd)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n    VirtIOSCSICommon *s = VIRTIO_SCSI_COMMON(dev);\n\n    int i;\n\n\n\n    virtio_init(vdev, \"virtio-scsi\", VIRTIO_ID_SCSI,\n\n                sizeof(VirtIOSCSIConfig));\n\n\n\n    if (s->conf.num_queues <= 0 || s->conf.num_queues > VIRTIO_PCI_QUEUE_MAX) {\n\n        error_setg(errp, \"Invalid number of queues (= %\" PRId32 \"), \"\n\n                         \"must be a positive integer less than %d.\",\n\n                   s->conf.num_queues, VIRTIO_PCI_QUEUE_MAX);\n\n        virtio_cleanup(vdev);\n\n        return;\n\n    }\n\n    s->cmd_vqs = g_malloc0(s->conf.num_queues * sizeof(VirtQueue *));\n\n    s->sense_size = VIRTIO_SCSI_SENSE_SIZE;\n\n    s->cdb_size = VIRTIO_SCSI_CDB_SIZE;\n\n\n\n    s->ctrl_vq = virtio_add_queue(vdev, VIRTIO_SCSI_VQ_SIZE,\n\n                                  ctrl);\n\n    s->event_vq = virtio_add_queue(vdev, VIRTIO_SCSI_VQ_SIZE,\n\n                                   evt);\n\n    for (i = 0; i < s->conf.num_queues; i++) {\n\n        s->cmd_vqs[i] = virtio_add_queue(vdev, VIRTIO_SCSI_VQ_SIZE,\n\n                                         cmd);\n\n    }\n\n\n\n    if (s->conf.iothread) {\n\n        virtio_scsi_set_iothread(VIRTIO_SCSI(s), s->conf.iothread);\n\n    }\n\n}\n", "idx": 24685}
{"project": "qemu", "commit_id": "2cac260768b9d4253737417ea7501cf2950e257f", "target": 0, "func": "static int write_elf32_load(DumpState *s, MemoryMapping *memory_mapping,\n\n                            int phdr_index, hwaddr offset)\n\n{\n\n    Elf32_Phdr phdr;\n\n    int ret;\n\n    int endian = s->dump_info.d_endian;\n\n\n\n    memset(&phdr, 0, sizeof(Elf32_Phdr));\n\n    phdr.p_type = cpu_convert_to_target32(PT_LOAD, endian);\n\n    phdr.p_offset = cpu_convert_to_target32(offset, endian);\n\n    phdr.p_paddr = cpu_convert_to_target32(memory_mapping->phys_addr, endian);\n\n    if (offset == -1) {\n\n        /* When the memory is not stored into vmcore, offset will be -1 */\n\n        phdr.p_filesz = 0;\n\n    } else {\n\n        phdr.p_filesz = cpu_convert_to_target32(memory_mapping->length, endian);\n\n    }\n\n    phdr.p_memsz = cpu_convert_to_target32(memory_mapping->length, endian);\n\n    phdr.p_vaddr = cpu_convert_to_target32(memory_mapping->virt_addr, endian);\n\n\n\n    ret = fd_write_vmcore(&phdr, sizeof(Elf32_Phdr), s);\n\n    if (ret < 0) {\n\n        dump_error(s, \"dump: failed to write program header table.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24686}
{"project": "qemu", "commit_id": "384acbf46b70edf0d2c1648aa1a92a90bcf7057d", "target": 0, "func": "static void qemu_laio_enqueue_completed(struct qemu_laio_state *s,\n\n    struct qemu_laiocb* laiocb)\n\n{\n\n    if (laiocb->async_context_id == get_async_context_id()) {\n\n        qemu_laio_process_completion(s, laiocb);\n\n    } else {\n\n        QLIST_INSERT_HEAD(&s->completed_reqs, laiocb, node);\n\n    }\n\n}\n", "idx": 24687}
{"project": "qemu", "commit_id": "cc9c1ed14e876d724107fe72f74dcac71a003fbc", "target": 0, "func": "static inline void gen_goto_tb(DisasContext *s, int n, uint64_t dest)\n\n{\n\n    TranslationBlock *tb;\n\n\n\n    tb = s->tb;\n\n    if (use_goto_tb(s, n, dest)) {\n\n        tcg_gen_goto_tb(n);\n\n        gen_a64_set_pc_im(dest);\n\n        tcg_gen_exit_tb((intptr_t)tb + n);\n\n        s->is_jmp = DISAS_TB_JUMP;\n\n    } else {\n\n        gen_a64_set_pc_im(dest);\n\n        if (s->singlestep_enabled) {\n\n            gen_exception_internal(EXCP_DEBUG);\n\n        }\n\n        tcg_gen_exit_tb(0);\n\n        s->is_jmp = DISAS_JUMP;\n\n    }\n\n}\n", "idx": 24689}
{"project": "qemu", "commit_id": "ba38ab8d429a326c2a9c30110df84f0cad441094", "target": 0, "func": "static void gen_spr_BookE206(CPUPPCState *env, uint32_t mas_mask,\n\n                              uint32_t *tlbncfg)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n    const char *mas_names[8] = {\n\n        \"MAS0\", \"MAS1\", \"MAS2\", \"MAS3\", \"MAS4\", \"MAS5\", \"MAS6\", \"MAS7\",\n\n    };\n\n    int mas_sprn[8] = {\n\n        SPR_BOOKE_MAS0, SPR_BOOKE_MAS1, SPR_BOOKE_MAS2, SPR_BOOKE_MAS3,\n\n        SPR_BOOKE_MAS4, SPR_BOOKE_MAS5, SPR_BOOKE_MAS6, SPR_BOOKE_MAS7,\n\n    };\n\n    int i;\n\n\n\n    /* TLB assist registers */\n\n    /* XXX : not implemented */\n\n    for (i = 0; i < 8; i++) {\n\n        if (mas_mask & (1 << i)) {\n\n            spr_register(env, mas_sprn[i], mas_names[i],\n\n                         SPR_NOACCESS, SPR_NOACCESS,\n\n                         &spr_read_generic, &spr_write_generic,\n\n                         0x00000000);\n\n        }\n\n    }\n\n    if (env->nb_pids > 1) {\n\n        /* XXX : not implemented */\n\n        spr_register(env, SPR_BOOKE_PID1, \"PID1\",\n\n                     SPR_NOACCESS, SPR_NOACCESS,\n\n                     &spr_read_generic, &spr_write_booke_pid,\n\n                     0x00000000);\n\n    }\n\n    if (env->nb_pids > 2) {\n\n        /* XXX : not implemented */\n\n        spr_register(env, SPR_BOOKE_PID2, \"PID2\",\n\n                     SPR_NOACCESS, SPR_NOACCESS,\n\n                     &spr_read_generic, &spr_write_booke_pid,\n\n                     0x00000000);\n\n    }\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_MMUCFG, \"MMUCFG\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, SPR_NOACCESS,\n\n                 0x00000000); /* TOFIX */\n\n    switch (env->nb_ways) {\n\n    case 4:\n\n        spr_register(env, SPR_BOOKE_TLB3CFG, \"TLB3CFG\",\n\n                     SPR_NOACCESS, SPR_NOACCESS,\n\n                     &spr_read_generic, SPR_NOACCESS,\n\n                     tlbncfg[3]);\n\n        /* Fallthru */\n\n    case 3:\n\n        spr_register(env, SPR_BOOKE_TLB2CFG, \"TLB2CFG\",\n\n                     SPR_NOACCESS, SPR_NOACCESS,\n\n                     &spr_read_generic, SPR_NOACCESS,\n\n                     tlbncfg[2]);\n\n        /* Fallthru */\n\n    case 2:\n\n        spr_register(env, SPR_BOOKE_TLB1CFG, \"TLB1CFG\",\n\n                     SPR_NOACCESS, SPR_NOACCESS,\n\n                     &spr_read_generic, SPR_NOACCESS,\n\n                     tlbncfg[1]);\n\n        /* Fallthru */\n\n    case 1:\n\n        spr_register(env, SPR_BOOKE_TLB0CFG, \"TLB0CFG\",\n\n                     SPR_NOACCESS, SPR_NOACCESS,\n\n                     &spr_read_generic, SPR_NOACCESS,\n\n                     tlbncfg[0]);\n\n        /* Fallthru */\n\n    case 0:\n\n    default:\n\n        break;\n\n    }\n\n#endif\n\n\n\n    gen_spr_usprgh(env);\n\n}\n", "idx": 24690}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static void vnc_tight_start(VncState *vs)\n\n{\n\n    buffer_reset(&vs->tight);\n\n\n\n    // make the output buffer be the zlib buffer, so we can compress it later\n\n    vs->tight_tmp = vs->output;\n\n    vs->output = vs->tight;\n\n}\n", "idx": 24691}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void error_mem_write(void *opaque, target_phys_addr_t addr,\n\n                            uint64_t value, unsigned size)\n\n{\n\n    abort();\n\n}\n", "idx": 24692}
{"project": "qemu", "commit_id": "37ad223c515da2fe9f1c679768cb5ccaa42e57e1", "target": 0, "func": "build_tpm_tcpa(GArray *table_data, GArray *linker, GArray *tcpalog)\n\n{\n\n    Acpi20Tcpa *tcpa = acpi_data_push(table_data, sizeof *tcpa);\n\n    uint64_t log_area_start_address = acpi_data_len(tcpalog);\n\n\n\n    tcpa->platform_class = cpu_to_le16(TPM_TCPA_ACPI_CLASS_CLIENT);\n\n    tcpa->log_area_minimum_length = cpu_to_le32(TPM_LOG_AREA_MINIMUM_SIZE);\n\n    tcpa->log_area_start_address = cpu_to_le64(log_area_start_address);\n\n\n\n    bios_linker_loader_alloc(linker, ACPI_BUILD_TPMLOG_FILE, 1,\n\n                             false /* high memory */);\n\n\n\n    /* log area start address to be filled by Guest linker */\n\n    bios_linker_loader_add_pointer(linker, ACPI_BUILD_TABLE_FILE,\n\n                                   ACPI_BUILD_TPMLOG_FILE,\n\n                                   table_data, &tcpa->log_area_start_address,\n\n                                   sizeof(tcpa->log_area_start_address));\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)tcpa, \"TCPA\", sizeof(*tcpa), 2, NULL);\n\n\n\n    acpi_data_push(tcpalog, TPM_LOG_AREA_MINIMUM_SIZE);\n\n}\n", "idx": 24693}
{"project": "qemu", "commit_id": "b23046abe78f48498a423b802d6d86ba0172d57f", "target": 0, "func": "static void build_pci_bus_state_cleanup(AcpiBuildPciBusHotplugState *state)\n\n{\n\n    build_free_array(state->device_table);\n\n    build_free_array(state->notify_table);\n\n}\n", "idx": 24694}
{"project": "qemu", "commit_id": "b29a0341d7ed7e7df4bf77a41db8e614f1ddb645", "target": 0, "func": "void op_mtc0_ebase (void)\n\n{\n\n    /* vectored interrupts not implemented */\n\n    /* Multi-CPU not implemented */\n\n    env->CP0_EBase = (int32_t)0x80000000 | (T0 & 0x3FFFF000);\n\n    RETURN();\n\n}\n", "idx": 24695}
{"project": "qemu", "commit_id": "d33271213437ed1834b0a50540d79e877e1cd894", "target": 0, "func": "uint32_t HELPER(mvcle)(CPUS390XState *env, uint32_t r1, uint64_t a2,\n\n                       uint32_t r3)\n\n{\n\n    uintptr_t ra = GETPC();\n\n    uint64_t destlen = get_length(env, r1 + 1);\n\n    uint64_t dest = get_address(env, r1);\n\n    uint64_t srclen = get_length(env, r3 + 1);\n\n    uint64_t src = get_address(env, r3);\n\n    uint8_t pad = a2 & 0xff;\n\n    uint8_t v;\n\n    uint32_t cc;\n\n\n\n    if (destlen == srclen) {\n\n        cc = 0;\n\n    } else if (destlen < srclen) {\n\n        cc = 1;\n\n    } else {\n\n        cc = 2;\n\n    }\n\n\n\n    if (srclen > destlen) {\n\n        srclen = destlen;\n\n    }\n\n\n\n    for (; destlen && srclen; src++, dest++, destlen--, srclen--) {\n\n        v = cpu_ldub_data_ra(env, src, ra);\n\n        cpu_stb_data_ra(env, dest, v, ra);\n\n    }\n\n\n\n    for (; destlen; dest++, destlen--) {\n\n        cpu_stb_data_ra(env, dest, pad, ra);\n\n    }\n\n\n\n    set_length(env, r1 + 1 , destlen);\n\n    /* can't use srclen here, we trunc'ed it */\n\n    set_length(env, r3 + 1, env->regs[r3 + 1] - src - env->regs[r3]);\n\n    set_address(env, r1, dest);\n\n    set_address(env, r3, src);\n\n\n\n    return cc;\n\n}\n", "idx": 24696}
{"project": "qemu", "commit_id": "0240ded8bb1580147ed2ff1748df439a3b41e38f", "target": 0, "func": "static inline void init_thread(struct target_pt_regs *regs, struct image_info *infop)\n\n{\n\n    target_long *stack = (void *)infop->start_stack;\n\n    memset(regs, 0, sizeof(*regs));\n\n    regs->ARM_cpsr = 0x10;\n\n    regs->ARM_pc = infop->entry;\n\n    regs->ARM_sp = infop->start_stack;\n\n    regs->ARM_r2 = tswapl(stack[2]); /* envp */\n\n    regs->ARM_r1 = tswapl(stack[1]); /* argv */\n\n    /* XXX: it seems that r0 is zeroed after ! */\n\n    //    regs->ARM_r0 = tswapl(stack[0]); /* argc */\n\n}\n", "idx": 24697}
{"project": "qemu", "commit_id": "2db2bfc0ccac5fd68dbf0ceb70fbc372c5d8a8c7", "target": 0, "func": "bool qemu_aio_wait(void)\n\n{\n\n    AioHandler *node;\n\n    fd_set rdfds, wrfds;\n\n    int max_fd = -1;\n\n    int ret;\n\n    bool busy;\n\n\n\n    /*\n\n     * If there are callbacks left that have been queued, we need to call then.\n\n     * Do not call select in this case, because it is possible that the caller\n\n     * does not need a complete flush (as is the case for qemu_aio_wait loops).\n\n     */\n\n    if (qemu_bh_poll()) {\n\n        return true;\n\n    }\n\n\n\n    walking_handlers++;\n\n\n\n    FD_ZERO(&rdfds);\n\n    FD_ZERO(&wrfds);\n\n\n\n    /* fill fd sets */\n\n    busy = false;\n\n    QLIST_FOREACH(node, &aio_handlers, node) {\n\n        /* If there aren't pending AIO operations, don't invoke callbacks.\n\n         * Otherwise, if there are no AIO requests, qemu_aio_wait() would\n\n         * wait indefinitely.\n\n         */\n\n        if (node->io_flush) {\n\n            if (node->io_flush(node->opaque) == 0) {\n\n                continue;\n\n            }\n\n            busy = true;\n\n        }\n\n        if (!node->deleted && node->io_read) {\n\n            FD_SET(node->fd, &rdfds);\n\n            max_fd = MAX(max_fd, node->fd + 1);\n\n        }\n\n        if (!node->deleted && node->io_write) {\n\n            FD_SET(node->fd, &wrfds);\n\n            max_fd = MAX(max_fd, node->fd + 1);\n\n        }\n\n    }\n\n\n\n    walking_handlers--;\n\n\n\n    /* No AIO operations?  Get us out of here */\n\n    if (!busy) {\n\n        return false;\n\n    }\n\n\n\n    /* wait until next event */\n\n    ret = select(max_fd, &rdfds, &wrfds, NULL, NULL);\n\n\n\n    /* if we have any readable fds, dispatch event */\n\n    if (ret > 0) {\n\n        walking_handlers++;\n\n\n\n        /* we have to walk very carefully in case\n\n         * qemu_aio_set_fd_handler is called while we're walking */\n\n        node = QLIST_FIRST(&aio_handlers);\n\n        while (node) {\n\n            AioHandler *tmp;\n\n\n\n            if (!node->deleted &&\n\n                FD_ISSET(node->fd, &rdfds) &&\n\n                node->io_read) {\n\n                node->io_read(node->opaque);\n\n            }\n\n            if (!node->deleted &&\n\n                FD_ISSET(node->fd, &wrfds) &&\n\n                node->io_write) {\n\n                node->io_write(node->opaque);\n\n            }\n\n\n\n            tmp = node;\n\n            node = QLIST_NEXT(node, node);\n\n\n\n            if (tmp->deleted) {\n\n                QLIST_REMOVE(tmp, node);\n\n                g_free(tmp);\n\n            }\n\n        }\n\n\n\n        walking_handlers--;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 24698}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t lsi_io_read(void *opaque, target_phys_addr_t addr,\n\n                            unsigned size)\n\n{\n\n    LSIState *s = opaque;\n\n    return lsi_reg_readb(s, addr & 0xff);\n\n}\n", "idx": 24700}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int ccid_handle_data(USBDevice *dev, USBPacket *p)\n\n{\n\n    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev, dev);\n\n    int ret = 0;\n\n    uint8_t *data = p->data;\n\n    int len = p->len;\n\n\n\n    switch (p->pid) {\n\n    case USB_TOKEN_OUT:\n\n        ret = ccid_handle_bulk_out(s, p);\n\n        break;\n\n\n\n    case USB_TOKEN_IN:\n\n        switch (p->devep & 0xf) {\n\n        case CCID_BULK_IN_EP:\n\n            if (!len) {\n\n                ret = USB_RET_NAK;\n\n            } else {\n\n                ret = ccid_bulk_in_copy_to_guest(s, data, len);\n\n            }\n\n            break;\n\n        case CCID_INT_IN_EP:\n\n            if (s->notify_slot_change) {\n\n                /* page 56, RDR_to_PC_NotifySlotChange */\n\n                data[0] = CCID_MESSAGE_TYPE_RDR_to_PC_NotifySlotChange;\n\n                data[1] = s->bmSlotICCState;\n\n                ret = 2;\n\n                s->notify_slot_change = false;\n\n                s->bmSlotICCState &= ~SLOT_0_CHANGED_MASK;\n\n                DPRINTF(s, D_INFO,\n\n                        \"handle_data: int_in: notify_slot_change %X, \"\n\n                        \"requested len %d\\n\",\n\n                        s->bmSlotICCState, len);\n\n            }\n\n            break;\n\n        default:\n\n            DPRINTF(s, 1, \"Bad endpoint\\n\");\n\n            break;\n\n        }\n\n        break;\n\n    default:\n\n        DPRINTF(s, 1, \"Bad token\\n\");\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 24704}
{"project": "qemu", "commit_id": "fe0bd475aa31e60674f7f53b85dc293108026202", "target": 1, "func": "static void disas_xtensa_insn(CPUXtensaState *env, DisasContext *dc)\n\n{\n\n#define HAS_OPTION_BITS(opt) do { \\\n\n        if (!option_bits_enabled(dc, opt)) { \\\n\n            qemu_log(\"Option is not enabled %s:%d\\n\", \\\n\n                    __FILE__, __LINE__); \\\n\n            goto invalid_opcode; \\\n\n        } \\\n\n    } while (0)\n\n\n\n#define HAS_OPTION(opt) HAS_OPTION_BITS(XTENSA_OPTION_BIT(opt))\n\n\n\n#define TBD() qemu_log(\"TBD(pc = %08x): %s:%d\\n\", dc->pc, __FILE__, __LINE__)\n\n#define RESERVED() do { \\\n\n        qemu_log(\"RESERVED(pc = %08x, %02x%02x%02x): %s:%d\\n\", \\\n\n                dc->pc, b0, b1, b2, __FILE__, __LINE__); \\\n\n        goto invalid_opcode; \\\n\n    } while (0)\n\n\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define OP0 (((b0) & 0xf0) >> 4)\n\n#define OP1 (((b2) & 0xf0) >> 4)\n\n#define OP2 ((b2) & 0xf)\n\n#define RRR_R ((b1) & 0xf)\n\n#define RRR_S (((b1) & 0xf0) >> 4)\n\n#define RRR_T ((b0) & 0xf)\n\n#else\n\n#define OP0 (((b0) & 0xf))\n\n#define OP1 (((b2) & 0xf))\n\n#define OP2 (((b2) & 0xf0) >> 4)\n\n#define RRR_R (((b1) & 0xf0) >> 4)\n\n#define RRR_S (((b1) & 0xf))\n\n#define RRR_T (((b0) & 0xf0) >> 4)\n\n#endif\n\n#define RRR_X ((RRR_R & 0x4) >> 2)\n\n#define RRR_Y ((RRR_T & 0x4) >> 2)\n\n#define RRR_W (RRR_R & 0x3)\n\n\n\n#define RRRN_R RRR_R\n\n#define RRRN_S RRR_S\n\n#define RRRN_T RRR_T\n\n\n\n#define RRI8_R RRR_R\n\n#define RRI8_S RRR_S\n\n#define RRI8_T RRR_T\n\n#define RRI8_IMM8 (b2)\n\n#define RRI8_IMM8_SE ((((b2) & 0x80) ? 0xffffff00 : 0) | RRI8_IMM8)\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define RI16_IMM16 (((b1) << 8) | (b2))\n\n#else\n\n#define RI16_IMM16 (((b2) << 8) | (b1))\n\n#endif\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define CALL_N (((b0) & 0xc) >> 2)\n\n#define CALL_OFFSET ((((b0) & 0x3) << 16) | ((b1) << 8) | (b2))\n\n#else\n\n#define CALL_N (((b0) & 0x30) >> 4)\n\n#define CALL_OFFSET ((((b0) & 0xc0) >> 6) | ((b1) << 2) | ((b2) << 10))\n\n#endif\n\n#define CALL_OFFSET_SE \\\n\n    (((CALL_OFFSET & 0x20000) ? 0xfffc0000 : 0) | CALL_OFFSET)\n\n\n\n#define CALLX_N CALL_N\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define CALLX_M ((b0) & 0x3)\n\n#else\n\n#define CALLX_M (((b0) & 0xc0) >> 6)\n\n#endif\n\n#define CALLX_S RRR_S\n\n\n\n#define BRI12_M CALLX_M\n\n#define BRI12_S RRR_S\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define BRI12_IMM12 ((((b1) & 0xf) << 8) | (b2))\n\n#else\n\n#define BRI12_IMM12 ((((b1) & 0xf0) >> 4) | ((b2) << 4))\n\n#endif\n\n#define BRI12_IMM12_SE (((BRI12_IMM12 & 0x800) ? 0xfffff000 : 0) | BRI12_IMM12)\n\n\n\n#define BRI8_M BRI12_M\n\n#define BRI8_R RRI8_R\n\n#define BRI8_S RRI8_S\n\n#define BRI8_IMM8 RRI8_IMM8\n\n#define BRI8_IMM8_SE RRI8_IMM8_SE\n\n\n\n#define RSR_SR (b1)\n\n\n\n    uint8_t b0 = cpu_ldub_code(env, dc->pc);\n\n    uint8_t b1 = cpu_ldub_code(env, dc->pc + 1);\n\n    uint8_t b2 = 0;\n\n\n\n    static const uint32_t B4CONST[] = {\n\n        0xffffffff, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256\n\n    };\n\n\n\n    static const uint32_t B4CONSTU[] = {\n\n        32768, 65536, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256\n\n    };\n\n\n\n    if (OP0 >= 8) {\n\n        dc->next_pc = dc->pc + 2;\n\n        HAS_OPTION(XTENSA_OPTION_CODE_DENSITY);\n\n    } else {\n\n        dc->next_pc = dc->pc + 3;\n\n        b2 = cpu_ldub_code(env, dc->pc + 2);\n\n    }\n\n\n\n    switch (OP0) {\n\n    case 0: /*QRST*/\n\n        switch (OP1) {\n\n        case 0: /*RST0*/\n\n            switch (OP2) {\n\n            case 0: /*ST0*/\n\n                if ((RRR_R & 0xc) == 0x8) {\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                }\n\n\n\n                switch (RRR_R) {\n\n                case 0: /*SNM0*/\n\n                    switch (CALLX_M) {\n\n                    case 0: /*ILL*/\n\n                        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                        break;\n\n\n\n                    case 1: /*reserved*/\n\n                        RESERVED();\n\n                        break;\n\n\n\n                    case 2: /*JR*/\n\n                        switch (CALLX_N) {\n\n                        case 0: /*RET*/\n\n                        case 2: /*JX*/\n\n                            gen_window_check1(dc, CALLX_S);\n\n                            gen_jump(dc, cpu_R[CALLX_S]);\n\n                            break;\n\n\n\n                        case 1: /*RETWw*/\n\n                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                            {\n\n                                TCGv_i32 tmp = tcg_const_i32(dc->pc);\n\n                                gen_advance_ccount(dc);\n\n                                gen_helper_retw(tmp, cpu_env, tmp);\n\n                                gen_jump(dc, tmp);\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n\n\n                        case 3: /*reserved*/\n\n                            RESERVED();\n\n                            break;\n\n                        }\n\n                        break;\n\n\n\n                    case 3: /*CALLX*/\n\n                        gen_window_check2(dc, CALLX_S, CALLX_N << 2);\n\n                        switch (CALLX_N) {\n\n                        case 0: /*CALLX0*/\n\n                            {\n\n                                TCGv_i32 tmp = tcg_temp_new_i32();\n\n                                tcg_gen_mov_i32(tmp, cpu_R[CALLX_S]);\n\n                                tcg_gen_movi_i32(cpu_R[0], dc->next_pc);\n\n                                gen_jump(dc, tmp);\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n\n\n                        case 1: /*CALLX4w*/\n\n                        case 2: /*CALLX8w*/\n\n                        case 3: /*CALLX12w*/\n\n                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                            {\n\n                                TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                                tcg_gen_mov_i32(tmp, cpu_R[CALLX_S]);\n\n                                gen_callw(dc, CALLX_N, tmp);\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n                        }\n\n                        break;\n\n                    }\n\n                    break;\n\n\n\n                case 1: /*MOVSPw*/\n\n                    HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                    gen_window_check2(dc, RRR_T, RRR_S);\n\n                    {\n\n                        TCGv_i32 pc = tcg_const_i32(dc->pc);\n\n                        gen_advance_ccount(dc);\n\n                        gen_helper_movsp(cpu_env, pc);\n\n                        tcg_gen_mov_i32(cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                        tcg_temp_free(pc);\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*SYNC*/\n\n                    switch (RRR_T) {\n\n                    case 0: /*ISYNC*/\n\n                        break;\n\n\n\n                    case 1: /*RSYNC*/\n\n                        break;\n\n\n\n                    case 2: /*ESYNC*/\n\n                        break;\n\n\n\n                    case 3: /*DSYNC*/\n\n                        break;\n\n\n\n                    case 8: /*EXCW*/\n\n                        HAS_OPTION(XTENSA_OPTION_EXCEPTION);\n\n                        break;\n\n\n\n                    case 12: /*MEMW*/\n\n                        break;\n\n\n\n                    case 13: /*EXTW*/\n\n                        break;\n\n\n\n                    case 15: /*NOP*/\n\n                        break;\n\n\n\n                    default: /*reserved*/\n\n                        RESERVED();\n\n                        break;\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*RFEIx*/\n\n                    switch (RRR_T) {\n\n                    case 0: /*RFETx*/\n\n                        HAS_OPTION(XTENSA_OPTION_EXCEPTION);\n\n                        switch (RRR_S) {\n\n                        case 0: /*RFEx*/\n\n                            gen_check_privilege(dc);\n\n                            tcg_gen_andi_i32(cpu_SR[PS], cpu_SR[PS], ~PS_EXCM);\n\n                            gen_helper_check_interrupts(cpu_env);\n\n                            gen_jump(dc, cpu_SR[EPC1]);\n\n                            break;\n\n\n\n                        case 1: /*RFUEx*/\n\n                            RESERVED();\n\n                            break;\n\n\n\n                        case 2: /*RFDEx*/\n\n                            gen_check_privilege(dc);\n\n                            gen_jump(dc, cpu_SR[\n\n                                    dc->config->ndepc ? DEPC : EPC1]);\n\n                            break;\n\n\n\n                        case 4: /*RFWOw*/\n\n                        case 5: /*RFWUw*/\n\n                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                            gen_check_privilege(dc);\n\n                            {\n\n                                TCGv_i32 tmp = tcg_const_i32(1);\n\n\n\n                                tcg_gen_andi_i32(\n\n                                        cpu_SR[PS], cpu_SR[PS], ~PS_EXCM);\n\n                                tcg_gen_shl_i32(tmp, tmp, cpu_SR[WINDOW_BASE]);\n\n\n\n                                if (RRR_S == 4) {\n\n                                    tcg_gen_andc_i32(cpu_SR[WINDOW_START],\n\n                                            cpu_SR[WINDOW_START], tmp);\n\n                                } else {\n\n                                    tcg_gen_or_i32(cpu_SR[WINDOW_START],\n\n                                            cpu_SR[WINDOW_START], tmp);\n\n                                }\n\n\n\n                                gen_helper_restore_owb(cpu_env);\n\n                                gen_helper_check_interrupts(cpu_env);\n\n                                gen_jump(dc, cpu_SR[EPC1]);\n\n\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n\n\n                        default: /*reserved*/\n\n                            RESERVED();\n\n                            break;\n\n                        }\n\n                        break;\n\n\n\n                    case 1: /*RFIx*/\n\n                        HAS_OPTION(XTENSA_OPTION_HIGH_PRIORITY_INTERRUPT);\n\n                        if (RRR_S >= 2 && RRR_S <= dc->config->nlevel) {\n\n                            gen_check_privilege(dc);\n\n                            tcg_gen_mov_i32(cpu_SR[PS],\n\n                                    cpu_SR[EPS2 + RRR_S - 2]);\n\n                            gen_helper_check_interrupts(cpu_env);\n\n                            gen_jump(dc, cpu_SR[EPC1 + RRR_S - 1]);\n\n                        } else {\n\n                            qemu_log(\"RFI %d is illegal\\n\", RRR_S);\n\n                            gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                        }\n\n                        break;\n\n\n\n                    case 2: /*RFME*/\n\n                        TBD();\n\n                        break;\n\n\n\n                    default: /*reserved*/\n\n                        RESERVED();\n\n                        break;\n\n\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*BREAKx*/\n\n                    HAS_OPTION(XTENSA_OPTION_DEBUG);\n\n                    if (dc->debug) {\n\n                        gen_debug_exception(dc, DEBUGCAUSE_BI);\n\n                    }\n\n                    break;\n\n\n\n                case 5: /*SYSCALLx*/\n\n                    HAS_OPTION(XTENSA_OPTION_EXCEPTION);\n\n                    switch (RRR_S) {\n\n                    case 0: /*SYSCALLx*/\n\n                        gen_exception_cause(dc, SYSCALL_CAUSE);\n\n                        break;\n\n\n\n                    case 1: /*SIMCALL*/\n\n                        if (semihosting_enabled) {\n\n                            gen_check_privilege(dc);\n\n                            gen_helper_simcall(cpu_env);\n\n                        } else {\n\n                            qemu_log(\"SIMCALL but semihosting is disabled\\n\");\n\n                            gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                        }\n\n                        break;\n\n\n\n                    default:\n\n                        RESERVED();\n\n                        break;\n\n                    }\n\n                    break;\n\n\n\n                case 6: /*RSILx*/\n\n                    HAS_OPTION(XTENSA_OPTION_INTERRUPT);\n\n                    gen_check_privilege(dc);\n\n                    gen_window_check1(dc, RRR_T);\n\n                    tcg_gen_mov_i32(cpu_R[RRR_T], cpu_SR[PS]);\n\n                    tcg_gen_andi_i32(cpu_SR[PS], cpu_SR[PS], ~PS_INTLEVEL);\n\n                    tcg_gen_ori_i32(cpu_SR[PS], cpu_SR[PS], RRR_S);\n\n                    gen_helper_check_interrupts(cpu_env);\n\n                    gen_jumpi_check_loop_end(dc, 0);\n\n                    break;\n\n\n\n                case 7: /*WAITIx*/\n\n                    HAS_OPTION(XTENSA_OPTION_INTERRUPT);\n\n                    gen_check_privilege(dc);\n\n                    gen_waiti(dc, RRR_S);\n\n                    break;\n\n\n\n                case 8: /*ANY4p*/\n\n                case 9: /*ALL4p*/\n\n                case 10: /*ANY8p*/\n\n                case 11: /*ALL8p*/\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                    {\n\n                        const unsigned shift = (RRR_R & 2) ? 8 : 4;\n\n                        TCGv_i32 mask = tcg_const_i32(\n\n                                ((1 << shift) - 1) << RRR_S);\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                        tcg_gen_and_i32(tmp, cpu_SR[BR], mask);\n\n                        if (RRR_R & 1) { /*ALL*/\n\n                            tcg_gen_addi_i32(tmp, tmp, 1 << RRR_S);\n\n                        } else { /*ANY*/\n\n                            tcg_gen_add_i32(tmp, tmp, mask);\n\n                        }\n\n                        tcg_gen_shri_i32(tmp, tmp, RRR_S + shift);\n\n                        tcg_gen_deposit_i32(cpu_SR[BR], cpu_SR[BR],\n\n                                tmp, RRR_T, 1);\n\n                        tcg_temp_free(mask);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n\n\n                }\n\n                break;\n\n\n\n            case 1: /*AND*/\n\n                gen_window_check3(dc, RRR_R, RRR_S, RRR_T);\n\n                tcg_gen_and_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            case 2: /*OR*/\n\n                gen_window_check3(dc, RRR_R, RRR_S, RRR_T);\n\n                tcg_gen_or_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            case 3: /*XOR*/\n\n                gen_window_check3(dc, RRR_R, RRR_S, RRR_T);\n\n                tcg_gen_xor_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            case 4: /*ST1*/\n\n                switch (RRR_R) {\n\n                case 0: /*SSR*/\n\n                    gen_window_check1(dc, RRR_S);\n\n                    gen_right_shift_sar(dc, cpu_R[RRR_S]);\n\n                    break;\n\n\n\n                case 1: /*SSL*/\n\n                    gen_window_check1(dc, RRR_S);\n\n                    gen_left_shift_sar(dc, cpu_R[RRR_S]);\n\n                    break;\n\n\n\n                case 2: /*SSA8L*/\n\n                    gen_window_check1(dc, RRR_S);\n\n                    {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], 3);\n\n                        gen_right_shift_sar(dc, tmp);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*SSA8B*/\n\n                    gen_window_check1(dc, RRR_S);\n\n                    {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], 3);\n\n                        gen_left_shift_sar(dc, tmp);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*SSAI*/\n\n                    {\n\n                        TCGv_i32 tmp = tcg_const_i32(\n\n                                RRR_S | ((RRR_T & 1) << 4));\n\n                        gen_right_shift_sar(dc, tmp);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 6: /*RER*/\n\n                    TBD();\n\n                    break;\n\n\n\n                case 7: /*WER*/\n\n                    TBD();\n\n                    break;\n\n\n\n                case 8: /*ROTWw*/\n\n                    HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                    gen_check_privilege(dc);\n\n                    {\n\n                        TCGv_i32 tmp = tcg_const_i32(\n\n                                RRR_T | ((RRR_T & 8) ? 0xfffffff0 : 0));\n\n                        gen_helper_rotw(cpu_env, tmp);\n\n                        tcg_temp_free(tmp);\n\n                        reset_used_window(dc);\n\n                    }\n\n                    break;\n\n\n\n                case 14: /*NSAu*/\n\n                    HAS_OPTION(XTENSA_OPTION_MISC_OP_NSA);\n\n                    gen_window_check2(dc, RRR_S, RRR_T);\n\n                    gen_helper_nsa(cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                    break;\n\n\n\n                case 15: /*NSAUu*/\n\n                    HAS_OPTION(XTENSA_OPTION_MISC_OP_NSA);\n\n                    gen_window_check2(dc, RRR_S, RRR_T);\n\n                    gen_helper_nsau(cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            case 5: /*TLB*/\n\n                HAS_OPTION_BITS(\n\n                        XTENSA_OPTION_BIT(XTENSA_OPTION_MMU) |\n\n                        XTENSA_OPTION_BIT(XTENSA_OPTION_REGION_PROTECTION) |\n\n                        XTENSA_OPTION_BIT(XTENSA_OPTION_REGION_TRANSLATION));\n\n                gen_check_privilege(dc);\n\n                gen_window_check2(dc, RRR_S, RRR_T);\n\n                {\n\n                    TCGv_i32 dtlb = tcg_const_i32((RRR_R & 8) != 0);\n\n\n\n                    switch (RRR_R & 7) {\n\n                    case 3: /*RITLB0*/ /*RDTLB0*/\n\n                        gen_helper_rtlb0(cpu_R[RRR_T],\n\n                                cpu_env, cpu_R[RRR_S], dtlb);\n\n                        break;\n\n\n\n                    case 4: /*IITLB*/ /*IDTLB*/\n\n                        gen_helper_itlb(cpu_env, cpu_R[RRR_S], dtlb);\n\n                        /* This could change memory mapping, so exit tb */\n\n                        gen_jumpi_check_loop_end(dc, -1);\n\n                        break;\n\n\n\n                    case 5: /*PITLB*/ /*PDTLB*/\n\n                        tcg_gen_movi_i32(cpu_pc, dc->pc);\n\n                        gen_helper_ptlb(cpu_R[RRR_T],\n\n                                cpu_env, cpu_R[RRR_S], dtlb);\n\n                        break;\n\n\n\n                    case 6: /*WITLB*/ /*WDTLB*/\n\n                        gen_helper_wtlb(\n\n                                cpu_env, cpu_R[RRR_T], cpu_R[RRR_S], dtlb);\n\n                        /* This could change memory mapping, so exit tb */\n\n                        gen_jumpi_check_loop_end(dc, -1);\n\n                        break;\n\n\n\n                    case 7: /*RITLB1*/ /*RDTLB1*/\n\n                        gen_helper_rtlb1(cpu_R[RRR_T],\n\n                                cpu_env, cpu_R[RRR_S], dtlb);\n\n                        break;\n\n\n\n                    default:\n\n                        tcg_temp_free(dtlb);\n\n                        RESERVED();\n\n                        break;\n\n                    }\n\n                    tcg_temp_free(dtlb);\n\n                }\n\n                break;\n\n\n\n            case 6: /*RT0*/\n\n                gen_window_check2(dc, RRR_R, RRR_T);\n\n                switch (RRR_S) {\n\n                case 0: /*NEG*/\n\n                    tcg_gen_neg_i32(cpu_R[RRR_R], cpu_R[RRR_T]);\n\n                    break;\n\n\n\n                case 1: /*ABS*/\n\n                    {\n\n                        int label = gen_new_label();\n\n                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_R[RRR_T]);\n\n                        tcg_gen_brcondi_i32(\n\n                                TCG_COND_GE, cpu_R[RRR_R], 0, label);\n\n                        tcg_gen_neg_i32(cpu_R[RRR_R], cpu_R[RRR_T]);\n\n                        gen_set_label(label);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            case 7: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n\n\n            case 8: /*ADD*/\n\n                gen_window_check3(dc, RRR_R, RRR_S, RRR_T);\n\n                tcg_gen_add_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            case 9: /*ADD**/\n\n            case 10:\n\n            case 11:\n\n                gen_window_check3(dc, RRR_R, RRR_S, RRR_T);\n\n                {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_shli_i32(tmp, cpu_R[RRR_S], OP2 - 8);\n\n                    tcg_gen_add_i32(cpu_R[RRR_R], tmp, cpu_R[RRR_T]);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 12: /*SUB*/\n\n                gen_window_check3(dc, RRR_R, RRR_S, RRR_T);\n\n                tcg_gen_sub_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            case 13: /*SUB**/\n\n            case 14:\n\n            case 15:\n\n                gen_window_check3(dc, RRR_R, RRR_S, RRR_T);\n\n                {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_shli_i32(tmp, cpu_R[RRR_S], OP2 - 12);\n\n                    tcg_gen_sub_i32(cpu_R[RRR_R], tmp, cpu_R[RRR_T]);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 1: /*RST1*/\n\n            switch (OP2) {\n\n            case 0: /*SLLI*/\n\n            case 1:\n\n                gen_window_check2(dc, RRR_R, RRR_S);\n\n                tcg_gen_shli_i32(cpu_R[RRR_R], cpu_R[RRR_S],\n\n                        32 - (RRR_T | ((OP2 & 1) << 4)));\n\n                break;\n\n\n\n            case 2: /*SRAI*/\n\n            case 3:\n\n                gen_window_check2(dc, RRR_R, RRR_T);\n\n                tcg_gen_sari_i32(cpu_R[RRR_R], cpu_R[RRR_T],\n\n                        RRR_S | ((OP2 & 1) << 4));\n\n                break;\n\n\n\n            case 4: /*SRLI*/\n\n                gen_window_check2(dc, RRR_R, RRR_T);\n\n                tcg_gen_shri_i32(cpu_R[RRR_R], cpu_R[RRR_T], RRR_S);\n\n                break;\n\n\n\n            case 6: /*XSR*/\n\n                {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    if (RSR_SR >= 64) {\n\n                        gen_check_privilege(dc);\n\n                    }\n\n                    gen_window_check1(dc, RRR_T);\n\n                    tcg_gen_mov_i32(tmp, cpu_R[RRR_T]);\n\n                    gen_rsr(dc, cpu_R[RRR_T], RSR_SR);\n\n                    gen_wsr(dc, RSR_SR, tmp);\n\n                    tcg_temp_free(tmp);\n\n                    if (!sregnames[RSR_SR]) {\n\n                        TBD();\n\n                    }\n\n                }\n\n                break;\n\n\n\n                /*\n\n                 * Note: 64 bit ops are used here solely because SAR values\n\n                 * have range 0..63\n\n                 */\n\n#define gen_shift_reg(cmd, reg) do { \\\n\n                    TCGv_i64 tmp = tcg_temp_new_i64(); \\\n\n                    tcg_gen_extu_i32_i64(tmp, reg); \\\n\n                    tcg_gen_##cmd##_i64(v, v, tmp); \\\n\n                    tcg_gen_trunc_i64_i32(cpu_R[RRR_R], v); \\\n\n                    tcg_temp_free_i64(v); \\\n\n                    tcg_temp_free_i64(tmp); \\\n\n                } while (0)\n\n\n\n#define gen_shift(cmd) gen_shift_reg(cmd, cpu_SR[SAR])\n\n\n\n            case 8: /*SRC*/\n\n                gen_window_check3(dc, RRR_R, RRR_S, RRR_T);\n\n                {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    tcg_gen_concat_i32_i64(v, cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                    gen_shift(shr);\n\n                }\n\n                break;\n\n\n\n            case 9: /*SRL*/\n\n                gen_window_check2(dc, RRR_R, RRR_T);\n\n                if (dc->sar_5bit) {\n\n                    tcg_gen_shr_i32(cpu_R[RRR_R], cpu_R[RRR_T], cpu_SR[SAR]);\n\n                } else {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    tcg_gen_extu_i32_i64(v, cpu_R[RRR_T]);\n\n                    gen_shift(shr);\n\n                }\n\n                break;\n\n\n\n            case 10: /*SLL*/\n\n                gen_window_check2(dc, RRR_R, RRR_S);\n\n                if (dc->sar_m32_5bit) {\n\n                    tcg_gen_shl_i32(cpu_R[RRR_R], cpu_R[RRR_S], dc->sar_m32);\n\n                } else {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    TCGv_i32 s = tcg_const_i32(32);\n\n                    tcg_gen_sub_i32(s, s, cpu_SR[SAR]);\n\n                    tcg_gen_andi_i32(s, s, 0x3f);\n\n                    tcg_gen_extu_i32_i64(v, cpu_R[RRR_S]);\n\n                    gen_shift_reg(shl, s);\n\n                    tcg_temp_free(s);\n\n                }\n\n                break;\n\n\n\n            case 11: /*SRA*/\n\n                gen_window_check2(dc, RRR_R, RRR_T);\n\n                if (dc->sar_5bit) {\n\n                    tcg_gen_sar_i32(cpu_R[RRR_R], cpu_R[RRR_T], cpu_SR[SAR]);\n\n                } else {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    tcg_gen_ext_i32_i64(v, cpu_R[RRR_T]);\n\n                    gen_shift(sar);\n\n                }\n\n                break;\n\n#undef gen_shift\n\n#undef gen_shift_reg\n\n\n\n            case 12: /*MUL16U*/\n\n                HAS_OPTION(XTENSA_OPTION_16_BIT_IMUL);\n\n                gen_window_check3(dc, RRR_R, RRR_S, RRR_T);\n\n                {\n\n                    TCGv_i32 v1 = tcg_temp_new_i32();\n\n                    TCGv_i32 v2 = tcg_temp_new_i32();\n\n                    tcg_gen_ext16u_i32(v1, cpu_R[RRR_S]);\n\n                    tcg_gen_ext16u_i32(v2, cpu_R[RRR_T]);\n\n                    tcg_gen_mul_i32(cpu_R[RRR_R], v1, v2);\n\n                    tcg_temp_free(v2);\n\n                    tcg_temp_free(v1);\n\n                }\n\n                break;\n\n\n\n            case 13: /*MUL16S*/\n\n                HAS_OPTION(XTENSA_OPTION_16_BIT_IMUL);\n\n                gen_window_check3(dc, RRR_R, RRR_S, RRR_T);\n\n                {\n\n                    TCGv_i32 v1 = tcg_temp_new_i32();\n\n                    TCGv_i32 v2 = tcg_temp_new_i32();\n\n                    tcg_gen_ext16s_i32(v1, cpu_R[RRR_S]);\n\n                    tcg_gen_ext16s_i32(v2, cpu_R[RRR_T]);\n\n                    tcg_gen_mul_i32(cpu_R[RRR_R], v1, v2);\n\n                    tcg_temp_free(v2);\n\n                    tcg_temp_free(v1);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 2: /*RST2*/\n\n            if (OP2 >= 8) {\n\n                gen_window_check3(dc, RRR_R, RRR_S, RRR_T);\n\n            }\n\n\n\n            if (OP2 >= 12) {\n\n                HAS_OPTION(XTENSA_OPTION_32_BIT_IDIV);\n\n                int label = gen_new_label();\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_T], 0, label);\n\n                gen_exception_cause(dc, INTEGER_DIVIDE_BY_ZERO_CAUSE);\n\n                gen_set_label(label);\n\n            }\n\n\n\n            switch (OP2) {\n\n#define BOOLEAN_LOGIC(fn, r, s, t) \\\n\n                do { \\\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN); \\\n\n                    TCGv_i32 tmp1 = tcg_temp_new_i32(); \\\n\n                    TCGv_i32 tmp2 = tcg_temp_new_i32(); \\\n\n                    \\\n\n                    tcg_gen_shri_i32(tmp1, cpu_SR[BR], s); \\\n\n                    tcg_gen_shri_i32(tmp2, cpu_SR[BR], t); \\\n\n                    tcg_gen_##fn##_i32(tmp1, tmp1, tmp2); \\\n\n                    tcg_gen_deposit_i32(cpu_SR[BR], cpu_SR[BR], tmp1, r, 1); \\\n\n                    tcg_temp_free(tmp1); \\\n\n                    tcg_temp_free(tmp2); \\\n\n                } while (0)\n\n\n\n            case 0: /*ANDBp*/\n\n                BOOLEAN_LOGIC(and, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 1: /*ANDBCp*/\n\n                BOOLEAN_LOGIC(andc, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 2: /*ORBp*/\n\n                BOOLEAN_LOGIC(or, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 3: /*ORBCp*/\n\n                BOOLEAN_LOGIC(orc, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 4: /*XORBp*/\n\n                BOOLEAN_LOGIC(xor, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n#undef BOOLEAN_LOGIC\n\n\n\n            case 8: /*MULLi*/\n\n                HAS_OPTION(XTENSA_OPTION_32_BIT_IMUL);\n\n                tcg_gen_mul_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            case 10: /*MULUHi*/\n\n            case 11: /*MULSHi*/\n\n                HAS_OPTION(XTENSA_OPTION_32_BIT_IMUL_HIGH);\n\n                {\n\n                    TCGv_i64 r = tcg_temp_new_i64();\n\n                    TCGv_i64 s = tcg_temp_new_i64();\n\n                    TCGv_i64 t = tcg_temp_new_i64();\n\n\n\n                    if (OP2 == 10) {\n\n                        tcg_gen_extu_i32_i64(s, cpu_R[RRR_S]);\n\n                        tcg_gen_extu_i32_i64(t, cpu_R[RRR_T]);\n\n                    } else {\n\n                        tcg_gen_ext_i32_i64(s, cpu_R[RRR_S]);\n\n                        tcg_gen_ext_i32_i64(t, cpu_R[RRR_T]);\n\n                    }\n\n                    tcg_gen_mul_i64(r, s, t);\n\n                    tcg_gen_shri_i64(r, r, 32);\n\n                    tcg_gen_trunc_i64_i32(cpu_R[RRR_R], r);\n\n\n\n                    tcg_temp_free_i64(r);\n\n                    tcg_temp_free_i64(s);\n\n                    tcg_temp_free_i64(t);\n\n                }\n\n                break;\n\n\n\n            case 12: /*QUOUi*/\n\n                tcg_gen_divu_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            case 13: /*QUOSi*/\n\n            case 15: /*REMSi*/\n\n                {\n\n                    int label1 = gen_new_label();\n\n                    int label2 = gen_new_label();\n\n\n\n                    tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_S], 0x80000000,\n\n                            label1);\n\n                    tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_T], 0xffffffff,\n\n                            label1);\n\n                    tcg_gen_movi_i32(cpu_R[RRR_R],\n\n                            OP2 == 13 ? 0x80000000 : 0);\n\n                    tcg_gen_br(label2);\n\n                    gen_set_label(label1);\n\n                    if (OP2 == 13) {\n\n                        tcg_gen_div_i32(cpu_R[RRR_R],\n\n                                cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    } else {\n\n                        tcg_gen_rem_i32(cpu_R[RRR_R],\n\n                                cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    }\n\n                    gen_set_label(label2);\n\n                }\n\n                break;\n\n\n\n            case 14: /*REMUi*/\n\n                tcg_gen_remu_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 3: /*RST3*/\n\n            switch (OP2) {\n\n            case 0: /*RSR*/\n\n                if (RSR_SR >= 64) {\n\n                    gen_check_privilege(dc);\n\n                }\n\n                gen_window_check1(dc, RRR_T);\n\n                gen_rsr(dc, cpu_R[RRR_T], RSR_SR);\n\n                if (!sregnames[RSR_SR]) {\n\n                    TBD();\n\n                }\n\n                break;\n\n\n\n            case 1: /*WSR*/\n\n                if (RSR_SR >= 64) {\n\n                    gen_check_privilege(dc);\n\n                }\n\n                gen_window_check1(dc, RRR_T);\n\n                gen_wsr(dc, RSR_SR, cpu_R[RRR_T]);\n\n                if (!sregnames[RSR_SR]) {\n\n                    TBD();\n\n                }\n\n                break;\n\n\n\n            case 2: /*SEXTu*/\n\n                HAS_OPTION(XTENSA_OPTION_MISC_OP_SEXT);\n\n                gen_window_check2(dc, RRR_R, RRR_S);\n\n                {\n\n                    int shift = 24 - RRR_T;\n\n\n\n                    if (shift == 24) {\n\n                        tcg_gen_ext8s_i32(cpu_R[RRR_R], cpu_R[RRR_S]);\n\n                    } else if (shift == 16) {\n\n                        tcg_gen_ext16s_i32(cpu_R[RRR_R], cpu_R[RRR_S]);\n\n                    } else {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], shift);\n\n                        tcg_gen_sari_i32(cpu_R[RRR_R], tmp, shift);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                }\n\n                break;\n\n\n\n            case 3: /*CLAMPSu*/\n\n                HAS_OPTION(XTENSA_OPTION_MISC_OP_CLAMPS);\n\n                gen_window_check2(dc, RRR_R, RRR_S);\n\n                {\n\n                    TCGv_i32 tmp1 = tcg_temp_new_i32();\n\n                    TCGv_i32 tmp2 = tcg_temp_new_i32();\n\n                    int label = gen_new_label();\n\n\n\n                    tcg_gen_sari_i32(tmp1, cpu_R[RRR_S], 24 - RRR_T);\n\n                    tcg_gen_xor_i32(tmp2, tmp1, cpu_R[RRR_S]);\n\n                    tcg_gen_andi_i32(tmp2, tmp2, 0xffffffff << (RRR_T + 7));\n\n                    tcg_gen_mov_i32(cpu_R[RRR_R], cpu_R[RRR_S]);\n\n                    tcg_gen_brcondi_i32(TCG_COND_EQ, tmp2, 0, label);\n\n\n\n                    tcg_gen_sari_i32(tmp1, cpu_R[RRR_S], 31);\n\n                    tcg_gen_xori_i32(cpu_R[RRR_R], tmp1,\n\n                            0xffffffff >> (25 - RRR_T));\n\n\n\n                    gen_set_label(label);\n\n\n\n                    tcg_temp_free(tmp1);\n\n                    tcg_temp_free(tmp2);\n\n                }\n\n                break;\n\n\n\n            case 4: /*MINu*/\n\n            case 5: /*MAXu*/\n\n            case 6: /*MINUu*/\n\n            case 7: /*MAXUu*/\n\n                HAS_OPTION(XTENSA_OPTION_MISC_OP_MINMAX);\n\n                gen_window_check3(dc, RRR_R, RRR_S, RRR_T);\n\n                {\n\n                    static const TCGCond cond[] = {\n\n                        TCG_COND_LE,\n\n                        TCG_COND_GE,\n\n                        TCG_COND_LEU,\n\n                        TCG_COND_GEU\n\n                    };\n\n                    int label = gen_new_label();\n\n\n\n                    if (RRR_R != RRR_T) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_R[RRR_S]);\n\n                        tcg_gen_brcond_i32(cond[OP2 - 4],\n\n                                cpu_R[RRR_S], cpu_R[RRR_T], label);\n\n                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_R[RRR_T]);\n\n                    } else {\n\n                        tcg_gen_brcond_i32(cond[OP2 - 4],\n\n                                cpu_R[RRR_T], cpu_R[RRR_S], label);\n\n                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_R[RRR_S]);\n\n                    }\n\n                    gen_set_label(label);\n\n                }\n\n                break;\n\n\n\n            case 8: /*MOVEQZ*/\n\n            case 9: /*MOVNEZ*/\n\n            case 10: /*MOVLTZ*/\n\n            case 11: /*MOVGEZ*/\n\n                gen_window_check3(dc, RRR_R, RRR_S, RRR_T);\n\n                {\n\n                    static const TCGCond cond[] = {\n\n                        TCG_COND_NE,\n\n                        TCG_COND_EQ,\n\n                        TCG_COND_GE,\n\n                        TCG_COND_LT\n\n                    };\n\n                    int label = gen_new_label();\n\n                    tcg_gen_brcondi_i32(cond[OP2 - 8], cpu_R[RRR_T], 0, label);\n\n                    tcg_gen_mov_i32(cpu_R[RRR_R], cpu_R[RRR_S]);\n\n                    gen_set_label(label);\n\n                }\n\n                break;\n\n\n\n            case 12: /*MOVFp*/\n\n            case 13: /*MOVTp*/\n\n                HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                gen_window_check2(dc, RRR_R, RRR_S);\n\n                {\n\n                    int label = gen_new_label();\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                    tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRR_T);\n\n                    tcg_gen_brcondi_i32(\n\n                            OP2 & 1 ? TCG_COND_EQ : TCG_COND_NE,\n\n                            tmp, 0, label);\n\n                    tcg_gen_mov_i32(cpu_R[RRR_R], cpu_R[RRR_S]);\n\n                    gen_set_label(label);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 14: /*RUR*/\n\n                gen_window_check1(dc, RRR_R);\n\n                {\n\n                    int st = (RRR_S << 4) + RRR_T;\n\n                    if (uregnames[st]) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_UR[st]);\n\n                    } else {\n\n                        qemu_log(\"RUR %d not implemented, \", st);\n\n                        TBD();\n\n                    }\n\n                }\n\n                break;\n\n\n\n            case 15: /*WUR*/\n\n                gen_window_check1(dc, RRR_T);\n\n                if (uregnames[RSR_SR]) {\n\n                    gen_wur(RSR_SR, cpu_R[RRR_T]);\n\n                } else {\n\n                    qemu_log(\"WUR %d not implemented, \", RSR_SR);\n\n                    TBD();\n\n                }\n\n                break;\n\n\n\n            }\n\n            break;\n\n\n\n        case 4: /*EXTUI*/\n\n        case 5:\n\n            gen_window_check2(dc, RRR_R, RRR_T);\n\n            {\n\n                int shiftimm = RRR_S | ((OP1 & 1) << 4);\n\n                int maskimm = (1 << (OP2 + 1)) - 1;\n\n\n\n                TCGv_i32 tmp = tcg_temp_new_i32();\n\n                tcg_gen_shri_i32(tmp, cpu_R[RRR_T], shiftimm);\n\n                tcg_gen_andi_i32(cpu_R[RRR_R], tmp, maskimm);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n\n\n        case 6: /*CUST0*/\n\n            RESERVED();\n\n            break;\n\n\n\n        case 7: /*CUST1*/\n\n            RESERVED();\n\n            break;\n\n\n\n        case 8: /*LSCXp*/\n\n            switch (OP2) {\n\n            case 0: /*LSXf*/\n\n            case 1: /*LSXUf*/\n\n            case 4: /*SSXf*/\n\n            case 5: /*SSXUf*/\n\n                HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n                gen_window_check2(dc, RRR_S, RRR_T);\n\n                gen_check_cpenable(dc, 0);\n\n                {\n\n                    TCGv_i32 addr = tcg_temp_new_i32();\n\n                    tcg_gen_add_i32(addr, cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    gen_load_store_alignment(dc, 2, addr, false);\n\n                    if (OP2 & 0x4) {\n\n                        tcg_gen_qemu_st32(cpu_FR[RRR_R], addr, dc->cring);\n\n                    } else {\n\n                        tcg_gen_qemu_ld32u(cpu_FR[RRR_R], addr, dc->cring);\n\n                    }\n\n                    if (OP2 & 0x1) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_S], addr);\n\n                    }\n\n                    tcg_temp_free(addr);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 9: /*LSC4*/\n\n            gen_window_check2(dc, RRR_S, RRR_T);\n\n            switch (OP2) {\n\n            case 0: /*L32E*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                gen_check_privilege(dc);\n\n                {\n\n                    TCGv_i32 addr = tcg_temp_new_i32();\n\n                    tcg_gen_addi_i32(addr, cpu_R[RRR_S],\n\n                            (0xffffffc0 | (RRR_R << 2)));\n\n                    tcg_gen_qemu_ld32u(cpu_R[RRR_T], addr, dc->ring);\n\n                    tcg_temp_free(addr);\n\n                }\n\n                break;\n\n\n\n            case 4: /*S32E*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                gen_check_privilege(dc);\n\n                {\n\n                    TCGv_i32 addr = tcg_temp_new_i32();\n\n                    tcg_gen_addi_i32(addr, cpu_R[RRR_S],\n\n                            (0xffffffc0 | (RRR_R << 2)));\n\n                    tcg_gen_qemu_st32(cpu_R[RRR_T], addr, dc->ring);\n\n                    tcg_temp_free(addr);\n\n                }\n\n                break;\n\n\n\n            default:\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 10: /*FP0*/\n\n            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n            switch (OP2) {\n\n            case 0: /*ADD.Sf*/\n\n                gen_check_cpenable(dc, 0);\n\n                gen_helper_add_s(cpu_FR[RRR_R], cpu_env,\n\n                        cpu_FR[RRR_S], cpu_FR[RRR_T]);\n\n                break;\n\n\n\n            case 1: /*SUB.Sf*/\n\n                gen_check_cpenable(dc, 0);\n\n                gen_helper_sub_s(cpu_FR[RRR_R], cpu_env,\n\n                        cpu_FR[RRR_S], cpu_FR[RRR_T]);\n\n                break;\n\n\n\n            case 2: /*MUL.Sf*/\n\n                gen_check_cpenable(dc, 0);\n\n                gen_helper_mul_s(cpu_FR[RRR_R], cpu_env,\n\n                        cpu_FR[RRR_S], cpu_FR[RRR_T]);\n\n                break;\n\n\n\n            case 4: /*MADD.Sf*/\n\n                gen_check_cpenable(dc, 0);\n\n                gen_helper_madd_s(cpu_FR[RRR_R], cpu_env,\n\n                        cpu_FR[RRR_R], cpu_FR[RRR_S], cpu_FR[RRR_T]);\n\n                break;\n\n\n\n            case 5: /*MSUB.Sf*/\n\n                gen_check_cpenable(dc, 0);\n\n                gen_helper_msub_s(cpu_FR[RRR_R], cpu_env,\n\n                        cpu_FR[RRR_R], cpu_FR[RRR_S], cpu_FR[RRR_T]);\n\n                break;\n\n\n\n            case 8: /*ROUND.Sf*/\n\n            case 9: /*TRUNC.Sf*/\n\n            case 10: /*FLOOR.Sf*/\n\n            case 11: /*CEIL.Sf*/\n\n            case 14: /*UTRUNC.Sf*/\n\n                gen_window_check1(dc, RRR_R);\n\n                gen_check_cpenable(dc, 0);\n\n                {\n\n                    static const unsigned rounding_mode_const[] = {\n\n                        float_round_nearest_even,\n\n                        float_round_to_zero,\n\n                        float_round_down,\n\n                        float_round_up,\n\n                        [6] = float_round_to_zero,\n\n                    };\n\n                    TCGv_i32 rounding_mode = tcg_const_i32(\n\n                            rounding_mode_const[OP2 & 7]);\n\n                    TCGv_i32 scale = tcg_const_i32(RRR_T);\n\n\n\n                    if (OP2 == 14) {\n\n                        gen_helper_ftoui(cpu_R[RRR_R], cpu_FR[RRR_S],\n\n                                rounding_mode, scale);\n\n                    } else {\n\n                        gen_helper_ftoi(cpu_R[RRR_R], cpu_FR[RRR_S],\n\n                                rounding_mode, scale);\n\n                    }\n\n\n\n                    tcg_temp_free(rounding_mode);\n\n                    tcg_temp_free(scale);\n\n                }\n\n                break;\n\n\n\n            case 12: /*FLOAT.Sf*/\n\n            case 13: /*UFLOAT.Sf*/\n\n                gen_window_check1(dc, RRR_S);\n\n                gen_check_cpenable(dc, 0);\n\n                {\n\n                    TCGv_i32 scale = tcg_const_i32(-RRR_T);\n\n\n\n                    if (OP2 == 13) {\n\n                        gen_helper_uitof(cpu_FR[RRR_R], cpu_env,\n\n                                cpu_R[RRR_S], scale);\n\n                    } else {\n\n                        gen_helper_itof(cpu_FR[RRR_R], cpu_env,\n\n                                cpu_R[RRR_S], scale);\n\n                    }\n\n                    tcg_temp_free(scale);\n\n                }\n\n                break;\n\n\n\n            case 15: /*FP1OP*/\n\n                switch (RRR_T) {\n\n                case 0: /*MOV.Sf*/\n\n                    gen_check_cpenable(dc, 0);\n\n                    tcg_gen_mov_i32(cpu_FR[RRR_R], cpu_FR[RRR_S]);\n\n                    break;\n\n\n\n                case 1: /*ABS.Sf*/\n\n                    gen_check_cpenable(dc, 0);\n\n                    gen_helper_abs_s(cpu_FR[RRR_R], cpu_FR[RRR_S]);\n\n                    break;\n\n\n\n                case 4: /*RFRf*/\n\n                    gen_window_check1(dc, RRR_R);\n\n                    gen_check_cpenable(dc, 0);\n\n                    tcg_gen_mov_i32(cpu_R[RRR_R], cpu_FR[RRR_S]);\n\n                    break;\n\n\n\n                case 5: /*WFRf*/\n\n                    gen_window_check1(dc, RRR_S);\n\n                    gen_check_cpenable(dc, 0);\n\n                    tcg_gen_mov_i32(cpu_FR[RRR_R], cpu_R[RRR_S]);\n\n                    break;\n\n\n\n                case 6: /*NEG.Sf*/\n\n                    gen_check_cpenable(dc, 0);\n\n                    gen_helper_neg_s(cpu_FR[RRR_R], cpu_FR[RRR_S]);\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 11: /*FP1*/\n\n            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n\n\n#define gen_compare(rel, br, a, b) \\\n\n    do { \\\n\n        TCGv_i32 bit = tcg_const_i32(1 << br); \\\n\n        \\\n\n        gen_check_cpenable(dc, 0); \\\n\n        gen_helper_##rel(cpu_env, bit, cpu_FR[a], cpu_FR[b]); \\\n\n        tcg_temp_free(bit); \\\n\n    } while (0)\n\n\n\n            switch (OP2) {\n\n            case 1: /*UN.Sf*/\n\n                gen_compare(un_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 2: /*OEQ.Sf*/\n\n                gen_compare(oeq_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 3: /*UEQ.Sf*/\n\n                gen_compare(ueq_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 4: /*OLT.Sf*/\n\n                gen_compare(olt_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 5: /*ULT.Sf*/\n\n                gen_compare(ult_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 6: /*OLE.Sf*/\n\n                gen_compare(ole_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 7: /*ULE.Sf*/\n\n                gen_compare(ule_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n#undef gen_compare\n\n\n\n            case 8: /*MOVEQZ.Sf*/\n\n            case 9: /*MOVNEZ.Sf*/\n\n            case 10: /*MOVLTZ.Sf*/\n\n            case 11: /*MOVGEZ.Sf*/\n\n                gen_window_check1(dc, RRR_T);\n\n                gen_check_cpenable(dc, 0);\n\n                {\n\n                    static const TCGCond cond[] = {\n\n                        TCG_COND_NE,\n\n                        TCG_COND_EQ,\n\n                        TCG_COND_GE,\n\n                        TCG_COND_LT\n\n                    };\n\n                    int label = gen_new_label();\n\n                    tcg_gen_brcondi_i32(cond[OP2 - 8], cpu_R[RRR_T], 0, label);\n\n                    tcg_gen_mov_i32(cpu_FR[RRR_R], cpu_FR[RRR_S]);\n\n                    gen_set_label(label);\n\n                }\n\n                break;\n\n\n\n            case 12: /*MOVF.Sf*/\n\n            case 13: /*MOVT.Sf*/\n\n                HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                gen_check_cpenable(dc, 0);\n\n                {\n\n                    int label = gen_new_label();\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                    tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRR_T);\n\n                    tcg_gen_brcondi_i32(\n\n                            OP2 & 1 ? TCG_COND_EQ : TCG_COND_NE,\n\n                            tmp, 0, label);\n\n                    tcg_gen_mov_i32(cpu_FR[RRR_R], cpu_FR[RRR_S]);\n\n                    gen_set_label(label);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 1: /*L32R*/\n\n        gen_window_check1(dc, RRR_T);\n\n        {\n\n            TCGv_i32 tmp = tcg_const_i32(\n\n                    ((dc->tb->flags & XTENSA_TBFLAG_LITBASE) ?\n\n                     0 : ((dc->pc + 3) & ~3)) +\n\n                    (0xfffc0000 | (RI16_IMM16 << 2)));\n\n\n\n            if (dc->tb->flags & XTENSA_TBFLAG_LITBASE) {\n\n                tcg_gen_add_i32(tmp, tmp, dc->litbase);\n\n            }\n\n            tcg_gen_qemu_ld32u(cpu_R[RRR_T], tmp, dc->cring);\n\n            tcg_temp_free(tmp);\n\n        }\n\n        break;\n\n\n\n    case 2: /*LSAI*/\n\n#define gen_load_store(type, shift) do { \\\n\n            TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n            gen_window_check2(dc, RRI8_S, RRI8_T); \\\n\n            tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << shift); \\\n\n            if (shift) { \\\n\n                gen_load_store_alignment(dc, shift, addr, false); \\\n\n            } \\\n\n            tcg_gen_qemu_##type(cpu_R[RRI8_T], addr, dc->cring); \\\n\n            tcg_temp_free(addr); \\\n\n        } while (0)\n\n\n\n        switch (RRI8_R) {\n\n        case 0: /*L8UI*/\n\n            gen_load_store(ld8u, 0);\n\n            break;\n\n\n\n        case 1: /*L16UI*/\n\n            gen_load_store(ld16u, 1);\n\n            break;\n\n\n\n        case 2: /*L32I*/\n\n            gen_load_store(ld32u, 2);\n\n            break;\n\n\n\n        case 4: /*S8I*/\n\n            gen_load_store(st8, 0);\n\n            break;\n\n\n\n        case 5: /*S16I*/\n\n            gen_load_store(st16, 1);\n\n            break;\n\n\n\n        case 6: /*S32I*/\n\n            gen_load_store(st32, 2);\n\n            break;\n\n\n\n        case 7: /*CACHEc*/\n\n            if (RRI8_T < 8) {\n\n                HAS_OPTION(XTENSA_OPTION_DCACHE);\n\n            }\n\n\n\n            switch (RRI8_T) {\n\n            case 0: /*DPFRc*/\n\n                break;\n\n\n\n            case 1: /*DPFWc*/\n\n                break;\n\n\n\n            case 2: /*DPFROc*/\n\n                break;\n\n\n\n            case 3: /*DPFWOc*/\n\n                break;\n\n\n\n            case 4: /*DHWBc*/\n\n                break;\n\n\n\n            case 5: /*DHWBIc*/\n\n                break;\n\n\n\n            case 6: /*DHIc*/\n\n                break;\n\n\n\n            case 7: /*DIIc*/\n\n                break;\n\n\n\n            case 8: /*DCEc*/\n\n                switch (OP1) {\n\n                case 0: /*DPFLl*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);\n\n                    break;\n\n\n\n                case 2: /*DHUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);\n\n                    break;\n\n\n\n                case 3: /*DIUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);\n\n                    break;\n\n\n\n                case 4: /*DIWBc*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE);\n\n                    break;\n\n\n\n                case 5: /*DIWBIc*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE);\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n\n\n                }\n\n                break;\n\n\n\n            case 12: /*IPFc*/\n\n                HAS_OPTION(XTENSA_OPTION_ICACHE);\n\n                break;\n\n\n\n            case 13: /*ICEc*/\n\n                switch (OP1) {\n\n                case 0: /*IPFLl*/\n\n                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);\n\n                    break;\n\n\n\n                case 2: /*IHUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);\n\n                    break;\n\n\n\n                case 3: /*IIUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            case 14: /*IHIc*/\n\n                HAS_OPTION(XTENSA_OPTION_ICACHE);\n\n                break;\n\n\n\n            case 15: /*IIIc*/\n\n                HAS_OPTION(XTENSA_OPTION_ICACHE);\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 9: /*L16SI*/\n\n            gen_load_store(ld16s, 1);\n\n            break;\n\n#undef gen_load_store\n\n\n\n        case 10: /*MOVI*/\n\n            gen_window_check1(dc, RRI8_T);\n\n            tcg_gen_movi_i32(cpu_R[RRI8_T],\n\n                    RRI8_IMM8 | (RRI8_S << 8) |\n\n                    ((RRI8_S & 0x8) ? 0xfffff000 : 0));\n\n            break;\n\n\n\n#define gen_load_store_no_hw_align(type) do { \\\n\n            TCGv_i32 addr = tcg_temp_local_new_i32(); \\\n\n            gen_window_check2(dc, RRI8_S, RRI8_T); \\\n\n            tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2); \\\n\n            gen_load_store_alignment(dc, 2, addr, true); \\\n\n            tcg_gen_qemu_##type(cpu_R[RRI8_T], addr, dc->cring); \\\n\n            tcg_temp_free(addr); \\\n\n        } while (0)\n\n\n\n        case 11: /*L32AIy*/\n\n            HAS_OPTION(XTENSA_OPTION_MP_SYNCHRO);\n\n            gen_load_store_no_hw_align(ld32u); /*TODO acquire?*/\n\n            break;\n\n\n\n        case 12: /*ADDI*/\n\n            gen_window_check2(dc, RRI8_S, RRI8_T);\n\n            tcg_gen_addi_i32(cpu_R[RRI8_T], cpu_R[RRI8_S], RRI8_IMM8_SE);\n\n            break;\n\n\n\n        case 13: /*ADDMI*/\n\n            gen_window_check2(dc, RRI8_S, RRI8_T);\n\n            tcg_gen_addi_i32(cpu_R[RRI8_T], cpu_R[RRI8_S], RRI8_IMM8_SE << 8);\n\n            break;\n\n\n\n        case 14: /*S32C1Iy*/\n\n            HAS_OPTION(XTENSA_OPTION_CONDITIONAL_STORE);\n\n            gen_window_check2(dc, RRI8_S, RRI8_T);\n\n            {\n\n                int label = gen_new_label();\n\n                TCGv_i32 tmp = tcg_temp_local_new_i32();\n\n                TCGv_i32 addr = tcg_temp_local_new_i32();\n\n                TCGv_i32 tpc;\n\n\n\n                tcg_gen_mov_i32(tmp, cpu_R[RRI8_T]);\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2);\n\n                gen_load_store_alignment(dc, 2, addr, true);\n\n\n\n                gen_advance_ccount(dc);\n\n                tpc = tcg_const_i32(dc->pc);\n\n                gen_helper_check_atomctl(cpu_env, tpc, addr);\n\n                tcg_gen_qemu_ld32u(cpu_R[RRI8_T], addr, dc->cring);\n\n                tcg_gen_brcond_i32(TCG_COND_NE, cpu_R[RRI8_T],\n\n                        cpu_SR[SCOMPARE1], label);\n\n\n\n                tcg_gen_qemu_st32(tmp, addr, dc->cring);\n\n\n\n                gen_set_label(label);\n\n                tcg_temp_free(tpc);\n\n                tcg_temp_free(addr);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n\n\n        case 15: /*S32RIy*/\n\n            HAS_OPTION(XTENSA_OPTION_MP_SYNCHRO);\n\n            gen_load_store_no_hw_align(st32); /*TODO release?*/\n\n            break;\n\n#undef gen_load_store_no_hw_align\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 3: /*LSCIp*/\n\n        switch (RRI8_R) {\n\n        case 0: /*LSIf*/\n\n        case 4: /*SSIf*/\n\n        case 8: /*LSIUf*/\n\n        case 12: /*SSIUf*/\n\n            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n            gen_window_check1(dc, RRI8_S);\n\n            gen_check_cpenable(dc, 0);\n\n            {\n\n                TCGv_i32 addr = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2);\n\n                gen_load_store_alignment(dc, 2, addr, false);\n\n                if (RRI8_R & 0x4) {\n\n                    tcg_gen_qemu_st32(cpu_FR[RRI8_T], addr, dc->cring);\n\n                } else {\n\n                    tcg_gen_qemu_ld32u(cpu_FR[RRI8_T], addr, dc->cring);\n\n                }\n\n                if (RRI8_R & 0x8) {\n\n                    tcg_gen_mov_i32(cpu_R[RRI8_S], addr);\n\n                }\n\n                tcg_temp_free(addr);\n\n            }\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 4: /*MAC16d*/\n\n        HAS_OPTION(XTENSA_OPTION_MAC16);\n\n        {\n\n            enum {\n\n                MAC16_UMUL = 0x0,\n\n                MAC16_MUL  = 0x4,\n\n                MAC16_MULA = 0x8,\n\n                MAC16_MULS = 0xc,\n\n                MAC16_NONE = 0xf,\n\n            } op = OP1 & 0xc;\n\n            bool is_m1_sr = (OP2 & 0x3) == 2;\n\n            bool is_m2_sr = (OP2 & 0xc) == 0;\n\n            uint32_t ld_offset = 0;\n\n\n\n            if (OP2 > 9) {\n\n                RESERVED();\n\n            }\n\n\n\n            switch (OP2 & 2) {\n\n            case 0: /*MACI?/MACC?*/\n\n                is_m1_sr = true;\n\n                ld_offset = (OP2 & 1) ? -4 : 4;\n\n\n\n                if (OP2 >= 8) { /*MACI/MACC*/\n\n                    if (OP1 == 0) { /*LDINC/LDDEC*/\n\n                        op = MAC16_NONE;\n\n                    } else {\n\n                        RESERVED();\n\n                    }\n\n                } else if (op != MAC16_MULA) { /*MULA.*.*.LDINC/LDDEC*/\n\n                    RESERVED();\n\n                }\n\n                break;\n\n\n\n            case 2: /*MACD?/MACA?*/\n\n                if (op == MAC16_UMUL && OP2 != 7) { /*UMUL only in MACAA*/\n\n                    RESERVED();\n\n                }\n\n                break;\n\n            }\n\n\n\n            if (op != MAC16_NONE) {\n\n                if (!is_m1_sr) {\n\n                    gen_window_check1(dc, RRR_S);\n\n                }\n\n                if (!is_m2_sr) {\n\n                    gen_window_check1(dc, RRR_T);\n\n                }\n\n            }\n\n\n\n            {\n\n                TCGv_i32 vaddr = tcg_temp_new_i32();\n\n                TCGv_i32 mem32 = tcg_temp_new_i32();\n\n\n\n                if (ld_offset) {\n\n                    gen_window_check1(dc, RRR_S);\n\n                    tcg_gen_addi_i32(vaddr, cpu_R[RRR_S], ld_offset);\n\n                    gen_load_store_alignment(dc, 2, vaddr, false);\n\n                    tcg_gen_qemu_ld32u(mem32, vaddr, dc->cring);\n\n                }\n\n                if (op != MAC16_NONE) {\n\n                    TCGv_i32 m1 = gen_mac16_m(\n\n                            is_m1_sr ? cpu_SR[MR + RRR_X] : cpu_R[RRR_S],\n\n                            OP1 & 1, op == MAC16_UMUL);\n\n                    TCGv_i32 m2 = gen_mac16_m(\n\n                            is_m2_sr ? cpu_SR[MR + 2 + RRR_Y] : cpu_R[RRR_T],\n\n                            OP1 & 2, op == MAC16_UMUL);\n\n\n\n                    if (op == MAC16_MUL || op == MAC16_UMUL) {\n\n                        tcg_gen_mul_i32(cpu_SR[ACCLO], m1, m2);\n\n                        if (op == MAC16_UMUL) {\n\n                            tcg_gen_movi_i32(cpu_SR[ACCHI], 0);\n\n                        } else {\n\n                            tcg_gen_sari_i32(cpu_SR[ACCHI], cpu_SR[ACCLO], 31);\n\n                        }\n\n                    } else {\n\n                        TCGv_i32 res = tcg_temp_new_i32();\n\n                        TCGv_i64 res64 = tcg_temp_new_i64();\n\n                        TCGv_i64 tmp = tcg_temp_new_i64();\n\n\n\n                        tcg_gen_mul_i32(res, m1, m2);\n\n                        tcg_gen_ext_i32_i64(res64, res);\n\n                        tcg_gen_concat_i32_i64(tmp,\n\n                                cpu_SR[ACCLO], cpu_SR[ACCHI]);\n\n                        if (op == MAC16_MULA) {\n\n                            tcg_gen_add_i64(tmp, tmp, res64);\n\n                        } else {\n\n                            tcg_gen_sub_i64(tmp, tmp, res64);\n\n                        }\n\n                        tcg_gen_trunc_i64_i32(cpu_SR[ACCLO], tmp);\n\n                        tcg_gen_shri_i64(tmp, tmp, 32);\n\n                        tcg_gen_trunc_i64_i32(cpu_SR[ACCHI], tmp);\n\n                        tcg_gen_ext8s_i32(cpu_SR[ACCHI], cpu_SR[ACCHI]);\n\n\n\n                        tcg_temp_free(res);\n\n                        tcg_temp_free_i64(res64);\n\n                        tcg_temp_free_i64(tmp);\n\n                    }\n\n                    tcg_temp_free(m1);\n\n                    tcg_temp_free(m2);\n\n                }\n\n                if (ld_offset) {\n\n                    tcg_gen_mov_i32(cpu_R[RRR_S], vaddr);\n\n                    tcg_gen_mov_i32(cpu_SR[MR + RRR_W], mem32);\n\n                }\n\n                tcg_temp_free(vaddr);\n\n                tcg_temp_free(mem32);\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 5: /*CALLN*/\n\n        switch (CALL_N) {\n\n        case 0: /*CALL0*/\n\n            tcg_gen_movi_i32(cpu_R[0], dc->next_pc);\n\n            gen_jumpi(dc, (dc->pc & ~3) + (CALL_OFFSET_SE << 2) + 4, 0);\n\n            break;\n\n\n\n        case 1: /*CALL4w*/\n\n        case 2: /*CALL8w*/\n\n        case 3: /*CALL12w*/\n\n            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n            gen_window_check1(dc, CALL_N << 2);\n\n            gen_callwi(dc, CALL_N,\n\n                    (dc->pc & ~3) + (CALL_OFFSET_SE << 2) + 4, 0);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 6: /*SI*/\n\n        switch (CALL_N) {\n\n        case 0: /*J*/\n\n            gen_jumpi(dc, dc->pc + 4 + CALL_OFFSET_SE, 0);\n\n            break;\n\n\n\n        case 1: /*BZ*/\n\n            gen_window_check1(dc, BRI12_S);\n\n            {\n\n                static const TCGCond cond[] = {\n\n                    TCG_COND_EQ, /*BEQZ*/\n\n                    TCG_COND_NE, /*BNEZ*/\n\n                    TCG_COND_LT, /*BLTZ*/\n\n                    TCG_COND_GE, /*BGEZ*/\n\n                };\n\n\n\n                gen_brcondi(dc, cond[BRI12_M & 3], cpu_R[BRI12_S], 0,\n\n                        4 + BRI12_IMM12_SE);\n\n            }\n\n            break;\n\n\n\n        case 2: /*BI0*/\n\n            gen_window_check1(dc, BRI8_S);\n\n            {\n\n                static const TCGCond cond[] = {\n\n                    TCG_COND_EQ, /*BEQI*/\n\n                    TCG_COND_NE, /*BNEI*/\n\n                    TCG_COND_LT, /*BLTI*/\n\n                    TCG_COND_GE, /*BGEI*/\n\n                };\n\n\n\n                gen_brcondi(dc, cond[BRI8_M & 3],\n\n                        cpu_R[BRI8_S], B4CONST[BRI8_R], 4 + BRI8_IMM8_SE);\n\n            }\n\n            break;\n\n\n\n        case 3: /*BI1*/\n\n            switch (BRI8_M) {\n\n            case 0: /*ENTRYw*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                {\n\n                    TCGv_i32 pc = tcg_const_i32(dc->pc);\n\n                    TCGv_i32 s = tcg_const_i32(BRI12_S);\n\n                    TCGv_i32 imm = tcg_const_i32(BRI12_IMM12);\n\n                    gen_advance_ccount(dc);\n\n                    gen_helper_entry(cpu_env, pc, s, imm);\n\n                    tcg_temp_free(imm);\n\n                    tcg_temp_free(s);\n\n                    tcg_temp_free(pc);\n\n                    reset_used_window(dc);\n\n                }\n\n                break;\n\n\n\n            case 1: /*B1*/\n\n                switch (BRI8_R) {\n\n                case 0: /*BFp*/\n\n                case 1: /*BTp*/\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                    {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRI8_S);\n\n                        gen_brcondi(dc,\n\n                                BRI8_R == 1 ? TCG_COND_NE : TCG_COND_EQ,\n\n                                tmp, 0, 4 + RRI8_IMM8_SE);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 8: /*LOOP*/\n\n                case 9: /*LOOPNEZ*/\n\n                case 10: /*LOOPGTZ*/\n\n                    HAS_OPTION(XTENSA_OPTION_LOOP);\n\n                    gen_window_check1(dc, RRI8_S);\n\n                    {\n\n                        uint32_t lend = dc->pc + RRI8_IMM8 + 4;\n\n                        TCGv_i32 tmp = tcg_const_i32(lend);\n\n\n\n                        tcg_gen_subi_i32(cpu_SR[LCOUNT], cpu_R[RRI8_S], 1);\n\n                        tcg_gen_movi_i32(cpu_SR[LBEG], dc->next_pc);\n\n                        gen_helper_wsr_lend(cpu_env, tmp);\n\n                        tcg_temp_free(tmp);\n\n\n\n                        if (BRI8_R > 8) {\n\n                            int label = gen_new_label();\n\n                            tcg_gen_brcondi_i32(\n\n                                    BRI8_R == 9 ? TCG_COND_NE : TCG_COND_GT,\n\n                                    cpu_R[RRI8_S], 0, label);\n\n                            gen_jumpi(dc, lend, 1);\n\n                            gen_set_label(label);\n\n                        }\n\n\n\n                        gen_jumpi(dc, dc->next_pc, 0);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n\n\n                }\n\n                break;\n\n\n\n            case 2: /*BLTUI*/\n\n            case 3: /*BGEUI*/\n\n                gen_window_check1(dc, BRI8_S);\n\n                gen_brcondi(dc, BRI8_M == 2 ? TCG_COND_LTU : TCG_COND_GEU,\n\n                        cpu_R[BRI8_S], B4CONSTU[BRI8_R], 4 + BRI8_IMM8_SE);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        }\n\n        break;\n\n\n\n    case 7: /*B*/\n\n        {\n\n            TCGCond eq_ne = (RRI8_R & 8) ? TCG_COND_NE : TCG_COND_EQ;\n\n\n\n            switch (RRI8_R & 7) {\n\n            case 0: /*BNONE*/ /*BANY*/\n\n                gen_window_check2(dc, RRI8_S, RRI8_T);\n\n                {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], cpu_R[RRI8_T]);\n\n                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 1: /*BEQ*/ /*BNE*/\n\n            case 2: /*BLT*/ /*BGE*/\n\n            case 3: /*BLTU*/ /*BGEU*/\n\n                gen_window_check2(dc, RRI8_S, RRI8_T);\n\n                {\n\n                    static const TCGCond cond[] = {\n\n                        [1] = TCG_COND_EQ,\n\n                        [2] = TCG_COND_LT,\n\n                        [3] = TCG_COND_LTU,\n\n                        [9] = TCG_COND_NE,\n\n                        [10] = TCG_COND_GE,\n\n                        [11] = TCG_COND_GEU,\n\n                    };\n\n                    gen_brcond(dc, cond[RRI8_R], cpu_R[RRI8_S], cpu_R[RRI8_T],\n\n                            4 + RRI8_IMM8_SE);\n\n                }\n\n                break;\n\n\n\n            case 4: /*BALL*/ /*BNALL*/\n\n                gen_window_check2(dc, RRI8_S, RRI8_T);\n\n                {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], cpu_R[RRI8_T]);\n\n                    gen_brcond(dc, eq_ne, tmp, cpu_R[RRI8_T],\n\n                            4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 5: /*BBC*/ /*BBS*/\n\n                gen_window_check2(dc, RRI8_S, RRI8_T);\n\n                {\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n                    TCGv_i32 bit = tcg_const_i32(0x80000000);\n\n#else\n\n                    TCGv_i32 bit = tcg_const_i32(0x00000001);\n\n#endif\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_andi_i32(tmp, cpu_R[RRI8_T], 0x1f);\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n                    tcg_gen_shr_i32(bit, bit, tmp);\n\n#else\n\n                    tcg_gen_shl_i32(bit, bit, tmp);\n\n#endif\n\n                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], bit);\n\n                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                    tcg_temp_free(bit);\n\n                }\n\n                break;\n\n\n\n            case 6: /*BBCI*/ /*BBSI*/\n\n            case 7:\n\n                gen_window_check1(dc, RRI8_S);\n\n                {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_andi_i32(tmp, cpu_R[RRI8_S],\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n                            0x80000000 >> (((RRI8_R & 1) << 4) | RRI8_T));\n\n#else\n\n                            0x00000001 << (((RRI8_R & 1) << 4) | RRI8_T));\n\n#endif\n\n                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            }\n\n        }\n\n        break;\n\n\n\n#define gen_narrow_load_store(type) do { \\\n\n            TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n            gen_window_check2(dc, RRRN_S, RRRN_T); \\\n\n            tcg_gen_addi_i32(addr, cpu_R[RRRN_S], RRRN_R << 2); \\\n\n            gen_load_store_alignment(dc, 2, addr, false); \\\n\n            tcg_gen_qemu_##type(cpu_R[RRRN_T], addr, dc->cring); \\\n\n            tcg_temp_free(addr); \\\n\n        } while (0)\n\n\n\n    case 8: /*L32I.Nn*/\n\n        gen_narrow_load_store(ld32u);\n\n        break;\n\n\n\n    case 9: /*S32I.Nn*/\n\n        gen_narrow_load_store(st32);\n\n        break;\n\n#undef gen_narrow_load_store\n\n\n\n    case 10: /*ADD.Nn*/\n\n        gen_window_check3(dc, RRRN_R, RRRN_S, RRRN_T);\n\n        tcg_gen_add_i32(cpu_R[RRRN_R], cpu_R[RRRN_S], cpu_R[RRRN_T]);\n\n        break;\n\n\n\n    case 11: /*ADDI.Nn*/\n\n        gen_window_check2(dc, RRRN_R, RRRN_S);\n\n        tcg_gen_addi_i32(cpu_R[RRRN_R], cpu_R[RRRN_S], RRRN_T ? RRRN_T : -1);\n\n        break;\n\n\n\n    case 12: /*ST2n*/\n\n        gen_window_check1(dc, RRRN_S);\n\n        if (RRRN_T < 8) { /*MOVI.Nn*/\n\n            tcg_gen_movi_i32(cpu_R[RRRN_S],\n\n                    RRRN_R | (RRRN_T << 4) |\n\n                    ((RRRN_T & 6) == 6 ? 0xffffff80 : 0));\n\n        } else { /*BEQZ.Nn*/ /*BNEZ.Nn*/\n\n            TCGCond eq_ne = (RRRN_T & 4) ? TCG_COND_NE : TCG_COND_EQ;\n\n\n\n            gen_brcondi(dc, eq_ne, cpu_R[RRRN_S], 0,\n\n                    4 + (RRRN_R | ((RRRN_T & 3) << 4)));\n\n        }\n\n        break;\n\n\n\n    case 13: /*ST3n*/\n\n        switch (RRRN_R) {\n\n        case 0: /*MOV.Nn*/\n\n            gen_window_check2(dc, RRRN_S, RRRN_T);\n\n            tcg_gen_mov_i32(cpu_R[RRRN_T], cpu_R[RRRN_S]);\n\n            break;\n\n\n\n        case 15: /*S3*/\n\n            switch (RRRN_T) {\n\n            case 0: /*RET.Nn*/\n\n                gen_jump(dc, cpu_R[0]);\n\n                break;\n\n\n\n            case 1: /*RETW.Nn*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                {\n\n                    TCGv_i32 tmp = tcg_const_i32(dc->pc);\n\n                    gen_advance_ccount(dc);\n\n                    gen_helper_retw(tmp, cpu_env, tmp);\n\n                    gen_jump(dc, tmp);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 2: /*BREAK.Nn*/\n\n                HAS_OPTION(XTENSA_OPTION_DEBUG);\n\n                if (dc->debug) {\n\n                    gen_debug_exception(dc, DEBUGCAUSE_BN);\n\n                }\n\n                break;\n\n\n\n            case 3: /*NOP.Nn*/\n\n                break;\n\n\n\n            case 6: /*ILL.Nn*/\n\n                gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default: /*reserved*/\n\n        RESERVED();\n\n        break;\n\n    }\n\n\n\n    if (dc->is_jmp == DISAS_NEXT) {\n\n        gen_check_loop_end(dc, 0);\n\n    }\n\n    dc->pc = dc->next_pc;\n\n\n\n    return;\n\n\n\ninvalid_opcode:\n\n    qemu_log(\"INVALID(pc = %08x)\\n\", dc->pc);\n\n    gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n#undef HAS_OPTION\n\n}\n", "idx": 24705}
{"project": "qemu", "commit_id": "f186d64d8fda4bb22c15beb8e45b7814fbd8b51e", "target": 0, "func": "bool replay_checkpoint(ReplayCheckpoint checkpoint)\n\n{\n\n    bool res = false;\n\n    assert(EVENT_CHECKPOINT + checkpoint <= EVENT_CHECKPOINT_LAST);\n\n    replay_save_instructions();\n\n\n\n    if (!replay_file) {\n\n        return true;\n\n    }\n\n\n\n    replay_mutex_lock();\n\n\n\n    if (replay_mode == REPLAY_MODE_PLAY) {\n\n        if (replay_next_event_is(EVENT_CHECKPOINT + checkpoint)) {\n\n            replay_finish_event();\n\n        } else if (replay_data_kind != EVENT_ASYNC) {\n\n            res = false;\n\n            goto out;\n\n        }\n\n        replay_read_events(checkpoint);\n\n        /* replay_read_events may leave some unread events.\n\n           Return false if not all of the events associated with\n\n           checkpoint were processed */\n\n        res = replay_data_kind != EVENT_ASYNC;\n\n    } else if (replay_mode == REPLAY_MODE_RECORD) {\n\n        replay_put_event(EVENT_CHECKPOINT + checkpoint);\n\n        replay_save_events(checkpoint);\n\n        res = true;\n\n    }\n\nout:\n\n    replay_mutex_unlock();\n\n    return res;\n\n}\n", "idx": 24711}
{"project": "qemu", "commit_id": "0e9b9edae7bebfd31fdbead4ccbbce03876a7edd", "target": 0, "func": "void virt_acpi_setup(VirtGuestInfo *guest_info)\n\n{\n\n    AcpiBuildTables tables;\n\n    AcpiBuildState *build_state;\n\n\n\n    if (!guest_info->fw_cfg) {\n\n        trace_virt_acpi_setup();\n\n        return;\n\n    }\n\n\n\n    if (!acpi_enabled) {\n\n        trace_virt_acpi_setup();\n\n        return;\n\n    }\n\n\n\n    build_state = g_malloc0(sizeof *build_state);\n\n    build_state->guest_info = guest_info;\n\n\n\n    acpi_build_tables_init(&tables);\n\n    virt_acpi_build(build_state->guest_info, &tables);\n\n\n\n    /* Now expose it all to Guest */\n\n    build_state->table_mr = acpi_add_rom_blob(build_state, tables.table_data,\n\n                                               ACPI_BUILD_TABLE_FILE,\n\n                                               ACPI_BUILD_TABLE_MAX_SIZE);\n\n    assert(build_state->table_mr != NULL);\n\n\n\n    build_state->linker_mr =\n\n        acpi_add_rom_blob(build_state, tables.linker, \"etc/table-loader\", 0);\n\n\n\n    fw_cfg_add_file(guest_info->fw_cfg, ACPI_BUILD_TPMLOG_FILE,\n\n                    tables.tcpalog->data, acpi_data_len(tables.tcpalog));\n\n\n\n    build_state->rsdp_mr = acpi_add_rom_blob(build_state, tables.rsdp,\n\n                                              ACPI_BUILD_RSDP_FILE, 0);\n\n\n\n    qemu_register_reset(virt_acpi_build_reset, build_state);\n\n    virt_acpi_build_reset(build_state);\n\n    vmstate_register(NULL, 0, &vmstate_virt_acpi_build, build_state);\n\n\n\n    /* Cleanup tables but don't free the memory: we track it\n\n     * in build_state.\n\n     */\n\n    acpi_build_tables_cleanup(&tables, false);\n\n}\n", "idx": 24712}
{"project": "qemu", "commit_id": "541dc0d47f10973c241e9955afc2aefc96adec51", "target": 0, "func": "void test_fenv(void)\n\n{\n\n    struct __attribute__((packed)) {\n\n        uint16_t fpuc;\n\n        uint16_t dummy1;\n\n        uint16_t fpus;\n\n        uint16_t dummy2;\n\n        uint16_t fptag;\n\n        uint16_t dummy3;\n\n        uint32_t ignored[4];\n\n        long double fpregs[8];\n\n    } float_env32;\n\n    struct __attribute__((packed)) {\n\n        uint16_t fpuc;\n\n        uint16_t fpus;\n\n        uint16_t fptag;\n\n        uint16_t ignored[4];\n\n        long double fpregs[8];\n\n    } float_env16;\n\n    double dtab[8];\n\n    double rtab[8];\n\n    int i;\n\n\n\n    for(i=0;i<8;i++)\n\n        dtab[i] = i + 1;\n\n\n\n    TEST_ENV(&float_env16, \"data16 fnstenv\", \"data16 fldenv\");\n\n    TEST_ENV(&float_env16, \"data16 fnsave\", \"data16 frstor\");\n\n    TEST_ENV(&float_env32, \"fnstenv\", \"fldenv\");\n\n    TEST_ENV(&float_env32, \"fnsave\", \"frstor\");\n\n\n\n    /* test for ffree */\n\n    for(i=0;i<5;i++)\n\n        asm volatile (\"fldl %0\" : : \"m\" (dtab[i]));\n\n    asm volatile(\"ffree %st(2)\");\n\n    asm volatile (\"fnstenv %0\\n\" : : \"m\" (float_env32));\n\n    asm volatile (\"fninit\");\n\n    printf(\"fptag=%04x\\n\", float_env32.fptag);\n\n}\n", "idx": 24713}
{"project": "qemu", "commit_id": "01fa55982692fb51a16049b63b571651a1053989", "target": 0, "func": "static void migrate_params_apply(MigrateSetParameters *params)\n\n{\n\n    MigrationState *s = migrate_get_current();\n\n\n\n    /* TODO use QAPI_CLONE() instead of duplicating it inline */\n\n\n\n    if (params->has_compress_level) {\n\n        s->parameters.compress_level = params->compress_level;\n\n    }\n\n\n\n    if (params->has_compress_threads) {\n\n        s->parameters.compress_threads = params->compress_threads;\n\n    }\n\n\n\n    if (params->has_decompress_threads) {\n\n        s->parameters.decompress_threads = params->decompress_threads;\n\n    }\n\n\n\n    if (params->has_cpu_throttle_initial) {\n\n        s->parameters.cpu_throttle_initial = params->cpu_throttle_initial;\n\n    }\n\n\n\n    if (params->has_cpu_throttle_increment) {\n\n        s->parameters.cpu_throttle_increment = params->cpu_throttle_increment;\n\n    }\n\n\n\n    if (params->has_tls_creds) {\n\n        g_free(s->parameters.tls_creds);\n\n        s->parameters.tls_creds = g_strdup(params->tls_creds);\n\n    }\n\n\n\n    if (params->has_tls_hostname) {\n\n        g_free(s->parameters.tls_hostname);\n\n        s->parameters.tls_hostname = g_strdup(params->tls_hostname);\n\n    }\n\n\n\n    if (params->has_max_bandwidth) {\n\n        s->parameters.max_bandwidth = params->max_bandwidth;\n\n        if (s->to_dst_file) {\n\n            qemu_file_set_rate_limit(s->to_dst_file,\n\n                                s->parameters.max_bandwidth / XFER_LIMIT_RATIO);\n\n        }\n\n    }\n\n\n\n    if (params->has_downtime_limit) {\n\n        s->parameters.downtime_limit = params->downtime_limit;\n\n    }\n\n\n\n    if (params->has_x_checkpoint_delay) {\n\n        s->parameters.x_checkpoint_delay = params->x_checkpoint_delay;\n\n        if (migration_in_colo_state()) {\n\n            colo_checkpoint_notify(s);\n\n        }\n\n    }\n\n\n\n    if (params->has_block_incremental) {\n\n        s->parameters.block_incremental = params->block_incremental;\n\n    }\n\n}\n", "idx": 24714}
{"project": "qemu", "commit_id": "ba801af429aaa68f6cc03842c8b6be81a6ede65a", "target": 0, "func": "void helper_mtc0_wired(CPUMIPSState *env, target_ulong arg1)\n\n{\n\n    env->CP0_Wired = arg1 % env->tlb->nb_tlb;\n\n}\n", "idx": 24715}
{"project": "qemu", "commit_id": "13f1c773640171efa8175b1ba6dcd624c1ad68c1", "target": 0, "func": "static void openrisc_sim_machine_init(MachineClass *mc)\n\n{\n\n    mc->desc = \"or1k simulation\";\n\n    mc->init = openrisc_sim_init;\n\n    mc->max_cpus = 1;\n\n    mc->is_default = 1;\n\n}\n", "idx": 24716}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static int multiwrite_req_compare(const void *a, const void *b)\n\n{\n\n    const BlockRequest *req1 = a, *req2 = b;\n\n\n\n    /*\n\n     * Note that we can't simply subtract req2->sector from req1->sector\n\n     * here as that could overflow the return value.\n\n     */\n\n    if (req1->sector > req2->sector) {\n\n        return 1;\n\n    } else if (req1->sector < req2->sector) {\n\n        return -1;\n\n    } else {\n\n        return 0;\n\n    }\n\n}\n", "idx": 24717}
{"project": "qemu", "commit_id": "d21e8776f6578be155714ae95c7d6c1bb03e8e34", "target": 0, "func": "static void iothread_complete(UserCreatable *obj, Error **errp)\n\n{\n\n    Error *local_error = NULL;\n\n    IOThread *iothread = IOTHREAD(obj);\n\n\n\n    iothread->stopping = false;\n\n    iothread->thread_id = -1;\n\n    iothread->ctx = aio_context_new(&local_error);\n\n    if (!iothread->ctx) {\n\n        error_propagate(errp, local_error);\n\n        return;\n\n    }\n\n\n\n    qemu_mutex_init(&iothread->init_done_lock);\n\n    qemu_cond_init(&iothread->init_done_cond);\n\n\n\n    /* This assumes we are called from a thread with useful CPU affinity for us\n\n     * to inherit.\n\n     */\n\n    qemu_thread_create(&iothread->thread, \"iothread\", iothread_run,\n\n                       iothread, QEMU_THREAD_JOINABLE);\n\n\n\n    /* Wait for initialization to complete */\n\n    qemu_mutex_lock(&iothread->init_done_lock);\n\n    while (iothread->thread_id == -1) {\n\n        qemu_cond_wait(&iothread->init_done_cond,\n\n                       &iothread->init_done_lock);\n\n    }\n\n    qemu_mutex_unlock(&iothread->init_done_lock);\n\n}\n", "idx": 24718}
{"project": "qemu", "commit_id": "945473847b4bb0869915aa47dabc4d2abbc87bdb", "target": 0, "func": "restore_fpu_state(CPUSPARCState *env, qemu_siginfo_fpu_t *fpu)\n\n{\n\n        int err;\n\n#if 0\n\n#ifdef CONFIG_SMP\n\n        if (current->flags & PF_USEDFPU)\n\n                regs->psr &= ~PSR_EF;\n\n#else\n\n        if (current == last_task_used_math) {\n\n                last_task_used_math = 0;\n\n                regs->psr &= ~PSR_EF;\n\n        }\n\n#endif\n\n        current->used_math = 1;\n\n        current->flags &= ~PF_USEDFPU;\n\n#endif\n\n#if 0\n\n        if (verify_area (VERIFY_READ, fpu, sizeof(*fpu)))\n\n                return -EFAULT;\n\n#endif\n\n\n\n        /* XXX: incorrect */\n\n        err = copy_from_user(&env->fpr[0], fpu->si_float_regs[0],\n\n                             (sizeof(abi_ulong) * 32));\n\n        err |= __get_user(env->fsr, &fpu->si_fsr);\n\n#if 0\n\n        err |= __get_user(current->thread.fpqdepth, &fpu->si_fpqdepth);\n\n        if (current->thread.fpqdepth != 0)\n\n                err |= __copy_from_user(&current->thread.fpqueue[0],\n\n                                        &fpu->si_fpqueue[0],\n\n                                        ((sizeof(unsigned long) +\n\n                                        (sizeof(unsigned long *)))*16));\n\n#endif\n\n        return err;\n\n}\n", "idx": 24719}
{"project": "qemu", "commit_id": "edf779ffccc836661a7b654d320571a6c220caea", "target": 0, "func": "static void setup_frame(int sig, struct emulated_sigaction *ka,\n\n\t\t\ttarget_sigset_t *set, CPUX86State *env)\n\n{\n\n\tstruct sigframe *frame;\n\n\tint err = 0;\n\n\n\n\tframe = get_sigframe(ka, env, sizeof(*frame));\n\n\n\n#if 0\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\n\t\tgoto give_sigsegv;\n\n#endif\n\n\terr |= __put_user((/*current->exec_domain\n\n\t\t           && current->exec_domain->signal_invmap\n\n\t\t           && sig < 32\n\n\t\t           ? current->exec_domain->signal_invmap[sig]\n\n\t\t           : */ sig),\n\n\t\t          &frame->sig);\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\tsetup_sigcontext(&frame->sc, &frame->fpstate, env, set->sig[0]);\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\tif (TARGET_NSIG_WORDS > 1) {\n\n\t\terr |= __copy_to_user(frame->extramask, &set->sig[1],\n\n\t\t\t\t      sizeof(frame->extramask));\n\n\t}\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up to return from userspace.  If provided, use a stub\n\n\t   already in userspace.  */\n\n\tif (ka->sa.sa_flags & TARGET_SA_RESTORER) {\n\n\t\terr |= __put_user(ka->sa.sa_restorer, &frame->pretcode);\n\n\t} else {\n\n\t\terr |= __put_user(frame->retcode, &frame->pretcode);\n\n\t\t/* This is popl %eax ; movl $,%eax ; int $0x80 */\n\n\t\terr |= __put_user(0xb858, (short *)(frame->retcode+0));\n\n\t\terr |= __put_user(TARGET_NR_sigreturn, (int *)(frame->retcode+2));\n\n\t\terr |= __put_user(0x80cd, (short *)(frame->retcode+6));\n\n\t}\n\n\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up registers for signal handler */\n\n\tenv->regs[R_ESP] = (unsigned long) frame;\n\n\tenv->eip = (unsigned long) ka->sa._sa_handler;\n\n\n\n        cpu_x86_load_seg(env, R_DS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_ES, __USER_DS);\n\n        cpu_x86_load_seg(env, R_SS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_CS, __USER_CS);\n\n\tenv->eflags &= ~TF_MASK;\n\n\n\n\treturn;\n\n\n\ngive_sigsegv:\n\n\tif (sig == TARGET_SIGSEGV)\n\n\t\tka->sa._sa_handler = TARGET_SIG_DFL;\n\n\tforce_sig(TARGET_SIGSEGV /* , current */);\n\n}\n", "idx": 24720}
{"project": "qemu", "commit_id": "ec990eb622ad46df5ddcb1e94c418c271894d416", "target": 0, "func": "int qdev_init(DeviceState *dev)\n\n{\n\n    int rc;\n\n\n\n    assert(dev->state == DEV_STATE_CREATED);\n\n    rc = dev->info->init(dev, dev->info);\n\n    if (rc < 0) {\n\n        qdev_free(dev);\n\n        return rc;\n\n    }\n\n    qemu_register_reset(qdev_reset, dev);\n\n    if (dev->info->vmsd) {\n\n        vmstate_register_with_alias_id(dev, -1, dev->info->vmsd, dev,\n\n                                       dev->instance_id_alias,\n\n                                       dev->alias_required_for_version);\n\n    }\n\n    dev->state = DEV_STATE_INITIALIZED;\n\n    return 0;\n\n}\n", "idx": 24722}
{"project": "qemu", "commit_id": "6b7d4c55586a849aa8313282d79432917eade3bf", "target": 0, "func": "static int coroutine_fn copy_sectors(BlockDriverState *bs,\n\n                                     uint64_t start_sect,\n\n                                     uint64_t cluster_offset,\n\n                                     int n_start, int n_end)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    QEMUIOVector qiov;\n\n    struct iovec iov;\n\n    int n, ret;\n\n\n\n    /*\n\n     * If this is the last cluster and it is only partially used, we must only\n\n     * copy until the end of the image, or bdrv_check_request will fail for the\n\n     * bdrv_read/write calls below.\n\n     */\n\n    if (start_sect + n_end > bs->total_sectors) {\n\n        n_end = bs->total_sectors - start_sect;\n\n    }\n\n\n\n    n = n_end - n_start;\n\n    if (n <= 0) {\n\n        return 0;\n\n    }\n\n\n\n    iov.iov_len = n * BDRV_SECTOR_SIZE;\n\n    iov.iov_base = qemu_blockalign(bs, iov.iov_len);\n\n\n\n    qemu_iovec_init_external(&qiov, &iov, 1);\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_COW_READ);\n\n\n\n    if (!bs->drv) {\n\n        return -ENOMEDIUM;\n\n    }\n\n\n\n    /* Call .bdrv_co_readv() directly instead of using the public block-layer\n\n     * interface.  This avoids double I/O throttling and request tracking,\n\n     * which can lead to deadlock when block layer copy-on-read is enabled.\n\n     */\n\n    ret = bs->drv->bdrv_co_readv(bs, start_sect + n_start, n, &qiov);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    if (s->crypt_method) {\n\n        qcow2_encrypt_sectors(s, start_sect + n_start,\n\n                        iov.iov_base, iov.iov_base, n, 1,\n\n                        &s->aes_encrypt_key);\n\n    }\n\n\n\n    ret = qcow2_pre_write_overlap_check(bs, 0,\n\n            cluster_offset + n_start * BDRV_SECTOR_SIZE, n * BDRV_SECTOR_SIZE);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_COW_WRITE);\n\n    ret = bdrv_co_writev(bs->file, (cluster_offset >> 9) + n_start, n, &qiov);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    qemu_vfree(iov.iov_base);\n\n    return ret;\n\n}\n", "idx": 24723}
{"project": "qemu", "commit_id": "94b037f2a451b3dc855f9f2c346e5049a361bd55", "target": 0, "func": "static int xhci_ep_nuke_xfers(XHCIState *xhci, unsigned int slotid,\n\n                               unsigned int epid, TRBCCode report)\n\n{\n\n    XHCISlot *slot;\n\n    XHCIEPContext *epctx;\n\n    int i, xferi, killed = 0;\n\n    USBEndpoint *ep = NULL;\n\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n\n    assert(epid >= 1 && epid <= 31);\n\n\n\n    DPRINTF(\"xhci_ep_nuke_xfers(%d, %d)\\n\", slotid, epid);\n\n\n\n    slot = &xhci->slots[slotid-1];\n\n\n\n    if (!slot->eps[epid-1]) {\n\n        return 0;\n\n    }\n\n\n\n    epctx = slot->eps[epid-1];\n\n\n\n    xferi = epctx->next_xfer;\n\n    for (i = 0; i < TD_QUEUE; i++) {\n\n        killed += xhci_ep_nuke_one_xfer(&epctx->transfers[xferi], report);\n\n        if (killed) {\n\n            report = 0; /* Only report once */\n\n        }\n\n        epctx->transfers[xferi].packet.ep = NULL;\n\n        xferi = (xferi + 1) % TD_QUEUE;\n\n    }\n\n\n\n    ep = xhci_epid_to_usbep(xhci, slotid, epid);\n\n    if (ep) {\n\n        usb_device_ep_stopped(ep->dev, ep);\n\n    }\n\n    return killed;\n\n}\n", "idx": 24724}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static inline void gen_branch_slot(uint32_t delayed_pc, int t)\n\n{\n\n    TCGv sr;\n\n    int label = gen_new_label();\n\n    tcg_gen_movi_i32(cpu_delayed_pc, delayed_pc);\n\n    sr = tcg_temp_new();\n\n    tcg_gen_andi_i32(sr, cpu_sr, SR_T);\n\n    tcg_gen_brcondi_i32(t ? TCG_COND_EQ:TCG_COND_NE, sr, 0, label);\n\n    tcg_gen_ori_i32(cpu_flags, cpu_flags, DELAY_SLOT_TRUE);\n\n    gen_set_label(label);\n\n}\n", "idx": 24725}
{"project": "qemu", "commit_id": "1f01e50b8330c24714ddca5841fdbb703076b121", "target": 0, "func": "static int coroutine_fn qed_aio_write_inplace(QEDAIOCB *acb, uint64_t offset,\n\n                                              size_t len)\n\n{\n\n    /* Allocate buffer for zero writes */\n\n    if (acb->flags & QED_AIOCB_ZERO) {\n\n        struct iovec *iov = acb->qiov->iov;\n\n\n\n        if (!iov->iov_base) {\n\n            iov->iov_base = qemu_try_blockalign(acb->bs, iov->iov_len);\n\n            if (iov->iov_base == NULL) {\n\n                return -ENOMEM;\n\n            }\n\n            memset(iov->iov_base, 0, iov->iov_len);\n\n        }\n\n    }\n\n\n\n    /* Calculate the I/O vector */\n\n    acb->cur_cluster = offset;\n\n    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);\n\n\n\n    /* Do the actual write */\n\n    return qed_aio_write_main(acb);\n\n}\n", "idx": 24726}
{"project": "qemu", "commit_id": "439e2a6e10ed7f5da819bf7dcaa54b8cfdbeab0d", "target": 0, "func": "Aml *aml_add(Aml *arg1, Aml *arg2)\n\n{\n\n    Aml *var = aml_opcode(0x72 /* AddOp */);\n\n    aml_append(var, arg1);\n\n    aml_append(var, arg2);\n\n    build_append_byte(var->buf, 0x00 /* NullNameOp */);\n\n    return var;\n\n}\n", "idx": 24727}
{"project": "qemu", "commit_id": "f0495f56c9f4574140c392bdbad42721ba692d19", "target": 0, "func": "static int menelaus_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    MenelausState *s = (MenelausState *) opaque;\n\n\n\n    s->firstbyte = qemu_get_be32(f);\n\n    qemu_get_8s(f, &s->reg);\n\n\n\n    if (s->rtc.ctrl & 1)\t\t\t\t\t/* RTC_EN */\n\n        menelaus_rtc_stop(s);\n\n    qemu_get_8s(f, &s->vcore[0]);\n\n    qemu_get_8s(f, &s->vcore[1]);\n\n    qemu_get_8s(f, &s->vcore[2]);\n\n    qemu_get_8s(f, &s->vcore[3]);\n\n    qemu_get_8s(f, &s->vcore[4]);\n\n    qemu_get_8s(f, &s->dcdc[0]);\n\n    qemu_get_8s(f, &s->dcdc[1]);\n\n    qemu_get_8s(f, &s->dcdc[2]);\n\n    qemu_get_8s(f, &s->ldo[0]);\n\n    qemu_get_8s(f, &s->ldo[1]);\n\n    qemu_get_8s(f, &s->ldo[2]);\n\n    qemu_get_8s(f, &s->ldo[3]);\n\n    qemu_get_8s(f, &s->ldo[4]);\n\n    qemu_get_8s(f, &s->ldo[5]);\n\n    qemu_get_8s(f, &s->ldo[6]);\n\n    qemu_get_8s(f, &s->ldo[7]);\n\n    qemu_get_8s(f, &s->sleep[0]);\n\n    qemu_get_8s(f, &s->sleep[1]);\n\n    qemu_get_8s(f, &s->osc);\n\n    qemu_get_8s(f, &s->detect);\n\n    qemu_get_be16s(f, &s->mask);\n\n    qemu_get_be16s(f, &s->status);\n\n    qemu_get_8s(f, &s->dir);\n\n    qemu_get_8s(f, &s->inputs);\n\n    qemu_get_8s(f, &s->outputs);\n\n    qemu_get_8s(f, &s->bbsms);\n\n    qemu_get_8s(f, &s->pull[0]);\n\n    qemu_get_8s(f, &s->pull[1]);\n\n    qemu_get_8s(f, &s->pull[2]);\n\n    qemu_get_8s(f, &s->pull[3]);\n\n    qemu_get_8s(f, &s->mmc_ctrl[0]);\n\n    qemu_get_8s(f, &s->mmc_ctrl[1]);\n\n    qemu_get_8s(f, &s->mmc_ctrl[2]);\n\n    qemu_get_8s(f, &s->mmc_debounce);\n\n    qemu_get_8s(f, &s->rtc.ctrl);\n\n    qemu_get_be16s(f, &s->rtc.comp);\n\n    s->rtc.next = qemu_get_be16(f);\n\n    tm_get(f, &s->rtc.new);\n\n    tm_get(f, &s->rtc.alm);\n\n    s->pwrbtn_state = qemu_get_byte(f);\n\n    menelaus_alm_update(s);\n\n    menelaus_update(s);\n\n    if (s->rtc.ctrl & 1)\t\t\t\t\t/* RTC_EN */\n\n        menelaus_rtc_start(s);\n\n\n\n    i2c_slave_load(f, &s->i2c);\n\n    return 0;\n\n}\n", "idx": 24728}
{"project": "qemu", "commit_id": "a911a182a6bfd3b0257b13f862b0d4fbd9392715", "target": 0, "func": "static void put_fid(V9fsPDU *pdu, V9fsFidState *fidp)\n\n{\n\n    BUG_ON(!fidp->ref);\n\n    fidp->ref--;\n\n    /*\n\n     * Don't free the fid if it is in reclaim list\n\n     */\n\n    if (!fidp->ref && fidp->clunked) {\n\n        if (fidp->fid == pdu->s->root_fid) {\n\n            /*\n\n             * if the clunked fid is root fid then we\n\n             * have unmounted the fs on the client side.\n\n             * delete the migration blocker. Ideally, this\n\n             * should be hooked to transport close notification\n\n             */\n\n            if (pdu->s->migration_blocker) {\n\n                migrate_del_blocker(pdu->s->migration_blocker);\n\n                error_free(pdu->s->migration_blocker);\n\n                pdu->s->migration_blocker = NULL;\n\n            }\n\n        }\n\n        free_fid(pdu, fidp);\n\n    }\n\n}\n", "idx": 24729}
{"project": "qemu", "commit_id": "ce137829e7e58fcdc5ba63b5e256f972e80be438", "target": 1, "func": "static void write_target_close(BlockDriverState *bs) {\n\n    BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque);\n\n    bdrv_delete(s->qcow);\n\n    free(s->qcow_filename);\n\n}\n", "idx": 24730}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void moxiesim_init(MachineState *machine)\n\n{\n\n    MoxieCPU *cpu = NULL;\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    CPUMoxieState *env;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *rom = g_new(MemoryRegion, 1);\n\n    hwaddr ram_base = 0x200000;\n\n    LoaderParams loader_params;\n\n\n\n    /* Init CPUs. */\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"MoxieLite-moxie-cpu\";\n\n    }\n\n    cpu = MOXIE_CPU(cpu_generic_init(TYPE_MOXIE_CPU, cpu_model));\n\n    if (!cpu) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    qemu_register_reset(main_cpu_reset, cpu);\n\n\n\n    /* Allocate RAM. */\n\n    memory_region_init_ram(ram, NULL, \"moxiesim.ram\", ram_size, &error_fatal);\n\n    memory_region_add_subregion(address_space_mem, ram_base, ram);\n\n\n\n    memory_region_init_ram(rom, NULL, \"moxie.rom\", 128 * 0x1000, &error_fatal);\n\n    memory_region_add_subregion(get_system_memory(), 0x1000, rom);\n\n\n\n    if (kernel_filename) {\n\n        loader_params.ram_size = ram_size;\n\n        loader_params.kernel_filename = kernel_filename;\n\n        loader_params.kernel_cmdline = kernel_cmdline;\n\n        loader_params.initrd_filename = initrd_filename;\n\n        load_kernel(cpu, &loader_params);\n\n    }\n\n\n\n    /* A single 16450 sits at offset 0x3f8.  */\n\n    if (serial_hds[0]) {\n\n        serial_mm_init(address_space_mem, 0x3f8, 0, env->irq[4],\n\n                       8000000/16, serial_hds[0], DEVICE_LITTLE_ENDIAN);\n\n    }\n\n}\n", "idx": 24733}
{"project": "qemu", "commit_id": "e668d1b8545f1c79cf869bd78813cb1e52216f45", "target": 1, "func": "static void build_guest_fsinfo_for_virtual_device(char const *syspath,\n\n                                                  GuestFilesystemInfo *fs,\n\n                                                  Error **errp)\n\n{\n\n    DIR *dir;\n\n    char *dirpath;\n\n    struct dirent entry, *result;\n\n\n\n    dirpath = g_strdup_printf(\"%s/slaves\", syspath);\n\n    dir = opendir(dirpath);\n\n    if (!dir) {\n\n        error_setg_errno(errp, errno, \"opendir(\\\"%s\\\")\", dirpath);\n\n        g_free(dirpath);\n\n        return;\n\n    }\n\n    g_free(dirpath);\n\n\n\n    for (;;) {\n\n        if (readdir_r(dir, &entry, &result) != 0) {\n\n            error_setg_errno(errp, errno, \"readdir_r(\\\"%s\\\")\", dirpath);\n\n            break;\n\n        }\n\n        if (!result) {\n\n            break;\n\n        }\n\n\n\n        if (entry.d_type == DT_LNK) {\n\n            g_debug(\" slave device '%s'\", entry.d_name);\n\n            dirpath = g_strdup_printf(\"%s/slaves/%s\", syspath, entry.d_name);\n\n            build_guest_fsinfo_for_device(dirpath, fs, errp);\n\n            g_free(dirpath);\n\n\n\n            if (*errp) {\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    closedir(dir);\n\n}\n", "idx": 24734}
{"project": "qemu", "commit_id": "9ecac5dad16722ce2a8c3e88d8eeba5794990031", "target": 1, "func": "static void gen_sse(CPUX86State *env, DisasContext *s, int b,\n\n                    target_ulong pc_start, int rex_r)\n\n{\n\n    int b1, op1_offset, op2_offset, is_xmm, val;\n\n    int modrm, mod, rm, reg;\n\n    SSEFunc_0_epp sse_fn_epp;\n\n    SSEFunc_0_eppi sse_fn_eppi;\n\n    SSEFunc_0_ppi sse_fn_ppi;\n\n    SSEFunc_0_eppt sse_fn_eppt;\n\n    TCGMemOp ot;\n\n\n\n    b &= 0xff;\n\n    if (s->prefix & PREFIX_DATA)\n\n        b1 = 1;\n\n    else if (s->prefix & PREFIX_REPZ)\n\n        b1 = 2;\n\n    else if (s->prefix & PREFIX_REPNZ)\n\n        b1 = 3;\n\n    else\n\n        b1 = 0;\n\n    sse_fn_epp = sse_op_table1[b][b1];\n\n    if (!sse_fn_epp) {\n\n        goto illegal_op;\n\n    }\n\n    if ((b <= 0x5f && b >= 0x10) || b == 0xc6 || b == 0xc2) {\n\n        is_xmm = 1;\n\n    } else {\n\n        if (b1 == 0) {\n\n            /* MMX case */\n\n            is_xmm = 0;\n\n        } else {\n\n            is_xmm = 1;\n\n        }\n\n    }\n\n    /* simple MMX/SSE operation */\n\n    if (s->flags & HF_TS_MASK) {\n\n        gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n        return;\n\n    }\n\n    if (s->flags & HF_EM_MASK) {\n\n    illegal_op:\n\n        gen_exception(s, EXCP06_ILLOP, pc_start - s->cs_base);\n\n        return;\n\n    }\n\n    if (is_xmm && !(s->flags & HF_OSFXSR_MASK))\n\n        if ((b != 0x38 && b != 0x3a) || (s->prefix & PREFIX_DATA))\n\n            goto illegal_op;\n\n    if (b == 0x0e) {\n\n        if (!(s->cpuid_ext2_features & CPUID_EXT2_3DNOW))\n\n            goto illegal_op;\n\n        /* femms */\n\n        gen_helper_emms(cpu_env);\n\n        return;\n\n    }\n\n    if (b == 0x77) {\n\n        /* emms */\n\n        gen_helper_emms(cpu_env);\n\n        return;\n\n    }\n\n    /* prepare MMX state (XXX: optimize by storing fptt and fptags in\n\n       the static cpu state) */\n\n    if (!is_xmm) {\n\n        gen_helper_enter_mmx(cpu_env);\n\n    }\n\n\n\n    modrm = cpu_ldub_code(env, s->pc++);\n\n    reg = ((modrm >> 3) & 7);\n\n    if (is_xmm)\n\n        reg |= rex_r;\n\n    mod = (modrm >> 6) & 3;\n\n    if (sse_fn_epp == SSE_SPECIAL) {\n\n        b |= (b1 << 8);\n\n        switch(b) {\n\n        case 0x0e7: /* movntq */\n\n            if (mod == 3)\n\n                goto illegal_op;\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_stq_env_A0(s, offsetof(CPUX86State, fpregs[reg].mmx));\n\n            break;\n\n        case 0x1e7: /* movntdq */\n\n        case 0x02b: /* movntps */\n\n        case 0x12b: /* movntps */\n\n            if (mod == 3)\n\n                goto illegal_op;\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_sto_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n\n            break;\n\n        case 0x3f0: /* lddqu */\n\n            if (mod == 3)\n\n                goto illegal_op;\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_ldo_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n\n            break;\n\n        case 0x22b: /* movntss */\n\n        case 0x32b: /* movntsd */\n\n            if (mod == 3)\n\n                goto illegal_op;\n\n            gen_lea_modrm(env, s, modrm);\n\n            if (b1 & 1) {\n\n                gen_stq_env_A0(s, offsetof(CPUX86State,\n\n                                           xmm_regs[reg].XMM_Q(0)));\n\n            } else {\n\n                tcg_gen_ld32u_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,\n\n                    xmm_regs[reg].XMM_L(0)));\n\n                gen_op_st_v(s, MO_32, cpu_T[0], cpu_A0);\n\n            }\n\n            break;\n\n        case 0x6e: /* movd mm, ea */\n\n#ifdef TARGET_X86_64\n\n            if (s->dflag == MO_64) {\n\n                gen_ldst_modrm(env, s, modrm, MO_64, OR_TMP0, 0);\n\n                tcg_gen_st_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,fpregs[reg].mmx));\n\n            } else\n\n#endif\n\n            {\n\n                gen_ldst_modrm(env, s, modrm, MO_32, OR_TMP0, 0);\n\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env, \n\n                                 offsetof(CPUX86State,fpregs[reg].mmx));\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                gen_helper_movl_mm_T0_mmx(cpu_ptr0, cpu_tmp2_i32);\n\n            }\n\n            break;\n\n        case 0x16e: /* movd xmm, ea */\n\n#ifdef TARGET_X86_64\n\n            if (s->dflag == MO_64) {\n\n                gen_ldst_modrm(env, s, modrm, MO_64, OR_TMP0, 0);\n\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env, \n\n                                 offsetof(CPUX86State,xmm_regs[reg]));\n\n                gen_helper_movq_mm_T0_xmm(cpu_ptr0, cpu_T[0]);\n\n            } else\n\n#endif\n\n            {\n\n                gen_ldst_modrm(env, s, modrm, MO_32, OR_TMP0, 0);\n\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env, \n\n                                 offsetof(CPUX86State,xmm_regs[reg]));\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                gen_helper_movl_mm_T0_xmm(cpu_ptr0, cpu_tmp2_i32);\n\n            }\n\n            break;\n\n        case 0x6f: /* movq mm, ea */\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_ldq_env_A0(s, offsetof(CPUX86State, fpregs[reg].mmx));\n\n            } else {\n\n                rm = (modrm & 7);\n\n                tcg_gen_ld_i64(cpu_tmp1_i64, cpu_env,\n\n                               offsetof(CPUX86State,fpregs[rm].mmx));\n\n                tcg_gen_st_i64(cpu_tmp1_i64, cpu_env,\n\n                               offsetof(CPUX86State,fpregs[reg].mmx));\n\n            }\n\n            break;\n\n        case 0x010: /* movups */\n\n        case 0x110: /* movupd */\n\n        case 0x028: /* movaps */\n\n        case 0x128: /* movapd */\n\n        case 0x16f: /* movdqa xmm, ea */\n\n        case 0x26f: /* movdqu xmm, ea */\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_ldo_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n\n            } else {\n\n                rm = (modrm & 7) | REX_B(s);\n\n                gen_op_movo(offsetof(CPUX86State,xmm_regs[reg]),\n\n                            offsetof(CPUX86State,xmm_regs[rm]));\n\n            }\n\n            break;\n\n        case 0x210: /* movss xmm, ea */\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_op_ld_v(s, MO_32, cpu_T[0], cpu_A0);\n\n                tcg_gen_st32_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,xmm_regs[reg].XMM_L(0)));\n\n                tcg_gen_movi_tl(cpu_T[0], 0);\n\n                tcg_gen_st32_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,xmm_regs[reg].XMM_L(1)));\n\n                tcg_gen_st32_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,xmm_regs[reg].XMM_L(2)));\n\n                tcg_gen_st32_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,xmm_regs[reg].XMM_L(3)));\n\n            } else {\n\n                rm = (modrm & 7) | REX_B(s);\n\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].XMM_L(0)),\n\n                            offsetof(CPUX86State,xmm_regs[rm].XMM_L(0)));\n\n            }\n\n            break;\n\n        case 0x310: /* movsd xmm, ea */\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_ldq_env_A0(s, offsetof(CPUX86State,\n\n                                           xmm_regs[reg].XMM_Q(0)));\n\n                tcg_gen_movi_tl(cpu_T[0], 0);\n\n                tcg_gen_st32_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,xmm_regs[reg].XMM_L(2)));\n\n                tcg_gen_st32_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,xmm_regs[reg].XMM_L(3)));\n\n            } else {\n\n                rm = (modrm & 7) | REX_B(s);\n\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].XMM_Q(0)),\n\n                            offsetof(CPUX86State,xmm_regs[rm].XMM_Q(0)));\n\n            }\n\n            break;\n\n        case 0x012: /* movlps */\n\n        case 0x112: /* movlpd */\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_ldq_env_A0(s, offsetof(CPUX86State,\n\n                                           xmm_regs[reg].XMM_Q(0)));\n\n            } else {\n\n                /* movhlps */\n\n                rm = (modrm & 7) | REX_B(s);\n\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].XMM_Q(0)),\n\n                            offsetof(CPUX86State,xmm_regs[rm].XMM_Q(1)));\n\n            }\n\n            break;\n\n        case 0x212: /* movsldup */\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_ldo_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n\n            } else {\n\n                rm = (modrm & 7) | REX_B(s);\n\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].XMM_L(0)),\n\n                            offsetof(CPUX86State,xmm_regs[rm].XMM_L(0)));\n\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].XMM_L(2)),\n\n                            offsetof(CPUX86State,xmm_regs[rm].XMM_L(2)));\n\n            }\n\n            gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].XMM_L(1)),\n\n                        offsetof(CPUX86State,xmm_regs[reg].XMM_L(0)));\n\n            gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].XMM_L(3)),\n\n                        offsetof(CPUX86State,xmm_regs[reg].XMM_L(2)));\n\n            break;\n\n        case 0x312: /* movddup */\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_ldq_env_A0(s, offsetof(CPUX86State,\n\n                                           xmm_regs[reg].XMM_Q(0)));\n\n            } else {\n\n                rm = (modrm & 7) | REX_B(s);\n\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].XMM_Q(0)),\n\n                            offsetof(CPUX86State,xmm_regs[rm].XMM_Q(0)));\n\n            }\n\n            gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].XMM_Q(1)),\n\n                        offsetof(CPUX86State,xmm_regs[reg].XMM_Q(0)));\n\n            break;\n\n        case 0x016: /* movhps */\n\n        case 0x116: /* movhpd */\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_ldq_env_A0(s, offsetof(CPUX86State,\n\n                                           xmm_regs[reg].XMM_Q(1)));\n\n            } else {\n\n                /* movlhps */\n\n                rm = (modrm & 7) | REX_B(s);\n\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].XMM_Q(1)),\n\n                            offsetof(CPUX86State,xmm_regs[rm].XMM_Q(0)));\n\n            }\n\n            break;\n\n        case 0x216: /* movshdup */\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_ldo_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n\n            } else {\n\n                rm = (modrm & 7) | REX_B(s);\n\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].XMM_L(1)),\n\n                            offsetof(CPUX86State,xmm_regs[rm].XMM_L(1)));\n\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].XMM_L(3)),\n\n                            offsetof(CPUX86State,xmm_regs[rm].XMM_L(3)));\n\n            }\n\n            gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].XMM_L(0)),\n\n                        offsetof(CPUX86State,xmm_regs[reg].XMM_L(1)));\n\n            gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].XMM_L(2)),\n\n                        offsetof(CPUX86State,xmm_regs[reg].XMM_L(3)));\n\n            break;\n\n        case 0x178:\n\n        case 0x378:\n\n            {\n\n                int bit_index, field_length;\n\n\n\n                if (b1 == 1 && reg != 0)\n\n                    goto illegal_op;\n\n                field_length = cpu_ldub_code(env, s->pc++) & 0x3F;\n\n                bit_index = cpu_ldub_code(env, s->pc++) & 0x3F;\n\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env,\n\n                    offsetof(CPUX86State,xmm_regs[reg]));\n\n                if (b1 == 1)\n\n                    gen_helper_extrq_i(cpu_env, cpu_ptr0,\n\n                                       tcg_const_i32(bit_index),\n\n                                       tcg_const_i32(field_length));\n\n                else\n\n                    gen_helper_insertq_i(cpu_env, cpu_ptr0,\n\n                                         tcg_const_i32(bit_index),\n\n                                         tcg_const_i32(field_length));\n\n            }\n\n            break;\n\n        case 0x7e: /* movd ea, mm */\n\n#ifdef TARGET_X86_64\n\n            if (s->dflag == MO_64) {\n\n                tcg_gen_ld_i64(cpu_T[0], cpu_env, \n\n                               offsetof(CPUX86State,fpregs[reg].mmx));\n\n                gen_ldst_modrm(env, s, modrm, MO_64, OR_TMP0, 1);\n\n            } else\n\n#endif\n\n            {\n\n                tcg_gen_ld32u_tl(cpu_T[0], cpu_env, \n\n                                 offsetof(CPUX86State,fpregs[reg].mmx.MMX_L(0)));\n\n                gen_ldst_modrm(env, s, modrm, MO_32, OR_TMP0, 1);\n\n            }\n\n            break;\n\n        case 0x17e: /* movd ea, xmm */\n\n#ifdef TARGET_X86_64\n\n            if (s->dflag == MO_64) {\n\n                tcg_gen_ld_i64(cpu_T[0], cpu_env, \n\n                               offsetof(CPUX86State,xmm_regs[reg].XMM_Q(0)));\n\n                gen_ldst_modrm(env, s, modrm, MO_64, OR_TMP0, 1);\n\n            } else\n\n#endif\n\n            {\n\n                tcg_gen_ld32u_tl(cpu_T[0], cpu_env, \n\n                                 offsetof(CPUX86State,xmm_regs[reg].XMM_L(0)));\n\n                gen_ldst_modrm(env, s, modrm, MO_32, OR_TMP0, 1);\n\n            }\n\n            break;\n\n        case 0x27e: /* movq xmm, ea */\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_ldq_env_A0(s, offsetof(CPUX86State,\n\n                                           xmm_regs[reg].XMM_Q(0)));\n\n            } else {\n\n                rm = (modrm & 7) | REX_B(s);\n\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].XMM_Q(0)),\n\n                            offsetof(CPUX86State,xmm_regs[rm].XMM_Q(0)));\n\n            }\n\n            gen_op_movq_env_0(offsetof(CPUX86State,xmm_regs[reg].XMM_Q(1)));\n\n            break;\n\n        case 0x7f: /* movq ea, mm */\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_stq_env_A0(s, offsetof(CPUX86State, fpregs[reg].mmx));\n\n            } else {\n\n                rm = (modrm & 7);\n\n                gen_op_movq(offsetof(CPUX86State,fpregs[rm].mmx),\n\n                            offsetof(CPUX86State,fpregs[reg].mmx));\n\n            }\n\n            break;\n\n        case 0x011: /* movups */\n\n        case 0x111: /* movupd */\n\n        case 0x029: /* movaps */\n\n        case 0x129: /* movapd */\n\n        case 0x17f: /* movdqa ea, xmm */\n\n        case 0x27f: /* movdqu ea, xmm */\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_sto_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n\n            } else {\n\n                rm = (modrm & 7) | REX_B(s);\n\n                gen_op_movo(offsetof(CPUX86State,xmm_regs[rm]),\n\n                            offsetof(CPUX86State,xmm_regs[reg]));\n\n            }\n\n            break;\n\n        case 0x211: /* movss ea, xmm */\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                tcg_gen_ld32u_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,xmm_regs[reg].XMM_L(0)));\n\n                gen_op_st_v(s, MO_32, cpu_T[0], cpu_A0);\n\n            } else {\n\n                rm = (modrm & 7) | REX_B(s);\n\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[rm].XMM_L(0)),\n\n                            offsetof(CPUX86State,xmm_regs[reg].XMM_L(0)));\n\n            }\n\n            break;\n\n        case 0x311: /* movsd ea, xmm */\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_stq_env_A0(s, offsetof(CPUX86State,\n\n                                           xmm_regs[reg].XMM_Q(0)));\n\n            } else {\n\n                rm = (modrm & 7) | REX_B(s);\n\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[rm].XMM_Q(0)),\n\n                            offsetof(CPUX86State,xmm_regs[reg].XMM_Q(0)));\n\n            }\n\n            break;\n\n        case 0x013: /* movlps */\n\n        case 0x113: /* movlpd */\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_stq_env_A0(s, offsetof(CPUX86State,\n\n                                           xmm_regs[reg].XMM_Q(0)));\n\n            } else {\n\n                goto illegal_op;\n\n            }\n\n            break;\n\n        case 0x017: /* movhps */\n\n        case 0x117: /* movhpd */\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_stq_env_A0(s, offsetof(CPUX86State,\n\n                                           xmm_regs[reg].XMM_Q(1)));\n\n            } else {\n\n                goto illegal_op;\n\n            }\n\n            break;\n\n        case 0x71: /* shift mm, im */\n\n        case 0x72:\n\n        case 0x73:\n\n        case 0x171: /* shift xmm, im */\n\n        case 0x172:\n\n        case 0x173:\n\n            if (b1 >= 2) {\n\n\t        goto illegal_op;\n\n            }\n\n            val = cpu_ldub_code(env, s->pc++);\n\n            if (is_xmm) {\n\n                tcg_gen_movi_tl(cpu_T[0], val);\n\n                tcg_gen_st32_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,xmm_t0.XMM_L(0)));\n\n                tcg_gen_movi_tl(cpu_T[0], 0);\n\n                tcg_gen_st32_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,xmm_t0.XMM_L(1)));\n\n                op1_offset = offsetof(CPUX86State,xmm_t0);\n\n            } else {\n\n                tcg_gen_movi_tl(cpu_T[0], val);\n\n                tcg_gen_st32_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,mmx_t0.MMX_L(0)));\n\n                tcg_gen_movi_tl(cpu_T[0], 0);\n\n                tcg_gen_st32_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,mmx_t0.MMX_L(1)));\n\n                op1_offset = offsetof(CPUX86State,mmx_t0);\n\n            }\n\n            sse_fn_epp = sse_op_table2[((b - 1) & 3) * 8 +\n\n                                       (((modrm >> 3)) & 7)][b1];\n\n            if (!sse_fn_epp) {\n\n                goto illegal_op;\n\n            }\n\n            if (is_xmm) {\n\n                rm = (modrm & 7) | REX_B(s);\n\n                op2_offset = offsetof(CPUX86State,xmm_regs[rm]);\n\n            } else {\n\n                rm = (modrm & 7);\n\n                op2_offset = offsetof(CPUX86State,fpregs[rm].mmx);\n\n            }\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op2_offset);\n\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op1_offset);\n\n            sse_fn_epp(cpu_env, cpu_ptr0, cpu_ptr1);\n\n            break;\n\n        case 0x050: /* movmskps */\n\n            rm = (modrm & 7) | REX_B(s);\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, \n\n                             offsetof(CPUX86State,xmm_regs[rm]));\n\n            gen_helper_movmskps(cpu_tmp2_i32, cpu_env, cpu_ptr0);\n\n            tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);\n\n            break;\n\n        case 0x150: /* movmskpd */\n\n            rm = (modrm & 7) | REX_B(s);\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, \n\n                             offsetof(CPUX86State,xmm_regs[rm]));\n\n            gen_helper_movmskpd(cpu_tmp2_i32, cpu_env, cpu_ptr0);\n\n            tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);\n\n            break;\n\n        case 0x02a: /* cvtpi2ps */\n\n        case 0x12a: /* cvtpi2pd */\n\n            gen_helper_enter_mmx(cpu_env);\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                op2_offset = offsetof(CPUX86State,mmx_t0);\n\n                gen_ldq_env_A0(s, op2_offset);\n\n            } else {\n\n                rm = (modrm & 7);\n\n                op2_offset = offsetof(CPUX86State,fpregs[rm].mmx);\n\n            }\n\n            op1_offset = offsetof(CPUX86State,xmm_regs[reg]);\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n\n            switch(b >> 8) {\n\n            case 0x0:\n\n                gen_helper_cvtpi2ps(cpu_env, cpu_ptr0, cpu_ptr1);\n\n                break;\n\n            default:\n\n            case 0x1:\n\n                gen_helper_cvtpi2pd(cpu_env, cpu_ptr0, cpu_ptr1);\n\n                break;\n\n            }\n\n            break;\n\n        case 0x22a: /* cvtsi2ss */\n\n        case 0x32a: /* cvtsi2sd */\n\n            ot = mo_64_32(s->dflag);\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n            op1_offset = offsetof(CPUX86State,xmm_regs[reg]);\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n\n            if (ot == MO_32) {\n\n                SSEFunc_0_epi sse_fn_epi = sse_op_table3ai[(b >> 8) & 1];\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                sse_fn_epi(cpu_env, cpu_ptr0, cpu_tmp2_i32);\n\n            } else {\n\n#ifdef TARGET_X86_64\n\n                SSEFunc_0_epl sse_fn_epl = sse_op_table3aq[(b >> 8) & 1];\n\n                sse_fn_epl(cpu_env, cpu_ptr0, cpu_T[0]);\n\n#else\n\n                goto illegal_op;\n\n#endif\n\n            }\n\n            break;\n\n        case 0x02c: /* cvttps2pi */\n\n        case 0x12c: /* cvttpd2pi */\n\n        case 0x02d: /* cvtps2pi */\n\n        case 0x12d: /* cvtpd2pi */\n\n            gen_helper_enter_mmx(cpu_env);\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                op2_offset = offsetof(CPUX86State,xmm_t0);\n\n                gen_ldo_env_A0(s, op2_offset);\n\n            } else {\n\n                rm = (modrm & 7) | REX_B(s);\n\n                op2_offset = offsetof(CPUX86State,xmm_regs[rm]);\n\n            }\n\n            op1_offset = offsetof(CPUX86State,fpregs[reg & 7].mmx);\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n\n            switch(b) {\n\n            case 0x02c:\n\n                gen_helper_cvttps2pi(cpu_env, cpu_ptr0, cpu_ptr1);\n\n                break;\n\n            case 0x12c:\n\n                gen_helper_cvttpd2pi(cpu_env, cpu_ptr0, cpu_ptr1);\n\n                break;\n\n            case 0x02d:\n\n                gen_helper_cvtps2pi(cpu_env, cpu_ptr0, cpu_ptr1);\n\n                break;\n\n            case 0x12d:\n\n                gen_helper_cvtpd2pi(cpu_env, cpu_ptr0, cpu_ptr1);\n\n                break;\n\n            }\n\n            break;\n\n        case 0x22c: /* cvttss2si */\n\n        case 0x32c: /* cvttsd2si */\n\n        case 0x22d: /* cvtss2si */\n\n        case 0x32d: /* cvtsd2si */\n\n            ot = mo_64_32(s->dflag);\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                if ((b >> 8) & 1) {\n\n                    gen_ldq_env_A0(s, offsetof(CPUX86State, xmm_t0.XMM_Q(0)));\n\n                } else {\n\n                    gen_op_ld_v(s, MO_32, cpu_T[0], cpu_A0);\n\n                    tcg_gen_st32_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,xmm_t0.XMM_L(0)));\n\n                }\n\n                op2_offset = offsetof(CPUX86State,xmm_t0);\n\n            } else {\n\n                rm = (modrm & 7) | REX_B(s);\n\n                op2_offset = offsetof(CPUX86State,xmm_regs[rm]);\n\n            }\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op2_offset);\n\n            if (ot == MO_32) {\n\n                SSEFunc_i_ep sse_fn_i_ep =\n\n                    sse_op_table3bi[((b >> 7) & 2) | (b & 1)];\n\n                sse_fn_i_ep(cpu_tmp2_i32, cpu_env, cpu_ptr0);\n\n                tcg_gen_extu_i32_tl(cpu_T[0], cpu_tmp2_i32);\n\n            } else {\n\n#ifdef TARGET_X86_64\n\n                SSEFunc_l_ep sse_fn_l_ep =\n\n                    sse_op_table3bq[((b >> 7) & 2) | (b & 1)];\n\n                sse_fn_l_ep(cpu_T[0], cpu_env, cpu_ptr0);\n\n#else\n\n                goto illegal_op;\n\n#endif\n\n            }\n\n            gen_op_mov_reg_v(ot, reg, cpu_T[0]);\n\n            break;\n\n        case 0xc4: /* pinsrw */\n\n        case 0x1c4:\n\n            s->rip_offset = 1;\n\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n            val = cpu_ldub_code(env, s->pc++);\n\n            if (b1) {\n\n                val &= 7;\n\n                tcg_gen_st16_tl(cpu_T[0], cpu_env,\n\n                                offsetof(CPUX86State,xmm_regs[reg].XMM_W(val)));\n\n            } else {\n\n                val &= 3;\n\n                tcg_gen_st16_tl(cpu_T[0], cpu_env,\n\n                                offsetof(CPUX86State,fpregs[reg].mmx.MMX_W(val)));\n\n            }\n\n            break;\n\n        case 0xc5: /* pextrw */\n\n        case 0x1c5:\n\n            if (mod != 3)\n\n                goto illegal_op;\n\n            ot = mo_64_32(s->dflag);\n\n            val = cpu_ldub_code(env, s->pc++);\n\n            if (b1) {\n\n                val &= 7;\n\n                rm = (modrm & 7) | REX_B(s);\n\n                tcg_gen_ld16u_tl(cpu_T[0], cpu_env,\n\n                                 offsetof(CPUX86State,xmm_regs[rm].XMM_W(val)));\n\n            } else {\n\n                val &= 3;\n\n                rm = (modrm & 7);\n\n                tcg_gen_ld16u_tl(cpu_T[0], cpu_env,\n\n                                offsetof(CPUX86State,fpregs[rm].mmx.MMX_W(val)));\n\n            }\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            gen_op_mov_reg_v(ot, reg, cpu_T[0]);\n\n            break;\n\n        case 0x1d6: /* movq ea, xmm */\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_stq_env_A0(s, offsetof(CPUX86State,\n\n                                           xmm_regs[reg].XMM_Q(0)));\n\n            } else {\n\n                rm = (modrm & 7) | REX_B(s);\n\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[rm].XMM_Q(0)),\n\n                            offsetof(CPUX86State,xmm_regs[reg].XMM_Q(0)));\n\n                gen_op_movq_env_0(offsetof(CPUX86State,xmm_regs[rm].XMM_Q(1)));\n\n            }\n\n            break;\n\n        case 0x2d6: /* movq2dq */\n\n            gen_helper_enter_mmx(cpu_env);\n\n            rm = (modrm & 7);\n\n            gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].XMM_Q(0)),\n\n                        offsetof(CPUX86State,fpregs[rm].mmx));\n\n            gen_op_movq_env_0(offsetof(CPUX86State,xmm_regs[reg].XMM_Q(1)));\n\n            break;\n\n        case 0x3d6: /* movdq2q */\n\n            gen_helper_enter_mmx(cpu_env);\n\n            rm = (modrm & 7) | REX_B(s);\n\n            gen_op_movq(offsetof(CPUX86State,fpregs[reg & 7].mmx),\n\n                        offsetof(CPUX86State,xmm_regs[rm].XMM_Q(0)));\n\n            break;\n\n        case 0xd7: /* pmovmskb */\n\n        case 0x1d7:\n\n            if (mod != 3)\n\n                goto illegal_op;\n\n            if (b1) {\n\n                rm = (modrm & 7) | REX_B(s);\n\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env, offsetof(CPUX86State,xmm_regs[rm]));\n\n                gen_helper_pmovmskb_xmm(cpu_tmp2_i32, cpu_env, cpu_ptr0);\n\n            } else {\n\n                rm = (modrm & 7);\n\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env, offsetof(CPUX86State,fpregs[rm].mmx));\n\n                gen_helper_pmovmskb_mmx(cpu_tmp2_i32, cpu_env, cpu_ptr0);\n\n            }\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);\n\n            break;\n\n\n\n        case 0x138:\n\n        case 0x038:\n\n            b = modrm;\n\n            if ((b & 0xf0) == 0xf0) {\n\n                goto do_0f_38_fx;\n\n            }\n\n            modrm = cpu_ldub_code(env, s->pc++);\n\n            rm = modrm & 7;\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            if (b1 >= 2) {\n\n                goto illegal_op;\n\n            }\n\n\n\n            sse_fn_epp = sse_op_table6[b].op[b1];\n\n            if (!sse_fn_epp) {\n\n                goto illegal_op;\n\n            }\n\n            if (!(s->cpuid_ext_features & sse_op_table6[b].ext_mask))\n\n                goto illegal_op;\n\n\n\n            if (b1) {\n\n                op1_offset = offsetof(CPUX86State,xmm_regs[reg]);\n\n                if (mod == 3) {\n\n                    op2_offset = offsetof(CPUX86State,xmm_regs[rm | REX_B(s)]);\n\n                } else {\n\n                    op2_offset = offsetof(CPUX86State,xmm_t0);\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    switch (b) {\n\n                    case 0x20: case 0x30: /* pmovsxbw, pmovzxbw */\n\n                    case 0x23: case 0x33: /* pmovsxwd, pmovzxwd */\n\n                    case 0x25: case 0x35: /* pmovsxdq, pmovzxdq */\n\n                        gen_ldq_env_A0(s, op2_offset +\n\n                                        offsetof(XMMReg, XMM_Q(0)));\n\n                        break;\n\n                    case 0x21: case 0x31: /* pmovsxbd, pmovzxbd */\n\n                    case 0x24: case 0x34: /* pmovsxwq, pmovzxwq */\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, op2_offset +\n\n                                        offsetof(XMMReg, XMM_L(0)));\n\n                        break;\n\n                    case 0x22: case 0x32: /* pmovsxbq, pmovzxbq */\n\n                        tcg_gen_qemu_ld_tl(cpu_tmp0, cpu_A0,\n\n                                           s->mem_index, MO_LEUW);\n\n                        tcg_gen_st16_tl(cpu_tmp0, cpu_env, op2_offset +\n\n                                        offsetof(XMMReg, XMM_W(0)));\n\n                        break;\n\n                    case 0x2a:            /* movntqda */\n\n                        gen_ldo_env_A0(s, op1_offset);\n\n                        return;\n\n                    default:\n\n                        gen_ldo_env_A0(s, op2_offset);\n\n                    }\n\n                }\n\n            } else {\n\n                op1_offset = offsetof(CPUX86State,fpregs[reg].mmx);\n\n                if (mod == 3) {\n\n                    op2_offset = offsetof(CPUX86State,fpregs[rm].mmx);\n\n                } else {\n\n                    op2_offset = offsetof(CPUX86State,mmx_t0);\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    gen_ldq_env_A0(s, op2_offset);\n\n                }\n\n            }\n\n            if (sse_fn_epp == SSE_SPECIAL) {\n\n                goto illegal_op;\n\n            }\n\n\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n\n            sse_fn_epp(cpu_env, cpu_ptr0, cpu_ptr1);\n\n\n\n            if (b == 0x17) {\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n            }\n\n            break;\n\n\n\n        case 0x238:\n\n        case 0x338:\n\n        do_0f_38_fx:\n\n            /* Various integer extensions at 0f 38 f[0-f].  */\n\n            b = modrm | (b1 << 8);\n\n            modrm = cpu_ldub_code(env, s->pc++);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n            switch (b) {\n\n            case 0x3f0: /* crc32 Gd,Eb */\n\n            case 0x3f1: /* crc32 Gd,Ey */\n\n            do_crc32:\n\n                if (!(s->cpuid_ext_features & CPUID_EXT_SSE42)) {\n\n                    goto illegal_op;\n\n                }\n\n                if ((b & 0xff) == 0xf0) {\n\n                    ot = MO_8;\n\n                } else if (s->dflag != MO_64) {\n\n                    ot = (s->prefix & PREFIX_DATA ? MO_16 : MO_32);\n\n                } else {\n\n                    ot = MO_64;\n\n                }\n\n\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[reg]);\n\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n                gen_helper_crc32(cpu_T[0], cpu_tmp2_i32,\n\n                                 cpu_T[0], tcg_const_i32(8 << ot));\n\n\n\n                ot = mo_64_32(s->dflag);\n\n                gen_op_mov_reg_v(ot, reg, cpu_T[0]);\n\n                break;\n\n\n\n            case 0x1f0: /* crc32 or movbe */\n\n            case 0x1f1:\n\n                /* For these insns, the f3 prefix is supposed to have priority\n\n                   over the 66 prefix, but that's not what we implement above\n\n                   setting b1.  */\n\n                if (s->prefix & PREFIX_REPNZ) {\n\n                    goto do_crc32;\n\n                }\n\n                /* FALLTHRU */\n\n            case 0x0f0: /* movbe Gy,My */\n\n            case 0x0f1: /* movbe My,Gy */\n\n                if (!(s->cpuid_ext_features & CPUID_EXT_MOVBE)) {\n\n                    goto illegal_op;\n\n                }\n\n                if (s->dflag != MO_64) {\n\n                    ot = (s->prefix & PREFIX_DATA ? MO_16 : MO_32);\n\n                } else {\n\n                    ot = MO_64;\n\n                }\n\n\n\n                gen_lea_modrm(env, s, modrm);\n\n                if ((b & 1) == 0) {\n\n                    tcg_gen_qemu_ld_tl(cpu_T[0], cpu_A0,\n\n                                       s->mem_index, ot | MO_BE);\n\n                    gen_op_mov_reg_v(ot, reg, cpu_T[0]);\n\n                } else {\n\n                    tcg_gen_qemu_st_tl(cpu_regs[reg], cpu_A0,\n\n                                       s->mem_index, ot | MO_BE);\n\n                }\n\n                break;\n\n\n\n            case 0x0f2: /* andn Gy, By, Ey */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)\n\n                    || !(s->prefix & PREFIX_VEX)\n\n                    || s->vex_l != 0) {\n\n                    goto illegal_op;\n\n                }\n\n                ot = mo_64_32(s->dflag);\n\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n                tcg_gen_andc_tl(cpu_T[0], cpu_regs[s->vex_v], cpu_T[0]);\n\n                gen_op_mov_reg_v(ot, reg, cpu_T[0]);\n\n                gen_op_update1_cc();\n\n                set_cc_op(s, CC_OP_LOGICB + ot);\n\n                break;\n\n\n\n            case 0x0f7: /* bextr Gy, Ey, By */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)\n\n                    || !(s->prefix & PREFIX_VEX)\n\n                    || s->vex_l != 0) {\n\n                    goto illegal_op;\n\n                }\n\n                ot = mo_64_32(s->dflag);\n\n                {\n\n                    TCGv bound, zero;\n\n\n\n                    gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n                    /* Extract START, and shift the operand.\n\n                       Shifts larger than operand size get zeros.  */\n\n                    tcg_gen_ext8u_tl(cpu_A0, cpu_regs[s->vex_v]);\n\n                    tcg_gen_shr_tl(cpu_T[0], cpu_T[0], cpu_A0);\n\n\n\n                    bound = tcg_const_tl(ot == MO_64 ? 63 : 31);\n\n                    zero = tcg_const_tl(0);\n\n                    tcg_gen_movcond_tl(TCG_COND_LEU, cpu_T[0], cpu_A0, bound,\n\n                                       cpu_T[0], zero);\n\n                    tcg_temp_free(zero);\n\n\n\n                    /* Extract the LEN into a mask.  Lengths larger than\n\n                       operand size get all ones.  */\n\n                    tcg_gen_shri_tl(cpu_A0, cpu_regs[s->vex_v], 8);\n\n                    tcg_gen_ext8u_tl(cpu_A0, cpu_A0);\n\n                    tcg_gen_movcond_tl(TCG_COND_LEU, cpu_A0, cpu_A0, bound,\n\n                                       cpu_A0, bound);\n\n                    tcg_temp_free(bound);\n\n                    tcg_gen_movi_tl(cpu_T[1], 1);\n\n                    tcg_gen_shl_tl(cpu_T[1], cpu_T[1], cpu_A0);\n\n                    tcg_gen_subi_tl(cpu_T[1], cpu_T[1], 1);\n\n                    tcg_gen_and_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n\n\n\n                    gen_op_mov_reg_v(ot, reg, cpu_T[0]);\n\n                    gen_op_update1_cc();\n\n                    set_cc_op(s, CC_OP_LOGICB + ot);\n\n                }\n\n                break;\n\n\n\n            case 0x0f5: /* bzhi Gy, Ey, By */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n\n                    || !(s->prefix & PREFIX_VEX)\n\n                    || s->vex_l != 0) {\n\n                    goto illegal_op;\n\n                }\n\n                ot = mo_64_32(s->dflag);\n\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n                tcg_gen_ext8u_tl(cpu_T[1], cpu_regs[s->vex_v]);\n\n                {\n\n                    TCGv bound = tcg_const_tl(ot == MO_64 ? 63 : 31);\n\n                    /* Note that since we're using BMILG (in order to get O\n\n                       cleared) we need to store the inverse into C.  */\n\n                    tcg_gen_setcond_tl(TCG_COND_LT, cpu_cc_src,\n\n                                       cpu_T[1], bound);\n\n                    tcg_gen_movcond_tl(TCG_COND_GT, cpu_T[1], cpu_T[1],\n\n                                       bound, bound, cpu_T[1]);\n\n                    tcg_temp_free(bound);\n\n                }\n\n                tcg_gen_movi_tl(cpu_A0, -1);\n\n                tcg_gen_shl_tl(cpu_A0, cpu_A0, cpu_T[1]);\n\n                tcg_gen_andc_tl(cpu_T[0], cpu_T[0], cpu_A0);\n\n                gen_op_mov_reg_v(ot, reg, cpu_T[0]);\n\n                gen_op_update1_cc();\n\n                set_cc_op(s, CC_OP_BMILGB + ot);\n\n                break;\n\n\n\n            case 0x3f6: /* mulx By, Gy, rdx, Ey */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n\n                    || !(s->prefix & PREFIX_VEX)\n\n                    || s->vex_l != 0) {\n\n                    goto illegal_op;\n\n                }\n\n                ot = mo_64_32(s->dflag);\n\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n                switch (ot) {\n\n                default:\n\n                    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EDX]);\n\n                    tcg_gen_mulu2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n\n                                      cpu_tmp2_i32, cpu_tmp3_i32);\n\n                    tcg_gen_extu_i32_tl(cpu_regs[s->vex_v], cpu_tmp2_i32);\n\n                    tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp3_i32);\n\n                    break;\n\n#ifdef TARGET_X86_64\n\n                case MO_64:\n\n                    tcg_gen_mulu2_i64(cpu_regs[s->vex_v], cpu_regs[reg],\n\n                                      cpu_T[0], cpu_regs[R_EDX]);\n\n                    break;\n\n#endif\n\n                }\n\n                break;\n\n\n\n            case 0x3f5: /* pdep Gy, By, Ey */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n\n                    || !(s->prefix & PREFIX_VEX)\n\n                    || s->vex_l != 0) {\n\n                    goto illegal_op;\n\n                }\n\n                ot = mo_64_32(s->dflag);\n\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n                /* Note that by zero-extending the mask operand, we\n\n                   automatically handle zero-extending the result.  */\n\n                if (ot == MO_64) {\n\n                    tcg_gen_mov_tl(cpu_T[1], cpu_regs[s->vex_v]);\n\n                } else {\n\n                    tcg_gen_ext32u_tl(cpu_T[1], cpu_regs[s->vex_v]);\n\n                }\n\n                gen_helper_pdep(cpu_regs[reg], cpu_T[0], cpu_T[1]);\n\n                break;\n\n\n\n            case 0x2f5: /* pext Gy, By, Ey */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n\n                    || !(s->prefix & PREFIX_VEX)\n\n                    || s->vex_l != 0) {\n\n                    goto illegal_op;\n\n                }\n\n                ot = mo_64_32(s->dflag);\n\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n                /* Note that by zero-extending the mask operand, we\n\n                   automatically handle zero-extending the result.  */\n\n                if (ot == MO_64) {\n\n                    tcg_gen_mov_tl(cpu_T[1], cpu_regs[s->vex_v]);\n\n                } else {\n\n                    tcg_gen_ext32u_tl(cpu_T[1], cpu_regs[s->vex_v]);\n\n                }\n\n                gen_helper_pext(cpu_regs[reg], cpu_T[0], cpu_T[1]);\n\n                break;\n\n\n\n            case 0x1f6: /* adcx Gy, Ey */\n\n            case 0x2f6: /* adox Gy, Ey */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_ADX)) {\n\n                    goto illegal_op;\n\n                } else {\n\n                    TCGv carry_in, carry_out, zero;\n\n                    int end_op;\n\n\n\n                    ot = mo_64_32(s->dflag);\n\n                    gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n\n\n                    /* Re-use the carry-out from a previous round.  */\n\n                    TCGV_UNUSED(carry_in);\n\n                    carry_out = (b == 0x1f6 ? cpu_cc_dst : cpu_cc_src2);\n\n                    switch (s->cc_op) {\n\n                    case CC_OP_ADCX:\n\n                        if (b == 0x1f6) {\n\n                            carry_in = cpu_cc_dst;\n\n                            end_op = CC_OP_ADCX;\n\n                        } else {\n\n                            end_op = CC_OP_ADCOX;\n\n                        }\n\n                        break;\n\n                    case CC_OP_ADOX:\n\n                        if (b == 0x1f6) {\n\n                            end_op = CC_OP_ADCOX;\n\n                        } else {\n\n                            carry_in = cpu_cc_src2;\n\n                            end_op = CC_OP_ADOX;\n\n                        }\n\n                        break;\n\n                    case CC_OP_ADCOX:\n\n                        end_op = CC_OP_ADCOX;\n\n                        carry_in = carry_out;\n\n                        break;\n\n                    default:\n\n                        end_op = (b == 0x1f6 ? CC_OP_ADCX : CC_OP_ADOX);\n\n                        break;\n\n                    }\n\n                    /* If we can't reuse carry-out, get it out of EFLAGS.  */\n\n                    if (TCGV_IS_UNUSED(carry_in)) {\n\n                        if (s->cc_op != CC_OP_ADCX && s->cc_op != CC_OP_ADOX) {\n\n                            gen_compute_eflags(s);\n\n                        }\n\n                        carry_in = cpu_tmp0;\n\n                        tcg_gen_shri_tl(carry_in, cpu_cc_src,\n\n                                        ctz32(b == 0x1f6 ? CC_C : CC_O));\n\n                        tcg_gen_andi_tl(carry_in, carry_in, 1);\n\n                    }\n\n\n\n                    switch (ot) {\n\n#ifdef TARGET_X86_64\n\n                    case MO_32:\n\n                        /* If we know TL is 64-bit, and we want a 32-bit\n\n                           result, just do everything in 64-bit arithmetic.  */\n\n                        tcg_gen_ext32u_i64(cpu_regs[reg], cpu_regs[reg]);\n\n                        tcg_gen_ext32u_i64(cpu_T[0], cpu_T[0]);\n\n                        tcg_gen_add_i64(cpu_T[0], cpu_T[0], cpu_regs[reg]);\n\n                        tcg_gen_add_i64(cpu_T[0], cpu_T[0], carry_in);\n\n                        tcg_gen_ext32u_i64(cpu_regs[reg], cpu_T[0]);\n\n                        tcg_gen_shri_i64(carry_out, cpu_T[0], 32);\n\n                        break;\n\n#endif\n\n                    default:\n\n                        /* Otherwise compute the carry-out in two steps.  */\n\n                        zero = tcg_const_tl(0);\n\n                        tcg_gen_add2_tl(cpu_T[0], carry_out,\n\n                                        cpu_T[0], zero,\n\n                                        carry_in, zero);\n\n                        tcg_gen_add2_tl(cpu_regs[reg], carry_out,\n\n                                        cpu_regs[reg], carry_out,\n\n                                        cpu_T[0], zero);\n\n                        tcg_temp_free(zero);\n\n                        break;\n\n                    }\n\n                    set_cc_op(s, end_op);\n\n                }\n\n                break;\n\n\n\n            case 0x1f7: /* shlx Gy, Ey, By */\n\n            case 0x2f7: /* sarx Gy, Ey, By */\n\n            case 0x3f7: /* shrx Gy, Ey, By */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n\n                    || !(s->prefix & PREFIX_VEX)\n\n                    || s->vex_l != 0) {\n\n                    goto illegal_op;\n\n                }\n\n                ot = mo_64_32(s->dflag);\n\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n                if (ot == MO_64) {\n\n                    tcg_gen_andi_tl(cpu_T[1], cpu_regs[s->vex_v], 63);\n\n                } else {\n\n                    tcg_gen_andi_tl(cpu_T[1], cpu_regs[s->vex_v], 31);\n\n                }\n\n                if (b == 0x1f7) {\n\n                    tcg_gen_shl_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n\n                } else if (b == 0x2f7) {\n\n                    if (ot != MO_64) {\n\n                        tcg_gen_ext32s_tl(cpu_T[0], cpu_T[0]);\n\n                    }\n\n                    tcg_gen_sar_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n\n                } else {\n\n                    if (ot != MO_64) {\n\n                        tcg_gen_ext32u_tl(cpu_T[0], cpu_T[0]);\n\n                    }\n\n                    tcg_gen_shr_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n\n                }\n\n                gen_op_mov_reg_v(ot, reg, cpu_T[0]);\n\n                break;\n\n\n\n            case 0x0f3:\n\n            case 0x1f3:\n\n            case 0x2f3:\n\n            case 0x3f3: /* Group 17 */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)\n\n                    || !(s->prefix & PREFIX_VEX)\n\n                    || s->vex_l != 0) {\n\n                    goto illegal_op;\n\n                }\n\n                ot = mo_64_32(s->dflag);\n\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n\n\n                switch (reg & 7) {\n\n                case 1: /* blsr By,Ey */\n\n                    tcg_gen_neg_tl(cpu_T[1], cpu_T[0]);\n\n                    tcg_gen_and_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n\n                    gen_op_mov_reg_v(ot, s->vex_v, cpu_T[0]);\n\n                    gen_op_update2_cc();\n\n                    set_cc_op(s, CC_OP_BMILGB + ot);\n\n                    break;\n\n\n\n                case 2: /* blsmsk By,Ey */\n\n                    tcg_gen_mov_tl(cpu_cc_src, cpu_T[0]);\n\n                    tcg_gen_subi_tl(cpu_T[0], cpu_T[0], 1);\n\n                    tcg_gen_xor_tl(cpu_T[0], cpu_T[0], cpu_cc_src);\n\n                    tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n\n                    set_cc_op(s, CC_OP_BMILGB + ot);\n\n                    break;\n\n\n\n                case 3: /* blsi By, Ey */\n\n                    tcg_gen_mov_tl(cpu_cc_src, cpu_T[0]);\n\n                    tcg_gen_subi_tl(cpu_T[0], cpu_T[0], 1);\n\n                    tcg_gen_and_tl(cpu_T[0], cpu_T[0], cpu_cc_src);\n\n                    tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n\n                    set_cc_op(s, CC_OP_BMILGB + ot);\n\n                    break;\n\n\n\n                default:\n\n                    goto illegal_op;\n\n                }\n\n                break;\n\n\n\n            default:\n\n                goto illegal_op;\n\n            }\n\n            break;\n\n\n\n        case 0x03a:\n\n        case 0x13a:\n\n            b = modrm;\n\n            modrm = cpu_ldub_code(env, s->pc++);\n\n            rm = modrm & 7;\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            if (b1 >= 2) {\n\n                goto illegal_op;\n\n            }\n\n\n\n            sse_fn_eppi = sse_op_table7[b].op[b1];\n\n            if (!sse_fn_eppi) {\n\n                goto illegal_op;\n\n            }\n\n            if (!(s->cpuid_ext_features & sse_op_table7[b].ext_mask))\n\n                goto illegal_op;\n\n\n\n            if (sse_fn_eppi == SSE_SPECIAL) {\n\n                ot = mo_64_32(s->dflag);\n\n                rm = (modrm & 7) | REX_B(s);\n\n                if (mod != 3)\n\n                    gen_lea_modrm(env, s, modrm);\n\n                reg = ((modrm >> 3) & 7) | rex_r;\n\n                val = cpu_ldub_code(env, s->pc++);\n\n                switch (b) {\n\n                case 0x14: /* pextrb */\n\n                    tcg_gen_ld8u_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,\n\n                                            xmm_regs[reg].XMM_B(val & 15)));\n\n                    if (mod == 3) {\n\n                        gen_op_mov_reg_v(ot, rm, cpu_T[0]);\n\n                    } else {\n\n                        tcg_gen_qemu_st_tl(cpu_T[0], cpu_A0,\n\n                                           s->mem_index, MO_UB);\n\n                    }\n\n                    break;\n\n                case 0x15: /* pextrw */\n\n                    tcg_gen_ld16u_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,\n\n                                            xmm_regs[reg].XMM_W(val & 7)));\n\n                    if (mod == 3) {\n\n                        gen_op_mov_reg_v(ot, rm, cpu_T[0]);\n\n                    } else {\n\n                        tcg_gen_qemu_st_tl(cpu_T[0], cpu_A0,\n\n                                           s->mem_index, MO_LEUW);\n\n                    }\n\n                    break;\n\n                case 0x16:\n\n                    if (ot == MO_32) { /* pextrd */\n\n                        tcg_gen_ld_i32(cpu_tmp2_i32, cpu_env,\n\n                                        offsetof(CPUX86State,\n\n                                                xmm_regs[reg].XMM_L(val & 3)));\n\n                        if (mod == 3) {\n\n                            tcg_gen_extu_i32_tl(cpu_regs[rm], cpu_tmp2_i32);\n\n                        } else {\n\n                            tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                                s->mem_index, MO_LEUL);\n\n                        }\n\n                    } else { /* pextrq */\n\n#ifdef TARGET_X86_64\n\n                        tcg_gen_ld_i64(cpu_tmp1_i64, cpu_env,\n\n                                        offsetof(CPUX86State,\n\n                                                xmm_regs[reg].XMM_Q(val & 1)));\n\n                        if (mod == 3) {\n\n                            tcg_gen_mov_i64(cpu_regs[rm], cpu_tmp1_i64);\n\n                        } else {\n\n                            tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,\n\n                                                s->mem_index, MO_LEQ);\n\n                        }\n\n#else\n\n                        goto illegal_op;\n\n#endif\n\n                    }\n\n                    break;\n\n                case 0x17: /* extractps */\n\n                    tcg_gen_ld32u_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,\n\n                                            xmm_regs[reg].XMM_L(val & 3)));\n\n                    if (mod == 3) {\n\n                        gen_op_mov_reg_v(ot, rm, cpu_T[0]);\n\n                    } else {\n\n                        tcg_gen_qemu_st_tl(cpu_T[0], cpu_A0,\n\n                                           s->mem_index, MO_LEUL);\n\n                    }\n\n                    break;\n\n                case 0x20: /* pinsrb */\n\n                    if (mod == 3) {\n\n                        gen_op_mov_v_reg(MO_32, cpu_T[0], rm);\n\n                    } else {\n\n                        tcg_gen_qemu_ld_tl(cpu_T[0], cpu_A0,\n\n                                           s->mem_index, MO_UB);\n\n                    }\n\n                    tcg_gen_st8_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,\n\n                                            xmm_regs[reg].XMM_B(val & 15)));\n\n                    break;\n\n                case 0x21: /* insertps */\n\n                    if (mod == 3) {\n\n                        tcg_gen_ld_i32(cpu_tmp2_i32, cpu_env,\n\n                                        offsetof(CPUX86State,xmm_regs[rm]\n\n                                                .XMM_L((val >> 6) & 3)));\n\n                    } else {\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                    }\n\n                    tcg_gen_st_i32(cpu_tmp2_i32, cpu_env,\n\n                                    offsetof(CPUX86State,xmm_regs[reg]\n\n                                            .XMM_L((val >> 4) & 3)));\n\n                    if ((val >> 0) & 1)\n\n                        tcg_gen_st_i32(tcg_const_i32(0 /*float32_zero*/),\n\n                                        cpu_env, offsetof(CPUX86State,\n\n                                                xmm_regs[reg].XMM_L(0)));\n\n                    if ((val >> 1) & 1)\n\n                        tcg_gen_st_i32(tcg_const_i32(0 /*float32_zero*/),\n\n                                        cpu_env, offsetof(CPUX86State,\n\n                                                xmm_regs[reg].XMM_L(1)));\n\n                    if ((val >> 2) & 1)\n\n                        tcg_gen_st_i32(tcg_const_i32(0 /*float32_zero*/),\n\n                                        cpu_env, offsetof(CPUX86State,\n\n                                                xmm_regs[reg].XMM_L(2)));\n\n                    if ((val >> 3) & 1)\n\n                        tcg_gen_st_i32(tcg_const_i32(0 /*float32_zero*/),\n\n                                        cpu_env, offsetof(CPUX86State,\n\n                                                xmm_regs[reg].XMM_L(3)));\n\n                    break;\n\n                case 0x22:\n\n                    if (ot == MO_32) { /* pinsrd */\n\n                        if (mod == 3) {\n\n                            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[rm]);\n\n                        } else {\n\n                            tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                                s->mem_index, MO_LEUL);\n\n                        }\n\n                        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env,\n\n                                        offsetof(CPUX86State,\n\n                                                xmm_regs[reg].XMM_L(val & 3)));\n\n                    } else { /* pinsrq */\n\n#ifdef TARGET_X86_64\n\n                        if (mod == 3) {\n\n                            gen_op_mov_v_reg(ot, cpu_tmp1_i64, rm);\n\n                        } else {\n\n                            tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,\n\n                                                s->mem_index, MO_LEQ);\n\n                        }\n\n                        tcg_gen_st_i64(cpu_tmp1_i64, cpu_env,\n\n                                        offsetof(CPUX86State,\n\n                                                xmm_regs[reg].XMM_Q(val & 1)));\n\n#else\n\n                        goto illegal_op;\n\n#endif\n\n                    }\n\n                    break;\n\n                }\n\n                return;\n\n            }\n\n\n\n            if (b1) {\n\n                op1_offset = offsetof(CPUX86State,xmm_regs[reg]);\n\n                if (mod == 3) {\n\n                    op2_offset = offsetof(CPUX86State,xmm_regs[rm | REX_B(s)]);\n\n                } else {\n\n                    op2_offset = offsetof(CPUX86State,xmm_t0);\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    gen_ldo_env_A0(s, op2_offset);\n\n                }\n\n            } else {\n\n                op1_offset = offsetof(CPUX86State,fpregs[reg].mmx);\n\n                if (mod == 3) {\n\n                    op2_offset = offsetof(CPUX86State,fpregs[rm].mmx);\n\n                } else {\n\n                    op2_offset = offsetof(CPUX86State,mmx_t0);\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    gen_ldq_env_A0(s, op2_offset);\n\n                }\n\n            }\n\n            val = cpu_ldub_code(env, s->pc++);\n\n\n\n            if ((b & 0xfc) == 0x60) { /* pcmpXstrX */\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n\n\n                if (s->dflag == MO_64) {\n\n                    /* The helper must use entire 64-bit gp registers */\n\n                    val |= 1 << 8;\n\n                }\n\n            }\n\n\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n\n            sse_fn_eppi(cpu_env, cpu_ptr0, cpu_ptr1, tcg_const_i32(val));\n\n            break;\n\n\n\n        case 0x33a:\n\n            /* Various integer extensions at 0f 3a f[0-f].  */\n\n            b = modrm | (b1 << 8);\n\n            modrm = cpu_ldub_code(env, s->pc++);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n            switch (b) {\n\n            case 0x3f0: /* rorx Gy,Ey, Ib */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n\n                    || !(s->prefix & PREFIX_VEX)\n\n                    || s->vex_l != 0) {\n\n                    goto illegal_op;\n\n                }\n\n                ot = mo_64_32(s->dflag);\n\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n                b = cpu_ldub_code(env, s->pc++);\n\n                if (ot == MO_64) {\n\n                    tcg_gen_rotri_tl(cpu_T[0], cpu_T[0], b & 63);\n\n                } else {\n\n                    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n\n                    tcg_gen_rotri_i32(cpu_tmp2_i32, cpu_tmp2_i32, b & 31);\n\n                    tcg_gen_extu_i32_tl(cpu_T[0], cpu_tmp2_i32);\n\n                }\n\n                gen_op_mov_reg_v(ot, reg, cpu_T[0]);\n\n                break;\n\n\n\n            default:\n\n                goto illegal_op;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            goto illegal_op;\n\n        }\n\n    } else {\n\n        /* generic MMX or SSE operation */\n\n        switch(b) {\n\n        case 0x70: /* pshufx insn */\n\n        case 0xc6: /* pshufx insn */\n\n        case 0xc2: /* compare insns */\n\n            s->rip_offset = 1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        if (is_xmm) {\n\n            op1_offset = offsetof(CPUX86State,xmm_regs[reg]);\n\n            if (mod != 3) {\n\n                int sz = 4;\n\n\n\n                gen_lea_modrm(env, s, modrm);\n\n                op2_offset = offsetof(CPUX86State,xmm_t0);\n\n\n\n                switch (b) {\n\n                case 0x50 ... 0x5a:\n\n                case 0x5c ... 0x5f:\n\n                case 0xc2:\n\n                    /* Most sse scalar operations.  */\n\n                    if (b1 == 2) {\n\n                        sz = 2;\n\n                    } else if (b1 == 3) {\n\n                        sz = 3;\n\n                    }\n\n                    break;\n\n\n\n                case 0x2e:  /* ucomis[sd] */\n\n                case 0x2f:  /* comis[sd] */\n\n                    if (b1 == 0) {\n\n                        sz = 2;\n\n                    } else {\n\n                        sz = 3;\n\n                    }\n\n                    break;\n\n                }\n\n\n\n                switch (sz) {\n\n                case 2:\n\n                    /* 32 bit access */\n\n                    gen_op_ld_v(s, MO_32, cpu_T[0], cpu_A0);\n\n                    tcg_gen_st32_tl(cpu_T[0], cpu_env,\n\n                                    offsetof(CPUX86State,xmm_t0.XMM_L(0)));\n\n                    break;\n\n                case 3:\n\n                    /* 64 bit access */\n\n                    gen_ldq_env_A0(s, offsetof(CPUX86State, xmm_t0.XMM_D(0)));\n\n                    break;\n\n                default:\n\n                    /* 128 bit access */\n\n                    gen_ldo_env_A0(s, op2_offset);\n\n                    break;\n\n                }\n\n            } else {\n\n                rm = (modrm & 7) | REX_B(s);\n\n                op2_offset = offsetof(CPUX86State,xmm_regs[rm]);\n\n            }\n\n        } else {\n\n            op1_offset = offsetof(CPUX86State,fpregs[reg].mmx);\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                op2_offset = offsetof(CPUX86State,mmx_t0);\n\n                gen_ldq_env_A0(s, op2_offset);\n\n            } else {\n\n                rm = (modrm & 7);\n\n                op2_offset = offsetof(CPUX86State,fpregs[rm].mmx);\n\n            }\n\n        }\n\n        switch(b) {\n\n        case 0x0f: /* 3DNow! data insns */\n\n            if (!(s->cpuid_ext2_features & CPUID_EXT2_3DNOW))\n\n                goto illegal_op;\n\n            val = cpu_ldub_code(env, s->pc++);\n\n            sse_fn_epp = sse_op_table5[val];\n\n            if (!sse_fn_epp) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n\n            sse_fn_epp(cpu_env, cpu_ptr0, cpu_ptr1);\n\n            break;\n\n        case 0x70: /* pshufx insn */\n\n        case 0xc6: /* pshufx insn */\n\n            val = cpu_ldub_code(env, s->pc++);\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n\n            /* XXX: introduce a new table? */\n\n            sse_fn_ppi = (SSEFunc_0_ppi)sse_fn_epp;\n\n            sse_fn_ppi(cpu_ptr0, cpu_ptr1, tcg_const_i32(val));\n\n            break;\n\n        case 0xc2:\n\n            /* compare insns */\n\n            val = cpu_ldub_code(env, s->pc++);\n\n            if (val >= 8)\n\n                goto illegal_op;\n\n            sse_fn_epp = sse_op_table4[val][b1];\n\n\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n\n            sse_fn_epp(cpu_env, cpu_ptr0, cpu_ptr1);\n\n            break;\n\n        case 0xf7:\n\n            /* maskmov : we must prepare A0 */\n\n            if (mod != 3)\n\n                goto illegal_op;\n\n            tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EDI]);\n\n            gen_extu(s->aflag, cpu_A0);\n\n            gen_add_A0_ds_seg(s);\n\n\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n\n            /* XXX: introduce a new table? */\n\n            sse_fn_eppt = (SSEFunc_0_eppt)sse_fn_epp;\n\n            sse_fn_eppt(cpu_env, cpu_ptr0, cpu_ptr1, cpu_A0);\n\n            break;\n\n        default:\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n\n            sse_fn_epp(cpu_env, cpu_ptr0, cpu_ptr1);\n\n            break;\n\n        }\n\n        if (b == 0x2e || b == 0x2f) {\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n        }\n\n    }\n\n}\n", "idx": 24736}
{"project": "qemu", "commit_id": "c3e10c7b4377c1cbc0a4fbc12312c2cf41c0cda7", "target": 1, "func": "void do_subfzeo_64 (void)\n\n{\n\n    T1 = T0;\n\n    T0 = ~T0 + xer_ca;\n\n    if (likely(!(((uint64_t)~T1 ^ UINT64_MAX) &\n\n                 ((uint64_t)(~T1) ^ (uint64_t)T0) & (1ULL << 63)))) {\n\n        xer_ov = 0;\n\n    } else {\n\n        xer_ov = 1;\n\n        xer_so = 1;\n\n    }\n\n    if (likely((uint64_t)T0 >= (uint64_t)~T1)) {\n\n        xer_ca = 0;\n\n    } else {\n\n        xer_ca = 1;\n\n    }\n\n}\n", "idx": 24737}
{"project": "qemu", "commit_id": "bec1631100323fac0900aea71043d5c4e22fc2fa", "target": 0, "func": "static void tgen_compare_imm_branch(TCGContext *s, S390Opcode opc, int cc,\n\n                                    TCGReg r1, int i2, int labelno)\n\n{\n\n    TCGLabel* l = &s->labels[labelno];\n\n    tcg_target_long off;\n\n\n\n    if (l->has_value) {\n\n        off = l->u.value_ptr - s->code_ptr;\n\n    } else {\n\n        /* We need to keep the offset unchanged for retranslation.  */\n\n        off = s->code_ptr[1];\n\n        tcg_out_reloc(s, s->code_ptr + 1, R_390_PC16DBL, labelno, -2);\n\n    }\n\n\n\n    tcg_out16(s, (opc & 0xff00) | (r1 << 4) | cc);\n\n    tcg_out16(s, off);\n\n    tcg_out16(s, (i2 << 8) | (opc & 0xff));\n\n}\n", "idx": 24739}
{"project": "qemu", "commit_id": "29e179bc3f5e804ab58b975e65c91cb9cd287846", "target": 0, "func": "int find_utlb_entry(CPUState * env, target_ulong address, int use_asid)\n\n{\n\n    uint8_t urb, urc;\n\n\n\n    /* Increment URC */\n\n    urb = ((env->mmucr) >> 18) & 0x3f;\n\n    urc = ((env->mmucr) >> 10) & 0x3f;\n\n    urc++;\n\n    if (urc == urb || urc == UTLB_SIZE - 1)\n\n\turc = 0;\n\n    env->mmucr = (env->mmucr & 0xffff03ff) | (urc << 10);\n\n\n\n    /* Return entry */\n\n    return find_tlb_entry(env, address, env->utlb, UTLB_SIZE, use_asid);\n\n}\n", "idx": 24740}
{"project": "qemu", "commit_id": "537b41f5013e1951fa15e8f18855b18d76124ce4", "target": 0, "func": "static void combine_addr(char *buf, size_t len, const char* address,\n\n                         uint16_t port)\n\n{\n\n    /* If the address-part contains a colon, it's an IPv6 IP so needs [] */\n\n    if (strstr(address, \":\")) {\n\n        snprintf(buf, len, \"[%s]:%u\", address, port);\n\n    } else {\n\n        snprintf(buf, len, \"%s:%u\", address, port);\n\n    }\n\n}\n", "idx": 24741}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint64_t helper_fnmsub (uint64_t arg1, uint64_t arg2, uint64_t arg3)\n\n{\n\n    CPU_DoubleU farg1, farg2, farg3;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n    farg3.ll = arg3;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                 float64_is_signaling_nan(farg2.d) ||\n\n                 float64_is_signaling_nan(farg3.d))) {\n\n        /* sNaN operation */\n\n        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN);\n\n    } else if (unlikely((float64_is_infinity(farg1.d) && float64_is_zero(farg2.d)) ||\n\n                        (float64_is_zero(farg1.d) && float64_is_infinity(farg2.d)))) {\n\n        /* Multiplication of zero by infinity */\n\n        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXIMZ);\n\n    } else {\n\n#if USE_PRECISE_EMULATION\n\n#ifdef FLOAT128\n\n        /* This is the way the PowerPC specification defines it */\n\n        float128 ft0_128, ft1_128;\n\n\n\n        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);\n\n        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);\n\n        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);\n\n        if (unlikely(float128_is_infinity(ft0_128) && float64_is_infinity(farg3.d) &&\n\n                     float128_is_neg(ft0_128) == float64_is_neg(farg3.d))) {\n\n            /* Magnitude subtraction of infinities */\n\n            farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXISI);\n\n        } else {\n\n            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);\n\n            ft0_128 = float128_sub(ft0_128, ft1_128, &env->fp_status);\n\n            farg1.d = float128_to_float64(ft0_128, &env->fp_status);\n\n        }\n\n#else\n\n        /* This is OK on x86 hosts */\n\n        farg1.d = (farg1.d * farg2.d) - farg3.d;\n\n#endif\n\n#else\n\n        farg1.d = float64_mul(farg1.d, farg2.d, &env->fp_status);\n\n        farg1.d = float64_sub(farg1.d, farg3.d, &env->fp_status);\n\n#endif\n\n        if (likely(!float64_is_nan(farg1.d)))\n\n            farg1.d = float64_chs(farg1.d);\n\n    }\n\n    return farg1.ll;\n\n}\n", "idx": 24742}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void find_completion(const char *cmdline)\n\n{\n\n    const char *cmdname;\n\n    char *args[MAX_ARGS];\n\n    int nb_args, i, len;\n\n    const char *ptype, *str;\n\n    term_cmd_t *cmd;\n\n\n\n    parse_cmdline(cmdline, &nb_args, args);\n\n#ifdef DEBUG_COMPLETION\n\n    for(i = 0; i < nb_args; i++) {\n\n        term_printf(\"arg%d = '%s'\\n\", i, (char *)args[i]);\n\n    }\n\n#endif\n\n\n\n    /* if the line ends with a space, it means we want to complete the\n\n       next arg */\n\n    len = strlen(cmdline);\n\n    if (len > 0 && isspace(cmdline[len - 1])) {\n\n        if (nb_args >= MAX_ARGS)\n\n            return;\n\n        args[nb_args++] = qemu_strdup(\"\");\n\n    }\n\n    if (nb_args <= 1) {\n\n        /* command completion */\n\n        if (nb_args == 0)\n\n            cmdname = \"\";\n\n        else\n\n            cmdname = args[0];\n\n        completion_index = strlen(cmdname);\n\n        for(cmd = term_cmds; cmd->name != NULL; cmd++) {\n\n            cmd_completion(cmdname, cmd->name);\n\n        }\n\n    } else {\n\n        /* find the command */\n\n        for(cmd = term_cmds; cmd->name != NULL; cmd++) {\n\n            if (compare_cmd(args[0], cmd->name))\n\n                goto found;\n\n        }\n\n        return;\n\n    found:\n\n        ptype = cmd->args_type;\n\n        for(i = 0; i < nb_args - 2; i++) {\n\n            if (*ptype != '\\0') {\n\n                ptype++;\n\n                while (*ptype == '?')\n\n                    ptype++;\n\n            }\n\n        }\n\n        str = args[nb_args - 1];\n\n        switch(*ptype) {\n\n        case 'F':\n\n            /* file completion */\n\n            completion_index = strlen(str);\n\n            file_completion(str);\n\n            break;\n\n        case 'B':\n\n            /* block device name completion */\n\n            completion_index = strlen(str);\n\n            bdrv_iterate(block_completion_it, (void *)str);\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    for(i = 0; i < nb_args; i++)\n\n        qemu_free(args[i]);\n\n}\n", "idx": 24743}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void dec_modu(DisasContext *dc)\n\n{\n\n    int l1;\n\n\n\n    LOG_DIS(\"modu r%d, r%d, %d\\n\", dc->r2, dc->r0, dc->r1);\n\n\n\n    if (!(dc->features & LM32_FEATURE_DIVIDE)) {\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"hardware divider is not available\\n\");\n\n        t_gen_illegal_insn(dc);\n\n        return;\n\n    }\n\n\n\n    l1 = gen_new_label();\n\n    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);\n\n    tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);\n\n    gen_set_label(l1);\n\n    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);\n\n}\n", "idx": 24744}
{"project": "qemu", "commit_id": "1e886639791762e89b51aa0507f523c6a1448831", "target": 0, "func": "vdi_co_pwritev(BlockDriverState *bs, uint64_t offset, uint64_t bytes,\n\n               QEMUIOVector *qiov, int flags)\n\n{\n\n    BDRVVdiState *s = bs->opaque;\n\n    QEMUIOVector local_qiov;\n\n    uint32_t bmap_entry;\n\n    uint32_t block_index;\n\n    uint32_t offset_in_block;\n\n    uint32_t n_bytes;\n\n    uint32_t bmap_first = VDI_UNALLOCATED;\n\n    uint32_t bmap_last = VDI_UNALLOCATED;\n\n    uint8_t *block = NULL;\n\n    uint64_t bytes_done = 0;\n\n    int ret = 0;\n\n\n\n    logout(\"\\n\");\n\n\n\n    qemu_iovec_init(&local_qiov, qiov->niov);\n\n\n\n    while (ret >= 0 && bytes > 0) {\n\n        block_index = offset / s->block_size;\n\n        offset_in_block = offset % s->block_size;\n\n        n_bytes = MIN(bytes, s->block_size - offset_in_block);\n\n\n\n        logout(\"will write %u bytes starting at offset %\" PRIu64 \"\\n\",\n\n               n_bytes, offset);\n\n\n\n        /* prepare next AIO request */\n\n        bmap_entry = le32_to_cpu(s->bmap[block_index]);\n\n        if (!VDI_IS_ALLOCATED(bmap_entry)) {\n\n            /* Allocate new block and write to it. */\n\n            uint64_t data_offset;\n\n            bmap_entry = s->header.blocks_allocated;\n\n            s->bmap[block_index] = cpu_to_le32(bmap_entry);\n\n            s->header.blocks_allocated++;\n\n            data_offset = s->header.offset_data +\n\n                          (uint64_t)bmap_entry * s->block_size;\n\n            if (block == NULL) {\n\n                block = g_malloc(s->block_size);\n\n                bmap_first = block_index;\n\n            }\n\n            bmap_last = block_index;\n\n            /* Copy data to be written to new block and zero unused parts. */\n\n            memset(block, 0, offset_in_block);\n\n            qemu_iovec_to_buf(qiov, bytes_done, block + offset_in_block,\n\n                              n_bytes);\n\n            memset(block + offset_in_block + n_bytes, 0,\n\n                   s->block_size - n_bytes - offset_in_block);\n\n\n\n            /* Note that this coroutine does not yield anywhere from reading the\n\n             * bmap entry until here, so in regards to all the coroutines trying\n\n             * to write to this cluster, the one doing the allocation will\n\n             * always be the first to try to acquire the lock.\n\n             * Therefore, it is also the first that will actually be able to\n\n             * acquire the lock and thus the padded cluster is written before\n\n             * the other coroutines can write to the affected area. */\n\n            qemu_co_mutex_lock(&s->write_lock);\n\n            ret = bdrv_pwrite(bs->file, data_offset, block, s->block_size);\n\n            qemu_co_mutex_unlock(&s->write_lock);\n\n        } else {\n\n            uint64_t data_offset = s->header.offset_data +\n\n                                   (uint64_t)bmap_entry * s->block_size +\n\n                                   offset_in_block;\n\n            qemu_co_mutex_lock(&s->write_lock);\n\n            /* This lock is only used to make sure the following write operation\n\n             * is executed after the write issued by the coroutine allocating\n\n             * this cluster, therefore we do not need to keep it locked.\n\n             * As stated above, the allocating coroutine will always try to lock\n\n             * the mutex before all the other concurrent accesses to that\n\n             * cluster, therefore at this point we can be absolutely certain\n\n             * that that write operation has returned (there may be other writes\n\n             * in flight, but they do not concern this very operation). */\n\n            qemu_co_mutex_unlock(&s->write_lock);\n\n\n\n            qemu_iovec_reset(&local_qiov);\n\n            qemu_iovec_concat(&local_qiov, qiov, bytes_done, n_bytes);\n\n\n\n            ret = bdrv_co_pwritev(bs->file, data_offset, n_bytes,\n\n                                  &local_qiov, 0);\n\n        }\n\n\n\n        bytes -= n_bytes;\n\n        offset += n_bytes;\n\n        bytes_done += n_bytes;\n\n\n\n        logout(\"%u bytes written\\n\", n_bytes);\n\n    }\n\n\n\n    qemu_iovec_destroy(&local_qiov);\n\n\n\n    logout(\"finished data write\\n\");\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    if (block) {\n\n        /* One or more new blocks were allocated. */\n\n        VdiHeader *header = (VdiHeader *) block;\n\n        uint8_t *base;\n\n        uint64_t offset;\n\n        uint32_t n_sectors;\n\n\n\n        logout(\"now writing modified header\\n\");\n\n        assert(VDI_IS_ALLOCATED(bmap_first));\n\n        *header = s->header;\n\n        vdi_header_to_le(header);\n\n        ret = bdrv_write(bs->file, 0, block, 1);\n\n        g_free(block);\n\n        block = NULL;\n\n\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        logout(\"now writing modified block map entry %u...%u\\n\",\n\n               bmap_first, bmap_last);\n\n        /* Write modified sectors from block map. */\n\n        bmap_first /= (SECTOR_SIZE / sizeof(uint32_t));\n\n        bmap_last /= (SECTOR_SIZE / sizeof(uint32_t));\n\n        n_sectors = bmap_last - bmap_first + 1;\n\n        offset = s->bmap_sector + bmap_first;\n\n        base = ((uint8_t *)&s->bmap[0]) + bmap_first * SECTOR_SIZE;\n\n        logout(\"will write %u block map sectors starting from entry %u\\n\",\n\n               n_sectors, bmap_first);\n\n        ret = bdrv_write(bs->file, offset, base, n_sectors);\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 24747}
{"project": "qemu", "commit_id": "92c0bba9a95739c92e959fe478cb1acb92fa5446", "target": 0, "func": "static void omap_l4_io_writeb(void *opaque, target_phys_addr_t addr,\n\n                uint32_t value)\n\n{\n\n    unsigned int i = (addr - OMAP2_L4_BASE) >> TARGET_PAGE_BITS;\n\n\n\n    return omap_l4_io_writeb_fn[i](omap_l4_io_opaque[i], addr, value);\n\n}\n", "idx": 24748}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "bool bdrv_can_write_zeroes_with_unmap(BlockDriverState *bs)\n\n{\n\n    BlockDriverInfo bdi;\n\n\n\n    if (bs->backing_hd || !(bs->open_flags & BDRV_O_UNMAP)) {\n\n        return false;\n\n    }\n\n\n\n    if (bdrv_get_info(bs, &bdi) == 0) {\n\n        return bdi.can_write_zeroes_with_unmap;\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 24749}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static uint32_t read_u32(uint8_t *data, size_t offset)\n\n{\n\n    return ((data[offset] << 24) | (data[offset + 1] << 16) |\n\n\t    (data[offset + 2] << 8) | data[offset + 3]);\n\n}\n", "idx": 24750}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void check_breakpoint(CPUState *env, DisasContext *dc)\n\n{\n\n    CPUBreakpoint *bp;\n\n\n\n    if (unlikely(!TAILQ_EMPTY(&env->breakpoints))) {\n\n        TAILQ_FOREACH(bp, &env->breakpoints, entry) {\n\n            if (bp->pc == dc->pc) {\n\n                t_gen_raise_exception(dc, EXCP_DEBUG);\n\n                dc->is_jmp = DISAS_UPDATE;\n\n             }\n\n        }\n\n    }\n\n}\n", "idx": 24751}
{"project": "qemu", "commit_id": "7d5e199ade76c53ec316ab6779800581bb47c50a", "target": 0, "func": "static void dump_json_image_info(ImageInfo *info)\n\n{\n\n    QString *str;\n\n    QObject *obj;\n\n    Visitor *v = qmp_output_visitor_new(&obj);\n\n\n\n    visit_type_ImageInfo(v, NULL, &info, &error_abort);\n\n    visit_complete(v, &obj);\n\n    str = qobject_to_json_pretty(obj);\n\n    assert(str != NULL);\n\n    printf(\"%s\\n\", qstring_get_str(str));\n\n    qobject_decref(obj);\n\n    visit_free(v);\n\n    QDECREF(str);\n\n}\n", "idx": 24752}
{"project": "qemu", "commit_id": "d0d7708ba29cbcc343364a46bff981e0ff88366f", "target": 0, "func": "static CharDriverState *qemu_chr_open_msmouse(const char *id,\n\n                                              ChardevBackend *backend,\n\n                                              ChardevReturn *ret,\n\n                                              Error **errp)\n\n{\n\n    CharDriverState *chr;\n\n\n\n    chr = qemu_chr_alloc();\n\n    chr->chr_write = msmouse_chr_write;\n\n    chr->chr_close = msmouse_chr_close;\n\n    chr->explicit_be_open = true;\n\n\n\n    qemu_add_mouse_event_handler(msmouse_event, chr, 0, \"QEMU Microsoft Mouse\");\n\n\n\n    return chr;\n\n}\n", "idx": 24753}
{"project": "qemu", "commit_id": "63729c36924348e494d69adbbdec6fdda339b76b", "target": 0, "func": "static void v9fs_create_post_lstat(V9fsState *s, V9fsCreateState *vs, int err)\n\n{\n\n\n\n    if (err == 0 || errno != ENOENT) {\n\n        err = -errno;\n\n        goto out;\n\n    }\n\n\n\n    if (vs->perm & P9_STAT_MODE_DIR) {\n\n        err = v9fs_do_mkdir(s, vs);\n\n        v9fs_create_post_mkdir(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_SYMLINK) {\n\n        err = v9fs_do_symlink(s, vs);\n\n        v9fs_create_post_perms(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_LINK) {\n\n        int32_t nfid = atoi(vs->extension.data);\n\n        V9fsFidState *nfidp = lookup_fid(s, nfid);\n\n        if (nfidp == NULL) {\n\n            err = -errno;\n\n            v9fs_post_create(s, vs, err);\n\n        }\n\n        err = v9fs_do_link(s, &nfidp->path, &vs->fullname);\n\n        v9fs_create_post_perms(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_DEVICE) {\n\n        char ctype;\n\n        uint32_t major, minor;\n\n        mode_t nmode = 0;\n\n\n\n        if (sscanf(vs->extension.data, \"%c %u %u\", &ctype, &major,\n\n                                        &minor) != 3) {\n\n            err = -errno;\n\n            v9fs_post_create(s, vs, err);\n\n        }\n\n\n\n        switch (ctype) {\n\n        case 'c':\n\n            nmode = S_IFCHR;\n\n            break;\n\n        case 'b':\n\n            nmode = S_IFBLK;\n\n            break;\n\n        default:\n\n            err = -EIO;\n\n            v9fs_post_create(s, vs, err);\n\n        }\n\n\n\n        nmode |= vs->perm & 0777;\n\n        err = v9fs_do_mknod(s, vs, nmode, makedev(major, minor));\n\n        v9fs_create_post_perms(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_NAMED_PIPE) {\n\n        err = v9fs_do_mknod(s, vs, S_IFIFO | (vs->perm & 0777), 0);\n\n        v9fs_post_create(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_SOCKET) {\n\n        err = v9fs_do_mksock(s, &vs->fullname);\n\n        v9fs_create_post_mksock(s, vs, err);\n\n    } else {\n\n        vs->fidp->fd = v9fs_do_open2(s, vs);\n\n        v9fs_create_post_open2(s, vs, err);\n\n    }\n\n\n\n    return;\n\n\n\nout:\n\n    v9fs_post_create(s, vs, err);\n\n}\n", "idx": 24754}
{"project": "qemu", "commit_id": "5d259fc7da83249a4f78fe32de2bc2874a997a9f", "target": 0, "func": "static int iscsi_refresh_limits(BlockDriverState *bs)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n\n\n    /* We don't actually refresh here, but just return data queried in\n\n     * iscsi_open(): iscsi targets don't change their limits. */\n\n    if (iscsilun->lbp.lbpu || iscsilun->lbp.lbpws) {\n\n        if (iscsilun->bl.max_unmap < 0xffffffff) {\n\n            bs->bl.max_discard = sector_lun2qemu(iscsilun->bl.max_unmap,\n\n                                                 iscsilun);\n\n        }\n\n        bs->bl.discard_alignment = sector_lun2qemu(iscsilun->bl.opt_unmap_gran,\n\n                                                   iscsilun);\n\n\n\n        if (iscsilun->bl.max_ws_len < 0xffffffff) {\n\n            bs->bl.max_write_zeroes = sector_lun2qemu(iscsilun->bl.max_ws_len,\n\n                                                      iscsilun);\n\n        }\n\n        bs->bl.write_zeroes_alignment = sector_lun2qemu(iscsilun->bl.opt_unmap_gran,\n\n                                                        iscsilun);\n\n\n\n        bs->bl.opt_transfer_length = sector_lun2qemu(iscsilun->bl.opt_xfer_len,\n\n                                                     iscsilun);\n\n    }\n\n    return 0;\n\n}\n", "idx": 24755}
{"project": "qemu", "commit_id": "6049f4f831c6f409031dfa09282b38d0cbaecad8", "target": 0, "func": "void pal_init (CPUState *env)\n\n{\n\n}\n", "idx": 24756}
{"project": "qemu", "commit_id": "2c62f08ddbf3fa80dc7202eb9a2ea60ae44e2cc5", "target": 0, "func": "static int pci_cirrus_vga_initfn(PCIDevice *dev)\n\n{\n\n     PCICirrusVGAState *d = DO_UPCAST(PCICirrusVGAState, dev, dev);\n\n     CirrusVGAState *s = &d->cirrus_vga;\n\n     PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(dev);\n\n     int16_t device_id = pc->device_id;\n\n\n\n     /* setup VGA */\n\n     vga_common_init(&s->vga);\n\n     cirrus_init_common(s, device_id, 1, pci_address_space(dev),\n\n                        pci_address_space_io(dev));\n\n     s->vga.con = graphic_console_init(s->vga.update, s->vga.invalidate,\n\n                                       s->vga.screen_dump, s->vga.text_update,\n\n                                       &s->vga);\n\n\n\n     /* setup PCI */\n\n\n\n    memory_region_init(&s->pci_bar, \"cirrus-pci-bar0\", 0x2000000);\n\n\n\n    /* XXX: add byte swapping apertures */\n\n    memory_region_add_subregion(&s->pci_bar, 0, &s->cirrus_linear_io);\n\n    memory_region_add_subregion(&s->pci_bar, 0x1000000,\n\n                                &s->cirrus_linear_bitblt_io);\n\n\n\n     /* setup memory space */\n\n     /* memory #0 LFB */\n\n     /* memory #1 memory-mapped I/O */\n\n     /* XXX: s->vga.vram_size must be a power of two */\n\n     pci_register_bar(&d->dev, 0, PCI_BASE_ADDRESS_MEM_PREFETCH, &s->pci_bar);\n\n     if (device_id == CIRRUS_ID_CLGD5446) {\n\n         pci_register_bar(&d->dev, 1, 0, &s->cirrus_mmio_io);\n\n     }\n\n     return 0;\n\n}\n", "idx": 24758}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "target_ulong spapr_rtas_call(sPAPREnvironment *spapr,\n\n                             uint32_t token, uint32_t nargs, target_ulong args,\n\n                             uint32_t nret, target_ulong rets)\n\n{\n\n    if ((token >= TOKEN_BASE)\n\n        && ((token - TOKEN_BASE) < TOKEN_MAX)) {\n\n        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);\n\n\n\n        if (call->fn) {\n\n            call->fn(spapr, token, nargs, args, nret, rets);\n\n            return H_SUCCESS;\n\n        }\n\n    }\n\n\n\n    /* HACK: Some Linux early debug code uses RTAS display-character,\n\n     * but assumes the token value is 0xa (which it is on some real\n\n     * machines) without looking it up in the device tree.  This\n\n     * special case makes this work */\n\n    if (token == 0xa) {\n\n        rtas_display_character(spapr, 0xa, nargs, args, nret, rets);\n\n        return H_SUCCESS;\n\n    }\n\n\n\n    hcall_dprintf(\"Unknown RTAS token 0x%x\\n\", token);\n\n    rtas_st(rets, 0, -3);\n\n    return H_PARAMETER;\n\n}\n", "idx": 24759}
{"project": "qemu", "commit_id": "7c38ecd09763107513bacc791856fdbb582a107c", "target": 1, "func": "static int acpi_pcihp_get_bsel(PCIBus *bus)\n\n{\n\n    QObject *o = object_property_get_qobject(OBJECT(bus),\n\n                                             ACPI_PCIHP_PROP_BSEL, NULL);\n\n    int64_t bsel = -1;\n\n    if (o) {\n\n        bsel = qint_get_int(qobject_to_qint(o));\n\n    }\n\n    if (bsel < 0) {\n\n        return -1;\n\n    }\n\n    return bsel;\n\n}\n", "idx": 24763}
{"project": "qemu", "commit_id": "2f9606b3736c3be4dbd606c46525c7b770ced119", "target": 1, "func": "void vnc_client_write(void *opaque)\n\n{\n\n    long ret;\n\n    VncState *vs = opaque;\n\n\n\n#ifdef CONFIG_VNC_TLS\n\n    if (vs->tls.session) {\n\n\tret = gnutls_write(vs->tls.session, vs->output.buffer, vs->output.offset);\n\n\tif (ret < 0) {\n\n\t    if (ret == GNUTLS_E_AGAIN)\n\n\t\terrno = EAGAIN;\n\n\t    else\n\n\t\terrno = EIO;\n\n\t    ret = -1;\n\n\t}\n\n    } else\n\n#endif /* CONFIG_VNC_TLS */\n\n\tret = send(vs->csock, vs->output.buffer, vs->output.offset, 0);\n\n    ret = vnc_client_io_error(vs, ret, socket_error());\n\n    if (!ret)\n\n\treturn;\n\n\n\n    memmove(vs->output.buffer, vs->output.buffer + ret, (vs->output.offset - ret));\n\n    vs->output.offset -= ret;\n\n\n\n    if (vs->output.offset == 0) {\n\n\tqemu_set_fd_handler2(vs->csock, NULL, vnc_client_read, NULL, vs);\n\n    }\n\n}\n", "idx": 24764}
{"project": "qemu", "commit_id": "5839e53bbc0fec56021d758aab7610df421ed8c8", "target": 1, "func": "static void add_user_command(char *optarg)\n\n{\n\n    cmdline = g_realloc(cmdline, ++ncmdline * sizeof(char *));\n\n    cmdline[ncmdline-1] = optarg;\n\n}\n", "idx": 24765}
{"project": "qemu", "commit_id": "1e7398a140f7a6bd9f5a438e7ad0f1ef50990e25", "target": 1, "func": "bool vhost_dev_query(struct vhost_dev *hdev, VirtIODevice *vdev)\n\n{\n\n    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));\n\n    VirtioBusState *vbus = VIRTIO_BUS(qbus);\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(vbus);\n\n\n\n    return !k->query_guest_notifiers ||\n\n           k->query_guest_notifiers(qbus->parent) ||\n\n           hdev->force;\n\n}\n", "idx": 24766}
{"project": "qemu", "commit_id": "9e1c2ec8fd8d9a9ee299ea86c5f6c986fe25e838", "target": 1, "func": "static void pc_init_pci_1_3(QEMUMachineInitArgs *args)\n\n{\n\n    enable_compat_apic_id_mode();\n\n    pc_sysfw_flash_vs_rom_bug_compatible = true;\n\n    has_pvpanic = false;\n\n    pc_init_pci(args);\n\n}\n", "idx": 24767}
{"project": "qemu", "commit_id": "665414ad06aa1bc92e615db9641e58fb13d07de1", "target": 1, "func": "static int ram_block_enable_notify(const char *block_name, void *host_addr,\n\n                                   ram_addr_t offset, ram_addr_t length,\n\n                                   void *opaque)\n\n{\n\n    MigrationIncomingState *mis = opaque;\n\n    struct uffdio_register reg_struct;\n\n\n\n    reg_struct.range.start = (uintptr_t)host_addr;\n\n    reg_struct.range.len = length;\n\n    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;\n\n\n\n    /* Now tell our userfault_fd that it's responsible for this area */\n\n    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {\n\n        error_report(\"%s userfault register: %s\", __func__, strerror(errno));\n\n\n\n\n\n\n\n\n\n    return 0;\n", "idx": 24771}
{"project": "qemu", "commit_id": "53628efbc8aa7a7ab5354d24b971f4d69452151d", "target": 1, "func": "static void qemu_chr_fe_write_log(CharDriverState *s,\n\n                                  const uint8_t *buf, size_t len)\n\n{\n\n    size_t done = 0;\n\n    ssize_t ret;\n\n\n\n    if (s->logfd < 0) {\n\n        return;\n\n    }\n\n\n\n    while (done < len) {\n\n        do {\n\n            ret = write(s->logfd, buf + done, len - done);\n\n            if (ret == -1 && errno == EAGAIN) {\n\n                g_usleep(100);\n\n            }\n\n        } while (ret == -1 && errno == EAGAIN);\n\n\n\n        if (ret <= 0) {\n\n            return;\n\n        }\n\n        done += ret;\n\n    }\n\n}\n", "idx": 24772}
{"project": "qemu", "commit_id": "e78815a554adaa551d62a71be10ee2fcf128e473", "target": 1, "func": "void kvm_setup_guest_memory(void *start, size_t size)\n\n{\n\n    if (!kvm_has_sync_mmu()) {\n\n#ifdef MADV_DONTFORK\n\n        int ret = madvise(start, size, MADV_DONTFORK);\n\n\n\n        if (ret) {\n\n            perror(\"madvice\");\n\n            exit(1);\n\n        }\n\n#else\n\n        fprintf(stderr,\n\n                \"Need MADV_DONTFORK in absence of synchronous KVM MMU\\n\");\n\n        exit(1);\n\n#endif\n\n    }\n\n}\n", "idx": 24774}
{"project": "qemu", "commit_id": "4f298a4b2957b7833bc607c951ca27c458d98d88", "target": 1, "func": "static void send_msg(IPMIBmcSim *ibs,\n\n                     uint8_t *cmd, unsigned int cmd_len,\n\n                     uint8_t *rsp, unsigned int *rsp_len,\n\n                     unsigned int max_rsp_len)\n\n{\n\n    IPMIInterface *s = ibs->parent.intf;\n\n    IPMIInterfaceClass *k = IPMI_INTERFACE_GET_CLASS(s);\n\n    IPMIRcvBufEntry *msg;\n\n    uint8_t *buf;\n\n    uint8_t netfn, rqLun, rsLun, rqSeq;\n\n\n\n    IPMI_CHECK_CMD_LEN(3);\n\n\n\n    if (cmd[2] != 0) {\n\n        /* We only handle channel 0 with no options */\n\n        rsp[2] = IPMI_CC_INVALID_DATA_FIELD;\n\n        return;\n\n    }\n\n\n\n    IPMI_CHECK_CMD_LEN(10);\n\n    if (cmd[3] != 0x40) {\n\n        /* We only emulate a MC at address 0x40. */\n\n        rsp[2] = 0x83; /* NAK on write */\n\n        return;\n\n    }\n\n\n\n    cmd += 3; /* Skip the header. */\n\n    cmd_len -= 3;\n\n\n\n    /*\n\n     * At this point we \"send\" the message successfully.  Any error will\n\n     * be returned in the response.\n\n     */\n\n    if (ipmb_checksum(cmd, cmd_len, 0) != 0 ||\n\n        cmd[3] != 0x20) { /* Improper response address */\n\n        return; /* No response */\n\n    }\n\n\n\n    netfn = cmd[1] >> 2;\n\n    rqLun = cmd[4] & 0x3;\n\n    rsLun = cmd[1] & 0x3;\n\n    rqSeq = cmd[4] >> 2;\n\n\n\n    if (rqLun != 2) {\n\n        /* We only support LUN 2 coming back to us. */\n\n        return;\n\n    }\n\n\n\n    msg = g_malloc(sizeof(*msg));\n\n    msg->buf[0] = ((netfn | 1) << 2) | rqLun; /* NetFN, and make a response */\n\n    msg->buf[1] = ipmb_checksum(msg->buf, 1, 0);\n\n    msg->buf[2] = cmd[0]; /* rsSA */\n\n    msg->buf[3] = (rqSeq << 2) | rsLun;\n\n    msg->buf[4] = cmd[5]; /* Cmd */\n\n    msg->buf[5] = 0; /* Completion Code */\n\n    msg->len = 6;\n\n\n\n    if ((cmd[1] >> 2) != IPMI_NETFN_APP || cmd[5] != IPMI_CMD_GET_DEVICE_ID) {\n\n        /* Not a command we handle. */\n\n        msg->buf[5] = IPMI_CC_INVALID_CMD;\n\n        goto end_msg;\n\n    }\n\n\n\n    buf = msg->buf + msg->len; /* After the CC */\n\n    buf[0] = 0;\n\n    buf[1] = 0;\n\n    buf[2] = 0;\n\n    buf[3] = 0;\n\n    buf[4] = 0x51;\n\n    buf[5] = 0;\n\n    buf[6] = 0;\n\n    buf[7] = 0;\n\n    buf[8] = 0;\n\n    buf[9] = 0;\n\n    buf[10] = 0;\n\n    msg->len += 11;\n\n\n\n end_msg:\n\n    msg->buf[msg->len] = ipmb_checksum(msg->buf, msg->len, 0);\n\n    msg->len++;\n\n    qemu_mutex_lock(&ibs->lock);\n\n    QTAILQ_INSERT_TAIL(&ibs->rcvbufs, msg, entry);\n\n    ibs->msg_flags |= IPMI_BMC_MSG_FLAG_RCV_MSG_QUEUE;\n\n    k->set_atn(s, 1, attn_irq_enabled(ibs));\n\n    qemu_mutex_unlock(&ibs->lock);\n\n}\n", "idx": 24778}
{"project": "qemu", "commit_id": "91a5bb76d47e1b06f0b7b67cae8497d8efc6ab87", "target": 1, "func": "static void disas_xtensa_insn(DisasContext *dc)\n\n{\n\n#define HAS_OPTION(opt) do { \\\n\n        if (!option_enabled(dc, opt)) { \\\n\n            qemu_log(\"Option %d is not enabled %s:%d\\n\", \\\n\n                    (opt), __FILE__, __LINE__); \\\n\n            goto invalid_opcode; \\\n\n        } \\\n\n    } while (0)\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define OP0 (((b0) & 0xf0) >> 4)\n\n#define OP1 (((b2) & 0xf0) >> 4)\n\n#define OP2 ((b2) & 0xf)\n\n#define RRR_R ((b1) & 0xf)\n\n#define RRR_S (((b1) & 0xf0) >> 4)\n\n#define RRR_T ((b0) & 0xf)\n\n#else\n\n#define OP0 (((b0) & 0xf))\n\n#define OP1 (((b2) & 0xf))\n\n#define OP2 (((b2) & 0xf0) >> 4)\n\n#define RRR_R (((b1) & 0xf0) >> 4)\n\n#define RRR_S (((b1) & 0xf))\n\n#define RRR_T (((b0) & 0xf0) >> 4)\n\n#endif\n\n\n\n#define RRRN_R RRR_R\n\n#define RRRN_S RRR_S\n\n#define RRRN_T RRR_T\n\n\n\n#define RRI8_R RRR_R\n\n#define RRI8_S RRR_S\n\n#define RRI8_T RRR_T\n\n#define RRI8_IMM8 (b2)\n\n#define RRI8_IMM8_SE ((((b2) & 0x80) ? 0xffffff00 : 0) | RRI8_IMM8)\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define RI16_IMM16 (((b1) << 8) | (b2))\n\n#else\n\n#define RI16_IMM16 (((b2) << 8) | (b1))\n\n#endif\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define CALL_N (((b0) & 0xc) >> 2)\n\n#define CALL_OFFSET ((((b0) & 0x3) << 16) | ((b1) << 8) | (b2))\n\n#else\n\n#define CALL_N (((b0) & 0x30) >> 4)\n\n#define CALL_OFFSET ((((b0) & 0xc0) >> 6) | ((b1) << 2) | ((b2) << 10))\n\n#endif\n\n#define CALL_OFFSET_SE \\\n\n    (((CALL_OFFSET & 0x20000) ? 0xfffc0000 : 0) | CALL_OFFSET)\n\n\n\n#define CALLX_N CALL_N\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define CALLX_M ((b0) & 0x3)\n\n#else\n\n#define CALLX_M (((b0) & 0xc0) >> 6)\n\n#endif\n\n#define CALLX_S RRR_S\n\n\n\n#define BRI12_M CALLX_M\n\n#define BRI12_S RRR_S\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define BRI12_IMM12 ((((b1) & 0xf) << 8) | (b2))\n\n#else\n\n#define BRI12_IMM12 ((((b1) & 0xf0) >> 4) | ((b2) << 4))\n\n#endif\n\n#define BRI12_IMM12_SE (((BRI12_IMM12 & 0x800) ? 0xfffff000 : 0) | BRI12_IMM12)\n\n\n\n#define BRI8_M BRI12_M\n\n#define BRI8_R RRI8_R\n\n#define BRI8_S RRI8_S\n\n#define BRI8_IMM8 RRI8_IMM8\n\n#define BRI8_IMM8_SE RRI8_IMM8_SE\n\n\n\n#define RSR_SR (b1)\n\n\n\n    uint8_t b0 = ldub_code(dc->pc);\n\n    uint8_t b1 = ldub_code(dc->pc + 1);\n\n    uint8_t b2 = ldub_code(dc->pc + 2);\n\n\n\n    static const uint32_t B4CONST[] = {\n\n        0xffffffff, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256\n\n    };\n\n\n\n    static const uint32_t B4CONSTU[] = {\n\n        32768, 65536, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256\n\n    };\n\n\n\n    if (OP0 >= 8) {\n\n        dc->next_pc = dc->pc + 2;\n\n        HAS_OPTION(XTENSA_OPTION_CODE_DENSITY);\n\n    } else {\n\n        dc->next_pc = dc->pc + 3;\n\n    }\n\n\n\n    switch (OP0) {\n\n    case 0: /*QRST*/\n\n        switch (OP1) {\n\n        case 0: /*RST0*/\n\n            switch (OP2) {\n\n            case 0: /*ST0*/\n\n                if ((RRR_R & 0xc) == 0x8) {\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                }\n\n\n\n                switch (RRR_R) {\n\n                case 0: /*SNM0*/\n\n                    switch (CALLX_M) {\n\n                    case 0: /*ILL*/\n\n                        break;\n\n\n\n                    case 1: /*reserved*/\n\n                        break;\n\n\n\n                    case 2: /*JR*/\n\n                        switch (CALLX_N) {\n\n                        case 0: /*RET*/\n\n                        case 2: /*JX*/\n\n                            gen_jump(dc, cpu_R[CALLX_S]);\n\n                            break;\n\n\n\n                        case 1: /*RETWw*/\n\n                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                            break;\n\n\n\n                        case 3: /*reserved*/\n\n                            break;\n\n                        }\n\n                        break;\n\n\n\n                    case 3: /*CALLX*/\n\n                        switch (CALLX_N) {\n\n                        case 0: /*CALLX0*/\n\n                            {\n\n                                TCGv_i32 tmp = tcg_temp_new_i32();\n\n                                tcg_gen_mov_i32(tmp, cpu_R[CALLX_S]);\n\n                                tcg_gen_movi_i32(cpu_R[0], dc->next_pc);\n\n                                gen_jump(dc, tmp);\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n\n\n                        case 1: /*CALLX4w*/\n\n                        case 2: /*CALLX8w*/\n\n                        case 3: /*CALLX12w*/\n\n                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                            break;\n\n                        }\n\n                        break;\n\n                    }\n\n                    break;\n\n\n\n                case 1: /*MOVSPw*/\n\n                    HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                    break;\n\n\n\n                case 2: /*SYNC*/\n\n                    break;\n\n\n\n                case 3:\n\n                    break;\n\n\n\n                }\n\n                break;\n\n\n\n            case 1: /*AND*/\n\n                tcg_gen_and_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            case 2: /*OR*/\n\n                tcg_gen_or_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            case 3: /*XOR*/\n\n                tcg_gen_xor_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            case 4: /*ST1*/\n\n                switch (RRR_R) {\n\n                case 0: /*SSR*/\n\n                    gen_right_shift_sar(dc, cpu_R[RRR_S]);\n\n                    break;\n\n\n\n                case 1: /*SSL*/\n\n                    gen_left_shift_sar(dc, cpu_R[RRR_S]);\n\n                    break;\n\n\n\n                case 2: /*SSA8L*/\n\n                    {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], 3);\n\n                        gen_right_shift_sar(dc, tmp);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*SSA8B*/\n\n                    {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], 3);\n\n                        gen_left_shift_sar(dc, tmp);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*SSAI*/\n\n                    {\n\n                        TCGv_i32 tmp = tcg_const_i32(\n\n                                RRR_S | ((RRR_T & 1) << 4));\n\n                        gen_right_shift_sar(dc, tmp);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 6: /*RER*/\n\n                    break;\n\n\n\n                case 7: /*WER*/\n\n                    break;\n\n\n\n                case 8: /*ROTWw*/\n\n                    HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                    break;\n\n\n\n                case 14: /*NSAu*/\n\n                    HAS_OPTION(XTENSA_OPTION_MISC_OP);\n\n                    gen_helper_nsa(cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                    break;\n\n\n\n                case 15: /*NSAUu*/\n\n                    HAS_OPTION(XTENSA_OPTION_MISC_OP);\n\n                    gen_helper_nsau(cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            case 5: /*TLB*/\n\n                break;\n\n\n\n            case 6: /*RT0*/\n\n                switch (RRR_S) {\n\n                case 0: /*NEG*/\n\n                    tcg_gen_neg_i32(cpu_R[RRR_R], cpu_R[RRR_T]);\n\n                    break;\n\n\n\n                case 1: /*ABS*/\n\n                    {\n\n                        int label = gen_new_label();\n\n                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_R[RRR_T]);\n\n                        tcg_gen_brcondi_i32(\n\n                                TCG_COND_GE, cpu_R[RRR_R], 0, label);\n\n                        tcg_gen_neg_i32(cpu_R[RRR_R], cpu_R[RRR_T]);\n\n                        gen_set_label(label);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            case 7: /*reserved*/\n\n                break;\n\n\n\n            case 8: /*ADD*/\n\n                tcg_gen_add_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            case 9: /*ADD**/\n\n            case 10:\n\n            case 11:\n\n                {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_shli_i32(tmp, cpu_R[RRR_S], OP2 - 8);\n\n                    tcg_gen_add_i32(cpu_R[RRR_R], tmp, cpu_R[RRR_T]);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 12: /*SUB*/\n\n                tcg_gen_sub_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            case 13: /*SUB**/\n\n            case 14:\n\n            case 15:\n\n                {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_shli_i32(tmp, cpu_R[RRR_S], OP2 - 12);\n\n                    tcg_gen_sub_i32(cpu_R[RRR_R], tmp, cpu_R[RRR_T]);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 1: /*RST1*/\n\n            switch (OP2) {\n\n            case 0: /*SLLI*/\n\n            case 1:\n\n                tcg_gen_shli_i32(cpu_R[RRR_R], cpu_R[RRR_S],\n\n                        32 - (RRR_T | ((OP2 & 1) << 4)));\n\n                break;\n\n\n\n            case 2: /*SRAI*/\n\n            case 3:\n\n                tcg_gen_sari_i32(cpu_R[RRR_R], cpu_R[RRR_T],\n\n                        RRR_S | ((OP2 & 1) << 4));\n\n                break;\n\n\n\n            case 4: /*SRLI*/\n\n                tcg_gen_shri_i32(cpu_R[RRR_R], cpu_R[RRR_T], RRR_S);\n\n                break;\n\n\n\n            case 6: /*XSR*/\n\n                {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_mov_i32(tmp, cpu_R[RRR_T]);\n\n                    gen_rsr(dc, cpu_R[RRR_T], RSR_SR);\n\n                    gen_wsr(dc, RSR_SR, tmp);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n                /*\n\n                 * Note: 64 bit ops are used here solely because SAR values\n\n                 * have range 0..63\n\n                 */\n\n#define gen_shift_reg(cmd, reg) do { \\\n\n                    TCGv_i64 tmp = tcg_temp_new_i64(); \\\n\n                    tcg_gen_extu_i32_i64(tmp, reg); \\\n\n                    tcg_gen_##cmd##_i64(v, v, tmp); \\\n\n                    tcg_gen_trunc_i64_i32(cpu_R[RRR_R], v); \\\n\n                    tcg_temp_free_i64(v); \\\n\n                    tcg_temp_free_i64(tmp); \\\n\n                } while (0)\n\n\n\n#define gen_shift(cmd) gen_shift_reg(cmd, cpu_SR[SAR])\n\n\n\n            case 8: /*SRC*/\n\n                {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    tcg_gen_concat_i32_i64(v, cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                    gen_shift(shr);\n\n                }\n\n                break;\n\n\n\n            case 9: /*SRL*/\n\n                if (dc->sar_5bit) {\n\n                    tcg_gen_shr_i32(cpu_R[RRR_R], cpu_R[RRR_T], cpu_SR[SAR]);\n\n                } else {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    tcg_gen_extu_i32_i64(v, cpu_R[RRR_T]);\n\n                    gen_shift(shr);\n\n                }\n\n                break;\n\n\n\n            case 10: /*SLL*/\n\n                if (dc->sar_m32_5bit) {\n\n                    tcg_gen_shl_i32(cpu_R[RRR_R], cpu_R[RRR_S], dc->sar_m32);\n\n                } else {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    TCGv_i32 s = tcg_const_i32(32);\n\n                    tcg_gen_sub_i32(s, s, cpu_SR[SAR]);\n\n                    tcg_gen_andi_i32(s, s, 0x3f);\n\n                    tcg_gen_extu_i32_i64(v, cpu_R[RRR_S]);\n\n                    gen_shift_reg(shl, s);\n\n                    tcg_temp_free(s);\n\n                }\n\n                break;\n\n\n\n            case 11: /*SRA*/\n\n                if (dc->sar_5bit) {\n\n                    tcg_gen_sar_i32(cpu_R[RRR_R], cpu_R[RRR_T], cpu_SR[SAR]);\n\n                } else {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    tcg_gen_ext_i32_i64(v, cpu_R[RRR_T]);\n\n                    gen_shift(sar);\n\n                }\n\n                break;\n\n#undef gen_shift\n\n#undef gen_shift_reg\n\n\n\n            case 12: /*MUL16U*/\n\n                HAS_OPTION(XTENSA_OPTION_16_BIT_IMUL);\n\n                {\n\n                    TCGv_i32 v1 = tcg_temp_new_i32();\n\n                    TCGv_i32 v2 = tcg_temp_new_i32();\n\n                    tcg_gen_ext16u_i32(v1, cpu_R[RRR_S]);\n\n                    tcg_gen_ext16u_i32(v2, cpu_R[RRR_T]);\n\n                    tcg_gen_mul_i32(cpu_R[RRR_R], v1, v2);\n\n                    tcg_temp_free(v2);\n\n                    tcg_temp_free(v1);\n\n                }\n\n                break;\n\n\n\n            case 13: /*MUL16S*/\n\n                HAS_OPTION(XTENSA_OPTION_16_BIT_IMUL);\n\n                {\n\n                    TCGv_i32 v1 = tcg_temp_new_i32();\n\n                    TCGv_i32 v2 = tcg_temp_new_i32();\n\n                    tcg_gen_ext16s_i32(v1, cpu_R[RRR_S]);\n\n                    tcg_gen_ext16s_i32(v2, cpu_R[RRR_T]);\n\n                    tcg_gen_mul_i32(cpu_R[RRR_R], v1, v2);\n\n                    tcg_temp_free(v2);\n\n                    tcg_temp_free(v1);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 2: /*RST2*/\n\n            break;\n\n\n\n        case 3: /*RST3*/\n\n            switch (OP2) {\n\n            case 0: /*RSR*/\n\n                gen_rsr(dc, cpu_R[RRR_T], RSR_SR);\n\n                break;\n\n\n\n            case 1: /*WSR*/\n\n                gen_wsr(dc, RSR_SR, cpu_R[RRR_T]);\n\n                break;\n\n\n\n            case 2: /*SEXTu*/\n\n                HAS_OPTION(XTENSA_OPTION_MISC_OP);\n\n                {\n\n                    int shift = 24 - RRR_T;\n\n\n\n                    if (shift == 24) {\n\n                        tcg_gen_ext8s_i32(cpu_R[RRR_R], cpu_R[RRR_S]);\n\n                    } else if (shift == 16) {\n\n                        tcg_gen_ext16s_i32(cpu_R[RRR_R], cpu_R[RRR_S]);\n\n                    } else {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], shift);\n\n                        tcg_gen_sari_i32(cpu_R[RRR_R], tmp, shift);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                }\n\n                break;\n\n\n\n            case 3: /*CLAMPSu*/\n\n                HAS_OPTION(XTENSA_OPTION_MISC_OP);\n\n                {\n\n                    TCGv_i32 tmp1 = tcg_temp_new_i32();\n\n                    TCGv_i32 tmp2 = tcg_temp_new_i32();\n\n                    int label = gen_new_label();\n\n\n\n                    tcg_gen_sari_i32(tmp1, cpu_R[RRR_S], 24 - RRR_T);\n\n                    tcg_gen_xor_i32(tmp2, tmp1, cpu_R[RRR_S]);\n\n                    tcg_gen_andi_i32(tmp2, tmp2, 0xffffffff << (RRR_T + 7));\n\n                    tcg_gen_mov_i32(cpu_R[RRR_R], cpu_R[RRR_S]);\n\n                    tcg_gen_brcondi_i32(TCG_COND_EQ, tmp2, 0, label);\n\n\n\n                    tcg_gen_sari_i32(tmp1, cpu_R[RRR_S], 31);\n\n                    tcg_gen_xori_i32(cpu_R[RRR_R], tmp1,\n\n                            0xffffffff >> (25 - RRR_T));\n\n\n\n                    gen_set_label(label);\n\n\n\n                    tcg_temp_free(tmp1);\n\n                    tcg_temp_free(tmp2);\n\n                }\n\n                break;\n\n\n\n            case 4: /*MINu*/\n\n            case 5: /*MAXu*/\n\n            case 6: /*MINUu*/\n\n            case 7: /*MAXUu*/\n\n                HAS_OPTION(XTENSA_OPTION_MISC_OP);\n\n                {\n\n                    static const TCGCond cond[] = {\n\n                        TCG_COND_LE,\n\n                        TCG_COND_GE,\n\n                        TCG_COND_LEU,\n\n                        TCG_COND_GEU\n\n                    };\n\n                    int label = gen_new_label();\n\n\n\n                    if (RRR_R != RRR_T) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_R[RRR_S]);\n\n                        tcg_gen_brcond_i32(cond[OP2 - 4],\n\n                                cpu_R[RRR_S], cpu_R[RRR_T], label);\n\n                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_R[RRR_T]);\n\n                    } else {\n\n                        tcg_gen_brcond_i32(cond[OP2 - 4],\n\n                                cpu_R[RRR_T], cpu_R[RRR_S], label);\n\n                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_R[RRR_S]);\n\n                    }\n\n                    gen_set_label(label);\n\n                }\n\n                break;\n\n\n\n            case 8: /*MOVEQZ*/\n\n            case 9: /*MOVNEZ*/\n\n            case 10: /*MOVLTZ*/\n\n            case 11: /*MOVGEZ*/\n\n                {\n\n                    static const TCGCond cond[] = {\n\n                        TCG_COND_NE,\n\n                        TCG_COND_EQ,\n\n                        TCG_COND_GE,\n\n                        TCG_COND_LT\n\n                    };\n\n                    int label = gen_new_label();\n\n                    tcg_gen_brcondi_i32(cond[OP2 - 8], cpu_R[RRR_T], 0, label);\n\n                    tcg_gen_mov_i32(cpu_R[RRR_R], cpu_R[RRR_S]);\n\n                    gen_set_label(label);\n\n                }\n\n                break;\n\n\n\n            case 12: /*MOVFp*/\n\n                HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                break;\n\n\n\n            case 13: /*MOVTp*/\n\n                HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                break;\n\n\n\n            case 14: /*RUR*/\n\n                {\n\n                    int st = (RRR_S << 4) + RRR_T;\n\n                    if (uregnames[st]) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_UR[st]);\n\n                    } else {\n\n                        qemu_log(\"RUR %d not implemented, \", st);\n\n                    }\n\n                }\n\n                break;\n\n\n\n            case 15: /*WUR*/\n\n                {\n\n                    if (uregnames[RSR_SR]) {\n\n                        tcg_gen_mov_i32(cpu_UR[RSR_SR], cpu_R[RRR_T]);\n\n                    } else {\n\n                        qemu_log(\"WUR %d not implemented, \", RSR_SR);\n\n                    }\n\n                }\n\n                break;\n\n\n\n            }\n\n            break;\n\n\n\n        case 4: /*EXTUI*/\n\n        case 5:\n\n            {\n\n                int shiftimm = RRR_S | (OP1 << 4);\n\n                int maskimm = (1 << (OP2 + 1)) - 1;\n\n\n\n                TCGv_i32 tmp = tcg_temp_new_i32();\n\n                tcg_gen_shri_i32(tmp, cpu_R[RRR_T], shiftimm);\n\n                tcg_gen_andi_i32(cpu_R[RRR_R], tmp, maskimm);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n\n\n        case 6: /*CUST0*/\n\n            break;\n\n\n\n        case 7: /*CUST1*/\n\n            break;\n\n\n\n        case 8: /*LSCXp*/\n\n            HAS_OPTION(XTENSA_OPTION_COPROCESSOR);\n\n            break;\n\n\n\n        case 9: /*LSC4*/\n\n            break;\n\n\n\n        case 10: /*FP0*/\n\n            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n            break;\n\n\n\n        case 11: /*FP1*/\n\n            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 1: /*L32R*/\n\n        {\n\n            TCGv_i32 tmp = tcg_const_i32(\n\n                    (0xfffc0000 | (RI16_IMM16 << 2)) +\n\n                    ((dc->pc + 3) & ~3));\n\n\n\n            /* no ext L32R */\n\n\n\n            tcg_gen_qemu_ld32u(cpu_R[RRR_T], tmp, 0);\n\n            tcg_temp_free(tmp);\n\n        }\n\n        break;\n\n\n\n    case 2: /*LSAI*/\n\n#define gen_load_store(type, shift) do { \\\n\n            TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n            tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << shift); \\\n\n            tcg_gen_qemu_##type(cpu_R[RRI8_T], addr, 0); \\\n\n            tcg_temp_free(addr); \\\n\n        } while (0)\n\n\n\n        switch (RRI8_R) {\n\n        case 0: /*L8UI*/\n\n            gen_load_store(ld8u, 0);\n\n            break;\n\n\n\n        case 1: /*L16UI*/\n\n            gen_load_store(ld16u, 1);\n\n            break;\n\n\n\n        case 2: /*L32I*/\n\n            gen_load_store(ld32u, 2);\n\n            break;\n\n\n\n        case 4: /*S8I*/\n\n            gen_load_store(st8, 0);\n\n            break;\n\n\n\n        case 5: /*S16I*/\n\n            gen_load_store(st16, 1);\n\n            break;\n\n\n\n        case 6: /*S32I*/\n\n            gen_load_store(st32, 2);\n\n            break;\n\n\n\n        case 7: /*CACHEc*/\n\n            break;\n\n\n\n        case 9: /*L16SI*/\n\n            gen_load_store(ld16s, 1);\n\n            break;\n\n\n\n        case 10: /*MOVI*/\n\n            tcg_gen_movi_i32(cpu_R[RRI8_T],\n\n                    RRI8_IMM8 | (RRI8_S << 8) |\n\n                    ((RRI8_S & 0x8) ? 0xfffff000 : 0));\n\n            break;\n\n\n\n        case 11: /*L32AIy*/\n\n            HAS_OPTION(XTENSA_OPTION_MP_SYNCHRO);\n\n            gen_load_store(ld32u, 2); /*TODO acquire?*/\n\n            break;\n\n\n\n        case 12: /*ADDI*/\n\n            tcg_gen_addi_i32(cpu_R[RRI8_T], cpu_R[RRI8_S], RRI8_IMM8_SE);\n\n            break;\n\n\n\n        case 13: /*ADDMI*/\n\n            tcg_gen_addi_i32(cpu_R[RRI8_T], cpu_R[RRI8_S], RRI8_IMM8_SE << 8);\n\n            break;\n\n\n\n        case 14: /*S32C1Iy*/\n\n            HAS_OPTION(XTENSA_OPTION_MP_SYNCHRO);\n\n            {\n\n                int label = gen_new_label();\n\n                TCGv_i32 tmp = tcg_temp_local_new_i32();\n\n                TCGv_i32 addr = tcg_temp_local_new_i32();\n\n\n\n                tcg_gen_mov_i32(tmp, cpu_R[RRI8_T]);\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2);\n\n                tcg_gen_qemu_ld32u(cpu_R[RRI8_T], addr, 0);\n\n                tcg_gen_brcond_i32(TCG_COND_NE, cpu_R[RRI8_T],\n\n                        cpu_SR[SCOMPARE1], label);\n\n\n\n                tcg_gen_qemu_st32(tmp, addr, 0);\n\n\n\n                gen_set_label(label);\n\n                tcg_temp_free(addr);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n\n\n        case 15: /*S32RIy*/\n\n            HAS_OPTION(XTENSA_OPTION_MP_SYNCHRO);\n\n            gen_load_store(st32, 2); /*TODO release?*/\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            break;\n\n        }\n\n        break;\n\n#undef gen_load_store\n\n\n\n    case 3: /*LSCIp*/\n\n        HAS_OPTION(XTENSA_OPTION_COPROCESSOR);\n\n        break;\n\n\n\n    case 4: /*MAC16d*/\n\n        HAS_OPTION(XTENSA_OPTION_MAC16);\n\n        break;\n\n\n\n    case 5: /*CALLN*/\n\n        switch (CALL_N) {\n\n        case 0: /*CALL0*/\n\n            tcg_gen_movi_i32(cpu_R[0], dc->next_pc);\n\n            gen_jumpi(dc, (dc->pc & ~3) + (CALL_OFFSET_SE << 2) + 4, 0);\n\n            break;\n\n\n\n        case 1: /*CALL4w*/\n\n        case 2: /*CALL8w*/\n\n        case 3: /*CALL12w*/\n\n            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 6: /*SI*/\n\n        switch (CALL_N) {\n\n        case 0: /*J*/\n\n            gen_jumpi(dc, dc->pc + 4 + CALL_OFFSET_SE, 0);\n\n            break;\n\n\n\n        case 1: /*BZ*/\n\n            {\n\n                static const TCGCond cond[] = {\n\n                    TCG_COND_EQ, /*BEQZ*/\n\n                    TCG_COND_NE, /*BNEZ*/\n\n                    TCG_COND_LT, /*BLTZ*/\n\n                    TCG_COND_GE, /*BGEZ*/\n\n                };\n\n\n\n                gen_brcondi(dc, cond[BRI12_M & 3], cpu_R[BRI12_S], 0,\n\n                        4 + BRI12_IMM12_SE);\n\n            }\n\n            break;\n\n\n\n        case 2: /*BI0*/\n\n            {\n\n                static const TCGCond cond[] = {\n\n                    TCG_COND_EQ, /*BEQI*/\n\n                    TCG_COND_NE, /*BNEI*/\n\n                    TCG_COND_LT, /*BLTI*/\n\n                    TCG_COND_GE, /*BGEI*/\n\n                };\n\n\n\n                gen_brcondi(dc, cond[BRI8_M & 3],\n\n                        cpu_R[BRI8_S], B4CONST[BRI8_R], 4 + BRI8_IMM8_SE);\n\n            }\n\n            break;\n\n\n\n        case 3: /*BI1*/\n\n            switch (BRI8_M) {\n\n            case 0: /*ENTRYw*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                break;\n\n\n\n            case 1: /*B1*/\n\n                switch (BRI8_R) {\n\n                case 0: /*BFp*/\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                    break;\n\n\n\n                case 1: /*BTp*/\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                    break;\n\n\n\n                case 8: /*LOOP*/\n\n                    break;\n\n\n\n                case 9: /*LOOPNEZ*/\n\n                    break;\n\n\n\n                case 10: /*LOOPGTZ*/\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    break;\n\n\n\n                }\n\n                break;\n\n\n\n            case 2: /*BLTUI*/\n\n            case 3: /*BGEUI*/\n\n                gen_brcondi(dc, BRI8_M == 2 ? TCG_COND_LTU : TCG_COND_GEU,\n\n                        cpu_R[BRI8_S], B4CONSTU[BRI8_R], 4 + BRI8_IMM8_SE);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        }\n\n        break;\n\n\n\n    case 7: /*B*/\n\n        {\n\n            TCGCond eq_ne = (RRI8_R & 8) ? TCG_COND_NE : TCG_COND_EQ;\n\n\n\n            switch (RRI8_R & 7) {\n\n            case 0: /*BNONE*/ /*BANY*/\n\n                {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], cpu_R[RRI8_T]);\n\n                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 1: /*BEQ*/ /*BNE*/\n\n            case 2: /*BLT*/ /*BGE*/\n\n            case 3: /*BLTU*/ /*BGEU*/\n\n                {\n\n                    static const TCGCond cond[] = {\n\n                        [1] = TCG_COND_EQ,\n\n                        [2] = TCG_COND_LT,\n\n                        [3] = TCG_COND_LTU,\n\n                        [9] = TCG_COND_NE,\n\n                        [10] = TCG_COND_GE,\n\n                        [11] = TCG_COND_GEU,\n\n                    };\n\n                    gen_brcond(dc, cond[RRI8_R], cpu_R[RRI8_S], cpu_R[RRI8_T],\n\n                            4 + RRI8_IMM8_SE);\n\n                }\n\n                break;\n\n\n\n            case 4: /*BALL*/ /*BNALL*/\n\n                {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], cpu_R[RRI8_T]);\n\n                    gen_brcond(dc, eq_ne, tmp, cpu_R[RRI8_T],\n\n                            4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 5: /*BBC*/ /*BBS*/\n\n                {\n\n                    TCGv_i32 bit = tcg_const_i32(1);\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_andi_i32(tmp, cpu_R[RRI8_T], 0x1f);\n\n                    tcg_gen_shl_i32(bit, bit, tmp);\n\n                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], bit);\n\n                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                    tcg_temp_free(bit);\n\n                }\n\n                break;\n\n\n\n            case 6: /*BBCI*/ /*BBSI*/\n\n            case 7:\n\n                {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_andi_i32(tmp, cpu_R[RRI8_S],\n\n                            1 << (((RRI8_R & 1) << 4) | RRI8_T));\n\n                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            }\n\n        }\n\n        break;\n\n\n\n#define gen_narrow_load_store(type) do { \\\n\n            TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n            tcg_gen_addi_i32(addr, cpu_R[RRRN_S], RRRN_R << 2); \\\n\n            tcg_gen_qemu_##type(cpu_R[RRRN_T], addr, 0); \\\n\n            tcg_temp_free(addr); \\\n\n        } while (0)\n\n\n\n    case 8: /*L32I.Nn*/\n\n        gen_narrow_load_store(ld32u);\n\n        break;\n\n\n\n    case 9: /*S32I.Nn*/\n\n        gen_narrow_load_store(st32);\n\n        break;\n\n#undef gen_narrow_load_store\n\n\n\n    case 10: /*ADD.Nn*/\n\n        tcg_gen_add_i32(cpu_R[RRRN_R], cpu_R[RRRN_S], cpu_R[RRRN_T]);\n\n        break;\n\n\n\n    case 11: /*ADDI.Nn*/\n\n        tcg_gen_addi_i32(cpu_R[RRRN_R], cpu_R[RRRN_S], RRRN_T ? RRRN_T : -1);\n\n        break;\n\n\n\n    case 12: /*ST2n*/\n\n        if (RRRN_T < 8) { /*MOVI.Nn*/\n\n            tcg_gen_movi_i32(cpu_R[RRRN_S],\n\n                    RRRN_R | (RRRN_T << 4) |\n\n                    ((RRRN_T & 6) == 6 ? 0xffffff80 : 0));\n\n        } else { /*BEQZ.Nn*/ /*BNEZ.Nn*/\n\n            TCGCond eq_ne = (RRRN_T & 4) ? TCG_COND_NE : TCG_COND_EQ;\n\n\n\n            gen_brcondi(dc, eq_ne, cpu_R[RRRN_S], 0,\n\n                    4 + (RRRN_R | ((RRRN_T & 3) << 4)));\n\n        }\n\n        break;\n\n\n\n    case 13: /*ST3n*/\n\n        switch (RRRN_R) {\n\n        case 0: /*MOV.Nn*/\n\n            tcg_gen_mov_i32(cpu_R[RRRN_T], cpu_R[RRRN_S]);\n\n            break;\n\n\n\n        case 15: /*S3*/\n\n            switch (RRRN_T) {\n\n            case 0: /*RET.Nn*/\n\n                gen_jump(dc, cpu_R[0]);\n\n                break;\n\n\n\n            case 1: /*RETW.Nn*/\n\n                break;\n\n\n\n            case 2: /*BREAK.Nn*/\n\n                break;\n\n\n\n            case 3: /*NOP.Nn*/\n\n                break;\n\n\n\n            case 6: /*ILL.Nn*/\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default: /*reserved*/\n\n        break;\n\n    }\n\n\n\n    dc->pc = dc->next_pc;\n\n    return;\n\n\n\ninvalid_opcode:\n\n    qemu_log(\"INVALID(pc = %08x)\\n\", dc->pc);\n\n    dc->pc = dc->next_pc;\n\n#undef HAS_OPTION\n\n}\n", "idx": 24780}
{"project": "qemu", "commit_id": "16e977d506bcc2d9f7daa4a9f7cc2b48536d9da6", "target": 1, "func": "void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)\n\n{\n\n    BdrvChild *child;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    if (!bs->drv)  {\n\n        return;\n\n    }\n\n\n\n    if (!(bs->open_flags & BDRV_O_INACTIVE)) {\n\n        return;\n\n    }\n\n    bs->open_flags &= ~BDRV_O_INACTIVE;\n\n\n\n    if (bs->drv->bdrv_invalidate_cache) {\n\n        bs->drv->bdrv_invalidate_cache(bs, &local_err);\n\n        if (local_err) {\n\n            bs->open_flags |= BDRV_O_INACTIVE;\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n    }\n\n\n\n    QLIST_FOREACH(child, &bs->children, next) {\n\n        bdrv_invalidate_cache(child->bs, &local_err);\n\n        if (local_err) {\n\n            bs->open_flags |= BDRV_O_INACTIVE;\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n    }\n\n\n\n    ret = refresh_total_sectors(bs, bs->total_sectors);\n\n    if (ret < 0) {\n\n        bs->open_flags |= BDRV_O_INACTIVE;\n\n        error_setg_errno(errp, -ret, \"Could not refresh total sector count\");\n\n        return;\n\n    }\n\n}\n", "idx": 24781}
{"project": "qemu", "commit_id": "f8de16605cf9864e258d91e95be0ed76bdeac744", "target": 1, "func": "static uint64_t get_cluster_offset(BlockDriverState *bs,\n                                   uint64_t offset, int *num)\n{\n    BDRVQcowState *s = bs->opaque;\n    int l1_index, l2_index;\n    uint64_t l2_offset, *l2_table, cluster_offset;\n    int l1_bits, c;\n    int index_in_cluster, nb_available, nb_needed, nb_clusters;\n    index_in_cluster = (offset >> 9) & (s->cluster_sectors - 1);\n    nb_needed = *num + index_in_cluster;\n    l1_bits = s->l2_bits + s->cluster_bits;\n    /* compute how many bytes there are between the offset and\n     * the end of the l1 entry\n     */\n    nb_available = (1 << l1_bits) - (offset & ((1 << l1_bits) - 1));\n    /* compute the number of available sectors */\n    nb_available = (nb_available >> 9) + index_in_cluster;\n    cluster_offset = 0;\n    /* seek the the l2 offset in the l1 table */\n    l1_index = offset >> l1_bits;\n    if (l1_index >= s->l1_size)\n        goto out;\n    l2_offset = s->l1_table[l1_index];\n    /* seek the l2 table of the given l2 offset */\n    if (!l2_offset)\n        goto out;\n    /* load the l2 table in memory */\n    l2_offset &= ~QCOW_OFLAG_COPIED;\n    l2_table = l2_load(bs, l2_offset);\n    if (l2_table == NULL)\n        return 0;\n    /* find the cluster offset for the given disk offset */\n    l2_index = (offset >> s->cluster_bits) & (s->l2_size - 1);\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n    nb_clusters = size_to_clusters(s, nb_needed << 9);\n    if (!cluster_offset) {\n        /* how many empty clusters ? */\n        c = count_contiguous_free_clusters(nb_clusters, &l2_table[l2_index]);\n    } else {\n        /* how many allocated clusters ? */\n        c = count_contiguous_clusters(nb_clusters, s->cluster_size,\n                &l2_table[l2_index], 0, QCOW_OFLAG_COPIED);\n   nb_available = (c * s->cluster_sectors);\nout:\n    if (nb_available > nb_needed)\n        nb_available = nb_needed;\n    *num = nb_available - index_in_cluster;\n    return cluster_offset & ~QCOW_OFLAG_COPIED;", "idx": 24791}
{"project": "qemu", "commit_id": "1f51470d044852592922f91000e741c381582cdc", "target": 1, "func": "static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr)\n\n{\n\n    const char *file_out = qemu_opt_get(opts, \"path\");\n\n    HANDLE fd_out;\n\n\n\n    fd_out = CreateFile(file_out, GENERIC_WRITE, FILE_SHARE_READ, NULL,\n\n                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n\n    if (fd_out == INVALID_HANDLE_VALUE) {\n\n        return -EIO;\n\n    }\n\n\n\n    return qemu_chr_open_win_file(fd_out, _chr);\n\n}\n", "idx": 24794}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "bool migrate_auto_converge(void)\n\n{\n\n    MigrationState *s;\n\n\n\n    s = migrate_get_current();\n\n\n\n    return s->enabled_capabilities[MIGRATION_CAPABILITY_AUTO_CONVERGE];\n\n}\n", "idx": 24796}
{"project": "qemu", "commit_id": "16fde5f2c2788232b16c06d34d0459a5c1ec1f6c", "target": 1, "func": "static int get_cluster_table(BlockDriverState *bs, uint64_t offset,\n\n                             uint64_t **new_l2_table,\n\n                             uint64_t *new_l2_offset,\n\n                             int *new_l2_index)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    unsigned int l1_index, l2_index;\n\n    uint64_t l2_offset;\n\n    uint64_t *l2_table = NULL;\n\n    int ret;\n\n\n\n    /* seek the the l2 offset in the l1 table */\n\n\n\n    l1_index = offset >> (s->l2_bits + s->cluster_bits);\n\n    if (l1_index >= s->l1_size) {\n\n        ret = qcow2_grow_l1_table(bs, l1_index + 1, false);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    l2_offset = s->l1_table[l1_index];\n\n\n\n    /* seek the l2 table of the given l2 offset */\n\n\n\n    if (l2_offset & QCOW_OFLAG_COPIED) {\n\n        /* load the l2 table in memory */\n\n        l2_offset &= ~QCOW_OFLAG_COPIED;\n\n        ret = l2_load(bs, l2_offset, &l2_table);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    } else {\n\n        /* FIXME Order */\n\n        if (l2_offset)\n\n            qcow2_free_clusters(bs, l2_offset, s->l2_size * sizeof(uint64_t));\n\n        ret = l2_allocate(bs, l1_index, &l2_table);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        l2_offset = s->l1_table[l1_index] & ~QCOW_OFLAG_COPIED;\n\n    }\n\n\n\n    /* find the cluster offset for the given disk offset */\n\n\n\n    l2_index = (offset >> s->cluster_bits) & (s->l2_size - 1);\n\n\n\n    *new_l2_table = l2_table;\n\n    *new_l2_offset = l2_offset;\n\n    *new_l2_index = l2_index;\n\n\n\n    return 0;\n\n}\n", "idx": 24798}
{"project": "qemu", "commit_id": "7f1e9d4e138f5baf1e862a1221ba13eee7dcce9e", "target": 1, "func": "static ssize_t nic_receive(VLANClientState *vc, const uint8_t * buf, size_t size)\n\n{\n\n    /* TODO:\n\n     * - Magic packets should set bit 30 in power management driver register.\n\n     * - Interesting packets should set bit 29 in power management driver register.\n\n     */\n\n    EEPRO100State *s = vc->opaque;\n\n    uint16_t rfd_status = 0xa000;\n\n    static const uint8_t broadcast_macaddr[6] =\n\n        { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\n\n\n    /* TODO: check multiple IA bit. */\n\n    assert(!(s->configuration[20] & BIT(6)));\n\n\n\n    if (s->configuration[8] & 0x80) {\n\n        /* CSMA is disabled. */\n\n        logout(\"%p received while CSMA is disabled\\n\", s);\n\n        return -1;\n\n    } else if (size < 64 && (s->configuration[7] & 1)) {\n\n        /* Short frame and configuration byte 7/0 (discard short receive) set:\n\n         * Short frame is discarded */\n\n        logout(\"%p received short frame (%zu byte)\\n\", s, size);\n\n        s->statistics.rx_short_frame_errors++;\n\n        //~ return -1;\n\n    } else if ((size > MAX_ETH_FRAME_SIZE + 4) && !(s->configuration[18] & 8)) {\n\n        /* Long frame and configuration byte 18/3 (long receive ok) not set:\n\n         * Long frames are discarded. */\n\n        logout(\"%p received long frame (%zu byte), ignored\\n\", s, size);\n\n        return -1;\n\n    } else if (memcmp(buf, s->macaddr, 6) == 0) {       // !!!\n\n        /* Frame matches individual address. */\n\n        /* TODO: check configuration byte 15/4 (ignore U/L). */\n\n        TRACE(RXTX, logout(\"%p received frame for me, len=%zu\\n\", s, size));\n\n    } else if (memcmp(buf, broadcast_macaddr, 6) == 0) {\n\n        /* Broadcast frame. */\n\n        TRACE(RXTX, logout(\"%p received broadcast, len=%zu\\n\", s, size));\n\n        rfd_status |= 0x0002;\n\n    } else if (buf[0] & 0x01) { // !!!\n\n        /* Multicast frame. */\n\n        TRACE(RXTX, logout(\"%p received multicast, len=%zu\\n\", s, size));\n\n        /* TODO: check multicast all bit. */\n\n        assert(!(s->configuration[21] & BIT(3)));\n\n        int mcast_idx = compute_mcast_idx(buf);\n\n        if (!(s->mult[mcast_idx >> 3] & (1 << (mcast_idx & 7)))) {\n\n            return size;\n\n        }\n\n        rfd_status |= 0x0002;\n\n    } else if (s->configuration[15] & 1) {\n\n        /* Promiscuous: receive all. */\n\n        TRACE(RXTX, logout(\"%p received frame in promiscuous mode, len=%zu\\n\", s, size));\n\n        rfd_status |= 0x0004;\n\n    } else {\n\n        TRACE(RXTX, logout(\"%p received frame, ignored, len=%zu,%s\\n\", s, size,\n\n              nic_dump(buf, size)));\n\n        return size;\n\n    }\n\n\n\n    if (get_ru_state(s) != ru_ready) {\n\n        /* No resources available. */\n\n        logout(\"no resources, state=%u\\n\", get_ru_state(s));\n\n        s->statistics.rx_resource_errors++;\n\n        //~ assert(!\"no resources\");\n\n        return -1;\n\n    }\n\n    //~ !!!\n\n//~ $3 = {status = 0x0, command = 0xc000, link = 0x2d220, rx_buf_addr = 0x207dc, count = 0x0, size = 0x5f8, packet = {0x0 <repeats 1518 times>}}\n\n    eepro100_rx_t rx;\n\n    cpu_physical_memory_read(s->ru_base + s->ru_offset, (uint8_t *) & rx,\n\n                             offsetof(eepro100_rx_t, packet));\n\n    uint16_t rfd_command = le16_to_cpu(rx.command);\n\n    uint16_t rfd_size = le16_to_cpu(rx.size);\n\n    assert(size <= rfd_size);\n\n    if (size < 64) {\n\n        rfd_status |= 0x0080;\n\n    }\n\n    TRACE(OTHER, logout(\"command 0x%04x, link 0x%08x, addr 0x%08x, size %u\\n\",\n\n          rfd_command, rx.link, rx.rx_buf_addr, rfd_size));\n\n    stw_phys(s->ru_base + s->ru_offset + offsetof(eepro100_rx_t, status),\n\n             rfd_status);\n\n    stw_phys(s->ru_base + s->ru_offset + offsetof(eepro100_rx_t, count), size);\n\n    /* Early receive interrupt not supported. */\n\n    //~ eepro100_er_interrupt(s);\n\n    /* Receive CRC Transfer not supported. */\n\n    assert(!(s->configuration[18] & 4));\n\n    /* TODO: check stripping enable bit. */\n\n    //~ assert(!(s->configuration[17] & 1));\n\n    cpu_physical_memory_write(s->ru_base + s->ru_offset +\n\n                              offsetof(eepro100_rx_t, packet), buf, size);\n\n    s->statistics.rx_good_frames++;\n\n    eepro100_fr_interrupt(s);\n\n    s->ru_offset = le32_to_cpu(rx.link);\n\n    if (rfd_command & 0x8000) {\n\n        /* EL bit is set, so this was the last frame. */\n\n        assert(0);\n\n    }\n\n    if (rfd_command & 0x4000) {\n\n        /* S bit is set. */\n\n        set_ru_state(s, ru_suspended);\n\n    }\n\n    return size;\n\n}\n", "idx": 24801}
{"project": "qemu", "commit_id": "b9c600d20716b3d942cb07188ff998fb236a8365", "target": 1, "func": "static BlockAIOCB *read_quorum_children(QuorumAIOCB *acb)\n\n{\n\n    BDRVQuorumState *s = acb->common.bs->opaque;\n\n    int i;\n\n\n\n    for (i = 0; i < s->num_children; i++) {\n\n        acb->qcrs[i].buf = qemu_blockalign(s->children[i]->bs, acb->qiov->size);\n\n        qemu_iovec_init(&acb->qcrs[i].qiov, acb->qiov->niov);\n\n        qemu_iovec_clone(&acb->qcrs[i].qiov, acb->qiov, acb->qcrs[i].buf);\n\n    }\n\n\n\n    for (i = 0; i < s->num_children; i++) {\n\n        bdrv_aio_readv(s->children[i]->bs, acb->sector_num, &acb->qcrs[i].qiov,\n\n                       acb->nb_sectors, quorum_aio_cb, &acb->qcrs[i]);\n\n    }\n\n\n\n    return &acb->common;\n\n}\n", "idx": 24802}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "petalogix_ml605_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    DeviceState *dev, *dma, *eth0;\n\n    Object *ds, *cs;\n\n    MicroBlazeCPU *cpu;\n\n    SysBusDevice *busdev;\n\n    DriveInfo *dinfo;\n\n    int i;\n\n    MemoryRegion *phys_lmb_bram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);\n\n    qemu_irq irq[32];\n\n\n\n    /* init CPUs */\n\n    cpu = MICROBLAZE_CPU(object_new(TYPE_MICROBLAZE_CPU));\n\n    /* Use FPU but don't use floating point conversion and square\n\n     * root instructions\n\n     */\n\n    object_property_set_int(OBJECT(cpu), 1, \"use-fpu\", &error_abort);\n\n    object_property_set_bool(OBJECT(cpu), true, \"dcache-writeback\",\n\n                             &error_abort);\n\n    object_property_set_bool(OBJECT(cpu), true, \"endianness\", &error_abort);\n\n    object_property_set_bool(OBJECT(cpu), true, \"realized\", &error_abort);\n\n\n\n    /* Attach emulated BRAM through the LMB.  */\n\n    memory_region_init_ram(phys_lmb_bram, NULL, \"petalogix_ml605.lmb_bram\",\n\n                           LMB_BRAM_SIZE, &error_abort);\n\n    vmstate_register_ram_global(phys_lmb_bram);\n\n    memory_region_add_subregion(address_space_mem, 0x00000000, phys_lmb_bram);\n\n\n\n    memory_region_init_ram(phys_ram, NULL, \"petalogix_ml605.ram\", ram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(phys_ram);\n\n    memory_region_add_subregion(address_space_mem, MEMORY_BASEADDR, phys_ram);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    /* 5th parameter 2 means bank-width\n\n     * 10th paremeter 0 means little-endian */\n\n    pflash_cfi01_register(FLASH_BASEADDR,\n\n                          NULL, \"petalogix_ml605.flash\", FLASH_SIZE,\n\n                          dinfo ? blk_by_legacy_dinfo(dinfo) : NULL,\n\n                          (64 * 1024), FLASH_SIZE >> 16,\n\n                          2, 0x89, 0x18, 0x0000, 0x0, 0);\n\n\n\n\n\n    dev = qdev_create(NULL, \"xlnx.xps-intc\");\n\n    qdev_prop_set_uint32(dev, \"kind-of-intr\", 1 << TIMER_IRQ);\n\n    qdev_init_nofail(dev);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, INTC_BASEADDR);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0,\n\n                       qdev_get_gpio_in(DEVICE(cpu), MB_CPU_IRQ));\n\n    for (i = 0; i < 32; i++) {\n\n        irq[i] = qdev_get_gpio_in(dev, i);\n\n    }\n\n\n\n    serial_mm_init(address_space_mem, UART16550_BASEADDR + 0x1000, 2,\n\n                   irq[UART16550_IRQ], 115200, serial_hds[0],\n\n                   DEVICE_LITTLE_ENDIAN);\n\n\n\n    /* 2 timers at irq 2 @ 100 Mhz.  */\n\n    dev = qdev_create(NULL, \"xlnx.xps-timer\");\n\n    qdev_prop_set_uint32(dev, \"one-timer-only\", 0);\n\n    qdev_prop_set_uint32(dev, \"clock-frequency\", 100 * 1000000);\n\n    qdev_init_nofail(dev);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, TIMER_BASEADDR);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, irq[TIMER_IRQ]);\n\n\n\n    /* axi ethernet and dma initialization. */\n\n    qemu_check_nic_model(&nd_table[0], \"xlnx.axi-ethernet\");\n\n    eth0 = qdev_create(NULL, \"xlnx.axi-ethernet\");\n\n    dma = qdev_create(NULL, \"xlnx.axi-dma\");\n\n\n\n    /* FIXME: attach to the sysbus instead */\n\n    object_property_add_child(qdev_get_machine(), \"xilinx-eth\", OBJECT(eth0),\n\n                              NULL);\n\n    object_property_add_child(qdev_get_machine(), \"xilinx-dma\", OBJECT(dma),\n\n                              NULL);\n\n\n\n    ds = object_property_get_link(OBJECT(dma),\n\n                                  \"axistream-connected-target\", NULL);\n\n    cs = object_property_get_link(OBJECT(dma),\n\n                                  \"axistream-control-connected-target\", NULL);\n\n    qdev_set_nic_properties(eth0, &nd_table[0]);\n\n    qdev_prop_set_uint32(eth0, \"rxmem\", 0x1000);\n\n    qdev_prop_set_uint32(eth0, \"txmem\", 0x1000);\n\n    object_property_set_link(OBJECT(eth0), OBJECT(ds),\n\n                             \"axistream-connected\", &error_abort);\n\n    object_property_set_link(OBJECT(eth0), OBJECT(cs),\n\n                             \"axistream-control-connected\", &error_abort);\n\n    qdev_init_nofail(eth0);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(eth0), 0, AXIENET_BASEADDR);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(eth0), 0, irq[AXIENET_IRQ]);\n\n\n\n    ds = object_property_get_link(OBJECT(eth0),\n\n                                  \"axistream-connected-target\", NULL);\n\n    cs = object_property_get_link(OBJECT(eth0),\n\n                                  \"axistream-control-connected-target\", NULL);\n\n    qdev_prop_set_uint32(dma, \"freqhz\", 100 * 1000000);\n\n    object_property_set_link(OBJECT(dma), OBJECT(ds),\n\n                             \"axistream-connected\", &error_abort);\n\n    object_property_set_link(OBJECT(dma), OBJECT(cs),\n\n                             \"axistream-control-connected\", &error_abort);\n\n    qdev_init_nofail(dma);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(dma), 0, AXIDMA_BASEADDR);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(dma), 0, irq[AXIDMA_IRQ0]);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(dma), 1, irq[AXIDMA_IRQ1]);\n\n\n\n    {\n\n        SSIBus *spi;\n\n\n\n        dev = qdev_create(NULL, \"xlnx.xps-spi\");\n\n        qdev_prop_set_uint8(dev, \"num-ss-bits\", NUM_SPI_FLASHES);\n\n        qdev_init_nofail(dev);\n\n        busdev = SYS_BUS_DEVICE(dev);\n\n        sysbus_mmio_map(busdev, 0, SPI_BASEADDR);\n\n        sysbus_connect_irq(busdev, 0, irq[SPI_IRQ]);\n\n\n\n        spi = (SSIBus *)qdev_get_child_bus(dev, \"spi\");\n\n\n\n        for (i = 0; i < NUM_SPI_FLASHES; i++) {\n\n            qemu_irq cs_line;\n\n\n\n            dev = ssi_create_slave(spi, \"n25q128\");\n\n            cs_line = qdev_get_gpio_in_named(dev, SSI_GPIO_CS, 0);\n\n            sysbus_connect_irq(busdev, i+1, cs_line);\n\n        }\n\n    }\n\n\n\n    /* setup PVR to match kernel settings */\n\n    cpu->env.pvr.regs[4] = 0xc56b8000;\n\n    cpu->env.pvr.regs[5] = 0xc56be000;\n\n    cpu->env.pvr.regs[10] = 0x0e000000; /* virtex 6 */\n\n\n\n    microblaze_load_kernel(cpu, MEMORY_BASEADDR, ram_size,\n\n                           machine->initrd_filename,\n\n                           BINARY_DEVICE_TREE_FILE,\n\n                           NULL);\n\n\n\n}\n", "idx": 24810}
{"project": "qemu", "commit_id": "257a7375582e4c3b32687c72d0f52279d28b2d85", "target": 1, "func": "static FILE *probe_splashfile(char *filename, int *file_sizep, int *file_typep)\n\n{\n\n    FILE *fp = NULL;\n\n    int fop_ret;\n\n    int file_size;\n\n    int file_type = -1;\n\n    unsigned char buf[2] = {0, 0};\n\n    unsigned int filehead_value = 0;\n\n    int bmp_bpp;\n\n\n\n    fp = fopen(filename, \"rb\");\n\n    if (fp == NULL) {\n\n        error_report(\"failed to open file '%s'.\", filename);\n\n\n\n    /* check file size */\n\n    fseek(fp, 0L, SEEK_END);\n\n    file_size = ftell(fp);\n\n    if (file_size < 2) {\n\n        error_report(\"file size is less than 2 bytes '%s'.\", filename);\n\n\n\n\n\n    /* check magic ID */\n\n    fseek(fp, 0L, SEEK_SET);\n\n    fop_ret = fread(buf, 1, 2, fp);\n\n\n\n\n\n\n\n\n    filehead_value = (buf[0] + (buf[1] << 8)) & 0xffff;\n\n    if (filehead_value == 0xd8ff) {\n\n        file_type = JPG_FILE;\n\n    } else {\n\n        if (filehead_value == 0x4d42) {\n\n            file_type = BMP_FILE;\n\n\n\n    if (file_type < 0) {\n\n        error_report(\"'%s' not jpg/bmp file,head:0x%x.\",\n\n                         filename, filehead_value);\n\n\n\n\n\n    /* check BMP bpp */\n\n    if (file_type == BMP_FILE) {\n\n        fseek(fp, 28, SEEK_SET);\n\n        fop_ret = fread(buf, 1, 2, fp);\n\n        bmp_bpp = (buf[0] + (buf[1] << 8)) & 0xffff;\n\n        if (bmp_bpp != 24) {\n\n            error_report(\"only 24bpp bmp file is supported.\");\n\n\n\n\n\n\n    /* return values */\n\n    *file_sizep = file_size;\n\n    *file_typep = file_type;\n\n", "idx": 24811}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "vmxnet3_read_next_rx_descr(VMXNET3State *s, int qidx, int ridx,\n\n                           struct Vmxnet3_RxDesc *dbuf, uint32_t *didx)\n\n{\n\n    Vmxnet3Ring *ring = &s->rxq_descr[qidx].rx_ring[ridx];\n\n    *didx = vmxnet3_ring_curr_cell_idx(ring);\n\n    vmxnet3_ring_read_curr_cell(ring, dbuf);\n\n}\n", "idx": 24812}
{"project": "qemu", "commit_id": "08942ac17922d923a7cc5cf9854e9cc4b150b942", "target": 1, "func": "int spapr_tce_dma_write(VIOsPAPRDevice *dev, uint64_t taddr, const void *buf,\n                        uint32_t size)\n{\n#ifdef DEBUG_TCE\n    fprintf(stderr, \"spapr_tce_dma_write taddr=0x%llx size=0x%x\\n\",\n            (unsigned long long)taddr, size);\n#endif\n    while (size) {\n        uint64_t tce;\n        uint32_t lsize;\n        uint64_t txaddr;\n        /* Check if we are in bound */\n        if (taddr >= dev->rtce_window_size) {\n#ifdef DEBUG_TCE\n            fprintf(stderr, \"spapr_tce_dma_write out of bounds\\n\");\n#endif\n            return H_DEST_PARM;\n        tce = dev->rtce_table[taddr >> SPAPR_VIO_TCE_PAGE_SHIFT].tce;\n        /* How much til end of page ? */\n        lsize = MIN(size, ((~taddr) & SPAPR_VIO_TCE_PAGE_MASK) + 1);\n        /* Check TCE */\n        if (!(tce & 2)) {\n            return H_DEST_PARM;\n        /* Translate */\n        txaddr = (tce & ~SPAPR_VIO_TCE_PAGE_MASK) |\n            (taddr & SPAPR_VIO_TCE_PAGE_MASK);\n#ifdef DEBUG_TCE\n        fprintf(stderr, \" -> write to txaddr=0x%llx, size=0x%x\\n\",\n                (unsigned long long)txaddr, lsize);\n#endif\n        /* Do it */\n        cpu_physical_memory_write(txaddr, buf, lsize);\n        buf += lsize;\n        taddr += lsize;\n        size -= lsize;", "idx": 24813}
{"project": "qemu", "commit_id": "2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3", "target": 1, "func": "static uint64_t boston_lcd_read(void *opaque, hwaddr addr,\n\n                                unsigned size)\n\n{\n\n    BostonState *s = opaque;\n\n    uint64_t val = 0;\n\n\n\n    switch (size) {\n\n    case 8:\n\n        val |= (uint64_t)s->lcd_content[(addr + 7) & 0x7] << 56;\n\n        val |= (uint64_t)s->lcd_content[(addr + 6) & 0x7] << 48;\n\n        val |= (uint64_t)s->lcd_content[(addr + 5) & 0x7] << 40;\n\n        val |= (uint64_t)s->lcd_content[(addr + 4) & 0x7] << 32;\n\n        /* fall through */\n\n    case 4:\n\n        val |= (uint64_t)s->lcd_content[(addr + 3) & 0x7] << 24;\n\n        val |= (uint64_t)s->lcd_content[(addr + 2) & 0x7] << 16;\n\n        /* fall through */\n\n    case 2:\n\n        val |= (uint64_t)s->lcd_content[(addr + 1) & 0x7] << 8;\n\n        /* fall through */\n\n    case 1:\n\n        val |= (uint64_t)s->lcd_content[(addr + 0) & 0x7];\n\n        break;\n\n    }\n\n\n\n    return val;\n\n}\n", "idx": 24817}
{"project": "qemu", "commit_id": "4118a97030aa9bd1d520d1d06bbe0655d829df04", "target": 1, "func": "static unsigned long copy_elf_strings(int argc,char ** argv, void **page,\n\n                                      unsigned long p)\n\n{\n\n    char *tmp, *tmp1, *pag = NULL;\n\n    int len, offset = 0;\n\n\n\n    if (!p) {\n\n\treturn 0;       /* bullet-proofing */\n\n    }\n\n    while (argc-- > 0) {\n\n        tmp = argv[argc];\n\n        if (!tmp) {\n\n\t    fprintf(stderr, \"VFS: argc is wrong\");\n\n\t    exit(-1);\n\n\t}\n\n        tmp1 = tmp;\n\n\twhile (*tmp++);\n\n\tlen = tmp - tmp1;\n\n\tif (p < len) {  /* this shouldn't happen - 128kB */\n\n\t\treturn 0;\n\n\t}\n\n\twhile (len) {\n\n\t    --p; --tmp; --len;\n\n\t    if (--offset < 0) {\n\n\t\toffset = p % TARGET_PAGE_SIZE;\n\n                pag = (char *)page[p/TARGET_PAGE_SIZE];\n\n                if (!pag) {\n\n                    pag = (char *)malloc(TARGET_PAGE_SIZE);\n\n                    page[p/TARGET_PAGE_SIZE] = pag;\n\n                    if (!pag)\n\n                        return 0;\n\n\t\t}\n\n\t    }\n\n\t    if (len == 0 || offset == 0) {\n\n\t        *(pag + offset) = *tmp;\n\n\t    }\n\n\t    else {\n\n\t      int bytes_to_copy = (len > offset) ? offset : len;\n\n\t      tmp -= bytes_to_copy;\n\n\t      p -= bytes_to_copy;\n\n\t      offset -= bytes_to_copy;\n\n\t      len -= bytes_to_copy;\n\n\t      memcpy_fromfs(pag + offset, tmp, bytes_to_copy + 1);\n\n\t    }\n\n\t}\n\n    }\n\n    return p;\n\n}\n", "idx": 24821}
{"project": "qemu", "commit_id": "06065c451f10c7ef62cfb575a87f323a70ae1c9e", "target": 1, "func": "void fork_end(int child)\n\n{\n\n    mmap_fork_end(child);\n\n    if (child) {\n\n        CPUState *cpu, *next_cpu;\n\n        /* Child processes created by fork() only have a single thread.\n\n           Discard information about the parent threads.  */\n\n        CPU_FOREACH_SAFE(cpu, next_cpu) {\n\n            if (cpu != thread_cpu) {\n\n                QTAILQ_REMOVE(&cpus, cpu, node);\n\n            }\n\n        }\n\n        qemu_mutex_init(&tb_ctx.tb_lock);\n\n        qemu_init_cpu_list();\n\n        gdbserver_fork(thread_cpu);\n\n\n\n\n    } else {\n\n        qemu_mutex_unlock(&tb_ctx.tb_lock);\n\n        cpu_list_unlock();\n\n\n    }\n\n}", "idx": 24822}
{"project": "qemu", "commit_id": "a3f409cb4a35d9aa6a4d24a7a1e05423e189cb7a", "target": 1, "func": "static void vtd_init(IntelIOMMUState *s)\n\n{\n\n    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(s);\n\n\n\n    memset(s->csr, 0, DMAR_REG_SIZE);\n\n    memset(s->wmask, 0, DMAR_REG_SIZE);\n\n    memset(s->w1cmask, 0, DMAR_REG_SIZE);\n\n    memset(s->womask, 0, DMAR_REG_SIZE);\n\n\n\n    s->iommu_ops.translate = vtd_iommu_translate;\n\n    s->iommu_ops.notify_started = vtd_iommu_notify_started;\n\n    s->root = 0;\n\n    s->root_extended = false;\n\n    s->dmar_enabled = false;\n\n    s->iq_head = 0;\n\n    s->iq_tail = 0;\n\n    s->iq = 0;\n\n    s->iq_size = 0;\n\n    s->qi_enabled = false;\n\n    s->iq_last_desc_type = VTD_INV_DESC_NONE;\n\n    s->next_frcd_reg = 0;\n\n    s->cap = VTD_CAP_FRO | VTD_CAP_NFR | VTD_CAP_ND | VTD_CAP_MGAW |\n\n             VTD_CAP_SAGAW | VTD_CAP_MAMV | VTD_CAP_PSI | VTD_CAP_SLLPS;\n\n    s->ecap = VTD_ECAP_QI | VTD_ECAP_IRO;\n\n\n\n    if (x86_iommu->intr_supported) {\n\n        s->ecap |= VTD_ECAP_IR | VTD_ECAP_EIM;\n\n    }\n\n\n\n    vtd_reset_context_cache(s);\n\n    vtd_reset_iotlb(s);\n\n\n\n    /* Define registers with default values and bit semantics */\n\n    vtd_define_long(s, DMAR_VER_REG, 0x10UL, 0, 0);\n\n    vtd_define_quad(s, DMAR_CAP_REG, s->cap, 0, 0);\n\n    vtd_define_quad(s, DMAR_ECAP_REG, s->ecap, 0, 0);\n\n    vtd_define_long(s, DMAR_GCMD_REG, 0, 0xff800000UL, 0);\n\n    vtd_define_long_wo(s, DMAR_GCMD_REG, 0xff800000UL);\n\n    vtd_define_long(s, DMAR_GSTS_REG, 0, 0, 0);\n\n    vtd_define_quad(s, DMAR_RTADDR_REG, 0, 0xfffffffffffff000ULL, 0);\n\n    vtd_define_quad(s, DMAR_CCMD_REG, 0, 0xe0000003ffffffffULL, 0);\n\n    vtd_define_quad_wo(s, DMAR_CCMD_REG, 0x3ffff0000ULL);\n\n\n\n    /* Advanced Fault Logging not supported */\n\n    vtd_define_long(s, DMAR_FSTS_REG, 0, 0, 0x11UL);\n\n    vtd_define_long(s, DMAR_FECTL_REG, 0x80000000UL, 0x80000000UL, 0);\n\n    vtd_define_long(s, DMAR_FEDATA_REG, 0, 0x0000ffffUL, 0);\n\n    vtd_define_long(s, DMAR_FEADDR_REG, 0, 0xfffffffcUL, 0);\n\n\n\n    /* Treated as RsvdZ when EIM in ECAP_REG is not supported\n\n     * vtd_define_long(s, DMAR_FEUADDR_REG, 0, 0xffffffffUL, 0);\n\n     */\n\n    vtd_define_long(s, DMAR_FEUADDR_REG, 0, 0, 0);\n\n\n\n    /* Treated as RO for implementations that PLMR and PHMR fields reported\n\n     * as Clear in the CAP_REG.\n\n     * vtd_define_long(s, DMAR_PMEN_REG, 0, 0x80000000UL, 0);\n\n     */\n\n    vtd_define_long(s, DMAR_PMEN_REG, 0, 0, 0);\n\n\n\n    vtd_define_quad(s, DMAR_IQH_REG, 0, 0, 0);\n\n    vtd_define_quad(s, DMAR_IQT_REG, 0, 0x7fff0ULL, 0);\n\n    vtd_define_quad(s, DMAR_IQA_REG, 0, 0xfffffffffffff007ULL, 0);\n\n    vtd_define_long(s, DMAR_ICS_REG, 0, 0, 0x1UL);\n\n    vtd_define_long(s, DMAR_IECTL_REG, 0x80000000UL, 0x80000000UL, 0);\n\n    vtd_define_long(s, DMAR_IEDATA_REG, 0, 0xffffffffUL, 0);\n\n    vtd_define_long(s, DMAR_IEADDR_REG, 0, 0xfffffffcUL, 0);\n\n    /* Treadted as RsvdZ when EIM in ECAP_REG is not supported */\n\n    vtd_define_long(s, DMAR_IEUADDR_REG, 0, 0, 0);\n\n\n\n    /* IOTLB registers */\n\n    vtd_define_quad(s, DMAR_IOTLB_REG, 0, 0Xb003ffff00000000ULL, 0);\n\n    vtd_define_quad(s, DMAR_IVA_REG, 0, 0xfffffffffffff07fULL, 0);\n\n    vtd_define_quad_wo(s, DMAR_IVA_REG, 0xfffffffffffff07fULL);\n\n\n\n    /* Fault Recording Registers, 128-bit */\n\n    vtd_define_quad(s, DMAR_FRCD_REG_0_0, 0, 0, 0);\n\n    vtd_define_quad(s, DMAR_FRCD_REG_0_2, 0, 0, 0x8000000000000000ULL);\n\n\n\n    /*\n\n     * Interrupt remapping registers.\n\n     */\n\n    vtd_define_quad(s, DMAR_IRTA_REG, 0, 0xfffffffffffff80fULL, 0);\n\n}\n", "idx": 24824}
{"project": "qemu", "commit_id": "d07bde88a52bf293c3f8846cfd162e0a57e1557c", "target": 1, "func": "static TranslationBlock *tb_find_slow(target_ulong pc,\n\n                                      target_ulong cs_base,\n\n                                      uint64_t flags)\n\n{\n\n    TranslationBlock *tb, **ptb1;\n\n    int code_gen_size;\n\n    unsigned int h;\n\n    target_ulong phys_pc, phys_page1, phys_page2, virt_page2;\n\n    uint8_t *tc_ptr;\n\n\n\n    spin_lock(&tb_lock);\n\n\n\n    tb_invalidated_flag = 0;\n\n\n\n    regs_to_env(); /* XXX: do it just before cpu_gen_code() */\n\n\n\n    /* find translated block using physical mappings */\n\n    phys_pc = get_phys_addr_code(env, pc);\n\n    phys_page1 = phys_pc & TARGET_PAGE_MASK;\n\n    phys_page2 = -1;\n\n    h = tb_phys_hash_func(phys_pc);\n\n    ptb1 = &tb_phys_hash[h];\n\n    for(;;) {\n\n        tb = *ptb1;\n\n        if (!tb)\n\n            goto not_found;\n\n        if (tb->pc == pc &&\n\n            tb->page_addr[0] == phys_page1 &&\n\n            tb->cs_base == cs_base &&\n\n            tb->flags == flags) {\n\n            /* check next page if needed */\n\n            if (tb->page_addr[1] != -1) {\n\n                virt_page2 = (pc & TARGET_PAGE_MASK) +\n\n                    TARGET_PAGE_SIZE;\n\n                phys_page2 = get_phys_addr_code(env, virt_page2);\n\n                if (tb->page_addr[1] == phys_page2)\n\n                    goto found;\n\n            } else {\n\n                goto found;\n\n            }\n\n        }\n\n        ptb1 = &tb->phys_hash_next;\n\n    }\n\n not_found:\n\n    /* if no translated code available, then translate it now */\n\n    tb = tb_alloc(pc);\n\n    if (!tb) {\n\n        /* flush must be done */\n\n        tb_flush(env);\n\n        /* cannot fail at this point */\n\n        tb = tb_alloc(pc);\n\n        /* don't forget to invalidate previous TB info */\n\n        tb_invalidated_flag = 1;\n\n    }\n\n    tc_ptr = code_gen_ptr;\n\n    tb->tc_ptr = tc_ptr;\n\n    tb->cs_base = cs_base;\n\n    tb->flags = flags;\n\n    cpu_gen_code(env, tb, CODE_GEN_MAX_SIZE, &code_gen_size);\n\n    code_gen_ptr = (void *)(((unsigned long)code_gen_ptr + code_gen_size + CODE_GEN_ALIGN - 1) & ~(CODE_GEN_ALIGN - 1));\n\n\n\n    /* check next page if needed */\n\n    virt_page2 = (pc + tb->size - 1) & TARGET_PAGE_MASK;\n\n    phys_page2 = -1;\n\n    if ((pc & TARGET_PAGE_MASK) != virt_page2) {\n\n        phys_page2 = get_phys_addr_code(env, virt_page2);\n\n    }\n\n    tb_link_phys(tb, phys_pc, phys_page2);\n\n\n\n found:\n\n    /* we add the TB in the virtual pc hash table */\n\n    env->tb_jmp_cache[tb_jmp_cache_hash_func(pc)] = tb;\n\n    spin_unlock(&tb_lock);\n\n    return tb;\n\n}\n", "idx": 24825}
{"project": "qemu", "commit_id": "5bf81c8d63db0216a4d29dc87f9ce530bb791dd1", "target": 1, "func": "void vmstate_save_state(QEMUFile *f, const VMStateDescription *vmsd,\n\n                        void *opaque)\n\n{\n\n    VMStateField *field = vmsd->fields;\n\n\n\n    if (vmsd->pre_save) {\n\n        vmsd->pre_save(opaque);\n\n\n    while (field->name) {\n\n        if (!field->field_exists ||\n\n            field->field_exists(opaque, vmsd->version_id)) {\n\n            void *base_addr = vmstate_base_addr(opaque, field);\n\n            int i, n_elems = vmstate_n_elems(opaque, field);\n\n            int size = vmstate_size(opaque, field);\n\n\n\n            for (i = 0; i < n_elems; i++) {\n\n                void *addr = base_addr + size * i;\n\n\n\n                if (field->flags & VMS_ARRAY_OF_POINTER) {\n\n                    addr = *(void **)addr;\n\n\n                if (field->flags & VMS_STRUCT) {\n\n                    vmstate_save_state(f, field->vmsd, addr);\n\n\n                    field->info->put(f, addr, size);\n\n\n\n\n\n\n\n\n\n\n        field++;\n\n\n    vmstate_subsection_save(f, vmsd, opaque);\n", "idx": 24830}
{"project": "qemu", "commit_id": "b027a538c6790bcfc93ef7f4819fe3e581445959", "target": 1, "func": "static int oss_poll_in (HWVoiceIn *hw)\n\n{\n\n    OSSVoiceIn *oss = (OSSVoiceIn *) hw;\n\n\n\n    return qemu_set_fd_handler (oss->fd, oss_helper_poll_in, NULL, NULL);\n\n}\n", "idx": 24831}
{"project": "qemu", "commit_id": "f9a8b5530d438f836f9697639814f585aaec554d", "target": 1, "func": "void qdev_prop_register_global(GlobalProperty *prop)\n\n{\n\n    QTAILQ_INSERT_TAIL(&global_props, prop, next);\n\n}\n", "idx": 24833}
{"project": "qemu", "commit_id": "91bea4e2bb1a5f7954a3b3a4f2e28e96bd25c458", "target": 1, "func": "iscsi_aio_readv(BlockDriverState *bs, int64_t sector_num,\n                QEMUIOVector *qiov, int nb_sectors,\n                BlockDriverCompletionFunc *cb,\n                void *opaque)\n{\n    IscsiLun *iscsilun = bs->opaque;\n    IscsiAIOCB *acb;\n    acb = qemu_aio_get(&iscsi_aiocb_info, bs, cb, opaque);\n    trace_iscsi_aio_readv(iscsilun->iscsi, sector_num, nb_sectors, opaque, acb);\n    acb->nb_sectors  = nb_sectors;\n    acb->sector_num  = sector_num;\n    acb->iscsilun    = iscsilun;\n    acb->qiov        = qiov;\n    acb->retries     = ISCSI_CMD_RETRIES;\n    if (iscsi_aio_readv_acb(acb) != 0) {\n        qemu_aio_release(acb);\n    iscsi_set_events(iscsilun);\n    return &acb->common;", "idx": 24835}
{"project": "qemu", "commit_id": "8a0f9b5263bb3a96d574ca78ad3b8f1d7bf8b12b", "target": 1, "func": "static GSList *gd_vc_gfx_init(GtkDisplayState *s, VirtualConsole *vc,\n\n                              QemuConsole *con, int idx,\n\n                              GSList *group, GtkWidget *view_menu)\n\n{\n\n    Error *local_err = NULL;\n\n    Object *obj;\n\n\n\n    obj = object_property_get_link(OBJECT(con), \"device\", &local_err);\n\n    if (obj) {\n\n        vc->label = g_strdup_printf(\"%s\", object_get_typename(obj));\n\n    } else {\n\n        vc->label = g_strdup_printf(\"VGA\");\n\n    }\n\n\n\n    vc->s = s;\n\n    vc->gfx.scale_x = 1.0;\n\n    vc->gfx.scale_y = 1.0;\n\n\n\n    vc->gfx.drawing_area = gtk_drawing_area_new();\n\n    gtk_widget_add_events(vc->gfx.drawing_area,\n\n                          GDK_POINTER_MOTION_MASK |\n\n                          GDK_BUTTON_PRESS_MASK |\n\n                          GDK_BUTTON_RELEASE_MASK |\n\n                          GDK_BUTTON_MOTION_MASK |\n\n                          GDK_ENTER_NOTIFY_MASK |\n\n                          GDK_LEAVE_NOTIFY_MASK |\n\n                          GDK_SCROLL_MASK |\n\n                          GDK_KEY_PRESS_MASK);\n\n    gtk_widget_set_can_focus(vc->gfx.drawing_area, TRUE);\n\n\n\n    vc->type = GD_VC_GFX;\n\n    vc->tab_item = vc->gfx.drawing_area;\n\n    gtk_notebook_append_page(GTK_NOTEBOOK(s->notebook),\n\n                             vc->tab_item, gtk_label_new(vc->label));\n\n    gd_connect_vc_gfx_signals(vc);\n\n\n\n    group = gd_vc_menu_init(s, vc, idx, group, view_menu);\n\n\n\n    vc->gfx.dcl.ops = &dcl_ops;\n\n    vc->gfx.dcl.con = con;\n\n    register_displaychangelistener(&vc->gfx.dcl);\n\n\n\n    return group;\n\n}\n", "idx": 24836}
{"project": "qemu", "commit_id": "d3c64d6a1874f94246af91963927fb4d924332f1", "target": 1, "func": "static void x86_cpu_apic_init(X86CPU *cpu, Error **errp)\n\n{\n\n    static int apic_mapped;\n\n    CPUX86State *env = &cpu->env;\n\n    APICCommonState *apic;\n\n    const char *apic_type = \"apic\";\n\n\n\n    if (kvm_irqchip_in_kernel()) {\n\n        apic_type = \"kvm-apic\";\n\n    } else if (xen_enabled()) {\n\n        apic_type = \"xen-apic\";\n\n    }\n\n\n\n    env->apic_state = qdev_try_create(NULL, apic_type);\n\n    if (env->apic_state == NULL) {\n\n        error_setg(errp, \"APIC device '%s' could not be created\", apic_type);\n\n        return;\n\n    }\n\n\n\n    object_property_add_child(OBJECT(cpu), \"apic\",\n\n                              OBJECT(env->apic_state), NULL);\n\n    qdev_prop_set_uint8(env->apic_state, \"id\", env->cpuid_apic_id);\n\n    /* TODO: convert to link<> */\n\n    apic = APIC_COMMON(env->apic_state);\n\n    apic->cpu = cpu;\n\n\n\n    if (qdev_init(env->apic_state)) {\n\n        error_setg(errp, \"APIC device '%s' could not be initialized\",\n\n                   object_get_typename(OBJECT(env->apic_state)));\n\n        return;\n\n    }\n\n\n\n    /* XXX: mapping more APICs at the same memory location */\n\n    if (apic_mapped == 0) {\n\n        /* NOTE: the APIC is directly connected to the CPU - it is not\n\n           on the global memory bus. */\n\n        /* XXX: what if the base changes? */\n\n        sysbus_mmio_map_overlap(SYS_BUS_DEVICE(env->apic_state), 0,\n\n                                APIC_DEFAULT_ADDRESS, 0x1000);\n\n        apic_mapped = 1;\n\n    }\n\n}\n", "idx": 24838}
{"project": "qemu", "commit_id": "ffa48cf5ab719e1e181e51b87bc0f5d397b791fa", "target": 0, "func": "void audio_init(ISABus *isa_bus, PCIBus *pci_bus)\n\n{\n\n}\n", "idx": 24840}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static void nand_command(NANDFlashState *s)\n\n{\n\n    unsigned int offset;\n\n    switch (s->cmd) {\n\n    case NAND_CMD_READ0:\n\n        s->iolen = 0;\n\n        break;\n\n\n\n    case NAND_CMD_READID:\n\n        s->ioaddr = s->io;\n\n        s->iolen = 0;\n\n        nand_pushio_byte(s, s->manf_id);\n\n        nand_pushio_byte(s, s->chip_id);\n\n        nand_pushio_byte(s, 'Q'); /* Don't-care byte (often 0xa5) */\n\n        if (nand_flash_ids[s->chip_id].options & NAND_SAMSUNG_LP) {\n\n            /* Page Size, Block Size, Spare Size; bit 6 indicates\n\n             * 8 vs 16 bit width NAND.\n\n             */\n\n            nand_pushio_byte(s, (s->buswidth == 2) ? 0x55 : 0x15);\n\n        } else {\n\n            nand_pushio_byte(s, 0xc0); /* Multi-plane */\n\n        }\n\n        break;\n\n\n\n    case NAND_CMD_RANDOMREAD2:\n\n    case NAND_CMD_NOSERIALREAD2:\n\n        if (!(nand_flash_ids[s->chip_id].options & NAND_SAMSUNG_LP))\n\n            break;\n\n        offset = s->addr & ((1 << s->addr_shift) - 1);\n\n        s->blk_load(s, s->addr, offset);\n\n        if (s->gnd)\n\n            s->iolen = (1 << s->page_shift) - offset;\n\n        else\n\n            s->iolen = (1 << s->page_shift) + (1 << s->oob_shift) - offset;\n\n        break;\n\n\n\n    case NAND_CMD_RESET:\n\n        nand_reset(DEVICE(s));\n\n        break;\n\n\n\n    case NAND_CMD_PAGEPROGRAM1:\n\n        s->ioaddr = s->io;\n\n        s->iolen = 0;\n\n        break;\n\n\n\n    case NAND_CMD_PAGEPROGRAM2:\n\n        if (s->wp) {\n\n            s->blk_write(s);\n\n        }\n\n        break;\n\n\n\n    case NAND_CMD_BLOCKERASE1:\n\n        break;\n\n\n\n    case NAND_CMD_BLOCKERASE2:\n\n        s->addr &= (1ull << s->addrlen * 8) - 1;\n\n        s->addr <<= nand_flash_ids[s->chip_id].options & NAND_SAMSUNG_LP ?\n\n                                                                    16 : 8;\n\n\n\n        if (s->wp) {\n\n            s->blk_erase(s);\n\n        }\n\n        break;\n\n\n\n    case NAND_CMD_READSTATUS:\n\n        s->ioaddr = s->io;\n\n        s->iolen = 0;\n\n        nand_pushio_byte(s, s->status);\n\n        break;\n\n\n\n    default:\n\n        printf(\"%s: Unknown NAND command 0x%02x\\n\", __FUNCTION__, s->cmd);\n\n    }\n\n}\n", "idx": 24841}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static int v9fs_synth_closedir(FsContext *ctx, V9fsFidOpenState *fs)\n\n{\n\n    V9fsSynthOpenState *synth_open = fs->private;\n\n    V9fsSynthNode *node = synth_open->node;\n\n\n\n    node->open_count--;\n\n    g_free(synth_open);\n\n    fs->private = NULL;\n\n    return 0;\n\n}\n", "idx": 24842}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "int64_t qemu_clock_deadline_ns_all(QEMUClockType type)\n\n{\n\n    int64_t deadline = -1;\n\n    QEMUTimerList *timer_list;\n\n    QEMUClock *clock = qemu_clock_ptr(type);\n\n    QLIST_FOREACH(timer_list, &clock->timerlists, list) {\n\n        deadline = qemu_soonest_timeout(deadline,\n\n                                        timerlist_deadline_ns(timer_list));\n\n    }\n\n    return deadline;\n\n}\n", "idx": 24843}
{"project": "qemu", "commit_id": "ddf21908961073199f3d186204da4810f2ea150b", "target": 0, "func": "UserDefTwo *qmp_user_def_cmd2(UserDefOne *ud1a,\n\n                              bool has_udb1, UserDefOne *ud1b,\n\n                              Error **errp)\n\n{\n\n    UserDefTwo *ret;\n\n    UserDefOne *ud1c = g_malloc0(sizeof(UserDefOne));\n\n    UserDefOne *ud1d = g_malloc0(sizeof(UserDefOne));\n\n\n\n    ud1c->string = strdup(ud1a->string);\n\n    ud1c->base = g_new0(UserDefZero, 1);\n\n    ud1c->base->integer = ud1a->base->integer;\n\n    ud1d->string = strdup(has_udb1 ? ud1b->string : \"blah0\");\n\n    ud1d->base = g_new0(UserDefZero, 1);\n\n    ud1d->base->integer = has_udb1 ? ud1b->base->integer : 0;\n\n\n\n    ret = g_new0(UserDefTwo, 1);\n\n    ret->string0 = strdup(\"blah1\");\n\n    ret->dict1 = g_new0(UserDefTwoDict, 1);\n\n    ret->dict1->string1 = strdup(\"blah2\");\n\n    ret->dict1->dict2 = g_new0(UserDefTwoDictDict, 1);\n\n    ret->dict1->dict2->userdef = ud1c;\n\n    ret->dict1->dict2->string = strdup(\"blah3\");\n\n    ret->dict1->dict3 = g_new0(UserDefTwoDictDict, 1);\n\n    ret->dict1->has_dict3 = true;\n\n    ret->dict1->dict3->userdef = ud1d;\n\n    ret->dict1->dict3->string = strdup(\"blah4\");\n\n\n\n    return ret;\n\n}\n", "idx": 24844}
{"project": "qemu", "commit_id": "8d5c773e323b22402abdd0beef4c7d2fc91dd0eb", "target": 0, "func": "static void vmsa_ttbcr_raw_write(CPUARMState *env, const ARMCPRegInfo *ri,\n\n                                 uint64_t value)\n\n{\n\n    int maskshift = extract32(value, 0, 3);\n\n\n\n    if (arm_feature(env, ARM_FEATURE_LPAE) && (value & (1 << 31))) {\n\n        value &= ~((7 << 19) | (3 << 14) | (0xf << 3));\n\n    } else {\n\n        value &= 7;\n\n    }\n\n    /* Note that we always calculate c2_mask and c2_base_mask, but\n\n     * they are only used for short-descriptor tables (ie if EAE is 0);\n\n     * for long-descriptor tables the TTBCR fields are used differently\n\n     * and the c2_mask and c2_base_mask values are meaningless.\n\n     */\n\n    env->cp15.c2_control = value;\n\n    env->cp15.c2_mask = ~(((uint32_t)0xffffffffu) >> maskshift);\n\n    env->cp15.c2_base_mask = ~((uint32_t)0x3fffu >> maskshift);\n\n}\n", "idx": 24845}
{"project": "qemu", "commit_id": "1945dbc15f0f1ffdc9a10526448e9eba7c599d98", "target": 0, "func": "static uint32_t openpic_cpu_read_internal(void *opaque, hwaddr addr,\n\n                                          int idx)\n\n{\n\n    openpic_t *opp = opaque;\n\n    IRQ_src_t *src;\n\n    IRQ_dst_t *dst;\n\n    uint32_t retval;\n\n    int n_IRQ;\n\n\n\n    DPRINTF(\"%s: cpu %d addr \" TARGET_FMT_plx \"\\n\", __func__, idx, addr);\n\n    retval = 0xFFFFFFFF;\n\n    if (addr & 0xF)\n\n        return retval;\n\n    dst = &opp->dst[idx];\n\n    addr &= 0xFF0;\n\n    switch (addr) {\n\n    case 0x00: /* Block Revision Register1 (BRR1) */\n\n        retval = FSL_BRR1_IPID | FSL_BRR1_IPMJ | FSL_BRR1_IPMN;\n\n        break;\n\n    case 0x80: /* PCTP */\n\n        retval = dst->pctp;\n\n        break;\n\n    case 0x90: /* WHOAMI */\n\n        retval = idx;\n\n        break;\n\n    case 0xA0: /* PIAC */\n\n        DPRINTF(\"Lower OpenPIC INT output\\n\");\n\n        qemu_irq_lower(dst->irqs[OPENPIC_OUTPUT_INT]);\n\n        n_IRQ = IRQ_get_next(opp, &dst->raised);\n\n        DPRINTF(\"PIAC: irq=%d\\n\", n_IRQ);\n\n        if (n_IRQ == -1) {\n\n            /* No more interrupt pending */\n\n            retval = IPVP_VECTOR(opp->spve);\n\n        } else {\n\n            src = &opp->src[n_IRQ];\n\n            if (!test_bit(&src->ipvp, IPVP_ACTIVITY) ||\n\n                !(IPVP_PRIORITY(src->ipvp) > dst->pctp)) {\n\n                /* - Spurious level-sensitive IRQ\n\n                 * - Priorities has been changed\n\n                 *   and the pending IRQ isn't allowed anymore\n\n                 */\n\n                reset_bit(&src->ipvp, IPVP_ACTIVITY);\n\n                retval = IPVP_VECTOR(opp->spve);\n\n            } else {\n\n                /* IRQ enter servicing state */\n\n                IRQ_setbit(&dst->servicing, n_IRQ);\n\n                retval = IPVP_VECTOR(src->ipvp);\n\n            }\n\n            IRQ_resetbit(&dst->raised, n_IRQ);\n\n            dst->raised.next = -1;\n\n            if (!test_bit(&src->ipvp, IPVP_SENSE)) {\n\n                /* edge-sensitive IRQ */\n\n                reset_bit(&src->ipvp, IPVP_ACTIVITY);\n\n                src->pending = 0;\n\n            }\n\n\n\n            if ((n_IRQ >= opp->irq_ipi0) &&  (n_IRQ < (opp->irq_ipi0 + MAX_IPI))) {\n\n                src->ide &= ~(1 << idx);\n\n                if (src->ide && !test_bit(&src->ipvp, IPVP_SENSE)) {\n\n                    /* trigger on CPUs that didn't know about it yet */\n\n                    openpic_set_irq(opp, n_IRQ, 1);\n\n                    openpic_set_irq(opp, n_IRQ, 0);\n\n                    /* if all CPUs knew about it, set active bit again */\n\n                    set_bit(&src->ipvp, IPVP_ACTIVITY);\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    case 0xB0: /* PEOI */\n\n        retval = 0;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n    DPRINTF(\"%s: => %08x\\n\", __func__, retval);\n\n\n\n    return retval;\n\n}\n", "idx": 24846}
{"project": "qemu", "commit_id": "736d120af4bf5f3e13b2f90c464b3a24847f78f0", "target": 0, "func": "void helper_ctc1(CPUMIPSState *env, target_ulong arg1, uint32_t reg)\n\n{\n\n    switch(reg) {\n\n    case 25:\n\n        if (arg1 & 0xffffff00)\n\n            return;\n\n        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0x017fffff) | ((arg1 & 0xfe) << 24) |\n\n                     ((arg1 & 0x1) << 23);\n\n        break;\n\n    case 26:\n\n        if (arg1 & 0x007c0000)\n\n            return;\n\n        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0xfffc0f83) | (arg1 & 0x0003f07c);\n\n        break;\n\n    case 28:\n\n        if (arg1 & 0x007c0000)\n\n            return;\n\n        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0xfefff07c) | (arg1 & 0x00000f83) |\n\n                     ((arg1 & 0x4) << 22);\n\n        break;\n\n    case 31:\n\n        if (arg1 & 0x007c0000)\n\n            return;\n\n        env->active_fpu.fcr31 = arg1;\n\n        break;\n\n    default:\n\n        return;\n\n    }\n\n    /* set rounding mode */\n\n    restore_rounding_mode(env);\n\n    /* set flush-to-zero mode */\n\n    restore_flush_mode(env);\n\n    set_float_exception_flags(0, &env->active_fpu.fp_status);\n\n    if ((GET_FP_ENABLE(env->active_fpu.fcr31) | 0x20) & GET_FP_CAUSE(env->active_fpu.fcr31))\n\n        do_raise_exception(env, EXCP_FPE, GETPC());\n\n}\n", "idx": 24847}
{"project": "qemu", "commit_id": "8df1426e44176512be1b6456e90d100d1af907e1", "target": 0, "func": "void pc_dimm_memory_plug(DeviceState *dev, MemoryHotplugState *hpms,\n\n                         MemoryRegion *mr, uint64_t align, Error **errp)\n\n{\n\n    int slot;\n\n    MachineState *machine = MACHINE(qdev_get_machine());\n\n    PCDIMMDevice *dimm = PC_DIMM(dev);\n\n    Error *local_err = NULL;\n\n    uint64_t existing_dimms_capacity = 0;\n\n    uint64_t addr;\n\n\n\n    addr = object_property_get_int(OBJECT(dimm), PC_DIMM_ADDR_PROP, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n\n\n    addr = pc_dimm_get_free_addr(hpms->base,\n\n                                 memory_region_size(&hpms->mr),\n\n                                 !addr ? NULL : &addr, align,\n\n                                 memory_region_size(mr), &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n\n\n    existing_dimms_capacity = pc_existing_dimms_capacity(&local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n\n\n    if (existing_dimms_capacity + memory_region_size(mr) >\n\n        machine->maxram_size - machine->ram_size) {\n\n        error_setg(&local_err, \"not enough space, currently 0x%\" PRIx64\n\n                   \" in use of total hot pluggable 0x\" RAM_ADDR_FMT,\n\n                   existing_dimms_capacity,\n\n                   machine->maxram_size - machine->ram_size);\n\n        goto out;\n\n    }\n\n\n\n    object_property_set_int(OBJECT(dev), addr, PC_DIMM_ADDR_PROP, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n    trace_mhp_pc_dimm_assigned_address(addr);\n\n\n\n    slot = object_property_get_int(OBJECT(dev), PC_DIMM_SLOT_PROP, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n\n\n    slot = pc_dimm_get_free_slot(slot == PC_DIMM_UNASSIGNED_SLOT ? NULL : &slot,\n\n                                 machine->ram_slots, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n    object_property_set_int(OBJECT(dev), slot, PC_DIMM_SLOT_PROP, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n    trace_mhp_pc_dimm_assigned_slot(slot);\n\n\n\n    if (kvm_enabled() && !kvm_has_free_slot(machine)) {\n\n        error_setg(&local_err, \"hypervisor has no free memory slots left\");\n\n        goto out;\n\n    }\n\n\n\n    if (!vhost_has_free_slot()) {\n\n        error_setg(&local_err, \"a used vhost backend has no free\"\n\n                               \" memory slots left\");\n\n        goto out;\n\n    }\n\n\n\n    memory_region_add_subregion(&hpms->mr, addr - hpms->base, mr);\n\n    vmstate_register_ram(mr, dev);\n\n    numa_set_mem_node_id(addr, memory_region_size(mr), dimm->node);\n\n\n\nout:\n\n    error_propagate(errp, local_err);\n\n}\n", "idx": 24849}
{"project": "qemu", "commit_id": "b75a02829dde98723dfe16fa098338cb267b28b9", "target": 0, "func": "static BOOL WINAPI qemu_ctrl_handler(DWORD type)\n\n{\n\n    exit(STATUS_CONTROL_C_EXIT);\n\n    return TRUE;\n\n}\n", "idx": 24850}
{"project": "qemu", "commit_id": "a178274efabcbbc5d44805b51def874e47051325", "target": 0, "func": "static int spapr_phb_init(SysBusDevice *s)\n\n{\n\n    sPAPRPHBState *sphb = SPAPR_PCI_HOST_BRIDGE(s);\n\n    PCIHostState *phb = PCI_HOST_BRIDGE(s);\n\n    char *namebuf;\n\n    int i;\n\n    PCIBus *bus;\n\n\n\n    sphb->dtbusname = g_strdup_printf(\"pci@%\" PRIx64, sphb->buid);\n\n    namebuf = alloca(strlen(sphb->dtbusname) + 32);\n\n\n\n    /* Initialize memory regions */\n\n    sprintf(namebuf, \"%s.mmio\", sphb->dtbusname);\n\n    memory_region_init(&sphb->memspace, namebuf, INT64_MAX);\n\n\n\n    sprintf(namebuf, \"%s.mmio-alias\", sphb->dtbusname);\n\n    memory_region_init_alias(&sphb->memwindow, namebuf, &sphb->memspace,\n\n                             SPAPR_PCI_MEM_WIN_BUS_OFFSET, sphb->mem_win_size);\n\n    memory_region_add_subregion(get_system_memory(), sphb->mem_win_addr,\n\n                                &sphb->memwindow);\n\n\n\n    /* On ppc, we only have MMIO no specific IO space from the CPU\n\n     * perspective.  In theory we ought to be able to embed the PCI IO\n\n     * memory region direction in the system memory space.  However,\n\n     * if any of the IO BAR subregions use the old_portio mechanism,\n\n     * that won't be processed properly unless accessed from the\n\n     * system io address space.  This hack to bounce things via\n\n     * system_io works around the problem until all the users of\n\n     * old_portion are updated */\n\n    sprintf(namebuf, \"%s.io\", sphb->dtbusname);\n\n    memory_region_init(&sphb->iospace, namebuf, SPAPR_PCI_IO_WIN_SIZE);\n\n    /* FIXME: fix to support multiple PHBs */\n\n    memory_region_add_subregion(get_system_io(), 0, &sphb->iospace);\n\n\n\n    sprintf(namebuf, \"%s.io-alias\", sphb->dtbusname);\n\n    memory_region_init_io(&sphb->iowindow, &spapr_io_ops, sphb,\n\n                          namebuf, SPAPR_PCI_IO_WIN_SIZE);\n\n    memory_region_add_subregion(get_system_memory(), sphb->io_win_addr,\n\n                                &sphb->iowindow);\n\n\n\n    /* As MSI/MSIX interrupts trigger by writing at MSI/MSIX vectors,\n\n     * we need to allocate some memory to catch those writes coming\n\n     * from msi_notify()/msix_notify() */\n\n    if (msi_supported) {\n\n        sprintf(namebuf, \"%s.msi\", sphb->dtbusname);\n\n        memory_region_init_io(&sphb->msiwindow, &spapr_msi_ops, sphb,\n\n                              namebuf, SPAPR_MSIX_MAX_DEVS * 0x10000);\n\n        memory_region_add_subregion(get_system_memory(), sphb->msi_win_addr,\n\n                                    &sphb->msiwindow);\n\n    }\n\n\n\n    bus = pci_register_bus(DEVICE(s),\n\n                           sphb->busname ? sphb->busname : sphb->dtbusname,\n\n                           pci_spapr_set_irq, pci_spapr_map_irq, sphb,\n\n                           &sphb->memspace, &sphb->iospace,\n\n                           PCI_DEVFN(0, 0), PCI_NUM_PINS);\n\n    phb->bus = bus;\n\n\n\n    sphb->dma_liobn = SPAPR_PCI_BASE_LIOBN | (pci_find_domain(bus) << 16);\n\n    sphb->dma_window_start = 0;\n\n    sphb->dma_window_size = 0x40000000;\n\n    sphb->dma = spapr_tce_new_dma_context(sphb->dma_liobn, sphb->dma_window_size);\n\n    pci_setup_iommu(bus, spapr_pci_dma_context_fn, sphb);\n\n\n\n    QLIST_INSERT_HEAD(&spapr->phbs, sphb, list);\n\n\n\n    /* Initialize the LSI table */\n\n    for (i = 0; i < PCI_NUM_PINS; i++) {\n\n        uint32_t irq;\n\n\n\n        irq = spapr_allocate_lsi(0);\n\n        if (!irq) {\n\n            return -1;\n\n        }\n\n\n\n        sphb->lsi_table[i].irq = irq;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24851}
{"project": "qemu", "commit_id": "203d65a4706be345c209f3408d3a011a3e48f0c9", "target": 0, "func": "static void imx_epit_write(void *opaque, hwaddr offset, uint64_t value,\n\n                           unsigned size)\n\n{\n\n    IMXEPITState *s = IMX_EPIT(opaque);\n\n    uint32_t reg = offset >> 2;\n\n    uint64_t oldcr;\n\n\n\n    DPRINTF(\"(%s, value = 0x%08x)\\n\", imx_epit_reg_name(reg), (uint32_t)value);\n\n\n\n    switch (reg) {\n\n    case 0: /* CR */\n\n\n\n        oldcr = s->cr;\n\n        s->cr = value & 0x03ffffff;\n\n        if (s->cr & CR_SWR) {\n\n            /* handle the reset */\n\n            imx_epit_reset(DEVICE(s));\n\n        } else {\n\n            imx_epit_set_freq(s);\n\n        }\n\n\n\n        if (s->freq && (s->cr & CR_EN) && !(oldcr & CR_EN)) {\n\n            if (s->cr & CR_ENMOD) {\n\n                if (s->cr & CR_RLD) {\n\n                    ptimer_set_limit(s->timer_reload, s->lr, 1);\n\n                    ptimer_set_limit(s->timer_cmp, s->lr, 1);\n\n                } else {\n\n                    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);\n\n                    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);\n\n                }\n\n            }\n\n\n\n            imx_epit_reload_compare_timer(s);\n\n            ptimer_run(s->timer_reload, 0);\n\n            if (s->cr & CR_OCIEN) {\n\n                ptimer_run(s->timer_cmp, 0);\n\n            } else {\n\n                ptimer_stop(s->timer_cmp);\n\n            }\n\n        } else if (!(s->cr & CR_EN)) {\n\n            /* stop both timers */\n\n            ptimer_stop(s->timer_reload);\n\n            ptimer_stop(s->timer_cmp);\n\n        } else  if (s->cr & CR_OCIEN) {\n\n            if (!(oldcr & CR_OCIEN)) {\n\n                imx_epit_reload_compare_timer(s);\n\n                ptimer_run(s->timer_cmp, 0);\n\n            }\n\n        } else {\n\n            ptimer_stop(s->timer_cmp);\n\n        }\n\n        break;\n\n\n\n    case 1: /* SR - ACK*/\n\n        /* writing 1 to OCIF clear the OCIF bit */\n\n        if (value & 0x01) {\n\n            s->sr = 0;\n\n            imx_epit_update_int(s);\n\n        }\n\n        break;\n\n\n\n    case 2: /* LR - set ticks */\n\n        s->lr = value;\n\n\n\n        if (s->cr & CR_RLD) {\n\n            /* Also set the limit if the LRD bit is set */\n\n            /* If IOVW bit is set then set the timer value */\n\n            ptimer_set_limit(s->timer_reload, s->lr, s->cr & CR_IOVW);\n\n            ptimer_set_limit(s->timer_cmp, s->lr, 0);\n\n        } else if (s->cr & CR_IOVW) {\n\n            /* If IOVW bit is set then set the timer value */\n\n            ptimer_set_count(s->timer_reload, s->lr);\n\n        }\n\n\n\n        imx_epit_reload_compare_timer(s);\n\n        break;\n\n\n\n    case 3: /* CMP */\n\n        s->cmp = value;\n\n\n\n        imx_epit_reload_compare_timer(s);\n\n\n\n        break;\n\n\n\n    default:\n\n        IPRINTF(\"Bad offset %x\\n\", reg);\n\n\n\n        break;\n\n    }\n\n}\n", "idx": 24852}
{"project": "qemu", "commit_id": "94ad5b00a31113ed36b9d03a8db16de5535e90c4", "target": 0, "func": "static void cpu_set_irq(void *opaque, int irq, int level)\n\n{\n\n    CPUState *env = opaque;\n\n\n\n    if (level) {\n\n        CPUIRQ_DPRINTF(\"Raise CPU IRQ %d\\n\", irq);\n\n        env->halted = 0;\n\n        env->pil_in |= 1 << irq;\n\n        cpu_check_irqs(env);\n\n    } else {\n\n        CPUIRQ_DPRINTF(\"Lower CPU IRQ %d\\n\", irq);\n\n        env->pil_in &= ~(1 << irq);\n\n        cpu_check_irqs(env);\n\n    }\n\n}\n", "idx": 24853}
{"project": "qemu", "commit_id": "17bb18ce16b45e61248c5238074fa9cf8bc547bf", "target": 0, "func": "uint32_t HELPER(rrbe)(uint32_t r1, uint64_t r2)\n\n{\n\n    if (r2 > ram_size) {\n\n        return 0;\n\n    }\n\n\n\n    /* XXX implement */\n\n#if 0\n\n    env->storage_keys[r2 / TARGET_PAGE_SIZE] &= ~SK_REFERENCED;\n\n#endif\n\n\n\n    /*\n\n     * cc\n\n     *\n\n     * 0  Reference bit zero; change bit zero\n\n     * 1  Reference bit zero; change bit one\n\n     * 2  Reference bit one; change bit zero\n\n     * 3  Reference bit one; change bit one\n\n     */\n\n    return 0;\n\n}\n", "idx": 24854}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int get_stream_blocksize(BlockDriverState *bdrv)\n\n{\n\n    uint8_t cmd[6];\n\n    uint8_t buf[12];\n\n    uint8_t sensebuf[8];\n\n    sg_io_hdr_t io_header;\n\n    int ret;\n\n\n\n    memset(cmd, 0, sizeof(cmd));\n\n    memset(buf, 0, sizeof(buf));\n\n    cmd[0] = MODE_SENSE;\n\n    cmd[4] = sizeof(buf);\n\n\n\n    memset(&io_header, 0, sizeof(io_header));\n\n    io_header.interface_id = 'S';\n\n    io_header.dxfer_direction = SG_DXFER_FROM_DEV;\n\n    io_header.dxfer_len = sizeof(buf);\n\n    io_header.dxferp = buf;\n\n    io_header.cmdp = cmd;\n\n    io_header.cmd_len = sizeof(cmd);\n\n    io_header.mx_sb_len = sizeof(sensebuf);\n\n    io_header.sbp = sensebuf;\n\n    io_header.timeout = 6000; /* XXX */\n\n\n\n    ret = bdrv_ioctl(bdrv, SG_IO, &io_header);\n\n    if (ret < 0 || io_header.driver_status || io_header.host_status) {\n\n        return -1;\n\n    }\n\n    return (buf[9] << 16) | (buf[10] << 8) | buf[11];\n\n}\n", "idx": 24855}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void ivshmem_io_write(void *opaque, target_phys_addr_t addr,\n\n                             uint64_t val, unsigned size)\n\n{\n\n    IVShmemState *s = opaque;\n\n\n\n    uint16_t dest = val >> 16;\n\n    uint16_t vector = val & 0xff;\n\n\n\n    addr &= 0xfc;\n\n\n\n    IVSHMEM_DPRINTF(\"writing to addr \" TARGET_FMT_plx \"\\n\", addr);\n\n    switch (addr)\n\n    {\n\n        case INTRMASK:\n\n            ivshmem_IntrMask_write(s, val);\n\n            break;\n\n\n\n        case INTRSTATUS:\n\n            ivshmem_IntrStatus_write(s, val);\n\n            break;\n\n\n\n        case DOORBELL:\n\n            /* check that dest VM ID is reasonable */\n\n            if (dest > s->max_peer) {\n\n                IVSHMEM_DPRINTF(\"Invalid destination VM ID (%d)\\n\", dest);\n\n                break;\n\n            }\n\n\n\n            /* check doorbell range */\n\n            if (vector < s->peers[dest].nb_eventfds) {\n\n                IVSHMEM_DPRINTF(\"Notifying VM %d on vector %d\\n\", dest, vector);\n\n                event_notifier_set(&s->peers[dest].eventfds[vector]);\n\n            }\n\n            break;\n\n        default:\n\n            IVSHMEM_DPRINTF(\"Invalid VM Doorbell VM %d\\n\", dest);\n\n    }\n\n}\n", "idx": 24856}
{"project": "qemu", "commit_id": "6735aa99a43c70c09b53af190b24600a61178b95", "target": 0, "func": "SpiceInfo *qmp_query_spice(Error **errp)\n\n{\n\n    QemuOpts *opts = QTAILQ_FIRST(&qemu_spice_opts.head);\n\n    int port, tls_port;\n\n    const char *addr;\n\n    SpiceInfo *info;\n\n    char version_string[20]; /* 12 = |255.255.255\\0| is the max */\n\n\n\n    info = g_malloc0(sizeof(*info));\n\n\n\n    if (!spice_server || !opts) {\n\n        info->enabled = false;\n\n        return info;\n\n    }\n\n\n\n    info->enabled = true;\n\n    info->migrated = spice_migration_completed;\n\n\n\n    addr = qemu_opt_get(opts, \"addr\");\n\n    port = qemu_opt_get_number(opts, \"port\", 0);\n\n    tls_port = qemu_opt_get_number(opts, \"tls-port\", 0);\n\n\n\n    info->has_auth = true;\n\n    info->auth = g_strdup(auth);\n\n\n\n    info->has_host = true;\n\n    info->host = g_strdup(addr ? addr : \"0.0.0.0\");\n\n\n\n    info->has_compiled_version = true;\n\n    snprintf(version_string, sizeof(version_string), \"%d.%d.%d\",\n\n             (SPICE_SERVER_VERSION & 0xff0000) >> 16,\n\n             (SPICE_SERVER_VERSION & 0xff00) >> 8,\n\n             SPICE_SERVER_VERSION & 0xff);\n\n    info->compiled_version = g_strdup(version_string);\n\n\n\n    if (port) {\n\n        info->has_port = true;\n\n        info->port = port;\n\n    }\n\n    if (tls_port) {\n\n        info->has_tls_port = true;\n\n        info->tls_port = tls_port;\n\n    }\n\n\n\n    info->mouse_mode = spice_server_is_server_mouse(spice_server) ?\n\n                       SPICE_QUERY_MOUSE_MODE_SERVER :\n\n                       SPICE_QUERY_MOUSE_MODE_CLIENT;\n\n\n\n    /* for compatibility with the original command */\n\n    info->has_channels = true;\n\n    info->channels = qmp_query_spice_channels();\n\n\n\n    return info;\n\n}\n", "idx": 24857}
{"project": "qemu", "commit_id": "26a83ad0e793465b74a8b06a65f2f6fdc5615413", "target": 0, "func": "void memory_region_init_rom_device(MemoryRegion *mr,\n\n                                   const MemoryRegionOps *ops,\n\n                                   void *opaque,\n\n                                   const char *name,\n\n                                   uint64_t size)\n\n{\n\n    memory_region_init(mr, name, size);\n\n    mr->ops = ops;\n\n    mr->opaque = opaque;\n\n    mr->terminates = true;\n\n    mr->destructor = memory_region_destructor_rom_device;\n\n    mr->ram_addr = qemu_ram_alloc(size, mr);\n\n    mr->ram_addr |= cpu_register_io_memory(memory_region_read_thunk,\n\n                                           memory_region_write_thunk,\n\n                                           mr);\n\n    mr->ram_addr |= IO_MEM_ROMD;\n\n    mr->backend_registered = true;\n\n}\n", "idx": 24858}
{"project": "qemu", "commit_id": "b035ffd11813524d7c0e44354f5c4bdd281f4b37", "target": 0, "func": "void *qemu_vmalloc(size_t size)\n\n{\n\n    void *p;\n\n    unsigned long addr;\n\n    mmap_lock();\n\n    /* Use map and mark the pages as used.  */\n\n    p = mmap(NULL, size, PROT_READ | PROT_WRITE,\n\n             MAP_PRIVATE | MAP_ANON, -1, 0);\n\n\n\n    addr = (unsigned long)p;\n\n    if (addr == (target_ulong) addr) {\n\n        /* Allocated region overlaps guest address space.\n\n           This may recurse.  */\n\n        page_set_flags(addr & TARGET_PAGE_MASK, TARGET_PAGE_ALIGN(addr + size),\n\n                       PAGE_RESERVED);\n\n    }\n\n\n\n    mmap_unlock();\n\n    return p;\n\n}\n", "idx": 24862}
{"project": "qemu", "commit_id": "c16de8f59a2bcbe2dc037524cc648de896f581a4", "target": 0, "func": "static int blk_root_inactivate(BdrvChild *child)\n\n{\n\n    BlockBackend *blk = child->opaque;\n\n\n\n    if (blk->disable_perm) {\n\n        return 0;\n\n    }\n\n\n\n    /* Only inactivate BlockBackends for guest devices (which are inactive at\n\n     * this point because the VM is stopped) and unattached monitor-owned\n\n     * BlockBackends. If there is still any other user like a block job, then\n\n     * we simply can't inactivate the image. */\n\n    if (!blk->dev && !blk_name(blk)[0]) {\n\n        return -EPERM;\n\n    }\n\n\n\n    blk->disable_perm = true;\n\n    if (blk->root) {\n\n        bdrv_child_try_set_perm(blk->root, 0, BLK_PERM_ALL, &error_abort);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24863}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "static void rtas_query_cpu_stopped_state(sPAPREnvironment *spapr,\n\n                                         uint32_t token, uint32_t nargs,\n\n                                         target_ulong args,\n\n                                         uint32_t nret, target_ulong rets)\n\n{\n\n    target_ulong id;\n\n    CPUState *cpu;\n\n\n\n    if (nargs != 1 || nret != 2) {\n\n        rtas_st(rets, 0, -3);\n\n        return;\n\n    }\n\n\n\n    id = rtas_ld(args, 0);\n\n    cpu = qemu_get_cpu(id);\n\n    if (cpu != NULL) {\n\n        if (cpu->halted) {\n\n            rtas_st(rets, 1, 0);\n\n        } else {\n\n            rtas_st(rets, 1, 2);\n\n        }\n\n\n\n        rtas_st(rets, 0, 0);\n\n        return;\n\n    }\n\n\n\n    /* Didn't find a matching cpu */\n\n    rtas_st(rets, 0, -3);\n\n}\n", "idx": 24864}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static inline void vmsvga_update_rect_flush(struct vmsvga_state_s *s)\n\n{\n\n    struct vmsvga_rect_s *rect;\n\n    if (s->invalidated) {\n\n        s->redraw_fifo_first = s->redraw_fifo_last;\n\n        return;\n\n    }\n\n    /* Overlapping region updates can be optimised out here - if someone\n\n     * knows a smart algorithm to do that, please share.  */\n\n    while (s->redraw_fifo_first != s->redraw_fifo_last) {\n\n        rect = &s->redraw_fifo[s->redraw_fifo_first ++];\n\n        s->redraw_fifo_first &= REDRAW_FIFO_LEN - 1;\n\n        vmsvga_update_rect(s, rect->x, rect->y, rect->w, rect->h);\n\n    }\n\n}\n", "idx": 24865}
{"project": "qemu", "commit_id": "5255fcf8e47acd059e2f0d414841c40231c1bd22", "target": 0, "func": "static void nvic_recompute_state(NVICState *s)\n\n{\n\n    int i;\n\n    int pend_prio = NVIC_NOEXC_PRIO;\n\n    int active_prio = NVIC_NOEXC_PRIO;\n\n    int pend_irq = 0;\n\n\n\n    for (i = 1; i < s->num_irq; i++) {\n\n        VecInfo *vec = &s->vectors[i];\n\n\n\n        if (vec->enabled && vec->pending && vec->prio < pend_prio) {\n\n            pend_prio = vec->prio;\n\n            pend_irq = i;\n\n        }\n\n        if (vec->active && vec->prio < active_prio) {\n\n            active_prio = vec->prio;\n\n        }\n\n    }\n\n\n\n    if (active_prio > 0) {\n\n        active_prio &= nvic_gprio_mask(s);\n\n    }\n\n\n\n    s->vectpending = pend_irq;\n\n    s->exception_prio = active_prio;\n\n\n\n    trace_nvic_recompute_state(s->vectpending, s->exception_prio);\n\n}\n", "idx": 24866}
{"project": "qemu", "commit_id": "e95ead32efc48157de12e0a257ea1c52541a6ce1", "target": 0, "func": "static int local_fsync(FsContext *ctx, int fd)\n\n{\n\n    if (0) /* Just to supress the warning. Will be removed in next patch. */\n\n        (void)local_set_xattr(NULL, NULL);\n\n    return fsync(fd);\n\n}\n", "idx": 24867}
{"project": "qemu", "commit_id": "7d5e199ade76c53ec316ab6779800581bb47c50a", "target": 0, "func": "void qmp_blockdev_add(BlockdevOptions *options, Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    QObject *obj;\n\n    Visitor *v = qmp_output_visitor_new(&obj);\n\n    QDict *qdict;\n\n    Error *local_err = NULL;\n\n\n\n    visit_type_BlockdevOptions(v, NULL, &options, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n    }\n\n\n\n    visit_complete(v, &obj);\n\n    qdict = qobject_to_qdict(obj);\n\n\n\n    qdict_flatten(qdict);\n\n\n\n    if (!qdict_get_try_str(qdict, \"node-name\")) {\n\n        error_setg(errp, \"'node-name' must be specified for the root node\");\n\n        goto fail;\n\n    }\n\n\n\n    bs = bds_tree_init(qdict, errp);\n\n    if (!bs) {\n\n        goto fail;\n\n    }\n\n\n\n    QTAILQ_INSERT_TAIL(&monitor_bdrv_states, bs, monitor_list);\n\n\n\n    if (bs && bdrv_key_required(bs)) {\n\n        QTAILQ_REMOVE(&monitor_bdrv_states, bs, monitor_list);\n\n        bdrv_unref(bs);\n\n        error_setg(errp, \"blockdev-add doesn't support encrypted devices\");\n\n        goto fail;\n\n    }\n\n\n\nfail:\n\n    visit_free(v);\n\n}\n", "idx": 24868}
{"project": "qemu", "commit_id": "7df9381b7aa56c897e344f3bfe43bf5848bbd3e0", "target": 0, "func": "static void vfio_platform_realize(DeviceState *dev, Error **errp)\n\n{\n\n    VFIOPlatformDevice *vdev = VFIO_PLATFORM_DEVICE(dev);\n\n    SysBusDevice *sbdev = SYS_BUS_DEVICE(dev);\n\n    VFIODevice *vbasedev = &vdev->vbasedev;\n\n    int i, ret;\n\n\n\n    vbasedev->type = VFIO_DEVICE_TYPE_PLATFORM;\n\n    vbasedev->ops = &vfio_platform_ops;\n\n\n\n    trace_vfio_platform_realize(vbasedev->name, vdev->compat);\n\n\n\n    ret = vfio_base_device_init(vbasedev);\n\n    if (ret) {\n\n        error_setg(errp, \"vfio: vfio_base_device_init failed for %s\",\n\n                   vbasedev->name);\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < vbasedev->num_regions; i++) {\n\n        vfio_map_region(vdev, i);\n\n        sysbus_init_mmio(sbdev, &vdev->regions[i]->mem);\n\n    }\n\n}\n", "idx": 24871}
{"project": "qemu", "commit_id": "0923c577f993d61eeaf41f66db1e1010fa113976", "target": 0, "func": "length_f(int argc, char **argv)\n\n{\n\n        int64_t size;\n\n\tchar s1[64];\n\n\n\n\tsize = bdrv_getlength(bs);\n\n\tif (size < 0) {\n\n\t\tprintf(\"getlength: %s\", strerror(size));\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tcvtstr(size, s1, sizeof(s1));\n\n\tprintf(\"%s\\n\", s1);\n\n\treturn 0;\n\n}\n", "idx": 24872}
{"project": "qemu", "commit_id": "d2ca7c0b0d876cf0e219ae7a92252626b0913a28", "target": 0, "func": "void json_lexer_destroy(JSONLexer *lexer)\n\n{\n\n    QDECREF(lexer->token);\n\n}\n", "idx": 24873}
{"project": "qemu", "commit_id": "7ba7974197090285fdb413c6e1c41aaacd44b9c4", "target": 0, "func": "static void pcnet_ioport_write(void *opaque, target_phys_addr_t addr,\n\n                               uint64_t data, unsigned size)\n\n{\n\n    PCNetState *d = opaque;\n\n\n\n    if (addr < 16 && size == 1) {\n\n        return pcnet_aprom_writeb(d, addr, data);\n\n    } else if (addr >= 0x10 && addr < 0x20 && size == 2) {\n\n        return pcnet_ioport_writew(d, addr, data);\n\n    } else if (addr >= 0x10 && addr < 0x20 && size == 4) {\n\n        return pcnet_ioport_writel(d, addr, data);\n\n    }\n\n}\n", "idx": 24874}
{"project": "qemu", "commit_id": "ef1e1e0782e99c9dcf2b35e5310cdd8ca9211374", "target": 0, "func": "build_hash_table (const sparc_opcode **opcode_table,\n\n                  sparc_opcode_hash **hash_table,\n\n                  int num_opcodes)\n\n{\n\n  int i;\n\n  int hash_count[HASH_SIZE];\n\n  static sparc_opcode_hash *hash_buf = NULL;\n\n\n\n  /* Start at the end of the table and work backwards so that each\n\n     chain is sorted.  */\n\n\n\n  memset (hash_table, 0, HASH_SIZE * sizeof (hash_table[0]));\n\n  memset (hash_count, 0, HASH_SIZE * sizeof (hash_count[0]));\n\n  if (hash_buf != NULL)\n\n    free (hash_buf);\n\n  hash_buf = malloc (sizeof (* hash_buf) * num_opcodes);\n\n  for (i = num_opcodes - 1; i >= 0; --i)\n\n    {\n\n      int hash = HASH_INSN (opcode_table[i]->match);\n\n      sparc_opcode_hash *h = &hash_buf[i];\n\n\n\n      h->next = hash_table[hash];\n\n      h->opcode = opcode_table[i];\n\n      hash_table[hash] = h;\n\n      ++hash_count[hash];\n\n    }\n\n\n\n#if 0 /* for debugging */\n\n  {\n\n    int min_count = num_opcodes, max_count = 0;\n\n    int total;\n\n\n\n    for (i = 0; i < HASH_SIZE; ++i)\n\n      {\n\n        if (hash_count[i] < min_count)\n\n          min_count = hash_count[i];\n\n        if (hash_count[i] > max_count)\n\n          max_count = hash_count[i];\n\n        total += hash_count[i];\n\n      }\n\n\n\n    printf (\"Opcode hash table stats: min %d, max %d, ave %f\\n\",\n\n            min_count, max_count, (double) total / HASH_SIZE);\n\n  }\n\n#endif\n\n}\n", "idx": 24875}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "void nbd_export_close(NBDExport *exp)\n\n{\n\n    NBDClient *client, *next;\n\n\n\n    nbd_export_get(exp);\n\n    QTAILQ_FOREACH_SAFE(client, &exp->clients, next, next) {\n\n        nbd_client_close(client);\n\n    }\n\n    nbd_export_set_name(exp, NULL);\n\n    nbd_export_put(exp);\n\n    if (exp->blk) {\n\n        blk_remove_aio_context_notifier(exp->blk, blk_aio_attached,\n\n                                        blk_aio_detach, exp);\n\n        blk_unref(exp->blk);\n\n        exp->blk = NULL;\n\n    }\n\n}\n", "idx": 24876}
{"project": "qemu", "commit_id": "31b2b0f8463533c32b5ad76e73668e2e9fca8ae2", "target": 0, "func": "static void gen_spr_power8_book4(CPUPPCState *env)\n\n{\n\n    /* Add a number of P8 book4 registers */\n\n#if !defined(CONFIG_USER_ONLY)\n\n    spr_register_kvm(env, SPR_ACOP, \"ACOP\",\n\n                     SPR_NOACCESS, SPR_NOACCESS,\n\n                     &spr_read_generic, &spr_write_generic,\n\n                     KVM_REG_PPC_ACOP, 0);\n\n    spr_register_kvm(env, SPR_BOOKS_PID, \"PID\",\n\n                     SPR_NOACCESS, SPR_NOACCESS,\n\n                     &spr_read_generic, &spr_write_generic,\n\n                     KVM_REG_PPC_PID, 0);\n\n    spr_register_kvm(env, SPR_WORT, \"WORT\",\n\n                     SPR_NOACCESS, SPR_NOACCESS,\n\n                     &spr_read_generic, &spr_write_generic,\n\n                     KVM_REG_PPC_WORT, 0);\n\n#endif\n\n}\n", "idx": 24877}
{"project": "qemu", "commit_id": "d4c430a80f000d722bb70287af4d4c184a8d7006", "target": 0, "func": "int cpu_m68k_handle_mmu_fault (CPUState *env, target_ulong address, int rw,\n\n                               int mmu_idx, int is_softmmu)\n\n{\n\n    int prot;\n\n\n\n    address &= TARGET_PAGE_MASK;\n\n    prot = PAGE_READ | PAGE_WRITE;\n\n    return tlb_set_page(env, address, address, prot, mmu_idx, is_softmmu);\n\n}\n", "idx": 24878}
{"project": "qemu", "commit_id": "1ac157da77c863b62b1d2f467626a440d57cf17d", "target": 0, "func": "void helper_movl_crN_T0(int reg)\n\n{\n\n    env->cr[reg] = T0;\n\n    switch(reg) {\n\n    case 0:\n\n        cpu_x86_update_cr0(env);\n\n        break;\n\n    case 3:\n\n        cpu_x86_update_cr3(env);\n\n        break;\n\n    }\n\n}\n", "idx": 24879}
{"project": "qemu", "commit_id": "786a4ea82ec9c87e3a895cf41081029b285a5fe5", "target": 0, "func": "int qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,\n\n                                  int64_t size)\n\n{\n\n    int ret = qcow2_check_metadata_overlap(bs, ign, offset, size);\n\n\n\n    if (ret < 0) {\n\n        return ret;\n\n    } else if (ret > 0) {\n\n        int metadata_ol_bitnr = ffs(ret) - 1;\n\n        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);\n\n\n\n        qcow2_signal_corruption(bs, true, offset, size, \"Preventing invalid \"\n\n                                \"write on metadata (overlaps with %s)\",\n\n                                metadata_ol_names[metadata_ol_bitnr]);\n\n        return -EIO;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24880}
{"project": "qemu", "commit_id": "0e1a46bbd2d6c39614b87f4e88ea305acce8a35f", "target": 0, "func": "static bool pmsav7_needed(void *opaque)\n\n{\n\n    ARMCPU *cpu = opaque;\n\n    CPUARMState *env = &cpu->env;\n\n\n\n    return arm_feature(env, ARM_FEATURE_PMSA) &&\n\n           arm_feature(env, ARM_FEATURE_V7);\n\n}\n", "idx": 24882}
{"project": "qemu", "commit_id": "b227a8e9aa5f27d29f77ba90d5eb9d0662a1175e", "target": 0, "func": "int mmu40x_get_physical_address (CPUState *env, mmu_ctx_t *ctx,\n\n                                 target_ulong address, int rw, int access_type)\n\n{\n\n    ppcemb_tlb_t *tlb;\n\n    target_phys_addr_t raddr;\n\n    int i, ret, zsel, zpr;\n\n\n\n    ret = -1;\n\n    raddr = -1;\n\n    for (i = 0; i < env->nb_tlb; i++) {\n\n        tlb = &env->tlb[i].tlbe;\n\n        if (ppcemb_tlb_check(env, tlb, &raddr, address,\n\n                             env->spr[SPR_40x_PID], 0, i) < 0)\n\n            continue;\n\n        zsel = (tlb->attr >> 4) & 0xF;\n\n        zpr = (env->spr[SPR_40x_ZPR] >> (28 - (2 * zsel))) & 0x3;\n\n#if defined (DEBUG_SOFTWARE_TLB)\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"%s: TLB %d zsel %d zpr %d rw %d attr %08x\\n\",\n\n                    __func__, i, zsel, zpr, rw, tlb->attr);\n\n        }\n\n#endif\n\n        if (access_type == ACCESS_CODE) {\n\n            /* Check execute enable bit */\n\n            switch (zpr) {\n\n            case 0x2:\n\n                if (msr_pr)\n\n                    goto check_exec_perm;\n\n                goto exec_granted;\n\n            case 0x0:\n\n                if (msr_pr) {\n\n                    ctx->prot = 0;\n\n                    ret = -3;\n\n                    break;\n\n                }\n\n                /* No break here */\n\n            case 0x1:\n\n            check_exec_perm:\n\n                /* Check from TLB entry */\n\n                if (!(tlb->prot & PAGE_EXEC)) {\n\n                    ret = -3;\n\n                } else {\n\n                    if (tlb->prot & PAGE_WRITE) {\n\n                        ctx->prot = PAGE_READ | PAGE_WRITE;\n\n                    } else {\n\n                        ctx->prot = PAGE_READ;\n\n                    }\n\n                    ret = 0;\n\n                }\n\n                break;\n\n            case 0x3:\n\n            exec_granted:\n\n                /* All accesses granted */\n\n                ctx->prot = PAGE_READ | PAGE_WRITE;\n\n                ret = 0;\n\n                break;\n\n            }\n\n        } else {\n\n            switch (zpr) {\n\n            case 0x2:\n\n                if (msr_pr)\n\n                    goto check_rw_perm;\n\n                goto rw_granted;\n\n            case 0x0:\n\n                if (msr_pr) {\n\n                    ctx->prot = 0;\n\n                    ret = -2;\n\n                    break;\n\n                }\n\n                /* No break here */\n\n            case 0x1:\n\n            check_rw_perm:\n\n                /* Check from TLB entry */\n\n                /* Check write protection bit */\n\n                if (tlb->prot & PAGE_WRITE) {\n\n                    ctx->prot = PAGE_READ | PAGE_WRITE;\n\n                    ret = 0;\n\n                } else {\n\n                    ctx->prot = PAGE_READ;\n\n                    if (rw)\n\n                        ret = -2;\n\n                    else\n\n                        ret = 0;\n\n                }\n\n                break;\n\n            case 0x3:\n\n            rw_granted:\n\n                /* All accesses granted */\n\n                ctx->prot = PAGE_READ | PAGE_WRITE;\n\n                ret = 0;\n\n                break;\n\n            }\n\n        }\n\n        if (ret >= 0) {\n\n            ctx->raddr = raddr;\n\n#if defined (DEBUG_SOFTWARE_TLB)\n\n            if (loglevel != 0) {\n\n                fprintf(logfile, \"%s: access granted \" ADDRX \" => \" REGX\n\n                        \" %d %d\\n\", __func__, address, ctx->raddr, ctx->prot,\n\n                        ret);\n\n            }\n\n#endif\n\n            return 0;\n\n        }\n\n    }\n\n#if defined (DEBUG_SOFTWARE_TLB)\n\n    if (loglevel != 0) {\n\n        fprintf(logfile, \"%s: access refused \" ADDRX \" => \" REGX\n\n                \" %d %d\\n\", __func__, address, raddr, ctx->prot,\n\n                ret);\n\n    }\n\n#endif\n\n\n\n    return ret;\n\n}\n", "idx": 24883}
{"project": "qemu", "commit_id": "81ffbf5ab1458e357a761f1272105a55829b351e", "target": 0, "func": "static struct dirent *local_readdir(FsContext *ctx, V9fsFidOpenState *fs)\n\n{\n\n    struct dirent *entry;\n\n\n\nagain:\n\n    entry = readdir(fs->dir.stream);\n\n    if (!entry) {\n\n        return NULL;\n\n    }\n\n\n\n    if (ctx->export_flags & V9FS_SM_MAPPED) {\n\n        entry->d_type = DT_UNKNOWN;\n\n    } else if (ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n\n        if (local_is_mapped_file_metadata(ctx, entry->d_name)) {\n\n            /* skip the meta data directory */\n\n            goto again;\n\n        }\n\n        entry->d_type = DT_UNKNOWN;\n\n    }\n\n\n\n    return entry;\n\n}\n", "idx": 24884}
{"project": "qemu", "commit_id": "855011be05fad72e17e0280d0bab87a4bc840695", "target": 0, "func": "static void kvm_arm_gic_get(GICState *s)\n\n{\n\n    /* TODO: there isn't currently a kernel interface to get the GIC state */\n\n}\n", "idx": 24885}
{"project": "qemu", "commit_id": "b190f477e29c7cd03a8fee49c96d27f160e3f5b0", "target": 1, "func": "static void tricore_cpu_class_init(ObjectClass *c, void *data)\n\n{\n\n    TriCoreCPUClass *mcc = TRICORE_CPU_CLASS(c);\n\n    CPUClass *cc = CPU_CLASS(c);\n\n    DeviceClass *dc = DEVICE_CLASS(c);\n\n\n\n    mcc->parent_realize = dc->realize;\n\n    dc->realize = tricore_cpu_realizefn;\n\n\n\n    mcc->parent_reset = cc->reset;\n\n    cc->reset = tricore_cpu_reset;\n\n    cc->class_by_name = tricore_cpu_class_by_name;\n\n    cc->has_work = tricore_cpu_has_work;\n\n\n\n    cc->dump_state = tricore_cpu_dump_state;\n\n    cc->set_pc = tricore_cpu_set_pc;\n\n    cc->synchronize_from_tb = tricore_cpu_synchronize_from_tb;\n\n\n}", "idx": 24886}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "void *kvmppc_create_spapr_tce(uint32_t liobn, uint32_t window_size, int *pfd)\n\n{\n\n    struct kvm_create_spapr_tce args = {\n\n        .liobn = liobn,\n\n        .window_size = window_size,\n\n    };\n\n    long len;\n\n    int fd;\n\n    void *table;\n\n\n\n    /* Must set fd to -1 so we don't try to munmap when called for\n\n     * destroying the table, which the upper layers -will- do\n\n     */\n\n    *pfd = -1;\n\n    if (!cap_spapr_tce) {\n\n        return NULL;\n\n    }\n\n\n\n    fd = kvm_vm_ioctl(kvm_state, KVM_CREATE_SPAPR_TCE, &args);\n\n    if (fd < 0) {\n\n        fprintf(stderr, \"KVM: Failed to create TCE table for liobn 0x%x\\n\",\n\n                liobn);\n\n        return NULL;\n\n    }\n\n\n\n    len = (window_size / SPAPR_VIO_TCE_PAGE_SIZE) * sizeof(VIOsPAPR_RTCE);\n\n    /* FIXME: round this up to page size */\n\n\n\n    table = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n\n    if (table == MAP_FAILED) {\n\n        fprintf(stderr, \"KVM: Failed to map TCE table for liobn 0x%x\\n\",\n\n                liobn);\n\n        close(fd);\n\n        return NULL;\n\n    }\n\n\n\n    *pfd = fd;\n\n    return table;\n\n}\n", "idx": 24892}
{"project": "qemu", "commit_id": "c599d4d6d6e9bfdb64e54c33a22cb26e3496b96d", "target": 1, "func": "long do_rt_sigreturn(CPUM68KState *env)\n\n{\n\n    struct target_rt_sigframe *frame;\n\n    abi_ulong frame_addr = env->aregs[7] - 4;\n\n    target_sigset_t target_set;\n\n    sigset_t set;\n\n\n\n    trace_user_do_rt_sigreturn(env, frame_addr);\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))\n\n        goto badframe;\n\n\n\n    target_to_host_sigset_internal(&set, &target_set);\n\n    set_sigmask(&set);\n\n\n\n    /* restore registers */\n\n\n\n    if (target_rt_restore_ucontext(env, &frame->uc))\n\n        goto badframe;\n\n\n\n    if (do_sigaltstack(frame_addr +\n\n                       offsetof(struct target_rt_sigframe, uc.tuc_stack),\n\n                       0, get_sp_from_cpustate(env)) == -EFAULT)\n\n        goto badframe;\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return -TARGET_QEMU_ESIGRETURN;\n\n\n\nbadframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n", "idx": 24893}
{"project": "qemu", "commit_id": "e92f0e1910f0655a0edd8d87c5a7262d36517a89", "target": 1, "func": "static BlockAIOCB *bdrv_co_aio_prw_vector(BdrvChild *child,\n\n                                          int64_t offset,\n\n                                          QEMUIOVector *qiov,\n\n                                          BdrvRequestFlags flags,\n\n                                          BlockCompletionFunc *cb,\n\n                                          void *opaque,\n\n                                          bool is_write)\n\n{\n\n    Coroutine *co;\n\n    BlockAIOCBCoroutine *acb;\n\n\n\n    /* Matched by bdrv_co_complete's bdrv_dec_in_flight.  */\n\n    bdrv_inc_in_flight(child->bs);\n\n\n\n    acb = qemu_aio_get(&bdrv_em_co_aiocb_info, child->bs, cb, opaque);\n\n    acb->child = child;\n\n    acb->need_bh = true;\n\n    acb->req.error = -EINPROGRESS;\n\n    acb->req.offset = offset;\n\n    acb->req.qiov = qiov;\n\n    acb->req.flags = flags;\n\n    acb->is_write = is_write;\n\n\n\n    co = qemu_coroutine_create(bdrv_co_do_rw, acb);\n\n    qemu_coroutine_enter(co);\n\n\n\n    bdrv_co_maybe_schedule_bh(acb);\n\n    return &acb->common;\n\n}\n", "idx": 24894}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void co_write_request(void *opaque)\n\n{\n\n    BDRVSheepdogState *s = opaque;\n\n\n\n    qemu_coroutine_enter(s->co_send, NULL);\n\n}\n", "idx": 24895}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "udp_listen(Slirp *slirp, u_int32_t haddr, u_int hport, u_int32_t laddr,\n\n           u_int lport, int flags)\n\n{\n\n\tstruct sockaddr_in addr;\n\n\tstruct socket *so;\n\n\tsocklen_t addrlen = sizeof(struct sockaddr_in), opt = 1;\n\n\n\n\tso = socreate(slirp);\n\n\tif (!so) {\n\n\t    return NULL;\n\n\t}\n\n\tso->s = socket(AF_INET,SOCK_DGRAM,0);\n\n\tso->so_expire = curtime + SO_EXPIRE;\n\n\tinsque(so, &slirp->udb);\n\n\n\n\taddr.sin_family = AF_INET;\n\n\taddr.sin_addr.s_addr = haddr;\n\n\taddr.sin_port = hport;\n\n\n\n\tif (bind(so->s,(struct sockaddr *)&addr, addrlen) < 0) {\n\n\t\tudp_detach(so);\n\n\t\treturn NULL;\n\n\t}\n\n\tsetsockopt(so->s,SOL_SOCKET,SO_REUSEADDR,(char *)&opt,sizeof(int));\n\n\n\n\tgetsockname(so->s,(struct sockaddr *)&addr,&addrlen);\n\n\tso->so_fport = addr.sin_port;\n\n\tif (addr.sin_addr.s_addr == 0 ||\n\n\t    addr.sin_addr.s_addr == loopback_addr.s_addr) {\n\n\t   so->so_faddr = slirp->vhost_addr;\n\n\t} else {\n\n\t   so->so_faddr = addr.sin_addr;\n\n\t}\n\n\tso->so_lport = lport;\n\n\tso->so_laddr.s_addr = laddr;\n\n\tif (flags != SS_FACCEPTONCE)\n\n\t   so->so_expire = 0;\n\n\n\n\tso->so_state &= SS_PERSISTENT_MASK;\n\n\tso->so_state |= SS_ISFCONNECTED | flags;\n\n\n\n\treturn so;\n\n}\n", "idx": 24897}
{"project": "qemu", "commit_id": "fac7aa7fc2ebc26803b0a7b44b010f47ce3e1dd8", "target": 1, "func": "static void  ahci_port_write(AHCIState *s, int port, int offset, uint32_t val)\n\n{\n\n    AHCIPortRegs *pr = &s->dev[port].port_regs;\n\n\n\n    DPRINTF(port, \"offset: 0x%x val: 0x%x\\n\", offset, val);\n\n    switch (offset) {\n\n        case PORT_LST_ADDR:\n\n            pr->lst_addr = val;\n\n            map_page(s->as, &s->dev[port].lst,\n\n                     ((uint64_t)pr->lst_addr_hi << 32) | pr->lst_addr, 1024);\n\n            s->dev[port].cur_cmd = NULL;\n\n            break;\n\n        case PORT_LST_ADDR_HI:\n\n            pr->lst_addr_hi = val;\n\n            map_page(s->as, &s->dev[port].lst,\n\n                     ((uint64_t)pr->lst_addr_hi << 32) | pr->lst_addr, 1024);\n\n            s->dev[port].cur_cmd = NULL;\n\n            break;\n\n        case PORT_FIS_ADDR:\n\n            pr->fis_addr = val;\n\n            map_page(s->as, &s->dev[port].res_fis,\n\n                     ((uint64_t)pr->fis_addr_hi << 32) | pr->fis_addr, 256);\n\n            break;\n\n        case PORT_FIS_ADDR_HI:\n\n            pr->fis_addr_hi = val;\n\n            map_page(s->as, &s->dev[port].res_fis,\n\n                     ((uint64_t)pr->fis_addr_hi << 32) | pr->fis_addr, 256);\n\n            break;\n\n        case PORT_IRQ_STAT:\n\n            pr->irq_stat &= ~val;\n\n            ahci_check_irq(s);\n\n            break;\n\n        case PORT_IRQ_MASK:\n\n            pr->irq_mask = val & 0xfdc000ff;\n\n            ahci_check_irq(s);\n\n            break;\n\n        case PORT_CMD:\n\n            pr->cmd = val & ~(PORT_CMD_LIST_ON | PORT_CMD_FIS_ON);\n\n\n\n            if (pr->cmd & PORT_CMD_START) {\n\n                pr->cmd |= PORT_CMD_LIST_ON;\n\n            }\n\n\n\n            if (pr->cmd & PORT_CMD_FIS_RX) {\n\n                pr->cmd |= PORT_CMD_FIS_ON;\n\n            }\n\n\n\n            /* XXX usually the FIS would be pending on the bus here and\n\n                   issuing deferred until the OS enables FIS receival.\n\n                   Instead, we only submit it once - which works in most\n\n                   cases, but is a hack. */\n\n            if ((pr->cmd & PORT_CMD_FIS_ON) &&\n\n                !s->dev[port].init_d2h_sent) {\n\n                ahci_init_d2h(&s->dev[port]);\n\n                s->dev[port].init_d2h_sent = true;\n\n            }\n\n\n\n            check_cmd(s, port);\n\n            break;\n\n        case PORT_TFDATA:\n\n            s->dev[port].port.ifs[0].error = (val >> 8) & 0xff;\n\n            s->dev[port].port.ifs[0].status = val & 0xff;\n\n            break;\n\n        case PORT_SIG:\n\n            pr->sig = val;\n\n            break;\n\n        case PORT_SCR_STAT:\n\n            pr->scr_stat = val;\n\n            break;\n\n        case PORT_SCR_CTL:\n\n            if (((pr->scr_ctl & AHCI_SCR_SCTL_DET) == 1) &&\n\n                ((val & AHCI_SCR_SCTL_DET) == 0)) {\n\n                ahci_reset_port(s, port);\n\n            }\n\n            pr->scr_ctl = val;\n\n            break;\n\n        case PORT_SCR_ERR:\n\n            pr->scr_err &= ~val;\n\n            break;\n\n        case PORT_SCR_ACT:\n\n            /* RW1 */\n\n            pr->scr_act |= val;\n\n            break;\n\n        case PORT_CMD_ISSUE:\n\n            pr->cmd_issue |= val;\n\n            check_cmd(s, port);\n\n            break;\n\n        default:\n\n            break;\n\n    }\n\n}\n", "idx": 24898}
{"project": "qemu", "commit_id": "b4548fcc0314f5e118ed45b5774e9cd99f9a97d3", "target": 1, "func": "static uint32_t grlib_irqmp_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    IRQMP      *irqmp = opaque;\n\n    IRQMPState *state;\n\n\n\n    assert(irqmp != NULL);\n\n    state = irqmp->state;\n\n    assert(state != NULL);\n\n\n\n    addr &= 0xff;\n\n\n\n    /* global registers */\n\n    switch (addr) {\n\n    case LEVEL_OFFSET:\n\n        return state->level;\n\n\n\n    case PENDING_OFFSET:\n\n        return state->pending;\n\n\n\n    case FORCE0_OFFSET:\n\n        /* This register is an \"alias\" for the force register of CPU 0 */\n\n        return state->force[0];\n\n\n\n    case CLEAR_OFFSET:\n\n    case MP_STATUS_OFFSET:\n\n        /* Always read as 0 */\n\n        return 0;\n\n\n\n    case BROADCAST_OFFSET:\n\n        return state->broadcast;\n\n\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* mask registers */\n\n    if (addr >= MASK_OFFSET && addr < FORCE_OFFSET) {\n\n        int cpu = (addr - MASK_OFFSET) / 4;\n\n        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);\n\n\n\n        return state->mask[cpu];\n\n    }\n\n\n\n    /* force registers */\n\n    if (addr >= FORCE_OFFSET && addr < EXTENDED_OFFSET) {\n\n        int cpu = (addr - FORCE_OFFSET) / 4;\n\n        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);\n\n\n\n        return state->force[cpu];\n\n    }\n\n\n\n    /* extended (not supported) */\n\n    if (addr >= EXTENDED_OFFSET && addr < IRQMP_REG_SIZE) {\n\n        int cpu = (addr - EXTENDED_OFFSET) / 4;\n\n        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);\n\n\n\n        return state->extended[cpu];\n\n    }\n\n\n\n    trace_grlib_irqmp_unknown_register(\"read\", addr);\n\n    return 0;\n\n}\n", "idx": 24899}
{"project": "qemu", "commit_id": "ea8d82a1ed72634f089ed1bccccd9c84cc1ab855", "target": 1, "func": "void qemu_sglist_destroy(QEMUSGList *qsg)\n\n{\n\n    g_free(qsg->sg);\n\n\n}", "idx": 24902}
{"project": "qemu", "commit_id": "dd793a74882477ca38d49e191110c17dfee51dcc", "target": 1, "func": "e1000_receive_iov(NetClientState *nc, const struct iovec *iov, int iovcnt)\n\n{\n\n    E1000State *s = qemu_get_nic_opaque(nc);\n\n    PCIDevice *d = PCI_DEVICE(s);\n\n    struct e1000_rx_desc desc;\n\n    dma_addr_t base;\n\n    unsigned int n, rdt;\n\n    uint32_t rdh_start;\n\n    uint16_t vlan_special = 0;\n\n    uint8_t vlan_status = 0;\n\n    uint8_t min_buf[MIN_BUF_SIZE];\n\n    struct iovec min_iov;\n\n    uint8_t *filter_buf = iov->iov_base;\n\n    size_t size = iov_size(iov, iovcnt);\n\n    size_t iov_ofs = 0;\n\n    size_t desc_offset;\n\n    size_t desc_size;\n\n    size_t total_size;\n\n    static const int PRCregs[6] = { PRC64, PRC127, PRC255, PRC511,\n\n                                    PRC1023, PRC1522 };\n\n\n\n    if (!(s->mac_reg[STATUS] & E1000_STATUS_LU)) {\n\n        return -1;\n\n    }\n\n\n\n    if (!(s->mac_reg[RCTL] & E1000_RCTL_EN)) {\n\n        return -1;\n\n    }\n\n\n\n    /* Pad to minimum Ethernet frame length */\n\n    if (size < sizeof(min_buf)) {\n\n        iov_to_buf(iov, iovcnt, 0, min_buf, size);\n\n        memset(&min_buf[size], 0, sizeof(min_buf) - size);\n\n        inc_reg_if_not_full(s, RUC);\n\n        min_iov.iov_base = filter_buf = min_buf;\n\n        min_iov.iov_len = size = sizeof(min_buf);\n\n        iovcnt = 1;\n\n        iov = &min_iov;\n\n    } else if (iov->iov_len < MAXIMUM_ETHERNET_HDR_LEN) {\n\n        /* This is very unlikely, but may happen. */\n\n        iov_to_buf(iov, iovcnt, 0, min_buf, MAXIMUM_ETHERNET_HDR_LEN);\n\n        filter_buf = min_buf;\n\n    }\n\n\n\n    /* Discard oversized packets if !LPE and !SBP. */\n\n    if ((size > MAXIMUM_ETHERNET_LPE_SIZE ||\n\n        (size > MAXIMUM_ETHERNET_VLAN_SIZE\n\n        && !(s->mac_reg[RCTL] & E1000_RCTL_LPE)))\n\n        && !(s->mac_reg[RCTL] & E1000_RCTL_SBP)) {\n\n        inc_reg_if_not_full(s, ROC);\n\n        return size;\n\n    }\n\n\n\n    if (!receive_filter(s, filter_buf, size)) {\n\n        return size;\n\n    }\n\n\n\n    if (vlan_enabled(s) && is_vlan_packet(s, filter_buf)) {\n\n        vlan_special = cpu_to_le16(be16_to_cpup((uint16_t *)(filter_buf\n\n                                                                + 14)));\n\n        iov_ofs = 4;\n\n        if (filter_buf == iov->iov_base) {\n\n            memmove(filter_buf + 4, filter_buf, 12);\n\n        } else {\n\n            iov_from_buf(iov, iovcnt, 4, filter_buf, 12);\n\n            while (iov->iov_len <= iov_ofs) {\n\n                iov_ofs -= iov->iov_len;\n\n                iov++;\n\n            }\n\n        }\n\n        vlan_status = E1000_RXD_STAT_VP;\n\n        size -= 4;\n\n    }\n\n\n\n    rdh_start = s->mac_reg[RDH];\n\n    desc_offset = 0;\n\n    total_size = size + fcs_len(s);\n\n    if (!e1000_has_rxbufs(s, total_size)) {\n\n            set_ics(s, 0, E1000_ICS_RXO);\n\n            return -1;\n\n    }\n\n    do {\n\n        desc_size = total_size - desc_offset;\n\n        if (desc_size > s->rxbuf_size) {\n\n            desc_size = s->rxbuf_size;\n\n        }\n\n        base = rx_desc_base(s) + sizeof(desc) * s->mac_reg[RDH];\n\n        pci_dma_read(d, base, &desc, sizeof(desc));\n\n        desc.special = vlan_special;\n\n        desc.status |= (vlan_status | E1000_RXD_STAT_DD);\n\n        if (desc.buffer_addr) {\n\n            if (desc_offset < size) {\n\n                size_t iov_copy;\n\n                hwaddr ba = le64_to_cpu(desc.buffer_addr);\n\n                size_t copy_size = size - desc_offset;\n\n                if (copy_size > s->rxbuf_size) {\n\n                    copy_size = s->rxbuf_size;\n\n                }\n\n                do {\n\n                    iov_copy = MIN(copy_size, iov->iov_len - iov_ofs);\n\n                    pci_dma_write(d, ba, iov->iov_base + iov_ofs, iov_copy);\n\n                    copy_size -= iov_copy;\n\n                    ba += iov_copy;\n\n                    iov_ofs += iov_copy;\n\n                    if (iov_ofs == iov->iov_len) {\n\n                        iov++;\n\n                        iov_ofs = 0;\n\n                    }\n\n                } while (copy_size);\n\n            }\n\n            desc_offset += desc_size;\n\n            desc.length = cpu_to_le16(desc_size);\n\n            if (desc_offset >= total_size) {\n\n                desc.status |= E1000_RXD_STAT_EOP | E1000_RXD_STAT_IXSM;\n\n            } else {\n\n                /* Guest zeroing out status is not a hardware requirement.\n\n                   Clear EOP in case guest didn't do it. */\n\n                desc.status &= ~E1000_RXD_STAT_EOP;\n\n            }\n\n        } else { // as per intel docs; skip descriptors with null buf addr\n\n            DBGOUT(RX, \"Null RX descriptor!!\\n\");\n\n        }\n\n        pci_dma_write(d, base, &desc, sizeof(desc));\n\n\n\n        if (++s->mac_reg[RDH] * sizeof(desc) >= s->mac_reg[RDLEN])\n\n            s->mac_reg[RDH] = 0;\n\n        /* see comment in start_xmit; same here */\n\n        if (s->mac_reg[RDH] == rdh_start) {\n\n            DBGOUT(RXERR, \"RDH wraparound @%x, RDT %x, RDLEN %x\\n\",\n\n                   rdh_start, s->mac_reg[RDT], s->mac_reg[RDLEN]);\n\n            set_ics(s, 0, E1000_ICS_RXO);\n\n            return -1;\n\n        }\n\n    } while (desc_offset < total_size);\n\n\n\n    increase_size_stats(s, PRCregs, total_size);\n\n    inc_reg_if_not_full(s, TPR);\n\n    s->mac_reg[GPRC] = s->mac_reg[TPR];\n\n    /* TOR - Total Octets Received:\n\n     * This register includes bytes received in a packet from the <Destination\n\n     * Address> field through the <CRC> field, inclusively.\n\n     * Always include FCS length (4) in size.\n\n     */\n\n    grow_8reg_if_not_full(s, TORL, size+4);\n\n    s->mac_reg[GORCL] = s->mac_reg[TORL];\n\n    s->mac_reg[GORCH] = s->mac_reg[TORH];\n\n\n\n    n = E1000_ICS_RXT0;\n\n    if ((rdt = s->mac_reg[RDT]) < s->mac_reg[RDH])\n\n        rdt += s->mac_reg[RDLEN] / sizeof(desc);\n\n    if (((rdt - s->mac_reg[RDH]) * sizeof(desc)) <= s->mac_reg[RDLEN] >>\n\n        s->rxbuf_min_shift)\n\n        n |= E1000_ICS_RXDMT0;\n\n\n\n    set_ics(s, 0, n);\n\n\n\n    return size;\n\n}\n", "idx": 24906}
{"project": "qemu", "commit_id": "9db51b4d64ded01536b3851a5a50e484ac2f7899", "target": 1, "func": "static void close_peer_eventfds(IVShmemState *s, int posn)\n\n{\n\n    int i, n;\n\n\n\n    if (!ivshmem_has_feature(s, IVSHMEM_IOEVENTFD)) {\n\n        return;\n\n    }\n\n    if (posn < 0 || posn >= s->nb_peers) {\n\n        error_report(\"invalid peer %d\", posn);\n\n        return;\n\n    }\n\n\n\n    n = s->peers[posn].nb_eventfds;\n\n\n\n    memory_region_transaction_begin();\n\n    for (i = 0; i < n; i++) {\n\n        ivshmem_del_eventfd(s, posn, i);\n\n    }\n\n    memory_region_transaction_commit();\n\n    for (i = 0; i < n; i++) {\n\n        event_notifier_cleanup(&s->peers[posn].eventfds[i]);\n\n    }\n\n\n\n    g_free(s->peers[posn].eventfds);\n\n    s->peers[posn].nb_eventfds = 0;\n\n}\n", "idx": 24907}
{"project": "qemu", "commit_id": "f689d2811a36894618087e1e2cc3ade78e758e94", "target": 1, "func": "static void pci_ivshmem_exit(PCIDevice *dev)\n\n{\n\n    IVShmemState *s = IVSHMEM(dev);\n\n    int i;\n\n\n\n    fifo8_destroy(&s->incoming_fifo);\n\n\n\n    if (s->migration_blocker) {\n\n        migrate_del_blocker(s->migration_blocker);\n\n        error_free(s->migration_blocker);\n\n    }\n\n\n\n    if (s->shm_fd >= 0) {\n\n        void *addr = memory_region_get_ram_ptr(&s->ivshmem);\n\n\n\n        vmstate_unregister_ram(&s->ivshmem, DEVICE(dev));\n\n        memory_region_del_subregion(&s->bar, &s->ivshmem);\n\n\n\n        if (munmap(addr, s->ivshmem_size) == -1) {\n\n            error_report(\"Failed to munmap shared memory %s\", strerror(errno));\n\n        }\n\n    }\n\n\n\n    if (s->eventfd_chr) {\n\n        for (i = 0; i < s->vectors; i++) {\n\n            if (s->eventfd_chr[i]) {\n\n                qemu_chr_free(s->eventfd_chr[i]);\n\n            }\n\n        }\n\n        g_free(s->eventfd_chr);\n\n    }\n\n\n\n    if (s->peers) {\n\n        for (i = 0; i < s->nb_peers; i++) {\n\n            close_peer_eventfds(s, i);\n\n        }\n\n        g_free(s->peers);\n\n    }\n\n\n\n    if (ivshmem_has_feature(s, IVSHMEM_MSI)) {\n\n        msix_uninit_exclusive_bar(dev);\n\n    }\n\n\n\n    g_free(s->eventfd_table);\n\n}\n", "idx": 24908}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void alpha_cpu_class_init(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(oc);\n\n    AlphaCPUClass *acc = ALPHA_CPU_CLASS(oc);\n\n\n\n    acc->parent_realize = dc->realize;\n\n    dc->realize = alpha_cpu_realizefn;\n\n\n\n    cc->class_by_name = alpha_cpu_class_by_name;\n\n    cc->has_work = alpha_cpu_has_work;\n\n    cc->do_interrupt = alpha_cpu_do_interrupt;\n\n    cc->cpu_exec_interrupt = alpha_cpu_exec_interrupt;\n\n    cc->dump_state = alpha_cpu_dump_state;\n\n    cc->set_pc = alpha_cpu_set_pc;\n\n    cc->gdb_read_register = alpha_cpu_gdb_read_register;\n\n    cc->gdb_write_register = alpha_cpu_gdb_write_register;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = alpha_cpu_handle_mmu_fault;\n\n#else\n\n    cc->do_unassigned_access = alpha_cpu_unassigned_access;\n\n    cc->do_unaligned_access = alpha_cpu_do_unaligned_access;\n\n    cc->get_phys_page_debug = alpha_cpu_get_phys_page_debug;\n\n    dc->vmsd = &vmstate_alpha_cpu;\n\n#endif\n\n    cc->disas_set_info = alpha_cpu_disas_set_info;\n\n\n\n    cc->gdb_num_core_regs = 67;\n\n\n\n    /*\n\n     * Reason: alpha_cpu_initfn() calls cpu_exec_init(), which saves\n\n     * the object in cpus -> dangling pointer after final\n\n     * object_unref().\n\n     */\n\n    dc->cannot_destroy_with_object_finalize_yet = true;\n\n}\n", "idx": 24916}
{"project": "qemu", "commit_id": "c9c3c80af71dd2b7813d1ada9b14cb51df584221", "target": 1, "func": "static void rtas_ibm_write_pci_config(sPAPREnvironment *spapr,\n\n                                      uint32_t token, uint32_t nargs,\n\n                                      target_ulong args,\n\n                                      uint32_t nret, target_ulong rets)\n\n{\n\n    uint32_t val, size, addr;\n\n    uint64_t buid = ((uint64_t)rtas_ld(args, 1) << 32) | rtas_ld(args, 2);\n\n    PCIDevice *dev = find_dev(spapr, buid, rtas_ld(args, 0));\n\n\n\n    if (!dev) {\n\n        rtas_st(rets, 0, -1);\n\n        return;\n\n    }\n\n    val = rtas_ld(args, 4);\n\n    size = rtas_ld(args, 3);\n\n    addr = rtas_pci_cfgaddr(rtas_ld(args, 0));\n\n    pci_default_write_config(dev, addr, val, size);\n\n    rtas_st(rets, 0, 0);\n\n}\n", "idx": 24917}
{"project": "qemu", "commit_id": "faadf50e2962dd54175647a80bd6fc4319c91973", "target": 1, "func": "static void init_proc_601 (CPUPPCState *env)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_spr_601(env);\n\n    /* Hardware implementation registers */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID1, \"HID1\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_601_HID2, \"HID2\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_601_HID5, \"HID5\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_601_HID15, \"HID15\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Memory management */\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->nb_tlb = 64;\n\n    env->nb_ways = 2;\n\n    env->id_tlbs = 0;\n\n#endif\n\n    init_excp_601(env);\n\n    env->dcache_line_size = 64;\n\n    env->icache_line_size = 64;\n\n    /* XXX: TODO: allocate internal IRQ controller */\n\n}\n", "idx": 24918}
{"project": "qemu", "commit_id": "27915efb974999dd256a6c432a17432d9d84e606", "target": 1, "func": "static int virtio_9p_device_init(VirtIODevice *vdev)\n\n{\n\n    V9fsState *s = VIRTIO_9P(vdev);\n\n    int i, len;\n\n    struct stat stat;\n\n    FsDriverEntry *fse;\n\n    V9fsPath path;\n\n\n\n    virtio_init(VIRTIO_DEVICE(s), \"virtio-9p\", VIRTIO_ID_9P,\n\n                sizeof(struct virtio_9p_config) + MAX_TAG_LEN);\n\n\n\n    /* initialize pdu allocator */\n\n    QLIST_INIT(&s->free_list);\n\n    QLIST_INIT(&s->active_list);\n\n    for (i = 0; i < (MAX_REQ - 1); i++) {\n\n        QLIST_INSERT_HEAD(&s->free_list, &s->pdus[i], next);\n\n    }\n\n\n\n    s->vq = virtio_add_queue(vdev, MAX_REQ, handle_9p_output);\n\n\n\n    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);\n\n\n\n    if (!fse) {\n\n        /* We don't have a fsdev identified by fsdev_id */\n\n        fprintf(stderr, \"Virtio-9p device couldn't find fsdev with the \"\n\n                \"id = %s\\n\",\n\n                s->fsconf.fsdev_id ? s->fsconf.fsdev_id : \"NULL\");\n\n        goto out;\n\n    }\n\n\n\n    if (!s->fsconf.tag) {\n\n        /* we haven't specified a mount_tag */\n\n        fprintf(stderr, \"fsdev with id %s needs mount_tag arguments\\n\",\n\n                s->fsconf.fsdev_id);\n\n        goto out;\n\n    }\n\n\n\n    s->ctx.export_flags = fse->export_flags;\n\n    s->ctx.fs_root = g_strdup(fse->path);\n\n    s->ctx.exops.get_st_gen = NULL;\n\n    len = strlen(s->fsconf.tag);\n\n    if (len > MAX_TAG_LEN - 1) {\n\n        fprintf(stderr, \"mount tag '%s' (%d bytes) is longer than \"\n\n                \"maximum (%d bytes)\", s->fsconf.tag, len, MAX_TAG_LEN - 1);\n\n        goto out;\n\n    }\n\n\n\n    s->tag = g_strdup(s->fsconf.tag);\n\n    s->ctx.uid = -1;\n\n\n\n    s->ops = fse->ops;\n\n    s->config_size = sizeof(struct virtio_9p_config) + len;\n\n    s->fid_list = NULL;\n\n    qemu_co_rwlock_init(&s->rename_lock);\n\n\n\n    if (s->ops->init(&s->ctx) < 0) {\n\n        fprintf(stderr, \"Virtio-9p Failed to initialize fs-driver with id:%s\"\n\n                \" and export path:%s\\n\", s->fsconf.fsdev_id, s->ctx.fs_root);\n\n        goto out;\n\n    }\n\n    if (v9fs_init_worker_threads() < 0) {\n\n        fprintf(stderr, \"worker thread initialization failed\\n\");\n\n        goto out;\n\n    }\n\n\n\n    /*\n\n     * Check details of export path, We need to use fs driver\n\n     * call back to do that. Since we are in the init path, we don't\n\n     * use co-routines here.\n\n     */\n\n    v9fs_path_init(&path);\n\n    if (s->ops->name_to_path(&s->ctx, NULL, \"/\", &path) < 0) {\n\n        fprintf(stderr,\n\n                \"error in converting name to path %s\", strerror(errno));\n\n        goto out;\n\n    }\n\n    if (s->ops->lstat(&s->ctx, &path, &stat)) {\n\n        fprintf(stderr, \"share path %s does not exist\\n\", fse->path);\n\n        goto out;\n\n    } else if (!S_ISDIR(stat.st_mode)) {\n\n        fprintf(stderr, \"share path %s is not a directory\\n\", fse->path);\n\n        goto out;\n\n    }\n\n    v9fs_path_free(&path);\n\n\n\n    return 0;\n\nout:\n\n    g_free(s->ctx.fs_root);\n\n    g_free(s->tag);\n\n    virtio_cleanup(vdev);\n\n    v9fs_path_free(&path);\n\n\n\n    return -1;\n\n\n\n}\n", "idx": 24921}
{"project": "qemu", "commit_id": "f50159fa9b5a0ad82e30c123643ec39a1df81d9a", "target": 0, "func": "static int vhdx_create(const char *filename, QEMUOptionParameter *options,\n\n                       Error **errp)\n\n{\n\n    int ret = 0;\n\n    uint64_t image_size = (uint64_t) 2 * GiB;\n\n    uint32_t log_size   = 1 * MiB;\n\n    uint32_t block_size = 0;\n\n    uint64_t signature;\n\n    uint64_t metadata_offset;\n\n    bool use_zero_blocks = false;\n\n\n\n    gunichar2 *creator = NULL;\n\n    glong creator_items;\n\n    BlockDriverState *bs;\n\n    const char *type = NULL;\n\n    VHDXImageType image_type;\n\n    Error *local_err = NULL;\n\n\n\n    while (options && options->name) {\n\n        if (!strcmp(options->name, BLOCK_OPT_SIZE)) {\n\n            image_size = options->value.n;\n\n        } else if (!strcmp(options->name, VHDX_BLOCK_OPT_LOG_SIZE)) {\n\n            log_size = options->value.n;\n\n        } else if (!strcmp(options->name, VHDX_BLOCK_OPT_BLOCK_SIZE)) {\n\n            block_size = options->value.n;\n\n        } else if (!strcmp(options->name, BLOCK_OPT_SUBFMT)) {\n\n            type = options->value.s;\n\n        } else if (!strcmp(options->name, VHDX_BLOCK_OPT_ZERO)) {\n\n            use_zero_blocks = options->value.n != 0;\n\n        }\n\n        options++;\n\n    }\n\n\n\n    if (image_size > VHDX_MAX_IMAGE_SIZE) {\n\n        error_setg_errno(errp, EINVAL, \"Image size too large; max of 64TB\");\n\n        ret = -EINVAL;\n\n        goto exit;\n\n    }\n\n\n\n    if (type == NULL) {\n\n        type = \"dynamic\";\n\n    }\n\n\n\n    if (!strcmp(type, \"dynamic\")) {\n\n        image_type = VHDX_TYPE_DYNAMIC;\n\n    } else if (!strcmp(type, \"fixed\")) {\n\n        image_type = VHDX_TYPE_FIXED;\n\n    } else if (!strcmp(type, \"differencing\")) {\n\n        error_setg_errno(errp, ENOTSUP,\n\n                         \"Differencing files not yet supported\");\n\n        ret = -ENOTSUP;\n\n        goto exit;\n\n    } else {\n\n        ret = -EINVAL;\n\n        goto exit;\n\n    }\n\n\n\n    /* These are pretty arbitrary, and mainly designed to keep the BAT\n\n     * size reasonable to load into RAM */\n\n    if (block_size == 0) {\n\n        if (image_size > 32 * TiB) {\n\n            block_size = 64 * MiB;\n\n        } else if (image_size > (uint64_t) 100 * GiB) {\n\n            block_size = 32 * MiB;\n\n        } else if (image_size > 1 * GiB) {\n\n            block_size = 16 * MiB;\n\n        } else {\n\n            block_size = 8 * MiB;\n\n        }\n\n    }\n\n\n\n\n\n    /* make the log size close to what was specified, but must be\n\n     * min 1MB, and multiple of 1MB */\n\n    log_size = ROUND_UP(log_size, MiB);\n\n\n\n    block_size = ROUND_UP(block_size, MiB);\n\n    block_size = block_size > VHDX_BLOCK_SIZE_MAX ? VHDX_BLOCK_SIZE_MAX :\n\n                                                    block_size;\n\n\n\n    ret = bdrv_create_file(filename, options, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        goto exit;\n\n    }\n\n\n\n    ret = bdrv_file_open(&bs, filename, NULL, NULL, BDRV_O_RDWR, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        goto exit;\n\n    }\n\n\n\n    /* Create (A) */\n\n\n\n    /* The creator field is optional, but may be useful for\n\n     * debugging / diagnostics */\n\n    creator = g_utf8_to_utf16(\"QEMU v\" QEMU_VERSION, -1, NULL,\n\n                              &creator_items, NULL);\n\n    signature = cpu_to_le64(VHDX_FILE_SIGNATURE);\n\n    bdrv_pwrite(bs, VHDX_FILE_ID_OFFSET, &signature, sizeof(signature));\n\n    if (ret < 0) {\n\n        goto delete_and_exit;\n\n    }\n\n    if (creator) {\n\n        bdrv_pwrite(bs, VHDX_FILE_ID_OFFSET + sizeof(signature), creator,\n\n                    creator_items * sizeof(gunichar2));\n\n        if (ret < 0) {\n\n            goto delete_and_exit;\n\n        }\n\n    }\n\n\n\n\n\n    /* Creates (B),(C) */\n\n    ret = vhdx_create_new_headers(bs, image_size, log_size);\n\n    if (ret < 0) {\n\n        goto delete_and_exit;\n\n    }\n\n\n\n    /* Creates (D),(E),(G) explicitly. (F) created as by-product */\n\n    ret = vhdx_create_new_region_table(bs, image_size, block_size, 512,\n\n                                       log_size, use_zero_blocks, image_type,\n\n                                       &metadata_offset);\n\n    if (ret < 0) {\n\n        goto delete_and_exit;\n\n    }\n\n\n\n    /* Creates (H) */\n\n    ret = vhdx_create_new_metadata(bs, image_size, block_size, 512,\n\n                                   metadata_offset, image_type);\n\n    if (ret < 0) {\n\n        goto delete_and_exit;\n\n    }\n\n\n\n\n\n\n\ndelete_and_exit:\n\n    bdrv_unref(bs);\n\nexit:\n\n    g_free(creator);\n\n    return ret;\n\n}\n", "idx": 24922}
{"project": "qemu", "commit_id": "06cc5e2b2d01cb778c966e1b4135062556b3b054", "target": 0, "func": "static int zero_single_l2(BlockDriverState *bs, uint64_t offset,\n\n                          uint64_t nb_clusters, int flags)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t *l2_table;\n\n    int l2_index;\n\n    int ret;\n\n    int i;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* Limit nb_clusters to one L2 table */\n\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n    assert(nb_clusters <= INT_MAX);\n\n\n\n    for (i = 0; i < nb_clusters; i++) {\n\n        uint64_t old_offset;\n\n\n\n        old_offset = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        /* Update L2 entries */\n\n        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);\n\n        if (old_offset & QCOW_OFLAG_COMPRESSED || flags & BDRV_REQ_MAY_UNMAP) {\n\n            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);\n\n            qcow2_free_any_clusters(bs, old_offset, 1, QCOW2_DISCARD_REQUEST);\n\n        } else {\n\n            l2_table[l2_index + i] |= cpu_to_be64(QCOW_OFLAG_ZERO);\n\n        }\n\n    }\n\n\n\n    qcow2_cache_put(bs, s->l2_table_cache, (void **) &l2_table);\n\n\n\n    return nb_clusters;\n\n}\n", "idx": 24923}
{"project": "qemu", "commit_id": "1b85898025c4cd95dce673d15e67e60e98e91731", "target": 0, "func": "static int megasas_dcmd_set_properties(MegasasState *s, MegasasCmd *cmd)\n\n{\n\n    struct mfi_ctrl_props info;\n\n    size_t dcmd_size = sizeof(info);\n\n\n\n    if (cmd->iov_size < dcmd_size) {\n\n        trace_megasas_dcmd_invalid_xfer_len(cmd->index, cmd->iov_size,\n\n                                            dcmd_size);\n\n        return MFI_STAT_INVALID_PARAMETER;\n\n    }\n\n    dma_buf_write((uint8_t *)&info, cmd->iov_size, &cmd->qsg);\n\n    trace_megasas_dcmd_unsupported(cmd->index, cmd->iov_size);\n\n    return MFI_STAT_OK;\n\n}\n", "idx": 24924}
{"project": "qemu", "commit_id": "3c529d935923a70519557d420db1d5a09a65086a", "target": 0, "func": "static int fd_open(BlockDriverState *bs)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    int last_media_present;\n\n\n\n    if (s->type != FTYPE_FD)\n\n        return 0;\n\n    last_media_present = (s->fd >= 0);\n\n    if (s->fd >= 0 &&\n\n        (qemu_get_clock(rt_clock) - s->fd_open_time) >= FD_OPEN_TIMEOUT) {\n\n        close(s->fd);\n\n        s->fd = -1;\n\n        raw_close_fd_pool(s);\n\n#ifdef DEBUG_FLOPPY\n\n        printf(\"Floppy closed\\n\");\n\n#endif\n\n    }\n\n    if (s->fd < 0) {\n\n        if (s->fd_got_error &&\n\n            (qemu_get_clock(rt_clock) - s->fd_error_time) < FD_OPEN_TIMEOUT) {\n\n#ifdef DEBUG_FLOPPY\n\n            printf(\"No floppy (open delayed)\\n\");\n\n#endif\n\n            return -EIO;\n\n        }\n\n        s->fd = open(bs->filename, s->fd_open_flags);\n\n        if (s->fd < 0) {\n\n            s->fd_error_time = qemu_get_clock(rt_clock);\n\n            s->fd_got_error = 1;\n\n            if (last_media_present)\n\n                s->fd_media_changed = 1;\n\n#ifdef DEBUG_FLOPPY\n\n            printf(\"No floppy\\n\");\n\n#endif\n\n            return -EIO;\n\n        }\n\n#ifdef DEBUG_FLOPPY\n\n        printf(\"Floppy opened\\n\");\n\n#endif\n\n    }\n\n    if (!last_media_present)\n\n        s->fd_media_changed = 1;\n\n    s->fd_open_time = qemu_get_clock(rt_clock);\n\n    s->fd_got_error = 0;\n\n    return 0;\n\n}\n", "idx": 24925}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void qdev_print(Monitor *mon, DeviceState *dev, int indent)\n\n{\n\n    BusState *child;\n\n    qdev_printf(\"dev: %s, id \\\"%s\\\"\\n\", dev->info->name,\n\n                dev->id ? dev->id : \"\");\n\n    indent += 2;\n\n    if (dev->num_gpio_in) {\n\n        qdev_printf(\"gpio-in %d\\n\", dev->num_gpio_in);\n\n    }\n\n    if (dev->num_gpio_out) {\n\n        qdev_printf(\"gpio-out %d\\n\", dev->num_gpio_out);\n\n    }\n\n    qdev_print_props(mon, dev, dev->info->props, \"dev\", indent);\n\n    qdev_print_props(mon, dev, dev->parent_bus->info->props, \"bus\", indent);\n\n    if (dev->parent_bus->info->print_dev)\n\n        dev->parent_bus->info->print_dev(mon, dev, indent);\n\n    LIST_FOREACH(child, &dev->child_bus, sibling) {\n\n        qbus_print(mon, child, indent);\n\n    }\n\n}\n", "idx": 24926}
{"project": "qemu", "commit_id": "734a77584ae13d36113a7a7cd8b54beb49a8a48e", "target": 0, "func": "static int qcow2_load_vmstate(BlockDriverState *bs, QEMUIOVector *qiov,\n\n                              int64_t pos)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    bool zero_beyond_eof = bs->zero_beyond_eof;\n\n    int ret;\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_VMSTATE_LOAD);\n\n    bs->zero_beyond_eof = false;\n\n    ret = bdrv_preadv(bs, qcow2_vm_state_offset(s) + pos, qiov);\n\n    bs->zero_beyond_eof = zero_beyond_eof;\n\n\n\n    return ret;\n\n}\n", "idx": 24927}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_acl_insert(qemu_acl *acl,\n\n                    int deny,\n\n                    const char *match,\n\n                    int index)\n\n{\n\n    qemu_acl_entry *entry;\n\n    qemu_acl_entry *tmp;\n\n    int i = 0;\n\n\n\n    if (index <= 0)\n\n        return -1;\n\n    if (index >= acl->nentries)\n\n        return qemu_acl_append(acl, deny, match);\n\n\n\n\n\n    entry = qemu_malloc(sizeof(*entry));\n\n    entry->match = qemu_strdup(match);\n\n    entry->deny = deny;\n\n\n\n    TAILQ_FOREACH(tmp, &acl->entries, next) {\n\n        i++;\n\n        if (i == index) {\n\n            TAILQ_INSERT_BEFORE(tmp, entry, next);\n\n            acl->nentries++;\n\n            break;\n\n        }\n\n    }\n\n\n\n    return i;\n\n}\n", "idx": 24929}
{"project": "qemu", "commit_id": "237d78f8fc62e62f62246883ecf62e44ed35fb80", "target": 0, "func": "int64_t bdrv_get_block_status(BlockDriverState *bs,\n\n                              int64_t sector_num,\n\n                              int nb_sectors, int *pnum,\n\n                              BlockDriverState **file)\n\n{\n\n    return bdrv_get_block_status_above(bs, backing_bs(bs),\n\n                                       sector_num, nb_sectors, pnum, file);\n\n}\n", "idx": 24930}
{"project": "qemu", "commit_id": "ae261c86aaed62e7acddafab8262a2bf286d40b7", "target": 0, "func": "static int vmdk_probe(const uint8_t *buf, int buf_size, const char *filename)\n\n{\n\n    uint32_t magic;\n\n\n\n    if (buf_size < 4)\n\n        return 0;\n\n    magic = be32_to_cpu(*(uint32_t *)buf);\n\n    if (magic == VMDK3_MAGIC ||\n\n        magic == VMDK4_MAGIC) {\n\n        return 100;\n\n    } else {\n\n        const char *p = (const char *)buf;\n\n        const char *end = p + buf_size;\n\n        while (p < end) {\n\n            if (*p == '#') {\n\n                /* skip comment line */\n\n                while (p < end && *p != '\\n') {\n\n                    p++;\n\n                }\n\n                p++;\n\n                continue;\n\n            }\n\n            if (*p == ' ') {\n\n                while (p < end && *p == ' ') {\n\n                    p++;\n\n                }\n\n                /* skip '\\r' if windows line endings used. */\n\n                if (p < end && *p == '\\r') {\n\n                    p++;\n\n                }\n\n                /* only accept blank lines before 'version=' line */\n\n                if (p == end || *p != '\\n') {\n\n                    return 0;\n\n                }\n\n                p++;\n\n                continue;\n\n            }\n\n            if (end - p >= strlen(\"version=X\\n\")) {\n\n                if (strncmp(\"version=1\\n\", p, strlen(\"version=1\\n\")) == 0 ||\n\n                    strncmp(\"version=2\\n\", p, strlen(\"version=2\\n\")) == 0) {\n\n                    return 100;\n\n                }\n\n            }\n\n            if (end - p >= strlen(\"version=X\\r\\n\")) {\n\n                if (strncmp(\"version=1\\r\\n\", p, strlen(\"version=1\\r\\n\")) == 0 ||\n\n                    strncmp(\"version=2\\r\\n\", p, strlen(\"version=2\\r\\n\")) == 0) {\n\n                    return 100;\n\n                }\n\n            }\n\n            return 0;\n\n        }\n\n        return 0;\n\n    }\n\n}\n", "idx": 24931}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static int write_elf64_note(DumpState *s)\n\n{\n\n    Elf64_Phdr phdr;\n\n    int endian = s->dump_info.d_endian;\n\n    target_phys_addr_t begin = s->memory_offset - s->note_size;\n\n    int ret;\n\n\n\n    memset(&phdr, 0, sizeof(Elf64_Phdr));\n\n    phdr.p_type = cpu_convert_to_target32(PT_NOTE, endian);\n\n    phdr.p_offset = cpu_convert_to_target64(begin, endian);\n\n    phdr.p_paddr = 0;\n\n    phdr.p_filesz = cpu_convert_to_target64(s->note_size, endian);\n\n    phdr.p_memsz = cpu_convert_to_target64(s->note_size, endian);\n\n    phdr.p_vaddr = 0;\n\n\n\n    ret = fd_write_vmcore(&phdr, sizeof(Elf64_Phdr), s);\n\n    if (ret < 0) {\n\n        dump_error(s, \"dump: failed to write program header table.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24932}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int v9fs_request(V9fsProxy *proxy, int type,\n\n                        void *response, const char *fmt, ...)\n\n{\n\n    dev_t rdev;\n\n    va_list ap;\n\n    int size = 0;\n\n    int retval = 0;\n\n    uint64_t offset;\n\n    ProxyHeader header = { 0, 0};\n\n    struct timespec spec[2];\n\n    int flags, mode, uid, gid;\n\n    V9fsString *name, *value;\n\n    V9fsString *path, *oldpath;\n\n    struct iovec *iovec = NULL, *reply = NULL;\n\n\n\n    qemu_mutex_lock(&proxy->mutex);\n\n\n\n    if (proxy->sockfd == -1) {\n\n        retval = -EIO;\n\n        goto err_out;\n\n    }\n\n    iovec = &proxy->out_iovec;\n\n    reply = &proxy->in_iovec;\n\n    va_start(ap, fmt);\n\n    switch (type) {\n\n    case T_OPEN:\n\n        path = va_arg(ap, V9fsString *);\n\n        flags = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sd\", path, flags);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_OPEN;\n\n        }\n\n        break;\n\n    case T_CREATE:\n\n        path = va_arg(ap, V9fsString *);\n\n        flags = va_arg(ap, int);\n\n        mode = va_arg(ap, int);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sdddd\", path,\n\n                                    flags, mode, uid, gid);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_CREATE;\n\n        }\n\n        break;\n\n    case T_MKNOD:\n\n        path = va_arg(ap, V9fsString *);\n\n        mode = va_arg(ap, int);\n\n        rdev = va_arg(ap, long int);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ddsdq\",\n\n                                    uid, gid, path, mode, rdev);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_MKNOD;\n\n        }\n\n        break;\n\n    case T_MKDIR:\n\n        path = va_arg(ap, V9fsString *);\n\n        mode = va_arg(ap, int);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ddsd\",\n\n                                    uid, gid, path, mode);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_MKDIR;\n\n        }\n\n        break;\n\n    case T_SYMLINK:\n\n        oldpath = va_arg(ap, V9fsString *);\n\n        path = va_arg(ap, V9fsString *);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ddss\",\n\n                                    uid, gid, oldpath, path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_SYMLINK;\n\n        }\n\n        break;\n\n    case T_LINK:\n\n        oldpath = va_arg(ap, V9fsString *);\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ss\",\n\n                                    oldpath, path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LINK;\n\n        }\n\n        break;\n\n    case T_LSTAT:\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LSTAT;\n\n        }\n\n        break;\n\n    case T_READLINK:\n\n        path = va_arg(ap, V9fsString *);\n\n        size = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sd\", path, size);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_READLINK;\n\n        }\n\n        break;\n\n    case T_STATFS:\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_STATFS;\n\n        }\n\n        break;\n\n    case T_CHMOD:\n\n        path = va_arg(ap, V9fsString *);\n\n        mode = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sd\", path, mode);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_CHMOD;\n\n        }\n\n        break;\n\n    case T_CHOWN:\n\n        path = va_arg(ap, V9fsString *);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sdd\", path, uid, gid);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_CHOWN;\n\n        }\n\n        break;\n\n    case T_TRUNCATE:\n\n        path = va_arg(ap, V9fsString *);\n\n        offset = va_arg(ap, uint64_t);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sq\", path, offset);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_TRUNCATE;\n\n        }\n\n        break;\n\n    case T_UTIME:\n\n        path = va_arg(ap, V9fsString *);\n\n        spec[0].tv_sec = va_arg(ap, long);\n\n        spec[0].tv_nsec = va_arg(ap, long);\n\n        spec[1].tv_sec = va_arg(ap, long);\n\n        spec[1].tv_nsec = va_arg(ap, long);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sqqqq\", path,\n\n                                    spec[0].tv_sec, spec[1].tv_nsec,\n\n                                    spec[1].tv_sec, spec[1].tv_nsec);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_UTIME;\n\n        }\n\n        break;\n\n    case T_RENAME:\n\n        oldpath = va_arg(ap, V9fsString *);\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ss\", oldpath, path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_RENAME;\n\n        }\n\n        break;\n\n    case T_REMOVE:\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_REMOVE;\n\n        }\n\n        break;\n\n    case T_LGETXATTR:\n\n        size = va_arg(ap, int);\n\n        path = va_arg(ap, V9fsString *);\n\n        name = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ,\n\n                                    \"dss\", size, path, name);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LGETXATTR;\n\n        }\n\n        break;\n\n    case T_LLISTXATTR:\n\n        size = va_arg(ap, int);\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ds\", size, path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LLISTXATTR;\n\n        }\n\n        break;\n\n    case T_LSETXATTR:\n\n        path = va_arg(ap, V9fsString *);\n\n        name = va_arg(ap, V9fsString *);\n\n        value = va_arg(ap, V9fsString *);\n\n        size = va_arg(ap, int);\n\n        flags = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sssdd\",\n\n                                    path, name, value, size, flags);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LSETXATTR;\n\n        }\n\n        break;\n\n    case T_LREMOVEXATTR:\n\n        path = va_arg(ap, V9fsString *);\n\n        name = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ss\", path, name);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LREMOVEXATTR;\n\n        }\n\n        break;\n\n    case T_GETVERSION:\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_GETVERSION;\n\n        }\n\n        break;\n\n    default:\n\n        error_report(\"Invalid type %d\", type);\n\n        retval = -EINVAL;\n\n        break;\n\n    }\n\n    va_end(ap);\n\n\n\n    if (retval < 0) {\n\n        goto err_out;\n\n    }\n\n\n\n    /* marshal the header details */\n\n    proxy_marshal(iovec, 0, \"dd\", header.type, header.size);\n\n    header.size += PROXY_HDR_SZ;\n\n\n\n    retval = qemu_write_full(proxy->sockfd, iovec->iov_base, header.size);\n\n    if (retval != header.size) {\n\n        goto close_error;\n\n    }\n\n\n\n    switch (type) {\n\n    case T_OPEN:\n\n    case T_CREATE:\n\n        /*\n\n         * A file descriptor is returned as response for\n\n         * T_OPEN,T_CREATE on success\n\n         */\n\n        if (v9fs_receivefd(proxy->sockfd, &retval) < 0) {\n\n            goto close_error;\n\n        }\n\n        break;\n\n    case T_MKNOD:\n\n    case T_MKDIR:\n\n    case T_SYMLINK:\n\n    case T_LINK:\n\n    case T_CHMOD:\n\n    case T_CHOWN:\n\n    case T_RENAME:\n\n    case T_TRUNCATE:\n\n    case T_UTIME:\n\n    case T_REMOVE:\n\n    case T_LSETXATTR:\n\n    case T_LREMOVEXATTR:\n\n        if (v9fs_receive_status(proxy, reply, &retval) < 0) {\n\n            goto close_error;\n\n        }\n\n        break;\n\n    case T_LSTAT:\n\n    case T_READLINK:\n\n    case T_STATFS:\n\n    case T_GETVERSION:\n\n        if (v9fs_receive_response(proxy, type, &retval, response) < 0) {\n\n            goto close_error;\n\n        }\n\n        break;\n\n    case T_LGETXATTR:\n\n    case T_LLISTXATTR:\n\n        if (!size) {\n\n            if (v9fs_receive_status(proxy, reply, &retval) < 0) {\n\n                goto close_error;\n\n            }\n\n        } else {\n\n            if (v9fs_receive_response(proxy, type, &retval, response) < 0) {\n\n                goto close_error;\n\n            }\n\n        }\n\n        break;\n\n    }\n\n\n\nerr_out:\n\n    qemu_mutex_unlock(&proxy->mutex);\n\n    return retval;\n\n\n\nclose_error:\n\n    close(proxy->sockfd);\n\n    proxy->sockfd = -1;\n\n    qemu_mutex_unlock(&proxy->mutex);\n\n    return -EIO;\n\n}\n", "idx": 24933}
{"project": "qemu", "commit_id": "dd65a52e4aa4a0adfedf0ed9a35da1960f359fe1", "target": 0, "func": "void bdrv_append(BlockDriverState *bs_new, BlockDriverState *bs_top)\n\n{\n\n    assert(!bdrv_requests_pending(bs_top));\n\n    assert(!bdrv_requests_pending(bs_new));\n\n\n\n    bdrv_ref(bs_top);\n\n\n\n    change_parent_backing_link(bs_top, bs_new);\n\n    bdrv_set_backing_hd(bs_new, bs_top);\n\n    bdrv_unref(bs_top);\n\n\n\n    /* bs_new is now referenced by its new parents, we don't need the\n\n     * additional reference any more. */\n\n    bdrv_unref(bs_new);\n\n}\n", "idx": 24934}
{"project": "qemu", "commit_id": "24b856ca63f1c72b5043af6b291e7cc35900f4d6", "target": 0, "func": "static int i6300esb_init(PCIDevice *dev)\n\n{\n\n    I6300State *d = DO_UPCAST(I6300State, dev, dev);\n\n    uint8_t *pci_conf;\n\n    int io_mem;\n\n    static CPUReadMemoryFunc * const mem_read[3] = {\n\n        i6300esb_mem_readb,\n\n        i6300esb_mem_readw,\n\n        i6300esb_mem_readl,\n\n    };\n\n    static CPUWriteMemoryFunc * const mem_write[3] = {\n\n        i6300esb_mem_writeb,\n\n        i6300esb_mem_writew,\n\n        i6300esb_mem_writel,\n\n    };\n\n\n\n    i6300esb_debug(\"I6300State = %p\\n\", d);\n\n\n\n    d->timer = qemu_new_timer_ns(vm_clock, i6300esb_timer_expired, d);\n\n    d->previous_reboot_flag = 0;\n\n\n\n    pci_conf = d->dev.config;\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_ESB_9);\n\n    pci_config_set_class(pci_conf, PCI_CLASS_SYSTEM_OTHER);\n\n\n\n    io_mem = cpu_register_io_memory(mem_read, mem_write, d,\n\n                                    DEVICE_NATIVE_ENDIAN);\n\n    pci_register_bar_simple(&d->dev, 0, 0x10, 0, io_mem);\n\n    /* qemu_register_coalesced_mmio (addr, 0x10); ? */\n\n\n\n    return 0;\n\n}\n", "idx": 24935}
{"project": "qemu", "commit_id": "ba41249678f8c1504bf07706ddb0eda0d36cccc2", "target": 0, "func": "static void restore_sigcontext(CPUSH4State *regs, struct target_sigcontext *sc,\n\n                               target_ulong *r0_p)\n\n{\n\n    int i;\n\n\n\n#define COPY(x)         __get_user(regs->x, &sc->sc_##x)\n\n    COPY(gregs[1]);\n\n    COPY(gregs[2]); COPY(gregs[3]);\n\n    COPY(gregs[4]); COPY(gregs[5]);\n\n    COPY(gregs[6]); COPY(gregs[7]);\n\n    COPY(gregs[8]); COPY(gregs[9]);\n\n    COPY(gregs[10]); COPY(gregs[11]);\n\n    COPY(gregs[12]); COPY(gregs[13]);\n\n    COPY(gregs[14]); COPY(gregs[15]);\n\n    COPY(gbr); COPY(mach);\n\n    COPY(macl); COPY(pr);\n\n    COPY(sr); COPY(pc);\n\n#undef COPY\n\n\n\n    for (i=0; i<16; i++) {\n\n        __get_user(regs->fregs[i], &sc->sc_fpregs[i]);\n\n    }\n\n    __get_user(regs->fpscr, &sc->sc_fpscr);\n\n    __get_user(regs->fpul, &sc->sc_fpul);\n\n\n\n    regs->tra = -1;         /* disable syscall checks */\n\n    __get_user(*r0_p, &sc->sc_gregs[0]);\n\n}\n", "idx": 24936}
{"project": "qemu", "commit_id": "0ddf08db22a9ef6b122d8c4cfe5b25d2c2c51962", "target": 0, "func": "NBDExport *nbd_export_new(BlockDriverState *bs, off_t dev_offset,\n\n                          off_t size, uint32_t nbdflags)\n\n{\n\n    NBDExport *exp = g_malloc0(sizeof(NBDExport));\n\n    QSIMPLEQ_INIT(&exp->requests);\n\n    exp->refcount = 1;\n\n    QTAILQ_INIT(&exp->clients);\n\n    exp->bs = bs;\n\n    exp->dev_offset = dev_offset;\n\n    exp->nbdflags = nbdflags;\n\n    exp->size = size == -1 ? bdrv_getlength(bs) : size;\n\n    return exp;\n\n}\n", "idx": 24937}
{"project": "qemu", "commit_id": "2572b37a4751cc967582d7d04f21d9bf97187ae5", "target": 0, "func": "static BlockDriverAIOCB *bdrv_aio_rw_vector(BlockDriverState *bs,\n\n                                            int64_t sector_num,\n\n                                            QEMUIOVector *qiov,\n\n                                            int nb_sectors,\n\n                                            BlockDriverCompletionFunc *cb,\n\n                                            void *opaque,\n\n                                            int is_write)\n\n\n\n{\n\n    BlockDriverAIOCBSync *acb;\n\n\n\n    acb = qemu_aio_get(&bdrv_em_aiocb_info, bs, cb, opaque);\n\n    acb->is_write = is_write;\n\n    acb->qiov = qiov;\n\n    acb->bounce = qemu_blockalign(bs, qiov->size);\n\n    acb->bh = qemu_bh_new(bdrv_aio_bh_cb, acb);\n\n\n\n    if (is_write) {\n\n        qemu_iovec_to_buf(acb->qiov, 0, acb->bounce, qiov->size);\n\n        acb->ret = bs->drv->bdrv_write(bs, sector_num, acb->bounce, nb_sectors);\n\n    } else {\n\n        acb->ret = bs->drv->bdrv_read(bs, sector_num, acb->bounce, nb_sectors);\n\n    }\n\n\n\n    qemu_bh_schedule(acb->bh);\n\n\n\n    return &acb->common;\n\n}\n", "idx": 24938}
{"project": "qemu", "commit_id": "d66b969b0d9c8eefdcbff4b48535b0fe1501d139", "target": 0, "func": "static void vtd_update_iotlb(IntelIOMMUState *s, uint16_t source_id,\n\n                             uint16_t domain_id, hwaddr addr, uint64_t slpte,\n\n                             bool read_flags, bool write_flags)\n\n{\n\n    VTDIOTLBEntry *entry = g_malloc(sizeof(*entry));\n\n    uint64_t *key = g_malloc(sizeof(*key));\n\n    uint64_t gfn = addr >> VTD_PAGE_SHIFT_4K;\n\n\n\n    VTD_DPRINTF(CACHE, \"update iotlb sid 0x%\"PRIx16 \" gpa 0x%\"PRIx64\n\n                \" slpte 0x%\"PRIx64 \" did 0x%\"PRIx16, source_id, addr, slpte,\n\n                domain_id);\n\n    if (g_hash_table_size(s->iotlb) >= VTD_IOTLB_MAX_SIZE) {\n\n        VTD_DPRINTF(CACHE, \"iotlb exceeds size limit, forced to reset\");\n\n        vtd_reset_iotlb(s);\n\n    }\n\n\n\n    entry->gfn = gfn;\n\n    entry->domain_id = domain_id;\n\n    entry->slpte = slpte;\n\n    entry->read_flags = read_flags;\n\n    entry->write_flags = write_flags;\n\n    *key = gfn | ((uint64_t)(source_id) << VTD_IOTLB_SID_SHIFT);\n\n    g_hash_table_replace(s->iotlb, key, entry);\n\n}\n", "idx": 24940}
{"project": "qemu", "commit_id": "bdb11366b9370e97fb436444c697c01fe839dc11", "target": 0, "func": "static void armv7m_nvic_init(SysBusDevice *dev)\n\n{\n\n    nvic_state *s= FROM_SYSBUSGIC(nvic_state, dev);\n\n    CPUState *env;\n\n\n\n    env = qdev_get_prop_ptr(&dev->qdev, \"cpu\");\n\n    gic_init(&s->gic);\n\n    cpu_register_physical_memory(0xe000e000, 0x1000, s->gic.iomemtype);\n\n    s->systick.timer = qemu_new_timer(vm_clock, systick_timer_tick, s);\n\n    if (env->v7m.nvic)\n\n        hw_error(\"CPU can only have one NVIC\\n\");\n\n    env->v7m.nvic = s;\n\n    register_savevm(\"armv7m_nvic\", -1, 1, nvic_save, nvic_load, s);\n\n}\n", "idx": 24941}
{"project": "qemu", "commit_id": "d95704341280fc521dc2b16bbbc5858f6647e2c3", "target": 0, "func": "lookup_scalar(const OptsVisitor *ov, const char *name, Error **errp)\n\n{\n\n    if (ov->repeated_opts == NULL) {\n\n        GQueue *list;\n\n\n\n        /* the last occurrence of any QemuOpt takes effect when queried by name\n\n         */\n\n        list = lookup_distinct(ov, name, errp);\n\n        return list ? g_queue_peek_tail(list) : NULL;\n\n    }\n\n    return g_queue_peek_head(ov->repeated_opts);\n\n}\n", "idx": 24942}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static void hextile_enc_cord(uint8_t *ptr, int x, int y, int w, int h)\n\n{\n\n    ptr[0] = ((x & 0x0F) << 4) | (y & 0x0F);\n\n    ptr[1] = (((w - 1) & 0x0F) << 4) | ((h - 1) & 0x0F);\n\n}\n", "idx": 24943}
{"project": "qemu", "commit_id": "81f099ad3266eede194bcb80f44e9ffe1772f257", "target": 1, "func": "static void vga_screen_dump_common(VGAState *s, const char *filename,\n\n                                   int w, int h)\n\n{\n\n    DisplayState *saved_ds, ds1, *ds = &ds1;\n\n    DisplayChangeListener dcl;\n\n\n\n    /* XXX: this is a little hackish */\n\n    vga_invalidate_display(s);\n\n    saved_ds = s->ds;\n\n\n\n    memset(ds, 0, sizeof(DisplayState));\n\n    memset(&dcl, 0, sizeof(DisplayChangeListener));\n\n    dcl.dpy_update = vga_save_dpy_update;\n\n    dcl.dpy_resize = vga_save_dpy_resize;\n\n    dcl.dpy_refresh = vga_save_dpy_refresh;\n\n    register_displaychangelistener(ds, &dcl);\n\n\n    ds->surface = qemu_create_displaysurface(ds, w, h);\n\n\n\n    s->ds = ds;\n\n    s->graphic_mode = -1;\n\n    vga_update_display(s);\n\n\n\n    ppm_save(filename, ds->surface);\n\n\n\n    qemu_free_displaysurface(ds);\n\n    s->ds = saved_ds;\n\n}", "idx": 24946}
{"project": "qemu", "commit_id": "cae5d3f4b3fbe9b681c0c4046008af424bd1d6a5", "target": 1, "func": "static int ehci_state_execute(EHCIQueue *q)\n\n{\n\n    EHCIPacket *p = QTAILQ_FIRST(&q->packets);\n\n    int again = 0;\n\n\n\n    assert(p != NULL);\n\n    assert(p->qtdaddr == q->qtdaddr);\n\n\n\n    if (ehci_qh_do_overlay(q) != 0) {\n\n        return -1;\n\n    }\n\n\n\n    // TODO verify enough time remains in the uframe as in 4.4.1.1\n\n    // TODO write back ptr to async list when done or out of time\n\n    // TODO Windows does not seem to ever set the MULT field\n\n\n\n    if (!q->async) {\n\n        int transactCtr = get_field(q->qh.epcap, QH_EPCAP_MULT);\n\n        if (!transactCtr) {\n\n            ehci_set_state(q->ehci, q->async, EST_HORIZONTALQH);\n\n            again = 1;\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    if (q->async) {\n\n        ehci_set_usbsts(q->ehci, USBSTS_REC);\n\n    }\n\n\n\n    p->usb_status = ehci_execute(p, \"process\");\n\n    if (p->usb_status == USB_RET_PROCERR) {\n\n        again = -1;\n\n        goto out;\n\n    }\n\n    if (p->usb_status == USB_RET_ASYNC) {\n\n        ehci_flush_qh(q);\n\n        trace_usb_ehci_packet_action(p->queue, p, \"async\");\n\n        p->async = EHCI_ASYNC_INFLIGHT;\n\n        ehci_set_state(q->ehci, q->async, EST_HORIZONTALQH);\n\n        again = (ehci_fill_queue(p) == USB_RET_PROCERR) ? -1 : 1;\n\n        goto out;\n\n    }\n\n\n\n    ehci_set_state(q->ehci, q->async, EST_EXECUTING);\n\n    again = 1;\n\n\n\nout:\n\n    return again;\n\n}\n", "idx": 24947}
{"project": "qemu", "commit_id": "cdd85eb2804018ab46a742ebf64dc5366b9fae73", "target": 1, "func": "static void update_msix_table_msg_data(S390PCIBusDevice *pbdev, uint64_t offset,\n\n                                       uint64_t *data, uint8_t len)\n\n{\n\n    uint32_t val;\n\n    uint8_t *msg_data;\n\n\n\n    if (offset % PCI_MSIX_ENTRY_SIZE != 8) {\n\n        return;\n\n    }\n\n\n\n    if (len != 4) {\n\n        DPRINTF(\"access msix table msg data but len is %d\\n\", len);\n\n        return;\n\n    }\n\n\n\n    msg_data = (uint8_t *)data - offset % PCI_MSIX_ENTRY_SIZE +\n\n               PCI_MSIX_ENTRY_VECTOR_CTRL;\n\n    val = pci_get_long(msg_data) | (pbdev->fid << ZPCI_MSI_VEC_BITS);\n\n    pci_set_long(msg_data, val);\n\n    DPRINTF(\"update msix msg_data to 0x%\" PRIx64 \"\\n\", *data);\n\n}\n", "idx": 24948}
{"project": "qemu", "commit_id": "49fb65c7f985baa56d2964e0a85c1f098e3e2a9d", "target": 1, "func": "static void virtio_scsi_push_event(VirtIOSCSI *s, SCSIDevice *dev,\n\n                                   uint32_t event, uint32_t reason)\n\n{\n\n    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(s);\n\n    VirtIOSCSIReq *req = virtio_scsi_pop_req(s, vs->event_vq);\n\n    VirtIOSCSIEvent *evt;\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n    int in_size;\n\n\n\n    if (!(vdev->status & VIRTIO_CONFIG_S_DRIVER_OK)) {\n\n        return;\n\n    }\n\n\n\n    if (!req) {\n\n        s->events_dropped = true;\n\n        return;\n\n    }\n\n\n\n    if (req->elem.out_num || req->elem.in_num != 1) {\n\n        virtio_scsi_bad_req();\n\n    }\n\n\n\n    if (s->events_dropped) {\n\n        event |= VIRTIO_SCSI_T_EVENTS_MISSED;\n\n        s->events_dropped = false;\n\n    }\n\n\n\n    in_size = req->elem.in_sg[0].iov_len;\n\n    if (in_size < sizeof(VirtIOSCSIEvent)) {\n\n        virtio_scsi_bad_req();\n\n    }\n\n\n\n    evt = req->resp.event;\n\n    memset(evt, 0, sizeof(VirtIOSCSIEvent));\n\n    evt->event = event;\n\n    evt->reason = reason;\n\n    if (!dev) {\n\n        assert(event == VIRTIO_SCSI_T_NO_EVENT);\n\n    } else {\n\n        evt->lun[0] = 1;\n\n        evt->lun[1] = dev->id;\n\n\n\n        /* Linux wants us to keep the same encoding we use for REPORT LUNS.  */\n\n        if (dev->lun >= 256) {\n\n            evt->lun[2] = (dev->lun >> 8) | 0x40;\n\n        }\n\n        evt->lun[3] = dev->lun & 0xFF;\n\n    }\n\n    virtio_scsi_complete_req(req);\n\n}\n", "idx": 24950}
{"project": "qemu", "commit_id": "e12ed72e5c00dd3375b8bd107200e4d7e950276a", "target": 1, "func": "void bitmap_clear(unsigned long *map, long start, long nr)\n{\n    unsigned long *p = map + BIT_WORD(start);\n    const long size = start + nr;\n    int bits_to_clear = BITS_PER_LONG - (start % BITS_PER_LONG);\n    unsigned long mask_to_clear = BITMAP_FIRST_WORD_MASK(start);\n    while (nr - bits_to_clear >= 0) {\n        *p &= ~mask_to_clear;\n        nr -= bits_to_clear;\n        bits_to_clear = BITS_PER_LONG;\n        mask_to_clear = ~0UL;\n        p++;\n    }\n    if (nr) {\n        mask_to_clear &= BITMAP_LAST_WORD_MASK(size);\n        *p &= ~mask_to_clear;\n    }\n}", "idx": 24954}
{"project": "qemu", "commit_id": "27bfd83c336283d1f7a5345ee386c4cd7b80db61", "target": 1, "func": "static inline void tcg_temp_free_internal(int idx)\n{\n    TCGContext *s = &tcg_ctx;\n    TCGTemp *ts;\n    int k;\n    assert(idx >= s->nb_globals && idx < s->nb_temps);\n    ts = &s->temps[idx];\n    assert(ts->temp_allocated != 0);\n    ts->temp_allocated = 0;\n    k = ts->base_type;\n    if (ts->temp_local)\n        k += TCG_TYPE_COUNT;\n    ts->next_free_temp = s->first_free_temp[k];\n    s->first_free_temp[k] = idx;", "idx": 24955}
{"project": "qemu", "commit_id": "6ab3fc32ea640026726bc5f9f4db622d0954fb8a", "target": 1, "func": "static void mcf_uart_do_tx(mcf_uart_state *s)\n\n{\n\n    if (s->tx_enabled && (s->sr & MCF_UART_TxEMP) == 0) {\n\n        if (s->chr)\n\n            qemu_chr_fe_write(s->chr, (unsigned char *)&s->tb, 1);\n\n        s->sr |= MCF_UART_TxEMP;\n\n    }\n\n    if (s->tx_enabled) {\n\n        s->sr |= MCF_UART_TxRDY;\n\n    } else {\n\n        s->sr &= ~MCF_UART_TxRDY;\n\n    }\n\n}\n", "idx": 24956}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void mainstone_common_init(MemoryRegion *address_space_mem,\n\n                                  MachineState *machine,\n\n                                  enum mainstone_model_e model, int arm_id)\n\n{\n\n    uint32_t sector_len = 256 * 1024;\n\n    hwaddr mainstone_flash_base[] = { MST_FLASH_0, MST_FLASH_1 };\n\n    PXA2xxState *mpu;\n\n    DeviceState *mst_irq;\n\n    DriveInfo *dinfo;\n\n    int i;\n\n    int be;\n\n    MemoryRegion *rom = g_new(MemoryRegion, 1);\n\n    const char *cpu_model = machine->cpu_model;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"pxa270-c5\";\n\n\n\n    /* Setup CPU & memory */\n\n    mpu = pxa270_init(address_space_mem, mainstone_binfo.ram_size, cpu_model);\n\n    memory_region_init_ram(rom, NULL, \"mainstone.rom\", MAINSTONE_ROM,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(rom);\n\n    memory_region_set_readonly(rom, true);\n\n    memory_region_add_subregion(address_space_mem, 0, rom);\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    /* There are two 32MiB flash devices on the board */\n\n    for (i = 0; i < 2; i ++) {\n\n        dinfo = drive_get(IF_PFLASH, 0, i);\n\n        if (!dinfo) {\n\n            if (qtest_enabled()) {\n\n                break;\n\n            }\n\n            fprintf(stderr, \"Two flash images must be given with the \"\n\n                    \"'pflash' parameter\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        if (!pflash_cfi01_register(mainstone_flash_base[i], NULL,\n\n                                   i ? \"mainstone.flash1\" : \"mainstone.flash0\",\n\n                                   MAINSTONE_FLASH,\n\n                                   blk_by_legacy_dinfo(dinfo),\n\n                                   sector_len, MAINSTONE_FLASH / sector_len,\n\n                                   4, 0, 0, 0, 0, be)) {\n\n            fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    mst_irq = sysbus_create_simple(\"mainstone-fpga\", MST_FPGA_PHYS,\n\n                    qdev_get_gpio_in(mpu->gpio, 0));\n\n\n\n    /* setup keypad */\n\n    pxa27x_register_keypad(mpu->kp, map, 0xe0);\n\n\n\n    /* MMC/SD host */\n\n    pxa2xx_mmci_handlers(mpu->mmc, NULL, qdev_get_gpio_in(mst_irq, MMC_IRQ));\n\n\n\n    pxa2xx_pcmcia_set_irq_cb(mpu->pcmcia[0],\n\n            qdev_get_gpio_in(mst_irq, S0_IRQ),\n\n            qdev_get_gpio_in(mst_irq, S0_CD_IRQ));\n\n    pxa2xx_pcmcia_set_irq_cb(mpu->pcmcia[1],\n\n            qdev_get_gpio_in(mst_irq, S1_IRQ),\n\n            qdev_get_gpio_in(mst_irq, S1_CD_IRQ));\n\n\n\n    smc91c111_init(&nd_table[0], MST_ETH_PHYS,\n\n                    qdev_get_gpio_in(mst_irq, ETHERNET_IRQ));\n\n\n\n    mainstone_binfo.kernel_filename = machine->kernel_filename;\n\n    mainstone_binfo.kernel_cmdline = machine->kernel_cmdline;\n\n    mainstone_binfo.initrd_filename = machine->initrd_filename;\n\n    mainstone_binfo.board_id = arm_id;\n\n    arm_load_kernel(mpu->cpu, &mainstone_binfo);\n\n}\n", "idx": 24958}
{"project": "qemu", "commit_id": "0920a17199d23b3def3a60fa1fbbdeadcdda452d", "target": 1, "func": "Visitor *validate_test_init(TestInputVisitorData *data,\n\n                             const char *json_string, ...)\n\n{\n\n    Visitor *v;\n\n    va_list ap;\n\n\n\n    va_start(ap, json_string);\n\n    data->obj = qobject_from_jsonv(json_string, &ap);\n\n    va_end(ap);\n\n\n\n    g_assert(data->obj != NULL);\n\n\n\n    data->qiv = qmp_input_visitor_new_strict(data->obj);\n\n    g_assert(data->qiv != NULL);\n\n\n\n    v = qmp_input_get_visitor(data->qiv);\n\n    g_assert(v != NULL);\n\n\n\n    return v;\n\n}\n", "idx": 24959}
{"project": "qemu", "commit_id": "07d4e69147b4957e617812206a62a86f03294ad3", "target": 1, "func": "void vmstate_save_state(QEMUFile *f, const VMStateDescription *vmsd,\n\n                        void *opaque, QJSON *vmdesc)\n\n{\n\n    VMStateField *field = vmsd->fields;\n\n\n\n    trace_vmstate_save_state_top(vmsd->name);\n\n\n\n    if (vmsd->pre_save) {\n\n        vmsd->pre_save(opaque);\n\n    }\n\n\n\n    if (vmdesc) {\n\n        json_prop_str(vmdesc, \"vmsd_name\", vmsd->name);\n\n        json_prop_int(vmdesc, \"version\", vmsd->version_id);\n\n        json_start_array(vmdesc, \"fields\");\n\n    }\n\n\n\n    while (field->name) {\n\n        if (!field->field_exists ||\n\n            field->field_exists(opaque, vmsd->version_id)) {\n\n            void *first_elem = opaque + field->offset;\n\n            int i, n_elems = vmstate_n_elems(opaque, field);\n\n            int size = vmstate_size(opaque, field);\n\n            int64_t old_offset, written_bytes;\n\n            QJSON *vmdesc_loop = vmdesc;\n\n\n\n            trace_vmstate_save_state_loop(vmsd->name, field->name, n_elems);\n\n            if (field->flags & VMS_POINTER) {\n\n                first_elem = *(void **)first_elem;\n\n                assert(first_elem  || !n_elems);\n\n            }\n\n            for (i = 0; i < n_elems; i++) {\n\n                void *curr_elem = first_elem + size * i;\n\n\n\n                vmsd_desc_field_start(vmsd, vmdesc_loop, field, i, n_elems);\n\n                old_offset = qemu_ftell_fast(f);\n\n                if (field->flags & VMS_ARRAY_OF_POINTER) {\n\n                    assert(curr_elem);\n\n                    curr_elem = *(void **)curr_elem;\n\n                }\n\n                if (field->flags & VMS_STRUCT) {\n\n                    vmstate_save_state(f, field->vmsd, curr_elem, vmdesc_loop);\n\n                } else {\n\n                    field->info->put(f, curr_elem, size, field, vmdesc_loop);\n\n                }\n\n\n\n                written_bytes = qemu_ftell_fast(f) - old_offset;\n\n                vmsd_desc_field_end(vmsd, vmdesc_loop, field, written_bytes, i);\n\n\n\n                /* Compressed arrays only care about the first element */\n\n                if (vmdesc_loop && vmsd_can_compress(field)) {\n\n                    vmdesc_loop = NULL;\n\n                }\n\n            }\n\n        } else {\n\n            if (field->flags & VMS_MUST_EXIST) {\n\n                error_report(\"Output state validation failed: %s/%s\",\n\n                        vmsd->name, field->name);\n\n                assert(!(field->flags & VMS_MUST_EXIST));\n\n            }\n\n        }\n\n        field++;\n\n    }\n\n\n\n    if (vmdesc) {\n\n        json_end_array(vmdesc);\n\n    }\n\n\n\n    vmstate_subsection_save(f, vmsd, opaque, vmdesc);\n\n}\n", "idx": 24960}
{"project": "qemu", "commit_id": "bb639f829f139ddc83325b3b6825f93096ee44f1", "target": 1, "func": "static void ahci_irq_raise(AHCIState *s, AHCIDevice *dev)\n\n{\n\n    AHCIPCIState *d = container_of(s, AHCIPCIState, ahci);\n\n    PCIDevice *pci_dev =\n\n        (PCIDevice *)object_dynamic_cast(OBJECT(d), TYPE_PCI_DEVICE);\n\n\n\n    DPRINTF(0, \"raise irq\\n\");\n\n\n\n    if (pci_dev && msi_enabled(pci_dev)) {\n\n        msi_notify(pci_dev, 0);\n\n    } else {\n\n        qemu_irq_raise(s->irq);\n\n    }\n\n}\n", "idx": 24965}
{"project": "qemu", "commit_id": "8b3b720620a1137a1b794fc3ed64734236f94e06", "target": 1, "func": "static int qcow2_truncate(BlockDriverState *bs, int64_t offset)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int ret, new_l1_size;\n\n\n\n    if (offset & 511) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* cannot proceed if image has snapshots */\n\n    if (s->nb_snapshots) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    /* shrinking is currently not supported */\n\n    if (offset < bs->total_sectors * 512) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    new_l1_size = size_to_l1(s, offset);\n\n    ret = qcow2_grow_l1_table(bs, new_l1_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* write updated header.size */\n\n    offset = cpu_to_be64(offset);\n\n    ret = bdrv_pwrite(bs->file, offsetof(QCowHeader, size),\n\n                      &offset, sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    s->l1_vm_state_index = new_l1_size;\n\n    return 0;\n\n}\n", "idx": 24967}
{"project": "qemu", "commit_id": "a1f0cce2ac0243572ff72aa561da67fe3766a395", "target": 1, "func": "static void scsi_req_set_status(SCSIDiskReq *r, int status, int sense_code)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n\n\n    r->req.status = status;\n\n    scsi_disk_set_sense(s, sense_code);\n\n}\n", "idx": 24968}
{"project": "qemu", "commit_id": "12f8def0e02232d7c6416ad9b66640f973c531d1", "target": 1, "func": "int qemu_mutex_trylock(QemuMutex *mutex)\n\n{\n\n    int owned;\n\n\n\n    owned = TryEnterCriticalSection(&mutex->lock);\n\n    if (owned) {\n\n        assert(mutex->owner == 0);\n\n        mutex->owner = GetCurrentThreadId();\n\n    }\n\n    return !owned;\n\n}\n", "idx": 24969}
{"project": "qemu", "commit_id": "010ec6293409f10b88631c36145944b9c3277ce1", "target": 1, "func": "static void nic_reset(void *opaque)\n\n{\n\n    EEPRO100State *s = opaque;\n\n    TRACE(OTHER, logout(\"%p\\n\", s));\n\n    /* TODO: Clearing of multicast table for selective reset, too? */\n\n    memset(&s->mult[0], 0, sizeof(s->mult));\n\n    nic_selective_reset(s);\n\n}\n", "idx": 24970}
{"project": "qemu", "commit_id": "983bff3530782d51c46c8d7c0e17e2a9dfe5fb77", "target": 1, "func": "static void usb_mtp_object_readdir(MTPState *s, MTPObject *o)\n\n{\n\n    struct dirent *entry;\n\n    DIR *dir;\n\n\n\n    if (o->have_children) {\n\n        return;\n\n    }\n\n    o->have_children = true;\n\n\n\n    dir = opendir(o->path);\n\n    if (!dir) {\n\n        return;\n\n    }\n\n#ifdef __linux__\n\n    int watchfd = usb_mtp_add_watch(s->inotifyfd, o->path);\n\n    if (watchfd == -1) {\n\n        fprintf(stderr, \"usb-mtp: failed to add watch for %s\\n\", o->path);\n\n    } else {\n\n        trace_usb_mtp_inotify_event(s->dev.addr, o->path,\n\n                                    0, \"Watch Added\");\n\n        o->watchfd = watchfd;\n\n    }\n\n#endif\n\n    while ((entry = readdir(dir)) != NULL) {\n\n        usb_mtp_add_child(s, o, entry->d_name);\n\n    }\n\n    closedir(dir);\n\n}\n", "idx": 24971}
{"project": "qemu", "commit_id": "ebca2df783a5a742bb93784524336d8cbb9e662b", "target": 1, "func": "TPMInfo *tpm_backend_query_tpm(TPMBackend *s)\n\n{\n\n    TPMInfo *info = g_new0(TPMInfo, 1);\n\n    TPMBackendClass *k = TPM_BACKEND_GET_CLASS(s);\n\n    TPMIfClass *tic = TPM_IF_GET_CLASS(s->tpmif);\n\n\n\n    info->id = g_strdup(s->id);\n\n    info->model = tic->model;\n\n    if (k->get_tpm_options) {\n\n        info->options = k->get_tpm_options(s);\n\n    }\n\n\n\n    return info;\n\n}\n", "idx": 24974}
{"project": "qemu", "commit_id": "c572f23a3e7180dbeab5e86583e43ea2afed6271", "target": 1, "func": "static void v9fs_remove(void *opaque)\n\n{\n\n    int32_t fid;\n\n    int err = 0;\n\n    size_t offset = 7;\n\n    V9fsFidState *fidp;\n\n    V9fsPDU *pdu = opaque;\n\n\n\n    pdu_unmarshal(pdu, offset, \"d\", &fid);\n\n\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        err = -EINVAL;\n\n        goto out_nofid;\n\n    }\n\n    /* if fs driver is not path based, return EOPNOTSUPP */\n\n    if (!pdu->s->ctx.flags & PATHNAME_FSCONTEXT) {\n\n        err = -EOPNOTSUPP;\n\n        goto out_err;\n\n    }\n\n    /*\n\n     * IF the file is unlinked, we cannot reopen\n\n     * the file later. So don't reclaim fd\n\n     */\n\n    err = v9fs_mark_fids_unreclaim(pdu, &fidp->path);\n\n    if (err < 0) {\n\n        goto out_err;\n\n    }\n\n    err = v9fs_co_remove(pdu, &fidp->path);\n\n    if (!err) {\n\n        err = offset;\n\n    }\n\nout_err:\n\n    /* For TREMOVE we need to clunk the fid even on failed remove */\n\n    clunk_fid(pdu->s, fidp->fid);\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    complete_pdu(pdu->s, pdu, err);\n\n}", "idx": 24979}
{"project": "qemu", "commit_id": "ebca5e6d5ec2f1cf6c886a114e161261af28dc0a", "target": 1, "func": "static void gen_msgclr(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    GEN_PRIV;\n\n#else\n\n    CHK_SV;\n\n    gen_helper_msgclr(cpu_env, cpu_gpr[rB(ctx->opcode)]);\n\n#endif /* defined(CONFIG_USER_ONLY) */\n\n}\n", "idx": 24980}
{"project": "qemu", "commit_id": "f45cb2f43f5bb0a4122a64e61c746048b59a84ed", "target": 1, "func": "void mips_cpu_do_interrupt(CPUState *cs)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n    MIPSCPU *cpu = MIPS_CPU(cs);\n\n    CPUMIPSState *env = &cpu->env;\n\n    target_ulong offset;\n\n    int cause = -1;\n\n    const char *name;\n\n\n\n    if (qemu_log_enabled() && cs->exception_index != EXCP_EXT_INTERRUPT) {\n\n        if (cs->exception_index < 0 || cs->exception_index > EXCP_LAST) {\n\n            name = \"unknown\";\n\n        } else {\n\n            name = excp_names[cs->exception_index];\n\n        }\n\n\n\n        qemu_log(\"%s enter: PC \" TARGET_FMT_lx \" EPC \" TARGET_FMT_lx \" %s exception\\n\",\n\n                 __func__, env->active_tc.PC, env->CP0_EPC, name);\n\n    }\n\n    if (cs->exception_index == EXCP_EXT_INTERRUPT &&\n\n        (env->hflags & MIPS_HFLAG_DM)) {\n\n        cs->exception_index = EXCP_DINT;\n\n    }\n\n    offset = 0x180;\n\n    switch (cs->exception_index) {\n\n    case EXCP_DSS:\n\n        env->CP0_Debug |= 1 << CP0DB_DSS;\n\n        /* Debug single step cannot be raised inside a delay slot and\n\n           resume will always occur on the next instruction\n\n           (but we assume the pc has always been updated during\n\n           code translation). */\n\n        env->CP0_DEPC = env->active_tc.PC | !!(env->hflags & MIPS_HFLAG_M16);\n\n        goto enter_debug_mode;\n\n    case EXCP_DINT:\n\n        env->CP0_Debug |= 1 << CP0DB_DINT;\n\n        goto set_DEPC;\n\n    case EXCP_DIB:\n\n        env->CP0_Debug |= 1 << CP0DB_DIB;\n\n        goto set_DEPC;\n\n    case EXCP_DBp:\n\n        env->CP0_Debug |= 1 << CP0DB_DBp;\n\n        goto set_DEPC;\n\n    case EXCP_DDBS:\n\n        env->CP0_Debug |= 1 << CP0DB_DDBS;\n\n        goto set_DEPC;\n\n    case EXCP_DDBL:\n\n        env->CP0_Debug |= 1 << CP0DB_DDBL;\n\n    set_DEPC:\n\n        env->CP0_DEPC = exception_resume_pc(env);\n\n        env->hflags &= ~MIPS_HFLAG_BMASK;\n\n enter_debug_mode:\n\n        env->hflags |= MIPS_HFLAG_DM | MIPS_HFLAG_64 | MIPS_HFLAG_CP0;\n\n        env->hflags &= ~(MIPS_HFLAG_KSU);\n\n        /* EJTAG probe trap enable is not implemented... */\n\n        if (!(env->CP0_Status & (1 << CP0St_EXL)))\n\n            env->CP0_Cause &= ~(1 << CP0Ca_BD);\n\n        env->active_tc.PC = (int32_t)0xBFC00480;\n\n        set_hflags_for_handler(env);\n\n        break;\n\n    case EXCP_RESET:\n\n        cpu_reset(CPU(cpu));\n\n        break;\n\n    case EXCP_SRESET:\n\n        env->CP0_Status |= (1 << CP0St_SR);\n\n        memset(env->CP0_WatchLo, 0, sizeof(*env->CP0_WatchLo));\n\n        goto set_error_EPC;\n\n    case EXCP_NMI:\n\n        env->CP0_Status |= (1 << CP0St_NMI);\n\n set_error_EPC:\n\n        env->CP0_ErrorEPC = exception_resume_pc(env);\n\n        env->hflags &= ~MIPS_HFLAG_BMASK;\n\n        env->CP0_Status |= (1 << CP0St_ERL) | (1 << CP0St_BEV);\n\n        env->hflags |= MIPS_HFLAG_64 | MIPS_HFLAG_CP0;\n\n        env->hflags &= ~(MIPS_HFLAG_KSU);\n\n        if (!(env->CP0_Status & (1 << CP0St_EXL)))\n\n            env->CP0_Cause &= ~(1 << CP0Ca_BD);\n\n        env->active_tc.PC = (int32_t)0xBFC00000;\n\n        set_hflags_for_handler(env);\n\n        break;\n\n    case EXCP_EXT_INTERRUPT:\n\n        cause = 0;\n\n        if (env->CP0_Cause & (1 << CP0Ca_IV))\n\n            offset = 0x200;\n\n\n\n        if (env->CP0_Config3 & ((1 << CP0C3_VInt) | (1 << CP0C3_VEIC))) {\n\n            /* Vectored Interrupts.  */\n\n            unsigned int spacing;\n\n            unsigned int vector;\n\n            unsigned int pending = (env->CP0_Cause & CP0Ca_IP_mask) >> 8;\n\n\n\n            pending &= env->CP0_Status >> 8;\n\n            /* Compute the Vector Spacing.  */\n\n            spacing = (env->CP0_IntCtl >> CP0IntCtl_VS) & ((1 << 6) - 1);\n\n            spacing <<= 5;\n\n\n\n            if (env->CP0_Config3 & (1 << CP0C3_VInt)) {\n\n                /* For VInt mode, the MIPS computes the vector internally.  */\n\n                for (vector = 7; vector > 0; vector--) {\n\n                    if (pending & (1 << vector)) {\n\n                        /* Found it.  */\n\n                        break;\n\n                    }\n\n                }\n\n            } else {\n\n                /* For VEIC mode, the external interrupt controller feeds the\n\n                   vector through the CP0Cause IP lines.  */\n\n                vector = pending;\n\n            }\n\n            offset = 0x200 + vector * spacing;\n\n        }\n\n        goto set_EPC;\n\n    case EXCP_LTLBL:\n\n        cause = 1;\n\n        goto set_EPC;\n\n    case EXCP_TLBL:\n\n        cause = 2;\n\n        if (env->error_code == 1 && !(env->CP0_Status & (1 << CP0St_EXL))) {\n\n#if defined(TARGET_MIPS64)\n\n            int R = env->CP0_BadVAddr >> 62;\n\n            int UX = (env->CP0_Status & (1 << CP0St_UX)) != 0;\n\n            int SX = (env->CP0_Status & (1 << CP0St_SX)) != 0;\n\n            int KX = (env->CP0_Status & (1 << CP0St_KX)) != 0;\n\n\n\n            if (((R == 0 && UX) || (R == 1 && SX) || (R == 3 && KX)) &&\n\n                (!(env->insn_flags & (INSN_LOONGSON2E | INSN_LOONGSON2F))))\n\n                offset = 0x080;\n\n            else\n\n#endif\n\n                offset = 0x000;\n\n        }\n\n        goto set_EPC;\n\n    case EXCP_TLBS:\n\n        cause = 3;\n\n        if (env->error_code == 1 && !(env->CP0_Status & (1 << CP0St_EXL))) {\n\n#if defined(TARGET_MIPS64)\n\n            int R = env->CP0_BadVAddr >> 62;\n\n            int UX = (env->CP0_Status & (1 << CP0St_UX)) != 0;\n\n            int SX = (env->CP0_Status & (1 << CP0St_SX)) != 0;\n\n            int KX = (env->CP0_Status & (1 << CP0St_KX)) != 0;\n\n\n\n            if (((R == 0 && UX) || (R == 1 && SX) || (R == 3 && KX)) &&\n\n                (!(env->insn_flags & (INSN_LOONGSON2E | INSN_LOONGSON2F))))\n\n                offset = 0x080;\n\n            else\n\n#endif\n\n                offset = 0x000;\n\n        }\n\n        goto set_EPC;\n\n    case EXCP_AdEL:\n\n        cause = 4;\n\n        goto set_EPC;\n\n    case EXCP_AdES:\n\n        cause = 5;\n\n        goto set_EPC;\n\n    case EXCP_IBE:\n\n        cause = 6;\n\n        goto set_EPC;\n\n    case EXCP_DBE:\n\n        cause = 7;\n\n        goto set_EPC;\n\n    case EXCP_SYSCALL:\n\n        cause = 8;\n\n        goto set_EPC;\n\n    case EXCP_BREAK:\n\n        cause = 9;\n\n        goto set_EPC;\n\n    case EXCP_RI:\n\n        cause = 10;\n\n        goto set_EPC;\n\n    case EXCP_CpU:\n\n        cause = 11;\n\n        env->CP0_Cause = (env->CP0_Cause & ~(0x3 << CP0Ca_CE)) |\n\n                         (env->error_code << CP0Ca_CE);\n\n        goto set_EPC;\n\n    case EXCP_OVERFLOW:\n\n        cause = 12;\n\n        goto set_EPC;\n\n    case EXCP_TRAP:\n\n        cause = 13;\n\n        goto set_EPC;\n\n    case EXCP_FPE:\n\n        cause = 15;\n\n        goto set_EPC;\n\n    case EXCP_C2E:\n\n        cause = 18;\n\n        goto set_EPC;\n\n    case EXCP_MDMX:\n\n        cause = 22;\n\n        goto set_EPC;\n\n    case EXCP_DWATCH:\n\n        cause = 23;\n\n        /* XXX: TODO: manage defered watch exceptions */\n\n        goto set_EPC;\n\n    case EXCP_MCHECK:\n\n        cause = 24;\n\n        goto set_EPC;\n\n    case EXCP_THREAD:\n\n        cause = 25;\n\n        goto set_EPC;\n\n    case EXCP_DSPDIS:\n\n        cause = 26;\n\n        goto set_EPC;\n\n    case EXCP_CACHE:\n\n        cause = 30;\n\n        if (env->CP0_Status & (1 << CP0St_BEV)) {\n\n            offset = 0x100;\n\n        } else {\n\n            offset = 0x20000100;\n\n        }\n\n set_EPC:\n\n        if (!(env->CP0_Status & (1 << CP0St_EXL))) {\n\n            env->CP0_EPC = exception_resume_pc(env);\n\n            if (env->hflags & MIPS_HFLAG_BMASK) {\n\n                env->CP0_Cause |= (1 << CP0Ca_BD);\n\n            } else {\n\n                env->CP0_Cause &= ~(1 << CP0Ca_BD);\n\n            }\n\n            env->CP0_Status |= (1 << CP0St_EXL);\n\n            env->hflags |= MIPS_HFLAG_64 | MIPS_HFLAG_CP0;\n\n            env->hflags &= ~(MIPS_HFLAG_KSU);\n\n        }\n\n        env->hflags &= ~MIPS_HFLAG_BMASK;\n\n        if (env->CP0_Status & (1 << CP0St_BEV)) {\n\n            env->active_tc.PC = (int32_t)0xBFC00200;\n\n        } else {\n\n            env->active_tc.PC = (int32_t)(env->CP0_EBase & ~0x3ff);\n\n        }\n\n        env->active_tc.PC += offset;\n\n        set_hflags_for_handler(env);\n\n        env->CP0_Cause = (env->CP0_Cause & ~(0x1f << CP0Ca_EC)) | (cause << CP0Ca_EC);\n\n        break;\n\n    default:\n\n        qemu_log(\"Invalid MIPS exception %d. Exiting\\n\", cs->exception_index);\n\n        printf(\"Invalid MIPS exception %d. Exiting\\n\", cs->exception_index);\n\n        exit(1);\n\n    }\n\n    if (qemu_log_enabled() && cs->exception_index != EXCP_EXT_INTERRUPT) {\n\n        qemu_log(\"%s: PC \" TARGET_FMT_lx \" EPC \" TARGET_FMT_lx \" cause %d\\n\"\n\n                \"    S %08x C %08x A \" TARGET_FMT_lx \" D \" TARGET_FMT_lx \"\\n\",\n\n                __func__, env->active_tc.PC, env->CP0_EPC, cause,\n\n                env->CP0_Status, env->CP0_Cause, env->CP0_BadVAddr,\n\n                env->CP0_DEPC);\n\n    }\n\n#endif\n\n    cs->exception_index = EXCP_NONE;\n\n}\n", "idx": 24982}
{"project": "qemu", "commit_id": "1452686495922b81d6cf43edf025c1aef15965c0", "target": 1, "func": "void qmp_drive_mirror(const char *device, const char *target,\n\n                      bool has_format, const char *format,\n\n                      enum MirrorSyncMode sync,\n\n                      bool has_mode, enum NewImageMode mode,\n\n                      bool has_speed, int64_t speed,\n\n                      bool has_granularity, uint32_t granularity,\n\n                      bool has_buf_size, int64_t buf_size,\n\n                      bool has_on_source_error, BlockdevOnError on_source_error,\n\n                      bool has_on_target_error, BlockdevOnError on_target_error,\n\n                      Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *source, *target_bs;\n\n    BlockDriver *drv = NULL;\n\n    Error *local_err = NULL;\n\n    int flags;\n\n    int64_t size;\n\n    int ret;\n\n\n\n    if (!has_speed) {\n\n        speed = 0;\n\n    }\n\n    if (!has_on_source_error) {\n\n        on_source_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n    if (!has_on_target_error) {\n\n        on_target_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n    if (!has_mode) {\n\n        mode = NEW_IMAGE_MODE_ABSOLUTE_PATHS;\n\n    }\n\n    if (!has_granularity) {\n\n        granularity = 0;\n\n    }\n\n    if (!has_buf_size) {\n\n        buf_size = DEFAULT_MIRROR_BUF_SIZE;\n\n    }\n\n\n\n    if (granularity != 0 && (granularity < 512 || granularity > 1048576 * 64)) {\n\n        error_set(errp, QERR_INVALID_PARAMETER, device);\n\n        return;\n\n    }\n\n    if (granularity & (granularity - 1)) {\n\n        error_set(errp, QERR_INVALID_PARAMETER, device);\n\n        return;\n\n    }\n\n\n\n    bs = bdrv_find(device);\n\n    if (!bs) {\n\n        error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n\n        return;\n\n    }\n\n\n\n    if (!bdrv_is_inserted(bs)) {\n\n        error_set(errp, QERR_DEVICE_HAS_NO_MEDIUM, device);\n\n        return;\n\n    }\n\n\n\n    if (!has_format) {\n\n        format = mode == NEW_IMAGE_MODE_EXISTING ? NULL : bs->drv->format_name;\n\n    }\n\n    if (format) {\n\n        drv = bdrv_find_format(format);\n\n        if (!drv) {\n\n            error_set(errp, QERR_INVALID_BLOCK_FORMAT, format);\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (bdrv_in_use(bs)) {\n\n        error_set(errp, QERR_DEVICE_IN_USE, device);\n\n        return;\n\n    }\n\n\n\n    flags = bs->open_flags | BDRV_O_RDWR;\n\n    source = bs->backing_hd;\n\n    if (!source && sync == MIRROR_SYNC_MODE_TOP) {\n\n        sync = MIRROR_SYNC_MODE_FULL;\n\n    }\n\n\n\n    size = bdrv_getlength(bs);\n\n    if (size < 0) {\n\n        error_setg_errno(errp, -size, \"bdrv_getlength failed\");\n\n        return;\n\n    }\n\n\n\n    if (sync == MIRROR_SYNC_MODE_FULL && mode != NEW_IMAGE_MODE_EXISTING) {\n\n        /* create new image w/o backing file */\n\n        assert(format && drv);\n\n        bdrv_img_create(target, format,\n\n                        NULL, NULL, NULL, size, flags, &local_err, false);\n\n    } else {\n\n        switch (mode) {\n\n        case NEW_IMAGE_MODE_EXISTING:\n\n            break;\n\n        case NEW_IMAGE_MODE_ABSOLUTE_PATHS:\n\n            /* create new image with backing file */\n\n            bdrv_img_create(target, format,\n\n                            source->filename,\n\n                            source->drv->format_name,\n\n                            NULL, size, flags, &local_err, false);\n\n            break;\n\n        default:\n\n            abort();\n\n        }\n\n    }\n\n\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    /* Mirroring takes care of copy-on-write using the source's backing\n\n     * file.\n\n     */\n\n    target_bs = bdrv_new(\"\");\n\n    ret = bdrv_open(target_bs, target, NULL, flags | BDRV_O_NO_BACKING, drv,\n\n                    &local_err);\n\n    if (ret < 0) {\n\n        bdrv_unref(target_bs);\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    mirror_start(bs, target_bs, speed, granularity, buf_size, sync,\n\n                 on_source_error, on_target_error,\n\n                 block_job_cb, bs, &local_err);\n\n    if (local_err != NULL) {\n\n        bdrv_unref(target_bs);\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n}\n", "idx": 24983}
{"project": "qemu", "commit_id": "668c0e441d761a79f33eae11c120e01a29f9d4dd", "target": 1, "func": "static void glfs_clear_preopened(glfs_t *fs)\n\n{\n\n    ListElement *entry = NULL;\n\n\n\n    if (fs == NULL) {\n\n        return;\n\n    }\n\n\n\n    QLIST_FOREACH(entry, &glfs_list, list) {\n\n        if (entry->saved.fs == fs) {\n\n            if (--entry->saved.ref) {\n\n                return;\n\n            }\n\n\n\n            QLIST_REMOVE(entry, list);\n\n\n\n            glfs_fini(entry->saved.fs);\n\n            g_free(entry->saved.volume);\n\n            g_free(entry);\n\n        }\n\n    }\n\n}\n", "idx": 24987}
{"project": "qemu", "commit_id": "66a08cbe6ad1aebec8eecf58b3ba042e19dd1649", "target": 1, "func": "static void uhci_process_frame(UHCIState *s)\n\n{\n\n    uint32_t frame_addr, link, old_td_ctrl, val, int_mask;\n\n    uint32_t curr_qh, td_count = 0;\n\n    int cnt, ret;\n\n    UHCI_TD td;\n\n    UHCI_QH qh;\n\n    QhDb qhdb;\n\n\n\n    frame_addr = s->fl_base_addr + ((s->frnum & 0x3ff) << 2);\n\n\n\n    pci_dma_read(&s->dev, frame_addr, &link, 4);\n\n    le32_to_cpus(&link);\n\n\n\n    int_mask = 0;\n\n    curr_qh  = 0;\n\n\n\n    qhdb_reset(&qhdb);\n\n\n\n    for (cnt = FRAME_MAX_LOOPS; is_valid(link) && cnt; cnt--) {\n\n        if (s->frame_bytes >= s->frame_bandwidth) {\n\n            /* We've reached the usb 1.1 bandwidth, which is\n\n               1280 bytes/frame, stop processing */\n\n            trace_usb_uhci_frame_stop_bandwidth();\n\n            break;\n\n        }\n\n        if (is_qh(link)) {\n\n            /* QH */\n\n            trace_usb_uhci_qh_load(link & ~0xf);\n\n\n\n            if (qhdb_insert(&qhdb, link)) {\n\n                /*\n\n                 * We're going in circles. Which is not a bug because\n\n                 * HCD is allowed to do that as part of the BW management.\n\n                 *\n\n                 * Stop processing here if no transaction has been done\n\n                 * since we've been here last time.\n\n                 */\n\n                if (td_count == 0) {\n\n                    trace_usb_uhci_frame_loop_stop_idle();\n\n                    break;\n\n                } else {\n\n                    trace_usb_uhci_frame_loop_continue();\n\n                    td_count = 0;\n\n                    qhdb_reset(&qhdb);\n\n                    qhdb_insert(&qhdb, link);\n\n                }\n\n            }\n\n\n\n            pci_dma_read(&s->dev, link & ~0xf, &qh, sizeof(qh));\n\n            le32_to_cpus(&qh.link);\n\n            le32_to_cpus(&qh.el_link);\n\n\n\n            if (!is_valid(qh.el_link)) {\n\n                /* QH w/o elements */\n\n                curr_qh = 0;\n\n                link = qh.link;\n\n            } else {\n\n                /* QH with elements */\n\n            \tcurr_qh = link;\n\n            \tlink = qh.el_link;\n\n            }\n\n            continue;\n\n        }\n\n\n\n        /* TD */\n\n        uhci_read_td(s, &td, link);\n\n        trace_usb_uhci_td_load(curr_qh & ~0xf, link & ~0xf, td.ctrl, td.token);\n\n\n\n        old_td_ctrl = td.ctrl;\n\n        ret = uhci_handle_td(s, NULL, &td, link, &int_mask);\n\n        if (old_td_ctrl != td.ctrl) {\n\n            /* update the status bits of the TD */\n\n            val = cpu_to_le32(td.ctrl);\n\n            pci_dma_write(&s->dev, (link & ~0xf) + 4, &val, sizeof(val));\n\n        }\n\n\n\n        switch (ret) {\n\n        case TD_RESULT_STOP_FRAME: /* interrupted frame */\n\n            goto out;\n\n\n\n        case TD_RESULT_NEXT_QH:\n\n        case TD_RESULT_ASYNC_CONT:\n\n            trace_usb_uhci_td_nextqh(curr_qh & ~0xf, link & ~0xf);\n\n            link = curr_qh ? qh.link : td.link;\n\n            continue;\n\n\n\n        case TD_RESULT_ASYNC_START:\n\n            trace_usb_uhci_td_async(curr_qh & ~0xf, link & ~0xf);\n\n            link = curr_qh ? qh.link : td.link;\n\n            continue;\n\n\n\n        case TD_RESULT_COMPLETE:\n\n            trace_usb_uhci_td_complete(curr_qh & ~0xf, link & ~0xf);\n\n            link = td.link;\n\n            td_count++;\n\n            s->frame_bytes += (td.ctrl & 0x7ff) + 1;\n\n\n\n            if (curr_qh) {\n\n                /* update QH element link */\n\n                qh.el_link = link;\n\n                val = cpu_to_le32(qh.el_link);\n\n                pci_dma_write(&s->dev, (curr_qh & ~0xf) + 4, &val, sizeof(val));\n\n\n\n                if (!depth_first(link)) {\n\n                    /* done with this QH */\n\n                    curr_qh = 0;\n\n                    link    = qh.link;\n\n                }\n\n            }\n\n            break;\n\n\n\n        default:\n\n            assert(!\"unknown return code\");\n\n        }\n\n\n\n        /* go to the next entry */\n\n    }\n\n\n\nout:\n\n    s->pending_int_mask |= int_mask;\n\n}\n", "idx": 24989}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_validate_fail_alternate(TestInputVisitorData *data,\n\n                                         const void *unused)\n\n{\n\n    UserDefAlternate *tmp;\n\n    Visitor *v;\n\n    Error *err = NULL;\n\n\n\n    v = validate_test_init(data, \"3.14\");\n\n\n\n    visit_type_UserDefAlternate(v, NULL, &tmp, &err);\n\n    error_free_or_abort(&err);\n\n    g_assert(!tmp);\n\n}\n", "idx": 24990}
{"project": "qemu", "commit_id": "abd696e4f74a9d30801c6ae2693efe4e5979c2f2", "target": 0, "func": "void sclp_print(const char *str)\n\n{\n\n    int len = _strlen(str);\n\n    WriteEventData *sccb = (void*)_sccb;\n\n\n\n    sccb->h.length = sizeof(WriteEventData) + len;\n\n    sccb->h.function_code = SCLP_FC_NORMAL_WRITE;\n\n    sccb->ebh.length = sizeof(EventBufferHeader) + len;\n\n    sccb->ebh.type = SCLP_EVENT_ASCII_CONSOLE_DATA;\n\n    sccb->ebh.flags = 0;\n\n    _memcpy(sccb->data, str, len);\n\n\n\n    sclp_service_call(SCLP_CMD_WRITE_EVENT_DATA, sccb);\n\n}\n", "idx": 24991}
{"project": "qemu", "commit_id": "7385aed20db5d83979f683b9d0048674411e963c", "target": 0, "func": "float64 helper_fstod(CPUSPARCState *env, float32 src)\n\n{\n\n    float64 ret;\n\n    clear_float_exceptions(env);\n\n    ret = float32_to_float64(src, &env->fp_status);\n\n    check_ieee_exceptions(env);\n\n    return ret;\n\n}\n", "idx": 24992}
{"project": "qemu", "commit_id": "c5c7d3f0a79a977955e9df436cf9ca17269b8783", "target": 0, "func": "static void do_log(int loglevel, const char *format, ...)\n\n{\n\n    va_list ap;\n\n\n\n    va_start(ap, format);\n\n    if (is_daemon) {\n\n        vsyslog(LOG_CRIT, format, ap);\n\n    } else {\n\n        vfprintf(stderr, format, ap);\n\n    }\n\n    va_end(ap);\n\n}\n", "idx": 24993}
{"project": "qemu", "commit_id": "41bf234d8e35e9273290df278e2aeb88c0c50a4f", "target": 0, "func": "static void gic_reset(gic_state *s)\n\n{\n\n    int i;\n\n    memset(s->irq_state, 0, GIC_NIRQ * sizeof(gic_irq_state));\n\n    for (i = 0 ; i < NUM_CPU(s); i++) {\n\n        s->priority_mask[i] = 0xf0;\n\n        s->current_pending[i] = 1023;\n\n        s->running_irq[i] = 1023;\n\n        s->running_priority[i] = 0x100;\n\n#ifdef NVIC\n\n        /* The NVIC doesn't have per-cpu interfaces, so enable by default.  */\n\n        s->cpu_enabled[i] = 1;\n\n#else\n\n        s->cpu_enabled[i] = 0;\n\n#endif\n\n    }\n\n    for (i = 0; i < 16; i++) {\n\n        GIC_SET_ENABLED(i);\n\n        GIC_SET_TRIGGER(i);\n\n    }\n\n#ifdef NVIC\n\n    /* The NVIC is always enabled.  */\n\n    s->enabled = 1;\n\n#else\n\n    s->enabled = 0;\n\n#endif\n\n}\n", "idx": 24994}
{"project": "qemu", "commit_id": "6100dda70d84be83d131c3b35cb9c00f7b07db15", "target": 0, "func": "static void xhci_er_reset(XHCIState *xhci, int v)\n\n{\n\n    XHCIInterrupter *intr = &xhci->intr[v];\n\n    XHCIEvRingSeg seg;\n\n\n\n    if (intr->erstsz == 0) {\n\n        /* disabled */\n\n        intr->er_start = 0;\n\n        intr->er_size = 0;\n\n        return;\n\n    }\n\n    /* cache the (sole) event ring segment location */\n\n    if (intr->erstsz != 1) {\n\n        DPRINTF(\"xhci: invalid value for ERSTSZ: %d\\n\", intr->erstsz);\n\n        xhci_die(xhci);\n\n        return;\n\n    }\n\n    dma_addr_t erstba = xhci_addr64(intr->erstba_low, intr->erstba_high);\n\n    pci_dma_read(PCI_DEVICE(xhci), erstba, &seg, sizeof(seg));\n\n    le32_to_cpus(&seg.addr_low);\n\n    le32_to_cpus(&seg.addr_high);\n\n    le32_to_cpus(&seg.size);\n\n    if (seg.size < 16 || seg.size > 4096) {\n\n        DPRINTF(\"xhci: invalid value for segment size: %d\\n\", seg.size);\n\n        xhci_die(xhci);\n\n        return;\n\n    }\n\n    intr->er_start = xhci_addr64(seg.addr_low, seg.addr_high);\n\n    intr->er_size = seg.size;\n\n\n\n    intr->er_ep_idx = 0;\n\n    intr->er_pcs = 1;\n\n\n\n    DPRINTF(\"xhci: event ring[%d]:\" DMA_ADDR_FMT \" [%d]\\n\",\n\n            v, intr->er_start, intr->er_size);\n\n}\n", "idx": 24995}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static void pxa2xx_cm_write(void *opaque, hwaddr addr,\n\n                            uint64_t value, unsigned size)\n\n{\n\n    PXA2xxState *s = (PXA2xxState *) opaque;\n\n\n\n    switch (addr) {\n\n    case CCCR:\n\n    case CKEN:\n\n        s->cm_regs[addr >> 2] = value;\n\n        break;\n\n\n\n    case OSCC:\n\n        s->cm_regs[addr >> 2] &= ~0x6c;\n\n        s->cm_regs[addr >> 2] |= value & 0x6e;\n\n        if ((value >> 1) & 1)\t\t\t/* OON */\n\n            s->cm_regs[addr >> 2] |= 1 << 0;\t/* Oscillator is now stable */\n\n        break;\n\n\n\n    default:\n\n        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);\n\n        break;\n\n    }\n\n}\n", "idx": 24996}
{"project": "qemu", "commit_id": "52b4bb7383b32e4e7512f98c57738c8fc9cb35ba", "target": 0, "func": "static void do_mac_write(lan9118_state *s, int reg, uint32_t val)\n\n{\n\n    switch (reg) {\n\n    case MAC_CR:\n\n        if ((s->mac_cr & MAC_CR_RXEN) != 0 && (val & MAC_CR_RXEN) == 0) {\n\n            s->int_sts |= RXSTOP_INT;\n\n        }\n\n        s->mac_cr = val & ~MAC_CR_RESERVED;\n\n        DPRINTF(\"MAC_CR: %08x\\n\", val);\n\n        break;\n\n    case MAC_ADDRH:\n\n        s->conf.macaddr.a[4] = val & 0xff;\n\n        s->conf.macaddr.a[5] = (val >> 8) & 0xff;\n\n        lan9118_mac_changed(s);\n\n        break;\n\n    case MAC_ADDRL:\n\n        s->conf.macaddr.a[0] = val & 0xff;\n\n        s->conf.macaddr.a[1] = (val >> 8) & 0xff;\n\n        s->conf.macaddr.a[2] = (val >> 16) & 0xff;\n\n        s->conf.macaddr.a[3] = (val >> 24) & 0xff;\n\n        lan9118_mac_changed(s);\n\n        break;\n\n    case MAC_HASHH:\n\n        s->mac_hashh = val;\n\n        break;\n\n    case MAC_HASHL:\n\n        s->mac_hashl = val;\n\n        break;\n\n    case MAC_MII_ACC:\n\n        s->mac_mii_acc = val & 0xffc2;\n\n        if (val & 2) {\n\n            DPRINTF(\"PHY write %d = 0x%04x\\n\",\n\n                    (val >> 6) & 0x1f, s->mac_mii_data);\n\n            do_phy_write(s, (val >> 6) & 0x1f, s->mac_mii_data);\n\n        } else {\n\n            s->mac_mii_data = do_phy_read(s, (val >> 6) & 0x1f);\n\n            DPRINTF(\"PHY read %d = 0x%04x\\n\",\n\n                    (val >> 6) & 0x1f, s->mac_mii_data);\n\n        }\n\n        break;\n\n    case MAC_MII_DATA:\n\n        s->mac_mii_data = val & 0xffff;\n\n        break;\n\n    case MAC_FLOW:\n\n        s->mac_flow = val & 0xffff0000;\n\n        break;\n\n    case MAC_VLAN1:\n\n        /* Writing to this register changes a condition for\n\n         * FrameTooLong bit in rx_status.  Since we do not set\n\n         * FrameTooLong anyway, just ignore write to this.\n\n         */\n\n        break;\n\n    default:\n\n        hw_error(\"lan9118: Unimplemented MAC register write: %d = 0x%x\\n\",\n\n                 s->mac_cmd & 0xf, val);\n\n    }\n\n}\n", "idx": 24997}
{"project": "qemu", "commit_id": "c433a17141fb2a400ecb656e55d8d21caa2e2390", "target": 0, "func": "static void decode_rrr_divide(CPUTriCoreState *env, DisasContext *ctx)\n\n{\n\n    uint32_t op2;\n\n\n\n    int r1, r2, r3, r4;\n\n\n\n    op2 = MASK_OP_RRR_OP2(ctx->opcode);\n\n    r1 = MASK_OP_RRR_S1(ctx->opcode);\n\n    r2 = MASK_OP_RRR_S2(ctx->opcode);\n\n    r3 = MASK_OP_RRR_S3(ctx->opcode);\n\n    r4 = MASK_OP_RRR_D(ctx->opcode);\n\n\n\n    CHECK_REG_PAIR(r3);\n\n\n\n    switch (op2) {\n\n    case OPC2_32_RRR_DVADJ:\n\n        CHECK_REG_PAIR(r4);\n\n        GEN_HELPER_RRR(dvadj, cpu_gpr_d[r4], cpu_gpr_d[r4+1], cpu_gpr_d[r3],\n\n                       cpu_gpr_d[r3+1], cpu_gpr_d[r2]);\n\n        break;\n\n    case OPC2_32_RRR_DVSTEP:\n\n        CHECK_REG_PAIR(r4);\n\n        GEN_HELPER_RRR(dvstep, cpu_gpr_d[r4], cpu_gpr_d[r4+1], cpu_gpr_d[r3],\n\n                       cpu_gpr_d[r3+1], cpu_gpr_d[r2]);\n\n        break;\n\n    case OPC2_32_RRR_DVSTEP_U:\n\n        CHECK_REG_PAIR(r4);\n\n        GEN_HELPER_RRR(dvstep_u, cpu_gpr_d[r4], cpu_gpr_d[r4+1], cpu_gpr_d[r3],\n\n                       cpu_gpr_d[r3+1], cpu_gpr_d[r2]);\n\n        break;\n\n    case OPC2_32_RRR_IXMAX:\n\n        CHECK_REG_PAIR(r4);\n\n        GEN_HELPER_RRR(ixmax, cpu_gpr_d[r4], cpu_gpr_d[r4+1], cpu_gpr_d[r3],\n\n                       cpu_gpr_d[r3+1], cpu_gpr_d[r2]);\n\n        break;\n\n    case OPC2_32_RRR_IXMAX_U:\n\n        CHECK_REG_PAIR(r4);\n\n        GEN_HELPER_RRR(ixmax_u, cpu_gpr_d[r4], cpu_gpr_d[r4+1], cpu_gpr_d[r3],\n\n                       cpu_gpr_d[r3+1], cpu_gpr_d[r2]);\n\n        break;\n\n    case OPC2_32_RRR_IXMIN:\n\n        CHECK_REG_PAIR(r4);\n\n        GEN_HELPER_RRR(ixmin, cpu_gpr_d[r4], cpu_gpr_d[r4+1], cpu_gpr_d[r3],\n\n                       cpu_gpr_d[r3+1], cpu_gpr_d[r2]);\n\n        break;\n\n    case OPC2_32_RRR_IXMIN_U:\n\n        CHECK_REG_PAIR(r4);\n\n        GEN_HELPER_RRR(ixmin_u, cpu_gpr_d[r4], cpu_gpr_d[r4+1], cpu_gpr_d[r3],\n\n                       cpu_gpr_d[r3+1], cpu_gpr_d[r2]);\n\n        break;\n\n    case OPC2_32_RRR_PACK:\n\n        gen_helper_pack(cpu_gpr_d[r4], cpu_PSW_C, cpu_gpr_d[r3],\n\n                        cpu_gpr_d[r3+1], cpu_gpr_d[r1]);\n\n        break;\n\n    default:\n\n        generate_trap(ctx, TRAPC_INSN_ERR, TIN2_IOPC);\n\n    }\n\n}\n", "idx": 24998}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static void qemu_input_transform_abs_rotate(InputEvent *evt)\n\n{\n\n    InputMoveEvent *move = evt->u.abs;\n\n    switch (graphic_rotate) {\n\n    case 90:\n\n        if (move->axis == INPUT_AXIS_X) {\n\n            move->axis = INPUT_AXIS_Y;\n\n        } else if (move->axis == INPUT_AXIS_Y) {\n\n            move->axis = INPUT_AXIS_X;\n\n            move->value = INPUT_EVENT_ABS_SIZE - 1 - move->value;\n\n        }\n\n        break;\n\n    case 180:\n\n        move->value = INPUT_EVENT_ABS_SIZE - 1 - move->value;\n\n        break;\n\n    case 270:\n\n        if (move->axis == INPUT_AXIS_X) {\n\n            move->axis = INPUT_AXIS_Y;\n\n            move->value = INPUT_EVENT_ABS_SIZE - 1 - move->value;\n\n        } else if (move->axis == INPUT_AXIS_Y) {\n\n            move->axis = INPUT_AXIS_X;\n\n        }\n\n        break;\n\n    }\n\n}\n", "idx": 24999}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static int mcf_fec_can_receive(void *opaque)\n\n{\n\n    mcf_fec_state *s = (mcf_fec_state *)opaque;\n\n    return s->rx_enabled;\n\n}\n", "idx": 25001}
{"project": "qemu", "commit_id": "de1b9b85eff3dca42fe2cabe6e026cd2a2d5c769", "target": 0, "func": "static void qxl_realize_common(PCIQXLDevice *qxl, Error **errp)\n\n{\n\n    uint8_t* config = qxl->pci.config;\n\n    uint32_t pci_device_rev;\n\n    uint32_t io_size;\n\n\n\n    qxl->mode = QXL_MODE_UNDEFINED;\n\n    qxl->generation = 1;\n\n    qxl->num_memslots = NUM_MEMSLOTS;\n\n    qemu_mutex_init(&qxl->track_lock);\n\n    qemu_mutex_init(&qxl->async_lock);\n\n    qxl->current_async = QXL_UNDEFINED_IO;\n\n    qxl->guest_bug = 0;\n\n\n\n    switch (qxl->revision) {\n\n    case 1: /* spice 0.4 -- qxl-1 */\n\n        pci_device_rev = QXL_REVISION_STABLE_V04;\n\n        io_size = 8;\n\n        break;\n\n    case 2: /* spice 0.6 -- qxl-2 */\n\n        pci_device_rev = QXL_REVISION_STABLE_V06;\n\n        io_size = 16;\n\n        break;\n\n    case 3: /* qxl-3 */\n\n        pci_device_rev = QXL_REVISION_STABLE_V10;\n\n        io_size = 32; /* PCI region size must be pow2 */\n\n        break;\n\n    case 4: /* qxl-4 */\n\n        pci_device_rev = QXL_REVISION_STABLE_V12;\n\n        io_size = pow2ceil(QXL_IO_RANGE_SIZE);\n\n        break;\n\n    default:\n\n        error_setg(errp, \"Invalid revision %d for qxl device (max %d)\",\n\n                   qxl->revision, QXL_DEFAULT_REVISION);\n\n        return;\n\n    }\n\n\n\n    pci_set_byte(&config[PCI_REVISION_ID], pci_device_rev);\n\n    pci_set_byte(&config[PCI_INTERRUPT_PIN], 1);\n\n\n\n    qxl->rom_size = qxl_rom_size();\n\n    memory_region_init_ram(&qxl->rom_bar, OBJECT(qxl), \"qxl.vrom\",\n\n                           qxl->rom_size, &error_fatal);\n\n    vmstate_register_ram(&qxl->rom_bar, &qxl->pci.qdev);\n\n    init_qxl_rom(qxl);\n\n    init_qxl_ram(qxl);\n\n\n\n    qxl->guest_surfaces.cmds = g_new0(QXLPHYSICAL, qxl->ssd.num_surfaces);\n\n    memory_region_init_ram(&qxl->vram_bar, OBJECT(qxl), \"qxl.vram\",\n\n                           qxl->vram_size, &error_fatal);\n\n    vmstate_register_ram(&qxl->vram_bar, &qxl->pci.qdev);\n\n    memory_region_init_alias(&qxl->vram32_bar, OBJECT(qxl), \"qxl.vram32\",\n\n                             &qxl->vram_bar, 0, qxl->vram32_size);\n\n\n\n    memory_region_init_io(&qxl->io_bar, OBJECT(qxl), &qxl_io_ops, qxl,\n\n                          \"qxl-ioports\", io_size);\n\n    if (qxl->id == 0) {\n\n        vga_dirty_log_start(&qxl->vga);\n\n    }\n\n    memory_region_set_flush_coalesced(&qxl->io_bar);\n\n\n\n\n\n    pci_register_bar(&qxl->pci, QXL_IO_RANGE_INDEX,\n\n                     PCI_BASE_ADDRESS_SPACE_IO, &qxl->io_bar);\n\n\n\n    pci_register_bar(&qxl->pci, QXL_ROM_RANGE_INDEX,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &qxl->rom_bar);\n\n\n\n    pci_register_bar(&qxl->pci, QXL_RAM_RANGE_INDEX,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &qxl->vga.vram);\n\n\n\n    pci_register_bar(&qxl->pci, QXL_VRAM_RANGE_INDEX,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &qxl->vram32_bar);\n\n\n\n    if (qxl->vram32_size < qxl->vram_size) {\n\n        /*\n\n         * Make the 64bit vram bar show up only in case it is\n\n         * configured to be larger than the 32bit vram bar.\n\n         */\n\n        pci_register_bar(&qxl->pci, QXL_VRAM64_RANGE_INDEX,\n\n                         PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                         PCI_BASE_ADDRESS_MEM_TYPE_64 |\n\n                         PCI_BASE_ADDRESS_MEM_PREFETCH,\n\n                         &qxl->vram_bar);\n\n    }\n\n\n\n    /* print pci bar details */\n\n    dprint(qxl, 1, \"ram/%s: %d MB [region 0]\\n\",\n\n           qxl->id == 0 ? \"pri\" : \"sec\",\n\n           qxl->vga.vram_size / (1024*1024));\n\n    dprint(qxl, 1, \"vram/32: %d MB [region 1]\\n\",\n\n           qxl->vram32_size / (1024*1024));\n\n    dprint(qxl, 1, \"vram/64: %d MB %s\\n\",\n\n           qxl->vram_size / (1024*1024),\n\n           qxl->vram32_size < qxl->vram_size ? \"[region 4]\" : \"[unmapped]\");\n\n\n\n    qxl->ssd.qxl.base.sif = &qxl_interface.base;\n\n    if (qemu_spice_add_display_interface(&qxl->ssd.qxl, qxl->vga.con) != 0) {\n\n        error_setg(errp, \"qxl interface %d.%d not supported by spice-server\",\n\n                   SPICE_INTERFACE_QXL_MAJOR, SPICE_INTERFACE_QXL_MINOR);\n\n        return;\n\n    }\n\n    qemu_add_vm_change_state_handler(qxl_vm_change_state_handler, qxl);\n\n\n\n    qxl->update_irq = qemu_bh_new(qxl_update_irq_bh, qxl);\n\n    qxl_reset_state(qxl);\n\n\n\n    qxl->update_area_bh = qemu_bh_new(qxl_render_update_area_bh, qxl);\n\n    qxl->ssd.cursor_bh = qemu_bh_new(qemu_spice_cursor_refresh_bh, &qxl->ssd);\n\n}\n", "idx": 25002}
{"project": "qemu", "commit_id": "4add0da64942d83e0564147c0876b01074bde9cb", "target": 0, "func": "static int css_interpret_ccw(SubchDev *sch, hwaddr ccw_addr,\n\n                             bool suspend_allowed)\n\n{\n\n    int ret;\n\n    bool check_len;\n\n    int len;\n\n    CCW1 ccw;\n\n\n\n    if (!ccw_addr) {\n\n        return -EIO;\n\n    }\n\n    /* Check doubleword aligned and 31 or 24 (fmt 0) bit addressable. */\n\n    if (ccw_addr & (sch->ccw_fmt_1 ? 0x80000007 : 0xff000007)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* Translate everything to format-1 ccws - the information is the same. */\n\n    ccw = copy_ccw_from_guest(ccw_addr, sch->ccw_fmt_1);\n\n\n\n    /* Check for invalid command codes. */\n\n    if ((ccw.cmd_code & 0x0f) == 0) {\n\n        return -EINVAL;\n\n    }\n\n    if (((ccw.cmd_code & 0x0f) == CCW_CMD_TIC) &&\n\n        ((ccw.cmd_code & 0xf0) != 0)) {\n\n        return -EINVAL;\n\n    }\n\n    if (!sch->ccw_fmt_1 && (ccw.count == 0) &&\n\n        (ccw.cmd_code != CCW_CMD_TIC)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* We don't support MIDA. */\n\n    if (ccw.flags & CCW_FLAG_MIDA) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (ccw.flags & CCW_FLAG_SUSPEND) {\n\n        return suspend_allowed ? -EINPROGRESS : -EINVAL;\n\n    }\n\n\n\n    check_len = !((ccw.flags & CCW_FLAG_SLI) && !(ccw.flags & CCW_FLAG_DC));\n\n\n\n    if (!ccw.cda) {\n\n        if (sch->ccw_no_data_cnt == 255) {\n\n            return -EINVAL;\n\n        }\n\n        sch->ccw_no_data_cnt++;\n\n    }\n\n\n\n    /* Look at the command. */\n\n    switch (ccw.cmd_code) {\n\n    case CCW_CMD_NOOP:\n\n        /* Nothing to do. */\n\n        ret = 0;\n\n        break;\n\n    case CCW_CMD_BASIC_SENSE:\n\n        if (check_len) {\n\n            if (ccw.count != sizeof(sch->sense_data)) {\n\n                ret = -EINVAL;\n\n                break;\n\n            }\n\n        }\n\n        len = MIN(ccw.count, sizeof(sch->sense_data));\n\n        cpu_physical_memory_write(ccw.cda, sch->sense_data, len);\n\n        sch->curr_status.scsw.count = ccw.count - len;\n\n        memset(sch->sense_data, 0, sizeof(sch->sense_data));\n\n        ret = 0;\n\n        break;\n\n    case CCW_CMD_SENSE_ID:\n\n    {\n\n        SenseId sense_id;\n\n\n\n        copy_sense_id_to_guest(&sense_id, &sch->id);\n\n        /* Sense ID information is device specific. */\n\n        if (check_len) {\n\n            if (ccw.count != sizeof(sense_id)) {\n\n                ret = -EINVAL;\n\n                break;\n\n            }\n\n        }\n\n        len = MIN(ccw.count, sizeof(sense_id));\n\n        /*\n\n         * Only indicate 0xff in the first sense byte if we actually\n\n         * have enough place to store at least bytes 0-3.\n\n         */\n\n        if (len >= 4) {\n\n            sense_id.reserved = 0xff;\n\n        } else {\n\n            sense_id.reserved = 0;\n\n        }\n\n        cpu_physical_memory_write(ccw.cda, &sense_id, len);\n\n        sch->curr_status.scsw.count = ccw.count - len;\n\n        ret = 0;\n\n        break;\n\n    }\n\n    case CCW_CMD_TIC:\n\n        if (sch->last_cmd_valid && (sch->last_cmd.cmd_code == CCW_CMD_TIC)) {\n\n            ret = -EINVAL;\n\n            break;\n\n        }\n\n        if (ccw.flags & (CCW_FLAG_CC | CCW_FLAG_DC)) {\n\n            ret = -EINVAL;\n\n            break;\n\n        }\n\n        sch->channel_prog = ccw.cda;\n\n        ret = -EAGAIN;\n\n        break;\n\n    default:\n\n        if (sch->ccw_cb) {\n\n            /* Handle device specific commands. */\n\n            ret = sch->ccw_cb(sch, ccw);\n\n        } else {\n\n            ret = -ENOSYS;\n\n        }\n\n        break;\n\n    }\n\n    sch->last_cmd = ccw;\n\n    sch->last_cmd_valid = true;\n\n    if (ret == 0) {\n\n        if (ccw.flags & CCW_FLAG_CC) {\n\n            sch->channel_prog += 8;\n\n            ret = -EAGAIN;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 25003}
{"project": "qemu", "commit_id": "466787fbca9b25b47365b3d2c09d308df67a61db", "target": 0, "func": "static void bdrv_detach_child(BdrvChild *child)\n\n{\n\n    if (child->next.le_prev) {\n\n        QLIST_REMOVE(child, next);\n\n        child->next.le_prev = NULL;\n\n    }\n\n\n\n    bdrv_replace_child(child, NULL, false);\n\n\n\n    g_free(child->name);\n\n    g_free(child);\n\n}\n", "idx": 25004}
{"project": "qemu", "commit_id": "d368ba4376b2c1c24175c74b3733b8fe64dbe8a6", "target": 0, "func": "static inline void sdhci_blkgap_write(SDHCIState *s, uint8_t value)\n\n{\n\n    if ((value & SDHC_STOP_AT_GAP_REQ) && (s->blkgap & SDHC_STOP_AT_GAP_REQ)) {\n\n        return;\n\n    }\n\n    s->blkgap = value & SDHC_STOP_AT_GAP_REQ;\n\n\n\n    if ((value & SDHC_CONTINUE_REQ) && s->stopped_state &&\n\n            (s->blkgap & SDHC_STOP_AT_GAP_REQ) == 0) {\n\n        if (s->stopped_state == sdhc_gap_read) {\n\n            s->prnsts |= SDHC_DAT_LINE_ACTIVE | SDHC_DOING_READ;\n\n            SDHCI_GET_CLASS(s)->read_block_from_card(s);\n\n        } else {\n\n            s->prnsts |= SDHC_DAT_LINE_ACTIVE | SDHC_DOING_WRITE;\n\n            SDHCI_GET_CLASS(s)->write_block_to_card(s);\n\n        }\n\n        s->stopped_state = sdhc_not_stopped;\n\n    } else if (!s->stopped_state && (value & SDHC_STOP_AT_GAP_REQ)) {\n\n        if (s->prnsts & SDHC_DOING_READ) {\n\n            s->stopped_state = sdhc_gap_read;\n\n        } else if (s->prnsts & SDHC_DOING_WRITE) {\n\n            s->stopped_state = sdhc_gap_write;\n\n        }\n\n    }\n\n}\n", "idx": 25005}
{"project": "qemu", "commit_id": "048c74c4379789d03c857cea038ec00d95b68eaf", "target": 0, "func": "RTCState *rtc_mm_init(target_phys_addr_t base, int it_shift, qemu_irq irq,\n\n                      int base_year)\n\n{\n\n    RTCState *s;\n\n    int io_memory;\n\n\n\n    s = qemu_mallocz(sizeof(RTCState));\n\n\n\n    s->irq = irq;\n\n    s->cmos_data[RTC_REG_A] = 0x26;\n\n    s->cmos_data[RTC_REG_B] = 0x02;\n\n    s->cmos_data[RTC_REG_C] = 0x00;\n\n    s->cmos_data[RTC_REG_D] = 0x80;\n\n\n\n    s->base_year = base_year;\n\n    rtc_set_date_from_host(s);\n\n\n\n    s->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, s);\n\n    s->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, s);\n\n    s->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, s);\n\n\n\n    s->next_second_time =\n\n        qemu_get_clock(rtc_clock) + (get_ticks_per_sec() * 99) / 100;\n\n    qemu_mod_timer(s->second_timer2, s->next_second_time);\n\n\n\n    io_memory = cpu_register_io_memory(rtc_mm_read, rtc_mm_write, s);\n\n    cpu_register_physical_memory(base, 2 << it_shift, io_memory);\n\n\n\n    register_savevm(\"mc146818rtc\", base, 1, rtc_save, rtc_load, s);\n\n#ifdef TARGET_I386\n\n    if (rtc_td_hack)\n\n        register_savevm(\"mc146818rtc-td\", base, 1, rtc_save_td, rtc_load_td, s);\n\n#endif\n\n    qemu_register_reset(rtc_reset, s);\n\n    return s;\n\n}\n", "idx": 25006}
{"project": "qemu", "commit_id": "0ab07c623c629acfbc792e5a174129c19faefbb7", "target": 0, "func": "void run_on_cpu(CPUState *env, void (*func)(void *data), void *data)\n\n{\n\n    struct qemu_work_item wi;\n\n\n\n    if (qemu_cpu_self(env)) {\n\n        func(data);\n\n        return;\n\n    }\n\n\n\n    wi.func = func;\n\n    wi.data = data;\n\n    if (!env->queued_work_first)\n\n        env->queued_work_first = &wi;\n\n    else\n\n        env->queued_work_last->next = &wi;\n\n    env->queued_work_last = &wi;\n\n    wi.next = NULL;\n\n    wi.done = false;\n\n\n\n    qemu_cpu_kick(env);\n\n    while (!wi.done) {\n\n        CPUState *self_env = cpu_single_env;\n\n\n\n        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);\n\n        cpu_single_env = self_env;\n\n    }\n\n}\n", "idx": 25007}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "INLINE float64 packFloat64( flag zSign, int16 zExp, bits64 zSig )\n\n{\n\n\n\n    return ( ( (bits64) zSign )<<63 ) + ( ( (bits64) zExp )<<52 ) + zSig;\n\n\n\n}\n", "idx": 25008}
{"project": "qemu", "commit_id": "e1c7f0e3f998866bedc9bdb53d247859b7beb5ce", "target": 0, "func": "static int qcow_create2(const char *filename, int64_t total_size,\n\n                        const char *backing_file, const char *backing_format,\n\n                        int flags, size_t cluster_size, int prealloc)\n\n{\n\n\n\n    int fd, header_size, backing_filename_len, l1_size, i, shift, l2_bits;\n\n    int ref_clusters, backing_format_len = 0;\n\n    QCowHeader header;\n\n    uint64_t tmp, offset;\n\n    QCowCreateState s1, *s = &s1;\n\n    QCowExtension ext_bf = {0, 0};\n\n\n\n\n\n    memset(s, 0, sizeof(*s));\n\n\n\n    fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0644);\n\n    if (fd < 0)\n\n        return -1;\n\n    memset(&header, 0, sizeof(header));\n\n    header.magic = cpu_to_be32(QCOW_MAGIC);\n\n    header.version = cpu_to_be32(QCOW_VERSION);\n\n    header.size = cpu_to_be64(total_size * 512);\n\n    header_size = sizeof(header);\n\n    backing_filename_len = 0;\n\n    if (backing_file) {\n\n        if (backing_format) {\n\n            ext_bf.magic = QCOW_EXT_MAGIC_BACKING_FORMAT;\n\n            backing_format_len = strlen(backing_format);\n\n            ext_bf.len = (backing_format_len + 7) & ~7;\n\n            header_size += ((sizeof(ext_bf) + ext_bf.len + 7) & ~7);\n\n        }\n\n        header.backing_file_offset = cpu_to_be64(header_size);\n\n        backing_filename_len = strlen(backing_file);\n\n        header.backing_file_size = cpu_to_be32(backing_filename_len);\n\n        header_size += backing_filename_len;\n\n    }\n\n\n\n    /* Cluster size */\n\n    s->cluster_bits = get_bits_from_size(cluster_size);\n\n    if (s->cluster_bits < MIN_CLUSTER_BITS ||\n\n        s->cluster_bits > MAX_CLUSTER_BITS)\n\n    {\n\n        fprintf(stderr, \"Cluster size must be a power of two between \"\n\n            \"%d and %dk\\n\",\n\n            1 << MIN_CLUSTER_BITS,\n\n            1 << (MAX_CLUSTER_BITS - 10));\n\n        return -EINVAL;\n\n    }\n\n    s->cluster_size = 1 << s->cluster_bits;\n\n\n\n    header.cluster_bits = cpu_to_be32(s->cluster_bits);\n\n    header_size = (header_size + 7) & ~7;\n\n    if (flags & BLOCK_FLAG_ENCRYPT) {\n\n        header.crypt_method = cpu_to_be32(QCOW_CRYPT_AES);\n\n    } else {\n\n        header.crypt_method = cpu_to_be32(QCOW_CRYPT_NONE);\n\n    }\n\n    l2_bits = s->cluster_bits - 3;\n\n    shift = s->cluster_bits + l2_bits;\n\n    l1_size = (((total_size * 512) + (1LL << shift) - 1) >> shift);\n\n    offset = align_offset(header_size, s->cluster_size);\n\n    s->l1_table_offset = offset;\n\n    header.l1_table_offset = cpu_to_be64(s->l1_table_offset);\n\n    header.l1_size = cpu_to_be32(l1_size);\n\n    offset += align_offset(l1_size * sizeof(uint64_t), s->cluster_size);\n\n\n\n    s->refcount_table = qemu_mallocz(s->cluster_size);\n\n\n\n    s->refcount_table_offset = offset;\n\n    header.refcount_table_offset = cpu_to_be64(offset);\n\n    header.refcount_table_clusters = cpu_to_be32(1);\n\n    offset += s->cluster_size;\n\n    s->refcount_block_offset = offset;\n\n\n\n    /* count how many refcount blocks needed */\n\n    tmp = offset >> s->cluster_bits;\n\n    ref_clusters = (tmp >> (s->cluster_bits - REFCOUNT_SHIFT)) + 1;\n\n    for (i=0; i < ref_clusters; i++) {\n\n        s->refcount_table[i] = cpu_to_be64(offset);\n\n        offset += s->cluster_size;\n\n    }\n\n\n\n    s->refcount_block = qemu_mallocz(ref_clusters * s->cluster_size);\n\n\n\n    /* update refcounts */\n\n    qcow2_create_refcount_update(s, 0, header_size);\n\n    qcow2_create_refcount_update(s, s->l1_table_offset,\n\n        l1_size * sizeof(uint64_t));\n\n    qcow2_create_refcount_update(s, s->refcount_table_offset, s->cluster_size);\n\n    qcow2_create_refcount_update(s, s->refcount_block_offset,\n\n        ref_clusters * s->cluster_size);\n\n\n\n    /* write all the data */\n\n    write(fd, &header, sizeof(header));\n\n    if (backing_file) {\n\n        if (backing_format_len) {\n\n            char zero[16];\n\n            int d = ext_bf.len - backing_format_len;\n\n\n\n            memset(zero, 0, sizeof(zero));\n\n            cpu_to_be32s(&ext_bf.magic);\n\n            cpu_to_be32s(&ext_bf.len);\n\n            write(fd, &ext_bf, sizeof(ext_bf));\n\n            write(fd, backing_format, backing_format_len);\n\n            if (d>0) {\n\n                write(fd, zero, d);\n\n            }\n\n        }\n\n        write(fd, backing_file, backing_filename_len);\n\n    }\n\n    lseek(fd, s->l1_table_offset, SEEK_SET);\n\n    tmp = 0;\n\n    for(i = 0;i < l1_size; i++) {\n\n        write(fd, &tmp, sizeof(tmp));\n\n    }\n\n    lseek(fd, s->refcount_table_offset, SEEK_SET);\n\n    write(fd, s->refcount_table, s->cluster_size);\n\n\n\n    lseek(fd, s->refcount_block_offset, SEEK_SET);\n\n    write(fd, s->refcount_block, ref_clusters * s->cluster_size);\n\n\n\n    qemu_free(s->refcount_table);\n\n    qemu_free(s->refcount_block);\n\n    close(fd);\n\n\n\n    /* Preallocate metadata */\n\n    if (prealloc) {\n\n        BlockDriverState *bs;\n\n        bs = bdrv_new(\"\");\n\n        bdrv_open(bs, filename, BDRV_O_CACHE_WB);\n\n        preallocate(bs);\n\n        bdrv_close(bs);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 25009}
{"project": "qemu", "commit_id": "e48e84ea80cb2e7fe6e48196ce187cfba6e3eb2c", "target": 0, "func": "static void scsi_cd_change_media_cb(void *opaque, bool load)\n\n{\n\n    SCSIDiskState *s = opaque;\n\n\n\n    /*\n\n     * When a CD gets changed, we have to report an ejected state and\n\n     * then a loaded state to guests so that they detect tray\n\n     * open/close and media change events.  Guests that do not use\n\n     * GET_EVENT_STATUS_NOTIFICATION to detect such tray open/close\n\n     * states rely on this behavior.\n\n     *\n\n     * media_changed governs the state machine used for unit attention\n\n     * report.  media_event is used by GET EVENT STATUS NOTIFICATION.\n\n     */\n\n    s->media_changed = load;\n\n    s->tray_open = !load;\n\n    s->qdev.unit_attention = SENSE_CODE(UNIT_ATTENTION_NO_MEDIUM);\n\n    s->media_event = true;\n\n    s->eject_request = false;\n\n}\n", "idx": 25010}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "static int check_directory_consistency(BDRVVVFATState *s,\n\n\tint cluster_num, const char* path)\n\n{\n\n    int ret = 0;\n\n    unsigned char* cluster = g_malloc(s->cluster_size);\n\n    direntry_t* direntries = (direntry_t*)cluster;\n\n    mapping_t* mapping = find_mapping_for_cluster(s, cluster_num);\n\n\n\n    long_file_name lfn;\n\n    int path_len = strlen(path);\n\n    char path2[PATH_MAX];\n\n\n\n    assert(path_len < PATH_MAX); /* len was tested before! */\n\n    pstrcpy(path2, sizeof(path2), path);\n\n    path2[path_len] = '/';\n\n    path2[path_len + 1] = '\\0';\n\n\n\n    if (mapping) {\n\n\tconst char* basename = get_basename(mapping->path);\n\n\tconst char* basename2 = get_basename(path);\n\n\n\n\tassert(mapping->mode & MODE_DIRECTORY);\n\n\n\n\tassert(mapping->mode & MODE_DELETED);\n\n\tmapping->mode &= ~MODE_DELETED;\n\n\n\n\tif (strcmp(basename, basename2))\n\n\t    schedule_rename(s, cluster_num, g_strdup(path));\n\n    } else\n\n\t/* new directory */\n\n\tschedule_mkdir(s, cluster_num, g_strdup(path));\n\n\n\n    lfn_init(&lfn);\n\n    do {\n\n\tint i;\n\n\tint subret = 0;\n\n\n\n\tret++;\n\n\n\n\tif (s->used_clusters[cluster_num] & USED_ANY) {\n\n\t    fprintf(stderr, \"cluster %d used more than once\\n\", (int)cluster_num);\n\n\t    return 0;\n\n\t}\n\n\ts->used_clusters[cluster_num] = USED_DIRECTORY;\n\n\n\nDLOG(fprintf(stderr, \"read cluster %d (sector %d)\\n\", (int)cluster_num, (int)cluster2sector(s, cluster_num)));\n\n\tsubret = vvfat_read(s->bs, cluster2sector(s, cluster_num), cluster,\n\n\t\ts->sectors_per_cluster);\n\n\tif (subret) {\n\n\t    fprintf(stderr, \"Error fetching direntries\\n\");\n\n\tfail:\n\n\t    free(cluster);\n\n\t    return 0;\n\n\t}\n\n\n\n\tfor (i = 0; i < 0x10 * s->sectors_per_cluster; i++) {\n\n\t    int cluster_count = 0;\n\n\n\nDLOG(fprintf(stderr, \"check direntry %d: \\n\", i); print_direntry(direntries + i));\n\n\t    if (is_volume_label(direntries + i) || is_dot(direntries + i) ||\n\n\t\t    is_free(direntries + i))\n\n\t\tcontinue;\n\n\n\n\t    subret = parse_long_name(&lfn, direntries + i);\n\n\t    if (subret < 0) {\n\n\t\tfprintf(stderr, \"Error in long name\\n\");\n\n\t\tgoto fail;\n\n\t    }\n\n\t    if (subret == 0 || is_free(direntries + i))\n\n\t\tcontinue;\n\n\n\n\t    if (fat_chksum(direntries+i) != lfn.checksum) {\n\n\t\tsubret = parse_short_name(s, &lfn, direntries + i);\n\n\t\tif (subret < 0) {\n\n\t\t    fprintf(stderr, \"Error in short name (%d)\\n\", subret);\n\n\t\t    goto fail;\n\n\t\t}\n\n\t\tif (subret > 0 || !strcmp((char*)lfn.name, \".\")\n\n\t\t\t|| !strcmp((char*)lfn.name, \"..\"))\n\n\t\t    continue;\n\n\t    }\n\n\t    lfn.checksum = 0x100; /* cannot use long name twice */\n\n\n\n\t    if (path_len + 1 + lfn.len >= PATH_MAX) {\n\n\t\tfprintf(stderr, \"Name too long: %s/%s\\n\", path, lfn.name);\n\n\t\tgoto fail;\n\n\t    }\n\n            pstrcpy(path2 + path_len + 1, sizeof(path2) - path_len - 1,\n\n                    (char*)lfn.name);\n\n\n\n\t    if (is_directory(direntries + i)) {\n\n\t\tif (begin_of_direntry(direntries + i) == 0) {\n\n\t\t    DLOG(fprintf(stderr, \"invalid begin for directory: %s\\n\", path2); print_direntry(direntries + i));\n\n\t\t    goto fail;\n\n\t\t}\n\n\t\tcluster_count = check_directory_consistency(s,\n\n\t\t\tbegin_of_direntry(direntries + i), path2);\n\n\t\tif (cluster_count == 0) {\n\n\t\t    DLOG(fprintf(stderr, \"problem in directory %s:\\n\", path2); print_direntry(direntries + i));\n\n\t\t    goto fail;\n\n\t\t}\n\n\t    } else if (is_file(direntries + i)) {\n\n\t\t/* check file size with FAT */\n\n\t\tcluster_count = get_cluster_count_for_direntry(s, direntries + i, path2);\n\n\t\tif (cluster_count !=\n\n\t\t\t(le32_to_cpu(direntries[i].size) + s->cluster_size\n\n\t\t\t - 1) / s->cluster_size) {\n\n\t\t    DLOG(fprintf(stderr, \"Cluster count mismatch\\n\"));\n\n\t\t    goto fail;\n\n\t\t}\n\n\t    } else\n\n                abort(); /* cluster_count = 0; */\n\n\n\n\t    ret += cluster_count;\n\n\t}\n\n\n\n\tcluster_num = modified_fat_get(s, cluster_num);\n\n    } while(!fat_eof(s, cluster_num));\n\n\n\n    free(cluster);\n\n    return ret;\n\n}\n", "idx": 25012}
{"project": "qemu", "commit_id": "380feaffb0fcc8e5f615ed8e86d2e93717a6f2c6", "target": 0, "func": "static void scsi_disk_emulate_write_data(SCSIRequest *req)\n\n{\n\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n\n\n    if (r->iov.iov_len) {\n\n        int buflen = r->iov.iov_len;\n\n        DPRINTF(\"Write buf_len=%zd\\n\", buflen);\n\n        r->iov.iov_len = 0;\n\n        scsi_req_data(&r->req, buflen);\n\n        return;\n\n    }\n\n\n\n    switch (req->cmd.buf[0]) {\n\n    case MODE_SELECT:\n\n    case MODE_SELECT_10:\n\n        /* This also clears the sense buffer for REQUEST SENSE.  */\n\n        scsi_req_complete(&r->req, GOOD);\n\n        break;\n\n\n\n    default:\n\n        abort();\n\n    }\n\n}\n", "idx": 25013}
{"project": "qemu", "commit_id": "c629a4bc9725a1ec64c4c89894ef27c758024516", "target": 0, "func": "bool tcg_cpu_exec(void)\n\n{\n\n    int ret = 0;\n\n\n\n    if (next_cpu == NULL)\n\n        next_cpu = first_cpu;\n\n    for (; next_cpu != NULL; next_cpu = next_cpu->next_cpu) {\n\n        CPUState *env = cur_cpu = next_cpu;\n\n\n\n        qemu_clock_enable(vm_clock,\n\n                          (cur_cpu->singlestep_enabled & SSTEP_NOTIMER) == 0);\n\n\n\n        if (qemu_alarm_pending())\n\n            break;\n\n        if (cpu_can_run(env))\n\n            ret = qemu_cpu_exec(env);\n\n        else if (env->stop)\n\n            break;\n\n\n\n        if (ret == EXCP_DEBUG) {\n\n            gdb_set_stop_cpu(env);\n\n            debug_requested = EXCP_DEBUG;\n\n            break;\n\n        }\n\n    }\n\n    return tcg_has_work();\n\n}\n", "idx": 25014}
{"project": "qemu", "commit_id": "5bbf90be97203c472f47da070c0040b464c0460f", "target": 0, "func": "static void memory_region_dispatch_write(MemoryRegion *mr,\n\n                                         hwaddr addr,\n\n                                         uint64_t data,\n\n                                         unsigned size)\n\n{\n\n    if (!memory_region_access_valid(mr, addr, size, true)) {\n\n        return; /* FIXME: better signalling */\n\n    }\n\n\n\n    adjust_endianness(mr, &data, size);\n\n\n\n    if (!mr->ops->write) {\n\n        mr->ops->old_mmio.write[bitops_ctzl(size)](mr->opaque, addr, data);\n\n        return;\n\n    }\n\n\n\n    /* FIXME: support unaligned access */\n\n    access_with_adjusted_size(addr, &data, size,\n\n                              mr->ops->impl.min_access_size,\n\n                              mr->ops->impl.max_access_size,\n\n                              memory_region_write_accessor, mr);\n\n}\n", "idx": 25015}
{"project": "qemu", "commit_id": "49aa46bb4b894ff8bdb0339ee2a5dd3fcfe93ecd", "target": 0, "func": "int bdrv_eject(BlockDriverState *bs, int eject_flag)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    if (bs->locked) {\n\n        return -EBUSY;\n\n    }\n\n\n\n    if (drv && drv->bdrv_eject) {\n\n        drv->bdrv_eject(bs, eject_flag);\n\n    }\n\n    bs->tray_open = eject_flag;\n\n    return 0;\n\n}\n", "idx": 25016}
{"project": "qemu", "commit_id": "a2db2a1edd06a50b8a862c654cf993368cf9f1d9", "target": 0, "func": "static struct XenDevice *xen_be_del_xendev(int dom, int dev)\n\n{\n\n    struct XenDevice *xendev, *xnext;\n\n\n\n    /*\n\n     * This is pretty much like QTAILQ_FOREACH(xendev, &xendevs, next) but\n\n     * we save the next pointer in xnext because we might free xendev.\n\n     */\n\n    xnext = xendevs.tqh_first;\n\n    while (xnext) {\n\n        xendev = xnext;\n\n        xnext = xendev->next.tqe_next;\n\n\n\n        if (xendev->dom != dom) {\n\n            continue;\n\n        }\n\n        if (xendev->dev != dev && dev != -1) {\n\n            continue;\n\n        }\n\n\n\n        if (xendev->ops->free) {\n\n            xendev->ops->free(xendev);\n\n        }\n\n\n\n        if (xendev->fe) {\n\n            char token[XEN_BUFSIZE];\n\n            snprintf(token, sizeof(token), \"fe:%p\", xendev);\n\n            xs_unwatch(xenstore, xendev->fe, token);\n\n            g_free(xendev->fe);\n\n        }\n\n\n\n        if (xendev->evtchndev != XC_HANDLER_INITIAL_VALUE) {\n\n            xc_evtchn_close(xendev->evtchndev);\n\n        }\n\n        if (xendev->gnttabdev != XC_HANDLER_INITIAL_VALUE) {\n\n            xc_gnttab_close(xendev->gnttabdev);\n\n        }\n\n\n\n        QTAILQ_REMOVE(&xendevs, xendev, next);\n\n        g_free(xendev);\n\n    }\n\n    return NULL;\n\n}\n", "idx": 25017}
{"project": "qemu", "commit_id": "4e2e4e6355959a1af011167b0db5ac7ffd3adf94", "target": 0, "func": "static void kvm_init_irq_routing(KVMState *s)\n\n{\n\n    int gsi_count;\n\n\n\n    gsi_count = kvm_check_extension(s, KVM_CAP_IRQ_ROUTING);\n\n    if (gsi_count > 0) {\n\n        unsigned int gsi_bits, i;\n\n\n\n        /* Round up so we can search ints using ffs */\n\n        gsi_bits = ALIGN(gsi_count, 32);\n\n        s->used_gsi_bitmap = g_malloc0(gsi_bits / 8);\n\n        s->max_gsi = gsi_bits;\n\n\n\n        /* Mark any over-allocated bits as already in use */\n\n        for (i = gsi_count; i < gsi_bits; i++) {\n\n            set_gsi(s, i);\n\n        }\n\n    }\n\n\n\n    s->irq_routes = g_malloc0(sizeof(*s->irq_routes));\n\n    s->nr_allocated_irq_routes = 0;\n\n\n\n    kvm_arch_init_irq_routing(s);\n\n}\n", "idx": 25019}
{"project": "qemu", "commit_id": "af52fe862fba686713044efdf9158195f84535ab", "target": 0, "func": "static void uart_read_rx_fifo(UartState *s, uint32_t *c)\n\n{\n\n    if ((s->r[R_CR] & UART_CR_RX_DIS) || !(s->r[R_CR] & UART_CR_RX_EN)) {\n\n        return;\n\n    }\n\n\n\n    if (s->rx_count) {\n\n        uint32_t rx_rpos =\n\n                (RX_FIFO_SIZE + s->rx_wpos - s->rx_count) % RX_FIFO_SIZE;\n\n        *c = s->rx_fifo[rx_rpos];\n\n        s->rx_count--;\n\n\n\n        qemu_chr_accept_input(s->chr);\n\n    } else {\n\n        *c = 0;\n\n    }\n\n\n\n    uart_update_status(s);\n\n}\n", "idx": 25020}
{"project": "qemu", "commit_id": "41ecc72ba5932381208e151bf2d2149a0342beff", "target": 0, "func": "static void setup_frame(int sig, struct target_sigaction *ka,\n\n                        target_sigset_t *set, CPUAlphaState *env)\n\n{\n\n    abi_ulong frame_addr, r26;\n\n    struct target_sigframe *frame;\n\n    int err = 0;\n\n\n\n    frame_addr = get_sigframe(ka, env, sizeof(*frame));\n\n    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0)) {\n\n        goto give_sigsegv;\n\n    }\n\n\n\n    err |= setup_sigcontext(&frame->sc, env, frame_addr, set);\n\n\n\n    if (ka->sa_restorer) {\n\n        r26 = ka->sa_restorer;\n\n    } else {\n\n        __put_user(INSN_MOV_R30_R16, &frame->retcode[0]);\n\n        __put_user(INSN_LDI_R0 + TARGET_NR_sigreturn,\n\n                   &frame->retcode[1]);\n\n        __put_user(INSN_CALLSYS, &frame->retcode[2]);\n\n        /* imb() */\n\n        r26 = frame_addr;\n\n    }\n\n\n\n    unlock_user_struct(frame, frame_addr, 1);\n\n\n\n    if (err) {\n\n    give_sigsegv:\n\n        if (sig == TARGET_SIGSEGV) {\n\n            ka->_sa_handler = TARGET_SIG_DFL;\n\n        }\n\n        force_sig(TARGET_SIGSEGV);\n\n    }\n\n\n\n    env->ir[IR_RA] = r26;\n\n    env->ir[IR_PV] = env->pc = ka->_sa_handler;\n\n    env->ir[IR_A0] = sig;\n\n    env->ir[IR_A1] = 0;\n\n    env->ir[IR_A2] = frame_addr + offsetof(struct target_sigframe, sc);\n\n    env->ir[IR_SP] = frame_addr;\n\n}\n", "idx": 25021}
{"project": "qemu", "commit_id": "6d18a7a1ff9665ad48a68a692fdf0a61edefcae8", "target": 0, "func": "static void spin_kick(void *data)\n\n{\n\n    SpinKick *kick = data;\n\n    CPUState *cpu = CPU(kick->cpu);\n\n    CPUPPCState *env = &kick->cpu->env;\n\n    SpinInfo *curspin = kick->spin;\n\n    hwaddr map_size = 64 * 1024 * 1024;\n\n    hwaddr map_start;\n\n\n\n    cpu_synchronize_state(cpu);\n\n    stl_p(&curspin->pir, env->spr[SPR_PIR]);\n\n    env->nip = ldq_p(&curspin->addr) & (map_size - 1);\n\n    env->gpr[3] = ldq_p(&curspin->r3);\n\n    env->gpr[4] = 0;\n\n    env->gpr[5] = 0;\n\n    env->gpr[6] = 0;\n\n    env->gpr[7] = map_size;\n\n    env->gpr[8] = 0;\n\n    env->gpr[9] = 0;\n\n\n\n    map_start = ldq_p(&curspin->addr) & ~(map_size - 1);\n\n    mmubooke_create_initial_mapping(env, 0, map_start, map_size);\n\n\n\n    cpu->halted = 0;\n\n    cpu->exception_index = -1;\n\n    cpu->stopped = false;\n\n    qemu_cpu_kick(cpu);\n\n}\n", "idx": 25022}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void sd_blk_write(SDState *sd, uint64_t addr, uint32_t len)\n\n{\n\n    uint64_t end = addr + len;\n\n\n\n    if ((addr & 511) || len < 512)\n\n        if (!sd->bdrv || bdrv_read(sd->bdrv, addr >> 9, sd->buf, 1) < 0) {\n\n            fprintf(stderr, \"sd_blk_write: read error on host side\\n\");\n\n            return;\n\n        }\n\n\n\n    if (end > (addr & ~511) + 512) {\n\n        memcpy(sd->buf + (addr & 511), sd->data, 512 - (addr & 511));\n\n        if (bdrv_write(sd->bdrv, addr >> 9, sd->buf, 1) < 0) {\n\n            fprintf(stderr, \"sd_blk_write: write error on host side\\n\");\n\n            return;\n\n        }\n\n\n\n        if (bdrv_read(sd->bdrv, end >> 9, sd->buf, 1) < 0) {\n\n            fprintf(stderr, \"sd_blk_write: read error on host side\\n\");\n\n            return;\n\n        }\n\n        memcpy(sd->buf, sd->data + 512 - (addr & 511), end & 511);\n\n        if (bdrv_write(sd->bdrv, end >> 9, sd->buf, 1) < 0) {\n\n            fprintf(stderr, \"sd_blk_write: write error on host side\\n\");\n\n        }\n\n    } else {\n\n        memcpy(sd->buf + (addr & 511), sd->data, len);\n\n        if (!sd->bdrv || bdrv_write(sd->bdrv, addr >> 9, sd->buf, 1) < 0) {\n\n            fprintf(stderr, \"sd_blk_write: write error on host side\\n\");\n\n        }\n\n    }\n\n}\n", "idx": 25023}
{"project": "qemu", "commit_id": "568c73a4783cd981e9aa6de4f15dcda7829643ad", "target": 0, "func": "static void qemu_chr_parse_vc(QemuOpts *opts, ChardevBackend *backend,\n\n                              Error **errp)\n\n{\n\n    int val;\n\n\n\n    backend->vc = g_new0(ChardevVC, 1);\n\n\n\n    val = qemu_opt_get_number(opts, \"width\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_width = true;\n\n        backend->vc->width = val;\n\n    }\n\n\n\n    val = qemu_opt_get_number(opts, \"height\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_height = true;\n\n        backend->vc->height = val;\n\n    }\n\n\n\n    val = qemu_opt_get_number(opts, \"cols\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_cols = true;\n\n        backend->vc->cols = val;\n\n    }\n\n\n\n    val = qemu_opt_get_number(opts, \"rows\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_rows = true;\n\n        backend->vc->rows = val;\n\n    }\n\n}\n", "idx": 25024}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static struct omap_uwire_s *omap_uwire_init(MemoryRegion *system_memory,\n\n                                            target_phys_addr_t base,\n\n                                            qemu_irq txirq, qemu_irq rxirq,\n\n                                            qemu_irq dma,\n\n                                            omap_clk clk)\n\n{\n\n    struct omap_uwire_s *s = (struct omap_uwire_s *)\n\n            g_malloc0(sizeof(struct omap_uwire_s));\n\n\n\n    s->txirq = txirq;\n\n    s->rxirq = rxirq;\n\n    s->txdrq = dma;\n\n    omap_uwire_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_uwire_ops, s, \"omap-uwire\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 25025}
{"project": "qemu", "commit_id": "0c33682d5f29b0a4ae53bdec4c8e52e4fae37b34", "target": 0, "func": "static void exception_action(CPUState *cpu)\n\n{\n\n#if defined(TARGET_I386)\n\n    X86CPU *x86_cpu = X86_CPU(cpu);\n\n    CPUX86State *env1 = &x86_cpu->env;\n\n\n\n    raise_exception_err(env1, cpu->exception_index, env1->error_code);\n\n#else\n\n    cpu_loop_exit(cpu);\n\n#endif\n\n}\n", "idx": 25026}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "void term_printf(const char *fmt, ...)\n\n{\n\n    char buf[4096];\n\n    va_list ap;\n\n    va_start(ap, fmt);\n\n    vsnprintf(buf, sizeof(buf), fmt, ap);\n\n    qemu_chr_write(monitor_hd, buf, strlen(buf));\n\n    va_end(ap);\n\n}\n", "idx": 25027}
{"project": "qemu", "commit_id": "28b70c9dbdce0d517ade9c04c7d7ae05c8b76d2f", "target": 0, "func": "static int scsi_req_length(SCSICommand *cmd, SCSIDevice *dev, uint8_t *buf)\n\n{\n\n    switch (buf[0] >> 5) {\n\n    case 0:\n\n        cmd->xfer = buf[4];\n\n        cmd->len = 6;\n\n        break;\n\n    case 1:\n\n    case 2:\n\n        cmd->xfer = lduw_be_p(&buf[7]);\n\n        cmd->len = 10;\n\n        break;\n\n    case 4:\n\n        cmd->xfer = ldl_be_p(&buf[10]) & 0xffffffffULL;\n\n        cmd->len = 16;\n\n        break;\n\n    case 5:\n\n        cmd->xfer = ldl_be_p(&buf[6]) & 0xffffffffULL;\n\n        cmd->len = 12;\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n\n\n    switch (buf[0]) {\n\n    case TEST_UNIT_READY:\n\n    case REWIND:\n\n    case START_STOP:\n\n    case SET_CAPACITY:\n\n    case WRITE_FILEMARKS:\n\n    case WRITE_FILEMARKS_16:\n\n    case SPACE:\n\n    case RESERVE:\n\n    case RELEASE:\n\n    case ERASE:\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n    case VERIFY_10:\n\n    case SEEK_10:\n\n    case SYNCHRONIZE_CACHE:\n\n    case SYNCHRONIZE_CACHE_16:\n\n    case LOCATE_16:\n\n    case LOCK_UNLOCK_CACHE:\n\n    case SET_CD_SPEED:\n\n    case SET_LIMITS:\n\n    case WRITE_LONG_10:\n\n    case MOVE_MEDIUM:\n\n    case UPDATE_BLOCK:\n\n    case RESERVE_TRACK:\n\n    case SET_READ_AHEAD:\n\n    case PRE_FETCH:\n\n    case PRE_FETCH_16:\n\n    case ALLOW_OVERWRITE:\n\n        cmd->xfer = 0;\n\n        break;\n\n    case MODE_SENSE:\n\n        break;\n\n    case WRITE_SAME_10:\n\n    case WRITE_SAME_16:\n\n        cmd->xfer = dev->blocksize;\n\n        break;\n\n    case READ_CAPACITY_10:\n\n        cmd->xfer = 8;\n\n        break;\n\n    case READ_BLOCK_LIMITS:\n\n        cmd->xfer = 6;\n\n        break;\n\n    case SEND_VOLUME_TAG:\n\n        /* GPCMD_SET_STREAMING from multimedia commands.  */\n\n        if (dev->type == TYPE_ROM) {\n\n            cmd->xfer = buf[10] | (buf[9] << 8);\n\n        } else {\n\n            cmd->xfer = buf[9] | (buf[8] << 8);\n\n        }\n\n        break;\n\n    case WRITE_6:\n\n        /* length 0 means 256 blocks */\n\n        if (cmd->xfer == 0) {\n\n            cmd->xfer = 256;\n\n        }\n\n    case WRITE_10:\n\n    case WRITE_VERIFY_10:\n\n    case WRITE_12:\n\n    case WRITE_VERIFY_12:\n\n    case WRITE_16:\n\n    case WRITE_VERIFY_16:\n\n        cmd->xfer *= dev->blocksize;\n\n        break;\n\n    case READ_6:\n\n    case READ_REVERSE:\n\n        /* length 0 means 256 blocks */\n\n        if (cmd->xfer == 0) {\n\n            cmd->xfer = 256;\n\n        }\n\n    case READ_10:\n\n    case RECOVER_BUFFERED_DATA:\n\n    case READ_12:\n\n    case READ_16:\n\n        cmd->xfer *= dev->blocksize;\n\n        break;\n\n    case FORMAT_UNIT:\n\n        /* MMC mandates the parameter list to be 12-bytes long.  Parameters\n\n         * for block devices are restricted to the header right now.  */\n\n        if (dev->type == TYPE_ROM && (buf[1] & 16)) {\n\n            cmd->xfer = 12;\n\n        } else {\n\n            cmd->xfer = (buf[1] & 16) == 0 ? 0 : (buf[1] & 32 ? 8 : 4);\n\n        }\n\n        break;\n\n    case INQUIRY:\n\n    case RECEIVE_DIAGNOSTIC:\n\n    case SEND_DIAGNOSTIC:\n\n        cmd->xfer = buf[4] | (buf[3] << 8);\n\n        break;\n\n    case READ_CD:\n\n    case READ_BUFFER:\n\n    case WRITE_BUFFER:\n\n    case SEND_CUE_SHEET:\n\n        cmd->xfer = buf[8] | (buf[7] << 8) | (buf[6] << 16);\n\n        break;\n\n    case PERSISTENT_RESERVE_OUT:\n\n        cmd->xfer = ldl_be_p(&buf[5]) & 0xffffffffULL;\n\n        break;\n\n    case ERASE_12:\n\n        if (dev->type == TYPE_ROM) {\n\n            /* MMC command GET PERFORMANCE.  */\n\n            cmd->xfer = scsi_get_performance_length(buf[9] | (buf[8] << 8),\n\n                                                    buf[10], buf[1] & 0x1f);\n\n        }\n\n        break;\n\n    case MECHANISM_STATUS:\n\n    case READ_DVD_STRUCTURE:\n\n    case SEND_DVD_STRUCTURE:\n\n    case MAINTENANCE_OUT:\n\n    case MAINTENANCE_IN:\n\n        if (dev->type == TYPE_ROM) {\n\n            /* GPCMD_REPORT_KEY and GPCMD_SEND_KEY from multi media commands */\n\n            cmd->xfer = buf[9] | (buf[8] << 8);\n\n        }\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 25028}
{"project": "qemu", "commit_id": "cca7fad5765251fece44cd230156a101867522dd", "target": 0, "func": "static void spapr_phb_finish_realize(sPAPRPHBState *sphb, Error **errp)\n\n{\n\n    sphb->dma_window_start = 0;\n\n    sphb->dma_window_size = 0x40000000;\n\n    sphb->tcet = spapr_tce_new_table(DEVICE(sphb), sphb->dma_liobn,\n\n                                     sphb->dma_window_size);\n\n    if (!sphb->tcet) {\n\n        error_setg(errp, \"Unable to create TCE table for %s\",\n\n                   sphb->dtbusname);\n\n        return ;\n\n    }\n\n    address_space_init(&sphb->iommu_as, spapr_tce_get_iommu(sphb->tcet),\n\n                       sphb->dtbusname);\n\n}\n", "idx": 25030}
{"project": "qemu", "commit_id": "973945804d95878375b487c0c5c9b2556c5e4543", "target": 0, "func": "static void tcx_rblit_writel(void *opaque, hwaddr addr,\n\n                         uint64_t val, unsigned size)\n\n{\n\n    TCXState *s = opaque;\n\n    uint32_t adsr, len;\n\n    int i;\n\n\n\n    if (!(addr & 4)) {\n\n        s->tmpblit = val;\n\n    } else {\n\n        addr = (addr >> 3) & 0xfffff;\n\n        adsr = val & 0xffffff;\n\n        len = ((val >> 24) & 0x1f) + 1;\n\n        if (adsr == 0xffffff) {\n\n            memset(&s->vram[addr], s->tmpblit, len);\n\n            if (s->depth == 24) {\n\n                val = s->tmpblit & 0xffffff;\n\n                val = cpu_to_be32(val);\n\n                for (i = 0; i < len; i++) {\n\n                    s->vram24[addr + i] = val;\n\n                    s->cplane[addr + i] = val;\n\n                }\n\n            }\n\n        } else {\n\n            memcpy(&s->vram[addr], &s->vram[adsr], len);\n\n            if (s->depth == 24) {\n\n                memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4);\n\n                memcpy(&s->cplane[addr], &s->cplane[adsr], len * 4);\n\n            }\n\n        }\n\n        memory_region_set_dirty(&s->vram_mem, addr, len);\n\n    }\n\n}\n", "idx": 25031}
{"project": "qemu", "commit_id": "130257dc443574a9da91dc293665be2cfc40245a", "target": 0, "func": "static CharDriverState *qemu_chr_open_mux(const char *id,\n\n                                          ChardevBackend *backend,\n\n                                          ChardevReturn *ret, Error **errp)\n\n{\n\n    ChardevMux *mux = backend->mux;\n\n    CharDriverState *chr, *drv;\n\n    MuxDriver *d;\n\n\n\n    drv = qemu_chr_find(mux->chardev);\n\n    if (drv == NULL) {\n\n        error_setg(errp, \"mux: base chardev %s not found\", mux->chardev);\n\n        return NULL;\n\n    }\n\n\n\n    chr = qemu_chr_alloc();\n\n    d = g_new0(MuxDriver, 1);\n\n\n\n    chr->opaque = d;\n\n    d->drv = drv;\n\n    d->focus = -1;\n\n    chr->chr_write = mux_chr_write;\n\n    chr->chr_update_read_handler = mux_chr_update_read_handler;\n\n    chr->chr_accept_input = mux_chr_accept_input;\n\n    /* Frontend guest-open / -close notification is not support with muxes */\n\n    chr->chr_set_fe_open = NULL;\n\n    if (drv->chr_add_watch) {\n\n        chr->chr_add_watch = mux_chr_add_watch;\n\n    }\n\n    /* only default to opened state if we've realized the initial\n\n     * set of muxes\n\n     */\n\n    chr->explicit_be_open = muxes_realized ? 0 : 1;\n\n    chr->is_mux = 1;\n\n\n\n    return chr;\n\n}\n", "idx": 25032}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void pmac_ide_transfer(DBDMA_io *io)\n\n{\n\n    MACIOIDEState *m = io->opaque;\n\n    IDEState *s = idebus_active_if(&m->bus);\n\n\n\n    MACIO_DPRINTF(\"\\n\");\n\n\n\n    s->io_buffer_size = 0;\n\n    if (s->drive_kind == IDE_CD) {\n\n\n\n        /* Handle non-block ATAPI DMA transfers */\n\n        if (s->lba == -1) {\n\n            s->io_buffer_size = MIN(io->len, s->packet_transfer_size);\n\n            block_acct_start(bdrv_get_stats(s->bs), &s->acct, s->io_buffer_size,\n\n                             BLOCK_ACCT_READ);\n\n            MACIO_DPRINTF(\"non-block ATAPI DMA transfer size: %d\\n\",\n\n                          s->io_buffer_size);\n\n\n\n            /* Copy ATAPI buffer directly to RAM and finish */\n\n            cpu_physical_memory_write(io->addr, s->io_buffer,\n\n                                      s->io_buffer_size);\n\n            ide_atapi_cmd_ok(s);\n\n            m->dma_active = false;\n\n\n\n            MACIO_DPRINTF(\"end of non-block ATAPI DMA transfer\\n\");\n\n            block_acct_done(bdrv_get_stats(s->bs), &s->acct);\n\n            io->dma_end(io);\n\n            return;\n\n        }\n\n\n\n        block_acct_start(bdrv_get_stats(s->bs), &s->acct, io->len,\n\n                         BLOCK_ACCT_READ);\n\n        pmac_ide_atapi_transfer_cb(io, 0);\n\n        return;\n\n    }\n\n\n\n    switch (s->dma_cmd) {\n\n    case IDE_DMA_READ:\n\n        block_acct_start(bdrv_get_stats(s->bs), &s->acct, io->len,\n\n                         BLOCK_ACCT_READ);\n\n        break;\n\n    case IDE_DMA_WRITE:\n\n        block_acct_start(bdrv_get_stats(s->bs), &s->acct, io->len,\n\n                         BLOCK_ACCT_WRITE);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    io->requests++;\n\n    pmac_ide_transfer_cb(io, 0);\n\n}\n", "idx": 25033}
{"project": "qemu", "commit_id": "cc0c4185e54867ef93c4b4dc0a8f3ecbc20ece42", "target": 0, "func": "static void do_cpu_set(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    int index = qdict_get_int(qdict, \"index\");\n\n    if (mon_set_cpu(index) < 0)\n\n        qemu_error_new(QERR_INVALID_CPU_INDEX);\n\n}\n", "idx": 25034}
{"project": "qemu", "commit_id": "88e8add8b6656c349a96b447b074688d02dc5415", "target": 0, "func": "static int get_phys_addr_lpae(CPUARMState *env, target_ulong address,\n\n                              int access_type, ARMMMUIdx mmu_idx,\n\n                              hwaddr *phys_ptr, MemTxAttrs *txattrs, int *prot,\n\n                              target_ulong *page_size_ptr)\n\n{\n\n    CPUState *cs = CPU(arm_env_get_cpu(env));\n\n    /* Read an LPAE long-descriptor translation table. */\n\n    MMUFaultType fault_type = translation_fault;\n\n    uint32_t level = 1;\n\n    uint32_t epd;\n\n    int32_t tsz;\n\n    uint32_t tg;\n\n    uint64_t ttbr;\n\n    int ttbr_select;\n\n    hwaddr descaddr, descmask;\n\n    uint32_t tableattrs;\n\n    target_ulong page_size;\n\n    uint32_t attrs;\n\n    int32_t granule_sz = 9;\n\n    int32_t va_size = 32;\n\n    int32_t tbi = 0;\n\n    TCR *tcr = regime_tcr(env, mmu_idx);\n\n    int ap, ns, xn, pxn;\n\n\n\n    /* TODO:\n\n     * This code assumes we're either a 64-bit EL1 or a 32-bit PL1;\n\n     * it doesn't handle the different format TCR for TCR_EL2, TCR_EL3,\n\n     * and VTCR_EL2, or the fact that those regimes don't have a split\n\n     * TTBR0/TTBR1. Attribute and permission bit handling should also\n\n     * be checked when adding support for those page table walks.\n\n     */\n\n    if (arm_el_is_aa64(env, regime_el(env, mmu_idx))) {\n\n        va_size = 64;\n\n        if (extract64(address, 55, 1))\n\n            tbi = extract64(tcr->raw_tcr, 38, 1);\n\n        else\n\n            tbi = extract64(tcr->raw_tcr, 37, 1);\n\n        tbi *= 8;\n\n    }\n\n\n\n    /* Determine whether this address is in the region controlled by\n\n     * TTBR0 or TTBR1 (or if it is in neither region and should fault).\n\n     * This is a Non-secure PL0/1 stage 1 translation, so controlled by\n\n     * TTBCR/TTBR0/TTBR1 in accordance with ARM ARM DDI0406C table B-32:\n\n     */\n\n    uint32_t t0sz = extract32(tcr->raw_tcr, 0, 6);\n\n    if (va_size == 64) {\n\n        t0sz = MIN(t0sz, 39);\n\n        t0sz = MAX(t0sz, 16);\n\n    }\n\n    uint32_t t1sz = extract32(tcr->raw_tcr, 16, 6);\n\n    if (va_size == 64) {\n\n        t1sz = MIN(t1sz, 39);\n\n        t1sz = MAX(t1sz, 16);\n\n    }\n\n    if (t0sz && !extract64(address, va_size - t0sz, t0sz - tbi)) {\n\n        /* there is a ttbr0 region and we are in it (high bits all zero) */\n\n        ttbr_select = 0;\n\n    } else if (t1sz && !extract64(~address, va_size - t1sz, t1sz - tbi)) {\n\n        /* there is a ttbr1 region and we are in it (high bits all one) */\n\n        ttbr_select = 1;\n\n    } else if (!t0sz) {\n\n        /* ttbr0 region is \"everything not in the ttbr1 region\" */\n\n        ttbr_select = 0;\n\n    } else if (!t1sz) {\n\n        /* ttbr1 region is \"everything not in the ttbr0 region\" */\n\n        ttbr_select = 1;\n\n    } else {\n\n        /* in the gap between the two regions, this is a Translation fault */\n\n        fault_type = translation_fault;\n\n        goto do_fault;\n\n    }\n\n\n\n    /* Note that QEMU ignores shareability and cacheability attributes,\n\n     * so we don't need to do anything with the SH, ORGN, IRGN fields\n\n     * in the TTBCR.  Similarly, TTBCR:A1 selects whether we get the\n\n     * ASID from TTBR0 or TTBR1, but QEMU's TLB doesn't currently\n\n     * implement any ASID-like capability so we can ignore it (instead\n\n     * we will always flush the TLB any time the ASID is changed).\n\n     */\n\n    if (ttbr_select == 0) {\n\n        ttbr = regime_ttbr(env, mmu_idx, 0);\n\n        epd = extract32(tcr->raw_tcr, 7, 1);\n\n        tsz = t0sz;\n\n\n\n        tg = extract32(tcr->raw_tcr, 14, 2);\n\n        if (tg == 1) { /* 64KB pages */\n\n            granule_sz = 13;\n\n        }\n\n        if (tg == 2) { /* 16KB pages */\n\n            granule_sz = 11;\n\n        }\n\n    } else {\n\n        ttbr = regime_ttbr(env, mmu_idx, 1);\n\n        epd = extract32(tcr->raw_tcr, 23, 1);\n\n        tsz = t1sz;\n\n\n\n        tg = extract32(tcr->raw_tcr, 30, 2);\n\n        if (tg == 3)  { /* 64KB pages */\n\n            granule_sz = 13;\n\n        }\n\n        if (tg == 1) { /* 16KB pages */\n\n            granule_sz = 11;\n\n        }\n\n    }\n\n\n\n    /* Here we should have set up all the parameters for the translation:\n\n     * va_size, ttbr, epd, tsz, granule_sz, tbi\n\n     */\n\n\n\n    if (epd) {\n\n        /* Translation table walk disabled => Translation fault on TLB miss */\n\n        goto do_fault;\n\n    }\n\n\n\n    /* The starting level depends on the virtual address size (which can be\n\n     * up to 48 bits) and the translation granule size. It indicates the number\n\n     * of strides (granule_sz bits at a time) needed to consume the bits\n\n     * of the input address. In the pseudocode this is:\n\n     *  level = 4 - RoundUp((inputsize - grainsize) / stride)\n\n     * where their 'inputsize' is our 'va_size - tsz', 'grainsize' is\n\n     * our 'granule_sz + 3' and 'stride' is our 'granule_sz'.\n\n     * Applying the usual \"rounded up m/n is (m+n-1)/n\" and simplifying:\n\n     *     = 4 - (va_size - tsz - granule_sz - 3 + granule_sz - 1) / granule_sz\n\n     *     = 4 - (va_size - tsz - 4) / granule_sz;\n\n     */\n\n    level = 4 - (va_size - tsz - 4) / granule_sz;\n\n\n\n    /* Clear the vaddr bits which aren't part of the within-region address,\n\n     * so that we don't have to special case things when calculating the\n\n     * first descriptor address.\n\n     */\n\n    if (tsz) {\n\n        address &= (1ULL << (va_size - tsz)) - 1;\n\n    }\n\n\n\n    descmask = (1ULL << (granule_sz + 3)) - 1;\n\n\n\n    /* Now we can extract the actual base address from the TTBR */\n\n    descaddr = extract64(ttbr, 0, 48);\n\n    descaddr &= ~((1ULL << (va_size - tsz - (granule_sz * (4 - level)))) - 1);\n\n\n\n    /* Secure accesses start with the page table in secure memory and\n\n     * can be downgraded to non-secure at any step. Non-secure accesses\n\n     * remain non-secure. We implement this by just ORing in the NSTable/NS\n\n     * bits at each step.\n\n     */\n\n    tableattrs = regime_is_secure(env, mmu_idx) ? 0 : (1 << 4);\n\n    for (;;) {\n\n        uint64_t descriptor;\n\n        bool nstable;\n\n\n\n        descaddr |= (address >> (granule_sz * (4 - level))) & descmask;\n\n        descaddr &= ~7ULL;\n\n        nstable = extract32(tableattrs, 4, 1);\n\n        descriptor = arm_ldq_ptw(cs, descaddr, !nstable);\n\n        if (!(descriptor & 1) ||\n\n            (!(descriptor & 2) && (level == 3))) {\n\n            /* Invalid, or the Reserved level 3 encoding */\n\n            goto do_fault;\n\n        }\n\n        descaddr = descriptor & 0xfffffff000ULL;\n\n\n\n        if ((descriptor & 2) && (level < 3)) {\n\n            /* Table entry. The top five bits are attributes which  may\n\n             * propagate down through lower levels of the table (and\n\n             * which are all arranged so that 0 means \"no effect\", so\n\n             * we can gather them up by ORing in the bits at each level).\n\n             */\n\n            tableattrs |= extract64(descriptor, 59, 5);\n\n            level++;\n\n            continue;\n\n        }\n\n        /* Block entry at level 1 or 2, or page entry at level 3.\n\n         * These are basically the same thing, although the number\n\n         * of bits we pull in from the vaddr varies.\n\n         */\n\n        page_size = (1ULL << ((granule_sz * (4 - level)) + 3));\n\n        descaddr |= (address & (page_size - 1));\n\n        /* Extract attributes from the descriptor and merge with table attrs */\n\n        attrs = extract64(descriptor, 2, 10)\n\n            | (extract64(descriptor, 52, 12) << 10);\n\n        attrs |= extract32(tableattrs, 0, 2) << 11; /* XN, PXN */\n\n        attrs |= extract32(tableattrs, 3, 1) << 5; /* APTable[1] => AP[2] */\n\n        /* The sense of AP[1] vs APTable[0] is reversed, as APTable[0] == 1\n\n         * means \"force PL1 access only\", which means forcing AP[1] to 0.\n\n         */\n\n        if (extract32(tableattrs, 2, 1)) {\n\n            attrs &= ~(1 << 4);\n\n        }\n\n        attrs |= nstable << 3; /* NS */\n\n        break;\n\n    }\n\n    /* Here descaddr is the final physical address, and attributes\n\n     * are all in attrs.\n\n     */\n\n    fault_type = access_fault;\n\n    if ((attrs & (1 << 8)) == 0) {\n\n        /* Access flag */\n\n        goto do_fault;\n\n    }\n\n\n\n    ap = extract32(attrs, 4, 2);\n\n    ns = extract32(attrs, 3, 1);\n\n    xn = extract32(attrs, 12, 1);\n\n    pxn = extract32(attrs, 11, 1);\n\n\n\n    *prot = get_S1prot(env, mmu_idx, va_size == 64, ap, ns, xn, pxn);\n\n\n\n    fault_type = permission_fault;\n\n    if (!(*prot & (1 << access_type))) {\n\n        goto do_fault;\n\n    }\n\n\n\n    if (ns) {\n\n        /* The NS bit will (as required by the architecture) have no effect if\n\n         * the CPU doesn't support TZ or this is a non-secure translation\n\n         * regime, because the attribute will already be non-secure.\n\n         */\n\n        txattrs->secure = false;\n\n    }\n\n    *phys_ptr = descaddr;\n\n    *page_size_ptr = page_size;\n\n    return 0;\n\n\n\ndo_fault:\n\n    /* Long-descriptor format IFSR/DFSR value */\n\n    return (1 << 9) | (fault_type << 2) | level;\n\n}\n", "idx": 25035}
{"project": "qemu", "commit_id": "8b714d3747e6870db85dd9382adb8ee371633092", "target": 1, "func": "static void qmp_input_start_struct(Visitor *v, void **obj, const char *kind,\n\n                                   const char *name, size_t size, Error **errp)\n\n{\n\n    QmpInputVisitor *qiv = to_qiv(v);\n\n    const QObject *qobj = qmp_input_get_object(qiv, name);\n\n\n\n    if (!qobj || qobject_type(qobj) != QTYPE_QDICT) {\n\n        error_set(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                  \"QDict\");\n\n        return;\n\n    }\n\n\n\n    qmp_input_push(qiv, qobj, errp);\n\n    if (error_is_set(errp)) {\n\n        return;\n\n    }\n\n\n\n    if (obj) {\n\n        *obj = g_malloc0(size);\n\n    }\n\n}\n", "idx": 25036}
{"project": "qemu", "commit_id": "9a94ee5bb15793ef69692998ef57794a33074134", "target": 1, "func": "static void rtas_start_cpu(PowerPCCPU *cpu_, sPAPRMachineState *spapr,\n\n                           uint32_t token, uint32_t nargs,\n\n                           target_ulong args,\n\n                           uint32_t nret, target_ulong rets)\n\n{\n\n    target_ulong id, start, r3;\n\n    PowerPCCPU *cpu;\n\n\n\n    if (nargs != 3 || nret != 1) {\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    id = rtas_ld(args, 0);\n\n    start = rtas_ld(args, 1);\n\n    r3 = rtas_ld(args, 2);\n\n\n\n    cpu = spapr_find_cpu(id);\n\n    if (cpu != NULL) {\n\n        CPUState *cs = CPU(cpu);\n\n        CPUPPCState *env = &cpu->env;\n\n\n\n\n        if (!cs->halted) {\n\n            rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n\n            return;\n\n        }\n\n\n\n        /* This will make sure qemu state is up to date with kvm, and\n\n         * mark it dirty so our changes get flushed back before the\n\n         * new cpu enters */\n\n        kvm_cpu_synchronize_state(cs);\n\n\n\n        env->msr = (1ULL << MSR_SF) | (1ULL << MSR_ME);\n\n\n\n        /* Enable Power-saving mode Exit Cause exceptions for the new CPU */\n\n        env->spr[SPR_LPCR] |= pcc->lpcr_pm;\n\n\n\n        env->nip = start;\n\n        env->gpr[3] = r3;\n\n        cs->halted = 0;\n\n        spapr_cpu_set_endianness(cpu);\n\n        spapr_cpu_update_tb_offset(cpu);\n\n\n\n        qemu_cpu_kick(cs);\n\n\n\n        rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n        return;\n\n    }\n\n\n\n    /* Didn't find a matching cpu */\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}", "idx": 25039}
{"project": "qemu", "commit_id": "128e4e108949b35dbe351fe122a3e34b834e185a", "target": 1, "func": "int vmstate_register_with_alias_id(DeviceState *dev, int instance_id,\n\n                                   const VMStateDescription *vmsd,\n\n                                   void *opaque, int alias_id,\n\n                                   int required_for_version,\n\n                                   Error **errp)\n\n{\n\n    SaveStateEntry *se;\n\n\n\n    /* If this triggers, alias support can be dropped for the vmsd. */\n\n    assert(alias_id == -1 || required_for_version >= vmsd->minimum_version_id);\n\n\n\n    se = g_new0(SaveStateEntry, 1);\n\n    se->version_id = vmsd->version_id;\n\n    se->section_id = savevm_state.global_section_id++;\n\n    se->opaque = opaque;\n\n    se->vmsd = vmsd;\n\n    se->alias_id = alias_id;\n\n\n\n    if (dev) {\n\n        char *id = qdev_get_dev_path(dev);\n\n        if (id) {\n\n            if (snprintf(se->idstr, sizeof(se->idstr), \"%s/\", id) >=\n\n                sizeof(se->idstr)) {\n\n                error_setg(errp, \"Path too long for VMState (%s)\", id);\n\n\n                g_free(se);\n\n\n\n                return -1;\n\n            }\n\n\n\n\n            se->compat = g_new0(CompatEntry, 1);\n\n            pstrcpy(se->compat->idstr, sizeof(se->compat->idstr), vmsd->name);\n\n            se->compat->instance_id = instance_id == -1 ?\n\n                         calculate_compat_instance_id(vmsd->name) : instance_id;\n\n            instance_id = -1;\n\n        }\n\n    }\n\n    pstrcat(se->idstr, sizeof(se->idstr), vmsd->name);\n\n\n\n    if (instance_id == -1) {\n\n        se->instance_id = calculate_new_instance_id(se->idstr);\n\n    } else {\n\n        se->instance_id = instance_id;\n\n    }\n\n    assert(!se->compat || se->instance_id == 0);\n\n    savevm_state_handler_insert(se);\n\n    return 0;\n\n}", "idx": 25041}
{"project": "qemu", "commit_id": "d6f723b513a0c3c4e58343b7c52a2f9850861fa0", "target": 1, "func": "static void test_qemu_strtoll_max(void)\n\n{\n\n    const char *str = g_strdup_printf(\"%lld\", LLONG_MAX);\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    int64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoll(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, LLONG_MAX);\n\n    g_assert(endptr == str + strlen(str));\n\n}\n", "idx": 25042}
{"project": "qemu", "commit_id": "04c5b17a74c9d6c309181079f8949665b43b0164", "target": 1, "func": "static int cpu_x86_find_by_name(x86_def_t *x86_cpu_def, const char *cpu_model)\n\n{\n\n    unsigned int i;\n\n    x86_def_t *def;\n\n\n\n    char *s = g_strdup(cpu_model);\n\n    char *featurestr, *name = strtok(s, \",\");\n\n    /* Features to be added*/\n\n    uint32_t plus_features = 0, plus_ext_features = 0;\n\n    uint32_t plus_ext2_features = 0, plus_ext3_features = 0;\n\n    uint32_t plus_kvm_features = 0, plus_svm_features = 0;\n\n    /* Features to be removed */\n\n    uint32_t minus_features = 0, minus_ext_features = 0;\n\n    uint32_t minus_ext2_features = 0, minus_ext3_features = 0;\n\n    uint32_t minus_kvm_features = 0, minus_svm_features = 0;\n\n    uint32_t numvalue;\n\n\n\n    for (def = x86_defs; def; def = def->next)\n\n        if (!strcmp(name, def->name))\n\n            break;\n\n    if (kvm_enabled() && strcmp(name, \"host\") == 0) {\n\n        cpu_x86_fill_host(x86_cpu_def);\n\n    } else if (!def) {\n\n        goto error;\n\n    } else {\n\n        memcpy(x86_cpu_def, def, sizeof(*def));\n\n    }\n\n\n\n    plus_kvm_features = ~0; /* not supported bits will be filtered out later */\n\n\n\n    add_flagname_to_bitmaps(\"hypervisor\", &plus_features,\n\n        &plus_ext_features, &plus_ext2_features, &plus_ext3_features,\n\n        &plus_kvm_features, &plus_svm_features);\n\n\n\n    featurestr = strtok(NULL, \",\");\n\n\n\n    while (featurestr) {\n\n        char *val;\n\n        if (featurestr[0] == '+') {\n\n            add_flagname_to_bitmaps(featurestr + 1, &plus_features,\n\n                            &plus_ext_features, &plus_ext2_features,\n\n                            &plus_ext3_features, &plus_kvm_features,\n\n                            &plus_svm_features);\n\n        } else if (featurestr[0] == '-') {\n\n            add_flagname_to_bitmaps(featurestr + 1, &minus_features,\n\n                            &minus_ext_features, &minus_ext2_features,\n\n                            &minus_ext3_features, &minus_kvm_features,\n\n                            &minus_svm_features);\n\n        } else if ((val = strchr(featurestr, '='))) {\n\n            *val = 0; val++;\n\n            if (!strcmp(featurestr, \"family\")) {\n\n                char *err;\n\n                numvalue = strtoul(val, &err, 0);\n\n                if (!*val || *err) {\n\n                    fprintf(stderr, \"bad numerical value %s\\n\", val);\n\n                    goto error;\n\n                }\n\n                x86_cpu_def->family = numvalue;\n\n            } else if (!strcmp(featurestr, \"model\")) {\n\n                char *err;\n\n                numvalue = strtoul(val, &err, 0);\n\n                if (!*val || *err || numvalue > 0xff) {\n\n                    fprintf(stderr, \"bad numerical value %s\\n\", val);\n\n                    goto error;\n\n                }\n\n                x86_cpu_def->model = numvalue;\n\n            } else if (!strcmp(featurestr, \"stepping\")) {\n\n                char *err;\n\n                numvalue = strtoul(val, &err, 0);\n\n                if (!*val || *err || numvalue > 0xf) {\n\n                    fprintf(stderr, \"bad numerical value %s\\n\", val);\n\n                    goto error;\n\n                }\n\n                x86_cpu_def->stepping = numvalue ;\n\n            } else if (!strcmp(featurestr, \"level\")) {\n\n                char *err;\n\n                numvalue = strtoul(val, &err, 0);\n\n                if (!*val || *err) {\n\n                    fprintf(stderr, \"bad numerical value %s\\n\", val);\n\n                    goto error;\n\n                }\n\n                x86_cpu_def->level = numvalue;\n\n            } else if (!strcmp(featurestr, \"xlevel\")) {\n\n                char *err;\n\n                numvalue = strtoul(val, &err, 0);\n\n                if (!*val || *err) {\n\n                    fprintf(stderr, \"bad numerical value %s\\n\", val);\n\n                    goto error;\n\n                }\n\n                if (numvalue < 0x80000000) {\n\n                    numvalue += 0x80000000;\n\n                }\n\n                x86_cpu_def->xlevel = numvalue;\n\n            } else if (!strcmp(featurestr, \"vendor\")) {\n\n                if (strlen(val) != 12) {\n\n                    fprintf(stderr, \"vendor string must be 12 chars long\\n\");\n\n                    goto error;\n\n                }\n\n                x86_cpu_def->vendor1 = 0;\n\n                x86_cpu_def->vendor2 = 0;\n\n                x86_cpu_def->vendor3 = 0;\n\n                for(i = 0; i < 4; i++) {\n\n                    x86_cpu_def->vendor1 |= ((uint8_t)val[i    ]) << (8 * i);\n\n                    x86_cpu_def->vendor2 |= ((uint8_t)val[i + 4]) << (8 * i);\n\n                    x86_cpu_def->vendor3 |= ((uint8_t)val[i + 8]) << (8 * i);\n\n                }\n\n                x86_cpu_def->vendor_override = 1;\n\n            } else if (!strcmp(featurestr, \"model_id\")) {\n\n                pstrcpy(x86_cpu_def->model_id, sizeof(x86_cpu_def->model_id),\n\n                        val);\n\n            } else if (!strcmp(featurestr, \"tsc_freq\")) {\n\n                int64_t tsc_freq;\n\n                char *err;\n\n\n\n                tsc_freq = strtosz_suffix_unit(val, &err,\n\n                                               STRTOSZ_DEFSUFFIX_B, 1000);\n\n                if (!*val || *err) {\n\n                    fprintf(stderr, \"bad numerical value %s\\n\", val);\n\n                    goto error;\n\n                }\n\n                x86_cpu_def->tsc_khz = tsc_freq / 1000;\n\n            } else {\n\n                fprintf(stderr, \"unrecognized feature %s\\n\", featurestr);\n\n                goto error;\n\n            }\n\n        } else if (!strcmp(featurestr, \"check\")) {\n\n            check_cpuid = 1;\n\n        } else if (!strcmp(featurestr, \"enforce\")) {\n\n            check_cpuid = enforce_cpuid = 1;\n\n        } else {\n\n            fprintf(stderr, \"feature string `%s' not in format (+feature|-feature|feature=xyz)\\n\", featurestr);\n\n            goto error;\n\n        }\n\n        featurestr = strtok(NULL, \",\");\n\n    }\n\n    x86_cpu_def->features |= plus_features;\n\n    x86_cpu_def->ext_features |= plus_ext_features;\n\n    x86_cpu_def->ext2_features |= plus_ext2_features;\n\n    x86_cpu_def->ext3_features |= plus_ext3_features;\n\n    x86_cpu_def->kvm_features |= plus_kvm_features;\n\n    x86_cpu_def->svm_features |= plus_svm_features;\n\n    x86_cpu_def->features &= ~minus_features;\n\n    x86_cpu_def->ext_features &= ~minus_ext_features;\n\n    x86_cpu_def->ext2_features &= ~minus_ext2_features;\n\n    x86_cpu_def->ext3_features &= ~minus_ext3_features;\n\n    x86_cpu_def->kvm_features &= ~minus_kvm_features;\n\n    x86_cpu_def->svm_features &= ~minus_svm_features;\n\n    if (check_cpuid) {\n\n        if (check_features_against_host(x86_cpu_def) && enforce_cpuid)\n\n            goto error;\n\n    }\n\n    g_free(s);\n\n    return 0;\n\n\n\nerror:\n\n    g_free(s);\n\n    return -1;\n\n}\n", "idx": 25045}
{"project": "qemu", "commit_id": "6b860806c0dd881373ead661c0f3499eca2c3995", "target": 1, "func": "static int virtio_gpu_ui_info(void *opaque, uint32_t idx, QemuUIInfo *info)\n\n{\n\n    VirtIOGPU *g = opaque;\n\n\n\n    if (idx > g->conf.max_outputs) {\n\n        return -1;\n\n    }\n\n\n\n    g->req_state[idx].x = info->xoff;\n\n    g->req_state[idx].y = info->yoff;\n\n    g->req_state[idx].width = info->width;\n\n    g->req_state[idx].height = info->height;\n\n\n\n    if (info->width && info->height) {\n\n        g->enabled_output_bitmask |= (1 << idx);\n\n    } else {\n\n        g->enabled_output_bitmask &= ~(1 << idx);\n\n    }\n\n\n\n    /* send event to guest */\n\n    virtio_gpu_notify_event(g, VIRTIO_GPU_EVENT_DISPLAY);\n\n    return 0;\n\n}\n", "idx": 25046}
{"project": "qemu", "commit_id": "44d691f7d9b6ebab102a31aa87fe59da8f7feff9", "target": 1, "func": "void spapr_core_unplug(HotplugHandler *hotplug_dev, DeviceState *dev,\n\n                       Error **errp)\n\n{\n\n    sPAPRCPUCore *core = SPAPR_CPU_CORE(OBJECT(dev));\n\n    PowerPCCPU *cpu = POWERPC_CPU(core->threads);\n\n    int id = ppc_get_vcpu_dt_id(cpu);\n\n    sPAPRDRConnector *drc =\n\n        spapr_dr_connector_by_id(SPAPR_DR_CONNECTOR_TYPE_CPU, id);\n\n    sPAPRDRConnectorClass *drck;\n\n    Error *local_err = NULL;\n\n\n\n    g_assert(drc);\n\n\n\n    drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n    drck->detach(drc, dev, spapr_core_release, NULL, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    spapr_hotplug_req_remove_by_index(drc);\n\n}\n", "idx": 25047}
{"project": "qemu", "commit_id": "a9fc37f6bc3f2ab90585cb16493da9f6dcfbfbcf", "target": 1, "func": "static void qobject_input_check_struct(Visitor *v, Error **errp)\n\n{\n\n    QObjectInputVisitor *qiv = to_qiv(v);\n\n    StackObject *tos = QSLIST_FIRST(&qiv->stack);\n\n\n\n    assert(tos && !tos->entry);\n\n    if (qiv->strict) {\n\n        GHashTable *const top_ht = tos->h;\n\n        if (top_ht) {\n\n            GHashTableIter iter;\n\n            const char *key;\n\n\n\n            g_hash_table_iter_init(&iter, top_ht);\n\n            if (g_hash_table_iter_next(&iter, (void **)&key, NULL)) {\n\n                error_setg(errp, \"Parameter '%s' is unexpected\", key);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 25048}
{"project": "qemu", "commit_id": "53bb8cc4855827f2981bf0566076233573a05bd7", "target": 1, "func": "static sd_rsp_type_t sd_normal_command(SDState *sd,\n\n                                       SDRequest req)\n\n{\n\n    uint32_t rca = 0x0000;\n\n    uint64_t addr = (sd->ocr & (1 << 30)) ? (uint64_t) req.arg << 9 : req.arg;\n\n\n\n    if (sd_cmd_type[req.cmd] == sd_ac || sd_cmd_type[req.cmd] == sd_adtc)\n\n        rca = req.arg >> 16;\n\n\n\n    DPRINTF(\"CMD%d 0x%08x state %d\\n\", req.cmd, req.arg, sd->state);\n\n    switch (req.cmd) {\n\n    /* Basic commands (Class 0 and Class 1) */\n\n    case 0:\t/* CMD0:   GO_IDLE_STATE */\n\n        switch (sd->state) {\n\n        case sd_inactive_state:\n\n            return sd->spi ? sd_r1 : sd_r0;\n\n\n\n        default:\n\n            sd->state = sd_idle_state;\n\n            sd_reset(sd, sd->bdrv);\n\n            return sd->spi ? sd_r1 : sd_r0;\n\n        }\n\n        break;\n\n\n\n    case 1:\t/* CMD1:   SEND_OP_CMD */\n\n        if (!sd->spi)\n\n            goto bad_cmd;\n\n\n\n        sd->state = sd_transfer_state;\n\n        return sd_r1;\n\n\n\n    case 2:\t/* CMD2:   ALL_SEND_CID */\n\n        if (sd->spi)\n\n            goto bad_cmd;\n\n        switch (sd->state) {\n\n        case sd_ready_state:\n\n            sd->state = sd_identification_state;\n\n            return sd_r2_i;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 3:\t/* CMD3:   SEND_RELATIVE_ADDR */\n\n        if (sd->spi)\n\n            goto bad_cmd;\n\n        switch (sd->state) {\n\n        case sd_identification_state:\n\n        case sd_standby_state:\n\n            sd->state = sd_standby_state;\n\n            sd_set_rca(sd);\n\n            return sd_r6;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 4:\t/* CMD4:   SEND_DSR */\n\n        if (sd->spi)\n\n            goto bad_cmd;\n\n        switch (sd->state) {\n\n        case sd_standby_state:\n\n            break;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 5: /* CMD5: reserved for SDIO cards */\n\n        sd->card_status |= ILLEGAL_COMMAND;\n\n        return sd_r0;\n\n\n\n    case 6:\t/* CMD6:   SWITCH_FUNCTION */\n\n        if (sd->spi)\n\n            goto bad_cmd;\n\n        switch (sd->mode) {\n\n        case sd_data_transfer_mode:\n\n            sd_function_switch(sd, req.arg);\n\n            sd->state = sd_sendingdata_state;\n\n            sd->data_start = 0;\n\n            sd->data_offset = 0;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 7:\t/* CMD7:   SELECT/DESELECT_CARD */\n\n        if (sd->spi)\n\n            goto bad_cmd;\n\n        switch (sd->state) {\n\n        case sd_standby_state:\n\n            if (sd->rca != rca)\n\n                return sd_r0;\n\n\n\n            sd->state = sd_transfer_state;\n\n            return sd_r1b;\n\n\n\n        case sd_transfer_state:\n\n        case sd_sendingdata_state:\n\n            if (sd->rca == rca)\n\n                break;\n\n\n\n            sd->state = sd_standby_state;\n\n            return sd_r1b;\n\n\n\n        case sd_disconnect_state:\n\n            if (sd->rca != rca)\n\n                return sd_r0;\n\n\n\n            sd->state = sd_programming_state;\n\n            return sd_r1b;\n\n\n\n        case sd_programming_state:\n\n            if (sd->rca == rca)\n\n                break;\n\n\n\n            sd->state = sd_disconnect_state;\n\n            return sd_r1b;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 8:\t/* CMD8:   SEND_IF_COND */\n\n        /* Physical Layer Specification Version 2.00 command */\n\n        switch (sd->state) {\n\n        case sd_idle_state:\n\n            sd->vhs = 0;\n\n\n\n            /* No response if not exactly one VHS bit is set.  */\n\n            if (!(req.arg >> 8) || (req.arg >> ffs(req.arg & ~0xff)))\n\n                return sd->spi ? sd_r7 : sd_r0;\n\n\n\n            /* Accept.  */\n\n            sd->vhs = req.arg;\n\n            return sd_r7;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 9:\t/* CMD9:   SEND_CSD */\n\n        switch (sd->state) {\n\n        case sd_standby_state:\n\n            if (sd->rca != rca)\n\n                return sd_r0;\n\n\n\n            return sd_r2_s;\n\n\n\n        case sd_transfer_state:\n\n            if (!sd->spi)\n\n                break;\n\n            sd->state = sd_sendingdata_state;\n\n            memcpy(sd->data, sd->csd, 16);\n\n            sd->data_start = addr;\n\n            sd->data_offset = 0;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 10:\t/* CMD10:  SEND_CID */\n\n        switch (sd->state) {\n\n        case sd_standby_state:\n\n            if (sd->rca != rca)\n\n                return sd_r0;\n\n\n\n            return sd_r2_i;\n\n\n\n        case sd_transfer_state:\n\n            if (!sd->spi)\n\n                break;\n\n            sd->state = sd_sendingdata_state;\n\n            memcpy(sd->data, sd->cid, 16);\n\n            sd->data_start = addr;\n\n            sd->data_offset = 0;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 11:\t/* CMD11:  READ_DAT_UNTIL_STOP */\n\n        if (sd->spi)\n\n            goto bad_cmd;\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->state = sd_sendingdata_state;\n\n            sd->data_start = req.arg;\n\n            sd->data_offset = 0;\n\n\n\n            if (sd->data_start + sd->blk_len > sd->size)\n\n                sd->card_status |= ADDRESS_ERROR;\n\n            return sd_r0;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 12:\t/* CMD12:  STOP_TRANSMISSION */\n\n        switch (sd->state) {\n\n        case sd_sendingdata_state:\n\n            sd->state = sd_transfer_state;\n\n            return sd_r1b;\n\n\n\n        case sd_receivingdata_state:\n\n            sd->state = sd_programming_state;\n\n            /* Bzzzzzzztt .... Operation complete.  */\n\n            sd->state = sd_transfer_state;\n\n            return sd_r1b;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 13:\t/* CMD13:  SEND_STATUS */\n\n        switch (sd->mode) {\n\n        case sd_data_transfer_mode:\n\n            if (sd->rca != rca)\n\n                return sd_r0;\n\n\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 15:\t/* CMD15:  GO_INACTIVE_STATE */\n\n        if (sd->spi)\n\n            goto bad_cmd;\n\n        switch (sd->mode) {\n\n        case sd_data_transfer_mode:\n\n            if (sd->rca != rca)\n\n                return sd_r0;\n\n\n\n            sd->state = sd_inactive_state;\n\n            return sd_r0;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    /* Block read commands (Classs 2) */\n\n    case 16:\t/* CMD16:  SET_BLOCKLEN */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            if (req.arg > (1 << HWBLOCK_SHIFT))\n\n                sd->card_status |= BLOCK_LEN_ERROR;\n\n            else\n\n                sd->blk_len = req.arg;\n\n\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 17:\t/* CMD17:  READ_SINGLE_BLOCK */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->state = sd_sendingdata_state;\n\n            sd->data_start = addr;\n\n            sd->data_offset = 0;\n\n\n\n            if (sd->data_start + sd->blk_len > sd->size)\n\n                sd->card_status |= ADDRESS_ERROR;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 18:\t/* CMD18:  READ_MULTIPLE_BLOCK */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->state = sd_sendingdata_state;\n\n            sd->data_start = addr;\n\n            sd->data_offset = 0;\n\n\n\n            if (sd->data_start + sd->blk_len > sd->size)\n\n                sd->card_status |= ADDRESS_ERROR;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    /* Block write commands (Class 4) */\n\n    case 24:\t/* CMD24:  WRITE_SINGLE_BLOCK */\n\n        if (sd->spi)\n\n            goto unimplemented_cmd;\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            /* Writing in SPI mode not implemented.  */\n\n            if (sd->spi)\n\n                break;\n\n            sd->state = sd_receivingdata_state;\n\n            sd->data_start = addr;\n\n            sd->data_offset = 0;\n\n            sd->blk_written = 0;\n\n\n\n            if (sd->data_start + sd->blk_len > sd->size)\n\n                sd->card_status |= ADDRESS_ERROR;\n\n            if (sd_wp_addr(sd, sd->data_start))\n\n                sd->card_status |= WP_VIOLATION;\n\n            if (sd->csd[14] & 0x30)\n\n                sd->card_status |= WP_VIOLATION;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 25:\t/* CMD25:  WRITE_MULTIPLE_BLOCK */\n\n        if (sd->spi)\n\n            goto unimplemented_cmd;\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            /* Writing in SPI mode not implemented.  */\n\n            if (sd->spi)\n\n                break;\n\n            sd->state = sd_receivingdata_state;\n\n            sd->data_start = addr;\n\n            sd->data_offset = 0;\n\n            sd->blk_written = 0;\n\n\n\n            if (sd->data_start + sd->blk_len > sd->size)\n\n                sd->card_status |= ADDRESS_ERROR;\n\n            if (sd_wp_addr(sd, sd->data_start))\n\n                sd->card_status |= WP_VIOLATION;\n\n            if (sd->csd[14] & 0x30)\n\n                sd->card_status |= WP_VIOLATION;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 26:\t/* CMD26:  PROGRAM_CID */\n\n        if (sd->spi)\n\n            goto bad_cmd;\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->state = sd_receivingdata_state;\n\n            sd->data_start = 0;\n\n            sd->data_offset = 0;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 27:\t/* CMD27:  PROGRAM_CSD */\n\n        if (sd->spi)\n\n            goto unimplemented_cmd;\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->state = sd_receivingdata_state;\n\n            sd->data_start = 0;\n\n            sd->data_offset = 0;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    /* Write protection (Class 6) */\n\n    case 28:\t/* CMD28:  SET_WRITE_PROT */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            if (addr >= sd->size) {\n\n                sd->card_status |= ADDRESS_ERROR;\n\n                return sd_r1b;\n\n            }\n\n\n\n            sd->state = sd_programming_state;\n\n            sd->wp_groups[addr >> (HWBLOCK_SHIFT +\n\n                            SECTOR_SHIFT + WPGROUP_SHIFT)] = 1;\n\n            /* Bzzzzzzztt .... Operation complete.  */\n\n            sd->state = sd_transfer_state;\n\n            return sd_r1b;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 29:\t/* CMD29:  CLR_WRITE_PROT */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            if (addr >= sd->size) {\n\n                sd->card_status |= ADDRESS_ERROR;\n\n                return sd_r1b;\n\n            }\n\n\n\n            sd->state = sd_programming_state;\n\n            sd->wp_groups[addr >> (HWBLOCK_SHIFT +\n\n                            SECTOR_SHIFT + WPGROUP_SHIFT)] = 0;\n\n            /* Bzzzzzzztt .... Operation complete.  */\n\n            sd->state = sd_transfer_state;\n\n            return sd_r1b;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 30:\t/* CMD30:  SEND_WRITE_PROT */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->state = sd_sendingdata_state;\n\n            *(uint32_t *) sd->data = sd_wpbits(sd, req.arg);\n\n            sd->data_start = addr;\n\n            sd->data_offset = 0;\n\n            return sd_r1b;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    /* Erase commands (Class 5) */\n\n    case 32:\t/* CMD32:  ERASE_WR_BLK_START */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->erase_start = req.arg;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 33:\t/* CMD33:  ERASE_WR_BLK_END */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->erase_end = req.arg;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 38:\t/* CMD38:  ERASE */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            if (sd->csd[14] & 0x30) {\n\n                sd->card_status |= WP_VIOLATION;\n\n                return sd_r1b;\n\n            }\n\n\n\n            sd->state = sd_programming_state;\n\n            sd_erase(sd);\n\n            /* Bzzzzzzztt .... Operation complete.  */\n\n            sd->state = sd_transfer_state;\n\n            return sd_r1b;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    /* Lock card commands (Class 7) */\n\n    case 42:\t/* CMD42:  LOCK_UNLOCK */\n\n        if (sd->spi)\n\n            goto unimplemented_cmd;\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->state = sd_receivingdata_state;\n\n            sd->data_start = 0;\n\n            sd->data_offset = 0;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 52:\n\n    case 53:\n\n        /* CMD52, CMD53: reserved for SDIO cards\n\n         * (see the SDIO Simplified Specification V2.0)\n\n         * Handle as illegal command but do not complain\n\n         * on stderr, as some OSes may use these in their\n\n         * probing for presence of an SDIO card.\n\n         */\n\n        sd->card_status |= ILLEGAL_COMMAND;\n\n        return sd_r0;\n\n\n\n    /* Application specific commands (Class 8) */\n\n    case 55:\t/* CMD55:  APP_CMD */\n\n        if (sd->rca != rca)\n\n            return sd_r0;\n\n\n\n        sd->card_status |= APP_CMD;\n\n        return sd_r1;\n\n\n\n    case 56:\t/* CMD56:  GEN_CMD */\n\n        fprintf(stderr, \"SD: GEN_CMD 0x%08x\\n\", req.arg);\n\n\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->data_offset = 0;\n\n            if (req.arg & 1)\n\n                sd->state = sd_sendingdata_state;\n\n            else\n\n                sd->state = sd_receivingdata_state;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default:\n\n    bad_cmd:\n\n        sd->card_status |= ILLEGAL_COMMAND;\n\n\n\n        fprintf(stderr, \"SD: Unknown CMD%i\\n\", req.cmd);\n\n        return sd_r0;\n\n\n\n    unimplemented_cmd:\n\n        /* Commands that are recognised but not yet implemented in SPI mode.  */\n\n        sd->card_status |= ILLEGAL_COMMAND;\n\n        fprintf(stderr, \"SD: CMD%i not implemented in SPI mode\\n\", req.cmd);\n\n        return sd_r0;\n\n    }\n\n\n\n    sd->card_status |= ILLEGAL_COMMAND;\n\n    fprintf(stderr, \"SD: CMD%i in a wrong state\\n\", req.cmd);\n\n    return sd_r0;\n\n}\n", "idx": 25049}
{"project": "qemu", "commit_id": "40a0d7c395f4d18a8061ba075d8f9aab2fa0ec2a", "target": 1, "func": "create_iovec(QEMUIOVector *qiov, char **argv, int nr_iov, int pattern)\n\n{\n\n\tsize_t *sizes = calloc(nr_iov, sizeof(size_t));\n\n\tsize_t count = 0;\n\n\tvoid *buf, *p;\n\n\tint i;\n\n\n\n\tfor (i = 0; i < nr_iov; i++) {\n\n\t\tchar *arg = argv[i];\n\n\t\tlong long len;\n\n\n\n\t\tlen = cvtnum(arg);\n\n\t\tif (len < 0) {\n\n\t\t\tprintf(\"non-numeric length argument -- %s\\n\", arg);\n\n\t\t\treturn NULL;\n\n\t\t}\n\n\n\n\t\t/* should be SIZE_T_MAX, but that doesn't exist */\n\n\t\tif (len > UINT_MAX) {\n\n\t\t\tprintf(\"too large length argument -- %s\\n\", arg);\n\n\t\t\treturn NULL;\n\n\t\t}\n\n\n\n\t\tif (len & 0x1ff) {\n\n\t\t\tprintf(\"length argument %lld is not sector aligned\\n\",\n\n\t\t\t\tlen);\n\n\t\t\treturn NULL;\n\n\t\t}\n\n\n\n\t\tsizes[i] = len;\n\n\t\tcount += len;\n\n\t}\n\n\n\n\tqemu_iovec_init(qiov, nr_iov);\n\n\n\n\tbuf = p = qemu_io_alloc(count, pattern);\n\n\n\n\tfor (i = 0; i < nr_iov; i++) {\n\n\t\tqemu_iovec_add(qiov, p, sizes[i]);\n\n\t\tp += sizes[i];\n\n\t}\n\n\n\n\tfree(sizes);\n\n\treturn buf;\n\n}\n", "idx": 25052}
{"project": "qemu", "commit_id": "068abdc8a57023eeafe1025b964a50f8a39929b4", "target": 1, "func": "void ppc_cpu_list (FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))\n\n{\n\n    int i;\n\n\n\n    for (i = 0; ; i++) {\n\n        (*cpu_fprintf)(f, \"PowerPC %-16s PVR %08x\\n\",\n\n                       ppc_defs[i].name, ppc_defs[i].pvr);\n\n        if (strcmp(ppc_defs[i].name, \"default\") == 0)\n\n            break;\n\n    }\n\n}\n", "idx": 25054}
{"project": "qemu", "commit_id": "fde9bf4470d4a3b6ee1da0dee2370ab028b6314a", "target": 1, "func": "void object_delete(Object *obj)\n\n{\n\n    object_unparent(obj);\n\n    g_assert(obj->ref == 1);\n\n    object_unref(obj);\n\n    g_free(obj);\n\n}\n", "idx": 25055}
{"project": "qemu", "commit_id": "f2917853f715b0ef55df29eb2ffea29dc69ce814", "target": 1, "func": "static struct scsi_task *iscsi_do_inquiry(struct iscsi_context *iscsi, int lun,\n\n                                          int evpd, int pc)\n\n{\n\n    int full_size;\n\n    struct scsi_task *task = NULL;\n\n    task = iscsi_inquiry_sync(iscsi, lun, evpd, pc, 64);\n\n    if (task == NULL || task->status != SCSI_STATUS_GOOD) {\n\n        goto fail;\n\n    }\n\n    full_size = scsi_datain_getfullsize(task);\n\n    if (full_size > task->datain.size) {\n\n        scsi_free_scsi_task(task);\n\n\n\n        /* we need more data for the full list */\n\n        task = iscsi_inquiry_sync(iscsi, lun, evpd, pc, full_size);\n\n        if (task == NULL || task->status != SCSI_STATUS_GOOD) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    return task;\n\n\n\nfail:\n\n    error_report(\"iSCSI: Inquiry command failed : %s\",\n\n                 iscsi_get_error(iscsi));\n\n    if (task) {\n\n        scsi_free_scsi_task(task);\n\n        return NULL;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 25057}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "static target_ulong h_add_logical_lan_buffer(CPUPPCState *env,\n\n                                             sPAPREnvironment *spapr,\n\n                                             target_ulong opcode,\n\n                                             target_ulong *args)\n\n{\n\n    target_ulong reg = args[0];\n\n    target_ulong buf = args[1];\n\n    VIOsPAPRDevice *sdev = spapr_vio_find_by_reg(spapr->vio_bus, reg);\n\n    VIOsPAPRVLANDevice *dev = (VIOsPAPRVLANDevice *)sdev;\n\n    vlan_bd_t bd;\n\n\n\n    dprintf(\"H_ADD_LOGICAL_LAN_BUFFER(0x\" TARGET_FMT_lx\n\n            \", 0x\" TARGET_FMT_lx \")\\n\", reg, buf);\n\n\n\n    if (!sdev) {\n\n        hcall_dprintf(\"Bad device\\n\");\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    if ((check_bd(dev, buf, 4) < 0)\n\n        || (VLAN_BD_LEN(buf) < 16)) {\n\n        hcall_dprintf(\"Bad buffer enqueued\\n\");\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    if (!dev->isopen || dev->rx_bufs >= VLAN_MAX_BUFS) {\n\n        return H_RESOURCE;\n\n    }\n\n\n\n    do {\n\n        dev->add_buf_ptr += 8;\n\n        if (dev->add_buf_ptr >= SPAPR_VIO_TCE_PAGE_SIZE) {\n\n            dev->add_buf_ptr = VLAN_RX_BDS_OFF;\n\n        }\n\n\n\n        bd = ldq_tce(sdev, dev->buf_list + dev->add_buf_ptr);\n\n    } while (bd & VLAN_BD_VALID);\n\n\n\n    stq_tce(sdev, dev->buf_list + dev->add_buf_ptr, buf);\n\n\n\n    dev->rx_bufs++;\n\n\n\n    dprintf(\"h_add_logical_lan_buffer():  Added buf  ptr=%d  rx_bufs=%d\"\n\n            \" bd=0x%016llx\\n\", dev->add_buf_ptr, dev->rx_bufs,\n\n            (unsigned long long)buf);\n\n\n\n    return H_SUCCESS;\n\n}\n", "idx": 25059}
{"project": "qemu", "commit_id": "b14ef7c9ab41ea824c3ccadb070ad95567cca84e", "target": 1, "func": "static uint32_t unassigned_mem_readw(void *opaque, target_phys_addr_t addr)\n\n{\n\n#ifdef DEBUG_UNASSIGNED\n\n    printf(\"Unassigned mem read \" TARGET_FMT_plx \"\\n\", addr);\n\n#endif\n\n#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)\n\n    do_unassigned_access(addr, 0, 0, 0, 2);\n\n#endif\n\n    return 0;\n\n}\n", "idx": 25060}
{"project": "qemu", "commit_id": "6df5718bd3ec56225c44cf96440c723c1b611b87", "target": 1, "func": "static void megasas_complete_frame(MegasasState *s, uint64_t context)\n\n{\n\n    PCIDevice *pci_dev = PCI_DEVICE(s);\n\n    int tail, queue_offset;\n\n\n\n    /* Decrement busy count */\n\n    s->busy--;\n\n\n\n    if (s->reply_queue_pa) {\n\n        /*\n\n         * Put command on the reply queue.\n\n         * Context is opaque, but emulation is running in\n\n         * little endian. So convert it.\n\n         */\n\n        tail = s->reply_queue_head;\n\n        if (megasas_use_queue64(s)) {\n\n            queue_offset = tail * sizeof(uint64_t);\n\n            stq_le_phys(&address_space_memory,\n\n                        s->reply_queue_pa + queue_offset, context);\n\n        } else {\n\n            queue_offset = tail * sizeof(uint32_t);\n\n            stl_le_phys(&address_space_memory,\n\n                        s->reply_queue_pa + queue_offset, context);\n\n        }\n\n        s->reply_queue_head = megasas_next_index(s, tail, s->fw_cmds);\n\n        s->reply_queue_tail = ldl_le_phys(&address_space_memory,\n\n                                          s->consumer_pa);\n\n        trace_megasas_qf_complete(context, s->reply_queue_head,\n\n                                  s->reply_queue_tail, s->busy, s->doorbell);\n\n    }\n\n\n\n    if (megasas_intr_enabled(s)) {\n\n        /* Notify HBA */\n\n        s->doorbell++;\n\n        if (s->doorbell == 1) {\n\n            if (msix_enabled(pci_dev)) {\n\n                trace_megasas_msix_raise(0);\n\n                msix_notify(pci_dev, 0);\n\n            } else if (msi_enabled(pci_dev)) {\n\n                trace_megasas_msi_raise(0);\n\n                msi_notify(pci_dev, 0);\n\n            } else {\n\n                trace_megasas_irq_raise();\n\n                pci_irq_assert(pci_dev);\n\n            }\n\n        }\n\n    } else {\n\n        trace_megasas_qf_complete_noirq(context);\n\n    }\n\n}\n", "idx": 25063}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_tlbld_6xx(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    gen_helper_6xx_tlbd(cpu_env, cpu_gpr[rB(ctx->opcode)]);\n\n#endif\n\n}\n", "idx": 25067}
{"project": "qemu", "commit_id": "aa0568ff2559d7717f4684af6a83d0bd1a125f56", "target": 1, "func": "static int ehci_process_itd(EHCIState *ehci,\n\n                            EHCIitd *itd)\n\n{\n\n    USBDevice *dev;\n\n    USBEndpoint *ep;\n\n    int ret;\n\n    uint32_t i, len, pid, dir, devaddr, endp;\n\n    uint32_t pg, off, ptr1, ptr2, max, mult;\n\n\n\n    dir =(itd->bufptr[1] & ITD_BUFPTR_DIRECTION);\n\n    devaddr = get_field(itd->bufptr[0], ITD_BUFPTR_DEVADDR);\n\n    endp = get_field(itd->bufptr[0], ITD_BUFPTR_EP);\n\n    max = get_field(itd->bufptr[1], ITD_BUFPTR_MAXPKT);\n\n    mult = get_field(itd->bufptr[2], ITD_BUFPTR_MULT);\n\n\n\n    for(i = 0; i < 8; i++) {\n\n        if (itd->transact[i] & ITD_XACT_ACTIVE) {\n\n            pg   = get_field(itd->transact[i], ITD_XACT_PGSEL);\n\n            off  = itd->transact[i] & ITD_XACT_OFFSET_MASK;\n\n            ptr1 = (itd->bufptr[pg] & ITD_BUFPTR_MASK);\n\n            ptr2 = (itd->bufptr[pg+1] & ITD_BUFPTR_MASK);\n\n            len  = get_field(itd->transact[i], ITD_XACT_LENGTH);\n\n\n\n            if (len > max * mult) {\n\n                len = max * mult;\n\n            }\n\n\n\n            if (len > BUFF_SIZE) {\n\n                return USB_RET_PROCERR;\n\n            }\n\n\n\n            pci_dma_sglist_init(&ehci->isgl, &ehci->dev, 2);\n\n            if (off + len > 4096) {\n\n                /* transfer crosses page border */\n\n                uint32_t len2 = off + len - 4096;\n\n                uint32_t len1 = len - len2;\n\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len1);\n\n                qemu_sglist_add(&ehci->isgl, ptr2, len2);\n\n            } else {\n\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len);\n\n            }\n\n\n\n            pid = dir ? USB_TOKEN_IN : USB_TOKEN_OUT;\n\n\n\n            dev = ehci_find_device(ehci, devaddr);\n\n            ep = usb_ep_get(dev, pid, endp);\n\n            usb_packet_setup(&ehci->ipacket, pid, ep);\n\n            usb_packet_map(&ehci->ipacket, &ehci->isgl);\n\n\n\n            ret = usb_handle_packet(dev, &ehci->ipacket);\n\n\n\n            usb_packet_unmap(&ehci->ipacket);\n\n            qemu_sglist_destroy(&ehci->isgl);\n\n\n\n#if 0\n\n            /*  In isoch, there is no facility to indicate a NAK so let's\n\n             *  instead just complete a zero-byte transaction.  Setting\n\n             *  DBERR seems too draconian.\n\n             */\n\n\n\n            if (ret == USB_RET_NAK) {\n\n                if (ehci->isoch_pause > 0) {\n\n                    DPRINTF(\"ISOCH: received a NAK but paused so returning\\n\");\n\n                    ehci->isoch_pause--;\n\n                    return 0;\n\n                } else if (ehci->isoch_pause == -1) {\n\n                    DPRINTF(\"ISOCH: recv NAK & isoch pause inactive, setting\\n\");\n\n                    // Pause frindex for up to 50 msec waiting for data from\n\n                    // remote\n\n                    ehci->isoch_pause = 50;\n\n                    return 0;\n\n                } else {\n\n                    DPRINTF(\"ISOCH: isoch pause timeout! return 0\\n\");\n\n                    ret = 0;\n\n                }\n\n            } else {\n\n                DPRINTF(\"ISOCH: received ACK, clearing pause\\n\");\n\n                ehci->isoch_pause = -1;\n\n            }\n\n#else\n\n            if (ret == USB_RET_NAK) {\n\n                ret = 0;\n\n            }\n\n#endif\n\n\n\n            if (ret >= 0) {\n\n                if (!dir) {\n\n                    /* OUT */\n\n                    set_field(&itd->transact[i], len - ret, ITD_XACT_LENGTH);\n\n                } else {\n\n                    /* IN */\n\n                    set_field(&itd->transact[i], ret, ITD_XACT_LENGTH);\n\n                }\n\n\n\n                if (itd->transact[i] & ITD_XACT_IOC) {\n\n                    ehci_record_interrupt(ehci, USBSTS_INT);\n\n                }\n\n            }\n\n            itd->transact[i] &= ~ITD_XACT_ACTIVE;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 25068}
{"project": "qemu", "commit_id": "5839e53bbc0fec56021d758aab7610df421ed8c8", "target": 1, "func": "static int vdi_check(BlockDriverState *bs, BdrvCheckResult *res,\n\n                     BdrvCheckMode fix)\n\n{\n\n    /* TODO: additional checks possible. */\n\n    BDRVVdiState *s = (BDRVVdiState *)bs->opaque;\n\n    uint32_t blocks_allocated = 0;\n\n    uint32_t block;\n\n    uint32_t *bmap;\n\n    logout(\"\\n\");\n\n\n\n    if (fix) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    bmap = g_try_malloc(s->header.blocks_in_image * sizeof(uint32_t));\n\n    if (s->header.blocks_in_image && bmap == NULL) {\n\n        res->check_errors++;\n\n        return -ENOMEM;\n\n    }\n\n\n\n    memset(bmap, 0xff, s->header.blocks_in_image * sizeof(uint32_t));\n\n\n\n    /* Check block map and value of blocks_allocated. */\n\n    for (block = 0; block < s->header.blocks_in_image; block++) {\n\n        uint32_t bmap_entry = le32_to_cpu(s->bmap[block]);\n\n        if (VDI_IS_ALLOCATED(bmap_entry)) {\n\n            if (bmap_entry < s->header.blocks_in_image) {\n\n                blocks_allocated++;\n\n                if (!VDI_IS_ALLOCATED(bmap[bmap_entry])) {\n\n                    bmap[bmap_entry] = bmap_entry;\n\n                } else {\n\n                    fprintf(stderr, \"ERROR: block index %\" PRIu32\n\n                            \" also used by %\" PRIu32 \"\\n\", bmap[bmap_entry], bmap_entry);\n\n                    res->corruptions++;\n\n                }\n\n            } else {\n\n                fprintf(stderr, \"ERROR: block index %\" PRIu32\n\n                        \" too large, is %\" PRIu32 \"\\n\", block, bmap_entry);\n\n                res->corruptions++;\n\n            }\n\n        }\n\n    }\n\n    if (blocks_allocated != s->header.blocks_allocated) {\n\n        fprintf(stderr, \"ERROR: allocated blocks mismatch, is %\" PRIu32\n\n               \", should be %\" PRIu32 \"\\n\",\n\n               blocks_allocated, s->header.blocks_allocated);\n\n        res->corruptions++;\n\n    }\n\n\n\n    g_free(bmap);\n\n\n\n    return 0;\n\n}\n", "idx": 25074}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "void helper_idivl_EAX_T0(void)\n\n{\n\n    int den, q, r;\n\n    int64_t num;\n\n    \n\n    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);\n\n    den = T0;\n\n    if (den == 0) {\n\n        raise_exception(EXCP00_DIVZ);\n\n    }\n\n#ifdef BUGGY_GCC_DIV64\n\n    r = idiv32(&q, num, den);\n\n#else\n\n    q = (num / den);\n\n    r = (num % den);\n\n#endif\n\n    EAX = (uint32_t)q;\n\n    EDX = (uint32_t)r;\n\n}\n", "idx": 25075}
{"project": "qemu", "commit_id": "6ab3fc32ea640026726bc5f9f4db622d0954fb8a", "target": 1, "func": "static void uart_write(void *opaque, hwaddr addr,\n\n                       uint64_t value, unsigned size)\n\n{\n\n    LM32UartState *s = opaque;\n\n    unsigned char ch = value;\n\n\n\n    trace_lm32_uart_memory_write(addr, value);\n\n\n\n    addr >>= 2;\n\n    switch (addr) {\n\n    case R_RXTX:\n\n        if (s->chr) {\n\n\n\n            qemu_chr_fe_write_all(s->chr, &ch, 1);\n\n        }\n\n        break;\n\n    case R_IER:\n\n    case R_LCR:\n\n    case R_MCR:\n\n    case R_DIV:\n\n        s->regs[addr] = value;\n\n        break;\n\n    case R_IIR:\n\n    case R_LSR:\n\n    case R_MSR:\n\n        error_report(\"lm32_uart: write access to read only register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    default:\n\n        error_report(\"lm32_uart: write access to unknown register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    }\n\n    uart_update_irq(s);\n\n}", "idx": 25076}
{"project": "qemu", "commit_id": "75cdcd1553e74b5edc58aed23e3b2da8dabb1876", "target": 1, "func": "static void test_opts_parse_size(void)\n\n{\n\n    Error *err = NULL;\n\n    QemuOpts *opts;\n\n\n\n    /* Lower limit zero */\n\n    opts = qemu_opts_parse(&opts_list_02, \"size1=0\", false, &error_abort);\n\n    g_assert_cmpuint(opts_count(opts), ==, 1);\n\n    g_assert_cmpuint(qemu_opt_get_size(opts, \"size1\", 1), ==, 0);\n\n\n\n    /* Note: precision is 53 bits since we're parsing with strtod() */\n\n\n\n    /* Around limit of precision: 2^53-1, 2^53, 2^54 */\n\n    opts = qemu_opts_parse(&opts_list_02,\n\n                           \"size1=9007199254740991,\"\n\n                           \"size2=9007199254740992,\"\n\n                           \"size3=9007199254740993\",\n\n                           false, &error_abort);\n\n    g_assert_cmpuint(opts_count(opts), ==, 3);\n\n    g_assert_cmphex(qemu_opt_get_size(opts, \"size1\", 1),\n\n                     ==, 0x1fffffffffffff);\n\n    g_assert_cmphex(qemu_opt_get_size(opts, \"size2\", 1),\n\n                     ==, 0x20000000000000);\n\n    g_assert_cmphex(qemu_opt_get_size(opts, \"size3\", 1),\n\n                     ==, 0x20000000000000);\n\n\n\n    /* Close to signed upper limit 0x7ffffffffffffc00 (53 msbs set) */\n\n    opts = qemu_opts_parse(&opts_list_02,\n\n                           \"size1=9223372036854774784,\" /* 7ffffffffffffc00 */\n\n                           \"size2=9223372036854775295\", /* 7ffffffffffffdff */\n\n                           false, &error_abort);\n\n    g_assert_cmpuint(opts_count(opts), ==, 2);\n\n    g_assert_cmphex(qemu_opt_get_size(opts, \"size1\", 1),\n\n                     ==, 0x7ffffffffffffc00);\n\n    g_assert_cmphex(qemu_opt_get_size(opts, \"size2\", 1),\n\n                     ==, 0x7ffffffffffffc00);\n\n\n\n    /* Close to actual upper limit 0xfffffffffffff800 (53 msbs set) */\n\n    opts = qemu_opts_parse(&opts_list_02,\n\n                           \"size1=18446744073709549568,\" /* fffffffffffff800 */\n\n                           \"size2=18446744073709550591\", /* fffffffffffffbff */\n\n                           false, &error_abort);\n\n    g_assert_cmpuint(opts_count(opts), ==, 2);\n\n    g_assert_cmphex(qemu_opt_get_size(opts, \"size1\", 1),\n\n                     ==, 0xfffffffffffff800);\n\n    g_assert_cmphex(qemu_opt_get_size(opts, \"size2\", 1),\n\n                     ==, 0xfffffffffffff800);\n\n\n\n    /* Beyond limits */\n\n    opts = qemu_opts_parse(&opts_list_02, \"size1=-1\", false, &err);\n\n    error_free_or_abort(&err);\n\n    g_assert(!opts);\n\n    opts = qemu_opts_parse(&opts_list_02,\n\n                           \"size1=18446744073709550592\", /* fffffffffffffc00 */\n\n                           false, &error_abort);\n\n    /* BUG: should reject */\n\n    g_assert_cmpuint(opts_count(opts), ==, 1);\n\n    g_assert_cmpuint(qemu_opt_get_size(opts, \"size1\", 1), ==, 0);\n\n\n\n    /* Suffixes */\n\n    opts = qemu_opts_parse(&opts_list_02, \"size1=8b,size2=1.5k,size3=2M\",\n\n                           false, &error_abort);\n\n    g_assert_cmpuint(opts_count(opts), ==, 3);\n\n    g_assert_cmphex(qemu_opt_get_size(opts, \"size1\", 0), ==, 8);\n\n    g_assert_cmphex(qemu_opt_get_size(opts, \"size2\", 0), ==, 1536);\n\n    g_assert_cmphex(qemu_opt_get_size(opts, \"size3\", 0), ==, 2 * M_BYTE);\n\n    opts = qemu_opts_parse(&opts_list_02, \"size1=0.1G,size2=16777215T\",\n\n                           false, &error_abort);\n\n    g_assert_cmpuint(opts_count(opts), ==, 2);\n\n    g_assert_cmphex(qemu_opt_get_size(opts, \"size1\", 0), ==, G_BYTE / 10);\n\n    g_assert_cmphex(qemu_opt_get_size(opts, \"size2\", 0),\n\n                     ==, 16777215 * T_BYTE);\n\n\n\n    /* Beyond limit with suffix */\n\n    opts = qemu_opts_parse(&opts_list_02, \"size1=16777216T\",\n\n                           false, &error_abort);\n\n    /* BUG: should reject */\n\n    g_assert_cmpuint(opts_count(opts), ==, 1);\n\n    g_assert_cmpuint(qemu_opt_get_size(opts, \"size1\", 1), ==, 0);\n\n\n\n    /* Trailing crap */\n\n    opts = qemu_opts_parse(&opts_list_02, \"size1=16E\", false, &err);\n\n    error_free_or_abort(&err);\n\n    g_assert(!opts);\n\n    opts = qemu_opts_parse(&opts_list_02, \"size1=16Gi\", false, &error_abort);\n\n    /* BUG: should reject */\n\n    g_assert_cmpuint(opts_count(opts), ==, 1);\n\n    g_assert_cmpuint(qemu_opt_get_size(opts, \"size1\", 1), ==, 16 * G_BYTE);\n\n\n\n    qemu_opts_reset(&opts_list_02);\n\n}\n", "idx": 25078}
{"project": "qemu", "commit_id": "3713e1485e6eace7d48b9c790602cfd92c616e5f", "target": 1, "func": "static int usbredir_post_load(void *priv, int version_id)\n{\n    USBRedirDevice *dev = priv;\n    switch (dev->device_info.speed) {\n    case usb_redir_speed_low:\n        dev->dev.speed = USB_SPEED_LOW;\n        break;\n    case usb_redir_speed_full:\n        dev->dev.speed = USB_SPEED_FULL;\n        break;\n    case usb_redir_speed_high:\n        dev->dev.speed = USB_SPEED_HIGH;\n        break;\n    case usb_redir_speed_super:\n        dev->dev.speed = USB_SPEED_SUPER;\n        break;\n    default:\n        dev->dev.speed = USB_SPEED_FULL;\n    dev->dev.speedmask = (1 << dev->dev.speed);\n    usbredir_setup_usb_eps(dev);\n    usbredir_check_bulk_receiving(dev);", "idx": 25079}
{"project": "qemu", "commit_id": "e3c9d76acc984218264bbc6435b0c09f959ed9b8", "target": 1, "func": "static void vhost_scsi_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);\n\n    dc->exit = vhost_scsi_exit;\n\n    dc->props = vhost_scsi_properties;\n\n    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);\n\n    vdc->init = vhost_scsi_init;\n\n    vdc->get_features = vhost_scsi_get_features;\n\n    vdc->set_config = vhost_scsi_set_config;\n\n    vdc->set_status = vhost_scsi_set_status;\n\n}\n", "idx": 25082}
{"project": "qemu", "commit_id": "45b00c44ceffeac8143fb8857a12677234114f2b", "target": 1, "func": "ivshmem_client_parse_args(IvshmemClientArgs *args, int argc, char *argv[])\n\n{\n\n    int c;\n\n\n\n    while ((c = getopt(argc, argv,\n\n                       \"h\"  /* help */\n\n                       \"v\"  /* verbose */\n\n                       \"S:\" /* unix_sock_path */\n\n                      )) != -1) {\n\n\n\n        switch (c) {\n\n        case 'h': /* help */\n\n            ivshmem_client_usage(argv[0], 0);\n\n            break;\n\n\n\n        case 'v': /* verbose */\n\n            args->verbose = 1;\n\n            break;\n\n\n\n        case 'S': /* unix_sock_path */\n\n            args->unix_sock_path = strdup(optarg);\n\n            break;\n\n\n\n        default:\n\n            ivshmem_client_usage(argv[0], 1);\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 25083}
{"project": "qemu", "commit_id": "7385aed20db5d83979f683b9d0048674411e963c", "target": 0, "func": "float32 helper_fdtos(CPUSPARCState *env, float64 src)\n\n{\n\n    float32 ret;\n\n    clear_float_exceptions(env);\n\n    ret = float64_to_float32(src, &env->fp_status);\n\n    check_ieee_exceptions(env);\n\n    return ret;\n\n}\n", "idx": 25099}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void icp_control_init(target_phys_addr_t base)\n\n{\n\n    MemoryRegion *io;\n\n\n\n    io = (MemoryRegion *)g_malloc0(sizeof(MemoryRegion));\n\n    memory_region_init_io(io, &icp_control_ops, NULL,\n\n                          \"control\", 0x00800000);\n\n    memory_region_add_subregion(get_system_memory(), base, io);\n\n    /* ??? Save/restore.  */\n\n}\n", "idx": 25100}
{"project": "qemu", "commit_id": "cd42d5b23691ad73edfd6dbcfc935a960a9c5a65", "target": 0, "func": "gen_intermediate_code_internal(MoxieCPU *cpu, TranslationBlock *tb,\n\n                               bool search_pc)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    DisasContext ctx;\n\n    target_ulong pc_start;\n\n    uint16_t *gen_opc_end;\n\n    CPUBreakpoint *bp;\n\n    int j, lj = -1;\n\n    CPUMoxieState *env = &cpu->env;\n\n    int num_insns;\n\n\n\n    pc_start = tb->pc;\n\n    gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE;\n\n    ctx.pc = pc_start;\n\n    ctx.saved_pc = -1;\n\n    ctx.tb = tb;\n\n    ctx.memidx = 0;\n\n    ctx.singlestep_enabled = 0;\n\n    ctx.bstate = BS_NONE;\n\n    num_insns = 0;\n\n\n\n    gen_tb_start();\n\n    do {\n\n        if (unlikely(!QTAILQ_EMPTY(&cs->breakpoints))) {\n\n            QTAILQ_FOREACH(bp, &cs->breakpoints, entry) {\n\n                if (ctx.pc == bp->pc) {\n\n                    tcg_gen_movi_i32(cpu_pc, ctx.pc);\n\n                    gen_helper_debug(cpu_env);\n\n                    ctx.bstate = BS_EXCP;\n\n                    goto done_generating;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (search_pc) {\n\n            j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j) {\n\n                    tcg_ctx.gen_opc_instr_start[lj++] = 0;\n\n                }\n\n            }\n\n            tcg_ctx.gen_opc_pc[lj] = ctx.pc;\n\n            tcg_ctx.gen_opc_instr_start[lj] = 1;\n\n            tcg_ctx.gen_opc_icount[lj] = num_insns;\n\n        }\n\n        ctx.opcode = cpu_lduw_code(env, ctx.pc);\n\n        ctx.pc += decode_opc(cpu, &ctx);\n\n        num_insns++;\n\n\n\n        if (cs->singlestep_enabled) {\n\n            break;\n\n        }\n\n\n\n        if ((ctx.pc & (TARGET_PAGE_SIZE - 1)) == 0) {\n\n            break;\n\n        }\n\n    } while (ctx.bstate == BS_NONE && tcg_ctx.gen_opc_ptr < gen_opc_end);\n\n\n\n    if (cs->singlestep_enabled) {\n\n        tcg_gen_movi_tl(cpu_pc, ctx.pc);\n\n        gen_helper_debug(cpu_env);\n\n    } else {\n\n        switch (ctx.bstate) {\n\n        case BS_STOP:\n\n        case BS_NONE:\n\n            gen_goto_tb(env, &ctx, 0, ctx.pc);\n\n            break;\n\n        case BS_EXCP:\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        case BS_BRANCH:\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n done_generating:\n\n    gen_tb_end(tb, num_insns);\n\n    *tcg_ctx.gen_opc_ptr = INDEX_op_end;\n\n    if (search_pc) {\n\n        j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j) {\n\n            tcg_ctx.gen_opc_instr_start[lj++] = 0;\n\n        }\n\n    } else {\n\n        tb->size = ctx.pc - pc_start;\n\n        tb->icount = num_insns;\n\n    }\n\n}\n", "idx": 25101}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "USBBus *usb_bus_find(int busnr)\n\n{\n\n    USBBus *bus;\n\n\n\n    if (-1 == busnr)\n\n        return TAILQ_FIRST(&busses);\n\n    TAILQ_FOREACH(bus, &busses, next) {\n\n        if (bus->busnr == busnr)\n\n            return bus;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 25102}
{"project": "qemu", "commit_id": "8dfe8e7f4facef400ef1c220f29196ae5cfc526c", "target": 0, "func": "static void ppc_spapr_init(MachineState *machine)\n\n{\n\n    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);\n\n    sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(machine);\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    PowerPCCPU *cpu;\n\n    PCIHostState *phb;\n\n    int i;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *rma_region;\n\n    void *rma = NULL;\n\n    hwaddr rma_alloc_size;\n\n    hwaddr node0_size = spapr_node0_size();\n\n    uint32_t initrd_base = 0;\n\n    long kernel_size = 0, initrd_size = 0;\n\n    long load_limit, fw_size;\n\n    bool kernel_le = false;\n\n    char *filename;\n\n\n\n    msi_supported = true;\n\n\n\n    QLIST_INIT(&spapr->phbs);\n\n\n\n    cpu_ppc_hypercall = emulate_spapr_hypercall;\n\n\n\n    /* Allocate RMA if necessary */\n\n    rma_alloc_size = kvmppc_alloc_rma(&rma);\n\n\n\n    if (rma_alloc_size == -1) {\n\n        error_report(\"Unable to create RMA\");\n\n        exit(1);\n\n    }\n\n\n\n    if (rma_alloc_size && (rma_alloc_size < node0_size)) {\n\n        spapr->rma_size = rma_alloc_size;\n\n    } else {\n\n        spapr->rma_size = node0_size;\n\n\n\n        /* With KVM, we don't actually know whether KVM supports an\n\n         * unbounded RMA (PR KVM) or is limited by the hash table size\n\n         * (HV KVM using VRMA), so we always assume the latter\n\n         *\n\n         * In that case, we also limit the initial allocations for RTAS\n\n         * etc... to 256M since we have no way to know what the VRMA size\n\n         * is going to be as it depends on the size of the hash table\n\n         * isn't determined yet.\n\n         */\n\n        if (kvm_enabled()) {\n\n            spapr->vrma_adjust = 1;\n\n            spapr->rma_size = MIN(spapr->rma_size, 0x10000000);\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size > node0_size) {\n\n        error_report(\"Numa node 0 has to span the RMA (%#08\"HWADDR_PRIx\")\",\n\n                     spapr->rma_size);\n\n        exit(1);\n\n    }\n\n\n\n    /* Setup a load limit for the ramdisk leaving room for SLOF and FDT */\n\n    load_limit = MIN(spapr->rma_size, RTAS_MAX_ADDR) - FW_OVERHEAD;\n\n\n\n    /* We aim for a hash table of size 1/128 the size of RAM.  The\n\n     * normal rule of thumb is 1/64 the size of RAM, but that's much\n\n     * more than needed for the Linux guests we support. */\n\n    spapr->htab_shift = 18; /* Minimum architected size */\n\n    while (spapr->htab_shift <= 46) {\n\n        if ((1ULL << (spapr->htab_shift + 7)) >= machine->maxram_size) {\n\n            break;\n\n        }\n\n        spapr->htab_shift++;\n\n    }\n\n    spapr_alloc_htab(spapr);\n\n\n\n    /* Set up Interrupt Controller before we create the VCPUs */\n\n    spapr->icp = xics_system_init(machine,\n\n                                  DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),\n\n                                               smp_threads),\n\n                                  XICS_IRQS, &error_fatal);\n\n\n\n    if (smc->dr_lmb_enabled) {\n\n        spapr_validate_node_memory(machine, &error_fatal);\n\n    }\n\n\n\n    /* init CPUs */\n\n    if (machine->cpu_model == NULL) {\n\n        machine->cpu_model = kvm_enabled() ? \"host\" : \"POWER7\";\n\n    }\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        cpu = cpu_ppc_init(machine->cpu_model);\n\n        if (cpu == NULL) {\n\n            error_report(\"Unable to find PowerPC CPU definition\");\n\n            exit(1);\n\n        }\n\n        spapr_cpu_init(spapr, cpu, &error_fatal);\n\n    }\n\n\n\n    if (kvm_enabled()) {\n\n        /* Enable H_LOGICAL_CI_* so SLOF can talk to in-kernel devices */\n\n        kvmppc_enable_logical_ci_hcalls();\n\n        kvmppc_enable_set_mode_hcall();\n\n    }\n\n\n\n    /* allocate RAM */\n\n    memory_region_allocate_system_memory(ram, NULL, \"ppc_spapr.ram\",\n\n                                         machine->ram_size);\n\n    memory_region_add_subregion(sysmem, 0, ram);\n\n\n\n    if (rma_alloc_size && rma) {\n\n        rma_region = g_new(MemoryRegion, 1);\n\n        memory_region_init_ram_ptr(rma_region, NULL, \"ppc_spapr.rma\",\n\n                                   rma_alloc_size, rma);\n\n        vmstate_register_ram_global(rma_region);\n\n        memory_region_add_subregion(sysmem, 0, rma_region);\n\n    }\n\n\n\n    /* initialize hotplug memory address space */\n\n    if (machine->ram_size < machine->maxram_size) {\n\n        ram_addr_t hotplug_mem_size = machine->maxram_size - machine->ram_size;\n\n\n\n        if (machine->ram_slots > SPAPR_MAX_RAM_SLOTS) {\n\n            error_report(\"Specified number of memory slots %\"\n\n                         PRIu64\" exceeds max supported %d\",\n\n                         machine->ram_slots, SPAPR_MAX_RAM_SLOTS);\n\n            exit(1);\n\n        }\n\n\n\n        spapr->hotplug_memory.base = ROUND_UP(machine->ram_size,\n\n                                              SPAPR_HOTPLUG_MEM_ALIGN);\n\n        memory_region_init(&spapr->hotplug_memory.mr, OBJECT(spapr),\n\n                           \"hotplug-memory\", hotplug_mem_size);\n\n        memory_region_add_subregion(sysmem, spapr->hotplug_memory.base,\n\n                                    &spapr->hotplug_memory.mr);\n\n    }\n\n\n\n    if (smc->dr_lmb_enabled) {\n\n        spapr_create_lmb_dr_connectors(spapr);\n\n    }\n\n\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\n\n    if (!filename) {\n\n        error_report(\"Could not find LPAR rtas '%s'\", \"spapr-rtas.bin\");\n\n        exit(1);\n\n    }\n\n    spapr->rtas_size = get_image_size(filename);\n\n    spapr->rtas_blob = g_malloc(spapr->rtas_size);\n\n    if (load_image_size(filename, spapr->rtas_blob, spapr->rtas_size) < 0) {\n\n        error_report(\"Could not load LPAR rtas '%s'\", filename);\n\n        exit(1);\n\n    }\n\n    if (spapr->rtas_size > RTAS_MAX_SIZE) {\n\n        error_report(\"RTAS too big ! 0x%zx bytes (max is 0x%x)\",\n\n                     (size_t)spapr->rtas_size, RTAS_MAX_SIZE);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    /* Set up EPOW events infrastructure */\n\n    spapr_events_init(spapr);\n\n\n\n    /* Set up the RTC RTAS interfaces */\n\n    spapr_rtc_create(spapr);\n\n\n\n    /* Set up VIO bus */\n\n    spapr->vio_bus = spapr_vio_bus_init();\n\n\n\n    for (i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            spapr_vty_create(spapr->vio_bus, serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    /* We always have at least the nvram device on VIO */\n\n    spapr_create_nvram(spapr);\n\n\n\n    /* Set up PCI */\n\n    spapr_pci_rtas_init();\n\n\n\n    phb = spapr_create_phb(spapr, 0);\n\n\n\n    for (i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!nd->model) {\n\n            nd->model = g_strdup(\"ibmveth\");\n\n        }\n\n\n\n        if (strcmp(nd->model, \"ibmveth\") == 0) {\n\n            spapr_vlan_create(spapr->vio_bus, nd);\n\n        } else {\n\n            pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {\n\n        spapr_vscsi_create(spapr->vio_bus);\n\n    }\n\n\n\n    /* Graphics */\n\n    if (spapr_vga_init(phb->bus, &error_fatal)) {\n\n        spapr->has_graphics = true;\n\n        machine->usb |= defaults_enabled() && !machine->usb_disabled;\n\n    }\n\n\n\n    if (machine->usb) {\n\n        if (smc->use_ohci_by_default) {\n\n            pci_create_simple(phb->bus, -1, \"pci-ohci\");\n\n        } else {\n\n            pci_create_simple(phb->bus, -1, \"nec-usb-xhci\");\n\n        }\n\n\n\n        if (spapr->has_graphics) {\n\n            USBBus *usb_bus = usb_bus_find(-1);\n\n\n\n            usb_create_simple(usb_bus, \"usb-kbd\");\n\n            usb_create_simple(usb_bus, \"usb-mouse\");\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size < (MIN_RMA_SLOF << 20)) {\n\n        error_report(\n\n            \"pSeries SLOF firmware requires >= %ldM guest RMA (Real Mode Area memory)\",\n\n            MIN_RMA_SLOF);\n\n        exit(1);\n\n    }\n\n\n\n    if (kernel_filename) {\n\n        uint64_t lowaddr = 0;\n\n\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, PPC_ELF_MACHINE, 0);\n\n        if (kernel_size == ELF_LOAD_WRONG_ENDIAN) {\n\n            kernel_size = load_elf(kernel_filename,\n\n                                   translate_kernel_address, NULL,\n\n                                   NULL, &lowaddr, NULL, 0, PPC_ELF_MACHINE, 0);\n\n            kernel_le = kernel_size > 0;\n\n        }\n\n        if (kernel_size < 0) {\n\n            error_report(\"error loading %s: %s\",\n\n                         kernel_filename, load_elf_strerror(kernel_size));\n\n            exit(1);\n\n        }\n\n\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            /* Try to locate the initrd in the gap between the kernel\n\n             * and the firmware. Add a bit of space just in case\n\n             */\n\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              load_limit - initrd_base);\n\n            if (initrd_size < 0) {\n\n                error_report(\"could not load initial ram disk '%s'\",\n\n                             initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    }\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = FW_FILE_NAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    if (!filename) {\n\n        error_report(\"Could not find LPAR firmware '%s'\", bios_name);\n\n        exit(1);\n\n    }\n\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n\n    if (fw_size <= 0) {\n\n        error_report(\"Could not load LPAR firmware '%s'\", filename);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    /* FIXME: Should register things through the MachineState's qdev\n\n     * interface, this is a legacy from the sPAPREnvironment structure\n\n     * which predated MachineState but had a similar function */\n\n    vmstate_register(NULL, 0, &vmstate_spapr, spapr);\n\n    register_savevm_live(NULL, \"spapr/htab\", -1, 1,\n\n                         &savevm_htab_handlers, spapr);\n\n\n\n    /* Prepare the device tree */\n\n    spapr->fdt_skel = spapr_create_fdt_skel(initrd_base, initrd_size,\n\n                                            kernel_size, kernel_le,\n\n                                            kernel_cmdline,\n\n                                            spapr->check_exception_irq);\n\n    assert(spapr->fdt_skel != NULL);\n\n\n\n    /* used by RTAS */\n\n    QTAILQ_INIT(&spapr->ccs_list);\n\n    qemu_register_reset(spapr_ccs_reset_hook, spapr);\n\n\n\n    qemu_register_boot_set(spapr_boot_set, spapr);\n\n}\n", "idx": 25103}
{"project": "qemu", "commit_id": "1687a089f103f9b7a1b4a1555068054cb46ee9e9", "target": 0, "func": "vreader_copy_list(VReaderList *list)\n\n{\n\n    VReaderList *new_list = NULL;\n\n    VReaderListEntry *current_entry = NULL;\n\n\n\n    new_list = vreader_list_new();\n\n    if (new_list == NULL) {\n\n        return NULL;\n\n    }\n\n    for (current_entry = vreader_list_get_first(list); current_entry;\n\n         current_entry = vreader_list_get_next(current_entry)) {\n\n        VReader *reader = vreader_list_get_reader(current_entry);\n\n        VReaderListEntry *new_entry = vreader_list_entry_new(reader);\n\n\n\n        vreader_free(reader);\n\n        vreader_queue(new_list, new_entry);\n\n    }\n\n    return new_list;\n\n}\n", "idx": 25104}
{"project": "qemu", "commit_id": "550830f9351291c585c963204ad9127998b1c1ce", "target": 0, "func": "static int cow_find_streak(const uint8_t *bitmap, int value, int start, int nb_sectors)\n\n{\n\n    int streak_value = value ? 0xFF : 0;\n\n    int last = MIN(start + nb_sectors, BITS_PER_BITMAP_SECTOR);\n\n    int bitnum = start;\n\n    while (bitnum < last) {\n\n        if ((bitnum & 7) == 0 && bitmap[bitnum / 8] == streak_value) {\n\n            bitnum += 8;\n\n            continue;\n\n        }\n\n        if (cow_test_bit(bitnum, bitmap) == value) {\n\n            bitnum++;\n\n            continue;\n\n        }\n\n        break;\n\n    }\n\n    return MIN(bitnum, last) - start;\n\n}\n", "idx": 25105}
{"project": "qemu", "commit_id": "2e6fc7eb1a4af1b127df5f07b8bb28af891946fa", "target": 0, "func": "static int raw_read_options(QDict *options, BlockDriverState *bs,\n\n    BDRVRawState *s, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    QemuOpts *opts = NULL;\n\n    int64_t real_size = 0;\n\n    int ret;\n\n\n\n    real_size = bdrv_getlength(bs->file->bs);\n\n    if (real_size < 0) {\n\n        error_setg_errno(errp, -real_size, \"Could not get image size\");\n\n        return real_size;\n\n    }\n\n\n\n    opts = qemu_opts_create(&raw_runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto end;\n\n    }\n\n\n\n    s->offset = qemu_opt_get_size(opts, \"offset\", 0);\n\n    if (s->offset > real_size) {\n\n        error_setg(errp, \"Offset (%\" PRIu64 \") cannot be greater than \"\n\n            \"size of the containing file (%\" PRId64 \")\",\n\n            s->offset, real_size);\n\n        ret = -EINVAL;\n\n        goto end;\n\n    }\n\n\n\n    if (qemu_opt_find(opts, \"size\") != NULL) {\n\n        s->size = qemu_opt_get_size(opts, \"size\", 0);\n\n        s->has_size = true;\n\n    } else {\n\n        s->has_size = false;\n\n        s->size = real_size - s->offset;\n\n    }\n\n\n\n    /* Check size and offset */\n\n    if ((real_size - s->offset) < s->size) {\n\n        error_setg(errp, \"The sum of offset (%\" PRIu64 \") and size \"\n\n            \"(%\" PRIu64 \") has to be smaller or equal to the \"\n\n            \" actual size of the containing file (%\" PRId64 \")\",\n\n            s->offset, s->size, real_size);\n\n        ret = -EINVAL;\n\n        goto end;\n\n    }\n\n\n\n    /* Make sure size is multiple of BDRV_SECTOR_SIZE to prevent rounding\n\n     * up and leaking out of the specified area. */\n\n    if (s->has_size && !QEMU_IS_ALIGNED(s->size, BDRV_SECTOR_SIZE)) {\n\n        error_setg(errp, \"Specified size is not multiple of %llu\",\n\n            BDRV_SECTOR_SIZE);\n\n        ret = -EINVAL;\n\n        goto end;\n\n    }\n\n\n\n    ret = 0;\n\n\n\nend:\n\n\n\n    qemu_opts_del(opts);\n\n\n\n    return ret;\n\n}\n", "idx": 25106}
{"project": "qemu", "commit_id": "21e00fa55f3fdfcbb20da7c6876c91ef3609b387", "target": 0, "func": "bool memory_region_is_skip_dump(MemoryRegion *mr)\n\n{\n\n    return mr->skip_dump;\n\n}\n", "idx": 25108}
{"project": "qemu", "commit_id": "185b43386ad999c80bdc58e41b87f05e5b3e8463", "target": 0, "func": "static ssize_t nbd_send_reply(int csock, struct nbd_reply *reply)\n\n{\n\n    uint8_t buf[4 + 4 + 8];\n\n\n\n    /* Reply\n\n       [ 0 ..  3]    magic   (NBD_REPLY_MAGIC)\n\n       [ 4 ..  7]    error   (0 == no error)\n\n       [ 7 .. 15]    handle\n\n     */\n\n    cpu_to_be32w((uint32_t*)buf, NBD_REPLY_MAGIC);\n\n    cpu_to_be32w((uint32_t*)(buf + 4), reply->error);\n\n    cpu_to_be64w((uint64_t*)(buf + 8), reply->handle);\n\n\n\n    TRACE(\"Sending response to client\");\n\n\n\n    if (write_sync(csock, buf, sizeof(buf)) != sizeof(buf)) {\n\n        LOG(\"writing to socket failed\");\n\n        errno = EINVAL;\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 25109}
{"project": "qemu", "commit_id": "7848c8d19f8556666df25044bbd5d8b29439c368", "target": 0, "func": "static void switch_tss(CPUX86State *env, int tss_selector,\n\n                       uint32_t e1, uint32_t e2, int source,\n\n                       uint32_t next_eip)\n\n{\n\n    int tss_limit, tss_limit_max, type, old_tss_limit_max, old_type, v1, v2, i;\n\n    target_ulong tss_base;\n\n    uint32_t new_regs[8], new_segs[6];\n\n    uint32_t new_eflags, new_eip, new_cr3, new_ldt, new_trap;\n\n    uint32_t old_eflags, eflags_mask;\n\n    SegmentCache *dt;\n\n    int index;\n\n    target_ulong ptr;\n\n\n\n    type = (e2 >> DESC_TYPE_SHIFT) & 0xf;\n\n    LOG_PCALL(\"switch_tss: sel=0x%04x type=%d src=%d\\n\", tss_selector, type,\n\n              source);\n\n\n\n    /* if task gate, we read the TSS segment and we load it */\n\n    if (type == 5) {\n\n        if (!(e2 & DESC_P_MASK)) {\n\n            raise_exception_err(env, EXCP0B_NOSEG, tss_selector & 0xfffc);\n\n        }\n\n        tss_selector = e1 >> 16;\n\n        if (tss_selector & 4) {\n\n            raise_exception_err(env, EXCP0A_TSS, tss_selector & 0xfffc);\n\n        }\n\n        if (load_segment(env, &e1, &e2, tss_selector) != 0) {\n\n            raise_exception_err(env, EXCP0D_GPF, tss_selector & 0xfffc);\n\n        }\n\n        if (e2 & DESC_S_MASK) {\n\n            raise_exception_err(env, EXCP0D_GPF, tss_selector & 0xfffc);\n\n        }\n\n        type = (e2 >> DESC_TYPE_SHIFT) & 0xf;\n\n        if ((type & 7) != 1) {\n\n            raise_exception_err(env, EXCP0D_GPF, tss_selector & 0xfffc);\n\n        }\n\n    }\n\n\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, tss_selector & 0xfffc);\n\n    }\n\n\n\n    if (type & 8) {\n\n        tss_limit_max = 103;\n\n    } else {\n\n        tss_limit_max = 43;\n\n    }\n\n    tss_limit = get_seg_limit(e1, e2);\n\n    tss_base = get_seg_base(e1, e2);\n\n    if ((tss_selector & 4) != 0 ||\n\n        tss_limit < tss_limit_max) {\n\n        raise_exception_err(env, EXCP0A_TSS, tss_selector & 0xfffc);\n\n    }\n\n    old_type = (env->tr.flags >> DESC_TYPE_SHIFT) & 0xf;\n\n    if (old_type & 8) {\n\n        old_tss_limit_max = 103;\n\n    } else {\n\n        old_tss_limit_max = 43;\n\n    }\n\n\n\n    /* read all the registers from the new TSS */\n\n    if (type & 8) {\n\n        /* 32 bit */\n\n        new_cr3 = cpu_ldl_kernel(env, tss_base + 0x1c);\n\n        new_eip = cpu_ldl_kernel(env, tss_base + 0x20);\n\n        new_eflags = cpu_ldl_kernel(env, tss_base + 0x24);\n\n        for (i = 0; i < 8; i++) {\n\n            new_regs[i] = cpu_ldl_kernel(env, tss_base + (0x28 + i * 4));\n\n        }\n\n        for (i = 0; i < 6; i++) {\n\n            new_segs[i] = cpu_lduw_kernel(env, tss_base + (0x48 + i * 4));\n\n        }\n\n        new_ldt = cpu_lduw_kernel(env, tss_base + 0x60);\n\n        new_trap = cpu_ldl_kernel(env, tss_base + 0x64);\n\n    } else {\n\n        /* 16 bit */\n\n        new_cr3 = 0;\n\n        new_eip = cpu_lduw_kernel(env, tss_base + 0x0e);\n\n        new_eflags = cpu_lduw_kernel(env, tss_base + 0x10);\n\n        for (i = 0; i < 8; i++) {\n\n            new_regs[i] = cpu_lduw_kernel(env, tss_base + (0x12 + i * 2)) |\n\n                0xffff0000;\n\n        }\n\n        for (i = 0; i < 4; i++) {\n\n            new_segs[i] = cpu_lduw_kernel(env, tss_base + (0x22 + i * 4));\n\n        }\n\n        new_ldt = cpu_lduw_kernel(env, tss_base + 0x2a);\n\n        new_segs[R_FS] = 0;\n\n        new_segs[R_GS] = 0;\n\n        new_trap = 0;\n\n    }\n\n    /* XXX: avoid a compiler warning, see\n\n     http://support.amd.com/us/Processor_TechDocs/24593.pdf\n\n     chapters 12.2.5 and 13.2.4 on how to implement TSS Trap bit */\n\n    (void)new_trap;\n\n\n\n    /* NOTE: we must avoid memory exceptions during the task switch,\n\n       so we make dummy accesses before */\n\n    /* XXX: it can still fail in some cases, so a bigger hack is\n\n       necessary to valid the TLB after having done the accesses */\n\n\n\n    v1 = cpu_ldub_kernel(env, env->tr.base);\n\n    v2 = cpu_ldub_kernel(env, env->tr.base + old_tss_limit_max);\n\n    cpu_stb_kernel(env, env->tr.base, v1);\n\n    cpu_stb_kernel(env, env->tr.base + old_tss_limit_max, v2);\n\n\n\n    /* clear busy bit (it is restartable) */\n\n    if (source == SWITCH_TSS_JMP || source == SWITCH_TSS_IRET) {\n\n        target_ulong ptr;\n\n        uint32_t e2;\n\n\n\n        ptr = env->gdt.base + (env->tr.selector & ~7);\n\n        e2 = cpu_ldl_kernel(env, ptr + 4);\n\n        e2 &= ~DESC_TSS_BUSY_MASK;\n\n        cpu_stl_kernel(env, ptr + 4, e2);\n\n    }\n\n    old_eflags = cpu_compute_eflags(env);\n\n    if (source == SWITCH_TSS_IRET) {\n\n        old_eflags &= ~NT_MASK;\n\n    }\n\n\n\n    /* save the current state in the old TSS */\n\n    if (type & 8) {\n\n        /* 32 bit */\n\n        cpu_stl_kernel(env, env->tr.base + 0x20, next_eip);\n\n        cpu_stl_kernel(env, env->tr.base + 0x24, old_eflags);\n\n        cpu_stl_kernel(env, env->tr.base + (0x28 + 0 * 4), env->regs[R_EAX]);\n\n        cpu_stl_kernel(env, env->tr.base + (0x28 + 1 * 4), env->regs[R_ECX]);\n\n        cpu_stl_kernel(env, env->tr.base + (0x28 + 2 * 4), env->regs[R_EDX]);\n\n        cpu_stl_kernel(env, env->tr.base + (0x28 + 3 * 4), env->regs[R_EBX]);\n\n        cpu_stl_kernel(env, env->tr.base + (0x28 + 4 * 4), env->regs[R_ESP]);\n\n        cpu_stl_kernel(env, env->tr.base + (0x28 + 5 * 4), env->regs[R_EBP]);\n\n        cpu_stl_kernel(env, env->tr.base + (0x28 + 6 * 4), env->regs[R_ESI]);\n\n        cpu_stl_kernel(env, env->tr.base + (0x28 + 7 * 4), env->regs[R_EDI]);\n\n        for (i = 0; i < 6; i++) {\n\n            cpu_stw_kernel(env, env->tr.base + (0x48 + i * 4),\n\n                           env->segs[i].selector);\n\n        }\n\n    } else {\n\n        /* 16 bit */\n\n        cpu_stw_kernel(env, env->tr.base + 0x0e, next_eip);\n\n        cpu_stw_kernel(env, env->tr.base + 0x10, old_eflags);\n\n        cpu_stw_kernel(env, env->tr.base + (0x12 + 0 * 2), env->regs[R_EAX]);\n\n        cpu_stw_kernel(env, env->tr.base + (0x12 + 1 * 2), env->regs[R_ECX]);\n\n        cpu_stw_kernel(env, env->tr.base + (0x12 + 2 * 2), env->regs[R_EDX]);\n\n        cpu_stw_kernel(env, env->tr.base + (0x12 + 3 * 2), env->regs[R_EBX]);\n\n        cpu_stw_kernel(env, env->tr.base + (0x12 + 4 * 2), env->regs[R_ESP]);\n\n        cpu_stw_kernel(env, env->tr.base + (0x12 + 5 * 2), env->regs[R_EBP]);\n\n        cpu_stw_kernel(env, env->tr.base + (0x12 + 6 * 2), env->regs[R_ESI]);\n\n        cpu_stw_kernel(env, env->tr.base + (0x12 + 7 * 2), env->regs[R_EDI]);\n\n        for (i = 0; i < 4; i++) {\n\n            cpu_stw_kernel(env, env->tr.base + (0x22 + i * 4),\n\n                           env->segs[i].selector);\n\n        }\n\n    }\n\n\n\n    /* now if an exception occurs, it will occurs in the next task\n\n       context */\n\n\n\n    if (source == SWITCH_TSS_CALL) {\n\n        cpu_stw_kernel(env, tss_base, env->tr.selector);\n\n        new_eflags |= NT_MASK;\n\n    }\n\n\n\n    /* set busy bit */\n\n    if (source == SWITCH_TSS_JMP || source == SWITCH_TSS_CALL) {\n\n        target_ulong ptr;\n\n        uint32_t e2;\n\n\n\n        ptr = env->gdt.base + (tss_selector & ~7);\n\n        e2 = cpu_ldl_kernel(env, ptr + 4);\n\n        e2 |= DESC_TSS_BUSY_MASK;\n\n        cpu_stl_kernel(env, ptr + 4, e2);\n\n    }\n\n\n\n    /* set the new CPU state */\n\n    /* from this point, any exception which occurs can give problems */\n\n    env->cr[0] |= CR0_TS_MASK;\n\n    env->hflags |= HF_TS_MASK;\n\n    env->tr.selector = tss_selector;\n\n    env->tr.base = tss_base;\n\n    env->tr.limit = tss_limit;\n\n    env->tr.flags = e2 & ~DESC_TSS_BUSY_MASK;\n\n\n\n    if ((type & 8) && (env->cr[0] & CR0_PG_MASK)) {\n\n        cpu_x86_update_cr3(env, new_cr3);\n\n    }\n\n\n\n    /* load all registers without an exception, then reload them with\n\n       possible exception */\n\n    env->eip = new_eip;\n\n    eflags_mask = TF_MASK | AC_MASK | ID_MASK |\n\n        IF_MASK | IOPL_MASK | VM_MASK | RF_MASK | NT_MASK;\n\n    if (!(type & 8)) {\n\n        eflags_mask &= 0xffff;\n\n    }\n\n    cpu_load_eflags(env, new_eflags, eflags_mask);\n\n    /* XXX: what to do in 16 bit case? */\n\n    env->regs[R_EAX] = new_regs[0];\n\n    env->regs[R_ECX] = new_regs[1];\n\n    env->regs[R_EDX] = new_regs[2];\n\n    env->regs[R_EBX] = new_regs[3];\n\n    env->regs[R_ESP] = new_regs[4];\n\n    env->regs[R_EBP] = new_regs[5];\n\n    env->regs[R_ESI] = new_regs[6];\n\n    env->regs[R_EDI] = new_regs[7];\n\n    if (new_eflags & VM_MASK) {\n\n        for (i = 0; i < 6; i++) {\n\n            load_seg_vm(env, i, new_segs[i]);\n\n        }\n\n        /* in vm86, CPL is always 3 */\n\n        cpu_x86_set_cpl(env, 3);\n\n    } else {\n\n        /* CPL is set the RPL of CS */\n\n        cpu_x86_set_cpl(env, new_segs[R_CS] & 3);\n\n        /* first just selectors as the rest may trigger exceptions */\n\n        for (i = 0; i < 6; i++) {\n\n            cpu_x86_load_seg_cache(env, i, new_segs[i], 0, 0, 0);\n\n        }\n\n    }\n\n\n\n    env->ldt.selector = new_ldt & ~4;\n\n    env->ldt.base = 0;\n\n    env->ldt.limit = 0;\n\n    env->ldt.flags = 0;\n\n\n\n    /* load the LDT */\n\n    if (new_ldt & 4) {\n\n        raise_exception_err(env, EXCP0A_TSS, new_ldt & 0xfffc);\n\n    }\n\n\n\n    if ((new_ldt & 0xfffc) != 0) {\n\n        dt = &env->gdt;\n\n        index = new_ldt & ~7;\n\n        if ((index + 7) > dt->limit) {\n\n            raise_exception_err(env, EXCP0A_TSS, new_ldt & 0xfffc);\n\n        }\n\n        ptr = dt->base + index;\n\n        e1 = cpu_ldl_kernel(env, ptr);\n\n        e2 = cpu_ldl_kernel(env, ptr + 4);\n\n        if ((e2 & DESC_S_MASK) || ((e2 >> DESC_TYPE_SHIFT) & 0xf) != 2) {\n\n            raise_exception_err(env, EXCP0A_TSS, new_ldt & 0xfffc);\n\n        }\n\n        if (!(e2 & DESC_P_MASK)) {\n\n            raise_exception_err(env, EXCP0A_TSS, new_ldt & 0xfffc);\n\n        }\n\n        load_seg_cache_raw_dt(&env->ldt, e1, e2);\n\n    }\n\n\n\n    /* load the segments */\n\n    if (!(new_eflags & VM_MASK)) {\n\n        tss_load_seg(env, R_CS, new_segs[R_CS]);\n\n        tss_load_seg(env, R_SS, new_segs[R_SS]);\n\n        tss_load_seg(env, R_ES, new_segs[R_ES]);\n\n        tss_load_seg(env, R_DS, new_segs[R_DS]);\n\n        tss_load_seg(env, R_FS, new_segs[R_FS]);\n\n        tss_load_seg(env, R_GS, new_segs[R_GS]);\n\n    }\n\n\n\n    /* check that env->eip is in the CS segment limits */\n\n    if (new_eip > env->segs[R_CS].limit) {\n\n        /* XXX: different exception if CALL? */\n\n        raise_exception_err(env, EXCP0D_GPF, 0);\n\n    }\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    /* reset local breakpoints */\n\n    if (env->dr[7] & DR7_LOCAL_BP_MASK) {\n\n        for (i = 0; i < DR7_MAX_BP; i++) {\n\n            if (hw_local_breakpoint_enabled(env->dr[7], i) &&\n\n                !hw_global_breakpoint_enabled(env->dr[7], i)) {\n\n                hw_breakpoint_remove(env, i);\n\n            }\n\n        }\n\n        env->dr[7] &= ~DR7_LOCAL_BP_MASK;\n\n    }\n\n#endif\n\n}\n", "idx": 25110}
{"project": "qemu", "commit_id": "a36593e16757e524c1596d93914155bd8acbb90a", "target": 0, "func": "void kvmppc_read_hptes(ppc_hash_pte64_t *hptes, hwaddr ptex, int n)\n\n{\n\n    int fd, rc;\n\n    int i;\n\n\n\n    fd = kvmppc_get_htab_fd(false, ptex, &error_abort);\n\n\n\n    i = 0;\n\n    while (i < n) {\n\n        struct kvm_get_htab_header *hdr;\n\n        int m = n < HPTES_PER_GROUP ? n : HPTES_PER_GROUP;\n\n        char buf[sizeof(*hdr) + m * HASH_PTE_SIZE_64];\n\n\n\n        rc = read(fd, buf, sizeof(buf));\n\n        if (rc < 0) {\n\n            hw_error(\"kvmppc_read_hptes: Unable to read HPTEs\");\n\n        }\n\n\n\n        hdr = (struct kvm_get_htab_header *)buf;\n\n        while ((i < n) && ((char *)hdr < (buf + rc))) {\n\n            int invalid = hdr->n_invalid;\n\n\n\n            if (hdr->index != (ptex + i)) {\n\n                hw_error(\"kvmppc_read_hptes: Unexpected HPTE index %\"PRIu32\n\n                         \" != (%\"HWADDR_PRIu\" + %d\", hdr->index, ptex, i);\n\n            }\n\n\n\n            memcpy(hptes + i, hdr + 1, HASH_PTE_SIZE_64 * hdr->n_valid);\n\n            i += hdr->n_valid;\n\n\n\n            if ((n - i) < invalid) {\n\n                invalid = n - i;\n\n            }\n\n            memset(hptes + i, 0, invalid * HASH_PTE_SIZE_64);\n\n            i += hdr->n_invalid;\n\n\n\n            hdr = (struct kvm_get_htab_header *)\n\n                ((char *)(hdr + 1) + HASH_PTE_SIZE_64 * hdr->n_valid);\n\n        }\n\n    }\n\n\n\n    close(fd);\n\n}\n", "idx": 25111}
{"project": "qemu", "commit_id": "1830f22a6777cedaccd67a08f675d30f7a85ebfd", "target": 0, "func": "void qmp_output_visitor_cleanup(QmpOutputVisitor *v)\n\n{\n\n    QStackEntry *e, *tmp;\n\n\n\n    QTAILQ_FOREACH_SAFE(e, &v->stack, node, tmp) {\n\n        QTAILQ_REMOVE(&v->stack, e, node);\n\n        g_free(e);\n\n    }\n\n\n\n    qobject_decref(v->root);\n\n    g_free(v);\n\n}\n", "idx": 25112}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void n8x0_nand_setup(struct n800_s *s)\n\n{\n\n    char *otp_region;\n\n    DriveInfo *dinfo;\n\n\n\n    s->nand = qdev_create(NULL, \"onenand\");\n\n    qdev_prop_set_uint16(s->nand, \"manufacturer_id\", NAND_MFR_SAMSUNG);\n\n    /* Either 0x40 or 0x48 are OK for the device ID */\n\n    qdev_prop_set_uint16(s->nand, \"device_id\", 0x48);\n\n    qdev_prop_set_uint16(s->nand, \"version_id\", 0);\n\n    qdev_prop_set_int32(s->nand, \"shift\", 1);\n\n    dinfo = drive_get(IF_MTD, 0, 0);\n\n    if (dinfo) {\n\n        qdev_prop_set_drive_nofail(s->nand, \"drive\",\n\n                                   blk_bs(blk_by_legacy_dinfo(dinfo)));\n\n    }\n\n    qdev_init_nofail(s->nand);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(s->nand), 0,\n\n                       qdev_get_gpio_in(s->mpu->gpio, N8X0_ONENAND_GPIO));\n\n    omap_gpmc_attach(s->mpu->gpmc, N8X0_ONENAND_CS,\n\n                     sysbus_mmio_get_region(SYS_BUS_DEVICE(s->nand), 0));\n\n    otp_region = onenand_raw_otp(s->nand);\n\n\n\n    memcpy(otp_region + 0x000, n8x0_cal_wlan_mac, sizeof(n8x0_cal_wlan_mac));\n\n    memcpy(otp_region + 0x800, n8x0_cal_bt_id, sizeof(n8x0_cal_bt_id));\n\n    /* XXX: in theory should also update the OOB for both pages */\n\n}\n", "idx": 25113}
{"project": "qemu", "commit_id": "01c2b265fce921d6460e06f5af4dfb405119cbab", "target": 0, "func": "static int check_host_key(BDRVSSHState *s, const char *host, int port,\n\n                          const char *host_key_check)\n\n{\n\n    /* host_key_check=no */\n\n    if (strcmp(host_key_check, \"no\") == 0) {\n\n        return 0;\n\n    }\n\n\n\n    /* host_key_check=md5:xx:yy:zz:... */\n\n    if (strncmp(host_key_check, \"md5:\", 4) == 0) {\n\n        return check_host_key_hash(s, &host_key_check[4],\n\n                                   LIBSSH2_HOSTKEY_HASH_MD5, 16);\n\n    }\n\n\n\n    /* host_key_check=sha1:xx:yy:zz:... */\n\n    if (strncmp(host_key_check, \"sha1:\", 5) == 0) {\n\n        return check_host_key_hash(s, &host_key_check[5],\n\n                                   LIBSSH2_HOSTKEY_HASH_SHA1, 20);\n\n    }\n\n\n\n    /* host_key_check=yes */\n\n    if (strcmp(host_key_check, \"yes\") == 0) {\n\n        return check_host_key_knownhosts(s, host, port);\n\n    }\n\n\n\n    error_report(\"unknown host_key_check setting (%s)\", host_key_check);\n\n    return -EINVAL;\n\n}\n", "idx": 25114}
{"project": "qemu", "commit_id": "bd2bfa4c52e5f4dc6dbaa5be0521aedc31cb53d9", "target": 0, "func": "void memory_region_notify_iommu(MemoryRegion *mr,\n\n                                IOMMUTLBEntry entry)\n\n{\n\n    IOMMUNotifier *iommu_notifier;\n\n    IOMMUNotifierFlag request_flags;\n\n\n\n    assert(memory_region_is_iommu(mr));\n\n\n\n    if (entry.perm & IOMMU_RW) {\n\n        request_flags = IOMMU_NOTIFIER_MAP;\n\n    } else {\n\n        request_flags = IOMMU_NOTIFIER_UNMAP;\n\n    }\n\n\n\n    IOMMU_NOTIFIER_FOREACH(iommu_notifier, mr) {\n\n        /*\n\n         * Skip the notification if the notification does not overlap\n\n         * with registered range.\n\n         */\n\n        if (iommu_notifier->start > entry.iova + entry.addr_mask + 1 ||\n\n            iommu_notifier->end < entry.iova) {\n\n            continue;\n\n        }\n\n        if (iommu_notifier->notifier_flags & request_flags) {\n\n            iommu_notifier->notify(iommu_notifier, &entry);\n\n        }\n\n    }\n\n}\n", "idx": 25115}
{"project": "qemu", "commit_id": "d185c094b404b4ff392b77d1244c0233da7d53bd", "target": 0, "func": "static IOWatchPoll *io_watch_poll_from_source(GSource *source)\n\n{\n\n    IOWatchPoll *i;\n\n\n\n    QTAILQ_FOREACH(i, &io_watch_poll_list, node) {\n\n        if (i->src == source) {\n\n            return i;\n\n        }\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 25116}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "void memory_region_init_io(MemoryRegion *mr,\n\n                           Object *owner,\n\n                           const MemoryRegionOps *ops,\n\n                           void *opaque,\n\n                           const char *name,\n\n                           uint64_t size)\n\n{\n\n    memory_region_init(mr, owner, name, size);\n\n    mr->ops = ops;\n\n    mr->opaque = opaque;\n\n    mr->terminates = true;\n\n    mr->ram_addr = ~(ram_addr_t)0;\n\n}\n", "idx": 25117}
{"project": "qemu", "commit_id": "5e755519ac9d867f7da13f58a9d0c262db82e14c", "target": 0, "func": "void cpu_dump_state (CPUState *env, FILE *f, \n\n                     int (*cpu_fprintf)(FILE *f, const char *fmt, ...),\n\n                     int flags)\n\n{\n\n    uint32_t c0_status;\n\n    int i;\n\n    \n\n    cpu_fprintf(f, \"pc=0x\" TARGET_FMT_lx \" HI=0x\" TARGET_FMT_lx \" LO=0x\" TARGET_FMT_lx \" ds %04x \" TARGET_FMT_lx \" %d\\n\",\n\n                env->PC, env->HI, env->LO, env->hflags, env->btarget, env->bcond);\n\n    for (i = 0; i < 32; i++) {\n\n        if ((i & 3) == 0)\n\n            cpu_fprintf(f, \"GPR%02d:\", i);\n\n        cpu_fprintf(f, \" %s \" TARGET_FMT_lx, regnames[i], env->gpr[i]);\n\n        if ((i & 3) == 3)\n\n            cpu_fprintf(f, \"\\n\");\n\n    }\n\n\n\n    c0_status = env->CP0_Status;\n\n\n\n    cpu_fprintf(f, \"CP0 Status  0x%08x Cause   0x%08x EPC    0x\" TARGET_FMT_lx \"\\n\",\n\n                c0_status, env->CP0_Cause, env->CP0_EPC);\n\n    cpu_fprintf(f, \"    Config0 0x%08x Config1 0x%08x LLAddr 0x\" TARGET_FMT_lx \"\\n\",\n\n                env->CP0_Config0, env->CP0_Config1, env->CP0_LLAddr);\n\n    if (c0_status & (1 << CP0St_CU1))\n\n        fpu_dump_state(env, f, cpu_fprintf, flags);\n\n#if defined(TARGET_MIPS64) && defined(MIPS_DEBUG_SIGN_EXTENSIONS)\n\n    cpu_mips_check_sign_extensions(env, f, cpu_fprintf, flags);\n\n#endif\n\n}\n", "idx": 25119}
{"project": "qemu", "commit_id": "eb7a20a3616085d46aa6b4b4224e15587ec67e6e", "target": 1, "func": "static void i6300esb_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->config_read = i6300esb_config_read;\n\n    k->config_write = i6300esb_config_write;\n\n    k->realize = i6300esb_realize;\n\n\n    k->vendor_id = PCI_VENDOR_ID_INTEL;\n\n    k->device_id = PCI_DEVICE_ID_INTEL_ESB_9;\n\n    k->class_id = PCI_CLASS_SYSTEM_OTHER;\n\n    dc->reset = i6300esb_reset;\n\n    dc->vmsd = &vmstate_i6300esb;\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n}", "idx": 25121}
{"project": "qemu", "commit_id": "4b6af3d58a73193017926dd59de3b3e7b4890323", "target": 1, "func": "BlockDriverAIOCB *win32_aio_submit(BlockDriverState *bs,\n\n        QEMUWin32AIOState *aio, HANDLE hfile,\n\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque, int type)\n\n{\n\n    struct QEMUWin32AIOCB *waiocb;\n\n    uint64_t offset = sector_num * 512;\n\n    DWORD rc;\n\n\n\n    waiocb = qemu_aio_get(&win32_aiocb_info, bs, cb, opaque);\n\n    waiocb->nbytes = nb_sectors * 512;\n\n    waiocb->qiov = qiov;\n\n    waiocb->is_read = (type == QEMU_AIO_READ);\n\n\n\n    if (qiov->niov > 1) {\n\n        waiocb->buf = qemu_blockalign(bs, qiov->size);\n\n        if (type & QEMU_AIO_WRITE) {\n\n            iov_to_buf(qiov->iov, qiov->niov, 0, waiocb->buf, qiov->size);\n\n        }\n\n        waiocb->is_linear = false;\n\n    } else {\n\n        waiocb->buf = qiov->iov[0].iov_base;\n\n        waiocb->is_linear = true;\n\n    }\n\n\n\n    memset(&waiocb->ov, 0, sizeof(waiocb->ov));\n\n    waiocb->ov.Offset = (DWORD)offset;\n\n    waiocb->ov.OffsetHigh = (DWORD)(offset >> 32);\n\n    waiocb->ov.hEvent = event_notifier_get_handle(&aio->e);\n\n\n\n    aio->count++;\n\n\n\n    if (type & QEMU_AIO_READ) {\n\n        rc = ReadFile(hfile, waiocb->buf, waiocb->nbytes, NULL, &waiocb->ov);\n\n    } else {\n\n        rc = WriteFile(hfile, waiocb->buf, waiocb->nbytes, NULL, &waiocb->ov);\n\n    }\n\n    if(rc == 0 && GetLastError() != ERROR_IO_PENDING) {\n\n        goto out_dec_count;\n\n    }\n\n    return &waiocb->common;\n\n\n\nout_dec_count:\n\n    aio->count--;\n\n    qemu_aio_release(waiocb);\n\n    return NULL;\n\n}\n", "idx": 25122}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_uint8_equal(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint8_t *v = pv;\n\n    uint8_t v2;\n\n    qemu_get_8s(f, &v2);\n\n\n\n    if (*v == v2) {\n\n        return 0;\n\n    }\n\n    return -EINVAL;\n\n}\n", "idx": 25123}
{"project": "qemu", "commit_id": "5839e53bbc0fec56021d758aab7610df421ed8c8", "target": 1, "func": "static int sd_create(const char *filename, QemuOpts *opts,\n\n                     Error **errp)\n\n{\n\n    int ret = 0;\n\n    uint32_t vid = 0;\n\n    char *backing_file = NULL;\n\n    char *buf = NULL;\n\n    BDRVSheepdogState *s;\n\n    char tag[SD_MAX_VDI_TAG_LEN];\n\n    uint32_t snapid;\n\n    bool prealloc = false;\n\n\n\n    s = g_malloc0(sizeof(BDRVSheepdogState));\n\n\n\n    memset(tag, 0, sizeof(tag));\n\n    if (strstr(filename, \"://\")) {\n\n        ret = sd_parse_uri(s, filename, s->name, &snapid, tag);\n\n    } else {\n\n        ret = parse_vdiname(s, filename, s->name, &snapid, tag);\n\n    }\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Can't parse filename\");\n\n        goto out;\n\n    }\n\n\n\n    s->inode.vdi_size = qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0);\n\n    backing_file = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FILE);\n\n    buf = qemu_opt_get_del(opts, BLOCK_OPT_PREALLOC);\n\n    if (!buf || !strcmp(buf, \"off\")) {\n\n        prealloc = false;\n\n    } else if (!strcmp(buf, \"full\")) {\n\n        prealloc = true;\n\n    } else {\n\n        error_setg(errp, \"Invalid preallocation mode: '%s'\", buf);\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    g_free(buf);\n\n    buf = qemu_opt_get_del(opts, BLOCK_OPT_REDUNDANCY);\n\n    if (buf) {\n\n        ret = parse_redundancy(s, buf);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Invalid redundancy mode: '%s'\", buf);\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    if (s->inode.vdi_size > SD_MAX_VDI_SIZE) {\n\n        error_setg(errp, \"too big image size\");\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    if (backing_file) {\n\n        BlockDriverState *bs;\n\n        BDRVSheepdogState *base;\n\n        BlockDriver *drv;\n\n\n\n        /* Currently, only Sheepdog backing image is supported. */\n\n        drv = bdrv_find_protocol(backing_file, true);\n\n        if (!drv || strcmp(drv->protocol_name, \"sheepdog\") != 0) {\n\n            error_setg(errp, \"backing_file must be a sheepdog image\");\n\n            ret = -EINVAL;\n\n            goto out;\n\n        }\n\n\n\n        bs = NULL;\n\n        ret = bdrv_open(&bs, backing_file, NULL, NULL, BDRV_O_PROTOCOL, NULL,\n\n                        errp);\n\n        if (ret < 0) {\n\n            goto out;\n\n        }\n\n\n\n        base = bs->opaque;\n\n\n\n        if (!is_snapshot(&base->inode)) {\n\n            error_setg(errp, \"cannot clone from a non snapshot vdi\");\n\n            bdrv_unref(bs);\n\n            ret = -EINVAL;\n\n            goto out;\n\n        }\n\n        s->inode.vdi_id = base->inode.vdi_id;\n\n        bdrv_unref(bs);\n\n    }\n\n\n\n    s->aio_context = qemu_get_aio_context();\n\n    ret = do_sd_create(s, &vid, 0, errp);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    if (prealloc) {\n\n        ret = sd_prealloc(filename, errp);\n\n    }\n\nout:\n\n    g_free(backing_file);\n\n    g_free(buf);\n\n    g_free(s);\n\n    return ret;\n\n}\n", "idx": 25125}
{"project": "qemu", "commit_id": "a1a6bbde4f6a29368f8f605cea2e73630ec1bc7c", "target": 1, "func": "static void ics_base_realize(DeviceState *dev, Error **errp)\n\n{\n\n    ICSStateClass *icsc = ICS_BASE_GET_CLASS(dev);\n\n    ICSState *ics = ICS_BASE(dev);\n\n    Object *obj;\n\n    Error *err = NULL;\n\n\n\n    obj = object_property_get_link(OBJECT(dev), ICS_PROP_XICS, &err);\n\n    if (!obj) {\n\n        error_setg(errp, \"%s: required link '\" ICS_PROP_XICS \"' not found: %s\",\n\n                   __func__, error_get_pretty(err));\n\n        return;\n\n    }\n\n    ics->xics = XICS_FABRIC(obj);\n\n\n\n\n\n    if (icsc->realize) {\n\n        icsc->realize(ics, errp);\n\n    }\n\n}\n", "idx": 25126}
{"project": "qemu", "commit_id": "5820945946b1e221905aa898f2cd97ed825acd47", "target": 1, "func": "static void shpc_interrupt_update(PCIDevice *d)\n\n{\n\n    SHPCDevice *shpc = d->shpc;\n\n    int slot;\n\n    int level = 0;\n\n    uint32_t serr_int;\n\n    uint32_t int_locator = 0;\n\n\n\n    /* Update interrupt locator register */\n\n    for (slot = 0; slot < shpc->nslots; ++slot) {\n\n        uint8_t event = shpc->config[SHPC_SLOT_EVENT_LATCH(slot)];\n\n        uint8_t disable = shpc->config[SHPC_SLOT_EVENT_SERR_INT_DIS(d, slot)];\n\n        uint32_t mask = 1 << SHPC_IDX_TO_LOGICAL(slot);\n\n        if (event & ~disable) {\n\n            int_locator |= mask;\n\n        }\n\n    }\n\n    serr_int = pci_get_long(shpc->config + SHPC_SERR_INT);\n\n    if ((serr_int & SHPC_CMD_DETECTED) && !(serr_int & SHPC_CMD_INT_DIS)) {\n\n        int_locator |= SHPC_INT_COMMAND;\n\n    }\n\n    pci_set_long(shpc->config + SHPC_INT_LOCATOR, int_locator);\n\n    level = (!(serr_int & SHPC_INT_DIS) && int_locator) ? 1 : 0;\n\n    if (msi_enabled(d) && shpc->msi_requested != level)\n\n        msi_notify(d, 0);\n\n    else\n\n        pci_set_irq(d, level);\n\n    shpc->msi_requested = level;\n\n}\n", "idx": 25128}
{"project": "qemu", "commit_id": "983bff3530782d51c46c8d7c0e17e2a9dfe5fb77", "target": 1, "func": "static void usb_mtp_command(MTPState *s, MTPControl *c)\n\n{\n\n    MTPData *data_in = NULL;\n\n    MTPObject *o;\n\n    uint32_t nres = 0, res0 = 0;\n\n\n\n    /* sanity checks */\n\n    if (c->code >= CMD_CLOSE_SESSION && s->session == 0) {\n\n        usb_mtp_queue_result(s, RES_SESSION_NOT_OPEN,\n\n                             c->trans, 0, 0, 0);\n\n        return;\n\n    }\n\n\n\n    /* process commands */\n\n    switch (c->code) {\n\n    case CMD_GET_DEVICE_INFO:\n\n        data_in = usb_mtp_get_device_info(s, c);\n\n        break;\n\n    case CMD_OPEN_SESSION:\n\n        if (s->session) {\n\n            usb_mtp_queue_result(s, RES_SESSION_ALREADY_OPEN,\n\n                                 c->trans, 1, s->session, 0);\n\n            return;\n\n        }\n\n        if (c->argv[0] == 0) {\n\n            usb_mtp_queue_result(s, RES_INVALID_PARAMETER,\n\n                                 c->trans, 0, 0, 0);\n\n            return;\n\n        }\n\n        trace_usb_mtp_op_open_session(s->dev.addr);\n\n        s->session = c->argv[0];\n\n        usb_mtp_object_alloc(s, s->next_handle++, NULL, s->root);\n\n#ifdef __linux__\n\n        if (usb_mtp_inotify_init(s)) {\n\n            fprintf(stderr, \"usb-mtp: file monitoring init failed\\n\");\n\n        }\n\n#endif\n\n        break;\n\n    case CMD_CLOSE_SESSION:\n\n        trace_usb_mtp_op_close_session(s->dev.addr);\n\n        s->session = 0;\n\n        s->next_handle = 0;\n\n#ifdef __linux__\n\n        usb_mtp_inotify_cleanup(s);\n\n#endif\n\n        usb_mtp_object_free(s, QTAILQ_FIRST(&s->objects));\n\n        assert(QTAILQ_EMPTY(&s->objects));\n\n        break;\n\n    case CMD_GET_STORAGE_IDS:\n\n        data_in = usb_mtp_get_storage_ids(s, c);\n\n        break;\n\n    case CMD_GET_STORAGE_INFO:\n\n        if (c->argv[0] != QEMU_STORAGE_ID &&\n\n            c->argv[0] != 0xffffffff) {\n\n            usb_mtp_queue_result(s, RES_INVALID_STORAGE_ID,\n\n                                 c->trans, 0, 0, 0);\n\n            return;\n\n        }\n\n        data_in = usb_mtp_get_storage_info(s, c);\n\n        break;\n\n    case CMD_GET_NUM_OBJECTS:\n\n    case CMD_GET_OBJECT_HANDLES:\n\n        if (c->argv[0] != QEMU_STORAGE_ID &&\n\n            c->argv[0] != 0xffffffff) {\n\n            usb_mtp_queue_result(s, RES_INVALID_STORAGE_ID,\n\n                                 c->trans, 0, 0, 0);\n\n            return;\n\n        }\n\n        if (c->argv[1] != 0x00000000) {\n\n            usb_mtp_queue_result(s, RES_SPEC_BY_FORMAT_UNSUPPORTED,\n\n                                 c->trans, 0, 0, 0);\n\n            return;\n\n        }\n\n        if (c->argv[2] == 0x00000000 ||\n\n            c->argv[2] == 0xffffffff) {\n\n            o = QTAILQ_FIRST(&s->objects);\n\n        } else {\n\n            o = usb_mtp_object_lookup(s, c->argv[2]);\n\n        }\n\n        if (o == NULL) {\n\n            usb_mtp_queue_result(s, RES_INVALID_OBJECT_HANDLE,\n\n                                 c->trans, 0, 0, 0);\n\n            return;\n\n        }\n\n        if (o->format != FMT_ASSOCIATION) {\n\n            usb_mtp_queue_result(s, RES_INVALID_PARENT_OBJECT,\n\n                                 c->trans, 0, 0, 0);\n\n            return;\n\n        }\n\n        usb_mtp_object_readdir(s, o);\n\n        if (c->code == CMD_GET_NUM_OBJECTS) {\n\n            trace_usb_mtp_op_get_num_objects(s->dev.addr, o->handle, o->path);\n\n            nres = 1;\n\n            res0 = o->nchildren;\n\n        } else {\n\n            data_in = usb_mtp_get_object_handles(s, c, o);\n\n        }\n\n        break;\n\n    case CMD_GET_OBJECT_INFO:\n\n        o = usb_mtp_object_lookup(s, c->argv[0]);\n\n        if (o == NULL) {\n\n            usb_mtp_queue_result(s, RES_INVALID_OBJECT_HANDLE,\n\n                                 c->trans, 0, 0, 0);\n\n            return;\n\n        }\n\n        data_in = usb_mtp_get_object_info(s, c, o);\n\n        break;\n\n    case CMD_GET_OBJECT:\n\n        o = usb_mtp_object_lookup(s, c->argv[0]);\n\n        if (o == NULL) {\n\n            usb_mtp_queue_result(s, RES_INVALID_OBJECT_HANDLE,\n\n                                 c->trans, 0, 0, 0);\n\n            return;\n\n        }\n\n        if (o->format == FMT_ASSOCIATION) {\n\n            usb_mtp_queue_result(s, RES_INVALID_OBJECT_HANDLE,\n\n                                 c->trans, 0, 0, 0);\n\n            return;\n\n        }\n\n        data_in = usb_mtp_get_object(s, c, o);\n\n        if (data_in == NULL) {\n\n            usb_mtp_queue_result(s, RES_GENERAL_ERROR,\n\n                                 c->trans, 0, 0, 0);\n\n            return;\n\n        }\n\n        break;\n\n    case CMD_GET_PARTIAL_OBJECT:\n\n        o = usb_mtp_object_lookup(s, c->argv[0]);\n\n        if (o == NULL) {\n\n            usb_mtp_queue_result(s, RES_INVALID_OBJECT_HANDLE,\n\n                                 c->trans, 0, 0, 0);\n\n            return;\n\n        }\n\n        if (o->format == FMT_ASSOCIATION) {\n\n            usb_mtp_queue_result(s, RES_INVALID_OBJECT_HANDLE,\n\n                                 c->trans, 0, 0, 0);\n\n            return;\n\n        }\n\n        data_in = usb_mtp_get_partial_object(s, c, o);\n\n        if (data_in == NULL) {\n\n            usb_mtp_queue_result(s, RES_GENERAL_ERROR,\n\n                                 c->trans, 0, 0, 0);\n\n            return;\n\n        }\n\n        nres = 1;\n\n        res0 = data_in->length;\n\n        break;\n\n    default:\n\n        trace_usb_mtp_op_unknown(s->dev.addr, c->code);\n\n        usb_mtp_queue_result(s, RES_OPERATION_NOT_SUPPORTED,\n\n                             c->trans, 0, 0, 0);\n\n        return;\n\n    }\n\n\n\n    /* return results on success */\n\n    if (data_in) {\n\n        assert(s->data_in == NULL);\n\n        s->data_in = data_in;\n\n    }\n\n    usb_mtp_queue_result(s, RES_OK, c->trans, nres, res0, 0);\n\n}\n", "idx": 25129}
{"project": "qemu", "commit_id": "c05541ee191107eb35093fb693e4ec038e60d2c0", "target": 1, "func": "static inline void gen_op_mfspr(DisasContext *ctx)\n\n{\n\n    void (*read_cb)(void *opaque, int gprn, int sprn);\n\n    uint32_t sprn = SPR(ctx->opcode);\n\n\n\n#if !defined(CONFIG_USER_ONLY)\n\n    if (ctx->mem_idx == 2)\n\n        read_cb = ctx->spr_cb[sprn].hea_read;\n\n    else if (ctx->mem_idx)\n\n        read_cb = ctx->spr_cb[sprn].oea_read;\n\n    else\n\n#endif\n\n        read_cb = ctx->spr_cb[sprn].uea_read;\n\n    if (likely(read_cb != NULL)) {\n\n        if (likely(read_cb != SPR_NOACCESS)) {\n\n            (*read_cb)(ctx, rD(ctx->opcode), sprn);\n\n        } else {\n\n            /* Privilege exception */\n\n            /* This is a hack to avoid warnings when running Linux:\n\n             * this OS breaks the PowerPC virtualisation model,\n\n             * allowing userland application to read the PVR\n\n             */\n\n            if (sprn != SPR_PVR) {\n\n                qemu_log(\"Trying to read privileged spr %d %03x at \"\n\n                         TARGET_FMT_lx \"\\n\", sprn, sprn, ctx->nip);\n\n                printf(\"Trying to read privileged spr %d %03x at \"\n\n                       TARGET_FMT_lx \"\\n\", sprn, sprn, ctx->nip);\n\n            }\n\n            gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        }\n\n    } else {\n\n        /* Not defined */\n\n        qemu_log(\"Trying to read invalid spr %d %03x at \"\n\n                    TARGET_FMT_lx \"\\n\", sprn, sprn, ctx->nip);\n\n        printf(\"Trying to read invalid spr %d %03x at \" TARGET_FMT_lx \"\\n\",\n\n               sprn, sprn, ctx->nip);\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_SPR);\n\n    }\n\n}\n", "idx": 25132}
{"project": "qemu", "commit_id": "eb513f82f04fab442cdef9db698dafc852275f7f", "target": 1, "func": "uint64_t helper_ld_asi(CPUSPARCState *env, target_ulong addr, int asi, int size,\n\n                       int sign)\n\n{\n\n    uint64_t ret = 0;\n\n#if defined(DEBUG_ASI)\n\n    target_ulong last_addr = addr;\n\n#endif\n\n\n\n    if (asi < 0x80) {\n\n        helper_raise_exception(env, TT_PRIV_ACT);\n\n    }\n\n\n\n    helper_check_align(env, addr, size - 1);\n\n    addr = asi_address_mask(env, asi, addr);\n\n\n\n    switch (asi) {\n\n    case 0x82: /* Primary no-fault */\n\n    case 0x8a: /* Primary no-fault LE */\n\n        if (page_check_range(addr, size, PAGE_READ) == -1) {\n\n#ifdef DEBUG_ASI\n\n            dump_asi(\"read \", last_addr, asi, size, ret);\n\n#endif\n\n            return 0;\n\n        }\n\n        /* Fall through */\n\n    case 0x80: /* Primary */\n\n    case 0x88: /* Primary LE */\n\n        {\n\n            switch (size) {\n\n            case 1:\n\n                ret = ldub_raw(addr);\n\n                break;\n\n            case 2:\n\n                ret = lduw_raw(addr);\n\n                break;\n\n            case 4:\n\n                ret = ldl_raw(addr);\n\n                break;\n\n            default:\n\n            case 8:\n\n                ret = ldq_raw(addr);\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n    case 0x83: /* Secondary no-fault */\n\n    case 0x8b: /* Secondary no-fault LE */\n\n        if (page_check_range(addr, size, PAGE_READ) == -1) {\n\n#ifdef DEBUG_ASI\n\n            dump_asi(\"read \", last_addr, asi, size, ret);\n\n#endif\n\n            return 0;\n\n        }\n\n        /* Fall through */\n\n    case 0x81: /* Secondary */\n\n    case 0x89: /* Secondary LE */\n\n        /* XXX */\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* Convert from little endian */\n\n    switch (asi) {\n\n    case 0x88: /* Primary LE */\n\n    case 0x89: /* Secondary LE */\n\n    case 0x8a: /* Primary no-fault LE */\n\n    case 0x8b: /* Secondary no-fault LE */\n\n        switch (size) {\n\n        case 2:\n\n            ret = bswap16(ret);\n\n            break;\n\n        case 4:\n\n            ret = bswap32(ret);\n\n            break;\n\n        case 8:\n\n            ret = bswap64(ret);\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* Convert to signed number */\n\n    if (sign) {\n\n        switch (size) {\n\n        case 1:\n\n            ret = (int8_t) ret;\n\n            break;\n\n        case 2:\n\n            ret = (int16_t) ret;\n\n            break;\n\n        case 4:\n\n            ret = (int32_t) ret;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n#ifdef DEBUG_ASI\n\n    dump_asi(\"read \", last_addr, asi, size, ret);\n\n#endif\n\n    return ret;\n\n}\n", "idx": 25134}
{"project": "qemu", "commit_id": "4d7a81c06f5f17e019a2d3a18300500bd64f6f40", "target": 1, "func": "static void xhci_check_iso_kick(XHCIState *xhci, XHCITransfer *xfer,\n\n                                XHCIEPContext *epctx, uint64_t mfindex)\n\n{\n\n    if (xfer->mfindex_kick > mfindex) {\n\n        timer_mod(epctx->kick_timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) +\n\n                       (xfer->mfindex_kick - mfindex) * 125000);\n\n        xfer->running_retry = 1;\n\n    } else {\n\n        epctx->mfindex_last = xfer->mfindex_kick;\n\n        timer_del(epctx->kick_timer);\n\n        xfer->running_retry = 0;\n\n    }\n\n}\n", "idx": 25136}
{"project": "qemu", "commit_id": "66b9b43c42049bcae37668e890fedde9a72c8167", "target": 1, "func": "static void watch_mem_write(void *opaque, hwaddr addr,\n\n                            uint64_t val, unsigned size)\n\n{\n\n    check_watchpoint(addr & ~TARGET_PAGE_MASK, size, BP_MEM_WRITE);\n\n    switch (size) {\n\n    case 1:\n\n        stb_phys(&address_space_memory, addr, val);\n\n        break;\n\n    case 2:\n\n        stw_phys(&address_space_memory, addr, val);\n\n        break;\n\n    case 4:\n\n        stl_phys(&address_space_memory, addr, val);\n\n        break;\n\n    default: abort();\n\n    }\n\n}\n", "idx": 25137}
{"project": "qemu", "commit_id": "a2bebfd6e09d285aa793cae3fb0fc3a39a9fee6e", "target": 1, "func": "long vnc_client_read_ws(VncState *vs)\n\n{\n\n    int ret, err;\n\n    uint8_t *payload;\n\n    size_t payload_size, frame_size;\n\n    VNC_DEBUG(\"Read websocket %p size %zd offset %zd\\n\", vs->ws_input.buffer,\n\n            vs->ws_input.capacity, vs->ws_input.offset);\n\n    buffer_reserve(&vs->ws_input, 4096);\n\n    ret = vnc_client_read_buf(vs, buffer_end(&vs->ws_input), 4096);\n\n    if (!ret) {\n\n        return 0;\n\n    }\n\n    vs->ws_input.offset += ret;\n\n\n\n    /* make sure that nothing is left in the ws_input buffer */\n\n    do {\n\n        err = vncws_decode_frame(&vs->ws_input, &payload,\n\n                              &payload_size, &frame_size);\n\n        if (err <= 0) {\n\n            return err;\n\n        }\n\n\n\n        buffer_reserve(&vs->input, payload_size);\n\n        buffer_append(&vs->input, payload, payload_size);\n\n\n\n        buffer_advance(&vs->ws_input, frame_size);\n\n    } while (vs->ws_input.offset > 0);\n\n\n\n    return ret;\n\n}\n", "idx": 25139}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mfsrin_64b(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    TCGv t0;\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    t0 = tcg_temp_new();\n\n    tcg_gen_shri_tl(t0, cpu_gpr[rB(ctx->opcode)], 28);\n\n    tcg_gen_andi_tl(t0, t0, 0xF);\n\n    gen_helper_load_sr(cpu_gpr[rD(ctx->opcode)], cpu_env, t0);\n\n    tcg_temp_free(t0);\n\n#endif\n\n}\n", "idx": 25142}
{"project": "qemu", "commit_id": "74f24cb6306d065045d0e2215a7d10533fa59c57", "target": 1, "func": "static void test_visitor_in_intList(TestInputVisitorData *data,\n\n                                    const void *unused)\n\n{\n\n    int64_t value[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 20};\n\n    int16List *res = NULL, *tmp;\n\n    Error *err = NULL;\n\n    Visitor *v;\n\n    int i = 0;\n\n\n\n    v = visitor_input_test_init(data, \"1,2,0,2-4,20,5-9,1-8\");\n\n\n\n    visit_type_int16List(v, NULL, &res, &error_abort);\n\n    tmp = res;\n\n    while (i < sizeof(value) / sizeof(value[0])) {\n\n        g_assert(tmp);\n\n        g_assert_cmpint(tmp->value, ==, value[i++]);\n\n        tmp = tmp->next;\n\n    }\n\n    g_assert(!tmp);\n\n\n\n    tmp = res;\n\n    while (tmp) {\n\n        res = res->next;\n\n        g_free(tmp);\n\n        tmp = res;\n\n    }\n\n\n\n    visitor_input_teardown(data, unused);\n\n\n\n    v = visitor_input_test_init(data, \"not an int list\");\n\n\n\n    visit_type_int16List(v, NULL, &res, &err);\n\n    /* FIXME fix the visitor, then error_free_or_abort(&err) here */\n\n}\n", "idx": 25146}
{"project": "qemu", "commit_id": "ad2d30f79d3b0812f02c741be2189796b788d6d7", "target": 1, "func": "static void scsi_req_dequeue(SCSIRequest *req)\n\n{\n\n    trace_scsi_req_dequeue(req->dev->id, req->lun, req->tag);\n\n    if (req->enqueued) {\n\n        QTAILQ_REMOVE(&req->dev->requests, req, next);\n\n        req->enqueued = false;\n\n    }\n\n}\n", "idx": 25148}
{"project": "qemu", "commit_id": "420b6c317de87890e06225de6e2f8af7bf714df0", "target": 1, "func": "void check_aligned_anonymous_unfixed_colliding_mmaps(void)\n\n{\n\n\tchar *p1;\n\n\tchar *p2;\n\n\tchar *p3;\n\n\tuintptr_t p;\n\n\tint i;\n\n\n\n\tfprintf (stderr, \"%s\", __func__);\n\n\tfor (i = 0; i < 0x2fff; i++)\n\n\t{\n\n\t\tint nlen;\n\n\t\tp1 = mmap(NULL, pagesize, PROT_READ, \n\n\t\t\t  MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n\t\tfail_unless (p1 != MAP_FAILED);\n\n\t\tp = (uintptr_t) p1;\n\n\t\tfail_unless ((p & pagemask) == 0);\n\n\t\tmemcpy (dummybuf, p1, pagesize);\n\n\n\n\t\tp2 = mmap(NULL, pagesize, PROT_READ, \n\n\t\t\t  MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n\t\tfail_unless (p2 != MAP_FAILED);\n\n\t\tp = (uintptr_t) p2;\n\n\t\tfail_unless ((p & pagemask) == 0);\n\n\t\tmemcpy (dummybuf, p2, pagesize);\n\n\n\n\n\n\t\tmunmap (p1, pagesize);\n\n\t\tnlen = pagesize * 8;\n\n\t\tp3 = mmap(NULL, nlen, PROT_READ, \n\n\t\t\t  MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n\n\n\t\t/* Check if the mmaped areas collide.  */\n\n\t\tif (p3 < p2 \n\n\t\t    && (p3 + nlen) > p2)\n\n\t\t\tfail_unless (0);\n\n\n\n\t\tmemcpy (dummybuf, p3, pagesize);\n\n\n\n\t\t/* Make sure we get pages aligned with the pagesize. The\n\n\t\t   target expects this.  */\n\n\t\tfail_unless (p3 != MAP_FAILED);\n\n\t\tp = (uintptr_t) p3;\n\n\t\tfail_unless ((p & pagemask) == 0);\n\n\t\tmunmap (p2, pagesize);\n\n\t\tmunmap (p3, nlen);\n\n\t}\n\n\tfprintf (stderr, \" passed\\n\");\n\n}\n", "idx": 25150}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qmp_migrate_set_downtime(double value, Error **errp)\n\n{\n\n    value *= 1e9;\n\n    value = MAX(0, MIN(UINT64_MAX, value));\n\n    max_downtime = (uint64_t)value;\n\n}\n", "idx": 25153}
{"project": "qemu", "commit_id": "a543a554cfffa4bbed2c74ac56c1abf046821377", "target": 1, "func": "static void prop_get_fdt(Object *obj, Visitor *v, const char *name,\n\n                         void *opaque, Error **errp)\n\n{\n\n    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(obj);\n\n    Error *err = NULL;\n\n    int fdt_offset_next, fdt_offset, fdt_depth;\n\n    void *fdt;\n\n\n\n    if (!drc->fdt) {\n\n        visit_start_struct(v, name, NULL, 0, &err);\n\n        if (!err) {\n\n            visit_end_struct(v, &err);\n\n        }\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n\n\n    fdt = drc->fdt;\n\n    fdt_offset = drc->fdt_start_offset;\n\n    fdt_depth = 0;\n\n\n\n    do {\n\n        const char *name = NULL;\n\n        const struct fdt_property *prop = NULL;\n\n        int prop_len = 0, name_len = 0;\n\n        uint32_t tag;\n\n\n\n        tag = fdt_next_tag(fdt, fdt_offset, &fdt_offset_next);\n\n        switch (tag) {\n\n        case FDT_BEGIN_NODE:\n\n            fdt_depth++;\n\n            name = fdt_get_name(fdt, fdt_offset, &name_len);\n\n            visit_start_struct(v, name, NULL, 0, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                return;\n\n            }\n\n            break;\n\n        case FDT_END_NODE:\n\n            /* shouldn't ever see an FDT_END_NODE before FDT_BEGIN_NODE */\n\n            g_assert(fdt_depth > 0);\n\n            visit_end_struct(v, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                return;\n\n            }\n\n            fdt_depth--;\n\n            break;\n\n        case FDT_PROP: {\n\n            int i;\n\n            prop = fdt_get_property_by_offset(fdt, fdt_offset, &prop_len);\n\n            name = fdt_string(fdt, fdt32_to_cpu(prop->nameoff));\n\n            visit_start_list(v, name, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                return;\n\n            }\n\n            for (i = 0; i < prop_len; i++) {\n\n                visit_type_uint8(v, NULL, (uint8_t *)&prop->data[i], &err);\n\n                if (err) {\n\n                    error_propagate(errp, err);\n\n                    return;\n\n                }\n\n            }\n\n            visit_end_list(v);\n\n            break;\n\n        }\n\n        default:\n\n            error_setg(&error_abort, \"device FDT in unexpected state: %d\", tag);\n\n        }\n\n        fdt_offset = fdt_offset_next;\n\n    } while (fdt_depth != 0);\n\n}\n", "idx": 25154}
{"project": "qemu", "commit_id": "4f400ab52009ed8f76fa541454a4368f9515f897", "target": 1, "func": "gen_intermediate_code_internal(CPUState *env, TranslationBlock *tb,\n\n                               int search_pc)\n\n{\n\n\tuint16_t *gen_opc_end;\n\n   \tuint32_t pc_start;\n\n\tunsigned int insn_len;\n\n\tint j, lj;\n\n\tstruct DisasContext *dc = &ctx;\n\n\tuint32_t next_page_start;\n\n\n\n\tpc_start = tb->pc;\n\n\tdc->env = env;\n\n\tdc->tb = tb;\n\n\n\n\tgen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n\n\n\tdc->is_jmp = DISAS_NEXT;\n\n\tdc->pc = pc_start;\n\n\tdc->singlestep_enabled = env->singlestep_enabled;\n\n\tdc->flagx_live = 0;\n\n\tdc->flags_x = 0;\n\n\tnext_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n\n\tlj = -1;\n\n\tdo\n\n\t{\n\n\t\tcheck_breakpoint(env, dc);\n\n\t\tif (dc->is_jmp == DISAS_JUMP)\n\n\t\t\tgoto done;\n\n\n\n\t\tif (search_pc) {\n\n\t\t\tj = gen_opc_ptr - gen_opc_buf;\n\n\t\t\tif (lj < j) {\n\n\t\t\t\tlj++;\n\n\t\t\t\twhile (lj < j)\n\n\t\t\t\t\tgen_opc_instr_start[lj++] = 0;\n\n\t\t\t}\n\n\t\t\tgen_opc_pc[lj] = dc->pc;\n\n\t\t\tgen_opc_instr_start[lj] = 1;\n\n\t\t}\n\n\n\n\t\tinsn_len = cris_decoder(dc);\n\n\t\tSTATS(gen_op_exec_insn());\n\n\t\tdc->pc += insn_len;\n\n\t\tif (!dc->flagx_live\n\n\t\t    || (dc->flagx_live &&\n\n\t\t\t!(dc->cc_op == CC_OP_FLAGS && dc->flags_x))) {\n\n\t\t\tgen_movl_T0_preg[PR_CCS]();\n\n\t\t\tgen_op_andl_T0_im(~X_FLAG);\n\n\t\t\tgen_movl_preg_T0[PR_CCS]();\n\n\t\t\tdc->flagx_live = 1;\n\n\t\t\tdc->flags_x = 0;\n\n\t\t}\n\n\n\n\t\t/* Check for delayed branches here. If we do it before\n\n\t\t   actually genereating any host code, the simulator will just\n\n\t\t   loop doing nothing for on this program location.  */\n\n\t\tif (dc->delayed_branch) {\n\n\t\t\tdc->delayed_branch--;\n\n\t\t\tif (dc->delayed_branch == 0)\n\n\t\t\t{\n\n\t\t\t\tif (dc->bcc == CC_A) {\n\n\t\t\t\t\tgen_op_jmp1 ();\n\n\t\t\t\t\tdc->is_jmp = DISAS_UPDATE;\n\n\t\t\t\t}\n\n\t\t\t\telse {\n\n\t\t\t\t\t/* Conditional jmp.  */\n\n\t\t\t\t\tgen_op_cc_jmp (dc->delayed_pc, dc->pc);\n\n\t\t\t\t\tdc->is_jmp = DISAS_UPDATE;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\n\t\tif (env->singlestep_enabled)\n\n\t\t\tbreak;\n\n\t} while (!dc->is_jmp && gen_opc_ptr < gen_opc_end\n\n\t\t && dc->pc < next_page_start);\n\n\n\n\tif (!dc->is_jmp) {\n\n\t\tgen_op_movl_T0_im((long)dc->pc);\n\n\t\tgen_op_movl_pc_T0();\n\n\t}\n\n\n\n\tcris_evaluate_flags (dc);\n\n  done:\n\n\tif (__builtin_expect(env->singlestep_enabled, 0)) {\n\n\t\tgen_op_debug();\n\n\t} else {\n\n\t\tswitch(dc->is_jmp) {\n\n\t\t\tcase DISAS_NEXT:\n\n\t\t\t\tgen_goto_tb(dc, 1, dc->pc);\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\tcase DISAS_JUMP:\n\n\t\t\tcase DISAS_UPDATE:\n\n\t\t\t\t/* indicate that the hash table must be used\n\n\t\t\t\t   to find the next TB */\n\n\t\t\t\ttcg_gen_exit_tb(0);\n\n\t\t\t\tbreak;\n\n\t\t\tcase DISAS_TB_JUMP:\n\n\t\t\t\t/* nothing more to generate */\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t*gen_opc_ptr = INDEX_op_end;\n\n\tif (search_pc) {\n\n\t\tj = gen_opc_ptr - gen_opc_buf;\n\n\t\tlj++;\n\n\t\twhile (lj <= j)\n\n\t\t\tgen_opc_instr_start[lj++] = 0;\n\n\t} else {\n\n\t\ttb->size = dc->pc - pc_start;\n\n\t}\n\n\n\n#ifdef DEBUG_DISAS\n\n\tif (loglevel & CPU_LOG_TB_IN_ASM) {\n\n\t\tfprintf(logfile, \"--------------\\n\");\n\n\t\tfprintf(logfile, \"IN: %s\\n\", lookup_symbol(pc_start));\n\n\t\ttarget_disas(logfile, pc_start, dc->pc + 4 - pc_start, 0);\n\n\t\tfprintf(logfile, \"\\n\");\n\n\t}\n\n#endif\n\n\treturn 0;\n\n}\n", "idx": 25157}
{"project": "qemu", "commit_id": "15c2f669e3fb2bc97f7b42d1871f595c0ac24af8", "target": 1, "func": "static void balloon_stats_get_all(Object *obj, Visitor *v, const char *name,\n\n                                  void *opaque, Error **errp)\n\n{\n\n    Error *err = NULL;\n\n    VirtIOBalloon *s = opaque;\n\n    int i;\n\n\n\n    visit_start_struct(v, name, NULL, 0, &err);\n\n    if (err) {\n\n        goto out;\n\n    }\n\n    visit_type_int(v, \"last-update\", &s->stats_last_update, &err);\n\n    if (err) {\n\n        goto out_end;\n\n    }\n\n\n\n    visit_start_struct(v, \"stats\", NULL, 0, &err);\n\n    if (err) {\n\n        goto out_end;\n\n    }\n\n    for (i = 0; i < VIRTIO_BALLOON_S_NR; i++) {\n\n        visit_type_uint64(v, balloon_stat_names[i], &s->stats[i], &err);\n\n        if (err) {\n\n            break;\n\n        }\n\n    }\n\n    error_propagate(errp, err);\n\n    err = NULL;\n\n    visit_end_struct(v, &err);\n\n\n\nout_end:\n\n    error_propagate(errp, err);\n\n    err = NULL;\n\n    visit_end_struct(v, &err);\n\nout:\n\n    error_propagate(errp, err);\n\n}\n", "idx": 25158}
{"project": "qemu", "commit_id": "ec45bbe5f1921c6553fbf9c0c76b358b0403c22d", "target": 1, "func": "envlist_setenv(envlist_t *envlist, const char *env)\n\n{\n\n\tstruct envlist_entry *entry = NULL;\n\n\tconst char *eq_sign;\n\n\tsize_t envname_len;\n\n\n\n\tif ((envlist == NULL) || (env == NULL))\n\n\t\treturn (EINVAL);\n\n\n\n\t/* find out first equals sign in given env */\n\n\tif ((eq_sign = strchr(env, '=')) == NULL)\n\n\t\treturn (EINVAL);\n\n\tenvname_len = eq_sign - env + 1;\n\n\n\n\t/*\n\n\t * If there already exists variable with given name\n\n\t * we remove and release it before allocating a whole\n\n\t * new entry.\n\n\t */\n\n\tfor (entry = envlist->el_entries.lh_first; entry != NULL;\n\n\t    entry = entry->ev_link.le_next) {\n\n\t\tif (strncmp(entry->ev_var, env, envname_len) == 0)\n\n\t\t\tbreak;\n\n\t}\n\n\n\n\tif (entry != NULL) {\n\n\t\tQLIST_REMOVE(entry, ev_link);\n\n\t\tfree((char *)entry->ev_var);\n\n\t\tfree(entry);\n\n\t} else {\n\n\t\tenvlist->el_count++;\n\n\t}\n\n\n\n\tif ((entry = malloc(sizeof (*entry))) == NULL)\n\n\t\treturn (errno);\n\n\tif ((entry->ev_var = strdup(env)) == NULL) {\n\n\t\tfree(entry);\n\n\t\treturn (errno);\n\n\t}\n\n\tQLIST_INSERT_HEAD(&envlist->el_entries, entry, ev_link);\n\n\n\n\treturn (0);\n\n}\n", "idx": 25159}
{"project": "qemu", "commit_id": "76e3e1bcaefe0da394f328854cb72f9449f23732", "target": 0, "func": "static inline int check_ap(CPUARMState *env, int ap, int domain_prot,\n\n                           int access_type, int is_user)\n\n{\n\n  int prot_ro;\n\n\n\n  if (domain_prot == 3) {\n\n    return PAGE_READ | PAGE_WRITE;\n\n  }\n\n\n\n  if (access_type == 1)\n\n      prot_ro = 0;\n\n  else\n\n      prot_ro = PAGE_READ;\n\n\n\n  switch (ap) {\n\n  case 0:\n\n      if (access_type == 1)\n\n          return 0;\n\n      switch ((env->cp15.c1_sys >> 8) & 3) {\n\n      case 1:\n\n          return is_user ? 0 : PAGE_READ;\n\n      case 2:\n\n          return PAGE_READ;\n\n      default:\n\n          return 0;\n\n      }\n\n  case 1:\n\n      return is_user ? 0 : PAGE_READ | PAGE_WRITE;\n\n  case 2:\n\n      if (is_user)\n\n          return prot_ro;\n\n      else\n\n          return PAGE_READ | PAGE_WRITE;\n\n  case 3:\n\n      return PAGE_READ | PAGE_WRITE;\n\n  case 4: /* Reserved.  */\n\n      return 0;\n\n  case 5:\n\n      return is_user ? 0 : prot_ro;\n\n  case 6:\n\n      return prot_ro;\n\n  case 7:\n\n      if (!arm_feature (env, ARM_FEATURE_V6K))\n\n          return 0;\n\n      return prot_ro;\n\n  default:\n\n      abort();\n\n  }\n\n}\n", "idx": 25160}
{"project": "qemu", "commit_id": "ea5bef49eadd240c7924f287f2da1bb457a3f92c", "target": 0, "func": "static void test_mirror(void)\n\n{\n\n    int send_sock[2], recv_sock;\n\n    char *cmdline;\n\n    uint32_t ret = 0, len = 0;\n\n    char send_buf[] = \"Hello! filter-mirror~\";\n\n    char sock_path[] = \"filter-mirror.XXXXXX\";\n\n    char *recv_buf;\n\n    uint32_t size = sizeof(send_buf);\n\n    size = htonl(size);\n\n\n\n    ret = socketpair(PF_UNIX, SOCK_STREAM, 0, send_sock);\n\n    g_assert_cmpint(ret, !=, -1);\n\n\n\n    ret = mkstemp(sock_path);\n\n    g_assert_cmpint(ret, !=, -1);\n\n\n\n    cmdline = g_strdup_printf(\"-netdev socket,id=qtest-bn0,fd=%d \"\n\n                 \"-device e1000,netdev=qtest-bn0,id=qtest-e0 \"\n\n                 \"-chardev socket,id=mirror0,path=%s,server,nowait \"\n\n                 \"-object filter-mirror,id=qtest-f0,netdev=qtest-bn0,queue=tx,outdev=mirror0 \"\n\n                 , send_sock[1], sock_path);\n\n    qtest_start(cmdline);\n\n    g_free(cmdline);\n\n\n\n    recv_sock = unix_connect(sock_path, NULL);\n\n    g_assert_cmpint(recv_sock, !=, -1);\n\n\n\n    struct iovec iov[] = {\n\n        {\n\n            .iov_base = &size,\n\n            .iov_len = sizeof(size),\n\n        }, {\n\n            .iov_base = send_buf,\n\n            .iov_len = sizeof(send_buf),\n\n        },\n\n    };\n\n\n\n    /* send a qmp command to guarantee that 'connected' is setting to true. */\n\n    qmp_discard_response(\"{ 'execute' : 'query-status'}\");\n\n    ret = iov_send(send_sock[0], iov, 2, 0, sizeof(size) + sizeof(send_buf));\n\n    g_assert_cmpint(ret, ==, sizeof(send_buf) + sizeof(size));\n\n    close(send_sock[0]);\n\n\n\n    ret = qemu_recv(recv_sock, &len, sizeof(len), 0);\n\n    g_assert_cmpint(ret, ==, sizeof(len));\n\n    len = ntohl(len);\n\n\n\n    g_assert_cmpint(len, ==, sizeof(send_buf));\n\n    recv_buf = g_malloc(len);\n\n    ret = qemu_recv(recv_sock, recv_buf, len, 0);\n\n    g_assert_cmpstr(recv_buf, ==, send_buf);\n\n\n\n    g_free(recv_buf);\n\n    close(recv_sock);\n\n    unlink(sock_path);\n\n}\n", "idx": 25161}
{"project": "qemu", "commit_id": "e7d336959b7c01699702dcda4b54a822972d74a8", "target": 0, "func": "S390PCIBusDevice *s390_pci_find_dev_by_fh(uint32_t fh)\n\n{\n\n    S390PCIBusDevice *pbdev;\n\n    int i;\n\n    S390pciState *s = S390_PCI_HOST_BRIDGE(\n\n        object_resolve_path(TYPE_S390_PCI_HOST_BRIDGE, NULL));\n\n\n\n    if (!s || !fh) {\n\n        return NULL;\n\n    }\n\n\n\n    for (i = 0; i < PCI_SLOT_MAX; i++) {\n\n        pbdev = &s->pbdev[i];\n\n        if (pbdev->fh == fh) {\n\n            return pbdev;\n\n        }\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 25162}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "static void spr_write_dbatu_h (void *opaque, int sprn)\n\n{\n\n    DisasContext *ctx = opaque;\n\n\n\n    gen_op_store_dbatu((sprn - SPR_DBAT4U) / 2);\n\n    RET_STOP(ctx);\n\n}\n", "idx": 25163}
{"project": "qemu", "commit_id": "807464d8a7326e1025a2f392bf41636b0809d6da", "target": 0, "func": "static void serial_ioport_write(void *opaque, hwaddr addr, uint64_t val,\n\n                                unsigned size)\n\n{\n\n    SerialState *s = opaque;\n\n\n\n    addr &= 7;\n\n    DPRINTF(\"write addr=0x%\" HWADDR_PRIx \" val=0x%\" PRIx64 \"\\n\", addr, val);\n\n    switch(addr) {\n\n    default:\n\n    case 0:\n\n        if (s->lcr & UART_LCR_DLAB) {\n\n            s->divider = (s->divider & 0xff00) | val;\n\n            serial_update_parameters(s);\n\n        } else {\n\n            s->thr = (uint8_t) val;\n\n            if(s->fcr & UART_FCR_FE) {\n\n                /* xmit overruns overwrite data, so make space if needed */\n\n                if (fifo8_is_full(&s->xmit_fifo)) {\n\n                    fifo8_pop(&s->xmit_fifo);\n\n                }\n\n                fifo8_push(&s->xmit_fifo, s->thr);\n\n            }\n\n            s->thr_ipending = 0;\n\n            s->lsr &= ~UART_LSR_THRE;\n\n            s->lsr &= ~UART_LSR_TEMT;\n\n            serial_update_irq(s);\n\n            if (s->tsr_retry <= 0) {\n\n                serial_xmit(NULL, G_IO_OUT, s);\n\n            }\n\n        }\n\n        break;\n\n    case 1:\n\n        if (s->lcr & UART_LCR_DLAB) {\n\n            s->divider = (s->divider & 0x00ff) | (val << 8);\n\n            serial_update_parameters(s);\n\n        } else {\n\n            uint8_t changed = (s->ier ^ val) & 0x0f;\n\n            s->ier = val & 0x0f;\n\n            /* If the backend device is a real serial port, turn polling of the modem\n\n             * status lines on physical port on or off depending on UART_IER_MSI state.\n\n             */\n\n            if ((changed & UART_IER_MSI) && s->poll_msl >= 0) {\n\n                if (s->ier & UART_IER_MSI) {\n\n                     s->poll_msl = 1;\n\n                     serial_update_msl(s);\n\n                } else {\n\n                     timer_del(s->modem_status_poll);\n\n                     s->poll_msl = 0;\n\n                }\n\n            }\n\n\n\n            /* Turning on the THRE interrupt on IER can trigger the interrupt\n\n             * if LSR.THRE=1, even if it had been masked before by reading IIR.\n\n             * This is not in the datasheet, but Windows relies on it.  It is\n\n             * unclear if THRE has to be resampled every time THRI becomes\n\n             * 1, or only on the rising edge.  Bochs does the latter, and Windows\n\n             * always toggles IER to all zeroes and back to all ones, so do the\n\n             * same.\n\n             *\n\n             * If IER.THRI is zero, thr_ipending is not used.  Set it to zero\n\n             * so that the thr_ipending subsection is not migrated.\n\n             */\n\n            if (changed & UART_IER_THRI) {\n\n                if ((s->ier & UART_IER_THRI) && (s->lsr & UART_LSR_THRE)) {\n\n                    s->thr_ipending = 1;\n\n                } else {\n\n                    s->thr_ipending = 0;\n\n                }\n\n            }\n\n\n\n            if (changed) {\n\n                serial_update_irq(s);\n\n            }\n\n        }\n\n        break;\n\n    case 2:\n\n        /* Did the enable/disable flag change? If so, make sure FIFOs get flushed */\n\n        if ((val ^ s->fcr) & UART_FCR_FE) {\n\n            val |= UART_FCR_XFR | UART_FCR_RFR;\n\n        }\n\n\n\n        /* FIFO clear */\n\n\n\n        if (val & UART_FCR_RFR) {\n\n            s->lsr &= ~(UART_LSR_DR | UART_LSR_BI);\n\n            timer_del(s->fifo_timeout_timer);\n\n            s->timeout_ipending = 0;\n\n            fifo8_reset(&s->recv_fifo);\n\n        }\n\n\n\n        if (val & UART_FCR_XFR) {\n\n            s->lsr |= UART_LSR_THRE;\n\n            s->thr_ipending = 1;\n\n            fifo8_reset(&s->xmit_fifo);\n\n        }\n\n\n\n        serial_write_fcr(s, val & 0xC9);\n\n        serial_update_irq(s);\n\n        break;\n\n    case 3:\n\n        {\n\n            int break_enable;\n\n            s->lcr = val;\n\n            serial_update_parameters(s);\n\n            break_enable = (val >> 6) & 1;\n\n            if (break_enable != s->last_break_enable) {\n\n                s->last_break_enable = break_enable;\n\n                qemu_chr_fe_ioctl(s->chr, CHR_IOCTL_SERIAL_SET_BREAK,\n\n                               &break_enable);\n\n            }\n\n        }\n\n        break;\n\n    case 4:\n\n        {\n\n            int flags;\n\n            int old_mcr = s->mcr;\n\n            s->mcr = val & 0x1f;\n\n            if (val & UART_MCR_LOOP)\n\n                break;\n\n\n\n            if (s->poll_msl >= 0 && old_mcr != s->mcr) {\n\n\n\n                qemu_chr_fe_ioctl(s->chr,CHR_IOCTL_SERIAL_GET_TIOCM, &flags);\n\n\n\n                flags &= ~(CHR_TIOCM_RTS | CHR_TIOCM_DTR);\n\n\n\n                if (val & UART_MCR_RTS)\n\n                    flags |= CHR_TIOCM_RTS;\n\n                if (val & UART_MCR_DTR)\n\n                    flags |= CHR_TIOCM_DTR;\n\n\n\n                qemu_chr_fe_ioctl(s->chr,CHR_IOCTL_SERIAL_SET_TIOCM, &flags);\n\n                /* Update the modem status after a one-character-send wait-time, since there may be a response\n\n                   from the device/computer at the other end of the serial line */\n\n                timer_mod(s->modem_status_poll, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + s->char_transmit_time);\n\n            }\n\n        }\n\n        break;\n\n    case 5:\n\n        break;\n\n    case 6:\n\n        break;\n\n    case 7:\n\n        s->scr = val;\n\n        break;\n\n    }\n\n}\n", "idx": 25165}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void bdrv_drain(BlockDriverState *bs)\n\n{\n\n    while (bdrv_drain_one(bs)) {\n\n        /* Keep iterating */\n\n    }\n\n}\n", "idx": 25166}
{"project": "qemu", "commit_id": "9eca6cc64392b4ad8bd8723e840f491fa36524ad", "target": 0, "func": "sprintf_len(char *string, const char *format, ...)\n\n#else\n\nsprintf_len(va_alist) va_dcl\n\n#endif\n\n{\n\n\tva_list args;\n\n#ifdef __STDC__\n\n\tva_start(args, format);\n\n#else\n\n\tchar *string;\n\n\tchar *format;\n\n\tva_start(args);\n\n\tstring = va_arg(args, char *);\n\n\tformat = va_arg(args, char *);\n\n#endif\n\n\tvsprintf(string, format, args);\n\n\treturn strlen(string);\n\n}\n", "idx": 25167}
{"project": "qemu", "commit_id": "c2fa30757a2ba1bb5b053883773a9a61fbdd7082", "target": 0, "func": "static void nvdimm_dsm_set_label_data(NVDIMMDevice *nvdimm, NvdimmDsmIn *in,\n\n                                      hwaddr dsm_mem_addr)\n\n{\n\n    NVDIMMClass *nvc = NVDIMM_GET_CLASS(nvdimm);\n\n    NvdimmFuncSetLabelDataIn *set_label_data;\n\n    uint32_t status;\n\n\n\n    set_label_data = (NvdimmFuncSetLabelDataIn *)in->arg3;\n\n\n\n    le32_to_cpus(&set_label_data->offset);\n\n    le32_to_cpus(&set_label_data->length);\n\n\n\n    nvdimm_debug(\"Write Label Data: offset %#x length %#x.\\n\",\n\n                 set_label_data->offset, set_label_data->length);\n\n\n\n    status = nvdimm_rw_label_data_check(nvdimm, set_label_data->offset,\n\n                                        set_label_data->length);\n\n    if (status != 0 /* Success */) {\n\n        nvdimm_dsm_no_payload(status, dsm_mem_addr);\n\n        return;\n\n    }\n\n\n\n    assert(offsetof(NvdimmDsmIn, arg3) +\n\n           sizeof(*set_label_data) + set_label_data->length <= 4096);\n\n\n\n    nvc->write_label_data(nvdimm, set_label_data->in_buf,\n\n                          set_label_data->length, set_label_data->offset);\n\n    nvdimm_dsm_no_payload(0 /* Success */, dsm_mem_addr);\n\n}\n", "idx": 25168}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static void slirp_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n#ifdef DEBUG_SLIRP\n\n    printf(\"slirp input:\\n\");\n\n    hex_dump(stdout, buf, size);\n\n#endif\n\n    slirp_input(buf, size);\n\n}\n", "idx": 25169}
{"project": "qemu", "commit_id": "b29a0341d7ed7e7df4bf77a41db8e614f1ddb645", "target": 0, "func": "void op_dmfc0_ebase (void)\n\n{\n\n    T0 = env->CP0_EBase;\n\n    RETURN();\n\n}\n", "idx": 25170}
{"project": "qemu", "commit_id": "9a78eead0c74333a394c0f7bbfc4423ac746fcd5", "target": 0, "func": "void sparc_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))\n\n{\n\n    unsigned int i;\n\n\n\n    for (i = 0; i < ARRAY_SIZE(sparc_defs); i++) {\n\n        (*cpu_fprintf)(f, \"Sparc %16s IU \" TARGET_FMT_lx \" FPU %08x MMU %08x NWINS %d \",\n\n                       sparc_defs[i].name,\n\n                       sparc_defs[i].iu_version,\n\n                       sparc_defs[i].fpu_version,\n\n                       sparc_defs[i].mmu_version,\n\n                       sparc_defs[i].nwindows);\n\n        print_features(f, cpu_fprintf, CPU_DEFAULT_FEATURES &\n\n                       ~sparc_defs[i].features, \"-\");\n\n        print_features(f, cpu_fprintf, ~CPU_DEFAULT_FEATURES &\n\n                       sparc_defs[i].features, \"+\");\n\n        (*cpu_fprintf)(f, \"\\n\");\n\n    }\n\n    (*cpu_fprintf)(f, \"Default CPU feature flags (use '-' to remove): \");\n\n    print_features(f, cpu_fprintf, CPU_DEFAULT_FEATURES, NULL);\n\n    (*cpu_fprintf)(f, \"\\n\");\n\n    (*cpu_fprintf)(f, \"Available CPU feature flags (use '+' to add): \");\n\n    print_features(f, cpu_fprintf, ~CPU_DEFAULT_FEATURES, NULL);\n\n    (*cpu_fprintf)(f, \"\\n\");\n\n    (*cpu_fprintf)(f, \"Numerical features (use '=' to set): iu_version \"\n\n                   \"fpu_version mmu_version nwindows\\n\");\n\n}\n", "idx": 25171}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t dma_rinvalid (void *opaque, target_phys_addr_t addr)\n\n{\n\n        hw_error(\"Unsupported short raccess. reg=\" TARGET_FMT_plx \"\\n\", addr);\n\n        return 0;\n\n}\n", "idx": 25172}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "func": "static void scsi_hd_class_initfn(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SCSIDeviceClass *sc = SCSI_DEVICE_CLASS(klass);\n\n\n\n    sc->init         = scsi_hd_initfn;\n\n    sc->destroy      = scsi_destroy;\n\n    sc->alloc_req    = scsi_new_request;\n\n    sc->unit_attention_reported = scsi_disk_unit_attention_reported;\n\n    dc->fw_name = \"disk\";\n\n    dc->desc = \"virtual SCSI disk\";\n\n    dc->reset = scsi_disk_reset;\n\n    dc->props = scsi_hd_properties;\n\n    dc->vmsd  = &vmstate_scsi_disk_state;\n\n}\n", "idx": 25173}
{"project": "qemu", "commit_id": "96c05abc904c6f74b60981d956cee531920e4cdf", "target": 0, "func": "static int qxl_init_secondary(PCIDevice *dev)\n\n{\n\n    static int device_id = 1;\n\n    PCIQXLDevice *qxl = DO_UPCAST(PCIQXLDevice, pci, dev);\n\n    ram_addr_t ram_size = msb_mask(qxl->vga.vram_size * 2 - 1);\n\n\n\n    qxl->id = device_id++;\n\n\n\n    if (ram_size < 16 * 1024 * 1024) {\n\n        ram_size = 16 * 1024 * 1024;\n\n    }\n\n    qxl->vga.vram_size = ram_size;\n\n    qxl->vga.vram_offset = qemu_ram_alloc(&qxl->pci.qdev, \"qxl.vgavram\",\n\n                                          qxl->vga.vram_size);\n\n    qxl->vga.vram_ptr = qemu_get_ram_ptr(qxl->vga.vram_offset);\n\n\n\n    pci_config_set_class(dev->config, PCI_CLASS_DISPLAY_OTHER);\n\n    return qxl_init_common(qxl);\n\n}\n", "idx": 25174}
{"project": "qemu", "commit_id": "8c6afa6ab158467d1938cc92022135bc7a872006", "target": 0, "func": "static void disas_simd_3same_logic(DisasContext *s, uint32_t insn)\n\n{\n\n    int rd = extract32(insn, 0, 5);\n\n    int rn = extract32(insn, 5, 5);\n\n    int rm = extract32(insn, 16, 5);\n\n    int size = extract32(insn, 22, 2);\n\n    bool is_u = extract32(insn, 29, 1);\n\n    bool is_q = extract32(insn, 30, 1);\n\n    TCGv_i64 tcg_op1 = tcg_temp_new_i64();\n\n    TCGv_i64 tcg_op2 = tcg_temp_new_i64();\n\n    TCGv_i64 tcg_res[2];\n\n    int pass;\n\n\n\n    tcg_res[0] = tcg_temp_new_i64();\n\n    tcg_res[1] = tcg_temp_new_i64();\n\n\n\n    for (pass = 0; pass < (is_q ? 2 : 1); pass++) {\n\n        read_vec_element(s, tcg_op1, rn, pass, MO_64);\n\n        read_vec_element(s, tcg_op2, rm, pass, MO_64);\n\n\n\n        if (!is_u) {\n\n            switch (size) {\n\n            case 0: /* AND */\n\n                tcg_gen_and_i64(tcg_res[pass], tcg_op1, tcg_op2);\n\n                break;\n\n            case 1: /* BIC */\n\n                tcg_gen_andc_i64(tcg_res[pass], tcg_op1, tcg_op2);\n\n                break;\n\n            case 2: /* ORR */\n\n                tcg_gen_or_i64(tcg_res[pass], tcg_op1, tcg_op2);\n\n                break;\n\n            case 3: /* ORN */\n\n                tcg_gen_orc_i64(tcg_res[pass], tcg_op1, tcg_op2);\n\n                break;\n\n            }\n\n        } else {\n\n            if (size != 0) {\n\n                /* B* ops need res loaded to operate on */\n\n                read_vec_element(s, tcg_res[pass], rd, pass, MO_64);\n\n            }\n\n\n\n            switch (size) {\n\n            case 0: /* EOR */\n\n                tcg_gen_xor_i64(tcg_res[pass], tcg_op1, tcg_op2);\n\n                break;\n\n            case 1: /* BSL bitwise select */\n\n                tcg_gen_xor_i64(tcg_op1, tcg_op1, tcg_op2);\n\n                tcg_gen_and_i64(tcg_op1, tcg_op1, tcg_res[pass]);\n\n                tcg_gen_xor_i64(tcg_res[pass], tcg_op2, tcg_op1);\n\n                break;\n\n            case 2: /* BIT, bitwise insert if true */\n\n                tcg_gen_xor_i64(tcg_op1, tcg_op1, tcg_res[pass]);\n\n                tcg_gen_and_i64(tcg_op1, tcg_op1, tcg_op2);\n\n                tcg_gen_xor_i64(tcg_res[pass], tcg_res[pass], tcg_op1);\n\n                break;\n\n            case 3: /* BIF, bitwise insert if false */\n\n                tcg_gen_xor_i64(tcg_op1, tcg_op1, tcg_res[pass]);\n\n                tcg_gen_andc_i64(tcg_op1, tcg_op1, tcg_op2);\n\n                tcg_gen_xor_i64(tcg_res[pass], tcg_res[pass], tcg_op1);\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    write_vec_element(s, tcg_res[0], rd, 0, MO_64);\n\n    if (!is_q) {\n\n        tcg_gen_movi_i64(tcg_res[1], 0);\n\n    }\n\n    write_vec_element(s, tcg_res[1], rd, 1, MO_64);\n\n\n\n    tcg_temp_free_i64(tcg_op1);\n\n    tcg_temp_free_i64(tcg_op2);\n\n    tcg_temp_free_i64(tcg_res[0]);\n\n    tcg_temp_free_i64(tcg_res[1]);\n\n}\n", "idx": 25176}
{"project": "qemu", "commit_id": "81017645e45bcb0b4d985e900c501f92f2c6fb60", "target": 0, "func": "void net_check_clients(void)\n\n{\n\n    VLANState *vlan;\n\n    VLANClientState *vc;\n\n    int i;\n\n\n\n    /* Don't warn about the default network setup that you get if\n\n     * no command line -net or -netdev options are specified. There\n\n     * are two cases that we would otherwise complain about:\n\n     * (1) board doesn't support a NIC but the implicit \"-net nic\"\n\n     * requested one\n\n     * (2) CONFIG_SLIRP not set, in which case the implicit \"-net nic\"\n\n     * sets up a nic that isn't connected to anything.\n\n     */\n\n    if (default_net) {\n\n        return;\n\n    }\n\n\n\n    QTAILQ_FOREACH(vlan, &vlans, next) {\n\n        int has_nic = 0, has_host_dev = 0;\n\n\n\n        QTAILQ_FOREACH(vc, &vlan->clients, next) {\n\n            switch (vc->info->type) {\n\n            case NET_CLIENT_OPTIONS_KIND_NIC:\n\n                has_nic = 1;\n\n                break;\n\n            case NET_CLIENT_OPTIONS_KIND_USER:\n\n            case NET_CLIENT_OPTIONS_KIND_TAP:\n\n            case NET_CLIENT_OPTIONS_KIND_SOCKET:\n\n            case NET_CLIENT_OPTIONS_KIND_VDE:\n\n                has_host_dev = 1;\n\n                break;\n\n            default: ;\n\n            }\n\n        }\n\n        if (has_host_dev && !has_nic)\n\n            fprintf(stderr, \"Warning: vlan %d with no nics\\n\", vlan->id);\n\n        if (has_nic && !has_host_dev)\n\n            fprintf(stderr,\n\n                    \"Warning: vlan %d is not connected to host network\\n\",\n\n                    vlan->id);\n\n    }\n\n    QTAILQ_FOREACH(vc, &non_vlan_clients, next) {\n\n        if (!vc->peer) {\n\n            fprintf(stderr, \"Warning: %s %s has no peer\\n\",\n\n                    vc->info->type == NET_CLIENT_OPTIONS_KIND_NIC ? \"nic\" : \"netdev\",\n\n                    vc->name);\n\n        }\n\n    }\n\n\n\n    /* Check that all NICs requested via -net nic actually got created.\n\n     * NICs created via -device don't need to be checked here because\n\n     * they are always instantiated.\n\n     */\n\n    for (i = 0; i < MAX_NICS; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n        if (nd->used && !nd->instantiated) {\n\n            fprintf(stderr, \"Warning: requested NIC (%s, model %s) \"\n\n                    \"was not created (not supported by this machine?)\\n\",\n\n                    nd->name ? nd->name : \"anonymous\",\n\n                    nd->model ? nd->model : \"unspecified\");\n\n        }\n\n    }\n\n}\n", "idx": 25177}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static uint16_t read_u16(uint8_t *data, size_t offset)\n\n{\n\n    return ((data[offset] & 0xFF) << 8) | (data[offset + 1] & 0xFF);\n\n}\n", "idx": 25178}
{"project": "qemu", "commit_id": "9d8256ebc0ef88fb1f35d0405893962d20cc10ad", "target": 1, "func": "void sdl2_gl_scanout(DisplayChangeListener *dcl,\n\n                     uint32_t backing_id, bool backing_y_0_top,\n\n\n                     uint32_t x, uint32_t y,\n\n                     uint32_t w, uint32_t h)\n\n{\n\n    struct sdl2_console *scon = container_of(dcl, struct sdl2_console, dcl);\n\n\n\n    assert(scon->opengl);\n\n    scon->x = x;\n\n    scon->y = y;\n\n    scon->w = w;\n\n    scon->h = h;\n\n    scon->tex_id = backing_id;\n\n    scon->y0_top = backing_y_0_top;\n\n\n\n    SDL_GL_MakeCurrent(scon->real_window, scon->winctx);\n\n\n\n    if (scon->tex_id == 0 || scon->w == 0 || scon->h == 0) {\n\n        sdl2_set_scanout_mode(scon, false);\n\n        return;\n\n    }\n\n\n\n    sdl2_set_scanout_mode(scon, true);\n\n    if (!scon->fbo_id) {\n\n        glGenFramebuffers(1, &scon->fbo_id);\n\n    }\n\n\n\n    glBindFramebuffer(GL_FRAMEBUFFER_EXT, scon->fbo_id);\n\n    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,\n\n                              GL_TEXTURE_2D, scon->tex_id, 0);\n\n}", "idx": 25182}
{"project": "qemu", "commit_id": "74f24cb6306d065045d0e2215a7d10533fa59c57", "target": 1, "func": "static void parse_str(StringInputVisitor *siv, Error **errp)\n\n{\n\n    char *str = (char *) siv->string;\n\n    long long start, end;\n\n    Range *cur;\n\n    char *endptr;\n\n\n\n    if (siv->ranges) {\n\n        return;\n\n    }\n\n\n\n    do {\n\n        errno = 0;\n\n        start = strtoll(str, &endptr, 0);\n\n        if (errno == 0 && endptr > str) {\n\n            if (*endptr == '\\0') {\n\n                cur = g_malloc0(sizeof(*cur));\n\n                cur->begin = start;\n\n                cur->end = start + 1;\n\n                siv->ranges = g_list_insert_sorted_merged(siv->ranges, cur,\n\n                                                          range_compare);\n\n                cur = NULL;\n\n                str = NULL;\n\n            } else if (*endptr == '-') {\n\n                str = endptr + 1;\n\n                errno = 0;\n\n                end = strtoll(str, &endptr, 0);\n\n                if (errno == 0 && endptr > str && start <= end &&\n\n                    (start > INT64_MAX - 65536 ||\n\n                     end < start + 65536)) {\n\n                    if (*endptr == '\\0') {\n\n                        cur = g_malloc0(sizeof(*cur));\n\n                        cur->begin = start;\n\n                        cur->end = end + 1;\n\n                        siv->ranges =\n\n                            g_list_insert_sorted_merged(siv->ranges,\n\n                                                        cur,\n\n                                                        range_compare);\n\n                        cur = NULL;\n\n                        str = NULL;\n\n                    } else if (*endptr == ',') {\n\n                        str = endptr + 1;\n\n                        cur = g_malloc0(sizeof(*cur));\n\n                        cur->begin = start;\n\n                        cur->end = end + 1;\n\n                        siv->ranges =\n\n                            g_list_insert_sorted_merged(siv->ranges,\n\n                                                        cur,\n\n                                                        range_compare);\n\n                        cur = NULL;\n\n                    } else {\n\n                        goto error;\n\n                    }\n\n                } else {\n\n                    goto error;\n\n                }\n\n            } else if (*endptr == ',') {\n\n                str = endptr + 1;\n\n                cur = g_malloc0(sizeof(*cur));\n\n                cur->begin = start;\n\n                cur->end = start + 1;\n\n                siv->ranges = g_list_insert_sorted_merged(siv->ranges,\n\n                                                          cur,\n\n                                                          range_compare);\n\n                cur = NULL;\n\n            } else {\n\n                goto error;\n\n            }\n\n        } else {\n\n            goto error;\n\n        }\n\n    } while (str);\n\n\n\n    return;\n\nerror:\n\n    g_list_foreach(siv->ranges, free_range, NULL);\n\n    g_list_free(siv->ranges);\n\n    siv->ranges = NULL;\n\n}\n", "idx": 25183}
{"project": "qemu", "commit_id": "40f08e87f613273f9dcc8df7d6a0f574b7d28d05", "target": 1, "func": "static void mm_stop_timer(struct qemu_alarm_timer *t)\n\n{\n\n    timeKillEvent(mm_timer);\n\n    timeEndPeriod(mm_period);\n\n}\n", "idx": 25185}
{"project": "qemu", "commit_id": "233aa5c2d1cf4655ffe335025a68cf5454f87dad", "target": 1, "func": "int inet_nonblocking_connect(const char *str, bool *in_progress,\n\n                             Error **errp)\n\n{\n\n    QemuOpts *opts;\n\n    int sock = -1;\n\n\n\n    opts = qemu_opts_create(&dummy_opts, NULL, 0, NULL);\n\n    if (inet_parse(opts, str) == 0) {\n\n        sock = inet_connect_opts(opts, false, in_progress, errp);\n\n    } else {\n\n        error_set(errp, QERR_SOCKET_CREATE_FAILED);\n\n    }\n\n    qemu_opts_del(opts);\n\n    return sock;\n\n}\n", "idx": 25186}
{"project": "qemu", "commit_id": "e6afc87f804abee7d0479be5e8e31c56d885fafb", "target": 1, "func": " roundAndPackFloatx80(\n\n     int8 roundingPrecision, flag zSign, int32 zExp, uint64_t zSig0, uint64_t zSig1\n\n STATUS_PARAM)\n\n{\n\n    int8 roundingMode;\n\n    flag roundNearestEven, increment, isTiny;\n\n    int64 roundIncrement, roundMask, roundBits;\n\n\n\n    roundingMode = STATUS(float_rounding_mode);\n\n    roundNearestEven = ( roundingMode == float_round_nearest_even );\n\n    if ( roundingPrecision == 80 ) goto precision80;\n\n    if ( roundingPrecision == 64 ) {\n\n        roundIncrement = LIT64( 0x0000000000000400 );\n\n        roundMask = LIT64( 0x00000000000007FF );\n\n    }\n\n    else if ( roundingPrecision == 32 ) {\n\n        roundIncrement = LIT64( 0x0000008000000000 );\n\n        roundMask = LIT64( 0x000000FFFFFFFFFF );\n\n    }\n\n    else {\n\n        goto precision80;\n\n    }\n\n    zSig0 |= ( zSig1 != 0 );\n\n    if ( ! roundNearestEven ) {\n\n        if ( roundingMode == float_round_to_zero ) {\n\n            roundIncrement = 0;\n\n        }\n\n        else {\n\n            roundIncrement = roundMask;\n\n            if ( zSign ) {\n\n                if ( roundingMode == float_round_up ) roundIncrement = 0;\n\n            }\n\n            else {\n\n                if ( roundingMode == float_round_down ) roundIncrement = 0;\n\n            }\n\n        }\n\n    }\n\n    roundBits = zSig0 & roundMask;\n\n    if ( 0x7FFD <= (uint32_t) ( zExp - 1 ) ) {\n\n        if (    ( 0x7FFE < zExp )\n\n             || ( ( zExp == 0x7FFE ) && ( zSig0 + roundIncrement < zSig0 ) )\n\n           ) {\n\n            goto overflow;\n\n        }\n\n        if ( zExp <= 0 ) {\n\n            if ( STATUS(flush_to_zero) ) return packFloatx80( zSign, 0, 0 );\n\n            isTiny =\n\n                   ( STATUS(float_detect_tininess) == float_tininess_before_rounding )\n\n                || ( zExp < 0 )\n\n                || ( zSig0 <= zSig0 + roundIncrement );\n\n            shift64RightJamming( zSig0, 1 - zExp, &zSig0 );\n\n            zExp = 0;\n\n            roundBits = zSig0 & roundMask;\n\n            if ( isTiny && roundBits ) float_raise( float_flag_underflow STATUS_VAR);\n\n            if ( roundBits ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n            zSig0 += roundIncrement;\n\n            if ( (int64_t) zSig0 < 0 ) zExp = 1;\n\n            roundIncrement = roundMask + 1;\n\n            if ( roundNearestEven && ( roundBits<<1 == roundIncrement ) ) {\n\n                roundMask |= roundIncrement;\n\n            }\n\n            zSig0 &= ~ roundMask;\n\n            return packFloatx80( zSign, zExp, zSig0 );\n\n        }\n\n    }\n\n    if ( roundBits ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n    zSig0 += roundIncrement;\n\n    if ( zSig0 < roundIncrement ) {\n\n        ++zExp;\n\n        zSig0 = LIT64( 0x8000000000000000 );\n\n    }\n\n    roundIncrement = roundMask + 1;\n\n    if ( roundNearestEven && ( roundBits<<1 == roundIncrement ) ) {\n\n        roundMask |= roundIncrement;\n\n    }\n\n    zSig0 &= ~ roundMask;\n\n    if ( zSig0 == 0 ) zExp = 0;\n\n    return packFloatx80( zSign, zExp, zSig0 );\n\n precision80:\n\n    increment = ( (int64_t) zSig1 < 0 );\n\n    if ( ! roundNearestEven ) {\n\n        if ( roundingMode == float_round_to_zero ) {\n\n            increment = 0;\n\n        }\n\n        else {\n\n            if ( zSign ) {\n\n                increment = ( roundingMode == float_round_down ) && zSig1;\n\n            }\n\n            else {\n\n                increment = ( roundingMode == float_round_up ) && zSig1;\n\n            }\n\n        }\n\n    }\n\n    if ( 0x7FFD <= (uint32_t) ( zExp - 1 ) ) {\n\n        if (    ( 0x7FFE < zExp )\n\n             || (    ( zExp == 0x7FFE )\n\n                  && ( zSig0 == LIT64( 0xFFFFFFFFFFFFFFFF ) )\n\n                  && increment\n\n                )\n\n           ) {\n\n            roundMask = 0;\n\n overflow:\n\n            float_raise( float_flag_overflow | float_flag_inexact STATUS_VAR);\n\n            if (    ( roundingMode == float_round_to_zero )\n\n                 || ( zSign && ( roundingMode == float_round_up ) )\n\n                 || ( ! zSign && ( roundingMode == float_round_down ) )\n\n               ) {\n\n                return packFloatx80( zSign, 0x7FFE, ~ roundMask );\n\n            }\n\n            return packFloatx80( zSign, 0x7FFF, LIT64( 0x8000000000000000 ) );\n\n        }\n\n        if ( zExp <= 0 ) {\n\n            isTiny =\n\n                   ( STATUS(float_detect_tininess) == float_tininess_before_rounding )\n\n                || ( zExp < 0 )\n\n                || ! increment\n\n                || ( zSig0 < LIT64( 0xFFFFFFFFFFFFFFFF ) );\n\n            shift64ExtraRightJamming( zSig0, zSig1, 1 - zExp, &zSig0, &zSig1 );\n\n            zExp = 0;\n\n            if ( isTiny && zSig1 ) float_raise( float_flag_underflow STATUS_VAR);\n\n            if ( zSig1 ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n            if ( roundNearestEven ) {\n\n                increment = ( (int64_t) zSig1 < 0 );\n\n            }\n\n            else {\n\n                if ( zSign ) {\n\n                    increment = ( roundingMode == float_round_down ) && zSig1;\n\n                }\n\n                else {\n\n                    increment = ( roundingMode == float_round_up ) && zSig1;\n\n                }\n\n            }\n\n            if ( increment ) {\n\n                ++zSig0;\n\n                zSig0 &=\n\n                    ~ ( ( (uint64_t) ( zSig1<<1 ) == 0 ) & roundNearestEven );\n\n                if ( (int64_t) zSig0 < 0 ) zExp = 1;\n\n            }\n\n            return packFloatx80( zSign, zExp, zSig0 );\n\n        }\n\n    }\n\n    if ( zSig1 ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n    if ( increment ) {\n\n        ++zSig0;\n\n        if ( zSig0 == 0 ) {\n\n            ++zExp;\n\n            zSig0 = LIT64( 0x8000000000000000 );\n\n        }\n\n        else {\n\n            zSig0 &= ~ ( ( (uint64_t) ( zSig1<<1 ) == 0 ) & roundNearestEven );\n\n        }\n\n    }\n\n    else {\n\n        if ( zSig0 == 0 ) zExp = 0;\n\n    }\n\n    return packFloatx80( zSign, zExp, zSig0 );\n\n\n\n}\n", "idx": 25187}
{"project": "qemu", "commit_id": "ba60e727b0a824baa1762264be5ef67dc30a6bac", "target": 1, "func": "static void win_stdio_close(CharDriverState *chr)\n\n{\n\n    WinStdioCharState *stdio = chr->opaque;\n\n\n\n    if (stdio->hInputReadyEvent != INVALID_HANDLE_VALUE) {\n\n        CloseHandle(stdio->hInputReadyEvent);\n\n    }\n\n    if (stdio->hInputDoneEvent != INVALID_HANDLE_VALUE) {\n\n        CloseHandle(stdio->hInputDoneEvent);\n\n    }\n\n    if (stdio->hInputThread != INVALID_HANDLE_VALUE) {\n\n        TerminateThread(stdio->hInputThread, 0);\n\n    }\n\n\n\n    g_free(chr->opaque);\n\n    g_free(chr);\n\n}\n", "idx": 25188}
{"project": "qemu", "commit_id": "5c32be5baf41aec4f4675d2bf24f9948756abf3c", "target": 1, "func": "static void tcg_out_qemu_st(TCGContext *s, TCGReg data, TCGReg addr,\n\n                            TCGMemOpIdx oi)\n\n{\n\n    TCGMemOp memop = get_memop(oi);\n\n#ifdef CONFIG_SOFTMMU\n\n    unsigned memi = get_mmuidx(oi);\n\n    TCGReg addrz, param;\n\n    tcg_insn_unit *func;\n\n    tcg_insn_unit *label_ptr;\n\n\n\n    addrz = tcg_out_tlb_load(s, addr, memi, memop,\n\n                             offsetof(CPUTLBEntry, addr_write));\n\n\n\n    /* The fast path is exactly one insn.  Thus we can perform the entire\n\n       TLB Hit in the (annulled) delay slot of the branch over TLB Miss.  */\n\n    /* beq,a,pt %[xi]cc, label0 */\n\n    label_ptr = s->code_ptr;\n\n    tcg_out_bpcc0(s, COND_E, BPCC_A | BPCC_PT\n\n                  | (TARGET_LONG_BITS == 64 ? BPCC_XCC : BPCC_ICC), 0);\n\n    /* delay slot */\n\n    tcg_out_ldst_rr(s, data, addrz, TCG_REG_O1,\n\n                    qemu_st_opc[memop & (MO_BSWAP | MO_SIZE)]);\n\n\n\n    /* TLB Miss.  */\n\n\n\n    param = TCG_REG_O1;\n\n    if (!SPARC64 && TARGET_LONG_BITS == 64) {\n\n        /* Skip the high-part; we'll perform the extract in the trampoline.  */\n\n        param++;\n\n    }\n\n    tcg_out_mov(s, TCG_TYPE_REG, param++, addr);\n\n    if (!SPARC64 && (memop & MO_SIZE) == MO_64) {\n\n        /* Skip the high-part; we'll perform the extract in the trampoline.  */\n\n        param++;\n\n    }\n\n    tcg_out_mov(s, TCG_TYPE_REG, param++, data);\n\n\n\n    func = qemu_st_trampoline[memop & (MO_BSWAP | MO_SIZE)];\n\n    tcg_debug_assert(func != NULL);\n\n    tcg_out_call_nodelay(s, func);\n\n    /* delay slot */\n\n    tcg_out_movi(s, TCG_TYPE_I32, param, oi);\n\n\n\n    *label_ptr |= INSN_OFF19(tcg_ptr_byte_diff(s->code_ptr, label_ptr));\n\n#else\n\n    if (SPARC64 && TARGET_LONG_BITS == 32) {\n\n        tcg_out_arithi(s, TCG_REG_T1, addr, 0, SHIFT_SRL);\n\n        addr = TCG_REG_T1;\n\n    }\n\n    tcg_out_ldst_rr(s, data, addr,\n\n                    (guest_base ? TCG_GUEST_BASE_REG : TCG_REG_G0),\n\n                    qemu_st_opc[memop & (MO_BSWAP | MO_SIZE)]);\n\n#endif /* CONFIG_SOFTMMU */\n\n}\n", "idx": 25189}
{"project": "qemu", "commit_id": "71ae65e552fc6e03572e430009b98b80b40f1c4d", "target": 1, "func": "static int i2c_slave_post_load(void *opaque, int version_id)\n\n{\n\n    I2CSlave *dev = opaque;\n\n    I2CBus *bus;\n\n    I2CNode *node;\n\n\n\n    bus = I2C_BUS(qdev_get_parent_bus(DEVICE(dev)));\n\n    if ((bus->saved_address == dev->address) || (bus->broadcast)) {\n\n        node = g_malloc(sizeof(struct I2CNode));\n\n        node->elt = dev;\n\n        QLIST_INSERT_HEAD(&bus->current_devs, node, next);\n\n    }\n\n    return 0;\n\n}\n", "idx": 25190}
{"project": "qemu", "commit_id": "490309fcfbed9fa1ed357541f609975016a34628", "target": 1, "func": "int qemu_poll_ns(GPollFD *fds, guint nfds, int64_t timeout)\n\n{\n\n#ifdef CONFIG_PPOLL\n\n    if (timeout < 0) {\n\n        return ppoll((struct pollfd *)fds, nfds, NULL, NULL);\n\n    } else {\n\n        struct timespec ts;\n\n        ts.tv_sec = timeout / 1000000000LL;\n\n        ts.tv_nsec = timeout % 1000000000LL;\n\n        return ppoll((struct pollfd *)fds, nfds, &ts, NULL);\n\n    }\n\n#else\n\n    return g_poll(fds, nfds, qemu_timeout_ns_to_ms(timeout));\n\n#endif\n\n}\n", "idx": 25191}
{"project": "qemu", "commit_id": "d59ce6f34434bf47a9b26138c908650bf9a24be1", "target": 1, "func": "const char *error_get_pretty(Error *err)\n\n{\n\n    return err->msg;\n\n}\n", "idx": 25192}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int qemu_rdma_put_buffer(void *opaque, const uint8_t *buf,\n\n                                int64_t pos, int size)\n\n{\n\n    QEMUFileRDMA *r = opaque;\n\n    QEMUFile *f = r->file;\n\n    RDMAContext *rdma = r->rdma;\n\n    size_t remaining = size;\n\n    uint8_t * data = (void *) buf;\n\n    int ret;\n\n\n\n    CHECK_ERROR_STATE();\n\n\n\n    /*\n\n     * Push out any writes that\n\n     * we're queued up for VM's ram.\n\n     */\n\n    ret = qemu_rdma_write_flush(f, rdma);\n\n    if (ret < 0) {\n\n        rdma->error_state = ret;\n\n        return ret;\n\n    }\n\n\n\n    while (remaining) {\n\n        RDMAControlHeader head;\n\n\n\n        r->len = MIN(remaining, RDMA_SEND_INCREMENT);\n\n        remaining -= r->len;\n\n\n\n        head.len = r->len;\n\n        head.type = RDMA_CONTROL_QEMU_FILE;\n\n\n\n        ret = qemu_rdma_exchange_send(rdma, &head, data, NULL, NULL, NULL);\n\n\n\n        if (ret < 0) {\n\n            rdma->error_state = ret;\n\n            return ret;\n\n        }\n\n\n\n        data += r->len;\n\n    }\n\n\n\n    return size;\n\n}\n", "idx": 25193}
{"project": "qemu", "commit_id": "d6085e3ace20bc9b0fa625d8d79b22668710e217", "target": 0, "func": "static int peer_has_ufo(VirtIONet *n)\n\n{\n\n    if (!peer_has_vnet_hdr(n))\n\n        return 0;\n\n\n\n    n->has_ufo = qemu_peer_has_ufo(qemu_get_queue(n->nic));\n\n\n\n    return n->has_ufo;\n\n}\n", "idx": 25195}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t apb_pci_config_read(void *opaque, target_phys_addr_t addr,\n\n                                    unsigned size)\n\n{\n\n    uint32_t ret;\n\n    APBState *s = opaque;\n\n\n\n    ret = pci_data_read(s->bus, addr, size);\n\n    ret = qemu_bswap_len(ret, size);\n\n    APB_DPRINTF(\"%s: addr \" TARGET_FMT_lx \" -> %x\\n\", __func__, addr, ret);\n\n    return ret;\n\n}\n", "idx": 25196}
{"project": "qemu", "commit_id": "80b7a265362c870f95fb5ca1f7e7a02c0fa0db3e", "target": 0, "func": "void s390_pci_sclp_deconfigure(SCCB *sccb)\n\n{\n\n    PciCfgSccb *psccb = (PciCfgSccb *)sccb;\n\n    S390PCIBusDevice *pbdev = s390_pci_find_dev_by_fid(s390_get_phb(),\n\n                                                       be32_to_cpu(psccb->aid));\n\n    uint16_t rc;\n\n\n\n    if (be16_to_cpu(sccb->h.length) < 16) {\n\n        rc = SCLP_RC_INSUFFICIENT_SCCB_LENGTH;\n\n        goto out;\n\n    }\n\n\n\n    if (!pbdev) {\n\n        DPRINTF(\"sclp deconfig no dev found\\n\");\n\n        rc = SCLP_RC_ADAPTER_ID_NOT_RECOGNIZED;\n\n        goto out;\n\n    }\n\n\n\n    switch (pbdev->state) {\n\n    case ZPCI_FS_RESERVED:\n\n        rc = SCLP_RC_ADAPTER_IN_RESERVED_STATE;\n\n        break;\n\n    case ZPCI_FS_STANDBY:\n\n        rc = SCLP_RC_NO_ACTION_REQUIRED;\n\n        break;\n\n    default:\n\n        if (pbdev->summary_ind) {\n\n            pci_dereg_irqs(pbdev);\n\n        }\n\n        if (pbdev->iommu->enabled) {\n\n            pci_dereg_ioat(pbdev->iommu);\n\n        }\n\n        pbdev->state = ZPCI_FS_STANDBY;\n\n        rc = SCLP_RC_NORMAL_COMPLETION;\n\n\n\n        if (pbdev->release_timer) {\n\n            qdev_unplug(DEVICE(pbdev->pdev), NULL);\n\n        }\n\n    }\n\nout:\n\n    psccb->header.response_code = cpu_to_be16(rc);\n\n}\n", "idx": 25198}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "void cpu_register_physical_memory_offset(target_phys_addr_t start_addr,\n\n                                         ram_addr_t size,\n\n                                         ram_addr_t phys_offset,\n\n                                         ram_addr_t region_offset)\n\n{\n\n    target_phys_addr_t addr, end_addr;\n\n    PhysPageDesc *p;\n\n    CPUState *env;\n\n    ram_addr_t orig_size = size;\n\n    void *subpage;\n\n\n\n#ifdef CONFIG_KQEMU\n\n    /* XXX: should not depend on cpu context */\n\n    env = first_cpu;\n\n    if (env->kqemu_enabled) {\n\n        kqemu_set_phys_mem(start_addr, size, phys_offset);\n\n    }\n\n#endif\n\n    if (kvm_enabled())\n\n        kvm_set_phys_mem(start_addr, size, phys_offset);\n\n\n\n    if (phys_offset == IO_MEM_UNASSIGNED) {\n\n        region_offset = start_addr;\n\n    }\n\n    region_offset &= TARGET_PAGE_MASK;\n\n    size = (size + TARGET_PAGE_SIZE - 1) & TARGET_PAGE_MASK;\n\n    end_addr = start_addr + (target_phys_addr_t)size;\n\n    for(addr = start_addr; addr != end_addr; addr += TARGET_PAGE_SIZE) {\n\n        p = phys_page_find(addr >> TARGET_PAGE_BITS);\n\n        if (p && p->phys_offset != IO_MEM_UNASSIGNED) {\n\n            ram_addr_t orig_memory = p->phys_offset;\n\n            target_phys_addr_t start_addr2, end_addr2;\n\n            int need_subpage = 0;\n\n\n\n            CHECK_SUBPAGE(addr, start_addr, start_addr2, end_addr, end_addr2,\n\n                          need_subpage);\n\n            if (need_subpage || phys_offset & IO_MEM_SUBWIDTH) {\n\n                if (!(orig_memory & IO_MEM_SUBPAGE)) {\n\n                    subpage = subpage_init((addr & TARGET_PAGE_MASK),\n\n                                           &p->phys_offset, orig_memory,\n\n                                           p->region_offset);\n\n                } else {\n\n                    subpage = io_mem_opaque[(orig_memory & ~TARGET_PAGE_MASK)\n\n                                            >> IO_MEM_SHIFT];\n\n                }\n\n                subpage_register(subpage, start_addr2, end_addr2, phys_offset,\n\n                                 region_offset);\n\n                p->region_offset = 0;\n\n            } else {\n\n                p->phys_offset = phys_offset;\n\n                if ((phys_offset & ~TARGET_PAGE_MASK) <= IO_MEM_ROM ||\n\n                    (phys_offset & IO_MEM_ROMD))\n\n                    phys_offset += TARGET_PAGE_SIZE;\n\n            }\n\n        } else {\n\n            p = phys_page_find_alloc(addr >> TARGET_PAGE_BITS, 1);\n\n            p->phys_offset = phys_offset;\n\n            p->region_offset = region_offset;\n\n            if ((phys_offset & ~TARGET_PAGE_MASK) <= IO_MEM_ROM ||\n\n                (phys_offset & IO_MEM_ROMD)) {\n\n                phys_offset += TARGET_PAGE_SIZE;\n\n            } else {\n\n                target_phys_addr_t start_addr2, end_addr2;\n\n                int need_subpage = 0;\n\n\n\n                CHECK_SUBPAGE(addr, start_addr, start_addr2, end_addr,\n\n                              end_addr2, need_subpage);\n\n\n\n                if (need_subpage || phys_offset & IO_MEM_SUBWIDTH) {\n\n                    subpage = subpage_init((addr & TARGET_PAGE_MASK),\n\n                                           &p->phys_offset, IO_MEM_UNASSIGNED,\n\n                                           addr & TARGET_PAGE_MASK);\n\n                    subpage_register(subpage, start_addr2, end_addr2,\n\n                                     phys_offset, region_offset);\n\n                    p->region_offset = 0;\n\n                }\n\n            }\n\n        }\n\n        region_offset += TARGET_PAGE_SIZE;\n\n    }\n\n\n\n    /* since each CPU stores ram addresses in its TLB cache, we must\n\n       reset the modified entries */\n\n    /* XXX: slow ! */\n\n    for(env = first_cpu; env != NULL; env = env->next_cpu) {\n\n        tlb_flush(env, 1);\n\n    }\n\n}\n", "idx": 25199}
{"project": "qemu", "commit_id": "a3adb7ad3bd9c517d569e7e23b249e7f7d616015", "target": 0, "func": "static void help(int exitcode)\n\n{\n\n    const char *options_help =\n\n#define QEMU_OPTIONS_GENERATE_HELP\n\n#include \"qemu-options-wrapper.h\"\n\n        ;\n\n    version();\n\n    printf(\"usage: %s [options] [disk_image]\\n\"\n\n           \"\\n\"\n\n           \"'disk_image' is a raw hard disk image for IDE hard disk 0\\n\"\n\n           \"\\n\"\n\n           \"%s\\n\"\n\n           \"During emulation, the following keys are useful:\\n\"\n\n           \"ctrl-alt-f      toggle full screen\\n\"\n\n           \"ctrl-alt-n      switch to virtual console 'n'\\n\"\n\n           \"ctrl-alt        toggle mouse and keyboard grab\\n\"\n\n           \"\\n\"\n\n           \"When using -nographic, press 'ctrl-a h' to get some help.\\n\",\n\n           error_get_progname(),\n\n           options_help);\n\n    exit(exitcode);\n\n}\n", "idx": 25200}
{"project": "qemu", "commit_id": "dd8070d865ad1b32876931f812a80645f97112ff", "target": 0, "func": "static TileExcp gen_rr_opcode(DisasContext *dc, unsigned opext,\n\n                              unsigned dest, unsigned srca)\n\n{\n\n    TCGv tdest, tsrca;\n\n    const char *mnemonic;\n\n    TCGMemOp memop;\n\n    TileExcp ret = TILEGX_EXCP_NONE;\n\n\n\n    /* Eliminate instructions with no output before doing anything else.  */\n\n    switch (opext) {\n\n    case OE_RR_Y0(NOP):\n\n    case OE_RR_Y1(NOP):\n\n    case OE_RR_X0(NOP):\n\n    case OE_RR_X1(NOP):\n\n        mnemonic = \"nop\";\n\n        goto done0;\n\n    case OE_RR_Y0(FNOP):\n\n    case OE_RR_Y1(FNOP):\n\n    case OE_RR_X0(FNOP):\n\n    case OE_RR_X1(FNOP):\n\n        mnemonic = \"fnop\";\n\n        goto done0;\n\n    case OE_RR_X1(DRAIN):\n\n        mnemonic = \"drain\";\n\n        goto done0;\n\n    case OE_RR_X1(FLUSHWB):\n\n        mnemonic = \"flushwb\";\n\n        goto done0;\n\n    case OE_RR_X1(ILL):\n\n        if (dest == 0x1c && srca == 0x25) {\n\n            mnemonic = \"bpt\";\n\n            goto done2;\n\n        }\n\n        /* Fall through */\n\n    case OE_RR_Y1(ILL):\n\n        mnemonic = \"ill\";\n\n    done2:\n\n        qemu_log_mask(CPU_LOG_TB_IN_ASM, \"%s\", mnemonic);\n\n        return TILEGX_EXCP_OPCODE_UNKNOWN;\n\n    case OE_RR_X1(MF):\n\n        mnemonic = \"mf\";\n\n        goto done0;\n\n    case OE_RR_X1(NAP):\n\n        /* ??? This should yield, especially in system mode.  */\n\n        mnemonic = \"nap\";\n\n        goto done0;\n\n    case OE_RR_X1(SWINT0):\n\n    case OE_RR_X1(SWINT2):\n\n    case OE_RR_X1(SWINT3):\n\n        return TILEGX_EXCP_OPCODE_UNIMPLEMENTED;\n\n    case OE_RR_X1(SWINT1):\n\n        ret = TILEGX_EXCP_SYSCALL;\n\n        mnemonic = \"swint1\";\n\n    done0:\n\n        if (srca || dest) {\n\n            return TILEGX_EXCP_OPCODE_UNIMPLEMENTED;\n\n        }\n\n        qemu_log_mask(CPU_LOG_TB_IN_ASM, \"%s\", mnemonic);\n\n        return ret;\n\n\n\n    case OE_RR_X1(DTLBPR):\n\n        return TILEGX_EXCP_OPCODE_UNIMPLEMENTED;\n\n    case OE_RR_X1(FINV):\n\n        mnemonic = \"finv\";\n\n        goto done1;\n\n    case OE_RR_X1(FLUSH):\n\n        mnemonic = \"flush\";\n\n        goto done1;\n\n    case OE_RR_X1(ICOH):\n\n        mnemonic = \"icoh\";\n\n        goto done1;\n\n    case OE_RR_X1(INV):\n\n        mnemonic = \"inv\";\n\n        goto done1;\n\n    case OE_RR_X1(WH64):\n\n        mnemonic = \"wh64\";\n\n        goto done1;\n\n    case OE_RR_X1(JRP):\n\n    case OE_RR_Y1(JRP):\n\n        mnemonic = \"jrp\";\n\n        goto do_jr;\n\n    case OE_RR_X1(JR):\n\n    case OE_RR_Y1(JR):\n\n        mnemonic = \"jr\";\n\n        goto do_jr;\n\n    case OE_RR_X1(JALRP):\n\n    case OE_RR_Y1(JALRP):\n\n        mnemonic = \"jalrp\";\n\n        goto do_jalr;\n\n    case OE_RR_X1(JALR):\n\n    case OE_RR_Y1(JALR):\n\n        mnemonic = \"jalr\";\n\n    do_jalr:\n\n        tcg_gen_movi_tl(dest_gr(dc, TILEGX_R_LR),\n\n                        dc->pc + TILEGX_BUNDLE_SIZE_IN_BYTES);\n\n    do_jr:\n\n        dc->jmp.cond = TCG_COND_ALWAYS;\n\n        dc->jmp.dest = tcg_temp_new();\n\n        tcg_gen_andi_tl(dc->jmp.dest, load_gr(dc, srca), ~7);\n\n    done1:\n\n        if (dest) {\n\n            return TILEGX_EXCP_OPCODE_UNIMPLEMENTED;\n\n        }\n\n        qemu_log_mask(CPU_LOG_TB_IN_ASM, \"%s %s\", mnemonic, reg_names[srca]);\n\n        return ret;\n\n    }\n\n\n\n    tdest = dest_gr(dc, dest);\n\n    tsrca = load_gr(dc, srca);\n\n\n\n    switch (opext) {\n\n    case OE_RR_X0(CNTLZ):\n\n    case OE_RR_Y0(CNTLZ):\n\n        gen_helper_cntlz(tdest, tsrca);\n\n        mnemonic = \"cntlz\";\n\n        break;\n\n    case OE_RR_X0(CNTTZ):\n\n    case OE_RR_Y0(CNTTZ):\n\n        gen_helper_cnttz(tdest, tsrca);\n\n        mnemonic = \"cnttz\";\n\n        break;\n\n    case OE_RR_X0(FSINGLE_PACK1):\n\n    case OE_RR_Y0(FSINGLE_PACK1):\n\n    case OE_RR_X1(IRET):\n\n        return TILEGX_EXCP_OPCODE_UNIMPLEMENTED;\n\n    case OE_RR_X1(LD1S):\n\n        memop = MO_SB;\n\n        mnemonic = \"ld1s\";\n\n        goto do_load;\n\n    case OE_RR_X1(LD1U):\n\n        memop = MO_UB;\n\n        mnemonic = \"ld1u\";\n\n        goto do_load;\n\n    case OE_RR_X1(LD2S):\n\n        memop = MO_TESW;\n\n        mnemonic = \"ld2s\";\n\n        goto do_load;\n\n    case OE_RR_X1(LD2U):\n\n        memop = MO_TEUW;\n\n        mnemonic = \"ld2u\";\n\n        goto do_load;\n\n    case OE_RR_X1(LD4S):\n\n        memop = MO_TESL;\n\n        mnemonic = \"ld4s\";\n\n        goto do_load;\n\n    case OE_RR_X1(LD4U):\n\n        memop = MO_TEUL;\n\n        mnemonic = \"ld4u\";\n\n        goto do_load;\n\n    case OE_RR_X1(LDNT1S):\n\n        memop = MO_SB;\n\n        mnemonic = \"ldnt1s\";\n\n        goto do_load;\n\n    case OE_RR_X1(LDNT1U):\n\n        memop = MO_UB;\n\n        mnemonic = \"ldnt1u\";\n\n        goto do_load;\n\n    case OE_RR_X1(LDNT2S):\n\n        memop = MO_TESW;\n\n        mnemonic = \"ldnt2s\";\n\n        goto do_load;\n\n    case OE_RR_X1(LDNT2U):\n\n        memop = MO_TEUW;\n\n        mnemonic = \"ldnt2u\";\n\n        goto do_load;\n\n    case OE_RR_X1(LDNT4S):\n\n        memop = MO_TESL;\n\n        mnemonic = \"ldnt4s\";\n\n        goto do_load;\n\n    case OE_RR_X1(LDNT4U):\n\n        memop = MO_TEUL;\n\n        mnemonic = \"ldnt4u\";\n\n        goto do_load;\n\n    case OE_RR_X1(LDNT):\n\n        memop = MO_TEQ;\n\n        mnemonic = \"ldnt\";\n\n        goto do_load;\n\n    case OE_RR_X1(LD):\n\n        memop = MO_TEQ;\n\n        mnemonic = \"ld\";\n\n    do_load:\n\n        tcg_gen_qemu_ld_tl(tdest, tsrca, dc->mmuidx, memop);\n\n        break;\n\n    case OE_RR_X1(LDNA):\n\n        tcg_gen_andi_tl(tdest, tsrca, ~7);\n\n        tcg_gen_qemu_ld_tl(tdest, tdest, dc->mmuidx, MO_TEQ);\n\n        mnemonic = \"ldna\";\n\n        break;\n\n    case OE_RR_X1(LNK):\n\n    case OE_RR_Y1(LNK):\n\n        if (srca) {\n\n            return TILEGX_EXCP_OPCODE_UNIMPLEMENTED;\n\n        }\n\n        tcg_gen_movi_tl(tdest, dc->pc + TILEGX_BUNDLE_SIZE_IN_BYTES);\n\n        mnemonic = \"lnk\";\n\n        break;\n\n    case OE_RR_X0(PCNT):\n\n    case OE_RR_Y0(PCNT):\n\n        gen_helper_pcnt(tdest, tsrca);\n\n        mnemonic = \"pcnt\";\n\n        break;\n\n    case OE_RR_X0(REVBITS):\n\n    case OE_RR_Y0(REVBITS):\n\n        gen_helper_revbits(tdest, tsrca);\n\n        mnemonic = \"revbits\";\n\n        break;\n\n    case OE_RR_X0(REVBYTES):\n\n    case OE_RR_Y0(REVBYTES):\n\n        tcg_gen_bswap64_tl(tdest, tsrca);\n\n        mnemonic = \"revbytes\";\n\n        break;\n\n    case OE_RR_X0(TBLIDXB0):\n\n    case OE_RR_Y0(TBLIDXB0):\n\n        tcg_gen_deposit_tl(tdest, load_gr(dc, dest), tsrca, 2, 8);\n\n        mnemonic = \"tblidxb0\";\n\n        break;\n\n    case OE_RR_X0(TBLIDXB1):\n\n    case OE_RR_Y0(TBLIDXB1):\n\n        tcg_gen_shri_tl(tdest, tsrca, 8);\n\n        tcg_gen_deposit_tl(tdest, load_gr(dc, dest), tdest, 2, 8);\n\n        mnemonic = \"tblidxb1\";\n\n        break;\n\n    case OE_RR_X0(TBLIDXB2):\n\n    case OE_RR_Y0(TBLIDXB2):\n\n        tcg_gen_shri_tl(tdest, tsrca, 16);\n\n        tcg_gen_deposit_tl(tdest, load_gr(dc, dest), tdest, 2, 8);\n\n        mnemonic = \"tblidxb2\";\n\n        break;\n\n    case OE_RR_X0(TBLIDXB3):\n\n    case OE_RR_Y0(TBLIDXB3):\n\n        tcg_gen_shri_tl(tdest, tsrca, 24);\n\n        tcg_gen_deposit_tl(tdest, load_gr(dc, dest), tdest, 2, 8);\n\n        mnemonic = \"tblidxb3\";\n\n        break;\n\n    default:\n\n        return TILEGX_EXCP_OPCODE_UNIMPLEMENTED;\n\n    }\n\n\n\n    qemu_log_mask(CPU_LOG_TB_IN_ASM, \"%s %s, %s\", mnemonic,\n\n                  reg_names[dest], reg_names[srca]);\n\n    return ret;\n\n}\n", "idx": 25201}
{"project": "qemu", "commit_id": "57407ea44cc0a3d630b9b89a2be011f1955ce5c1", "target": 0, "func": "static void etsec_cleanup(NetClientState *nc)\n\n{\n\n    /* qemu_log(\"eTSEC cleanup\\n\"); */\n\n}\n", "idx": 25202}
{"project": "qemu", "commit_id": "3a86a0fa76b5103a122b6e817b3827b2837f4956", "target": 0, "func": "static void qmp_input_push(QmpInputVisitor *qiv, const QObject *obj, Error **errp)\n\n{\n\n    qiv->stack[qiv->nb_stack].obj = obj;\n\n    if (qobject_type(obj) == QTYPE_QLIST) {\n\n        qiv->stack[qiv->nb_stack].entry = qlist_first(qobject_to_qlist(obj));\n\n    }\n\n    qiv->nb_stack++;\n\n\n\n    if (qiv->nb_stack >= QIV_STACK_SIZE) {\n\n        error_set(errp, QERR_BUFFER_OVERRUN);\n\n        return;\n\n    }\n\n}\n", "idx": 25203}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static const IntelHDAReg *intel_hda_reg_find(IntelHDAState *d, target_phys_addr_t addr)\n\n{\n\n    const IntelHDAReg *reg;\n\n\n\n    if (addr >= sizeof(regtab)/sizeof(regtab[0])) {\n\n        goto noreg;\n\n    }\n\n    reg = regtab+addr;\n\n    if (reg->name == NULL) {\n\n        goto noreg;\n\n    }\n\n    return reg;\n\n\n\nnoreg:\n\n    dprint(d, 1, \"unknown register, addr 0x%x\\n\", (int) addr);\n\n    return NULL;\n\n}\n", "idx": 25204}
{"project": "qemu", "commit_id": "d41f3e750d2c06c613cb1b8db7724f0fbc0a2b14", "target": 0, "func": "build_srat(GArray *table_data, BIOSLinker *linker, VirtMachineState *vms)\n\n{\n\n    AcpiSystemResourceAffinityTable *srat;\n\n    AcpiSratProcessorGiccAffinity *core;\n\n    AcpiSratMemoryAffinity *numamem;\n\n    int i, srat_start;\n\n    uint64_t mem_base;\n\n    MachineClass *mc = MACHINE_GET_CLASS(vms);\n\n    const CPUArchIdList *cpu_list = mc->possible_cpu_arch_ids(MACHINE(vms));\n\n\n\n    srat_start = table_data->len;\n\n    srat = acpi_data_push(table_data, sizeof(*srat));\n\n    srat->reserved1 = cpu_to_le32(1);\n\n\n\n    for (i = 0; i < cpu_list->len; ++i) {\n\n        int node_id = cpu_list->cpus[i].props.has_node_id ?\n\n            cpu_list->cpus[i].props.node_id : 0;\n\n        core = acpi_data_push(table_data, sizeof(*core));\n\n        core->type = ACPI_SRAT_PROCESSOR_GICC;\n\n        core->length = sizeof(*core);\n\n        core->proximity = cpu_to_le32(node_id);\n\n        core->acpi_processor_uid = cpu_to_le32(i);\n\n        core->flags = cpu_to_le32(1);\n\n    }\n\n\n\n    mem_base = vms->memmap[VIRT_MEM].base;\n\n    for (i = 0; i < nb_numa_nodes; ++i) {\n\n        numamem = acpi_data_push(table_data, sizeof(*numamem));\n\n        build_srat_memory(numamem, mem_base, numa_info[i].node_mem, i,\n\n                          MEM_AFFINITY_ENABLED);\n\n        mem_base += numa_info[i].node_mem;\n\n    }\n\n\n\n    build_header(linker, table_data, (void *)srat, \"SRAT\",\n\n                 table_data->len - srat_start, 3, NULL, NULL);\n\n}\n", "idx": 25205}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void bdrv_io_limits_disable(BlockDriverState *bs)\n\n{\n\n    bs->io_limits_enabled = false;\n\n\n\n    bdrv_start_throttled_reqs(bs);\n\n\n\n    throttle_destroy(&bs->throttle_state);\n\n}\n", "idx": 25206}
{"project": "qemu", "commit_id": "78c2d8722b9118509e3d4ed8bae67c3e4eaa443e", "target": 0, "func": "void acpi_pcihp_init(AcpiPciHpState *s, PCIBus *root_bus,\n\n                     MemoryRegion *address_space_io, bool bridges_enabled)\n\n{\n\n    uint16_t io_size = ACPI_PCIHP_SIZE;\n\n\n\n    s->root= root_bus;\n\n    s->legacy_piix = !bridges_enabled;\n\n\n\n    if (s->legacy_piix) {\n\n        unsigned *bus_bsel = g_malloc(sizeof *bus_bsel);\n\n\n\n        io_size = ACPI_PCIHP_LEGACY_SIZE;\n\n\n\n        *bus_bsel = ACPI_PCIHP_BSEL_DEFAULT;\n\n        object_property_add_uint32_ptr(OBJECT(root_bus), ACPI_PCIHP_PROP_BSEL,\n\n                                       bus_bsel, NULL);\n\n    }\n\n\n\n    memory_region_init_io(&s->io, NULL, &acpi_pcihp_io_ops, s,\n\n                          \"acpi-pci-hotplug\", io_size);\n\n    memory_region_add_subregion(address_space_io, ACPI_PCIHP_ADDR, &s->io);\n\n}\n", "idx": 25207}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static void omap_lpg_tick(void *opaque)\n\n{\n\n    struct omap_lpg_s *s = opaque;\n\n\n\n    if (s->cycle)\n\n        timer_mod(s->tm, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) + s->period - s->on);\n\n    else\n\n        timer_mod(s->tm, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) + s->on);\n\n\n\n    s->cycle = !s->cycle;\n\n    printf(\"%s: LED is %s\\n\", __FUNCTION__, s->cycle ? \"on\" : \"off\");\n\n}\n", "idx": 25209}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int ohci_service_iso_td(OHCIState *ohci, struct ohci_ed *ed,\n\n                               int completion)\n\n{\n\n    int dir;\n\n    size_t len = 0;\n\n#ifdef DEBUG_ISOCH\n\n    const char *str = NULL;\n\n#endif\n\n    int pid;\n\n    int ret;\n\n    int i;\n\n    USBDevice *dev;\n\n    struct ohci_iso_td iso_td;\n\n    uint32_t addr;\n\n    uint16_t starting_frame;\n\n    int16_t relative_frame_number;\n\n    int frame_count;\n\n    uint32_t start_offset, next_offset, end_offset = 0;\n\n    uint32_t start_addr, end_addr;\n\n\n\n    addr = ed->head & OHCI_DPTR_MASK;\n\n\n\n    if (!ohci_read_iso_td(ohci, addr, &iso_td)) {\n\n        printf(\"usb-ohci: ISO_TD read error at %x\\n\", addr);\n\n        return 0;\n\n    }\n\n\n\n    starting_frame = OHCI_BM(iso_td.flags, TD_SF);\n\n    frame_count = OHCI_BM(iso_td.flags, TD_FC);\n\n    relative_frame_number = USUB(ohci->frame_number, starting_frame); \n\n\n\n#ifdef DEBUG_ISOCH\n\n    printf(\"--- ISO_TD ED head 0x%.8x tailp 0x%.8x\\n\"\n\n           \"0x%.8x 0x%.8x 0x%.8x 0x%.8x\\n\"\n\n           \"0x%.8x 0x%.8x 0x%.8x 0x%.8x\\n\"\n\n           \"0x%.8x 0x%.8x 0x%.8x 0x%.8x\\n\"\n\n           \"frame_number 0x%.8x starting_frame 0x%.8x\\n\"\n\n           \"frame_count  0x%.8x relative %d\\n\"\n\n           \"di 0x%.8x cc 0x%.8x\\n\",\n\n           ed->head & OHCI_DPTR_MASK, ed->tail & OHCI_DPTR_MASK,\n\n           iso_td.flags, iso_td.bp, iso_td.next, iso_td.be,\n\n           iso_td.offset[0], iso_td.offset[1], iso_td.offset[2], iso_td.offset[3],\n\n           iso_td.offset[4], iso_td.offset[5], iso_td.offset[6], iso_td.offset[7],\n\n           ohci->frame_number, starting_frame, \n\n           frame_count, relative_frame_number,         \n\n           OHCI_BM(iso_td.flags, TD_DI), OHCI_BM(iso_td.flags, TD_CC));\n\n#endif\n\n\n\n    if (relative_frame_number < 0) {\n\n        DPRINTF(\"usb-ohci: ISO_TD R=%d < 0\\n\", relative_frame_number);\n\n        return 1;\n\n    } else if (relative_frame_number > frame_count) {\n\n        /* ISO TD expired - retire the TD to the Done Queue and continue with\n\n           the next ISO TD of the same ED */\n\n        DPRINTF(\"usb-ohci: ISO_TD R=%d > FC=%d\\n\", relative_frame_number, \n\n               frame_count);\n\n        OHCI_SET_BM(iso_td.flags, TD_CC, OHCI_CC_DATAOVERRUN);\n\n        ed->head &= ~OHCI_DPTR_MASK;\n\n        ed->head |= (iso_td.next & OHCI_DPTR_MASK);\n\n        iso_td.next = ohci->done;\n\n        ohci->done = addr;\n\n        i = OHCI_BM(iso_td.flags, TD_DI);\n\n        if (i < ohci->done_count)\n\n            ohci->done_count = i;\n\n        ohci_put_iso_td(ohci, addr, &iso_td);\n\n        return 0;\n\n    }\n\n\n\n    dir = OHCI_BM(ed->flags, ED_D);\n\n    switch (dir) {\n\n    case OHCI_TD_DIR_IN:\n\n#ifdef DEBUG_ISOCH\n\n        str = \"in\";\n\n#endif\n\n        pid = USB_TOKEN_IN;\n\n        break;\n\n    case OHCI_TD_DIR_OUT:\n\n#ifdef DEBUG_ISOCH\n\n        str = \"out\";\n\n#endif\n\n        pid = USB_TOKEN_OUT;\n\n        break;\n\n    case OHCI_TD_DIR_SETUP:\n\n#ifdef DEBUG_ISOCH\n\n        str = \"setup\";\n\n#endif\n\n        pid = USB_TOKEN_SETUP;\n\n        break;\n\n    default:\n\n        printf(\"usb-ohci: Bad direction %d\\n\", dir);\n\n        return 1;\n\n    }\n\n\n\n    if (!iso_td.bp || !iso_td.be) {\n\n        printf(\"usb-ohci: ISO_TD bp 0x%.8x be 0x%.8x\\n\", iso_td.bp, iso_td.be);\n\n        return 1;\n\n    }\n\n\n\n    start_offset = iso_td.offset[relative_frame_number];\n\n    next_offset = iso_td.offset[relative_frame_number + 1];\n\n\n\n    if (!(OHCI_BM(start_offset, TD_PSW_CC) & 0xe) || \n\n        ((relative_frame_number < frame_count) && \n\n         !(OHCI_BM(next_offset, TD_PSW_CC) & 0xe))) {\n\n        printf(\"usb-ohci: ISO_TD cc != not accessed 0x%.8x 0x%.8x\\n\",\n\n               start_offset, next_offset);\n\n        return 1;\n\n    }\n\n\n\n    if ((relative_frame_number < frame_count) && (start_offset > next_offset)) {\n\n        printf(\"usb-ohci: ISO_TD start_offset=0x%.8x > next_offset=0x%.8x\\n\",\n\n                start_offset, next_offset);\n\n        return 1;\n\n    }\n\n\n\n    if ((start_offset & 0x1000) == 0) {\n\n        start_addr = (iso_td.bp & OHCI_PAGE_MASK) |\n\n            (start_offset & OHCI_OFFSET_MASK);\n\n    } else {\n\n        start_addr = (iso_td.be & OHCI_PAGE_MASK) |\n\n            (start_offset & OHCI_OFFSET_MASK);\n\n    }\n\n\n\n    if (relative_frame_number < frame_count) {\n\n        end_offset = next_offset - 1;\n\n        if ((end_offset & 0x1000) == 0) {\n\n            end_addr = (iso_td.bp & OHCI_PAGE_MASK) |\n\n                (end_offset & OHCI_OFFSET_MASK);\n\n        } else {\n\n            end_addr = (iso_td.be & OHCI_PAGE_MASK) |\n\n                (end_offset & OHCI_OFFSET_MASK);\n\n        }\n\n    } else {\n\n        /* Last packet in the ISO TD */\n\n        end_addr = iso_td.be;\n\n    }\n\n\n\n    if ((start_addr & OHCI_PAGE_MASK) != (end_addr & OHCI_PAGE_MASK)) {\n\n        len = (end_addr & OHCI_OFFSET_MASK) + 0x1001\n\n            - (start_addr & OHCI_OFFSET_MASK);\n\n    } else {\n\n        len = end_addr - start_addr + 1;\n\n    }\n\n\n\n    if (len && dir != OHCI_TD_DIR_IN) {\n\n        ohci_copy_iso_td(ohci, start_addr, end_addr, ohci->usb_buf, len, 0);\n\n    }\n\n\n\n    if (completion) {\n\n        ret = ohci->usb_packet.result;\n\n    } else {\n\n        usb_packet_setup(&ohci->usb_packet, pid,\n\n                         OHCI_BM(ed->flags, ED_FA),\n\n                         OHCI_BM(ed->flags, ED_EN));\n\n        usb_packet_addbuf(&ohci->usb_packet, ohci->usb_buf, len);\n\n        dev = ohci_find_device(ohci, ohci->usb_packet.devaddr);\n\n        ret = usb_handle_packet(dev, &ohci->usb_packet);\n\n        if (ret == USB_RET_ASYNC) {\n\n            return 1;\n\n        }\n\n    }\n\n\n\n#ifdef DEBUG_ISOCH\n\n    printf(\"so 0x%.8x eo 0x%.8x\\nsa 0x%.8x ea 0x%.8x\\ndir %s len %zu ret %d\\n\",\n\n           start_offset, end_offset, start_addr, end_addr, str, len, ret);\n\n#endif\n\n\n\n    /* Writeback */\n\n    if (dir == OHCI_TD_DIR_IN && ret >= 0 && ret <= len) {\n\n        /* IN transfer succeeded */\n\n        ohci_copy_iso_td(ohci, start_addr, end_addr, ohci->usb_buf, ret, 1);\n\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n\n                    OHCI_CC_NOERROR);\n\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE, ret);\n\n    } else if (dir == OHCI_TD_DIR_OUT && ret == len) {\n\n        /* OUT transfer succeeded */\n\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n\n                    OHCI_CC_NOERROR);\n\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE, 0);\n\n    } else {\n\n        if (ret > (ssize_t) len) {\n\n            printf(\"usb-ohci: DataOverrun %d > %zu\\n\", ret, len);\n\n            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n\n                        OHCI_CC_DATAOVERRUN);\n\n            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n\n                        len);\n\n        } else if (ret >= 0) {\n\n            printf(\"usb-ohci: DataUnderrun %d\\n\", ret);\n\n            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n\n                        OHCI_CC_DATAUNDERRUN);\n\n        } else {\n\n            switch (ret) {\n\n            case USB_RET_NODEV:\n\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n\n                            OHCI_CC_DEVICENOTRESPONDING);\n\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n\n                            0);\n\n                break;\n\n            case USB_RET_NAK:\n\n            case USB_RET_STALL:\n\n                printf(\"usb-ohci: got NAK/STALL %d\\n\", ret);\n\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n\n                            OHCI_CC_STALL);\n\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n\n                            0);\n\n                break;\n\n            default:\n\n                printf(\"usb-ohci: Bad device response %d\\n\", ret);\n\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n\n                            OHCI_CC_UNDEXPETEDPID);\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (relative_frame_number == frame_count) {\n\n        /* Last data packet of ISO TD - retire the TD to the Done Queue */\n\n        OHCI_SET_BM(iso_td.flags, TD_CC, OHCI_CC_NOERROR);\n\n        ed->head &= ~OHCI_DPTR_MASK;\n\n        ed->head |= (iso_td.next & OHCI_DPTR_MASK);\n\n        iso_td.next = ohci->done;\n\n        ohci->done = addr;\n\n        i = OHCI_BM(iso_td.flags, TD_DI);\n\n        if (i < ohci->done_count)\n\n            ohci->done_count = i;\n\n    }\n\n    ohci_put_iso_td(ohci, addr, &iso_td);\n\n    return 1;\n\n}\n", "idx": 25210}
{"project": "qemu", "commit_id": "65c0f1e9558c7c762cdb333406243fff1d687117", "target": 0, "func": "static QObject *parse_literal(JSONParserContext *ctxt, QList **tokens)\n\n{\n\n    QObject *token, *obj;\n\n    QList *working = qlist_copy(*tokens);\n\n\n\n    token = qlist_pop(working);\n\n    if (token == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    switch (token_get_type(token)) {\n\n    case JSON_STRING:\n\n        obj = QOBJECT(qstring_from_escaped_str(ctxt, token));\n\n        break;\n\n    case JSON_INTEGER:\n\n        obj = QOBJECT(qint_from_int(strtoll(token_get_value(token), NULL, 10)));\n\n        break;\n\n    case JSON_FLOAT:\n\n        /* FIXME dependent on locale */\n\n        obj = QOBJECT(qfloat_from_double(strtod(token_get_value(token), NULL)));\n\n        break;\n\n    default:\n\n        goto out;\n\n    }\n\n\n\n    qobject_decref(token);\n\n    QDECREF(*tokens);\n\n    *tokens = working;\n\n\n\n    return obj;\n\n\n\nout:\n\n    qobject_decref(token);\n\n    QDECREF(working);\n\n\n\n    return NULL;\n\n}\n", "idx": 25211}
{"project": "qemu", "commit_id": "e634b89c6ed2309814de7a89bd7c5ced96f59291", "target": 0, "func": "static int spapr_populate_pci_child_dt(PCIDevice *dev, void *fdt, int offset,\n\n                                       int phb_index, int drc_index,\n\n                                       sPAPRPHBState *sphb)\n\n{\n\n    ResourceProps rp;\n\n    bool is_bridge = false;\n\n    int pci_status, err;\n\n    char *buf = NULL;\n\n\n\n    if (pci_default_read_config(dev, PCI_HEADER_TYPE, 1) ==\n\n        PCI_HEADER_TYPE_BRIDGE) {\n\n        is_bridge = true;\n\n    }\n\n\n\n    /* in accordance with PAPR+ v2.7 13.6.3, Table 181 */\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"vendor-id\",\n\n                          pci_default_read_config(dev, PCI_VENDOR_ID, 2)));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"device-id\",\n\n                          pci_default_read_config(dev, PCI_DEVICE_ID, 2)));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"revision-id\",\n\n                          pci_default_read_config(dev, PCI_REVISION_ID, 1)));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"class-code\",\n\n                          pci_default_read_config(dev, PCI_CLASS_PROG, 3)));\n\n    if (pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"interrupts\",\n\n                 pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1)));\n\n    }\n\n\n\n    if (!is_bridge) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"min-grant\",\n\n            pci_default_read_config(dev, PCI_MIN_GNT, 1)));\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"max-latency\",\n\n            pci_default_read_config(dev, PCI_MAX_LAT, 1)));\n\n    }\n\n\n\n    if (pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"subsystem-id\",\n\n                 pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2)));\n\n    }\n\n\n\n    if (pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"subsystem-vendor-id\",\n\n                 pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2)));\n\n    }\n\n\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"cache-line-size\",\n\n        pci_default_read_config(dev, PCI_CACHE_LINE_SIZE, 1)));\n\n\n\n    /* the following fdt cells are masked off the pci status register */\n\n    pci_status = pci_default_read_config(dev, PCI_STATUS, 2);\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"devsel-speed\",\n\n                          PCI_STATUS_DEVSEL_MASK & pci_status));\n\n\n\n    if (pci_status & PCI_STATUS_FAST_BACK) {\n\n        _FDT(fdt_setprop(fdt, offset, \"fast-back-to-back\", NULL, 0));\n\n    }\n\n    if (pci_status & PCI_STATUS_66MHZ) {\n\n        _FDT(fdt_setprop(fdt, offset, \"66mhz-capable\", NULL, 0));\n\n    }\n\n    if (pci_status & PCI_STATUS_UDF) {\n\n        _FDT(fdt_setprop(fdt, offset, \"udf-supported\", NULL, 0));\n\n    }\n\n\n\n    /* NOTE: this is normally generated by firmware via path/unit name,\n\n     * but in our case we must set it manually since it does not get\n\n     * processed by OF beforehand\n\n     */\n\n    _FDT(fdt_setprop_string(fdt, offset, \"name\", \"pci\"));\n\n    buf = spapr_phb_get_loc_code(sphb, dev);\n\n    if (!buf) {\n\n        error_report(\"Failed setting the ibm,loc-code\");\n\n        return -1;\n\n    }\n\n\n\n    err = fdt_setprop_string(fdt, offset, \"ibm,loc-code\", buf);\n\n    g_free(buf);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"ibm,my-drc-index\", drc_index));\n\n\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"#address-cells\",\n\n                          RESOURCE_CELLS_ADDRESS));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"#size-cells\",\n\n                          RESOURCE_CELLS_SIZE));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"ibm,req#msi-x\",\n\n                          RESOURCE_CELLS_SIZE));\n\n\n\n    populate_resource_props(dev, &rp);\n\n    _FDT(fdt_setprop(fdt, offset, \"reg\", (uint8_t *)rp.reg, rp.reg_len));\n\n    _FDT(fdt_setprop(fdt, offset, \"assigned-addresses\",\n\n                     (uint8_t *)rp.assigned, rp.assigned_len));\n\n\n\n    return 0;\n\n}\n", "idx": 25212}
{"project": "qemu", "commit_id": "f34d5c750897abb3853910ce73f63d88d74dc827", "target": 0, "func": "static void usb_host_set_config(USBHostDevice *s, int config, USBPacket *p)\n\n{\n\n    int rc;\n\n\n\n    trace_usb_host_set_config(s->bus_num, s->addr, config);\n\n\n\n    usb_host_release_interfaces(s);\n\n    usb_host_detach_kernel(s);\n\n    rc = libusb_set_configuration(s->dh, config);\n\n    if (rc != 0) {\n\n        usb_host_libusb_error(\"libusb_set_configuration\", rc);\n\n        p->status = USB_RET_STALL;\n\n        if (rc == LIBUSB_ERROR_NO_DEVICE) {\n\n            usb_host_nodev(s);\n\n        }\n\n        return;\n\n    }\n\n    p->status = usb_host_claim_interfaces(s, config);\n\n    if (p->status != USB_RET_SUCCESS) {\n\n        return;\n\n    }\n\n    usb_host_ep_update(s);\n\n}\n", "idx": 25213}
{"project": "qemu", "commit_id": "f293709c6af7a65a9bcec09cdba7a60183657a3e", "target": 1, "func": "static __attribute__((unused)) void map_exec(void *addr, long size)\n\n{\n\n    unsigned long start, end, page_size;\n\n\n\n    page_size = getpagesize();\n\n    start = (unsigned long)addr;\n\n    start &= ~(page_size - 1);\n\n\n\n    end = (unsigned long)addr + size;\n\n    end += page_size - 1;\n\n    end &= ~(page_size - 1);\n\n\n\n    mprotect((void *)start, end - start,\n\n             PROT_READ | PROT_WRITE | PROT_EXEC);\n\n}\n", "idx": 25214}
{"project": "qemu", "commit_id": "1c4c28149fff77b8c983fdabe4e76bdc8cadd572", "target": 1, "func": "static int QEMU_WARN_UNUSED_RESULT update_refcount(BlockDriverState *bs,\n\n    int64_t offset, int64_t length, int addend)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t start, last, cluster_offset;\n\n    int64_t refcount_block_offset = 0;\n\n    int64_t table_index = -1, old_table_index;\n\n    int first_index = -1, last_index = -1;\n\n    int ret;\n\n\n\n#ifdef DEBUG_ALLOC2\n\n    printf(\"update_refcount: offset=%\" PRId64 \" size=%\" PRId64 \" addend=%d\\n\",\n\n           offset, length, addend);\n\n#endif\n\n    if (length < 0) {\n\n        return -EINVAL;\n\n    } else if (length == 0) {\n\n        return 0;\n\n    }\n\n\n\n    start = offset & ~(s->cluster_size - 1);\n\n    last = (offset + length - 1) & ~(s->cluster_size - 1);\n\n    for(cluster_offset = start; cluster_offset <= last;\n\n        cluster_offset += s->cluster_size)\n\n    {\n\n        int block_index, refcount;\n\n        int64_t cluster_index = cluster_offset >> s->cluster_bits;\n\n        int64_t new_block;\n\n\n\n        /* Only write refcount block to disk when we are done with it */\n\n        old_table_index = table_index;\n\n        table_index = cluster_index >> (s->cluster_bits - REFCOUNT_SHIFT);\n\n        if ((old_table_index >= 0) && (table_index != old_table_index)) {\n\n\n\n            ret = write_refcount_block_entries(bs, refcount_block_offset,\n\n                first_index, last_index);\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n\n\n            first_index = -1;\n\n            last_index = -1;\n\n        }\n\n\n\n        /* Load the refcount block and allocate it if needed */\n\n        new_block = alloc_refcount_block(bs, cluster_index);\n\n        if (new_block < 0) {\n\n            ret = new_block;\n\n            goto fail;\n\n        }\n\n        refcount_block_offset = new_block;\n\n\n\n        /* we can update the count and save it */\n\n        block_index = cluster_index &\n\n            ((1 << (s->cluster_bits - REFCOUNT_SHIFT)) - 1);\n\n        if (first_index == -1 || block_index < first_index) {\n\n            first_index = block_index;\n\n        }\n\n        if (block_index > last_index) {\n\n            last_index = block_index;\n\n        }\n\n\n\n        refcount = be16_to_cpu(s->refcount_block_cache[block_index]);\n\n        refcount += addend;\n\n        if (refcount < 0 || refcount > 0xffff) {\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n        if (refcount == 0 && cluster_index < s->free_cluster_index) {\n\n            s->free_cluster_index = cluster_index;\n\n        }\n\n        s->refcount_block_cache[block_index] = cpu_to_be16(refcount);\n\n    }\n\n\n\n    ret = 0;\n\nfail:\n\n\n\n    /* Write last changed block to disk */\n\n    if (refcount_block_offset != 0) {\n\n        int wret;\n\n        wret = write_refcount_block_entries(bs, refcount_block_offset,\n\n            first_index, last_index);\n\n        if (wret < 0) {\n\n            return ret < 0 ? ret : wret;\n\n        }\n\n    }\n\n\n\n    /*\n\n     * Try do undo any updates if an error is returned (This may succeed in\n\n     * some cases like ENOSPC for allocating a new refcount block)\n\n     */\n\n    if (ret < 0) {\n\n        int dummy;\n\n        dummy = update_refcount(bs, offset, cluster_offset - offset, -addend);\n\n    }\n\n\n\n    bdrv_flush(bs->file);\n\n\n\n    return ret;\n\n}\n", "idx": 25215}
{"project": "qemu", "commit_id": "4cad3867b6df2c0826ae508a9fe15dd0b9d8936a", "target": 1, "func": "int fw_cfg_add_i16(FWCfgState *s, uint16_t key, uint16_t value)\n\n{\n\n    uint16_t *copy;\n\n\n\n    copy = g_malloc(sizeof(value));\n\n    *copy = cpu_to_le16(value);\n\n    return fw_cfg_add_bytes(s, key, (uint8_t *)copy, sizeof(value));\n\n}\n", "idx": 25216}
{"project": "qemu", "commit_id": "88ee13c7b656e5504613b527f3a51591e9afae69", "target": 1, "func": "int pcistg_service_call(S390CPU *cpu, uint8_t r1, uint8_t r2)\n\n{\n\n    CPUS390XState *env = &cpu->env;\n\n    uint64_t offset, data;\n\n    S390PCIBusDevice *pbdev;\n\n    MemoryRegion *mr;\n\n    uint8_t len;\n\n    uint32_t fh;\n\n    uint8_t pcias;\n\n\n\n    cpu_synchronize_state(CPU(cpu));\n\n\n\n    if (env->psw.mask & PSW_MASK_PSTATE) {\n\n        program_interrupt(env, PGM_PRIVILEGED, 4);\n\n        return 0;\n\n    }\n\n\n\n    if (r2 & 0x1) {\n\n        program_interrupt(env, PGM_SPECIFICATION, 4);\n\n        return 0;\n\n    }\n\n\n\n    fh = env->regs[r2] >> 32;\n\n    pcias = (env->regs[r2] >> 16) & 0xf;\n\n    len = env->regs[r2] & 0xf;\n\n    offset = env->regs[r2 + 1];\n\n\n\n    pbdev = s390_pci_find_dev_by_fh(fh);\n\n    if (!pbdev) {\n\n        DPRINTF(\"pcistg no pci dev\\n\");\n\n        setcc(cpu, ZPCI_PCI_LS_INVAL_HANDLE);\n\n        return 0;\n\n    }\n\n\n\n    switch (pbdev->state) {\n\n    case ZPCI_FS_RESERVED:\n\n    case ZPCI_FS_STANDBY:\n\n    case ZPCI_FS_DISABLED:\n\n    case ZPCI_FS_PERMANENT_ERROR:\n\n        setcc(cpu, ZPCI_PCI_LS_INVAL_HANDLE);\n\n        return 0;\n\n    case ZPCI_FS_ERROR:\n\n        setcc(cpu, ZPCI_PCI_LS_ERR);\n\n        s390_set_status_code(env, r2, ZPCI_PCI_ST_BLOCKED);\n\n        return 0;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    data = env->regs[r1];\n\n    if (pcias < 6) {\n\n        if ((8 - (offset & 0x7)) < len) {\n\n            program_interrupt(env, PGM_OPERAND, 4);\n\n            return 0;\n\n        }\n\n\n\n        if (trap_msix(pbdev, offset, pcias)) {\n\n            offset = offset - pbdev->msix.table_offset;\n\n            mr = &pbdev->pdev->msix_table_mmio;\n\n            update_msix_table_msg_data(pbdev, offset, &data, len);\n\n        } else {\n\n            mr = pbdev->pdev->io_regions[pcias].memory;\n\n        }\n\n\n\n        memory_region_dispatch_write(mr, offset, data, len,\n\n                                     MEMTXATTRS_UNSPECIFIED);\n\n    } else if (pcias == 15) {\n\n        if ((4 - (offset & 0x3)) < len) {\n\n            program_interrupt(env, PGM_OPERAND, 4);\n\n            return 0;\n\n        }\n\n        switch (len) {\n\n        case 1:\n\n            break;\n\n        case 2:\n\n            data = bswap16(data);\n\n            break;\n\n        case 4:\n\n            data = bswap32(data);\n\n            break;\n\n        case 8:\n\n            data = bswap64(data);\n\n            break;\n\n        default:\n\n            program_interrupt(env, PGM_OPERAND, 4);\n\n            return 0;\n\n        }\n\n\n\n        pci_host_config_write_common(pbdev->pdev, offset,\n\n                                     pci_config_size(pbdev->pdev),\n\n                                     data, len);\n\n    } else {\n\n        DPRINTF(\"pcistg invalid space\\n\");\n\n        setcc(cpu, ZPCI_PCI_LS_ERR);\n\n        s390_set_status_code(env, r2, ZPCI_PCI_ST_INVAL_AS);\n\n        return 0;\n\n    }\n\n\n\n    setcc(cpu, ZPCI_PCI_LS_OK);\n\n    return 0;\n\n}\n", "idx": 25217}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static int coroutine_fn bdrv_co_do_preadv(BlockDriverState *bs,\n\n    int64_t offset, unsigned int bytes, QEMUIOVector *qiov,\n\n    BdrvRequestFlags flags)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    BdrvTrackedRequest req;\n\n\n\n    uint64_t align = bdrv_get_align(bs);\n\n    uint8_t *head_buf = NULL;\n\n    uint8_t *tail_buf = NULL;\n\n    QEMUIOVector local_qiov;\n\n    bool use_local_qiov = false;\n\n    int ret;\n\n\n\n    if (!drv) {\n\n        return -ENOMEDIUM;\n\n    }\n\n\n\n    ret = bdrv_check_byte_request(bs, offset, bytes);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    if (bs->copy_on_read) {\n\n        flags |= BDRV_REQ_COPY_ON_READ;\n\n    }\n\n\n\n    /* throttling disk I/O */\n\n    if (bs->io_limits_enabled) {\n\n        bdrv_io_limits_intercept(bs, bytes, false);\n\n    }\n\n\n\n    /* Align read if necessary by padding qiov */\n\n    if (offset & (align - 1)) {\n\n        head_buf = qemu_blockalign(bs, align);\n\n        qemu_iovec_init(&local_qiov, qiov->niov + 2);\n\n        qemu_iovec_add(&local_qiov, head_buf, offset & (align - 1));\n\n        qemu_iovec_concat(&local_qiov, qiov, 0, qiov->size);\n\n        use_local_qiov = true;\n\n\n\n        bytes += offset & (align - 1);\n\n        offset = offset & ~(align - 1);\n\n    }\n\n\n\n    if ((offset + bytes) & (align - 1)) {\n\n        if (!use_local_qiov) {\n\n            qemu_iovec_init(&local_qiov, qiov->niov + 1);\n\n            qemu_iovec_concat(&local_qiov, qiov, 0, qiov->size);\n\n            use_local_qiov = true;\n\n        }\n\n        tail_buf = qemu_blockalign(bs, align);\n\n        qemu_iovec_add(&local_qiov, tail_buf,\n\n                       align - ((offset + bytes) & (align - 1)));\n\n\n\n        bytes = ROUND_UP(bytes, align);\n\n    }\n\n\n\n    tracked_request_begin(&req, bs, offset, bytes, false);\n\n    ret = bdrv_aligned_preadv(bs, &req, offset, bytes, align,\n\n                              use_local_qiov ? &local_qiov : qiov,\n\n                              flags);\n\n    tracked_request_end(&req);\n\n\n\n    if (use_local_qiov) {\n\n        qemu_iovec_destroy(&local_qiov);\n\n        qemu_vfree(head_buf);\n\n        qemu_vfree(tail_buf);\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 25219}
{"project": "qemu", "commit_id": "6a91cf04a1177f47a18d3c25873513a1ebfc2fcb", "target": 0, "func": "void build_legacy_cpu_hotplug_aml(Aml *ctx, MachineState *machine,\n\n                                  uint16_t io_base)\n\n{\n\n    Aml *dev;\n\n    Aml *crs;\n\n    Aml *pkg;\n\n    Aml *field;\n\n    Aml *method;\n\n    Aml *if_ctx;\n\n    Aml *else_ctx;\n\n    int i, apic_idx;\n\n    Aml *sb_scope = aml_scope(\"_SB\");\n\n    uint8_t madt_tmpl[8] = {0x00, 0x08, 0x00, 0x00, 0x00, 0, 0, 0};\n\n    Aml *cpu_id = aml_arg(1);\n\n    Aml *apic_id = aml_arg(0);\n\n    Aml *cpu_on = aml_local(0);\n\n    Aml *madt = aml_local(1);\n\n    Aml *cpus_map = aml_name(CPU_ON_BITMAP);\n\n    Aml *zero = aml_int(0);\n\n    Aml *one = aml_int(1);\n\n    MachineClass *mc = MACHINE_GET_CLASS(machine);\n\n    CPUArchIdList *apic_ids = mc->possible_cpu_arch_ids(machine);\n\n    PCMachineState *pcms = PC_MACHINE(machine);\n\n\n\n    /*\n\n     * _MAT method - creates an madt apic buffer\n\n     * apic_id = Arg0 = Local APIC ID\n\n     * cpu_id  = Arg1 = Processor ID\n\n     * cpu_on = Local0 = CPON flag for this cpu\n\n     * madt = Local1 = Buffer (in madt apic form) to return\n\n     */\n\n    method = aml_method(CPU_MAT_METHOD, 2, AML_NOTSERIALIZED);\n\n    aml_append(method,\n\n        aml_store(aml_derefof(aml_index(cpus_map, apic_id)), cpu_on));\n\n    aml_append(method,\n\n        aml_store(aml_buffer(sizeof(madt_tmpl), madt_tmpl), madt));\n\n    /* Update the processor id, lapic id, and enable/disable status */\n\n    aml_append(method, aml_store(cpu_id, aml_index(madt, aml_int(2))));\n\n    aml_append(method, aml_store(apic_id, aml_index(madt, aml_int(3))));\n\n    aml_append(method, aml_store(cpu_on, aml_index(madt, aml_int(4))));\n\n    aml_append(method, aml_return(madt));\n\n    aml_append(sb_scope, method);\n\n\n\n    /*\n\n     * _STA method - return ON status of cpu\n\n     * apic_id = Arg0 = Local APIC ID\n\n     * cpu_on = Local0 = CPON flag for this cpu\n\n     */\n\n    method = aml_method(CPU_STATUS_METHOD, 1, AML_NOTSERIALIZED);\n\n    aml_append(method,\n\n        aml_store(aml_derefof(aml_index(cpus_map, apic_id)), cpu_on));\n\n    if_ctx = aml_if(cpu_on);\n\n    {\n\n        aml_append(if_ctx, aml_return(aml_int(0xF)));\n\n    }\n\n    aml_append(method, if_ctx);\n\n    else_ctx = aml_else();\n\n    {\n\n        aml_append(else_ctx, aml_return(zero));\n\n    }\n\n    aml_append(method, else_ctx);\n\n    aml_append(sb_scope, method);\n\n\n\n    method = aml_method(CPU_EJECT_METHOD, 2, AML_NOTSERIALIZED);\n\n    aml_append(method, aml_sleep(200));\n\n    aml_append(sb_scope, method);\n\n\n\n    method = aml_method(CPU_SCAN_METHOD, 0, AML_NOTSERIALIZED);\n\n    {\n\n        Aml *while_ctx, *if_ctx2, *else_ctx2;\n\n        Aml *bus_check_evt = aml_int(1);\n\n        Aml *remove_evt = aml_int(3);\n\n        Aml *status_map = aml_local(5); /* Local5 = active cpu bitmap */\n\n        Aml *byte = aml_local(2); /* Local2 = last read byte from bitmap */\n\n        Aml *idx = aml_local(0); /* Processor ID / APIC ID iterator */\n\n        Aml *is_cpu_on = aml_local(1); /* Local1 = CPON flag for cpu */\n\n        Aml *status = aml_local(3); /* Local3 = active state for cpu */\n\n\n\n        aml_append(method, aml_store(aml_name(CPU_STATUS_MAP), status_map));\n\n        aml_append(method, aml_store(zero, byte));\n\n        aml_append(method, aml_store(zero, idx));\n\n\n\n        /* While (idx < SizeOf(CPON)) */\n\n        while_ctx = aml_while(aml_lless(idx, aml_sizeof(cpus_map)));\n\n        aml_append(while_ctx,\n\n            aml_store(aml_derefof(aml_index(cpus_map, idx)), is_cpu_on));\n\n\n\n        if_ctx = aml_if(aml_and(idx, aml_int(0x07), NULL));\n\n        {\n\n            /* Shift down previously read bitmap byte */\n\n            aml_append(if_ctx, aml_shiftright(byte, one, byte));\n\n        }\n\n        aml_append(while_ctx, if_ctx);\n\n\n\n        else_ctx = aml_else();\n\n        {\n\n            /* Read next byte from cpu bitmap */\n\n            aml_append(else_ctx, aml_store(aml_derefof(aml_index(status_map,\n\n                       aml_shiftright(idx, aml_int(3), NULL))), byte));\n\n        }\n\n        aml_append(while_ctx, else_ctx);\n\n\n\n        aml_append(while_ctx, aml_store(aml_and(byte, one, NULL), status));\n\n        if_ctx = aml_if(aml_lnot(aml_equal(is_cpu_on, status)));\n\n        {\n\n            /* State change - update CPON with new state */\n\n            aml_append(if_ctx, aml_store(status, aml_index(cpus_map, idx)));\n\n            if_ctx2 = aml_if(aml_equal(status, one));\n\n            {\n\n                aml_append(if_ctx2,\n\n                    aml_call2(AML_NOTIFY_METHOD, idx, bus_check_evt));\n\n            }\n\n            aml_append(if_ctx, if_ctx2);\n\n            else_ctx2 = aml_else();\n\n            {\n\n                aml_append(else_ctx2,\n\n                    aml_call2(AML_NOTIFY_METHOD, idx, remove_evt));\n\n            }\n\n        }\n\n        aml_append(if_ctx, else_ctx2);\n\n        aml_append(while_ctx, if_ctx);\n\n\n\n        aml_append(while_ctx, aml_increment(idx)); /* go to next cpu */\n\n        aml_append(method, while_ctx);\n\n    }\n\n    aml_append(sb_scope, method);\n\n\n\n    /* The current AML generator can cover the APIC ID range [0..255],\n\n     * inclusive, for VCPU hotplug. */\n\n    QEMU_BUILD_BUG_ON(ACPI_CPU_HOTPLUG_ID_LIMIT > 256);\n\n    g_assert(pcms->apic_id_limit <= ACPI_CPU_HOTPLUG_ID_LIMIT);\n\n\n\n    /* create PCI0.PRES device and its _CRS to reserve CPU hotplug MMIO */\n\n    dev = aml_device(\"PCI0.\" stringify(CPU_HOTPLUG_RESOURCE_DEVICE));\n\n    aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A06\")));\n\n    aml_append(dev,\n\n        aml_name_decl(\"_UID\", aml_string(\"CPU Hotplug resources\"))\n\n    );\n\n    /* device present, functioning, decoding, not shown in UI */\n\n    aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n    crs = aml_resource_template();\n\n    aml_append(crs,\n\n        aml_io(AML_DECODE16, io_base, io_base, 1, ACPI_GPE_PROC_LEN)\n\n    );\n\n    aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n    aml_append(sb_scope, dev);\n\n    /* declare CPU hotplug MMIO region and PRS field to access it */\n\n    aml_append(sb_scope, aml_operation_region(\n\n        \"PRST\", AML_SYSTEM_IO, aml_int(io_base), ACPI_GPE_PROC_LEN));\n\n    field = aml_field(\"PRST\", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);\n\n    aml_append(field, aml_named_field(\"PRS\", 256));\n\n    aml_append(sb_scope, field);\n\n\n\n    /* build Processor object for each processor */\n\n    for (i = 0; i < apic_ids->len; i++) {\n\n        int apic_id = apic_ids->cpus[i].arch_id;\n\n\n\n        assert(apic_id < ACPI_CPU_HOTPLUG_ID_LIMIT);\n\n\n\n        dev = aml_processor(i, 0, 0, \"CP%.02X\", apic_id);\n\n\n\n        method = aml_method(\"_MAT\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method,\n\n            aml_return(aml_call2(CPU_MAT_METHOD, aml_int(apic_id), aml_int(i))\n\n        ));\n\n        aml_append(dev, method);\n\n\n\n        method = aml_method(\"_STA\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method,\n\n            aml_return(aml_call1(CPU_STATUS_METHOD, aml_int(apic_id))));\n\n        aml_append(dev, method);\n\n\n\n        method = aml_method(\"_EJ0\", 1, AML_NOTSERIALIZED);\n\n        aml_append(method,\n\n            aml_return(aml_call2(CPU_EJECT_METHOD, aml_int(apic_id),\n\n                aml_arg(0)))\n\n        );\n\n        aml_append(dev, method);\n\n\n\n        aml_append(sb_scope, dev);\n\n    }\n\n\n\n    /* build this code:\n\n     *   Method(NTFY, 2) {If (LEqual(Arg0, 0x00)) {Notify(CP00, Arg1)} ...}\n\n     */\n\n    /* Arg0 = APIC ID */\n\n    method = aml_method(AML_NOTIFY_METHOD, 2, AML_NOTSERIALIZED);\n\n    for (i = 0; i < apic_ids->len; i++) {\n\n        int apic_id = apic_ids->cpus[i].arch_id;\n\n\n\n        if_ctx = aml_if(aml_equal(aml_arg(0), aml_int(apic_id)));\n\n        aml_append(if_ctx,\n\n            aml_notify(aml_name(\"CP%.02X\", apic_id), aml_arg(1))\n\n        );\n\n        aml_append(method, if_ctx);\n\n    }\n\n    aml_append(sb_scope, method);\n\n\n\n    /* build \"Name(CPON, Package() { One, One, ..., Zero, Zero, ... })\"\n\n     *\n\n     * Note: The ability to create variable-sized packages was first\n\n     * introduced in ACPI 2.0. ACPI 1.0 only allowed fixed-size packages\n\n     * ith up to 255 elements. Windows guests up to win2k8 fail when\n\n     * VarPackageOp is used.\n\n     */\n\n    pkg = pcms->apic_id_limit <= 255 ? aml_package(pcms->apic_id_limit) :\n\n                                       aml_varpackage(pcms->apic_id_limit);\n\n\n\n    for (i = 0, apic_idx = 0; i < apic_ids->len; i++) {\n\n        int apic_id = apic_ids->cpus[i].arch_id;\n\n\n\n        for (; apic_idx < apic_id; apic_idx++) {\n\n            aml_append(pkg, aml_int(0));\n\n        }\n\n        aml_append(pkg, aml_int(apic_ids->cpus[i].cpu ? 1 : 0));\n\n        apic_idx = apic_id + 1;\n\n    }\n\n    aml_append(sb_scope, aml_name_decl(CPU_ON_BITMAP, pkg));\n\n    g_free(apic_ids);\n\n\n\n    aml_append(ctx, sb_scope);\n\n\n\n    method = aml_method(\"\\\\_GPE._E02\", 0, AML_NOTSERIALIZED);\n\n    aml_append(method, aml_call0(\"\\\\_SB.\" CPU_SCAN_METHOD));\n\n    aml_append(ctx, method);\n\n}\n", "idx": 25220}
{"project": "qemu", "commit_id": "b6fcf32d9b851a83dedcb609091236b97cc4a985", "target": 0, "func": "static void test_dispatch_cmd_io(void)\n\n{\n\n    QDict *req = qdict_new();\n\n    QDict *args = qdict_new();\n\n    QDict *args3 = qdict_new();\n\n    QDict *ud1a = qdict_new();\n\n    QDict *ud1b = qdict_new();\n\n    QDict *ret, *ret_dict, *ret_dict_dict, *ret_dict_dict_userdef;\n\n    QDict *ret_dict_dict2, *ret_dict_dict2_userdef;\n\n    QInt *ret3;\n\n\n\n    qdict_put_obj(ud1a, \"integer\", QOBJECT(qint_from_int(42)));\n\n    qdict_put_obj(ud1a, \"string\", QOBJECT(qstring_from_str(\"hello\")));\n\n    qdict_put_obj(ud1b, \"integer\", QOBJECT(qint_from_int(422)));\n\n    qdict_put_obj(ud1b, \"string\", QOBJECT(qstring_from_str(\"hello2\")));\n\n    qdict_put_obj(args, \"ud1a\", QOBJECT(ud1a));\n\n    qdict_put_obj(args, \"ud1b\", QOBJECT(ud1b));\n\n    qdict_put_obj(req, \"arguments\", QOBJECT(args));\n\n    qdict_put_obj(req, \"execute\", QOBJECT(qstring_from_str(\"user_def_cmd2\")));\n\n\n\n    ret = qobject_to_qdict(test_qmp_dispatch(req));\n\n\n\n    assert(!strcmp(qdict_get_str(ret, \"string\"), \"blah1\"));\n\n    ret_dict = qdict_get_qdict(ret, \"dict\");\n\n    assert(!strcmp(qdict_get_str(ret_dict, \"string\"), \"blah2\"));\n\n    ret_dict_dict = qdict_get_qdict(ret_dict, \"dict\");\n\n    ret_dict_dict_userdef = qdict_get_qdict(ret_dict_dict, \"userdef\");\n\n    assert(qdict_get_int(ret_dict_dict_userdef, \"integer\") == 42);\n\n    assert(!strcmp(qdict_get_str(ret_dict_dict_userdef, \"string\"), \"hello\"));\n\n    assert(!strcmp(qdict_get_str(ret_dict_dict, \"string\"), \"blah3\"));\n\n    ret_dict_dict2 = qdict_get_qdict(ret_dict, \"dict2\");\n\n    ret_dict_dict2_userdef = qdict_get_qdict(ret_dict_dict2, \"userdef\");\n\n    assert(qdict_get_int(ret_dict_dict2_userdef, \"integer\") == 422);\n\n    assert(!strcmp(qdict_get_str(ret_dict_dict2_userdef, \"string\"), \"hello2\"));\n\n    assert(!strcmp(qdict_get_str(ret_dict_dict2, \"string\"), \"blah4\"));\n\n    QDECREF(ret);\n\n\n\n    qdict_put(args3, \"a\", qint_from_int(66));\n\n    qdict_put(req, \"arguments\", args3);\n\n    qdict_put(req, \"execute\", qstring_from_str(\"user_def_cmd3\"));\n\n\n\n    ret3 = qobject_to_qint(test_qmp_dispatch(req));\n\n    assert(qint_get_int(ret3) == 66);\n\n    QDECREF(ret3);\n\n\n\n    QDECREF(req);\n\n}\n", "idx": 25221}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static void coroutine_fn bdrv_flush_co_entry(void *opaque)\n\n{\n\n    RwCo *rwco = opaque;\n\n\n\n    rwco->ret = bdrv_co_flush(rwco->bs);\n\n}\n", "idx": 25222}
{"project": "qemu", "commit_id": "871d2f079661323a7645b388eb5ae8d7eeb3117c", "target": 0, "func": "QEMUFile *qemu_fopen_fd(int fd)\n\n{\n\n    QEMUFileFD *s = qemu_mallocz(sizeof(QEMUFileFD));\n\n\n\n    if (s == NULL)\n\n        return NULL;\n\n\n\n    s->fd = fd;\n\n    s->file = qemu_fopen_ops(s, fd_put_buffer, fd_get_buffer, fd_close, NULL);\n\n    return s->file;\n\n}\n", "idx": 25223}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static inline void t_gen_add_flag(TCGv d, int flag)\n\n{\n\n\tTCGv c;\n\n\n\n\tc = tcg_temp_new(TCG_TYPE_TL);\n\n\tt_gen_mov_TN_preg(c, PR_CCS);\n\n\t/* Propagate carry into d.  */\n\n\ttcg_gen_andi_tl(c, c, 1 << flag);\n\n\tif (flag)\n\n\t\ttcg_gen_shri_tl(c, c, flag);\n\n\ttcg_gen_add_tl(d, d, c);\n\n\ttcg_temp_free(c);\n\n}\n", "idx": 25224}
{"project": "qemu", "commit_id": "c21bbcfa3ff4f6dc49fb01080ef598851aa424dd", "target": 0, "func": "void console_select(unsigned int index)\n\n{\n\n    TextConsole *s;\n\n\n\n    if (index >= MAX_CONSOLES)\n\n        return;\n\n    s = consoles[index];\n\n    if (s) {\n\n        active_console = s;\n\n        if (s->g_width && s->g_height\n\n            && (s->g_width != s->ds->width || s->g_height != s->ds->height))\n\n            dpy_resize(s->ds, s->g_width, s->g_height);\n\n        vga_hw_invalidate();\n\n    }\n\n}\n", "idx": 25225}
{"project": "qemu", "commit_id": "177b75104da3e3a9af84975c32a44782d903c41f", "target": 0, "func": "static void update_max_chunk_size(BDRVDMGState *s, uint32_t chunk,\n\n                                  uint32_t *max_compressed_size,\n\n                                  uint32_t *max_sectors_per_chunk)\n\n{\n\n    uint32_t compressed_size = 0;\n\n    uint32_t uncompressed_sectors = 0;\n\n\n\n    switch (s->types[chunk]) {\n\n    case 0x80000005: /* zlib compressed */\n\n    case 0x80000006: /* bzip2 compressed */\n\n        compressed_size = s->lengths[chunk];\n\n        uncompressed_sectors = s->sectorcounts[chunk];\n\n        break;\n\n    case 1: /* copy */\n\n        uncompressed_sectors = (s->lengths[chunk] + 511) / 512;\n\n        break;\n\n    case 2: /* zero */\n\n        uncompressed_sectors = s->sectorcounts[chunk];\n\n        break;\n\n    }\n\n\n\n    if (compressed_size > *max_compressed_size) {\n\n        *max_compressed_size = compressed_size;\n\n    }\n\n    if (uncompressed_sectors > *max_sectors_per_chunk) {\n\n        *max_sectors_per_chunk = uncompressed_sectors;\n\n    }\n\n}\n", "idx": 25226}
{"project": "qemu", "commit_id": "7d5e199ade76c53ec316ab6779800581bb47c50a", "target": 0, "func": "static void qmp_output_type_int64(Visitor *v, const char *name, int64_t *obj,\n\n                                  Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    qmp_output_add(qov, name, qint_from_int(*obj));\n\n}\n", "idx": 25229}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void qemu_bh_cancel(QEMUBH *bh)\n\n{\n\n    bh->scheduled = 0;\n\n}\n", "idx": 25230}
{"project": "qemu", "commit_id": "897804d6299af372a43110799cbe1d6804d5e1bc", "target": 0, "func": "static int cdrom_probe_device(const char *filename)\n\n{\n\n    int fd, ret;\n\n    int prio = 0;\n\n\n\n    if (strstart(filename, \"/dev/cd\", NULL))\n\n        prio = 50;\n\n\n\n    fd = open(filename, O_RDONLY | O_NONBLOCK);\n\n    if (fd < 0) {\n\n        goto out;\n\n    }\n\n\n\n    /* Attempt to detect via a CDROM specific ioctl */\n\n    ret = ioctl(fd, CDROM_DRIVE_STATUS, CDSL_CURRENT);\n\n    if (ret >= 0)\n\n        prio = 100;\n\n\n\n    close(fd);\n\nout:\n\n    return prio;\n\n}\n", "idx": 25231}
{"project": "qemu", "commit_id": "1ec26c757d5996468afcc0dced4fad04139574b3", "target": 0, "func": "void kvmppc_update_sdr1(target_ulong sdr1)\n\n{\n\n    CPUState *cs;\n\n\n\n    CPU_FOREACH(cs) {\n\n        run_on_cpu(cs, kvmppc_pivot_hpt_cpu, RUN_ON_CPU_TARGET_PTR(sdr1));\n\n    }\n\n}\n", "idx": 25232}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t megasas_mmio_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    MegasasState *s = opaque;\n\n    uint32_t retval = 0;\n\n\n\n    switch (addr) {\n\n    case MFI_IDB:\n\n        retval = 0;\n\n        break;\n\n    case MFI_OMSG0:\n\n    case MFI_OSP0:\n\n        retval = (megasas_use_msix(s) ? MFI_FWSTATE_MSIX_SUPPORTED : 0) |\n\n            (s->fw_state & MFI_FWSTATE_MASK) |\n\n            ((s->fw_sge & 0xff) << 16) |\n\n            (s->fw_cmds & 0xFFFF);\n\n        break;\n\n    case MFI_OSTS:\n\n        if (megasas_intr_enabled(s) && s->doorbell) {\n\n            retval = MFI_1078_RM | 1;\n\n        }\n\n        break;\n\n    case MFI_OMSK:\n\n        retval = s->intr_mask;\n\n        break;\n\n    case MFI_ODCR0:\n\n        retval = s->doorbell;\n\n        break;\n\n    default:\n\n        trace_megasas_mmio_invalid_readl(addr);\n\n        break;\n\n    }\n\n    trace_megasas_mmio_readl(addr, retval);\n\n    return retval;\n\n}\n", "idx": 25233}
{"project": "qemu", "commit_id": "a22313deca720e038ebc5805cf451b3a685d29ce", "target": 0, "func": "static void vfio_start_irqfd_injection(SysBusDevice *sbdev, qemu_irq irq)\n\n{\n\n    VFIOPlatformDevice *vdev = VFIO_PLATFORM_DEVICE(sbdev);\n\n    VFIOINTp *intp;\n\n\n\n    if (!kvm_irqfds_enabled() || !kvm_resamplefds_enabled() ||\n\n        !vdev->irqfd_allowed) {\n\n        goto fail_irqfd;\n\n    }\n\n\n\n    QLIST_FOREACH(intp, &vdev->intp_list, next) {\n\n        if (intp->qemuirq == irq) {\n\n            break;\n\n        }\n\n    }\n\n    assert(intp);\n\n\n\n    if (kvm_irqchip_add_irqfd_notifier(kvm_state, &intp->interrupt,\n\n                                   &intp->unmask, irq) < 0) {\n\n        goto fail_irqfd;\n\n    }\n\n\n\n    if (vfio_set_trigger_eventfd(intp, NULL) < 0) {\n\n        goto fail_vfio;\n\n    }\n\n    if (vfio_set_resample_eventfd(intp) < 0) {\n\n        goto fail_vfio;\n\n    }\n\n\n\n    intp->kvm_accel = true;\n\n\n\n    trace_vfio_platform_start_irqfd_injection(intp->pin,\n\n                                     event_notifier_get_fd(&intp->interrupt),\n\n                                     event_notifier_get_fd(&intp->unmask));\n\n    return;\n\nfail_vfio:\n\n    kvm_irqchip_remove_irqfd_notifier(kvm_state, &intp->interrupt, irq);\n\n    error_report(\"vfio: failed to start eventfd signaling for IRQ %d: %m\",\n\n                 intp->pin);\n\n    abort();\n\nfail_irqfd:\n\n    vfio_start_eventfd_injection(sbdev, irq);\n\n    return;\n\n}\n", "idx": 25234}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static uint64_t pxa2xx_rtc_read(void *opaque, hwaddr addr,\n\n                                unsigned size)\n\n{\n\n    PXA2xxRTCState *s = (PXA2xxRTCState *) opaque;\n\n\n\n    switch (addr) {\n\n    case RTTR:\n\n        return s->rttr;\n\n    case RTSR:\n\n        return s->rtsr;\n\n    case RTAR:\n\n        return s->rtar;\n\n    case RDAR1:\n\n        return s->rdar1;\n\n    case RDAR2:\n\n        return s->rdar2;\n\n    case RYAR1:\n\n        return s->ryar1;\n\n    case RYAR2:\n\n        return s->ryar2;\n\n    case SWAR1:\n\n        return s->swar1;\n\n    case SWAR2:\n\n        return s->swar2;\n\n    case PIAR:\n\n        return s->piar;\n\n    case RCNR:\n\n        return s->last_rcnr +\n\n            ((qemu_clock_get_ms(rtc_clock) - s->last_hz) << 15) /\n\n            (1000 * ((s->rttr & 0xffff) + 1));\n\n    case RDCR:\n\n        return s->last_rdcr +\n\n            ((qemu_clock_get_ms(rtc_clock) - s->last_hz) << 15) /\n\n            (1000 * ((s->rttr & 0xffff) + 1));\n\n    case RYCR:\n\n        return s->last_rycr;\n\n    case SWCR:\n\n        if (s->rtsr & (1 << 12))\n\n            return s->last_swcr +\n\n                (qemu_clock_get_ms(rtc_clock) - s->last_sw) / 10;\n\n        else\n\n            return s->last_swcr;\n\n    default:\n\n        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 25235}
{"project": "qemu", "commit_id": "c363acef772647f66becdbf46dd54e70e67f3cc9", "target": 0, "func": "static void test_visitor_out_union_flat(TestOutputVisitorData *data,\n\n                                        const void *unused)\n\n{\n\n    QObject *arg;\n\n    QDict *qdict;\n\n\n\n    Error *err = NULL;\n\n\n\n    UserDefFlatUnion *tmp = g_malloc0(sizeof(UserDefFlatUnion));\n\n    tmp->enum1 = ENUM_ONE_VALUE1;\n\n    tmp->string = g_strdup(\"str\");\n\n    tmp->value1 = g_malloc0(sizeof(UserDefA));\n\n    /* TODO when generator bug is fixed: tmp->integer = 41; */\n\n    tmp->value1->boolean = true;\n\n\n\n    visit_type_UserDefFlatUnion(data->ov, &tmp, NULL, &err);\n\n    g_assert(err == NULL);\n\n    arg = qmp_output_get_qobject(data->qov);\n\n\n\n    g_assert(qobject_type(arg) == QTYPE_QDICT);\n\n    qdict = qobject_to_qdict(arg);\n\n\n\n    g_assert_cmpstr(qdict_get_str(qdict, \"enum1\"), ==, \"value1\");\n\n    g_assert_cmpstr(qdict_get_str(qdict, \"string\"), ==, \"str\");\n\n    /* TODO g_assert_cmpint(qdict_get_int(qdict, \"integer\"), ==, 41); */\n\n    g_assert_cmpint(qdict_get_bool(qdict, \"boolean\"), ==, true);\n\n\n\n    qapi_free_UserDefFlatUnion(tmp);\n\n    QDECREF(qdict);\n\n}\n", "idx": 25236}
{"project": "qemu", "commit_id": "4d2ffa08b601bdd40d9ccf225480c0a7e90ca078", "target": 0, "func": "static SaveStateEntry *find_se(const char *idstr, int instance_id)\n\n{\n\n    SaveStateEntry *se;\n\n\n\n    QTAILQ_FOREACH(se, &savevm_handlers, entry) {\n\n        if (!strcmp(se->idstr, idstr) &&\n\n            instance_id == se->instance_id)\n\n            return se;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 25237}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_mpuio_write(void *opaque, target_phys_addr_t addr,\n\n                             uint64_t value, unsigned size)\n\n{\n\n    struct omap_mpuio_s *s = (struct omap_mpuio_s *) opaque;\n\n    int offset = addr & OMAP_MPUI_REG_MASK;\n\n    uint16_t diff;\n\n    int ln;\n\n\n\n    if (size != 2) {\n\n        return omap_badwidth_write16(opaque, addr, value);\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x04:\t/* OUTPUT_REG */\n\n        diff = (s->outputs ^ value) & ~s->dir;\n\n        s->outputs = value;\n\n        while ((ln = ffs(diff))) {\n\n            ln --;\n\n            if (s->handler[ln])\n\n                qemu_set_irq(s->handler[ln], (value >> ln) & 1);\n\n            diff &= ~(1 << ln);\n\n        }\n\n        break;\n\n\n\n    case 0x08:\t/* IO_CNTL */\n\n        diff = s->outputs & (s->dir ^ value);\n\n        s->dir = value;\n\n\n\n        value = s->outputs & ~s->dir;\n\n        while ((ln = ffs(diff))) {\n\n            ln --;\n\n            if (s->handler[ln])\n\n                qemu_set_irq(s->handler[ln], (value >> ln) & 1);\n\n            diff &= ~(1 << ln);\n\n        }\n\n        break;\n\n\n\n    case 0x14:\t/* KBC_REG */\n\n        s->cols = value;\n\n        omap_mpuio_kbd_update(s);\n\n        break;\n\n\n\n    case 0x18:\t/* GPIO_EVENT_MODE_REG */\n\n        s->event = value & 0x1f;\n\n        break;\n\n\n\n    case 0x1c:\t/* GPIO_INT_EDGE_REG */\n\n        s->edge = value;\n\n        break;\n\n\n\n    case 0x28:\t/* KBD_MASKIT */\n\n        s->kbd_mask = value & 1;\n\n        omap_mpuio_kbd_update(s);\n\n        break;\n\n\n\n    case 0x2c:\t/* GPIO_MASKIT */\n\n        s->mask = value;\n\n        break;\n\n\n\n    case 0x30:\t/* GPIO_DEBOUNCING_REG */\n\n        s->debounce = value & 0x1ff;\n\n        break;\n\n\n\n    case 0x00:\t/* INPUT_LATCH */\n\n    case 0x10:\t/* KBR_LATCH */\n\n    case 0x20:\t/* KBD_INT */\n\n    case 0x24:\t/* GPIO_INT */\n\n    case 0x34:\t/* GPIO_LATCH_REG */\n\n        OMAP_RO_REG(addr);\n\n        return;\n\n\n\n    default:\n\n        OMAP_BAD_REG(addr);\n\n        return;\n\n    }\n\n}\n", "idx": 25238}
{"project": "qemu", "commit_id": "eabc977973103527bbb8fed69c91cfaa6691f8ab", "target": 1, "func": "static void test_source_notify(void)\n\n{\n\n    while (g_main_context_iteration(NULL, false));\n\n    aio_notify(ctx);\n\n    g_assert(g_main_context_iteration(NULL, true));\n\n    g_assert(!g_main_context_iteration(NULL, false));\n\n}\n", "idx": 25244}
{"project": "qemu", "commit_id": "600f5ce356b44d8fa5a611ff6b034eb95ecf04e7", "target": 1, "func": "static void virtio_crypto_dataq_bh(void *opaque)\n\n{\n\n    VirtIOCryptoQueue *q = opaque;\n\n    VirtIOCrypto *vcrypto = q->vcrypto;\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(vcrypto);\n\n\n\n    /* This happens when device was stopped but BH wasn't. */\n\n    if (!vdev->vm_running) {\n\n        return;\n\n    }\n\n\n\n    /* Just in case the driver is not ready on more */\n\n    if (unlikely(!(vdev->status & VIRTIO_CONFIG_S_DRIVER_OK))) {\n\n        return;\n\n    }\n\n\n\n    virtio_crypto_handle_dataq(vdev, q->dataq);\n\n    virtio_queue_set_notification(q->dataq, 1);\n\n}\n", "idx": 25246}
{"project": "qemu", "commit_id": "2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3", "target": 1, "func": "static void boston_lcd_event(void *opaque, int event)\n\n{\n\n    BostonState *s = opaque;\n\n    if (event == CHR_EVENT_OPENED && !s->lcd_inited) {\n\n        qemu_chr_fe_printf(&s->lcd_display, \"        \");\n\n        s->lcd_inited = true;\n\n    }\n\n}\n", "idx": 25247}
{"project": "qemu", "commit_id": "a554ecb49d0021fd8bb0fd4f2f6be807b3c8b54f", "target": 1, "func": "static int load_dtb(hwaddr addr, const struct arm_boot_info *binfo,\n\n                    hwaddr addr_limit)\n\n{\n\n    void *fdt = NULL;\n\n    int size, rc;\n\n    uint32_t acells, scells;\n\n\n\n    if (binfo->dtb_filename) {\n\n        char *filename;\n\n        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, binfo->dtb_filename);\n\n        if (!filename) {\n\n            fprintf(stderr, \"Couldn't open dtb file %s\\n\", binfo->dtb_filename);\n\n            goto fail;\n\n        }\n\n\n\n        fdt = load_device_tree(filename, &size);\n\n        if (!fdt) {\n\n            fprintf(stderr, \"Couldn't open dtb file %s\\n\", filename);\n\n            g_free(filename);\n\n            goto fail;\n\n        }\n\n        g_free(filename);\n\n    } else if (binfo->get_dtb) {\n\n        fdt = binfo->get_dtb(binfo, &size);\n\n        if (!fdt) {\n\n            fprintf(stderr, \"Board was unable to create a dtb blob\\n\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    if (addr_limit > addr && size > (addr_limit - addr)) {\n\n        /* Installing the device tree blob at addr would exceed addr_limit.\n\n         * Whether this constitutes failure is up to the caller to decide,\n\n         * so just return 0 as size, i.e., no error.\n\n         */\n\n        g_free(fdt);\n\n        return 0;\n\n    }\n\n\n\n    acells = qemu_fdt_getprop_cell(fdt, \"/\", \"#address-cells\");\n\n    scells = qemu_fdt_getprop_cell(fdt, \"/\", \"#size-cells\");\n\n    if (acells == 0 || scells == 0) {\n\n        fprintf(stderr, \"dtb file invalid (#address-cells or #size-cells 0)\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    if (scells < 2 && binfo->ram_size >= (1ULL << 32)) {\n\n        /* This is user error so deserves a friendlier error message\n\n         * than the failure of setprop_sized_cells would provide\n\n         */\n\n        fprintf(stderr, \"qemu: dtb file not compatible with \"\n\n                \"RAM size > 4GB\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    rc = qemu_fdt_setprop_sized_cells(fdt, \"/memory\", \"reg\",\n\n                                      acells, binfo->loader_start,\n\n                                      scells, binfo->ram_size);\n\n    if (rc < 0) {\n\n        fprintf(stderr, \"couldn't set /memory/reg\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    if (binfo->kernel_cmdline && *binfo->kernel_cmdline) {\n\n        rc = qemu_fdt_setprop_string(fdt, \"/chosen\", \"bootargs\",\n\n                                     binfo->kernel_cmdline);\n\n        if (rc < 0) {\n\n            fprintf(stderr, \"couldn't set /chosen/bootargs\\n\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    if (binfo->initrd_size) {\n\n        rc = qemu_fdt_setprop_cell(fdt, \"/chosen\", \"linux,initrd-start\",\n\n                                   binfo->initrd_start);\n\n        if (rc < 0) {\n\n            fprintf(stderr, \"couldn't set /chosen/linux,initrd-start\\n\");\n\n            goto fail;\n\n        }\n\n\n\n        rc = qemu_fdt_setprop_cell(fdt, \"/chosen\", \"linux,initrd-end\",\n\n                                   binfo->initrd_start + binfo->initrd_size);\n\n        if (rc < 0) {\n\n            fprintf(stderr, \"couldn't set /chosen/linux,initrd-end\\n\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    if (binfo->modify_dtb) {\n\n        binfo->modify_dtb(binfo, fdt);\n\n    }\n\n\n\n    qemu_fdt_dumpdtb(fdt, size);\n\n\n\n    /* Put the DTB into the memory map as a ROM image: this will ensure\n\n     * the DTB is copied again upon reset, even if addr points into RAM.\n\n     */\n\n    rom_add_blob_fixed(\"dtb\", fdt, size, addr);\n\n\n\n    g_free(fdt);\n\n\n\n    return size;\n\n\n\nfail:\n\n    g_free(fdt);\n\n    return -1;\n\n}\n", "idx": 25248}
{"project": "qemu", "commit_id": "8db804ac412010fc96397c2d67ee6417eccd9d34", "target": 1, "func": "static NetSocketState *net_socket_fd_init_dgram(NetClientState *peer,\n\n                                                const char *model,\n\n                                                const char *name,\n\n                                                int fd, int is_connected)\n\n{\n\n    struct sockaddr_in saddr;\n\n    int newfd;\n\n    socklen_t saddr_len = sizeof(saddr);\n\n    NetClientState *nc;\n\n    NetSocketState *s;\n\n\n\n    /* fd passed: multicast: \"learn\" dgram_dst address from bound address and save it\n\n     * Because this may be \"shared\" socket from a \"master\" process, datagrams would be recv()\n\n     * by ONLY ONE process: we must \"clone\" this dgram socket --jjo\n\n     */\n\n\n\n    if (is_connected) {\n\n        if (getsockname(fd, (struct sockaddr *) &saddr, &saddr_len) == 0) {\n\n            /* must be bound */\n\n            if (saddr.sin_addr.s_addr == 0) {\n\n                fprintf(stderr, \"qemu: error: init_dgram: fd=%d unbound, \"\n\n                        \"cannot setup multicast dst addr\\n\", fd);\n\n                goto err;\n\n            }\n\n            /* clone dgram socket */\n\n            newfd = net_socket_mcast_create(&saddr, NULL);\n\n            if (newfd < 0) {\n\n                /* error already reported by net_socket_mcast_create() */\n\n                goto err;\n\n            }\n\n            /* clone newfd to fd, close newfd */\n\n            dup2(newfd, fd);\n\n            close(newfd);\n\n\n\n        } else {\n\n            fprintf(stderr,\n\n                    \"qemu: error: init_dgram: fd=%d failed getsockname(): %s\\n\",\n\n                    fd, strerror(errno));\n\n            goto err;\n\n        }\n\n    }\n\n\n\n    nc = qemu_new_net_client(&net_dgram_socket_info, peer, model, name);\n\n\n\n    snprintf(nc->info_str, sizeof(nc->info_str),\n\n            \"socket: fd=%d (%s mcast=%s:%d)\",\n\n            fd, is_connected ? \"cloned\" : \"\",\n\n            inet_ntoa(saddr.sin_addr), ntohs(saddr.sin_port));\n\n\n\n    s = DO_UPCAST(NetSocketState, nc, nc);\n\n\n\n    s->fd = fd;\n\n    s->listen_fd = -1;\n\n    s->send_fn = net_socket_send_dgram;\n\n    net_socket_read_poll(s, true);\n\n\n\n    /* mcast: save bound address as dst */\n\n    if (is_connected) {\n\n        s->dgram_dst = saddr;\n\n    }\n\n\n\n    return s;\n\n\n\nerr:\n\n    closesocket(fd);\n\n    return NULL;\n\n}\n", "idx": 25249}
{"project": "qemu", "commit_id": "ecaf54a052c357e0bacb93c3f178fed34e4821ec", "target": 1, "func": "void hmp_info_memdev(Monitor *mon, const QDict *qdict)\n{\n    Error *err = NULL;\n    MemdevList *memdev_list = qmp_query_memdev(&err);\n    MemdevList *m = memdev_list;\n    StringOutputVisitor *ov;\n    char *str;\n    int i = 0;\n    while (m) {\n        ov = string_output_visitor_new(false);\n        visit_type_uint16List(string_output_get_visitor(ov),\n                              &m->value->host_nodes, NULL, NULL);\n        monitor_printf(mon, \"memory backend: %d\\n\", i);\n        monitor_printf(mon, \"  size:  %\" PRId64 \"\\n\", m->value->size);\n        monitor_printf(mon, \"  merge: %s\\n\",\n                       m->value->merge ? \"true\" : \"false\");\n        monitor_printf(mon, \"  dump: %s\\n\",\n                       m->value->dump ? \"true\" : \"false\");\n        monitor_printf(mon, \"  prealloc: %s\\n\",\n                       m->value->prealloc ? \"true\" : \"false\");\n        monitor_printf(mon, \"  policy: %s\\n\",\n                       HostMemPolicy_lookup[m->value->policy]);\n        str = string_output_get_string(ov);\n        monitor_printf(mon, \"  host nodes: %s\\n\", str);\n        g_free(str);\n        string_output_visitor_cleanup(ov);\n        m = m->next;\n        i++;\n    }\n    monitor_printf(mon, \"\\n\");\n}", "idx": 25251}
{"project": "qemu", "commit_id": "ba7806ad92a2f6b1625cfa67d44dc1b71e3be44e", "target": 1, "func": "void add_command(const cmdinfo_t *ci)\n\n{\n\n    cmdtab = realloc((void *)cmdtab, ++ncmds * sizeof(*cmdtab));\n\n    cmdtab[ncmds - 1] = *ci;\n\n    qsort(cmdtab, ncmds, sizeof(*cmdtab), compare);\n\n}\n", "idx": 25252}
{"project": "qemu", "commit_id": "dc8764f06155a7b3e635e02281b747a9e292127e", "target": 1, "func": "static void guest_suspend(const char *pmutils_bin, const char *sysfile_str,\n\n                          Error **err)\n\n{\n\n    pid_t pid;\n\n    char *pmutils_path;\n\n\n\n    pmutils_path = g_find_program_in_path(pmutils_bin);\n\n\n\n    pid = fork();\n\n    if (pid == 0) {\n\n        /* child */\n\n        int fd;\n\n\n\n        setsid();\n\n        reopen_fd_to_null(0);\n\n        reopen_fd_to_null(1);\n\n        reopen_fd_to_null(2);\n\n\n\n        if (pmutils_path) {\n\n            execle(pmutils_path, pmutils_bin, NULL, environ);\n\n        }\n\n\n\n        /*\n\n         * If we get here either pm-utils is not installed or execle() has\n\n         * failed. Let's try the manual method if the caller wants it.\n\n         */\n\n\n\n        if (!sysfile_str) {\n\n            _exit(EXIT_FAILURE);\n\n        }\n\n\n\n        fd = open(LINUX_SYS_STATE_FILE, O_WRONLY);\n\n        if (fd < 0) {\n\n            _exit(EXIT_FAILURE);\n\n        }\n\n\n\n        if (write(fd, sysfile_str, strlen(sysfile_str)) < 0) {\n\n            _exit(EXIT_FAILURE);\n\n        }\n\n\n\n        _exit(EXIT_SUCCESS);\n\n    }\n\n\n\n    g_free(pmutils_path);\n\n\n\n    if (pid < 0) {\n\n        error_set(err, QERR_UNDEFINED_ERROR);\n\n        return;\n\n    }\n\n}\n", "idx": 25253}
{"project": "qemu", "commit_id": "d6f723b513a0c3c4e58343b7c52a2f9850861fa0", "target": 1, "func": "static void test_qemu_strtoull_max(void)\n\n{\n\n    const char *str = g_strdup_printf(\"%llu\", ULLONG_MAX);\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    uint64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoull(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, ULLONG_MAX);\n\n    g_assert(endptr == str + strlen(str));\n\n}\n", "idx": 25254}
{"project": "qemu", "commit_id": "a308817743be5cc051d3379477f54027deb0befb", "target": 1, "func": "int net_init_tap(const NetClientOptions *opts, const char *name,\n\n                 NetClientState *peer, Error **errp)\n\n{\n\n    /* FIXME error_setg(errp, ...) on failure */\n\n    const NetdevTapOptions *tap;\n\n    int fd, vnet_hdr = 0, i = 0, queues;\n\n    /* for the no-fd, no-helper case */\n\n    const char *script = NULL; /* suppress wrong \"uninit'd use\" gcc warning */\n\n    const char *downscript = NULL;\n\n    Error *err = NULL;\n\n    const char *vhostfdname;\n\n    char ifname[128];\n\n\n\n    assert(opts->kind == NET_CLIENT_OPTIONS_KIND_TAP);\n\n    tap = opts->tap;\n\n    queues = tap->has_queues ? tap->queues : 1;\n\n    vhostfdname = tap->has_vhostfd ? tap->vhostfd : NULL;\n\n\n\n    /* QEMU vlans does not support multiqueue tap, in this case peer is set.\n\n     * For -netdev, peer is always NULL. */\n\n    if (peer && (tap->has_queues || tap->has_fds || tap->has_vhostfds)) {\n\n        error_report(\"Multiqueue tap cannot be used with QEMU vlans\");\n\n        return -1;\n\n    }\n\n\n\n    if (tap->has_fd) {\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||\n\n            tap->has_fds || tap->has_vhostfds) {\n\n            error_report(\"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                         \"helper=, queues=, fds=, and vhostfds= \"\n\n                         \"are invalid with fd=\");\n\n            return -1;\n\n        }\n\n\n\n        fd = monitor_fd_param(cur_mon, tap->fd, &err);\n\n        if (fd == -1) {\n\n            error_report_err(err);\n\n            return -1;\n\n        }\n\n\n\n        fcntl(fd, F_SETFL, O_NONBLOCK);\n\n\n\n        vnet_hdr = tap_probe_vnet_hdr(fd);\n\n\n\n        net_init_tap_one(tap, peer, \"tap\", name, NULL,\n\n                         script, downscript,\n\n                         vhostfdname, vnet_hdr, fd, &err);\n\n        if (err) {\n\n            error_report_err(err);\n\n            return -1;\n\n        }\n\n    } else if (tap->has_fds) {\n\n        char *fds[MAX_TAP_QUEUES];\n\n        char *vhost_fds[MAX_TAP_QUEUES];\n\n        int nfds, nvhosts;\n\n\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||\n\n            tap->has_vhostfd) {\n\n            error_report(\"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                         \"helper=, queues=, and vhostfd= \"\n\n                         \"are invalid with fds=\");\n\n            return -1;\n\n        }\n\n\n\n        nfds = get_fds(tap->fds, fds, MAX_TAP_QUEUES);\n\n        if (tap->has_vhostfds) {\n\n            nvhosts = get_fds(tap->vhostfds, vhost_fds, MAX_TAP_QUEUES);\n\n            if (nfds != nvhosts) {\n\n                error_report(\"The number of fds passed does not match the \"\n\n                             \"number of vhostfds passed\");\n\n                return -1;\n\n            }\n\n        }\n\n\n\n        for (i = 0; i < nfds; i++) {\n\n            fd = monitor_fd_param(cur_mon, fds[i], &err);\n\n            if (fd == -1) {\n\n                error_report_err(err);\n\n                return -1;\n\n            }\n\n\n\n            fcntl(fd, F_SETFL, O_NONBLOCK);\n\n\n\n            if (i == 0) {\n\n                vnet_hdr = tap_probe_vnet_hdr(fd);\n\n            } else if (vnet_hdr != tap_probe_vnet_hdr(fd)) {\n\n                error_report(\"vnet_hdr not consistent across given tap fds\");\n\n                return -1;\n\n            }\n\n\n\n            net_init_tap_one(tap, peer, \"tap\", name, ifname,\n\n                             script, downscript,\n\n                             tap->has_vhostfds ? vhost_fds[i] : NULL,\n\n                             vnet_hdr, fd, &err);\n\n            if (err) {\n\n                error_report_err(err);\n\n                return -1;\n\n            }\n\n        }\n\n    } else if (tap->has_helper) {\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_queues || tap->has_vhostfds) {\n\n            error_report(\"ifname=, script=, downscript=, and vnet_hdr= \"\n\n                         \"queues=, and vhostfds= are invalid with helper=\");\n\n            return -1;\n\n        }\n\n\n\n        fd = net_bridge_run_helper(tap->helper, DEFAULT_BRIDGE_INTERFACE,\n\n                                   errp);\n\n        if (fd == -1) {\n\n            return -1;\n\n        }\n\n\n\n        fcntl(fd, F_SETFL, O_NONBLOCK);\n\n        vnet_hdr = tap_probe_vnet_hdr(fd);\n\n\n\n        net_init_tap_one(tap, peer, \"bridge\", name, ifname,\n\n                         script, downscript, vhostfdname,\n\n                         vnet_hdr, fd, &err);\n\n        if (err) {\n\n            error_report_err(err);\n\n            close(fd);\n\n            return -1;\n\n        }\n\n    } else {\n\n        if (tap->has_vhostfds) {\n\n            error_report(\"vhostfds= is invalid if fds= wasn't specified\");\n\n            return -1;\n\n        }\n\n        script = tap->has_script ? tap->script : DEFAULT_NETWORK_SCRIPT;\n\n        downscript = tap->has_downscript ? tap->downscript :\n\n            DEFAULT_NETWORK_DOWN_SCRIPT;\n\n\n\n        if (tap->has_ifname) {\n\n            pstrcpy(ifname, sizeof ifname, tap->ifname);\n\n        } else {\n\n            ifname[0] = '\\0';\n\n        }\n\n\n\n        for (i = 0; i < queues; i++) {\n\n            fd = net_tap_init(tap, &vnet_hdr, i >= 1 ? \"no\" : script,\n\n                              ifname, sizeof ifname, queues > 1, &err);\n\n            if (fd == -1) {\n\n                error_report_err(err);\n\n                return -1;\n\n            }\n\n\n\n            if (queues > 1 && i == 0 && !tap->has_ifname) {\n\n                if (tap_fd_get_ifname(fd, ifname)) {\n\n                    error_report(\"Fail to get ifname\");\n\n                    close(fd);\n\n                    return -1;\n\n                }\n\n            }\n\n\n\n            net_init_tap_one(tap, peer, \"tap\", name, ifname,\n\n                             i >= 1 ? \"no\" : script,\n\n                             i >= 1 ? \"no\" : downscript,\n\n                             vhostfdname, vnet_hdr, fd, &err);\n\n            if (err) {\n\n                error_report_err(err);\n\n                close(fd);\n\n                return -1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 25256}
{"project": "qemu", "commit_id": "f6e6652d7c9251236fc1ecc6cece36104c7af15b", "target": 1, "func": "static int dmg_read_resource_fork(BlockDriverState *bs, DmgHeaderState *ds,\n\n                                  uint64_t info_begin, uint64_t info_length)\n\n{\n\n    BDRVDMGState *s = bs->opaque;\n\n    int ret;\n\n    uint32_t count, rsrc_data_offset;\n\n    uint8_t *buffer = NULL;\n\n    uint64_t info_end;\n\n    uint64_t offset;\n\n\n\n    /* read offset from begin of resource fork (info_begin) to resource data */\n\n    ret = read_uint32(bs, info_begin, &rsrc_data_offset);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    } else if (rsrc_data_offset > info_length) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    /* read length of resource data */\n\n    ret = read_uint32(bs, info_begin + 8, &count);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    } else if (count == 0 || rsrc_data_offset + count > info_length) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    /* begin of resource data (consisting of one or more resources) */\n\n    offset = info_begin + rsrc_data_offset;\n\n\n\n    /* end of resource data (there is possibly a following resource map\n\n     * which will be ignored). */\n\n    info_end = offset + count;\n\n\n\n    /* read offsets (mish blocks) from one or more resources in resource data */\n\n    while (offset < info_end) {\n\n        /* size of following resource */\n\n        ret = read_uint32(bs, offset, &count);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        } else if (count == 0) {\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n        offset += 4;\n\n\n\n        buffer = g_realloc(buffer, count);\n\n        ret = bdrv_pread(bs->file, offset, buffer, count);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        ret = dmg_read_mish_block(s, ds, buffer, count);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        /* advance offset by size of resource */\n\n        offset += count;\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    g_free(buffer);\n\n    return ret;\n\n}\n", "idx": 25257}
{"project": "qemu", "commit_id": "dd98b71f4885814de9a64e7acc0e17b38ab7c38b", "target": 1, "func": "static int qdev_add_one_global(QemuOpts *opts, void *opaque)\n\n{\n\n    GlobalProperty *g;\n\n    ObjectClass *oc;\n\n\n\n    g = g_malloc0(sizeof(*g));\n\n    g->driver   = qemu_opt_get(opts, \"driver\");\n\n    g->property = qemu_opt_get(opts, \"property\");\n\n    g->value    = qemu_opt_get(opts, \"value\");\n\n    oc = object_class_by_name(g->driver);\n\n    if (oc) {\n\n        DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n        if (dc->hotpluggable) {\n\n            /* If hotpluggable then skip not_used checking. */\n\n            g->not_used = false;\n\n        } else {\n\n            /* Maybe a typo. */\n\n            g->not_used = true;\n\n        }\n\n    } else {\n\n        /* Maybe a typo. */\n\n        g->not_used = true;\n\n    }\n\n    qdev_prop_register_global(g);\n\n    return 0;\n\n}\n", "idx": 25259}
{"project": "qemu", "commit_id": "af7e9e74c6a62a5bcd911726a9e88d28b61490e0", "target": 1, "func": "static void openpic_update_irq(OpenPICState *opp, int n_IRQ)\n\n{\n\n    IRQ_src_t *src;\n\n    int i;\n\n\n\n    src = &opp->src[n_IRQ];\n\n\n\n    if (!src->pending) {\n\n        /* no irq pending */\n\n        DPRINTF(\"%s: IRQ %d is not pending\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (src->ipvp & IPVP_MASK_MASK) {\n\n        /* Interrupt source is disabled */\n\n        DPRINTF(\"%s: IRQ %d is disabled\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (IPVP_PRIORITY(src->ipvp) == 0) {\n\n        /* Priority set to zero */\n\n        DPRINTF(\"%s: IRQ %d has 0 priority\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (src->ipvp & IPVP_ACTIVITY_MASK) {\n\n        /* IRQ already active */\n\n        DPRINTF(\"%s: IRQ %d is already active\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (src->ide == 0) {\n\n        /* No target */\n\n        DPRINTF(\"%s: IRQ %d has no target\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n\n\n    if (src->ide == (1 << src->last_cpu)) {\n\n        /* Only one CPU is allowed to receive this IRQ */\n\n        IRQ_local_pipe(opp, src->last_cpu, n_IRQ);\n\n    } else if (!(src->ipvp & IPVP_MODE_MASK)) {\n\n        /* Directed delivery mode */\n\n        for (i = 0; i < opp->nb_cpus; i++) {\n\n            if (src->ide & (1 << i)) {\n\n                IRQ_local_pipe(opp, i, n_IRQ);\n\n            }\n\n        }\n\n    } else {\n\n        /* Distributed delivery mode */\n\n        for (i = src->last_cpu + 1; i != src->last_cpu; i++) {\n\n            if (i == opp->nb_cpus)\n\n                i = 0;\n\n            if (src->ide & (1 << i)) {\n\n                IRQ_local_pipe(opp, i, n_IRQ);\n\n                src->last_cpu = i;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 25260}
{"project": "qemu", "commit_id": "91d670fbf9945ca4ecbd123affb36889e7fe8a5d", "target": 1, "func": "void virtio_scsi_common_realize(DeviceState *dev, Error **errp)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n    VirtIOSCSICommon *s = VIRTIO_SCSI_COMMON(dev);\n\n    int i;\n\n\n\n    virtio_init(vdev, \"virtio-scsi\", VIRTIO_ID_SCSI,\n\n                sizeof(VirtIOSCSIConfig));\n\n\n\n    s->cmd_vqs = g_malloc0(s->conf.num_queues * sizeof(VirtQueue *));\n\n    s->sense_size = VIRTIO_SCSI_SENSE_SIZE;\n\n    s->cdb_size = VIRTIO_SCSI_CDB_SIZE;\n\n\n\n    s->ctrl_vq = virtio_add_queue(vdev, VIRTIO_SCSI_VQ_SIZE,\n\n                                  virtio_scsi_handle_ctrl);\n\n    s->event_vq = virtio_add_queue(vdev, VIRTIO_SCSI_VQ_SIZE,\n\n                                   virtio_scsi_handle_event);\n\n    for (i = 0; i < s->conf.num_queues; i++) {\n\n        s->cmd_vqs[i] = virtio_add_queue(vdev, VIRTIO_SCSI_VQ_SIZE,\n\n                                         virtio_scsi_handle_cmd);\n\n    }\n\n}\n", "idx": 25262}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static inline void usb_bt_fifo_out_enqueue(struct USBBtState *s,\n\n                struct usb_hci_out_fifo_s *fifo,\n\n                void (*send)(struct HCIInfo *, const uint8_t *, int),\n\n                int (*complete)(const uint8_t *, int),\n\n                const uint8_t *data, int len)\n\n{\n\n    if (fifo->len) {\n\n        memcpy(fifo->data + fifo->len, data, len);\n\n        fifo->len += len;\n\n        if (complete(fifo->data, fifo->len)) {\n\n            send(s->hci, fifo->data, fifo->len);\n\n            fifo->len = 0;\n\n        }\n\n    } else if (complete(data, len))\n\n        send(s->hci, data, len);\n\n    else {\n\n        memcpy(fifo->data, data, len);\n\n        fifo->len = len;\n\n    }\n\n\n\n    /* TODO: do we need to loop? */\n\n}\n", "idx": 25263}
{"project": "qemu", "commit_id": "2d528d45ecf5ee3c1a566a9f3d664464925ef830", "target": 1, "func": "static CharDriverState *qemu_chr_open_udp_fd(int fd)\n\n{\n\n    CharDriverState *chr = NULL;\n\n    NetCharDriver *s = NULL;\n\n\n\n    chr = qemu_chr_alloc();\n\n    s = g_malloc0(sizeof(NetCharDriver));\n\n\n\n    s->fd = fd;\n\n    s->chan = io_channel_from_socket(s->fd);\n\n    s->bufcnt = 0;\n\n    s->bufptr = 0;\n\n    chr->opaque = s;\n\n    chr->chr_write = udp_chr_write;\n\n    chr->chr_update_read_handler = udp_chr_update_read_handler;\n\n    chr->chr_close = udp_chr_close;\n\n    /* be isn't opened until we get a connection */\n\n    chr->explicit_be_open = true;\n\n    return chr;\n\n}\n", "idx": 25264}
{"project": "qemu", "commit_id": "e78815a554adaa551d62a71be10ee2fcf128e473", "target": 1, "func": "static void balloon_page(void *addr, int deflate)\n\n{\n\n#if defined(__linux__)\n\n    if (!kvm_enabled() || kvm_has_sync_mmu())\n\n        madvise(addr, TARGET_PAGE_SIZE,\n\n                deflate ? MADV_WILLNEED : MADV_DONTNEED);\n\n#endif\n\n}\n", "idx": 25268}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void test_self(void)\n\n{\n\n    Coroutine *coroutine;\n\n\n\n    coroutine = qemu_coroutine_create(verify_self);\n\n    qemu_coroutine_enter(coroutine, &coroutine);\n\n}\n", "idx": 25269}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_wrteei(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    if (ctx->opcode & 0x00008000) {\n\n        tcg_gen_ori_tl(cpu_msr, cpu_msr, (1 << MSR_EE));\n\n        /* Stop translation to have a chance to raise an exception */\n\n        gen_stop_exception(ctx);\n\n    } else {\n\n        tcg_gen_andi_tl(cpu_msr, cpu_msr, ~(1 << MSR_EE));\n\n    }\n\n#endif\n\n}\n", "idx": 25270}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_put_be16(QEMUFile *f, unsigned int v)\n\n{\n\n    qemu_put_byte(f, v >> 8);\n\n    qemu_put_byte(f, v);\n\n}\n", "idx": 25272}
{"project": "qemu", "commit_id": "35ecde26018207fe723bec6efbd340db6e9c2d53", "target": 1, "func": "static void test_cancel(void)\n\n{\n\n    WorkerTestData data[100];\n\n    int num_canceled;\n\n    int i;\n\n\n\n    /* Start more work items than there will be threads, to ensure\n\n     * the pool is full.\n\n     */\n\n    test_submit_many();\n\n\n\n    /* Start long running jobs, to ensure we can cancel some.  */\n\n    for (i = 0; i < 100; i++) {\n\n        data[i].n = 0;\n\n        data[i].ret = -EINPROGRESS;\n\n        data[i].aiocb = thread_pool_submit_aio(pool, long_cb, &data[i],\n\n                                               done_cb, &data[i]);\n\n    }\n\n\n\n    /* Starting the threads may be left to a bottom half.  Let it\n\n     * run, but do not waste too much time...\n\n     */\n\n    active = 100;\n\n    aio_notify(ctx);\n\n    aio_poll(ctx, false);\n\n\n\n    /* Wait some time for the threads to start, with some sanity\n\n     * testing on the behavior of the scheduler...\n\n     */\n\n    g_assert_cmpint(active, ==, 100);\n\n    g_usleep(1000000);\n\n    g_assert_cmpint(active, >, 50);\n\n\n\n    /* Cancel the jobs that haven't been started yet.  */\n\n    num_canceled = 0;\n\n    for (i = 0; i < 100; i++) {\n\n        if (atomic_cmpxchg(&data[i].n, 0, 3) == 0) {\n\n            data[i].ret = -ECANCELED;\n\n            bdrv_aio_cancel(data[i].aiocb);\n\n            active--;\n\n            num_canceled++;\n\n        }\n\n    }\n\n    g_assert_cmpint(active, >, 0);\n\n    g_assert_cmpint(num_canceled, <, 100);\n\n\n\n    /* Canceling the others will be a blocking operation.  */\n\n    for (i = 0; i < 100; i++) {\n\n        if (data[i].n != 3) {\n\n            bdrv_aio_cancel(data[i].aiocb);\n\n        }\n\n    }\n\n\n\n    /* Finish execution and execute any remaining callbacks.  */\n\n    qemu_aio_wait_all();\n\n    g_assert_cmpint(active, ==, 0);\n\n    for (i = 0; i < 100; i++) {\n\n        if (data[i].n == 3) {\n\n            g_assert_cmpint(data[i].ret, ==, -ECANCELED);\n\n            g_assert(data[i].aiocb != NULL);\n\n        } else {\n\n            g_assert_cmpint(data[i].n, ==, 2);\n\n            g_assert_cmpint(data[i].ret, ==, 0);\n\n            g_assert(data[i].aiocb == NULL);\n\n        }\n\n    }\n\n}\n", "idx": 25273}
{"project": "qemu", "commit_id": "c5a49c63fa26e8825ad101dfe86339ae4c216539", "target": 1, "func": "static void spr_write_tbl(DisasContext *ctx, int sprn, int gprn)\n\n{\n\n    if (ctx->tb->cflags & CF_USE_ICOUNT) {\n\n        gen_io_start();\n\n    }\n\n    gen_helper_store_tbl(cpu_env, cpu_gpr[gprn]);\n\n    if (ctx->tb->cflags & CF_USE_ICOUNT) {\n\n        gen_io_end();\n\n        gen_stop_exception(ctx);\n\n    }\n\n}\n", "idx": 25274}
{"project": "qemu", "commit_id": "6d759117d3fd28e38c49c56c9de206cc718d32fa", "target": 1, "func": "static void coroutine_fn commit_run(void *opaque)\n\n{\n\n    CommitBlockJob *s = opaque;\n\n    BlockDriverState *active = s->active;\n\n    BlockDriverState *top = s->top;\n\n    BlockDriverState *base = s->base;\n\n    BlockDriverState *overlay_bs = NULL;\n\n    int64_t sector_num, end;\n\n    int ret = 0;\n\n    int n = 0;\n\n    void *buf;\n\n    int bytes_written = 0;\n\n    int64_t base_len;\n\n\n\n    ret = s->common.len = bdrv_getlength(top);\n\n\n\n\n\n    if (s->common.len < 0) {\n\n        goto exit_restore_reopen;\n\n    }\n\n\n\n    ret = base_len = bdrv_getlength(base);\n\n    if (base_len < 0) {\n\n        goto exit_restore_reopen;\n\n    }\n\n\n\n    if (base_len < s->common.len) {\n\n        ret = bdrv_truncate(base, s->common.len);\n\n        if (ret) {\n\n            goto exit_restore_reopen;\n\n        }\n\n    }\n\n\n\n    overlay_bs = bdrv_find_overlay(active, top);\n\n\n\n    end = s->common.len >> BDRV_SECTOR_BITS;\n\n    buf = qemu_blockalign(top, COMMIT_BUFFER_SIZE);\n\n\n\n    for (sector_num = 0; sector_num < end; sector_num += n) {\n\n        uint64_t delay_ns = 0;\n\n        bool copy;\n\n\n\nwait:\n\n        /* Note that even when no rate limit is applied we need to yield\n\n         * with no pending I/O here so that bdrv_drain_all() returns.\n\n         */\n\n        block_job_sleep_ns(&s->common, rt_clock, delay_ns);\n\n        if (block_job_is_cancelled(&s->common)) {\n\n            break;\n\n        }\n\n        /* Copy if allocated above the base */\n\n        ret = bdrv_co_is_allocated_above(top, base, sector_num,\n\n                                         COMMIT_BUFFER_SIZE / BDRV_SECTOR_SIZE,\n\n                                         &n);\n\n        copy = (ret == 1);\n\n        trace_commit_one_iteration(s, sector_num, n, ret);\n\n        if (copy) {\n\n            if (s->common.speed) {\n\n                delay_ns = ratelimit_calculate_delay(&s->limit, n);\n\n                if (delay_ns > 0) {\n\n                    goto wait;\n\n                }\n\n            }\n\n            ret = commit_populate(top, base, sector_num, n, buf);\n\n            bytes_written += n * BDRV_SECTOR_SIZE;\n\n        }\n\n        if (ret < 0) {\n\n            if (s->on_error == BLOCKDEV_ON_ERROR_STOP ||\n\n                s->on_error == BLOCKDEV_ON_ERROR_REPORT||\n\n                (s->on_error == BLOCKDEV_ON_ERROR_ENOSPC && ret == -ENOSPC)) {\n\n                goto exit_free_buf;\n\n            } else {\n\n                n = 0;\n\n                continue;\n\n            }\n\n        }\n\n        /* Publish progress */\n\n        s->common.offset += n * BDRV_SECTOR_SIZE;\n\n    }\n\n\n\n    ret = 0;\n\n\n\n    if (!block_job_is_cancelled(&s->common) && sector_num == end) {\n\n        /* success */\n\n        ret = bdrv_drop_intermediate(active, top, base);\n\n    }\n\n\n\nexit_free_buf:\n\n    qemu_vfree(buf);\n\n\n\nexit_restore_reopen:\n\n    /* restore base open flags here if appropriate (e.g., change the base back\n\n     * to r/o). These reopens do not need to be atomic, since we won't abort\n\n     * even on failure here */\n\n    if (s->base_flags != bdrv_get_flags(base)) {\n\n        bdrv_reopen(base, s->base_flags, NULL);\n\n    }\n\n    if (s->orig_overlay_flags != bdrv_get_flags(overlay_bs)) {\n\n        bdrv_reopen(overlay_bs, s->orig_overlay_flags, NULL);\n\n    }\n\n\n\n    block_job_completed(&s->common, ret);\n\n}\n", "idx": 25275}
{"project": "qemu", "commit_id": "155eb9aa09249874b4ff49e94c58595ad82d3abb", "target": 1, "func": "static inline long double compute_read_bwidth(void)\n\n{\n\n    assert(block_mig_state.total_time != 0);\n\n    return  (block_mig_state.reads * BLOCK_SIZE)/ block_mig_state.total_time;\n\n}\n", "idx": 25276}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "size_t v9fs_unmarshal(struct iovec *out_sg, int out_num, size_t offset,\n\n                      int bswap, const char *fmt, ...)\n\n{\n\n    int i;\n\n    va_list ap;\n\n    size_t old_offset = offset;\n\n\n\n    va_start(ap, fmt);\n\n    for (i = 0; fmt[i]; i++) {\n\n        switch (fmt[i]) {\n\n        case 'b': {\n\n            uint8_t *valp = va_arg(ap, uint8_t *);\n\n            offset += v9fs_unpack(valp, out_sg, out_num, offset, sizeof(*valp));\n\n            break;\n\n        }\n\n        case 'w': {\n\n            uint16_t val, *valp;\n\n            valp = va_arg(ap, uint16_t *);\n\n            offset += v9fs_unpack(&val, out_sg, out_num, offset, sizeof(val));\n\n            if (bswap) {\n\n                *valp = le16_to_cpu(val);\n\n            } else {\n\n                *valp = val;\n\n            }\n\n            break;\n\n        }\n\n        case 'd': {\n\n            uint32_t val, *valp;\n\n            valp = va_arg(ap, uint32_t *);\n\n            offset += v9fs_unpack(&val, out_sg, out_num, offset, sizeof(val));\n\n            if (bswap) {\n\n                *valp = le32_to_cpu(val);\n\n            } else {\n\n                *valp = val;\n\n            }\n\n            break;\n\n        }\n\n        case 'q': {\n\n            uint64_t val, *valp;\n\n            valp = va_arg(ap, uint64_t *);\n\n            offset += v9fs_unpack(&val, out_sg, out_num, offset, sizeof(val));\n\n            if (bswap) {\n\n                *valp = le64_to_cpu(val);\n\n            } else {\n\n                *valp = val;\n\n            }\n\n            break;\n\n        }\n\n        case 's': {\n\n            V9fsString *str = va_arg(ap, V9fsString *);\n\n            offset += v9fs_unmarshal(out_sg, out_num, offset, bswap,\n\n                            \"w\", &str->size);\n\n            /* FIXME: sanity check str->size */\n\n            str->data = g_malloc(str->size + 1);\n\n            offset += v9fs_unpack(str->data, out_sg, out_num, offset,\n\n                            str->size);\n\n            str->data[str->size] = 0;\n\n            break;\n\n        }\n\n        case 'Q': {\n\n            V9fsQID *qidp = va_arg(ap, V9fsQID *);\n\n            offset += v9fs_unmarshal(out_sg, out_num, offset, bswap, \"bdq\",\n\n                                     &qidp->type, &qidp->version, &qidp->path);\n\n            break;\n\n        }\n\n        case 'S': {\n\n            V9fsStat *statp = va_arg(ap, V9fsStat *);\n\n            offset += v9fs_unmarshal(out_sg, out_num, offset, bswap,\n\n                                    \"wwdQdddqsssssddd\",\n\n                                     &statp->size, &statp->type, &statp->dev,\n\n                                     &statp->qid, &statp->mode, &statp->atime,\n\n                                     &statp->mtime, &statp->length,\n\n                                     &statp->name, &statp->uid, &statp->gid,\n\n                                     &statp->muid, &statp->extension,\n\n                                     &statp->n_uid, &statp->n_gid,\n\n                                     &statp->n_muid);\n\n            break;\n\n        }\n\n        case 'I': {\n\n            V9fsIattr *iattr = va_arg(ap, V9fsIattr *);\n\n            offset += v9fs_unmarshal(out_sg, out_num, offset, bswap,\n\n                                     \"ddddqqqqq\",\n\n                                     &iattr->valid, &iattr->mode,\n\n                                     &iattr->uid, &iattr->gid, &iattr->size,\n\n                                     &iattr->atime_sec, &iattr->atime_nsec,\n\n                                     &iattr->mtime_sec, &iattr->mtime_nsec);\n\n            break;\n\n        }\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n\n\n    va_end(ap);\n\n\n\n    return offset - old_offset;\n\n}\n", "idx": 25277}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static void proxy_rewinddir(FsContext *ctx, V9fsFidOpenState *fs)\n\n{\n\n    rewinddir(fs->dir);\n\n}\n", "idx": 25278}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "int coroutine_fn thread_pool_submit_co(ThreadPool *pool, ThreadPoolFunc *func,\n\n                                       void *arg)\n\n{\n\n    ThreadPoolCo tpc = { .co = qemu_coroutine_self(), .ret = -EINPROGRESS };\n\n    assert(qemu_in_coroutine());\n\n    thread_pool_submit_aio(pool, func, arg, thread_pool_co_cb, &tpc);\n\n    qemu_coroutine_yield();\n\n    return tpc.ret;\n\n}\n", "idx": 25279}
{"project": "qemu", "commit_id": "7aff0f218cf623fbc4e2fe86c3ed8985ca3f2a9a", "target": 0, "func": "static int pci_ivshmem_init(PCIDevice *dev)\n\n{\n\n    IVShmemState *s = DO_UPCAST(IVShmemState, dev, dev);\n\n    uint8_t *pci_conf;\n\n\n\n    if (s->sizearg == NULL)\n\n        s->ivshmem_size = 4 << 20; /* 4 MB default */\n\n    else {\n\n        s->ivshmem_size = ivshmem_get_size(s);\n\n    }\n\n\n\n    register_savevm(&s->dev.qdev, \"ivshmem\", 0, 0, ivshmem_save, ivshmem_load,\n\n                                                                        dev);\n\n\n\n    /* IRQFD requires MSI */\n\n    if (ivshmem_has_feature(s, IVSHMEM_IOEVENTFD) &&\n\n        !ivshmem_has_feature(s, IVSHMEM_MSI)) {\n\n        fprintf(stderr, \"ivshmem: ioeventfd/irqfd requires MSI\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* check that role is reasonable */\n\n    if (s->role) {\n\n        if (strncmp(s->role, \"peer\", 5) == 0) {\n\n            s->role_val = IVSHMEM_PEER;\n\n        } else if (strncmp(s->role, \"master\", 7) == 0) {\n\n            s->role_val = IVSHMEM_MASTER;\n\n        } else {\n\n            fprintf(stderr, \"ivshmem: 'role' must be 'peer' or 'master'\\n\");\n\n            exit(1);\n\n        }\n\n    } else {\n\n        s->role_val = IVSHMEM_MASTER; /* default */\n\n    }\n\n\n\n    if (s->role_val == IVSHMEM_PEER) {\n\n        register_device_unmigratable(&s->dev.qdev, \"ivshmem\", s);\n\n    }\n\n\n\n    pci_conf = s->dev.config;\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_REDHAT_QUMRANET);\n\n    pci_conf[0x02] = 0x10;\n\n    pci_conf[0x03] = 0x11;\n\n    pci_conf[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY;\n\n    pci_config_set_class(pci_conf, PCI_CLASS_MEMORY_RAM);\n\n    pci_conf[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_NORMAL;\n\n\n\n    pci_config_set_interrupt_pin(pci_conf, 1);\n\n\n\n    s->shm_pci_addr = 0;\n\n    s->ivshmem_offset = 0;\n\n    s->shm_fd = 0;\n\n\n\n    s->ivshmem_mmio_io_addr = cpu_register_io_memory(ivshmem_mmio_read,\n\n                                    ivshmem_mmio_write, s, DEVICE_NATIVE_ENDIAN);\n\n    /* region for registers*/\n\n    pci_register_bar(&s->dev, 0, IVSHMEM_REG_BAR_SIZE,\n\n                           PCI_BASE_ADDRESS_SPACE_MEMORY, ivshmem_mmio_map);\n\n\n\n    if ((s->server_chr != NULL) &&\n\n                        (strncmp(s->server_chr->filename, \"unix:\", 5) == 0)) {\n\n        /* if we get a UNIX socket as the parameter we will talk\n\n         * to the ivshmem server to receive the memory region */\n\n\n\n        if (s->shmobj != NULL) {\n\n            fprintf(stderr, \"WARNING: do not specify both 'chardev' \"\n\n                                                \"and 'shm' with ivshmem\\n\");\n\n        }\n\n\n\n        IVSHMEM_DPRINTF(\"using shared memory server (socket = %s)\\n\",\n\n                                                    s->server_chr->filename);\n\n\n\n        if (ivshmem_has_feature(s, IVSHMEM_MSI)) {\n\n            ivshmem_setup_msi(s);\n\n        }\n\n\n\n        /* we allocate enough space for 16 guests and grow as needed */\n\n        s->nb_peers = 16;\n\n        s->vm_id = -1;\n\n\n\n        /* allocate/initialize space for interrupt handling */\n\n        s->peers = qemu_mallocz(s->nb_peers * sizeof(Peer));\n\n\n\n        pci_register_bar(&s->dev, 2, s->ivshmem_size,\n\n                                PCI_BASE_ADDRESS_SPACE_MEMORY, ivshmem_map);\n\n\n\n        s->eventfd_chr = qemu_mallocz(s->vectors * sizeof(CharDriverState *));\n\n\n\n        qemu_chr_add_handlers(s->server_chr, ivshmem_can_receive, ivshmem_read,\n\n                     ivshmem_event, s);\n\n    } else {\n\n        /* just map the file immediately, we're not using a server */\n\n        int fd;\n\n\n\n        if (s->shmobj == NULL) {\n\n            fprintf(stderr, \"Must specify 'chardev' or 'shm' to ivshmem\\n\");\n\n        }\n\n\n\n        IVSHMEM_DPRINTF(\"using shm_open (shm object = %s)\\n\", s->shmobj);\n\n\n\n        /* try opening with O_EXCL and if it succeeds zero the memory\n\n         * by truncating to 0 */\n\n        if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR|O_EXCL,\n\n                        S_IRWXU|S_IRWXG|S_IRWXO)) > 0) {\n\n           /* truncate file to length PCI device's memory */\n\n            if (ftruncate(fd, s->ivshmem_size) != 0) {\n\n                fprintf(stderr, \"ivshmem: could not truncate shared file\\n\");\n\n            }\n\n\n\n        } else if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR,\n\n                        S_IRWXU|S_IRWXG|S_IRWXO)) < 0) {\n\n            fprintf(stderr, \"ivshmem: could not open shared file\\n\");\n\n            exit(-1);\n\n\n\n        }\n\n\n\n        if (check_shm_size(s, fd) == -1) {\n\n            exit(-1);\n\n        }\n\n\n\n        create_shared_memory_BAR(s, fd);\n\n\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 25280}
{"project": "qemu", "commit_id": "91bfcdb01d4869aa8f4cb67007827de63b8c2217", "target": 0, "func": "int qcrypto_init(Error **errp G_GNUC_UNUSED)\n\n{\n\n    return 0;\n\n}\n", "idx": 25281}
{"project": "qemu", "commit_id": "e12f3784097a26a1ba51be420f41038b4c0ae5d1", "target": 0, "func": "BlockDriverState *check_to_replace_node(const char *node_name, Error **errp)\n\n{\n\n    BlockDriverState *to_replace_bs = bdrv_find_node(node_name);\n\n    AioContext *aio_context;\n\n\n\n    if (!to_replace_bs) {\n\n        error_setg(errp, \"Node name '%s' not found\", node_name);\n\n        return NULL;\n\n    }\n\n\n\n    aio_context = bdrv_get_aio_context(to_replace_bs);\n\n    aio_context_acquire(aio_context);\n\n\n\n    if (bdrv_op_is_blocked(to_replace_bs, BLOCK_OP_TYPE_REPLACE, errp)) {\n\n        to_replace_bs = NULL;\n\n        goto out;\n\n    }\n\n\n\n    /* We don't want arbitrary node of the BDS chain to be replaced only the top\n\n     * most non filter in order to prevent data corruption.\n\n     * Another benefit is that this tests exclude backing files which are\n\n     * blocked by the backing blockers.\n\n     */\n\n    if (!bdrv_is_first_non_filter(to_replace_bs)) {\n\n        error_setg(errp, \"Only top most non filter can be replaced\");\n\n        to_replace_bs = NULL;\n\n        goto out;\n\n    }\n\n\n\nout:\n\n    aio_context_release(aio_context);\n\n    return to_replace_bs;\n\n}\n", "idx": 25283}
{"project": "qemu", "commit_id": "b3be28969b797b27d7f7f806827e9898e4ee08f0", "target": 0, "func": "static int ram_save_compressed_page(QEMUFile *f, PageSearchStatus *pss,\n\n                                    bool last_stage,\n\n                                    uint64_t *bytes_transferred)\n\n{\n\n    int pages = -1;\n\n    uint64_t bytes_xmit;\n\n    uint8_t *p;\n\n    int ret;\n\n    RAMBlock *block = pss->block;\n\n    ram_addr_t offset = pss->offset;\n\n\n\n    p = block->host + offset;\n\n\n\n    bytes_xmit = 0;\n\n    ret = ram_control_save_page(f, block->offset,\n\n                                offset, TARGET_PAGE_SIZE, &bytes_xmit);\n\n    if (bytes_xmit) {\n\n        *bytes_transferred += bytes_xmit;\n\n        pages = 1;\n\n    }\n\n    if (block == last_sent_block) {\n\n        offset |= RAM_SAVE_FLAG_CONTINUE;\n\n    }\n\n    if (ret != RAM_SAVE_CONTROL_NOT_SUPP) {\n\n        if (ret != RAM_SAVE_CONTROL_DELAYED) {\n\n            if (bytes_xmit > 0) {\n\n                acct_info.norm_pages++;\n\n            } else if (bytes_xmit == 0) {\n\n                acct_info.dup_pages++;\n\n            }\n\n        }\n\n    } else {\n\n        /* When starting the process of a new block, the first page of\n\n         * the block should be sent out before other pages in the same\n\n         * block, and all the pages in last block should have been sent\n\n         * out, keeping this order is important, because the 'cont' flag\n\n         * is used to avoid resending the block name.\n\n         */\n\n        if (block != last_sent_block) {\n\n            flush_compressed_data(f);\n\n            pages = save_zero_page(f, block, offset, p, bytes_transferred);\n\n            if (pages == -1) {\n\n                set_compress_params(&comp_param[0], block, offset);\n\n                /* Use the qemu thread to compress the data to make sure the\n\n                 * first page is sent out before other pages\n\n                 */\n\n                bytes_xmit = do_compress_ram_page(&comp_param[0]);\n\n                acct_info.norm_pages++;\n\n                qemu_put_qemu_file(f, comp_param[0].file);\n\n                *bytes_transferred += bytes_xmit;\n\n                pages = 1;\n\n            }\n\n        } else {\n\n            pages = save_zero_page(f, block, offset, p, bytes_transferred);\n\n            if (pages == -1) {\n\n                pages = compress_page_with_multi_thread(f, block, offset,\n\n                                                        bytes_transferred);\n\n            }\n\n        }\n\n    }\n\n\n\n    return pages;\n\n}\n", "idx": 25284}
{"project": "qemu", "commit_id": "7c560456707bfe53eb1728fcde759be7d9418b62", "target": 0, "func": "static uint32_t ecc_mem_readb(void *opaque, target_phys_addr_t addr)\n\n{\n\n    printf(\"ECC: Unsupported read 0x\" TARGET_FMT_plx \" 00\\n\", addr);\n\n    return 0;\n\n}\n", "idx": 25285}
{"project": "qemu", "commit_id": "96d7073fb058e6f05257cd9041ffbbd736f6ccec", "target": 0, "func": "static inline void gen_op_mov_reg_v(int ot, int reg, TCGv t0)\n\n{\n\n    switch(ot) {\n\n    case OT_BYTE:\n\n        if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {\n\n            tcg_gen_deposit_tl(cpu_regs[reg], cpu_regs[reg], t0, 0, 8);\n\n        } else {\n\n            tcg_gen_deposit_tl(cpu_regs[reg - 4], cpu_regs[reg - 4], t0, 8, 8);\n\n        }\n\n        break;\n\n    case OT_WORD:\n\n        tcg_gen_deposit_tl(cpu_regs[reg], cpu_regs[reg], t0, 0, 16);\n\n        break;\n\n    default: /* XXX this shouldn't be reached;  abort? */\n\n    case OT_LONG:\n\n        /* For x86_64, this sets the higher half of register to zero.\n\n           For i386, this is equivalent to a mov. */\n\n        tcg_gen_ext32u_tl(cpu_regs[reg], t0);\n\n        break;\n\n#ifdef TARGET_X86_64\n\n    case OT_QUAD:\n\n        tcg_gen_mov_tl(cpu_regs[reg], t0);\n\n        break;\n\n#endif\n\n    }\n\n}\n", "idx": 25286}
{"project": "qemu", "commit_id": "b97400caef60ccfb0bc81c59f8bd824c43a0d6c8", "target": 0, "func": "static int local_symlink(FsContext *fs_ctx, const char *oldpath,\n\n                         V9fsPath *dir_path, const char *name, FsCred *credp)\n\n{\n\n    int err = -1;\n\n    int serrno = 0;\n\n    char *newpath;\n\n    V9fsString fullname;\n\n    char buffer[PATH_MAX];\n\n\n\n    v9fs_string_init(&fullname);\n\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);\n\n    newpath = fullname.data;\n\n\n\n    /* Determine the security model */\n\n    if (fs_ctx->fs_sm == SM_MAPPED) {\n\n        int fd;\n\n        ssize_t oldpath_size, write_size;\n\n        fd = open(rpath(fs_ctx, newpath, buffer), O_CREAT|O_EXCL|O_RDWR,\n\n                SM_LOCAL_MODE_BITS);\n\n        if (fd == -1) {\n\n            err = fd;\n\n            goto out;\n\n        }\n\n        /* Write the oldpath (target) to the file. */\n\n        oldpath_size = strlen(oldpath);\n\n        do {\n\n            write_size = write(fd, (void *)oldpath, oldpath_size);\n\n        } while (write_size == -1 && errno == EINTR);\n\n\n\n        if (write_size != oldpath_size) {\n\n            serrno = errno;\n\n            close(fd);\n\n            err = -1;\n\n            goto err_end;\n\n        }\n\n        close(fd);\n\n        /* Set cleint credentials in symlink's xattr */\n\n        credp->fc_mode = credp->fc_mode|S_IFLNK;\n\n        err = local_set_xattr(rpath(fs_ctx, newpath, buffer), credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if ((fs_ctx->fs_sm == SM_PASSTHROUGH) ||\n\n               (fs_ctx->fs_sm == SM_NONE)) {\n\n        err = symlink(oldpath, rpath(fs_ctx, newpath, buffer));\n\n        if (err) {\n\n            goto out;\n\n        }\n\n        err = lchown(rpath(fs_ctx, newpath, buffer), credp->fc_uid,\n\n                     credp->fc_gid);\n\n        if (err == -1) {\n\n            /*\n\n             * If we fail to change ownership and if we are\n\n             * using security model none. Ignore the error\n\n             */\n\n            if (fs_ctx->fs_sm != SM_NONE) {\n\n                serrno = errno;\n\n                goto err_end;\n\n            } else\n\n                err = 0;\n\n        }\n\n    }\n\n    goto out;\n\n\n\nerr_end:\n\n    remove(rpath(fs_ctx, newpath, buffer));\n\n    errno = serrno;\n\nout:\n\n    v9fs_string_free(&fullname);\n\n    return err;\n\n}\n", "idx": 25287}
{"project": "qemu", "commit_id": "2d32addae70987521578d8bb27c6b3f52cdcbdcb", "target": 0, "func": "int socket_listen(SocketAddress *addr, Error **errp)\n\n{\n\n    QemuOpts *opts;\n\n    int fd;\n\n\n\n    opts = qemu_opts_create(&socket_optslist, NULL, 0, &error_abort);\n\n    switch (addr->kind) {\n\n    case SOCKET_ADDRESS_KIND_INET:\n\n        inet_addr_to_opts(opts, addr->inet);\n\n        fd = inet_listen_opts(opts, 0, errp);\n\n        break;\n\n\n\n    case SOCKET_ADDRESS_KIND_UNIX:\n\n        qemu_opt_set(opts, \"path\", addr->q_unix->path, &error_abort);\n\n        fd = unix_listen_opts(opts, errp);\n\n        break;\n\n\n\n    case SOCKET_ADDRESS_KIND_FD:\n\n        fd = monitor_get_fd(cur_mon, addr->fd->str, errp);\n\n        break;\n\n\n\n    default:\n\n        abort();\n\n    }\n\n    qemu_opts_del(opts);\n\n    return fd;\n\n}\n", "idx": 25288}
{"project": "qemu", "commit_id": "d85f4222b4681da7ebf8a90b26e085a68fa2c55a", "target": 0, "func": "static int qcow_open(BlockDriverState *bs, QDict *options, int flags,\n\n                     Error **errp)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    unsigned int len, i, shift;\n\n    int ret;\n\n    QCowHeader header;\n\n    Error *local_err = NULL;\n\n\n\n    bs->file = bdrv_open_child(NULL, options, \"file\", bs, &child_file,\n\n                               false, errp);\n\n    if (!bs->file) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    ret = bdrv_pread(bs->file, 0, &header, sizeof(header));\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n    be32_to_cpus(&header.magic);\n\n    be32_to_cpus(&header.version);\n\n    be64_to_cpus(&header.backing_file_offset);\n\n    be32_to_cpus(&header.backing_file_size);\n\n    be32_to_cpus(&header.mtime);\n\n    be64_to_cpus(&header.size);\n\n    be32_to_cpus(&header.crypt_method);\n\n    be64_to_cpus(&header.l1_table_offset);\n\n\n\n    if (header.magic != QCOW_MAGIC) {\n\n        error_setg(errp, \"Image not in qcow format\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    if (header.version != QCOW_VERSION) {\n\n        error_setg(errp, \"Unsupported qcow version %\" PRIu32, header.version);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    }\n\n\n\n    if (header.size <= 1) {\n\n        error_setg(errp, \"Image size is too small (must be at least 2 bytes)\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    if (header.cluster_bits < 9 || header.cluster_bits > 16) {\n\n        error_setg(errp, \"Cluster size must be between 512 and 64k\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    /* l2_bits specifies number of entries; storing a uint64_t in each entry,\n\n     * so bytes = num_entries << 3. */\n\n    if (header.l2_bits < 9 - 3 || header.l2_bits > 16 - 3) {\n\n        error_setg(errp, \"L2 table size must be between 512 and 64k\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    if (header.crypt_method > QCOW_CRYPT_AES) {\n\n        error_setg(errp, \"invalid encryption method in qcow header\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    if (!qcrypto_cipher_supports(QCRYPTO_CIPHER_ALG_AES_128,\n\n                                 QCRYPTO_CIPHER_MODE_CBC)) {\n\n        error_setg(errp, \"AES cipher not available\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    s->crypt_method_header = header.crypt_method;\n\n    if (s->crypt_method_header) {\n\n        if (bdrv_uses_whitelist() &&\n\n            s->crypt_method_header == QCOW_CRYPT_AES) {\n\n            error_setg(errp,\n\n                       \"Use of AES-CBC encrypted qcow images is no longer \"\n\n                       \"supported in system emulators\");\n\n            error_append_hint(errp,\n\n                              \"You can use 'qemu-img convert' to convert your \"\n\n                              \"image to an alternative supported format, such \"\n\n                              \"as unencrypted qcow, or raw with the LUKS \"\n\n                              \"format instead.\\n\");\n\n            ret = -ENOSYS;\n\n            goto fail;\n\n        }\n\n\n\n        bs->encrypted = true;\n\n    }\n\n    s->cluster_bits = header.cluster_bits;\n\n    s->cluster_size = 1 << s->cluster_bits;\n\n    s->cluster_sectors = 1 << (s->cluster_bits - 9);\n\n    s->l2_bits = header.l2_bits;\n\n    s->l2_size = 1 << s->l2_bits;\n\n    bs->total_sectors = header.size / 512;\n\n    s->cluster_offset_mask = (1LL << (63 - s->cluster_bits)) - 1;\n\n\n\n    /* read the level 1 table */\n\n    shift = s->cluster_bits + s->l2_bits;\n\n    if (header.size > UINT64_MAX - (1LL << shift)) {\n\n        error_setg(errp, \"Image too large\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    } else {\n\n        uint64_t l1_size = (header.size + (1LL << shift) - 1) >> shift;\n\n        if (l1_size > INT_MAX / sizeof(uint64_t)) {\n\n            error_setg(errp, \"Image too large\");\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n        s->l1_size = l1_size;\n\n    }\n\n\n\n    s->l1_table_offset = header.l1_table_offset;\n\n    s->l1_table = g_try_new(uint64_t, s->l1_size);\n\n    if (s->l1_table == NULL) {\n\n        error_setg(errp, \"Could not allocate memory for L1 table\");\n\n        ret = -ENOMEM;\n\n        goto fail;\n\n    }\n\n\n\n    ret = bdrv_pread(bs->file, s->l1_table_offset, s->l1_table,\n\n               s->l1_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    for(i = 0;i < s->l1_size; i++) {\n\n        be64_to_cpus(&s->l1_table[i]);\n\n    }\n\n\n\n    /* alloc L2 cache (max. 64k * 16 * 8 = 8 MB) */\n\n    s->l2_cache =\n\n        qemu_try_blockalign(bs->file->bs,\n\n                            s->l2_size * L2_CACHE_SIZE * sizeof(uint64_t));\n\n    if (s->l2_cache == NULL) {\n\n        error_setg(errp, \"Could not allocate L2 table cache\");\n\n        ret = -ENOMEM;\n\n        goto fail;\n\n    }\n\n    s->cluster_cache = g_malloc(s->cluster_size);\n\n    s->cluster_data = g_malloc(s->cluster_size);\n\n    s->cluster_cache_offset = -1;\n\n\n\n    /* read the backing file name */\n\n    if (header.backing_file_offset != 0) {\n\n        len = header.backing_file_size;\n\n        if (len > 1023 || len >= sizeof(bs->backing_file)) {\n\n            error_setg(errp, \"Backing file name too long\");\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n        ret = bdrv_pread(bs->file, header.backing_file_offset,\n\n                   bs->backing_file, len);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        bs->backing_file[len] = '\\0';\n\n    }\n\n\n\n    /* Disable migration when qcow images are used */\n\n    error_setg(&s->migration_blocker, \"The qcow format used by node '%s' \"\n\n               \"does not support live migration\",\n\n               bdrv_get_device_or_node_name(bs));\n\n    ret = migrate_add_blocker(s->migration_blocker, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        error_free(s->migration_blocker);\n\n        goto fail;\n\n    }\n\n\n\n    qemu_co_mutex_init(&s->lock);\n\n    return 0;\n\n\n\n fail:\n\n    g_free(s->l1_table);\n\n    qemu_vfree(s->l2_cache);\n\n    g_free(s->cluster_cache);\n\n    g_free(s->cluster_data);\n\n    return ret;\n\n}\n", "idx": 25289}
{"project": "qemu", "commit_id": "eabcea18f835178c1f8f088f88bf00e379f09438", "target": 0, "func": "static void sigp_restart(CPUState *cs, run_on_cpu_data arg)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    SigpInfo *si = arg.host_ptr;\n\n    struct kvm_s390_irq irq = {\n\n        .type = KVM_S390_RESTART,\n\n    };\n\n\n\n    switch (s390_cpu_get_state(cpu)) {\n\n    case CPU_STATE_STOPPED:\n\n        /* the restart irq has to be delivered prior to any other pending irq */\n\n        cpu_synchronize_state(cs);\n\n        do_restart_interrupt(&cpu->env);\n\n        s390_cpu_set_state(CPU_STATE_OPERATING, cpu);\n\n        break;\n\n    case CPU_STATE_OPERATING:\n\n        kvm_s390_vcpu_interrupt(cpu, &irq);\n\n        break;\n\n    }\n\n    si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;\n\n}\n", "idx": 25290}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void qemu_purge_queued_packets(VLANClientState *vc)\n\n{\n\n    VLANPacket *packet, *next;\n\n\n\n    TAILQ_FOREACH_SAFE(packet, &vc->vlan->send_queue, entry, next) {\n\n        if (packet->sender == vc) {\n\n            TAILQ_REMOVE(&vc->vlan->send_queue, packet, entry);\n\n            qemu_free(packet);\n\n        }\n\n    }\n\n}\n", "idx": 25291}
{"project": "qemu", "commit_id": "2ee4aed86ff2ba38a0e1846de18a9aec38d73015", "target": 0, "func": "static void mips_tlb_flush_extra (CPUState *env, int first)\n\n{\n\n    /* Discard entries from env->tlb[first] onwards.  */\n\n    while (env->tlb_in_use > first) {\n\n        invalidate_tlb(--env->tlb_in_use, 0);\n\n    }\n\n}\n", "idx": 25292}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "DeviceState *exynos4210_uart_create(target_phys_addr_t addr,\n\n                                 int fifo_size,\n\n                                 int channel,\n\n                                 CharDriverState *chr,\n\n                                 qemu_irq irq)\n\n{\n\n    DeviceState  *dev;\n\n    SysBusDevice *bus;\n\n\n\n    const char chr_name[] = \"serial\";\n\n    char label[ARRAY_SIZE(chr_name) + 1];\n\n\n\n    dev = qdev_create(NULL, \"exynos4210.uart\");\n\n\n\n    if (!chr) {\n\n        if (channel >= MAX_SERIAL_PORTS) {\n\n            hw_error(\"Only %d serial ports are supported by QEMU.\\n\",\n\n                     MAX_SERIAL_PORTS);\n\n        }\n\n        chr = serial_hds[channel];\n\n        if (!chr) {\n\n            snprintf(label, ARRAY_SIZE(label), \"%s%d\", chr_name, channel);\n\n            chr = qemu_chr_new(label, \"null\", NULL);\n\n            if (!(chr)) {\n\n                hw_error(\"Can't assign serial port to UART%d.\\n\", channel);\n\n            }\n\n        }\n\n    }\n\n\n\n    qdev_prop_set_chr(dev, \"chardev\", chr);\n\n    qdev_prop_set_uint32(dev, \"channel\", channel);\n\n    qdev_prop_set_uint32(dev, \"rx-size\", fifo_size);\n\n    qdev_prop_set_uint32(dev, \"tx-size\", fifo_size);\n\n\n\n    bus = sysbus_from_qdev(dev);\n\n    qdev_init_nofail(dev);\n\n    if (addr != (target_phys_addr_t)-1) {\n\n        sysbus_mmio_map(bus, 0, addr);\n\n    }\n\n    sysbus_connect_irq(bus, 0, irq);\n\n\n\n    return dev;\n\n}\n", "idx": 25294}
{"project": "qemu", "commit_id": "ddf21908961073199f3d186204da4810f2ea150b", "target": 0, "func": "static VncClientInfo *qmp_query_vnc_client(const VncState *client)\n\n{\n\n    struct sockaddr_storage sa;\n\n    socklen_t salen = sizeof(sa);\n\n    char host[NI_MAXHOST];\n\n    char serv[NI_MAXSERV];\n\n    VncClientInfo *info;\n\n\n\n    if (getpeername(client->csock, (struct sockaddr *)&sa, &salen) < 0) {\n\n        return NULL;\n\n    }\n\n\n\n    if (getnameinfo((struct sockaddr *)&sa, salen,\n\n                    host, sizeof(host),\n\n                    serv, sizeof(serv),\n\n                    NI_NUMERICHOST | NI_NUMERICSERV) < 0) {\n\n        return NULL;\n\n    }\n\n\n\n    info = g_malloc0(sizeof(*info));\n\n    info->base = g_malloc0(sizeof(*info->base));\n\n    info->base->host = g_strdup(host);\n\n    info->base->service = g_strdup(serv);\n\n    info->base->family = inet_netfamily(sa.ss_family);\n\n    info->base->websocket = client->websocket;\n\n\n\n    if (client->tls) {\n\n        info->x509_dname = qcrypto_tls_session_get_peer_name(client->tls);\n\n        info->has_x509_dname = info->x509_dname != NULL;\n\n    }\n\n#ifdef CONFIG_VNC_SASL\n\n    if (client->sasl.conn && client->sasl.username) {\n\n        info->has_sasl_username = true;\n\n        info->sasl_username = g_strdup(client->sasl.username);\n\n    }\n\n#endif\n\n\n\n    return info;\n\n}\n", "idx": 25295}
{"project": "qemu", "commit_id": "4d29b50a41810684ad34e44352a630eb1dd94b58", "target": 1, "func": "static int ahci_dma_set_inactive(IDEDMA *dma)\n\n{\n\n    AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);\n\n\n\n    DPRINTF(ad->port_no, \"dma done\\n\");\n\n\n\n    /* update d2h status */\n\n    ahci_write_fis_d2h(ad, NULL);\n\n\n\n    ad->dma_cb = NULL;\n\n\n\n    /* maybe we still have something to process, check later */\n\n    ad->check_bh = qemu_bh_new(ahci_check_cmd_bh, ad);\n\n    qemu_bh_schedule(ad->check_bh);\n\n\n\n    return 0;\n\n}\n", "idx": 25301}
{"project": "qemu", "commit_id": "016f5cf6ff465411733878a17c8f8febb7668321", "target": 1, "func": "DriveInfo *drive_init(QemuOpts *opts, void *opaque,\n\n                      int *fatal_error)\n\n{\n\n    const char *buf;\n\n    const char *file = NULL;\n\n    char devname[128];\n\n    const char *serial;\n\n    const char *mediastr = \"\";\n\n    BlockInterfaceType type;\n\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n\n    int bus_id, unit_id;\n\n    int cyls, heads, secs, translation;\n\n    BlockDriver *drv = NULL;\n\n    QEMUMachine *machine = opaque;\n\n    int max_devs;\n\n    int index;\n\n    int ro = 0;\n\n    int bdrv_flags = 0;\n\n    int on_read_error, on_write_error;\n\n    const char *devaddr;\n\n    DriveInfo *dinfo;\n\n    int snapshot = 0;\n\n\n\n    *fatal_error = 1;\n\n\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\n\n    if (machine && machine->use_scsi) {\n\n        type = IF_SCSI;\n\n        max_devs = MAX_SCSI_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"scsi\");\n\n    } else {\n\n        type = IF_IDE;\n\n        max_devs = MAX_IDE_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"ide\");\n\n    }\n\n    media = MEDIA_DISK;\n\n\n\n    /* extract parameters */\n\n    bus_id  = qemu_opt_get_number(opts, \"bus\", 0);\n\n    unit_id = qemu_opt_get_number(opts, \"unit\", -1);\n\n    index   = qemu_opt_get_number(opts, \"index\", -1);\n\n\n\n    cyls  = qemu_opt_get_number(opts, \"cyls\", 0);\n\n    heads = qemu_opt_get_number(opts, \"heads\", 0);\n\n    secs  = qemu_opt_get_number(opts, \"secs\", 0);\n\n\n\n    snapshot = qemu_opt_get_bool(opts, \"snapshot\", 0);\n\n    ro = qemu_opt_get_bool(opts, \"readonly\", 0);\n\n\n\n    file = qemu_opt_get(opts, \"file\");\n\n    serial = qemu_opt_get(opts, \"serial\");\n\n\n\n    if ((buf = qemu_opt_get(opts, \"if\")) != NULL) {\n\n        pstrcpy(devname, sizeof(devname), buf);\n\n        if (!strcmp(buf, \"ide\")) {\n\n\t    type = IF_IDE;\n\n            max_devs = MAX_IDE_DEVS;\n\n        } else if (!strcmp(buf, \"scsi\")) {\n\n\t    type = IF_SCSI;\n\n            max_devs = MAX_SCSI_DEVS;\n\n        } else if (!strcmp(buf, \"floppy\")) {\n\n\t    type = IF_FLOPPY;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"pflash\")) {\n\n\t    type = IF_PFLASH;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"mtd\")) {\n\n\t    type = IF_MTD;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"sd\")) {\n\n\t    type = IF_SD;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"virtio\")) {\n\n            type = IF_VIRTIO;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"xen\")) {\n\n\t    type = IF_XEN;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"none\")) {\n\n\t    type = IF_NONE;\n\n            max_devs = 0;\n\n\t} else {\n\n            fprintf(stderr, \"qemu: unsupported bus type '%s'\\n\", buf);\n\n            return NULL;\n\n\t}\n\n    }\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1 || (type == IF_IDE && cyls > 16383)) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical cyls number\\n\", buf);\n\n\t    return NULL;\n\n\t}\n\n        if (heads < 1 || (type == IF_IDE && heads > 16)) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical heads number\\n\", buf);\n\n\t    return NULL;\n\n\t}\n\n        if (secs < 1 || (type == IF_IDE && secs > 63)) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical secs number\\n\", buf);\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"trans\")) != NULL) {\n\n        if (!cyls) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' trans must be used with cyls,heads and secs\\n\",\n\n                    buf);\n\n            return NULL;\n\n        }\n\n        if (!strcmp(buf, \"none\"))\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        else if (!strcmp(buf, \"lba\"))\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        else if (!strcmp(buf, \"auto\"))\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\telse {\n\n            fprintf(stderr, \"qemu: '%s' invalid translation type\\n\", buf);\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"media\")) != NULL) {\n\n        if (!strcmp(buf, \"disk\")) {\n\n\t    media = MEDIA_DISK;\n\n\t} else if (!strcmp(buf, \"cdrom\")) {\n\n            if (cyls || secs || heads) {\n\n                fprintf(stderr,\n\n                        \"qemu: '%s' invalid physical CHS format\\n\", buf);\n\n\t        return NULL;\n\n            }\n\n\t    media = MEDIA_CDROM;\n\n\t} else {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid media\\n\", buf);\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"cache\")) != NULL) {\n\n        if (!strcmp(buf, \"off\") || !strcmp(buf, \"none\")) {\n\n            bdrv_flags |= BDRV_O_NOCACHE;\n\n        } else if (!strcmp(buf, \"writeback\")) {\n\n\n\n\n\n        } else if (!strcmp(buf, \"writethrough\")) {\n\n            /* this is the default */\n\n        } else {\n\n           fprintf(stderr, \"qemu: invalid cache option\\n\");\n\n           return NULL;\n\n        }\n\n    }\n\n\n\n#ifdef CONFIG_LINUX_AIO\n\n    if ((buf = qemu_opt_get(opts, \"aio\")) != NULL) {\n\n        if (!strcmp(buf, \"native\")) {\n\n            bdrv_flags |= BDRV_O_NATIVE_AIO;\n\n        } else if (!strcmp(buf, \"threads\")) {\n\n            /* this is the default */\n\n        } else {\n\n           fprintf(stderr, \"qemu: invalid aio option\\n\");\n\n           return NULL;\n\n        }\n\n    }\n\n#endif\n\n\n\n    if ((buf = qemu_opt_get(opts, \"format\")) != NULL) {\n\n       if (strcmp(buf, \"?\") == 0) {\n\n            fprintf(stderr, \"qemu: Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            fprintf(stderr, \"\\n\");\n\n\t    return NULL;\n\n        }\n\n        drv = bdrv_find_whitelisted_format(buf);\n\n        if (!drv) {\n\n            fprintf(stderr, \"qemu: '%s' invalid format\\n\", buf);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    on_write_error = BLOCK_ERR_STOP_ENOSPC;\n\n    if ((buf = qemu_opt_get(opts, \"werror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) {\n\n            fprintf(stderr, \"werror is no supported by this format\\n\");\n\n            return NULL;\n\n        }\n\n\n\n        on_write_error = parse_block_error_action(buf, 0);\n\n        if (on_write_error < 0) {\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    on_read_error = BLOCK_ERR_REPORT;\n\n    if ((buf = qemu_opt_get(opts, \"rerror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_VIRTIO) {\n\n            fprintf(stderr, \"rerror is no supported by this format\\n\");\n\n            return NULL;\n\n        }\n\n\n\n        on_read_error = parse_block_error_action(buf, 1);\n\n        if (on_read_error < 0) {\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if ((devaddr = qemu_opt_get(opts, \"addr\")) != NULL) {\n\n        if (type != IF_VIRTIO) {\n\n            fprintf(stderr, \"addr is not supported\\n\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* compute bus and unit according index */\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            fprintf(stderr,\n\n                    \"qemu: index cannot be used with bus and unit\\n\");\n\n            return NULL;\n\n        }\n\n        if (max_devs == 0)\n\n        {\n\n            unit_id = index;\n\n            bus_id = 0;\n\n        } else {\n\n            unit_id = index % max_devs;\n\n            bus_id = index / max_devs;\n\n        }\n\n    }\n\n\n\n    /* if user doesn't specify a unit_id,\n\n     * try to find the first free\n\n     */\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get(type, bus_id, unit_id) != NULL) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    /* check unit id */\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        fprintf(stderr, \"qemu: unit %d too big (max is %d)\\n\",\n\n                unit_id, max_devs - 1);\n\n        return NULL;\n\n    }\n\n\n\n    /*\n\n     * ignore multiple definitions\n\n     */\n\n\n\n    if (drive_get(type, bus_id, unit_id) != NULL) {\n\n        *fatal_error = 0;\n\n        return NULL;\n\n    }\n\n\n\n    /* init */\n\n\n\n    dinfo = qemu_mallocz(sizeof(*dinfo));\n\n    if ((buf = qemu_opts_id(opts)) != NULL) {\n\n        dinfo->id = qemu_strdup(buf);\n\n    } else {\n\n        /* no id supplied -> create one */\n\n        dinfo->id = qemu_mallocz(32);\n\n        if (type == IF_IDE || type == IF_SCSI)\n\n            mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n        if (max_devs)\n\n            snprintf(dinfo->id, 32, \"%s%i%s%i\",\n\n                     devname, bus_id, mediastr, unit_id);\n\n        else\n\n            snprintf(dinfo->id, 32, \"%s%s%i\",\n\n                     devname, mediastr, unit_id);\n\n    }\n\n    dinfo->bdrv = bdrv_new(dinfo->id);\n\n    dinfo->devaddr = devaddr;\n\n    dinfo->type = type;\n\n    dinfo->bus = bus_id;\n\n    dinfo->unit = unit_id;\n\n    dinfo->on_read_error = on_read_error;\n\n    dinfo->on_write_error = on_write_error;\n\n    dinfo->opts = opts;\n\n    if (serial)\n\n        strncpy(dinfo->serial, serial, sizeof(serial));\n\n    QTAILQ_INSERT_TAIL(&drives, dinfo, next);\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n    case IF_NONE:\n\n        switch(media) {\n\n\tcase MEDIA_DISK:\n\n            if (cyls != 0) {\n\n                bdrv_set_geometry_hint(dinfo->bdrv, cyls, heads, secs);\n\n                bdrv_set_translation_hint(dinfo->bdrv, translation);\n\n            }\n\n\t    break;\n\n\tcase MEDIA_CDROM:\n\n            bdrv_set_type_hint(dinfo->bdrv, BDRV_TYPE_CDROM);\n\n\t    break;\n\n\t}\n\n        break;\n\n    case IF_SD:\n\n        /* FIXME: This isn't really a floppy, but it's a reasonable\n\n           approximation.  */\n\n    case IF_FLOPPY:\n\n        bdrv_set_type_hint(dinfo->bdrv, BDRV_TYPE_FLOPPY);\n\n        break;\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n        break;\n\n    case IF_VIRTIO:\n\n        /* add virtio block device */\n\n        opts = qemu_opts_create(&qemu_device_opts, NULL, 0);\n\n        qemu_opt_set(opts, \"driver\", \"virtio-blk-pci\");\n\n        qemu_opt_set(opts, \"drive\", dinfo->id);\n\n        if (devaddr)\n\n            qemu_opt_set(opts, \"addr\", devaddr);\n\n        break;\n\n    case IF_COUNT:\n\n        abort();\n\n    }\n\n    if (!file) {\n\n        *fatal_error = 0;\n\n        return NULL;\n\n    }\n\n    if (snapshot) {\n\n        /* always use write-back with snapshot */\n\n        bdrv_flags &= ~BDRV_O_CACHE_MASK;\n\n        bdrv_flags |= (BDRV_O_SNAPSHOT|BDRV_O_CACHE_WB);\n\n    }\n\n\n\n    if (media == MEDIA_CDROM) {\n\n        /* CDROM is fine for any interface, don't check.  */\n\n        ro = 1;\n\n    } else if (ro == 1) {\n\n        if (type != IF_SCSI && type != IF_VIRTIO && type != IF_FLOPPY) {\n\n            fprintf(stderr, \"qemu: readonly flag not supported for drive with this interface\\n\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    bdrv_flags |= ro ? 0 : BDRV_O_RDWR;\n\n\n\n    if (bdrv_open(dinfo->bdrv, file, bdrv_flags, drv) < 0) {\n\n        fprintf(stderr, \"qemu: could not open disk image %s: %s\\n\",\n\n                        file, strerror(errno));\n\n        return NULL;\n\n    }\n\n\n\n    if (bdrv_key_required(dinfo->bdrv))\n\n        autostart = 0;\n\n    *fatal_error = 0;\n\n    return dinfo;\n\n}", "idx": 25302}
{"project": "qemu", "commit_id": "f41152bd9d01ab327c19a3828bb7896d67cf0752", "target": 1, "func": "milkymist_init(QEMUMachineInitArgs *args)\n{\n    const char *cpu_model = args->cpu_model;\n    const char *kernel_filename = args->kernel_filename;\n    const char *kernel_cmdline = args->kernel_cmdline;\n    const char *initrd_filename = args->initrd_filename;\n    LM32CPU *cpu;\n    CPULM32State *env;\n    int kernel_size;\n    DriveInfo *dinfo;\n    MemoryRegion *address_space_mem = get_system_memory();\n    MemoryRegion *phys_sdram = g_new(MemoryRegion, 1);\n    qemu_irq irq[32], *cpu_irq;\n    int i;\n    char *bios_filename;\n    ResetInfo *reset_info;\n    /* memory map */\n    hwaddr flash_base   = 0x00000000;\n    size_t flash_sector_size        = 128 * 1024;\n    size_t flash_size               = 32 * 1024 * 1024;\n    hwaddr sdram_base   = 0x40000000;\n    size_t sdram_size               = 128 * 1024 * 1024;\n    hwaddr initrd_base  = sdram_base + 0x1002000;\n    hwaddr cmdline_base = sdram_base + 0x1000000;\n    size_t initrd_max = sdram_size - 0x1002000;\n    reset_info = g_malloc0(sizeof(ResetInfo));\n    if (cpu_model == NULL) {\n        cpu_model = \"lm32-full\";\n    cpu = cpu_lm32_init(cpu_model);\n    env = &cpu->env;\n    reset_info->cpu = cpu;\n    cpu_lm32_set_phys_msb_ignore(env, 1);\n    memory_region_init_ram(phys_sdram, NULL, \"milkymist.sdram\", sdram_size);\n    vmstate_register_ram_global(phys_sdram);\n    memory_region_add_subregion(address_space_mem, sdram_base, phys_sdram);\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n    /* Numonyx JS28F256J3F105 */\n    pflash_cfi01_register(flash_base, NULL, \"milkymist.flash\", flash_size,\n                          dinfo ? dinfo->bdrv : NULL, flash_sector_size,\n                          flash_size / flash_sector_size, 2,\n                          0x00, 0x89, 0x00, 0x1d, 1);\n    /* create irq lines */\n    cpu_irq = qemu_allocate_irqs(cpu_irq_handler, cpu, 1);\n    env->pic_state = lm32_pic_init(*cpu_irq);\n    for (i = 0; i < 32; i++) {\n        irq[i] = qdev_get_gpio_in(env->pic_state, i);\n    /* load bios rom */\n    if (bios_name == NULL) {\n        bios_name = BIOS_FILENAME;\n    bios_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n    if (bios_filename) {\n        load_image_targphys(bios_filename, BIOS_OFFSET, BIOS_SIZE);\n    reset_info->bootstrap_pc = BIOS_OFFSET;\n    /* if no kernel is given no valid bios rom is a fatal error */\n    if (!kernel_filename && !dinfo && !bios_filename && !qtest_enabled()) {\n        fprintf(stderr, \"qemu: could not load Milkymist One bios '%s'\\n\",\n                bios_name);\n    milkymist_uart_create(0x60000000, irq[0]);\n    milkymist_sysctl_create(0x60001000, irq[1], irq[2], irq[3],\n            80000000, 0x10014d31, 0x0000041f, 0x00000001);\n    milkymist_hpdmc_create(0x60002000);\n    milkymist_vgafb_create(0x60003000, 0x40000000, 0x0fffffff);\n    milkymist_memcard_create(0x60004000);\n    milkymist_ac97_create(0x60005000, irq[4], irq[5], irq[6], irq[7]);\n    milkymist_pfpu_create(0x60006000, irq[8]);\n    milkymist_tmu2_create(0x60007000, irq[9]);\n    milkymist_minimac2_create(0x60008000, 0x30000000, irq[10], irq[11]);\n    milkymist_softusb_create(0x6000f000, irq[15],\n            0x20000000, 0x1000, 0x20020000, 0x2000);\n    /* make sure juart isn't the first chardev */\n    env->juart_state = lm32_juart_init();\n    if (kernel_filename) {\n        uint64_t entry;\n        /* Boots a kernel elf binary.  */\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n                               1, ELF_MACHINE, 0);\n        reset_info->bootstrap_pc = entry;\n        if (kernel_size < 0) {\n            kernel_size = load_image_targphys(kernel_filename, sdram_base,\n                                              sdram_size);\n            reset_info->bootstrap_pc = sdram_base;\n        if (kernel_size < 0) {\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n                    kernel_filename);\n    if (kernel_cmdline && strlen(kernel_cmdline)) {\n        pstrcpy_targphys(\"cmdline\", cmdline_base, TARGET_PAGE_SIZE,\n                kernel_cmdline);\n        reset_info->cmdline_base = (uint32_t)cmdline_base;\n    if (initrd_filename) {\n        size_t initrd_size;\n        initrd_size = load_image_targphys(initrd_filename, initrd_base,\n                initrd_max);\n        reset_info->initrd_base = (uint32_t)initrd_base;\n        reset_info->initrd_size = (uint32_t)initrd_size;\n    qemu_register_reset(main_cpu_reset, reset_info);", "idx": 25304}
{"project": "qemu", "commit_id": "e5fda03839e3c61b01d6c60de5625501d01c69d0", "target": 1, "func": "static int bt_hci_name_req(struct bt_hci_s *hci, bdaddr_t *bdaddr)\n\n{\n\n    struct bt_device_s *slave;\n\n    evt_remote_name_req_complete params;\n\n    int len;\n\n\n\n    for (slave = hci->device.net->slave; slave; slave = slave->next)\n\n        if (slave->page_scan && !bacmp(&slave->bd_addr, bdaddr))\n\n            break;\n\n    if (!slave)\n\n        return -ENODEV;\n\n\n\n    bt_hci_event_status(hci, HCI_SUCCESS);\n\n\n\n    params.status       = HCI_SUCCESS;\n\n    bacpy(&params.bdaddr, &slave->bd_addr);\n\n    len = snprintf(params.name, sizeof(params.name),\n\n                    \"%s\", slave->lmp_name ?: \"\");\n\n    memset(params.name + len, 0, sizeof(params.name) - len);\n\n    bt_hci_event(hci, EVT_REMOTE_NAME_REQ_COMPLETE,\n\n                    &params, EVT_REMOTE_NAME_REQ_COMPLETE_SIZE);\n\n\n\n    return 0;\n\n}\n", "idx": 25307}
{"project": "qemu", "commit_id": "554b614765090f47d97a20ca6981e17e96515ec1", "target": 0, "func": "void qmp_block_stream(bool has_job_id, const char *job_id, const char *device,\n\n                      bool has_base, const char *base,\n\n                      bool has_backing_file, const char *backing_file,\n\n                      bool has_speed, int64_t speed,\n\n                      bool has_on_error, BlockdevOnError on_error,\n\n                      Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *base_bs = NULL;\n\n    AioContext *aio_context;\n\n    Error *local_err = NULL;\n\n    const char *base_name = NULL;\n\n\n\n    if (!has_on_error) {\n\n        on_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n\n\n    bs = qmp_get_root_bs(device, errp);\n\n    if (!bs) {\n\n        return;\n\n    }\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_STREAM, errp)) {\n\n        goto out;\n\n    }\n\n\n\n    if (has_base) {\n\n        base_bs = bdrv_find_backing_image(bs, base);\n\n        if (base_bs == NULL) {\n\n            error_setg(errp, QERR_BASE_NOT_FOUND, base);\n\n            goto out;\n\n        }\n\n        assert(bdrv_get_aio_context(base_bs) == aio_context);\n\n        base_name = base;\n\n    }\n\n\n\n    /* if we are streaming the entire chain, the result will have no backing\n\n     * file, and specifying one is therefore an error */\n\n    if (base_bs == NULL && has_backing_file) {\n\n        error_setg(errp, \"backing file specified, but streaming the \"\n\n                         \"entire chain\");\n\n        goto out;\n\n    }\n\n\n\n    /* backing_file string overrides base bs filename */\n\n    base_name = has_backing_file ? backing_file : base_name;\n\n\n\n    stream_start(has_job_id ? job_id : NULL, bs, base_bs, base_name,\n\n                 has_speed ? speed : 0, on_error, block_job_cb, bs, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto out;\n\n    }\n\n\n\n    trace_qmp_block_stream(bs, bs->job);\n\n\n\nout:\n\n    aio_context_release(aio_context);\n\n}\n", "idx": 25310}
{"project": "qemu", "commit_id": "dd321ecfc2e82e6f9578b986060b1aa3f036bd98", "target": 0, "func": "static gboolean check_old_packet_regular(void *opaque)\n\n{\n\n    CompareState *s = opaque;\n\n\n\n    /* if have old packet we will notify checkpoint */\n\n    colo_old_packet_check(s);\n\n\n\n    return TRUE;\n\n}\n", "idx": 25312}
{"project": "qemu", "commit_id": "7385aed20db5d83979f683b9d0048674411e963c", "target": 0, "func": "float64 helper_fsqrtd(CPUSPARCState *env, float64 src)\n\n{\n\n    float64 ret;\n\n    clear_float_exceptions(env);\n\n    ret = float64_sqrt(src, &env->fp_status);\n\n    check_ieee_exceptions(env);\n\n    return ret;\n\n}\n", "idx": 25313}
{"project": "qemu", "commit_id": "1c29331248d82e5a9caaf7974756a9d8bd5cd1e5", "target": 0, "func": "static int local_mknod(FsContext *ctx, const char *path, mode_t mode, dev_t dev)\n\n{\n\n    return mknod(rpath(ctx, path), mode, dev);\n\n}\n", "idx": 25314}
{"project": "qemu", "commit_id": "71ed827abd57dc7947ce3316118d0e601e70fac9", "target": 0, "func": "int ioinst_handle_msch(CPUS390XState *env, uint64_t reg1, uint32_t ipb)\n\n{\n\n    int cssid, ssid, schid, m;\n\n    SubchDev *sch;\n\n    SCHIB *schib;\n\n    uint64_t addr;\n\n    int ret = -ENODEV;\n\n    int cc;\n\n    hwaddr len = sizeof(*schib);\n\n\n\n    if (ioinst_disassemble_sch_ident(reg1, &m, &cssid, &ssid, &schid)) {\n\n        program_interrupt(env, PGM_OPERAND, 2);\n\n        return -EIO;\n\n    }\n\n    trace_ioinst_sch_id(\"msch\", cssid, ssid, schid);\n\n    addr = decode_basedisp_s(env, ipb);\n\n    if (addr & 3) {\n\n        program_interrupt(env, PGM_SPECIFICATION, 2);\n\n        return -EIO;\n\n    }\n\n    schib = s390_cpu_physical_memory_map(env, addr, &len, 0);\n\n    if (!schib || len != sizeof(*schib)) {\n\n        program_interrupt(env, PGM_ADDRESSING, 2);\n\n        cc = -EIO;\n\n        goto out;\n\n    }\n\n    if (!ioinst_schib_valid(schib)) {\n\n        program_interrupt(env, PGM_OPERAND, 2);\n\n        cc = -EIO;\n\n        goto out;\n\n    }\n\n    sch = css_find_subch(m, cssid, ssid, schid);\n\n    if (sch && css_subch_visible(sch)) {\n\n        ret = css_do_msch(sch, schib);\n\n    }\n\n    switch (ret) {\n\n    case -ENODEV:\n\n        cc = 3;\n\n        break;\n\n    case -EBUSY:\n\n        cc = 2;\n\n        break;\n\n    case 0:\n\n        cc = 0;\n\n        break;\n\n    default:\n\n        cc = 1;\n\n        break;\n\n    }\n\nout:\n\n    s390_cpu_physical_memory_unmap(env, schib, len, 0);\n\n    return cc;\n\n}\n", "idx": 25315}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "static void v9fs_readlink(void *opaque)\n\n{\n\n    V9fsPDU *pdu = opaque;\n\n    size_t offset = 7;\n\n    V9fsString target;\n\n    int32_t fid;\n\n    int err = 0;\n\n    V9fsFidState *fidp;\n\n\n\n    pdu_unmarshal(pdu, offset, \"d\", &fid);\n\n    trace_v9fs_readlink(pdu->tag, pdu->id, fid);\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n\n\n    v9fs_string_init(&target);\n\n    err = v9fs_co_readlink(pdu, &fidp->path, &target);\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n    offset += pdu_marshal(pdu, offset, \"s\", &target);\n\n    err = offset;\n\n    trace_v9fs_readlink_return(pdu->tag, pdu->id, target.data);\n\n    v9fs_string_free(&target);\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    complete_pdu(pdu->s, pdu, err);\n\n}\n", "idx": 25316}
{"project": "qemu", "commit_id": "1931e26054fdf2b1b84091f0b9662979eb6931ec", "target": 0, "func": "static void gt64120_write_config(PCIDevice *d, uint32_t address, uint32_t val,\n\n                                 int len)\n\n{\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    val = bswap32(val);\n\n#endif\n\n    pci_default_write_config(d, address, val, len);\n\n}\n", "idx": 25317}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void arm_thiswdog_write(void *opaque, target_phys_addr_t addr,\n\n                               uint64_t value, unsigned size)\n\n{\n\n    arm_mptimer_state *s = (arm_mptimer_state *)opaque;\n\n    int id = get_current_cpu(s);\n\n    timerblock_write(&s->timerblock[id * 2 + 1], addr, value, size);\n\n}\n", "idx": 25318}
{"project": "qemu", "commit_id": "048c74c4379789d03c857cea038ec00d95b68eaf", "target": 0, "func": "static void rtc_save_td(QEMUFile *f, void *opaque)\n\n{\n\n    RTCState *s = opaque;\n\n\n\n    qemu_put_be32(f, s->irq_coalesced);\n\n    qemu_put_be32(f, s->period);\n\n}\n", "idx": 25319}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void scsi_realize(SCSIDevice *dev, Error **errp)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, dev);\n\n    Error *err = NULL;\n\n\n\n    if (!s->qdev.conf.bs) {\n\n        error_setg(errp, \"drive property not set\");\n\n        return;\n\n    }\n\n\n\n    if (!(s->features & (1 << SCSI_DISK_F_REMOVABLE)) &&\n\n        !bdrv_is_inserted(s->qdev.conf.bs)) {\n\n        error_setg(errp, \"Device needs media, but drive is empty\");\n\n        return;\n\n    }\n\n\n\n    blkconf_serial(&s->qdev.conf, &s->serial);\n\n    if (dev->type == TYPE_DISK) {\n\n        blkconf_geometry(&dev->conf, NULL, 65535, 255, 255, &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (s->qdev.conf.discard_granularity == -1) {\n\n        s->qdev.conf.discard_granularity =\n\n            MAX(s->qdev.conf.logical_block_size, DEFAULT_DISCARD_GRANULARITY);\n\n    }\n\n\n\n    if (!s->version) {\n\n        s->version = g_strdup(qemu_get_version());\n\n    }\n\n    if (!s->vendor) {\n\n        s->vendor = g_strdup(\"QEMU\");\n\n    }\n\n\n\n    if (bdrv_is_sg(s->qdev.conf.bs)) {\n\n        error_setg(errp, \"unwanted /dev/sg*\");\n\n        return;\n\n    }\n\n\n\n    if ((s->features & (1 << SCSI_DISK_F_REMOVABLE)) &&\n\n            !(s->features & (1 << SCSI_DISK_F_NO_REMOVABLE_DEVOPS))) {\n\n        bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_removable_block_ops, s);\n\n    } else {\n\n        bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_block_ops, s);\n\n    }\n\n    bdrv_set_guest_block_size(s->qdev.conf.bs, s->qdev.blocksize);\n\n\n\n    bdrv_iostatus_enable(s->qdev.conf.bs);\n\n}\n", "idx": 25320}
{"project": "qemu", "commit_id": "debaaa114a8877a939533ba846e64168fb287b7b", "target": 0, "func": "static void ahci_shutdown(AHCIQState *ahci)\n\n{\n\n    QOSState *qs = ahci->parent;\n\n\n\n    ahci_clean_mem(ahci);\n\n    free_ahci_device(ahci->dev);\n\n    g_free(ahci);\n\n    qtest_shutdown(qs);\n\n}\n", "idx": 25321}
{"project": "qemu", "commit_id": "a78b1299f1bbb9608e3e3a36a7f16cf700a2789d", "target": 0, "func": "int cpu_signal_handler(int host_signum, void *pinfo,\n\n                       void *puc)\n\n{\n\n    siginfo_t *info = pinfo;\n\n#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)\n\n    ucontext_t *uc = puc;\n\n#else\n\n    ucontext_t *uc = puc;\n\n#endif\n\n    unsigned long pc;\n\n    int is_write;\n\n\n\n    pc = IAR_sig(uc);\n\n    is_write = 0;\n\n#if 0\n\n    /* ppc 4xx case */\n\n    if (DSISR_sig(uc) & 0x00800000) {\n\n        is_write = 1;\n\n    }\n\n#else\n\n    if (TRAP_sig(uc) != 0x400 && (DSISR_sig(uc) & 0x02000000)) {\n\n        is_write = 1;\n\n    }\n\n#endif\n\n    return handle_cpu_signal(pc, (unsigned long)info->si_addr,\n\n                             is_write, &uc->uc_sigmask);\n\n}\n", "idx": 25323}
{"project": "qemu", "commit_id": "bec93d7283b635aabaf0bbff67b6da7fc99e020a", "target": 0, "func": "static void gen_compute_eflags_c(DisasContext *s, TCGv reg, bool inv)\n\n{\n\n    TCGv t0, t1;\n\n    int size;\n\n\n\n    switch (s->cc_op) {\n\n    case CC_OP_SUBB ... CC_OP_SUBQ:\n\n        /* (DATA_TYPE)(CC_DST + CC_SRC) < (DATA_TYPE)CC_SRC */\n\n        size = s->cc_op - CC_OP_SUBB;\n\n        t1 = gen_ext_tl(cpu_tmp0, cpu_cc_src, size, false);\n\n        /* If no temporary was used, be careful not to alias t1 and t0.  */\n\n        t0 = TCGV_EQUAL(t1, cpu_cc_src) ? cpu_tmp0 : reg;\n\n        tcg_gen_add_tl(t0, cpu_cc_dst, cpu_cc_src);\n\n        gen_extu(size, t0);\n\n        goto add_sub;\n\n\n\n    case CC_OP_ADDB ... CC_OP_ADDQ:\n\n        /* (DATA_TYPE)CC_DST < (DATA_TYPE)CC_SRC */\n\n        size = s->cc_op - CC_OP_ADDB;\n\n        t1 = gen_ext_tl(cpu_tmp0, cpu_cc_src, size, false);\n\n        t0 = gen_ext_tl(reg, cpu_cc_dst, size, false);\n\n    add_sub:\n\n        tcg_gen_setcond_tl(inv ? TCG_COND_GEU : TCG_COND_LTU, reg, t0, t1);\n\n        inv = false;\n\n        break;\n\n\n\n    case CC_OP_SBBB ... CC_OP_SBBQ:\n\n        /* (DATA_TYPE)(CC_DST + CC_SRC + 1) <= (DATA_TYPE)CC_SRC */\n\n        size = s->cc_op - CC_OP_SBBB;\n\n        t1 = gen_ext_tl(cpu_tmp0, cpu_cc_src, size, false);\n\n        if (TCGV_EQUAL(t1, reg) && TCGV_EQUAL(reg, cpu_cc_src)) {\n\n            tcg_gen_mov_tl(cpu_tmp0, cpu_cc_src);\n\n            t1 = cpu_tmp0;\n\n        }\n\n\n\n        tcg_gen_add_tl(reg, cpu_cc_dst, cpu_cc_src);\n\n        tcg_gen_addi_tl(reg, reg, 1);\n\n        gen_extu(size, reg);\n\n        t0 = reg;\n\n        goto adc_sbb;\n\n\n\n    case CC_OP_ADCB ... CC_OP_ADCQ:\n\n        /* (DATA_TYPE)CC_DST <= (DATA_TYPE)CC_SRC */\n\n        size = s->cc_op - CC_OP_ADCB;\n\n        t1 = gen_ext_tl(cpu_tmp0, cpu_cc_src, size, false);\n\n        t0 = gen_ext_tl(reg, cpu_cc_dst, size, false);\n\n    adc_sbb:\n\n        tcg_gen_setcond_tl(inv ? TCG_COND_GTU : TCG_COND_LEU, reg, t0, t1);\n\n        inv = false;\n\n        break;\n\n\n\n    case CC_OP_LOGICB ... CC_OP_LOGICQ:\n\n        tcg_gen_movi_tl(reg, 0);\n\n        break;\n\n\n\n    case CC_OP_INCB ... CC_OP_INCQ:\n\n    case CC_OP_DECB ... CC_OP_DECQ:\n\n        if (inv) {\n\n            tcg_gen_xori_tl(reg, cpu_cc_src, 1);\n\n        } else {\n\n            tcg_gen_mov_tl(reg, cpu_cc_src);\n\n        }\n\n        inv = false;\n\n        break;\n\n\n\n    case CC_OP_SHLB ... CC_OP_SHLQ:\n\n        /* (CC_SRC >> (DATA_BITS - 1)) & 1 */\n\n        size = s->cc_op - CC_OP_SHLB;\n\n        tcg_gen_shri_tl(reg, cpu_cc_src, (8 << size) - 1);\n\n        tcg_gen_andi_tl(reg, reg, 1);\n\n        break;\n\n\n\n    case CC_OP_MULB ... CC_OP_MULQ:\n\n        tcg_gen_setcondi_tl(inv ? TCG_COND_EQ : TCG_COND_NE,\n\n                            reg, cpu_cc_src, 0);\n\n        inv = false;\n\n        break;\n\n\n\n    case CC_OP_EFLAGS:\n\n    case CC_OP_SARB ... CC_OP_SARQ:\n\n        /* CC_SRC & 1 */\n\n        tcg_gen_andi_tl(reg, cpu_cc_src, 1);\n\n        break;\n\n\n\n    default:\n\n       /* The need to compute only C from CC_OP_DYNAMIC is important\n\n          in efficiently implementing e.g. INC at the start of a TB.  */\n\n       gen_update_cc_op(s);\n\n       gen_helper_cc_compute_c(cpu_tmp2_i32, cpu_env, cpu_cc_op);\n\n       tcg_gen_extu_i32_tl(reg, cpu_tmp2_i32);\n\n       break;\n\n    }\n\n    if (inv) {\n\n        tcg_gen_xori_tl(reg, reg, 1);\n\n    }\n\n}\n", "idx": 25324}
{"project": "qemu", "commit_id": "3f66f764ee25f10d3e1144ebc057a949421b7728", "target": 0, "func": "static void test_struct(gconstpointer opaque)\n\n{\n\n    TestArgs *args = (TestArgs *) opaque;\n\n    const SerializeOps *ops = args->ops;\n\n    TestStruct *ts = struct_create();\n\n    TestStruct *ts_copy = NULL;\n\n    Error *err = NULL;\n\n    void *serialize_data;\n\n\n\n    ops->serialize(ts, &serialize_data, visit_struct, &err);\n\n    ops->deserialize((void **)&ts_copy, serialize_data, visit_struct, &err); \n\n\n\n    g_assert(err == NULL);\n\n    struct_compare(ts, ts_copy);\n\n\n\n    struct_cleanup(ts);\n\n    struct_cleanup(ts_copy);\n\n\n\n    ops->cleanup(serialize_data);\n\n    g_free(args);\n\n}\n", "idx": 25325}
{"project": "qemu", "commit_id": "6701e5514beab7b781a10424a94e9850c707287c", "target": 0, "func": "static void net_socket_connected(int fd, Error *err, void *opaque)\n\n{\n\n    socket_connect_data *c = opaque;\n\n    NetSocketState *s;\n\n    char *addr_str = NULL;\n\n    Error *local_error = NULL;\n\n\n\n    addr_str = socket_address_to_string(c->saddr, &local_error);\n\n    if (addr_str == NULL) {\n\n        error_report_err(local_error);\n\n        closesocket(fd);\n\n        goto end;\n\n    }\n\n\n\n    s = net_socket_fd_init(c->peer, c->model, c->name, fd, true);\n\n    if (!s) {\n\n        closesocket(fd);\n\n        goto end;\n\n    }\n\n\n\n    snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n\n             \"socket: connect to %s\", addr_str);\n\n\n\nend:\n\n    g_free(addr_str);\n\n    socket_connect_data_free(c);\n\n}\n", "idx": 25326}
{"project": "qemu", "commit_id": "6e0d8677cb443e7408c0b7a25a93c6596d7fa380", "target": 0, "func": "void OPPROTO op_decw_ECX(void)\n\n{\n\n    ECX = (ECX & ~0xffff) | ((ECX - 1) & 0xffff);\n\n}\n", "idx": 25327}
{"project": "qemu", "commit_id": "76655d6dece88bd00e190956e8e4285b682edcbb", "target": 0, "func": "static int vnc_auth_sasl_check_access(VncState *vs)\n\n{\n\n    const void *val;\n\n    int err;\n\n\n\n    err = sasl_getprop(vs->sasl.conn, SASL_USERNAME, &val);\n\n    if (err != SASL_OK) {\n\n\tVNC_DEBUG(\"cannot query SASL username on connection %d (%s)\\n\",\n\n\t\t  err, sasl_errstring(err, NULL, NULL));\n\n\treturn -1;\n\n    }\n\n    if (val == NULL) {\n\n\tVNC_DEBUG(\"no client username was found\\n\");\n\n\treturn -1;\n\n    }\n\n    VNC_DEBUG(\"SASL client username %s\\n\", (const char *)val);\n\n\n\n    vs->sasl.username = qemu_strdup((const char*)val);\n\n\n\n    return 0;\n\n}\n", "idx": 25328}
{"project": "qemu", "commit_id": "b626b51a6721e53817155af720243f59072e424f", "target": 0, "func": "ssize_t nbd_send_request(QIOChannel *ioc, struct nbd_request *request)\n\n{\n\n    uint8_t buf[NBD_REQUEST_SIZE];\n\n    ssize_t ret;\n\n\n\n    TRACE(\"Sending request to server: \"\n\n          \"{ .from = %\" PRIu64\", .len = %\" PRIu32 \", .handle = %\" PRIu64\n\n          \", .type=%\" PRIu32 \" }\",\n\n          request->from, request->len, request->handle, request->type);\n\n\n\n    stl_be_p(buf, NBD_REQUEST_MAGIC);\n\n    stl_be_p(buf + 4, request->type);\n\n    stq_be_p(buf + 8, request->handle);\n\n    stq_be_p(buf + 16, request->from);\n\n    stl_be_p(buf + 24, request->len);\n\n\n\n    ret = write_sync(ioc, buf, sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    if (ret != sizeof(buf)) {\n\n        LOG(\"writing to socket failed\");\n\n        return -EINVAL;\n\n    }\n\n    return 0;\n\n}\n", "idx": 25329}
{"project": "qemu", "commit_id": "4f2d31fbc0bfdf41feea7d1be49f4f7ffa005534", "target": 1, "func": "static void json_message_process_token(JSONLexer *lexer, QString *token, JSONTokenType type, int x, int y)\n\n{\n\n    JSONMessageParser *parser = container_of(lexer, JSONMessageParser, lexer);\n\n    QDict *dict;\n\n\n\n    if (type == JSON_OPERATOR) {\n\n        switch (qstring_get_str(token)[0]) {\n\n        case '{':\n\n            parser->brace_count++;\n\n            break;\n\n        case '}':\n\n            parser->brace_count--;\n\n            break;\n\n        case '[':\n\n            parser->bracket_count++;\n\n            break;\n\n        case ']':\n\n            parser->bracket_count--;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n\n\n    dict = qdict_new();\n\n    qdict_put(dict, \"type\", qint_from_int(type));\n\n    QINCREF(token);\n\n    qdict_put(dict, \"token\", token);\n\n    qdict_put(dict, \"x\", qint_from_int(x));\n\n    qdict_put(dict, \"y\", qint_from_int(y));\n\n\n\n    parser->token_size += token->length;\n\n\n\n    qlist_append(parser->tokens, dict);\n\n\n\n    if (type == JSON_ERROR) {\n\n        goto out_emit_bad;\n\n    } else if (parser->brace_count < 0 ||\n\n        parser->bracket_count < 0 ||\n\n        (parser->brace_count == 0 &&\n\n         parser->bracket_count == 0)) {\n\n        goto out_emit;\n\n    } else if (parser->token_size > MAX_TOKEN_SIZE ||\n\n               parser->bracket_count > MAX_NESTING ||\n\n               parser->brace_count > MAX_NESTING) {\n\n        /* Security consideration, we limit total memory allocated per object\n\n         * and the maximum recursion depth that a message can force.\n\n         */\n\n        goto out_emit;\n\n    }\n\n\n\n    return;\n\n\n\nout_emit_bad:\n\n    /* clear out token list and tell the parser to emit and error\n\n     * indication by passing it a NULL list\n\n     */\n\n    QDECREF(parser->tokens);\n\n    parser->tokens = NULL;\n\nout_emit:\n\n    /* send current list of tokens to parser and reset tokenizer */\n\n    parser->brace_count = 0;\n\n    parser->bracket_count = 0;\n\n    parser->emit(parser, parser->tokens);\n\n    if (parser->tokens) {\n\n        QDECREF(parser->tokens);\n\n    }\n\n    parser->tokens = qlist_new();\n\n    parser->token_size = 0;\n\n}\n", "idx": 25330}
{"project": "qemu", "commit_id": "c5a49c63fa26e8825ad101dfe86339ae4c216539", "target": 1, "func": "static bool gen_wsr_ccompare(DisasContext *dc, uint32_t sr, TCGv_i32 v)\n\n{\n\n    uint32_t id = sr - CCOMPARE;\n\n    bool ret = false;\n\n\n\n    if (id < dc->config->nccompare) {\n\n        uint32_t int_bit = 1 << dc->config->timerint[id];\n\n        TCGv_i32 tmp = tcg_const_i32(id);\n\n\n\n        tcg_gen_mov_i32(cpu_SR[sr], v);\n\n        tcg_gen_andi_i32(cpu_SR[INTSET], cpu_SR[INTSET], ~int_bit);\n\n        if (dc->tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n        }\n\n        gen_helper_update_ccompare(cpu_env, tmp);\n\n        if (dc->tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jumpi_check_loop_end(dc, 0);\n\n            ret = true;\n\n        }\n\n        tcg_temp_free(tmp);\n\n    }\n\n    return ret;\n\n}\n", "idx": 25331}
{"project": "qemu", "commit_id": "6cec5487990bf3f1f22b3fcb871978255e92ae0d", "target": 1, "func": "static void vnc_write_pixels_generic(VncState *vs, void *pixels1, int size)\n\n{\n\n    uint8_t buf[4];\n\n\n\n    if (vs->depth == 4) {\n\n        uint32_t *pixels = pixels1;\n\n        int n, i;\n\n        n = size >> 2;\n\n        for(i = 0; i < n; i++) {\n\n            vnc_convert_pixel(vs, buf, pixels[i]);\n\n            vnc_write(vs, buf, vs->pix_bpp);\n\n        }\n\n    } else if (vs->depth == 2) {\n\n        uint16_t *pixels = pixels1;\n\n        int n, i;\n\n        n = size >> 1;\n\n        for(i = 0; i < n; i++) {\n\n            vnc_convert_pixel(vs, buf, pixels[i]);\n\n            vnc_write(vs, buf, vs->pix_bpp);\n\n        }\n\n    } else if (vs->depth == 1) {\n\n        uint8_t *pixels = pixels1;\n\n        int n, i;\n\n        n = size;\n\n        for(i = 0; i < n; i++) {\n\n            vnc_convert_pixel(vs, buf, pixels[i]);\n\n            vnc_write(vs, buf, vs->pix_bpp);\n\n        }\n\n    } else {\n\n        fprintf(stderr, \"vnc_write_pixels_generic: VncState color depth not supported\\n\");\n\n    }\n\n}\n", "idx": 25332}
{"project": "qemu", "commit_id": "cf143ad35018c5fc1da6365b45acda2b34aba90a", "target": 1, "func": "static uint64_t mv88w8618_eth_read(void *opaque, hwaddr offset,\n\n                                   unsigned size)\n\n{\n\n    mv88w8618_eth_state *s = opaque;\n\n\n\n    switch (offset) {\n\n    case MP_ETH_SMIR:\n\n        if (s->smir & MP_ETH_SMIR_OPCODE) {\n\n            switch (s->smir & MP_ETH_SMIR_ADDR) {\n\n            case MP_ETH_PHY1_BMSR:\n\n                return MP_PHY_BMSR_LINK | MP_PHY_BMSR_AUTONEG |\n\n                       MP_ETH_SMIR_RDVALID;\n\n            case MP_ETH_PHY1_PHYSID1:\n\n                return (MP_PHY_88E3015 >> 16) | MP_ETH_SMIR_RDVALID;\n\n            case MP_ETH_PHY1_PHYSID2:\n\n                return (MP_PHY_88E3015 & 0xFFFF) | MP_ETH_SMIR_RDVALID;\n\n            default:\n\n                return MP_ETH_SMIR_RDVALID;\n\n            }\n\n        }\n\n        return 0;\n\n\n\n    case MP_ETH_ICR:\n\n        return s->icr;\n\n\n\n    case MP_ETH_IMR:\n\n        return s->imr;\n\n\n\n    case MP_ETH_FRDP0 ... MP_ETH_FRDP3:\n\n        return s->frx_queue[(offset - MP_ETH_FRDP0)/4];\n\n\n\n    case MP_ETH_CRDP0 ... MP_ETH_CRDP3:\n\n        return s->rx_queue[(offset - MP_ETH_CRDP0)/4];\n\n\n\n    case MP_ETH_CTDP0 ... MP_ETH_CTDP3:\n\n        return s->tx_queue[(offset - MP_ETH_CTDP0)/4];\n\n\n\n    default:\n\n        return 0;\n\n    }\n\n}\n", "idx": 25334}
{"project": "qemu", "commit_id": "bb89c2e901b1a0c1cb6b94392cae1f98e6660ed7", "target": 1, "func": "static void monitor_call_handler(Monitor *mon, const mon_cmd_t *cmd,\n\n                                 const QDict *params)\n\n{\n\n    QObject *data = NULL;\n\n\n\n    cmd->mhandler.cmd_new(mon, params, &data);\n\n\n\n    if (is_async_return(data)) {\n\n        /*\n\n         * Asynchronous commands have no initial return data but they can\n\n         * generate errors.  Data is returned via the async completion handler.\n\n         */\n\n        if (monitor_ctrl_mode(mon) && monitor_has_error(mon)) {\n\n            monitor_protocol_emitter(mon, NULL);\n\n        }\n\n    } else if (monitor_ctrl_mode(mon)) {\n\n        /* Monitor Protocol */\n\n        monitor_protocol_emitter(mon, data);\n\n    } else {\n\n        /* User Protocol */\n\n         if (data)\n\n            cmd->user_print(mon, data);\n\n    }\n\n\n\n    qobject_decref(data);\n\n}\n", "idx": 25336}
{"project": "qemu", "commit_id": "cfc87e00c22ab4ea0262c9771c803ed03d754001", "target": 1, "func": "static inline int64_t get_image_offset(BlockDriverState *bs, uint64_t offset,\n\n                                       bool write)\n\n{\n\n    BDRVVPCState *s = bs->opaque;\n\n    uint64_t bitmap_offset, block_offset;\n\n    uint32_t pagetable_index, offset_in_block;\n\n\n\n    pagetable_index = offset / s->block_size;\n\n    offset_in_block = offset % s->block_size;\n\n\n\n    if (pagetable_index >= s->max_table_entries || s->pagetable[pagetable_index] == 0xffffffff)\n\n        return -1; /* not allocated */\n\n\n\n    bitmap_offset = 512 * (uint64_t) s->pagetable[pagetable_index];\n\n    block_offset = bitmap_offset + s->bitmap_size + offset_in_block;\n\n\n\n    /* We must ensure that we don't write to any sectors which are marked as\n\n       unused in the bitmap. We get away with setting all bits in the block\n\n       bitmap each time we write to a new block. This might cause Virtual PC to\n\n       miss sparse read optimization, but it's not a problem in terms of\n\n       correctness. */\n\n    if (write && (s->last_bitmap_offset != bitmap_offset)) {\n\n        uint8_t bitmap[s->bitmap_size];\n\n\n\n        s->last_bitmap_offset = bitmap_offset;\n\n        memset(bitmap, 0xff, s->bitmap_size);\n\n        bdrv_pwrite_sync(bs->file, bitmap_offset, bitmap, s->bitmap_size);\n\n    }\n\n\n\n    return block_offset;\n\n}\n", "idx": 25337}
{"project": "qemu", "commit_id": "af7e9e74c6a62a5bcd911726a9e88d28b61490e0", "target": 1, "func": "static void openpic_tmr_write(void *opaque, hwaddr addr, uint64_t val,\n\n                                unsigned len)\n\n{\n\n    OpenPICState *opp = opaque;\n\n    int idx;\n\n\n\n    DPRINTF(\"%s: addr %08x <= %08x\\n\", __func__, addr, val);\n\n    if (addr & 0xF)\n\n        return;\n\n    idx = (addr >> 6) & 0x3;\n\n    addr = addr & 0x30;\n\n\n\n    if (addr == 0x0) {\n\n        /* TIFR (TFRR) */\n\n        opp->tifr = val;\n\n        return;\n\n    }\n\n    switch (addr & 0x30) {\n\n    case 0x00: /* TICC (GTCCR) */\n\n        break;\n\n    case 0x10: /* TIBC (GTBCR) */\n\n        if ((opp->timers[idx].ticc & TICC_TOG) != 0 &&\n\n            (val & TIBC_CI) == 0 &&\n\n            (opp->timers[idx].tibc & TIBC_CI) != 0) {\n\n            opp->timers[idx].ticc &= ~TICC_TOG;\n\n        }\n\n        opp->timers[idx].tibc = val;\n\n        break;\n\n    case 0x20: /* TIVP (GTIVPR) */\n\n        write_IRQreg_ipvp(opp, opp->irq_tim0 + idx, val);\n\n        break;\n\n    case 0x30: /* TIDE (GTIDR) */\n\n        write_IRQreg_ide(opp, opp->irq_tim0 + idx, val);\n\n        break;\n\n    }\n\n}\n", "idx": 25338}
{"project": "qemu", "commit_id": "aedbe19297907143f17b733a7ff0e0534377bed1", "target": 1, "func": "int load_vmstate(const char *name, Error **errp)\n\n{\n\n    BlockDriverState *bs, *bs_vm_state;\n\n    QEMUSnapshotInfo sn;\n\n    QEMUFile *f;\n\n    int ret;\n\n    AioContext *aio_context;\n\n    MigrationIncomingState *mis = migration_incoming_get_current();\n\n\n\n    if (!bdrv_all_can_snapshot(&bs)) {\n\n        error_setg(errp,\n\n                   \"Device '%s' is writable but does not support snapshots\",\n\n                   bdrv_get_device_name(bs));\n\n        return -ENOTSUP;\n\n    }\n\n    ret = bdrv_all_find_snapshot(name, &bs);\n\n    if (ret < 0) {\n\n        error_setg(errp,\n\n                   \"Device '%s' does not have the requested snapshot '%s'\",\n\n                   bdrv_get_device_name(bs), name);\n\n        return ret;\n\n    }\n\n\n\n    bs_vm_state = bdrv_all_find_vmstate_bs();\n\n    if (!bs_vm_state) {\n\n        error_setg(errp, \"No block device supports snapshots\");\n\n        return -ENOTSUP;\n\n    }\n\n    aio_context = bdrv_get_aio_context(bs_vm_state);\n\n\n\n    /* Don't even try to load empty VM states */\n\n    aio_context_acquire(aio_context);\n\n    ret = bdrv_snapshot_find(bs_vm_state, &sn, name);\n\n    aio_context_release(aio_context);\n\n    if (ret < 0) {\n\n        return ret;\n\n    } else if (sn.vm_state_size == 0) {\n\n        error_setg(errp, \"This is a disk-only snapshot. Revert to it \"\n\n                   \" offline using qemu-img\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* Flush all IO requests so they don't interfere with the new state.  */\n\n    bdrv_drain_all();\n\n\n\n    ret = bdrv_all_goto_snapshot(name, &bs);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Error %d while activating snapshot '%s' on '%s'\",\n\n                     ret, name, bdrv_get_device_name(bs));\n\n        return ret;\n\n    }\n\n\n\n    /* restore the VM state */\n\n    f = qemu_fopen_bdrv(bs_vm_state, 0);\n\n    if (!f) {\n\n        error_setg(errp, \"Could not open VM state file\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    qemu_system_reset(VMRESET_SILENT);\n\n    mis->from_src_file = f;\n\n\n\n    aio_context_acquire(aio_context);\n\n    ret = qemu_loadvm_state(f);\n\n    qemu_fclose(f);\n\n    aio_context_release(aio_context);\n\n\n\n    migration_incoming_state_destroy();\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Error %d while loading VM state\", ret);\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 25339}
{"project": "qemu", "commit_id": "dc2c4eca89ec5ee7b7a4c2563c991a14a7c5ee84", "target": 1, "func": "CharDriverState *qemu_chr_new_from_opts(QemuOpts *opts,\n\n                                    void (*init)(struct CharDriverState *s),\n\n                                    Error **errp)\n\n{\n\n    CharDriver *cd;\n\n    CharDriverState *chr;\n\n    GSList *i;\n\n\n\n    if (qemu_opts_id(opts) == NULL) {\n\n        error_setg(errp, \"chardev: no id specified\");\n\n        goto err;\n\n    }\n\n\n\n    if (qemu_opt_get(opts, \"backend\") == NULL) {\n\n        error_setg(errp, \"chardev: \\\"%s\\\" missing backend\",\n\n                   qemu_opts_id(opts));\n\n        goto err;\n\n    }\n\n    for (i = backends; i; i = i->next) {\n\n        cd = i->data;\n\n\n\n        if (strcmp(cd->name, qemu_opt_get(opts, \"backend\")) == 0) {\n\n            break;\n\n        }\n\n    }\n\n    if (i == NULL) {\n\n        error_setg(errp, \"chardev: backend \\\"%s\\\" not found\",\n\n                   qemu_opt_get(opts, \"backend\"));\n\n        goto err;\n\n    }\n\n\n\n    if (!cd->open) {\n\n        /* using new, qapi init */\n\n        ChardevBackend *backend = g_new0(ChardevBackend, 1);\n\n        ChardevReturn *ret = NULL;\n\n        const char *id = qemu_opts_id(opts);\n\n        const char *bid = NULL;\n\n\n\n        if (qemu_opt_get_bool(opts, \"mux\", 0)) {\n\n            bid = g_strdup_printf(\"%s-base\", id);\n\n        }\n\n\n\n        chr = NULL;\n\n        backend->kind = cd->kind;\n\n        if (cd->parse) {\n\n            cd->parse(opts, backend, errp);\n\n            if (error_is_set(errp)) {\n\n                goto qapi_out;\n\n            }\n\n        }\n\n        ret = qmp_chardev_add(bid ? bid : id, backend, errp);\n\n        if (error_is_set(errp)) {\n\n            goto qapi_out;\n\n        }\n\n\n\n        if (bid) {\n\n            qapi_free_ChardevBackend(backend);\n\n            qapi_free_ChardevReturn(ret);\n\n            backend = g_new0(ChardevBackend, 1);\n\n            backend->mux = g_new0(ChardevMux, 1);\n\n            backend->kind = CHARDEV_BACKEND_KIND_MUX;\n\n            backend->mux->chardev = g_strdup(bid);\n\n            ret = qmp_chardev_add(id, backend, errp);\n\n            if (error_is_set(errp)) {\n\n                goto qapi_out;\n\n            }\n\n        }\n\n\n\n        chr = qemu_chr_find(id);\n\n\n\n    qapi_out:\n\n        qapi_free_ChardevBackend(backend);\n\n        qapi_free_ChardevReturn(ret);\n\n        return chr;\n\n    }\n\n\n\n    chr = cd->open(opts);\n\n    if (!chr) {\n\n        error_setg(errp, \"chardev: opening backend \\\"%s\\\" failed\",\n\n                   qemu_opt_get(opts, \"backend\"));\n\n        goto err;\n\n    }\n\n\n\n    if (!chr->filename)\n\n        chr->filename = g_strdup(qemu_opt_get(opts, \"backend\"));\n\n    chr->init = init;\n\n    /* if we didn't create the chardev via qmp_chardev_add, we\n\n     * need to send the OPENED event here\n\n     */\n\n    if (!chr->explicit_be_open) {\n\n        qemu_chr_be_event(chr, CHR_EVENT_OPENED);\n\n    }\n\n    QTAILQ_INSERT_TAIL(&chardevs, chr, next);\n\n\n\n    if (qemu_opt_get_bool(opts, \"mux\", 0)) {\n\n        CharDriverState *base = chr;\n\n        int len = strlen(qemu_opts_id(opts)) + 6;\n\n        base->label = g_malloc(len);\n\n        snprintf(base->label, len, \"%s-base\", qemu_opts_id(opts));\n\n        chr = qemu_chr_open_mux(base);\n\n        chr->filename = base->filename;\n\n        chr->avail_connections = MAX_MUX;\n\n        QTAILQ_INSERT_TAIL(&chardevs, chr, next);\n\n    } else {\n\n        chr->avail_connections = 1;\n\n    }\n\n    chr->label = g_strdup(qemu_opts_id(opts));\n\n    chr->opts = opts;\n\n    return chr;\n\n\n\nerr:\n\n    qemu_opts_del(opts);\n\n    return NULL;\n\n}\n", "idx": 25340}
{"project": "qemu", "commit_id": "0b7a4a97119eefc2c39c5f34602df9e1cc0f493b", "target": 1, "func": "static int init_directory(BDRVVVFATState* s,const char* dirname)\n\n{\n\n    bootsector_t* bootsector=(bootsector_t*)&(s->first_sectors[(s->first_sectors_number-1)*0x200]);\n\n    unsigned int i;\n\n    unsigned int cluster;\n\n\n\n    memset(&(s->first_sectors[0]),0,0x40*0x200);\n\n\n\n    /* TODO: if FAT32, this is probably wrong */\n\n    s->sectors_per_fat=0xfc;\n\n    s->sectors_per_cluster=0x10;\n\n    s->cluster_size=s->sectors_per_cluster*0x200;\n\n    s->cluster=malloc(s->cluster_size);\n\n    \n\n    array_init(&(s->mapping),sizeof(mapping_t));\n\n    array_init(&(s->directory),sizeof(direntry_t));\n\n    array_init(&(s->commit),sizeof(commit_t));\n\n\n\n    /* add volume label */\n\n    {\n\n\tdirentry_t* entry=array_get_next(&(s->directory));\n\n\tentry->attributes=0x28; /* archive | volume label */\n\n\tsnprintf(entry->name,11,\"QEMU VVFAT\");\n\n    }\n\n\n\n    if(read_directory(s,dirname,0))\n\n\treturn -1;\n\n\n\n    /* make sure that the number of directory entries is multiple of 0x200/0x20 (to fit the last sector exactly) */\n\n    s->sectors_for_directory=s->directory.next/0x10;\n\n\n\n    s->faked_sectors=s->first_sectors_number+s->sectors_per_fat*2+s->sectors_for_directory;\n\n    s->cluster_count=(s->sector_count-s->faked_sectors)/s->sectors_per_cluster;\n\n\n\n    /* Now build FAT, and write back information into directory */\n\n    init_fat(s);\n\n\n\n    cluster=s->sectors_for_directory/s->sectors_per_cluster;\n\n    assert(s->sectors_for_directory%s->sectors_per_cluster==0);\n\n\n\n    /* set the end of the last read directory */\n\n    if(s->first_file_mapping>0) {\n\n\tmapping_t* mapping=array_get(&(s->mapping),s->first_file_mapping-1);\n\n\tmapping->end=cluster;\n\n    }\n\n\n\n    for(i=1;i<s->mapping.next;i++) {\n\n\tmapping_t* mapping=array_get(&(s->mapping),i);\n\n\tdirentry_t* direntry=array_get(&(s->directory),mapping->dir_index);\n\n\tif(mapping->mode==MODE_DIRECTORY) {\n\n\t    /* directory */\n\n\t    int i;\n\n#ifdef DEBUG\n\n\t    fprintf(stderr,\"assert: %s %d < %d\\n\",mapping->filename,(int)mapping->begin,(int)mapping->end);\n\n#endif\n\n\t    assert(mapping->begin<mapping->end);\n\n\t    for(i=mapping->begin;i<mapping->end-1;i++)\n\n\t\tfat_set(s,i,i+1);\n\n\t    fat_set(s,i,0x7fffffff);\n\n\t} else {\n\n\t    /* as the space is virtual, we can be sloppy about it */\n\n\t    unsigned int end_cluster=cluster+mapping->end/s->cluster_size;\n\n\n\n\t    if(end_cluster>=s->cluster_count) {\n\n\t\tfprintf(stderr,\"Directory does not fit in FAT%d\\n\",s->fat_type);\n\n\t\treturn -1;\n\n\t    }\n\n\t    mapping->begin=cluster;\n\n\t    mapping->mode=MODE_NORMAL;\n\n\t    mapping->offset=0;\n\n\t    direntry->size=cpu_to_le32(mapping->end);\n\n\t    if(direntry->size==0) {\n\n\t\tdirentry->begin=0;\n\n\t\tmapping->end=cluster;\n\n\t\tcontinue;\n\n\t    }\n\n\n\n\t    direntry->begin=cpu_to_le16(cluster);\n\n\t    mapping->end=end_cluster+1;\n\n\t    for(;cluster<end_cluster;cluster++)\n\n\t        fat_set(s,cluster,cluster+1);\n\n\t    fat_set(s,cluster,0x7fffffff);\n\n\t    cluster++;\n\n\t}\n\n    }\n\n\n\n    s->current_mapping=0;\n\n\n\n    bootsector->jump[0]=0xeb;\n\n    bootsector->jump[1]=0x3e;\n\n    bootsector->jump[2]=0x90;\n\n    memcpy(bootsector->name,\"QEMU    \",8);\n\n    bootsector->sector_size=cpu_to_le16(0x200);\n\n    bootsector->sectors_per_cluster=s->sectors_per_cluster;\n\n    bootsector->reserved_sectors=cpu_to_le16(1);\n\n    bootsector->number_of_fats=0x2; /* number of FATs */\n\n    bootsector->root_entries=cpu_to_le16(s->sectors_of_root_directory*0x10);\n\n    bootsector->zero=0;\n\n    bootsector->media_type=(s->first_sectors_number==1?0xf0:0xf8); /* media descriptor */\n\n    bootsector->sectors_per_fat=cpu_to_le16(s->sectors_per_fat);\n\n    bootsector->sectors_per_track=cpu_to_le16(0x3f);\n\n    bootsector->number_of_heads=cpu_to_le16(0x10);\n\n    bootsector->hidden_sectors=cpu_to_le32(s->first_sectors_number==1?0:0x3f);\n\n    /* TODO: if FAT32, adjust */\n\n    bootsector->total_sectors=cpu_to_le32(s->sector_count);\n\n\n\n    /* TODO: if FAT32, this is wrong */\n\n    bootsector->u.fat16.drive_number=0x80; /* assume this is hda (TODO) */\n\n    bootsector->u.fat16.current_head=0;\n\n    bootsector->u.fat16.signature=0x29;\n\n    bootsector->u.fat16.id=cpu_to_le32(0xfabe1afd);\n\n\n\n    memcpy(bootsector->u.fat16.volume_label,\"QEMU VVFAT \",11);\n\n    memcpy(bootsector->fat_type,(s->fat_type==12?\"FAT12   \":s->fat_type==16?\"FAT16   \":\"FAT32   \"),8);\n\n    bootsector->magic[0]=0x55; bootsector->magic[1]=0xaa;\n\n\n\n    return 0;\n\n}\n", "idx": 25342}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void zynq_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    ObjectClass *cpu_oc;\n\n    ARMCPU *cpu;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ext_ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ocm_ram = g_new(MemoryRegion, 1);\n\n    DeviceState *dev;\n\n    SysBusDevice *busdev;\n\n    qemu_irq pic[64];\n\n    Error *err = NULL;\n\n    int n;\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"cortex-a9\";\n\n    }\n\n    cpu_oc = cpu_class_by_name(TYPE_ARM_CPU, cpu_model);\n\n\n\n    cpu = ARM_CPU(object_new(object_class_get_name(cpu_oc)));\n\n\n\n    object_property_set_int(OBJECT(cpu), ZYNQ_BOARD_MIDR, \"midr\", &err);\n\n    if (err) {\n\n        error_report(\"%s\", error_get_pretty(err));\n\n        exit(1);\n\n    }\n\n\n\n    object_property_set_int(OBJECT(cpu), MPCORE_PERIPHBASE, \"reset-cbar\", &err);\n\n    if (err) {\n\n        error_report(\"%s\", error_get_pretty(err));\n\n        exit(1);\n\n    }\n\n    object_property_set_bool(OBJECT(cpu), true, \"realized\", &err);\n\n    if (err) {\n\n        error_report(\"%s\", error_get_pretty(err));\n\n        exit(1);\n\n    }\n\n\n\n    /* max 2GB ram */\n\n    if (ram_size > 0x80000000) {\n\n        ram_size = 0x80000000;\n\n    }\n\n\n\n    /* DDR remapped to address zero.  */\n\n    memory_region_init_ram(ext_ram, NULL, \"zynq.ext_ram\", ram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(ext_ram);\n\n    memory_region_add_subregion(address_space_mem, 0, ext_ram);\n\n\n\n    /* 256K of on-chip memory */\n\n    memory_region_init_ram(ocm_ram, NULL, \"zynq.ocm_ram\", 256 << 10,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(ocm_ram);\n\n    memory_region_add_subregion(address_space_mem, 0xFFFC0000, ocm_ram);\n\n\n\n    DriveInfo *dinfo = drive_get(IF_PFLASH, 0, 0);\n\n\n\n    /* AMD */\n\n    pflash_cfi02_register(0xe2000000, NULL, \"zynq.pflash\", FLASH_SIZE,\n\n                          dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                          FLASH_SECTOR_SIZE,\n\n                          FLASH_SIZE/FLASH_SECTOR_SIZE, 1,\n\n                          1, 0x0066, 0x0022, 0x0000, 0x0000, 0x0555, 0x2aa,\n\n                              0);\n\n\n\n    dev = qdev_create(NULL, \"xilinx,zynq_slcr\");\n\n    qdev_init_nofail(dev);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xF8000000);\n\n\n\n    dev = qdev_create(NULL, \"a9mpcore_priv\");\n\n    qdev_prop_set_uint32(dev, \"num-cpu\", 1);\n\n    qdev_init_nofail(dev);\n\n    busdev = SYS_BUS_DEVICE(dev);\n\n    sysbus_mmio_map(busdev, 0, MPCORE_PERIPHBASE);\n\n    sysbus_connect_irq(busdev, 0,\n\n                       qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_IRQ));\n\n\n\n    for (n = 0; n < 64; n++) {\n\n        pic[n] = qdev_get_gpio_in(dev, n);\n\n    }\n\n\n\n    zynq_init_spi_flashes(0xE0006000, pic[58-IRQ_OFFSET], false);\n\n    zynq_init_spi_flashes(0xE0007000, pic[81-IRQ_OFFSET], false);\n\n    zynq_init_spi_flashes(0xE000D000, pic[51-IRQ_OFFSET], true);\n\n\n\n    sysbus_create_simple(\"xlnx,ps7-usb\", 0xE0002000, pic[53-IRQ_OFFSET]);\n\n    sysbus_create_simple(\"xlnx,ps7-usb\", 0xE0003000, pic[76-IRQ_OFFSET]);\n\n\n\n    sysbus_create_simple(\"cadence_uart\", 0xE0000000, pic[59-IRQ_OFFSET]);\n\n    sysbus_create_simple(\"cadence_uart\", 0xE0001000, pic[82-IRQ_OFFSET]);\n\n\n\n    sysbus_create_varargs(\"cadence_ttc\", 0xF8001000,\n\n            pic[42-IRQ_OFFSET], pic[43-IRQ_OFFSET], pic[44-IRQ_OFFSET], NULL);\n\n    sysbus_create_varargs(\"cadence_ttc\", 0xF8002000,\n\n            pic[69-IRQ_OFFSET], pic[70-IRQ_OFFSET], pic[71-IRQ_OFFSET], NULL);\n\n\n\n    gem_init(&nd_table[0], 0xE000B000, pic[54-IRQ_OFFSET]);\n\n    gem_init(&nd_table[1], 0xE000C000, pic[77-IRQ_OFFSET]);\n\n\n\n    dev = qdev_create(NULL, \"generic-sdhci\");\n\n    qdev_init_nofail(dev);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xE0100000);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, pic[56-IRQ_OFFSET]);\n\n\n\n    dev = qdev_create(NULL, \"generic-sdhci\");\n\n    qdev_init_nofail(dev);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xE0101000);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, pic[79-IRQ_OFFSET]);\n\n\n\n    dev = qdev_create(NULL, \"pl330\");\n\n    qdev_prop_set_uint8(dev, \"num_chnls\",  8);\n\n    qdev_prop_set_uint8(dev, \"num_periph_req\",  4);\n\n    qdev_prop_set_uint8(dev, \"num_events\",  16);\n\n\n\n    qdev_prop_set_uint8(dev, \"data_width\",  64);\n\n    qdev_prop_set_uint8(dev, \"wr_cap\",  8);\n\n    qdev_prop_set_uint8(dev, \"wr_q_dep\",  16);\n\n    qdev_prop_set_uint8(dev, \"rd_cap\",  8);\n\n    qdev_prop_set_uint8(dev, \"rd_q_dep\",  16);\n\n    qdev_prop_set_uint16(dev, \"data_buffer_dep\",  256);\n\n\n\n    qdev_init_nofail(dev);\n\n    busdev = SYS_BUS_DEVICE(dev);\n\n    sysbus_mmio_map(busdev, 0, 0xF8003000);\n\n    sysbus_connect_irq(busdev, 0, pic[45-IRQ_OFFSET]); /* abort irq line */\n\n    for (n = 0; n < 8; ++n) { /* event irqs */\n\n        sysbus_connect_irq(busdev, n + 1, pic[dma_irqs[n] - IRQ_OFFSET]);\n\n    }\n\n\n\n    zynq_binfo.ram_size = ram_size;\n\n    zynq_binfo.kernel_filename = kernel_filename;\n\n    zynq_binfo.kernel_cmdline = kernel_cmdline;\n\n    zynq_binfo.initrd_filename = initrd_filename;\n\n    zynq_binfo.nb_cpus = 1;\n\n    zynq_binfo.board_id = 0xd32;\n\n    zynq_binfo.loader_start = 0;\n\n    arm_load_kernel(ARM_CPU(first_cpu), &zynq_binfo);\n\n}\n", "idx": 25350}
{"project": "qemu", "commit_id": "bec1631100323fac0900aea71043d5c4e22fc2fa", "target": 0, "func": "static void tcg_out_brcond(TCGContext *s, TCGMemOp ext, TCGCond c, TCGArg a,\n\n                           TCGArg b, bool b_const, int label)\n\n{\n\n    TCGLabel *l = &s->labels[label];\n\n    intptr_t offset;\n\n    bool need_cmp;\n\n\n\n    if (b_const && b == 0 && (c == TCG_COND_EQ || c == TCG_COND_NE)) {\n\n        need_cmp = false;\n\n    } else {\n\n        need_cmp = true;\n\n        tcg_out_cmp(s, ext, a, b, b_const);\n\n    }\n\n\n\n    if (!l->has_value) {\n\n        tcg_out_reloc(s, s->code_ptr, R_AARCH64_CONDBR19, label, 0);\n\n        offset = tcg_in32(s) >> 5;\n\n    } else {\n\n        offset = l->u.value_ptr - s->code_ptr;\n\n        assert(offset == sextract64(offset, 0, 19));\n\n    }\n\n\n\n    if (need_cmp) {\n\n        tcg_out_insn(s, 3202, B_C, c, offset);\n\n    } else if (c == TCG_COND_EQ) {\n\n        tcg_out_insn(s, 3201, CBZ, ext, a, offset);\n\n    } else {\n\n        tcg_out_insn(s, 3201, CBNZ, ext, a, offset);\n\n    }\n\n}\n", "idx": 25351}
{"project": "qemu", "commit_id": "3954d33ab7f82f5a5fa0ced231849920265a5fec", "target": 0, "func": "static target_ulong h_vio_signal(CPUState *env, sPAPREnvironment *spapr,\n\n                                 target_ulong opcode,\n\n                                 target_ulong *args)\n\n{\n\n    target_ulong reg = args[0];\n\n    target_ulong mode = args[1];\n\n    VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, reg);\n\n    VIOsPAPRDeviceInfo *info;\n\n\n\n    if (!dev) {\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    info = (VIOsPAPRDeviceInfo *)qdev_get_info(&dev->qdev);\n\n\n\n    if (mode & ~info->signal_mask) {\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    dev->signal_state = mode;\n\n\n\n    return H_SUCCESS;\n\n}\n", "idx": 25352}
{"project": "qemu", "commit_id": "39f80521df1e7f1252960d1ada2bd1a41d4d2cd3", "target": 0, "func": "static int inet_listen_saddr(InetSocketAddress *saddr,\n\n                             int port_offset,\n\n                             bool update_addr,\n\n                             Error **errp)\n\n{\n\n    struct addrinfo ai,*res,*e;\n\n    char port[33];\n\n    char uaddr[INET6_ADDRSTRLEN+1];\n\n    char uport[33];\n\n    int slisten, rc, port_min, port_max, p;\n\n    Error *err = NULL;\n\n\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_PASSIVE;\n\n    if (saddr->has_numeric && saddr->numeric) {\n\n        ai.ai_flags |= AI_NUMERICHOST | AI_NUMERICSERV;\n\n    }\n\n    ai.ai_family = inet_ai_family_from_address(saddr, &err);\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return -1;\n\n    }\n\n\n\n    if (saddr->host == NULL) {\n\n        error_setg(errp, \"host not specified\");\n\n        return -1;\n\n    }\n\n    if (saddr->port != NULL) {\n\n        pstrcpy(port, sizeof(port), saddr->port);\n\n    } else {\n\n        port[0] = '\\0';\n\n    }\n\n\n\n    /* lookup */\n\n    if (port_offset) {\n\n        unsigned long long baseport;\n\n        if (strlen(port) == 0) {\n\n            error_setg(errp, \"port not specified\");\n\n            return -1;\n\n        }\n\n        if (parse_uint_full(port, &baseport, 10) < 0) {\n\n            error_setg(errp, \"can't convert to a number: %s\", port);\n\n            return -1;\n\n        }\n\n        if (baseport > 65535 ||\n\n            baseport + port_offset > 65535) {\n\n            error_setg(errp, \"port %s out of range\", port);\n\n            return -1;\n\n        }\n\n        snprintf(port, sizeof(port), \"%d\", (int)baseport + port_offset);\n\n    }\n\n    rc = getaddrinfo(strlen(saddr->host) ? saddr->host : NULL,\n\n                     strlen(port) ? port : NULL, &ai, &res);\n\n    if (rc != 0) {\n\n        error_setg(errp, \"address resolution failed for %s:%s: %s\",\n\n                   saddr->host, port, gai_strerror(rc));\n\n        return -1;\n\n    }\n\n\n\n    /* create socket + bind */\n\n    for (e = res; e != NULL; e = e->ai_next) {\n\n        getnameinfo((struct sockaddr*)e->ai_addr,e->ai_addrlen,\n\n\t\t        uaddr,INET6_ADDRSTRLEN,uport,32,\n\n\t\t        NI_NUMERICHOST | NI_NUMERICSERV);\n\n        slisten = qemu_socket(e->ai_family, e->ai_socktype, e->ai_protocol);\n\n        if (slisten < 0) {\n\n            if (!e->ai_next) {\n\n                error_setg_errno(errp, errno, \"Failed to create socket\");\n\n            }\n\n            continue;\n\n        }\n\n\n\n        socket_set_fast_reuse(slisten);\n\n\n\n        port_min = inet_getport(e);\n\n        port_max = saddr->has_to ? saddr->to + port_offset : port_min;\n\n        for (p = port_min; p <= port_max; p++) {\n\n            inet_setport(e, p);\n\n            if (try_bind(slisten, saddr, e) >= 0) {\n\n                goto listen;\n\n            }\n\n            if (p == port_max) {\n\n                if (!e->ai_next) {\n\n                    error_setg_errno(errp, errno, \"Failed to bind socket\");\n\n                }\n\n            }\n\n        }\n\n        closesocket(slisten);\n\n    }\n\n    freeaddrinfo(res);\n\n    return -1;\n\n\n\nlisten:\n\n    if (listen(slisten,1) != 0) {\n\n        error_setg_errno(errp, errno, \"Failed to listen on socket\");\n\n        closesocket(slisten);\n\n        freeaddrinfo(res);\n\n        return -1;\n\n    }\n\n    if (update_addr) {\n\n        g_free(saddr->host);\n\n        saddr->host = g_strdup(uaddr);\n\n        g_free(saddr->port);\n\n        saddr->port = g_strdup_printf(\"%d\",\n\n                                      inet_getport(e) - port_offset);\n\n        saddr->has_ipv6 = saddr->ipv6 = e->ai_family == PF_INET6;\n\n        saddr->has_ipv4 = saddr->ipv4 = e->ai_family != PF_INET6;\n\n    }\n\n    freeaddrinfo(res);\n\n    return slisten;\n\n}\n", "idx": 25353}
{"project": "qemu", "commit_id": "25c4d9cc845fb58f624dae8c0f690e20c70e7a1d", "target": 0, "func": "static TCGArg do_constant_folding(int op, TCGArg x, TCGArg y)\n\n{\n\n    TCGArg res = do_constant_folding_2(op, x, y);\n\n#if TCG_TARGET_REG_BITS == 64\n\n    if (op_bits(op) == 32) {\n\n        res &= 0xffffffff;\n\n    }\n\n#endif\n\n    return res;\n\n}\n", "idx": 25354}
{"project": "qemu", "commit_id": "369f7de9d57e4dd2f312255fc12271d5749c0a4e", "target": 0, "func": "static int64_t seek_to_sector(BDRVParallelsState *s, int64_t sector_num)\n\n{\n\n    uint32_t index, offset;\n\n\n\n    index = sector_num / s->tracks;\n\n    offset = sector_num % s->tracks;\n\n\n\n    /* not allocated */\n\n    if ((index >= s->catalog_size) || (s->catalog_bitmap[index] == 0))\n\n        return -1;\n\n    return (uint64_t)s->catalog_bitmap[index] * s->off_multiplier + offset;\n\n}\n", "idx": 25355}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "int load_image_targphys(const char *filename,\n\n                        target_phys_addr_t addr, uint64_t max_sz)\n\n{\n\n    int size;\n\n\n\n    size = get_image_size(filename);\n\n    if (size > max_sz) {\n\n        return -1;\n\n    }\n\n    if (size > 0) {\n\n        rom_add_file_fixed(filename, addr, -1);\n\n    }\n\n    return size;\n\n}\n", "idx": 25356}
{"project": "qemu", "commit_id": "82ca891283a08cddd659b534592fe00f2159bc74", "target": 0, "func": "static uint64_t vfio_bar_read(void *opaque,\n\n                              hwaddr addr, unsigned size)\n\n{\n\n    VFIOBAR *bar = opaque;\n\n    union {\n\n        uint8_t byte;\n\n        uint16_t word;\n\n        uint32_t dword;\n\n        uint64_t qword;\n\n    } buf;\n\n    uint64_t data = 0;\n\n\n\n    if (pread(bar->fd, &buf, size, bar->fd_offset + addr) != size) {\n\n        error_report(\"%s(,0x%\"HWADDR_PRIx\", %d) failed: %m\",\n\n                     __func__, addr, size);\n\n        return (uint64_t)-1;\n\n    }\n\n\n\n    switch (size) {\n\n    case 1:\n\n        data = buf.byte;\n\n        break;\n\n    case 2:\n\n        data = le16_to_cpu(buf.word);\n\n        break;\n\n    case 4:\n\n        data = le32_to_cpu(buf.dword);\n\n        break;\n\n    default:\n\n        hw_error(\"vfio: unsupported read size, %d bytes\\n\", size);\n\n        break;\n\n    }\n\n\n\n    DPRINTF(\"%s(BAR%d+0x%\"HWADDR_PRIx\", %d) = 0x%\"PRIx64\"\\n\",\n\n            __func__, bar->nr, addr, size, data);\n\n\n\n    /* Same as write above */\n\n    vfio_eoi(container_of(bar, VFIODevice, bars[bar->nr]));\n\n\n\n    return data;\n\n}\n", "idx": 25358}
{"project": "qemu", "commit_id": "95b1416ae93106923f733941e52dfe55c4318643", "target": 0, "func": "static int l2tpv3_can_send(void *opaque)\n\n{\n\n    NetL2TPV3State *s = opaque;\n\n\n\n    return qemu_can_send_packet(&s->nc);\n\n}\n", "idx": 25359}
{"project": "qemu", "commit_id": "d5851089a8a77d5c23e8d5fffb5b99265009ba62", "target": 0, "func": "static void extract_common_blockdev_options(QemuOpts *opts, int *bdrv_flags,\n\n    const char **throttling_group, ThrottleConfig *throttle_cfg,\n\n    BlockdevDetectZeroesOptions *detect_zeroes, Error **errp)\n\n{\n\n    const char *discard;\n\n    Error *local_error = NULL;\n\n    const char *aio;\n\n\n\n    if (bdrv_flags) {\n\n        if (!qemu_opt_get_bool(opts, \"read-only\", false)) {\n\n            *bdrv_flags |= BDRV_O_RDWR;\n\n        }\n\n        if (qemu_opt_get_bool(opts, \"copy-on-read\", false)) {\n\n            *bdrv_flags |= BDRV_O_COPY_ON_READ;\n\n        }\n\n\n\n        if ((discard = qemu_opt_get(opts, \"discard\")) != NULL) {\n\n            if (bdrv_parse_discard_flags(discard, bdrv_flags) != 0) {\n\n                error_setg(errp, \"Invalid discard option\");\n\n                return;\n\n            }\n\n        }\n\n\n\n        if ((aio = qemu_opt_get(opts, \"aio\")) != NULL) {\n\n            if (!strcmp(aio, \"native\")) {\n\n                *bdrv_flags |= BDRV_O_NATIVE_AIO;\n\n            } else if (!strcmp(aio, \"threads\")) {\n\n                /* this is the default */\n\n            } else {\n\n               error_setg(errp, \"invalid aio option\");\n\n               return;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* disk I/O throttling */\n\n    if (throttling_group) {\n\n        *throttling_group = qemu_opt_get(opts, \"throttling.group\");\n\n    }\n\n\n\n    if (throttle_cfg) {\n\n        memset(throttle_cfg, 0, sizeof(*throttle_cfg));\n\n        throttle_cfg->buckets[THROTTLE_BPS_TOTAL].avg =\n\n            qemu_opt_get_number(opts, \"throttling.bps-total\", 0);\n\n        throttle_cfg->buckets[THROTTLE_BPS_READ].avg  =\n\n            qemu_opt_get_number(opts, \"throttling.bps-read\", 0);\n\n        throttle_cfg->buckets[THROTTLE_BPS_WRITE].avg =\n\n            qemu_opt_get_number(opts, \"throttling.bps-write\", 0);\n\n        throttle_cfg->buckets[THROTTLE_OPS_TOTAL].avg =\n\n            qemu_opt_get_number(opts, \"throttling.iops-total\", 0);\n\n        throttle_cfg->buckets[THROTTLE_OPS_READ].avg =\n\n            qemu_opt_get_number(opts, \"throttling.iops-read\", 0);\n\n        throttle_cfg->buckets[THROTTLE_OPS_WRITE].avg =\n\n            qemu_opt_get_number(opts, \"throttling.iops-write\", 0);\n\n\n\n        throttle_cfg->buckets[THROTTLE_BPS_TOTAL].max =\n\n            qemu_opt_get_number(opts, \"throttling.bps-total-max\", 0);\n\n        throttle_cfg->buckets[THROTTLE_BPS_READ].max  =\n\n            qemu_opt_get_number(opts, \"throttling.bps-read-max\", 0);\n\n        throttle_cfg->buckets[THROTTLE_BPS_WRITE].max =\n\n            qemu_opt_get_number(opts, \"throttling.bps-write-max\", 0);\n\n        throttle_cfg->buckets[THROTTLE_OPS_TOTAL].max =\n\n            qemu_opt_get_number(opts, \"throttling.iops-total-max\", 0);\n\n        throttle_cfg->buckets[THROTTLE_OPS_READ].max =\n\n            qemu_opt_get_number(opts, \"throttling.iops-read-max\", 0);\n\n        throttle_cfg->buckets[THROTTLE_OPS_WRITE].max =\n\n            qemu_opt_get_number(opts, \"throttling.iops-write-max\", 0);\n\n\n\n        throttle_cfg->op_size =\n\n            qemu_opt_get_number(opts, \"throttling.iops-size\", 0);\n\n\n\n        if (!check_throttle_config(throttle_cfg, errp)) {\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (detect_zeroes) {\n\n        *detect_zeroes =\n\n            qapi_enum_parse(BlockdevDetectZeroesOptions_lookup,\n\n                            qemu_opt_get(opts, \"detect-zeroes\"),\n\n                            BLOCKDEV_DETECT_ZEROES_OPTIONS__MAX,\n\n                            BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF,\n\n                            &local_error);\n\n        if (local_error) {\n\n            error_propagate(errp, local_error);\n\n            return;\n\n        }\n\n\n\n        if (bdrv_flags &&\n\n            *detect_zeroes == BLOCKDEV_DETECT_ZEROES_OPTIONS_UNMAP &&\n\n            !(*bdrv_flags & BDRV_O_UNMAP))\n\n        {\n\n            error_setg(errp, \"setting detect-zeroes to unmap is not allowed \"\n\n                             \"without setting discard operation to unmap\");\n\n            return;\n\n        }\n\n    }\n\n}\n", "idx": 25360}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static inline void tcg_out_dat_rI(TCGContext *s, int cond, int opc, TCGArg dst,\n\n                                  TCGArg lhs, TCGArg rhs, int rhs_is_const)\n\n{\n\n    /* Emit either the reg,imm or reg,reg form of a data-processing insn.\n\n     * rhs must satisfy the \"rI\" constraint.\n\n     */\n\n    if (rhs_is_const) {\n\n        int rot = encode_imm(rhs);\n\n        assert(rot >= 0);\n\n        tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));\n\n    } else {\n\n        tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));\n\n    }\n\n}\n", "idx": 25361}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static always_inline void gen_bcond (DisasContext *ctx,\n\n                                     TCGCond cond,\n\n                                     int ra, int32_t disp16, int mask)\n\n{\n\n    int l1, l2;\n\n\n\n    l1 = gen_new_label();\n\n    l2 = gen_new_label();\n\n    if (likely(ra != 31)) {\n\n        if (mask) {\n\n            TCGv tmp = tcg_temp_new(TCG_TYPE_I64);\n\n            tcg_gen_andi_i64(tmp, cpu_ir[ra], 1);\n\n            tcg_gen_brcondi_i64(cond, tmp, 0, l1);\n\n            tcg_temp_free(tmp);\n\n        } else\n\n            tcg_gen_brcondi_i64(cond, cpu_ir[ra], 0, l1);\n\n    } else {\n\n        /* Very uncommon case - Do not bother to optimize.  */\n\n        TCGv tmp = tcg_const_i64(0);\n\n        tcg_gen_brcondi_i64(cond, tmp, 0, l1);\n\n        tcg_temp_free(tmp);\n\n    }\n\n    tcg_gen_movi_i64(cpu_pc, ctx->pc);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_movi_i64(cpu_pc, ctx->pc + (int64_t)(disp16 << 2));\n\n    gen_set_label(l2);\n\n}\n", "idx": 25362}
{"project": "qemu", "commit_id": "2fb50a33401a2415b71ddc291e8a77bcd2f9e547", "target": 0, "func": "static void set_irq_level(void *opaque, int n, int level)\n\n{\n\n    NVICState *s = opaque;\n\n    VecInfo *vec;\n\n\n\n    n += NVIC_FIRST_IRQ;\n\n\n\n    assert(n >= NVIC_FIRST_IRQ && n < s->num_irq);\n\n\n\n    trace_nvic_set_irq_level(n, level);\n\n\n\n    /* The pending status of an external interrupt is\n\n     * latched on rising edge and exception handler return.\n\n     *\n\n     * Pulsing the IRQ will always run the handler\n\n     * once, and the handler will re-run until the\n\n     * level is low when the handler completes.\n\n     */\n\n    vec = &s->vectors[n];\n\n    if (level != vec->level) {\n\n        vec->level = level;\n\n        if (level) {\n\n            armv7m_nvic_set_pending(s, n);\n\n        }\n\n    }\n\n}\n", "idx": 25363}
{"project": "qemu", "commit_id": "82cbbdc6a0958b49c77639a60906e30d02e6bb7b", "target": 0, "func": "void qemu_aio_set_event_notifier(EventNotifier *notifier,\n\n                                 EventNotifierHandler *io_read,\n\n                                 AioFlushEventNotifierHandler *io_flush)\n\n{\n\n    qemu_aio_set_fd_handler(event_notifier_get_fd(notifier),\n\n                            (IOHandler *)io_read, NULL,\n\n                            (AioFlushHandler *)io_flush, notifier);\n\n}\n", "idx": 25364}
{"project": "qemu", "commit_id": "5d7fd045cafeac1831c1999cb9e1251b7906c6b2", "target": 0, "func": "uint32_t HELPER(lpebr)(CPUS390XState *env, uint32_t f1, uint32_t f2)\n\n{\n\n    float32 v1;\n\n    float32 v2 = env->fregs[f2].d;\n\n\n\n    v1 = float32_abs(v2);\n\n    env->fregs[f1].d = v1;\n\n    return set_cc_nz_f32(v1);\n\n}\n", "idx": 25365}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint64_t helper_fsel (uint64_t arg1, uint64_t arg2, uint64_t arg3)\n\n{\n\n    CPU_DoubleU farg1;\n\n\n\n    farg1.ll = arg1;\n\n\n\n    if ((!float64_is_neg(farg1.d) || float64_is_zero(farg1.d)) && !float64_is_nan(farg1.d))\n\n        return arg2;\n\n    else\n\n        return arg3;\n\n}\n", "idx": 25366}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int ohci_service_td(OHCIState *ohci, struct ohci_ed *ed)\n\n{\n\n    int dir;\n\n    size_t len = 0, pktlen = 0;\n\n#ifdef DEBUG_PACKET\n\n    const char *str = NULL;\n\n#endif\n\n    int pid;\n\n    int ret;\n\n    int i;\n\n    USBDevice *dev;\n\n    struct ohci_td td;\n\n    uint32_t addr;\n\n    int flag_r;\n\n    int completion;\n\n\n\n    addr = ed->head & OHCI_DPTR_MASK;\n\n    /* See if this TD has already been submitted to the device.  */\n\n    completion = (addr == ohci->async_td);\n\n    if (completion && !ohci->async_complete) {\n\n#ifdef DEBUG_PACKET\n\n        DPRINTF(\"Skipping async TD\\n\");\n\n#endif\n\n        return 1;\n\n    }\n\n    if (!ohci_read_td(ohci, addr, &td)) {\n\n        fprintf(stderr, \"usb-ohci: TD read error at %x\\n\", addr);\n\n        return 0;\n\n    }\n\n\n\n    dir = OHCI_BM(ed->flags, ED_D);\n\n    switch (dir) {\n\n    case OHCI_TD_DIR_OUT:\n\n    case OHCI_TD_DIR_IN:\n\n        /* Same value.  */\n\n        break;\n\n    default:\n\n        dir = OHCI_BM(td.flags, TD_DP);\n\n        break;\n\n    }\n\n\n\n    switch (dir) {\n\n    case OHCI_TD_DIR_IN:\n\n#ifdef DEBUG_PACKET\n\n        str = \"in\";\n\n#endif\n\n        pid = USB_TOKEN_IN;\n\n        break;\n\n    case OHCI_TD_DIR_OUT:\n\n#ifdef DEBUG_PACKET\n\n        str = \"out\";\n\n#endif\n\n        pid = USB_TOKEN_OUT;\n\n        break;\n\n    case OHCI_TD_DIR_SETUP:\n\n#ifdef DEBUG_PACKET\n\n        str = \"setup\";\n\n#endif\n\n        pid = USB_TOKEN_SETUP;\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"usb-ohci: Bad direction\\n\");\n\n        return 1;\n\n    }\n\n    if (td.cbp && td.be) {\n\n        if ((td.cbp & 0xfffff000) != (td.be & 0xfffff000)) {\n\n            len = (td.be & 0xfff) + 0x1001 - (td.cbp & 0xfff);\n\n        } else {\n\n            len = (td.be - td.cbp) + 1;\n\n        }\n\n\n\n        pktlen = len;\n\n        if (len && dir != OHCI_TD_DIR_IN) {\n\n            /* The endpoint may not allow us to transfer it all now */\n\n            pktlen = (ed->flags & OHCI_ED_MPS_MASK) >> OHCI_ED_MPS_SHIFT;\n\n            if (pktlen > len) {\n\n                pktlen = len;\n\n            }\n\n            if (!completion) {\n\n                ohci_copy_td(ohci, &td, ohci->usb_buf, pktlen, 0);\n\n            }\n\n        }\n\n    }\n\n\n\n    flag_r = (td.flags & OHCI_TD_R) != 0;\n\n#ifdef DEBUG_PACKET\n\n    DPRINTF(\" TD @ 0x%.8x %\" PRId64 \" of %\" PRId64\n\n            \" bytes %s r=%d cbp=0x%.8x be=0x%.8x\\n\",\n\n            addr, (int64_t)pktlen, (int64_t)len, str, flag_r, td.cbp, td.be);\n\n\n\n    if (pktlen > 0 && dir != OHCI_TD_DIR_IN) {\n\n        DPRINTF(\"  data:\");\n\n        for (i = 0; i < pktlen; i++) {\n\n            printf(\" %.2x\", ohci->usb_buf[i]);\n\n        }\n\n        DPRINTF(\"\\n\");\n\n    }\n\n#endif\n\n    if (completion) {\n\n        ret = ohci->usb_packet.result;\n\n        ohci->async_td = 0;\n\n        ohci->async_complete = 0;\n\n    } else {\n\n        if (ohci->async_td) {\n\n            /* ??? The hardware should allow one active packet per\n\n               endpoint.  We only allow one active packet per controller.\n\n               This should be sufficient as long as devices respond in a\n\n               timely manner.\n\n            */\n\n#ifdef DEBUG_PACKET\n\n            DPRINTF(\"Too many pending packets\\n\");\n\n#endif\n\n            return 1;\n\n        }\n\n        usb_packet_setup(&ohci->usb_packet, pid,\n\n                         OHCI_BM(ed->flags, ED_FA),\n\n                         OHCI_BM(ed->flags, ED_EN));\n\n        usb_packet_addbuf(&ohci->usb_packet, ohci->usb_buf, pktlen);\n\n        dev = ohci_find_device(ohci, ohci->usb_packet.devaddr);\n\n        ret = usb_handle_packet(dev, &ohci->usb_packet);\n\n#ifdef DEBUG_PACKET\n\n        DPRINTF(\"ret=%d\\n\", ret);\n\n#endif\n\n        if (ret == USB_RET_ASYNC) {\n\n            ohci->async_td = addr;\n\n            return 1;\n\n        }\n\n    }\n\n    if (ret >= 0) {\n\n        if (dir == OHCI_TD_DIR_IN) {\n\n            ohci_copy_td(ohci, &td, ohci->usb_buf, ret, 1);\n\n#ifdef DEBUG_PACKET\n\n            DPRINTF(\"  data:\");\n\n            for (i = 0; i < ret; i++)\n\n                printf(\" %.2x\", ohci->usb_buf[i]);\n\n            DPRINTF(\"\\n\");\n\n#endif\n\n        } else {\n\n            ret = pktlen;\n\n        }\n\n    }\n\n\n\n    /* Writeback */\n\n    if (ret == pktlen || (dir == OHCI_TD_DIR_IN && ret >= 0 && flag_r)) {\n\n        /* Transmission succeeded.  */\n\n        if (ret == len) {\n\n            td.cbp = 0;\n\n        } else {\n\n            if ((td.cbp & 0xfff) + ret > 0xfff) {\n\n                td.cbp = (td.be & ~0xfff) + ((td.cbp + ret) & 0xfff);\n\n            } else {\n\n                td.cbp += ret;\n\n            }\n\n        }\n\n        td.flags |= OHCI_TD_T1;\n\n        td.flags ^= OHCI_TD_T0;\n\n        OHCI_SET_BM(td.flags, TD_CC, OHCI_CC_NOERROR);\n\n        OHCI_SET_BM(td.flags, TD_EC, 0);\n\n\n\n        if ((dir != OHCI_TD_DIR_IN) && (ret != len)) {\n\n            /* Partial packet transfer: TD not ready to retire yet */\n\n            goto exit_no_retire;\n\n        }\n\n\n\n        /* Setting ED_C is part of the TD retirement process */\n\n        ed->head &= ~OHCI_ED_C;\n\n        if (td.flags & OHCI_TD_T0)\n\n            ed->head |= OHCI_ED_C;\n\n    } else {\n\n        if (ret >= 0) {\n\n            DPRINTF(\"usb-ohci: Underrun\\n\");\n\n            OHCI_SET_BM(td.flags, TD_CC, OHCI_CC_DATAUNDERRUN);\n\n        } else {\n\n            switch (ret) {\n\n            case USB_RET_NODEV:\n\n                OHCI_SET_BM(td.flags, TD_CC, OHCI_CC_DEVICENOTRESPONDING);\n\n            case USB_RET_NAK:\n\n                DPRINTF(\"usb-ohci: got NAK\\n\");\n\n                return 1;\n\n            case USB_RET_STALL:\n\n                DPRINTF(\"usb-ohci: got STALL\\n\");\n\n                OHCI_SET_BM(td.flags, TD_CC, OHCI_CC_STALL);\n\n                break;\n\n            case USB_RET_BABBLE:\n\n                DPRINTF(\"usb-ohci: got BABBLE\\n\");\n\n                OHCI_SET_BM(td.flags, TD_CC, OHCI_CC_DATAOVERRUN);\n\n                break;\n\n            default:\n\n                fprintf(stderr, \"usb-ohci: Bad device response %d\\n\", ret);\n\n                OHCI_SET_BM(td.flags, TD_CC, OHCI_CC_UNDEXPETEDPID);\n\n                OHCI_SET_BM(td.flags, TD_EC, 3);\n\n                break;\n\n            }\n\n        }\n\n        ed->head |= OHCI_ED_H;\n\n    }\n\n\n\n    /* Retire this TD */\n\n    ed->head &= ~OHCI_DPTR_MASK;\n\n    ed->head |= td.next & OHCI_DPTR_MASK;\n\n    td.next = ohci->done;\n\n    ohci->done = addr;\n\n    i = OHCI_BM(td.flags, TD_DI);\n\n    if (i < ohci->done_count)\n\n        ohci->done_count = i;\n\nexit_no_retire:\n\n    ohci_put_td(ohci, addr, &td);\n\n    return OHCI_BM(td.flags, TD_CC) != OHCI_CC_NOERROR;\n\n}\n", "idx": 25367}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void vmstate_unregister(const VMStateDescription *vmsd, void *opaque)\n\n{\n\n    SaveStateEntry *se, *new_se;\n\n\n\n    TAILQ_FOREACH_SAFE(se, &savevm_handlers, entry, new_se) {\n\n        if (se->vmsd == vmsd && se->opaque == opaque) {\n\n            TAILQ_REMOVE(&savevm_handlers, se, entry);\n\n            qemu_free(se);\n\n        }\n\n    }\n\n}\n", "idx": 25370}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_cli(DisasContext *ctx)\n\n{\n\n    /* Cache line invalidate: privileged and treated as no-op */\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n#endif\n\n}\n", "idx": 25374}
{"project": "qemu", "commit_id": "1e9981465f05a0f103d7e09afd975c9c0ff6d132", "target": 1, "func": "void qmp_cont(Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n\n\n    if (runstate_check(RUN_STATE_INMIGRATE)) {\n\n        error_set(errp, QERR_MIGRATION_EXPECTED);\n\n        return;\n\n    } else if (runstate_check(RUN_STATE_INTERNAL_ERROR) ||\n\n               runstate_check(RUN_STATE_SHUTDOWN)) {\n\n        error_set(errp, QERR_RESET_REQUIRED);\n\n        return;\n\n    } else if (runstate_check(RUN_STATE_SUSPENDED)) {\n\n        return;\n\n    }\n\n\n\n    bdrv_iterate(iostatus_bdrv_it, NULL);\n\n    bdrv_iterate(encrypted_bdrv_it, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    vm_start();\n\n}\n", "idx": 25379}
{"project": "qemu", "commit_id": "edc243851279e3393000b28b6b69454cae1190ef", "target": 1, "func": "static int virtio_net_handle_mac(VirtIONet *n, uint8_t cmd,\n\n                                 struct iovec *iov, unsigned int iov_cnt)\n\n{\n\n    struct virtio_net_ctrl_mac mac_data;\n\n    size_t s;\n\n    NetClientState *nc = qemu_get_queue(n->nic);\n\n\n\n    if (cmd == VIRTIO_NET_CTRL_MAC_ADDR_SET) {\n\n        if (iov_size(iov, iov_cnt) != sizeof(n->mac)) {\n\n            return VIRTIO_NET_ERR;\n\n        }\n\n        s = iov_to_buf(iov, iov_cnt, 0, &n->mac, sizeof(n->mac));\n\n        assert(s == sizeof(n->mac));\n\n        qemu_format_nic_info_str(qemu_get_queue(n->nic), n->mac);\n\n        rxfilter_notify(nc);\n\n\n\n        return VIRTIO_NET_OK;\n\n    }\n\n\n\n    if (cmd != VIRTIO_NET_CTRL_MAC_TABLE_SET) {\n\n        return VIRTIO_NET_ERR;\n\n    }\n\n\n\n    int in_use = 0;\n\n    int first_multi = 0;\n\n    uint8_t uni_overflow = 0;\n\n    uint8_t multi_overflow = 0;\n\n    uint8_t *macs = g_malloc0(MAC_TABLE_ENTRIES * ETH_ALEN);\n\n\n\n    s = iov_to_buf(iov, iov_cnt, 0, &mac_data.entries,\n\n                   sizeof(mac_data.entries));\n\n    mac_data.entries = ldl_p(&mac_data.entries);\n\n    if (s != sizeof(mac_data.entries)) {\n\n        goto error;\n\n    }\n\n    iov_discard_front(&iov, &iov_cnt, s);\n\n\n\n    if (mac_data.entries * ETH_ALEN > iov_size(iov, iov_cnt)) {\n\n        goto error;\n\n    }\n\n\n\n    if (mac_data.entries <= MAC_TABLE_ENTRIES) {\n\n        s = iov_to_buf(iov, iov_cnt, 0, macs,\n\n                       mac_data.entries * ETH_ALEN);\n\n        if (s != mac_data.entries * ETH_ALEN) {\n\n            goto error;\n\n        }\n\n        in_use += mac_data.entries;\n\n    } else {\n\n        uni_overflow = 1;\n\n    }\n\n\n\n    iov_discard_front(&iov, &iov_cnt, mac_data.entries * ETH_ALEN);\n\n\n\n    first_multi = in_use;\n\n\n\n    s = iov_to_buf(iov, iov_cnt, 0, &mac_data.entries,\n\n                   sizeof(mac_data.entries));\n\n    mac_data.entries = ldl_p(&mac_data.entries);\n\n    if (s != sizeof(mac_data.entries)) {\n\n        goto error;\n\n    }\n\n\n\n    iov_discard_front(&iov, &iov_cnt, s);\n\n\n\n    if (mac_data.entries * ETH_ALEN != iov_size(iov, iov_cnt)) {\n\n        goto error;\n\n    }\n\n\n\n    if (in_use + mac_data.entries <= MAC_TABLE_ENTRIES) {\n\n        s = iov_to_buf(iov, iov_cnt, 0, &macs[in_use * ETH_ALEN],\n\n                       mac_data.entries * ETH_ALEN);\n\n        if (s != mac_data.entries * ETH_ALEN) {\n\n            goto error;\n\n        }\n\n        in_use += mac_data.entries;\n\n    } else {\n\n        multi_overflow = 1;\n\n    }\n\n\n\n    n->mac_table.in_use = in_use;\n\n    n->mac_table.first_multi = first_multi;\n\n    n->mac_table.uni_overflow = uni_overflow;\n\n    n->mac_table.multi_overflow = multi_overflow;\n\n    memcpy(n->mac_table.macs, macs, MAC_TABLE_ENTRIES * ETH_ALEN);\n\n    g_free(macs);\n\n    rxfilter_notify(nc);\n\n\n\n    return VIRTIO_NET_OK;\n\n\n\nerror:\n\n    g_free(macs);\n\n    return VIRTIO_NET_ERR;\n\n}\n", "idx": 25382}
{"project": "qemu", "commit_id": "e0e2d644096c79a71099b176d08f465f6803a8b1", "target": 1, "func": "static inline uint16_t vring_avail_idx(VirtQueue *vq)\n\n{\n\n    VRingMemoryRegionCaches *caches = atomic_rcu_read(&vq->vring.caches);\n\n    hwaddr pa = offsetof(VRingAvail, idx);\n\n    vq->shadow_avail_idx = virtio_lduw_phys_cached(vq->vdev, &caches->avail, pa);\n\n    return vq->shadow_avail_idx;\n\n}\n", "idx": 25384}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "USBDevice *usb_create_simple(USBBus *bus, const char *name)\n\n{\n\n    USBDevice *dev = usb_create(bus, name);\n\n    qdev_init(&dev->qdev);\n\n    return dev;\n\n}\n", "idx": 25385}
{"project": "qemu", "commit_id": "80e1eea37a25a7696137e680285e36d0bfdc9f34", "target": 1, "func": "static void qvirtio_pci_foreach_callback(\n\n                        QPCIDevice *dev, int devfn, void *data)\n\n{\n\n    QVirtioPCIForeachData *d = data;\n\n    QVirtioPCIDevice *vpcidev = qpcidevice_to_qvirtiodevice(dev);\n\n\n\n    if (vpcidev->vdev.device_type == d->device_type &&\n\n        (!d->has_slot || vpcidev->pdev->devfn == d->slot << 3)) {\n\n        d->func(&vpcidev->vdev, d->user_data);\n\n    } else {\n\n        g_free(vpcidev);\n\n    }\n\n}\n", "idx": 25386}
{"project": "qemu", "commit_id": "93b91c59dbccde6e4d25661150c1529bd5ee4a06", "target": 1, "func": "QObject *qmp_dispatch(QObject *request)\n\n{\n\n    Error *err = NULL;\n\n    QObject *ret;\n\n    QDict *rsp;\n\n\n\n    ret = do_qmp_dispatch(request, &err);\n\n\n\n    rsp = qdict_new();\n\n    if (err) {\n\n        qdict_put_obj(rsp, \"error\", error_get_qobject(err));\n\n        error_free(err);\n\n    } else if (ret) {\n\n        qdict_put_obj(rsp, \"return\", ret);\n\n    } else {\n\n        QDECREF(rsp);\n\n        return NULL;\n\n    }\n\n\n\n    return QOBJECT(rsp);\n\n}\n", "idx": 25388}
{"project": "qemu", "commit_id": "e3fce97cf500c61f23df8e0245e08625fc375295", "target": 1, "func": "static int host_pci_config_read(int pos, int len, uint32_t val)\n\n{\n\n    char path[PATH_MAX];\n\n    int config_fd;\n\n    ssize_t size = sizeof(path);\n\n    /* Access real host bridge. */\n\n    int rc = snprintf(path, size, \"/sys/bus/pci/devices/%04x:%02x:%02x.%d/%s\",\n\n                      0, 0, 0, 0, \"config\");\n\n\n\n    if (rc >= size || rc < 0) {\n\n        return -ENODEV;\n\n    }\n\n\n\n    config_fd = open(path, O_RDWR);\n\n    if (config_fd < 0) {\n\n        return -ENODEV;\n\n    }\n\n\n\n    if (lseek(config_fd, pos, SEEK_SET) != pos) {\n\n        return -errno;\n\n    }\n\n    do {\n\n        rc = read(config_fd, (uint8_t *)&val, len);\n\n    } while (rc < 0 && (errno == EINTR || errno == EAGAIN));\n\n    if (rc != len) {\n\n        return -errno;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 25389}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static inline void read_mem(IVState *s, uint64_t off, void *buf, size_t len)\n\n{\n\n    QTestState *qtest = global_qtest;\n\n\n\n    global_qtest = s->qtest;\n\n    qpci_memread(s->dev, s->mem_base + off, buf, len);\n\n    global_qtest = qtest;\n\n}\n", "idx": 25390}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "static void sdhci_initfn(Object *obj)\n\n{\n\n    SDHCIState *s = SDHCI(obj);\n\n    DriveInfo *di;\n\n\n\n    di = drive_get_next(IF_SD);\n\n    s->card = sd_init(di ? di->bdrv : NULL, false);\n\n    if (s->card == NULL) {\n\n        exit(1);\n\n    }\n\n    s->eject_cb = qemu_allocate_irqs(sdhci_insert_eject_cb, s, 1)[0];\n\n    s->ro_cb = qemu_allocate_irqs(sdhci_card_readonly_cb, s, 1)[0];\n\n    sd_set_cb(s->card, s->ro_cb, s->eject_cb);\n\n\n\n    s->insert_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, sdhci_raise_insertion_irq, s);\n\n    s->transfer_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, sdhci_do_data_transfer, s);\n\n}\n", "idx": 25391}
{"project": "qemu", "commit_id": "384b557da1a44ce260cd0328c06a250507348f73", "target": 1, "func": "int vhost_backend_update_device_iotlb(struct vhost_dev *dev,\n\n                                             uint64_t iova, uint64_t uaddr,\n\n                                             uint64_t len,\n\n                                             IOMMUAccessFlags perm)\n\n{\n\n    struct vhost_iotlb_msg imsg;\n\n\n\n    imsg.iova =  iova;\n\n    imsg.uaddr = uaddr;\n\n    imsg.size = len;\n\n    imsg.type = VHOST_IOTLB_UPDATE;\n\n\n\n    switch (perm) {\n\n    case IOMMU_RO:\n\n        imsg.perm = VHOST_ACCESS_RO;\n\n        break;\n\n    case IOMMU_WO:\n\n        imsg.perm = VHOST_ACCESS_WO;\n\n        break;\n\n    case IOMMU_RW:\n\n        imsg.perm = VHOST_ACCESS_RW;\n\n        break;\n\n    default:\n\n        return -EINVAL;\n\n    }\n\n\n\n    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);\n\n}\n", "idx": 25393}
{"project": "qemu", "commit_id": "daa76aa416b1e18ab1fac650ff53d966d8f21f68", "target": 1, "func": "void qemu_set_log_filename(const char *filename)\n\n{\n\n    char *pidstr;\n\n    g_free(logfilename);\n\n\n\n    pidstr = strstr(filename, \"%\");\n\n    if (pidstr) {\n\n        /* We only accept one %d, no other format strings */\n\n        if (pidstr[1] != 'd' || strchr(pidstr + 2, '%')) {\n\n            error_report(\"Bad logfile format: %s\", filename);\n\n            logfilename = NULL;\n\n        } else {\n\n            logfilename = g_strdup_printf(filename, getpid());\n\n        }\n\n    } else {\n\n        logfilename = g_strdup(filename);\n\n    }\n\n    qemu_log_close();\n\n    qemu_set_log(qemu_loglevel);\n\n}\n", "idx": 25394}
{"project": "qemu", "commit_id": "a8f2e5c8fffbaf7fbd4f0efc8efbeebade78008f", "target": 1, "func": "static void virtio_scsi_handle_event(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    VirtIOSCSI *s = VIRTIO_SCSI(vdev);\n\n\n\n    if (s->ctx && !s->dataplane_started) {\n\n        virtio_scsi_dataplane_start(s);\n\n        return;\n\n    }\n\n    if (s->events_dropped) {\n\n        virtio_scsi_push_event(s, NULL, VIRTIO_SCSI_T_NO_EVENT, 0);\n\n    }\n\n}\n", "idx": 25395}
{"project": "qemu", "commit_id": "70976a7926b42d87e0c575412b85a8f5c1e48fad", "target": 1, "func": "static int gdb_set_spe_reg(CPUState *env, uint8_t *mem_buf, int n)\n\n{\n\n    if (n < 32) {\n\n#if defined(TARGET_PPC64)\n\n        target_ulong lo = (uint32_t)env->gpr[n];\n\n        target_ulong hi = (target_ulong)ldl_p(mem_buf) << 32;\n\n        env->gpr[n] = lo | hi;\n\n#else\n\n        env->gprh[n] = ldl_p(mem_buf);\n\n#endif\n\n        return 4;\n\n    }\n\n    if (n == 33) {\n\n        env->spe_acc = ldq_p(mem_buf);\n\n        return 8;\n\n    }\n\n    if (n == 34) {\n\n        /* SPEFSCR not implemented */\n\n        return 4;\n\n    }\n\n    return 0;\n\n}\n", "idx": 25396}
{"project": "qemu", "commit_id": "b308c82cbda44e138ef990af64d44a5613c16092", "target": 1, "func": "int pci_bridge_initfn(PCIDevice *dev)\n\n{\n\n    PCIBus *parent = dev->bus;\n\n    PCIBridge *br = DO_UPCAST(PCIBridge, dev, dev);\n\n    PCIBus *sec_bus = &br->sec_bus;\n\n\n\n    pci_word_test_and_set_mask(dev->config + PCI_STATUS,\n\n                               PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK);\n\n    pci_config_set_class(dev->config, PCI_CLASS_BRIDGE_PCI);\n\n    dev->config[PCI_HEADER_TYPE] =\n\n        (dev->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |\n\n        PCI_HEADER_TYPE_BRIDGE;\n\n    pci_set_word(dev->config + PCI_SEC_STATUS,\n\n                 PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK);\n\n\n\n    /*\n\n     * If we don't specify the name, the bus will be addressed as <id>.0, where\n\n     * id is the device id.\n\n     * Since PCI Bridge devices have a single bus each, we don't need the index:\n\n     * let users address the bus using the device name.\n\n     */\n\n    if (!br->bus_name && dev->qdev.id && *dev->qdev.id) {\n\n\t    br->bus_name = dev->qdev.id;\n\n    }\n\n\n\n    qbus_create_inplace(&sec_bus->qbus, TYPE_PCI_BUS, &dev->qdev,\n\n                        br->bus_name);\n\n    sec_bus->parent_dev = dev;\n\n    sec_bus->map_irq = br->map_irq;\n\n    sec_bus->address_space_mem = &br->address_space_mem;\n\n    memory_region_init(&br->address_space_mem, \"pci_bridge_pci\", INT64_MAX);\n\n    sec_bus->address_space_io = &br->address_space_io;\n\n    memory_region_init(&br->address_space_io, \"pci_bridge_io\", 65536);\n\n    pci_bridge_region_init(br);\n\n    QLIST_INIT(&sec_bus->child);\n\n    QLIST_INSERT_HEAD(&parent->child, sec_bus, sibling);\n\n    return 0;\n\n}\n", "idx": 25397}
{"project": "qemu", "commit_id": "a903f40c314c57734ffd651786c953541cfc43a8", "target": 1, "func": "int64_t qmp_guest_file_open(const char *path, bool has_mode, const char *mode,\n\n                            Error **errp)\n\n{\n\n    FILE *fh;\n\n    Error *local_err = NULL;\n\n    int fd;\n\n    int64_t ret = -1, handle;\n\n\n\n    if (!has_mode) {\n\n        mode = \"r\";\n\n    }\n\n    slog(\"guest-file-open called, filepath: %s, mode: %s\", path, mode);\n\n    fh = safe_open_or_create(path, mode, &local_err);\n\n    if (local_err != NULL) {\n\n        error_propagate(errp, local_err);\n\n        return -1;\n\n    }\n\n\n\n    /* set fd non-blocking to avoid common use cases (like reading from a\n\n     * named pipe) from hanging the agent\n\n     */\n\n    fd = fileno(fh);\n\n    ret = fcntl(fd, F_GETFL);\n\n    ret = fcntl(fd, F_SETFL, ret | O_NONBLOCK);\n\n    if (ret == -1) {\n\n        error_setg_errno(errp, errno, \"failed to make file '%s' non-blocking\",\n\n                         path);\n\n        fclose(fh);\n\n        return -1;\n\n    }\n\n\n\n    handle = guest_file_handle_add(fh, errp);\n\n    if (error_is_set(errp)) {\n\n        fclose(fh);\n\n        return -1;\n\n    }\n\n\n\n    slog(\"guest-file-open, handle: %\" PRId64, handle);\n\n    return handle;\n\n}\n", "idx": 25399}
{"project": "qemu", "commit_id": "b3a6a2e0417c78ec5491347eb85a7d125a5fefdc", "target": 1, "func": "int32 floatx80_to_int32_round_to_zero( floatx80 a STATUS_PARAM )\n\n{\n\n    flag aSign;\n\n    int32 aExp, shiftCount;\n\n    uint64_t aSig, savedASig;\n\n    int32 z;\n\n\n\n    aSig = extractFloatx80Frac( a );\n\n    aExp = extractFloatx80Exp( a );\n\n    aSign = extractFloatx80Sign( a );\n\n    if ( 0x401E < aExp ) {\n\n        if ( ( aExp == 0x7FFF ) && (uint64_t) ( aSig<<1 ) ) aSign = 0;\n\n        goto invalid;\n\n    }\n\n    else if ( aExp < 0x3FFF ) {\n\n        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n        return 0;\n\n    }\n\n    shiftCount = 0x403E - aExp;\n\n    savedASig = aSig;\n\n    aSig >>= shiftCount;\n\n    z = aSig;\n\n    if ( aSign ) z = - z;\n\n    if ( ( z < 0 ) ^ aSign ) {\n\n invalid:\n\n        float_raise( float_flag_invalid STATUS_VAR);\n\n        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;\n\n    }\n\n    if ( ( aSig<<shiftCount ) != savedASig ) {\n\n        STATUS(float_exception_flags) |= float_flag_inexact;\n\n    }\n\n    return z;\n\n\n\n}\n", "idx": 25403}
{"project": "qemu", "commit_id": "3453f9a0dfa58578e6dadf0905ff4528b428ec73", "target": 1, "func": "static void usb_uas_command(UASDevice *uas, uas_ui *ui)\n{\n    UASRequest *req;\n    uint32_t len;\n    uint16_t tag = be16_to_cpu(ui->hdr.tag);\n    if (uas_using_streams(uas) && tag > UAS_MAX_STREAMS) {\n        goto invalid_tag;\n    }\n    req = usb_uas_find_request(uas, tag);\n    if (req) {\n        goto overlapped_tag;\n    }\n    req = usb_uas_alloc_request(uas, ui);\n    if (req->dev == NULL) {\n        goto bad_target;\n    }\n    trace_usb_uas_command(uas->dev.addr, req->tag,\n                          usb_uas_get_lun(req->lun),\n                          req->lun >> 32, req->lun & 0xffffffff);\n    QTAILQ_INSERT_TAIL(&uas->requests, req, next);\n    if (uas_using_streams(uas) && uas->data3[req->tag] != NULL) {\n        req->data = uas->data3[req->tag];\n        req->data_async = true;\n        uas->data3[req->tag] = NULL;\n    }\n    req->req = scsi_req_new(req->dev, req->tag,\n                            usb_uas_get_lun(req->lun),\n                            ui->command.cdb, req);\n    if (uas->requestlog) {\n        scsi_req_print(req->req);\n    }\n    len = scsi_req_enqueue(req->req);\n    if (len) {\n        req->data_size = len;\n        scsi_req_continue(req->req);\n    }\noverlapped_tag:\n    usb_uas_queue_fake_sense(uas, tag, sense_code_OVERLAPPED_COMMANDS);\nbad_target:\n    usb_uas_queue_fake_sense(uas, tag, sense_code_LUN_NOT_SUPPORTED);\n    g_free(req);\n}", "idx": 25407}
{"project": "qemu", "commit_id": "e05ca8200216149008fa1b1d1d847bf16691f6b4", "target": 1, "func": "int vhost_dev_start(struct vhost_dev *hdev, VirtIODevice *vdev)\n\n{\n\n    int i, r;\n\n\n\n    hdev->started = true;\n\n\n\n    r = vhost_dev_set_features(hdev, hdev->log_enabled);\n\n    if (r < 0) {\n\n        goto fail_features;\n\n    }\n\n    r = hdev->vhost_ops->vhost_call(hdev, VHOST_SET_MEM_TABLE, hdev->mem);\n\n    if (r < 0) {\n\n        r = -errno;\n\n        goto fail_mem;\n\n    }\n\n    for (i = 0; i < hdev->nvqs; ++i) {\n\n        r = vhost_virtqueue_start(hdev,\n\n                                  vdev,\n\n                                  hdev->vqs + i,\n\n                                  hdev->vq_index + i);\n\n        if (r < 0) {\n\n            goto fail_vq;\n\n        }\n\n    }\n\n\n\n    if (hdev->log_enabled) {\n\n        hdev->log_size = vhost_get_log_size(hdev);\n\n        hdev->log = hdev->log_size ?\n\n            g_malloc0(hdev->log_size * sizeof *hdev->log) : NULL;\n\n        r = hdev->vhost_ops->vhost_call(hdev, VHOST_SET_LOG_BASE, hdev->log);\n\n        if (r < 0) {\n\n            r = -errno;\n\n            goto fail_log;\n\n        }\n\n    }\n\n\n\n    return 0;\n\nfail_log:\n\nfail_vq:\n\n    while (--i >= 0) {\n\n        vhost_virtqueue_stop(hdev,\n\n                             vdev,\n\n                             hdev->vqs + i,\n\n                             hdev->vq_index + i);\n\n    }\n\n    i = hdev->nvqs;\n\nfail_mem:\n\nfail_features:\n\n\n\n    hdev->started = false;\n\n    return r;\n\n}\n", "idx": 25414}
{"project": "qemu", "commit_id": "82be8e7394b31fd2d740651365b8ebdd0c847529", "target": 1, "func": "int kvmppc_get_htab_fd(bool write)\n\n{\n\n    struct kvm_get_htab_fd s = {\n\n        .flags = write ? KVM_GET_HTAB_WRITE : 0,\n\n        .start_index = 0,\n\n    };\n\n\n\n    if (!cap_htab_fd) {\n\n        fprintf(stderr, \"KVM version doesn't support saving the hash table\\n\");\n\n        return -1;\n\n    }\n\n\n\n    return kvm_vm_ioctl(kvm_state, KVM_PPC_GET_HTAB_FD, &s);\n\n}\n", "idx": 25419}
{"project": "qemu", "commit_id": "95a5befc2f8b359e72926f89cd661d063c2cf06c", "target": 1, "func": "static void machine_set_loadparm(Object *obj, const char *val, Error **errp)\n\n{\n\n    S390CcwMachineState *ms = S390_CCW_MACHINE(obj);\n\n    int i;\n\n\n\n    for (i = 0; i < sizeof(ms->loadparm) && val[i]; i++) {\n\n        uint8_t c = toupper(val[i]); /* mimic HMC */\n\n\n\n        if (('A' <= c && c <= 'Z') || ('0' <= c && c <= '9') || (c == '.') ||\n\n            (c == ' ')) {\n\n            ms->loadparm[i] = c;\n\n        } else {\n\n            error_setg(errp, \"LOADPARM: invalid character '%c' (ASCII 0x%02x)\",\n\n                       c, c);\n\n            return;\n\n        }\n\n    }\n\n\n\n    for (; i < sizeof(ms->loadparm); i++) {\n\n        ms->loadparm[i] = ' '; /* pad right with spaces */\n\n    }\n\n}\n", "idx": 25420}
{"project": "qemu", "commit_id": "7f1e9d4e138f5baf1e862a1221ba13eee7dcce9e", "target": 1, "func": "static void eepro100_cu_command(EEPRO100State * s, uint8_t val)\n\n{\n\n    eepro100_tx_t tx;\n\n    uint32_t cb_address;\n\n    switch (val) {\n\n    case CU_NOP:\n\n        /* No operation. */\n\n        break;\n\n    case CU_START:\n\n        if (get_cu_state(s) != cu_idle) {\n\n            /* Intel documentation says that CU must be idle for the CU\n\n             * start command. Intel driver for Linux also starts the CU\n\n             * from suspended state. */\n\n            logout(\"CU state is %u, should be %u\\n\", get_cu_state(s), cu_idle);\n\n            //~ assert(!\"wrong CU state\");\n\n        }\n\n        set_cu_state(s, cu_active);\n\n        s->cu_offset = s->pointer;\n\n      next_command:\n\n        cb_address = s->cu_base + s->cu_offset;\n\n        cpu_physical_memory_read(cb_address, (uint8_t *) & tx, sizeof(tx));\n\n        uint16_t status = le16_to_cpu(tx.status);\n\n        uint16_t command = le16_to_cpu(tx.command);\n\n        logout\n\n            (\"val=0x%02x (cu start), status=0x%04x, command=0x%04x, link=0x%08x\\n\",\n\n             val, status, command, tx.link);\n\n        bool bit_el = ((command & 0x8000) != 0);\n\n        bool bit_s = ((command & 0x4000) != 0);\n\n        bool bit_i = ((command & 0x2000) != 0);\n\n        bool bit_nc = ((command & 0x0010) != 0);\n\n        //~ bool bit_sf = ((command & 0x0008) != 0);\n\n        uint16_t cmd = command & 0x0007;\n\n        s->cu_offset = le32_to_cpu(tx.link);\n\n        switch (cmd) {\n\n        case CmdNOp:\n\n            /* Do nothing. */\n\n            break;\n\n        case CmdIASetup:\n\n            cpu_physical_memory_read(cb_address + 8, &s->macaddr[0], 6);\n\n            TRACE(OTHER, logout(\"macaddr: %s\\n\", nic_dump(&s->macaddr[0], 6)));\n\n            break;\n\n        case CmdConfigure:\n\n            cpu_physical_memory_read(cb_address + 8, &s->configuration[0],\n\n                                     sizeof(s->configuration));\n\n            TRACE(OTHER, logout(\"configuration: %s\\n\", nic_dump(&s->configuration[0], 16)));\n\n            break;\n\n        case CmdMulticastList:\n\n            //~ missing(\"multicast list\");\n\n            break;\n\n        case CmdTx:\n\n            (void)0;\n\n            uint32_t tbd_array = le32_to_cpu(tx.tx_desc_addr);\n\n            uint16_t tcb_bytes = (le16_to_cpu(tx.tcb_bytes) & 0x3fff);\n\n            TRACE(RXTX, logout\n\n                (\"transmit, TBD array address 0x%08x, TCB byte count 0x%04x, TBD count %u\\n\",\n\n                 tbd_array, tcb_bytes, tx.tbd_count));\n\n            assert(!bit_nc);\n\n            //~ assert(!bit_sf);\n\n            assert(tcb_bytes <= 2600);\n\n            /* Next assertion fails for local configuration. */\n\n            //~ assert((tcb_bytes > 0) || (tbd_array != 0xffffffff));\n\n            if (!((tcb_bytes > 0) || (tbd_array != 0xffffffff))) {\n\n                logout\n\n                    (\"illegal values of TBD array address and TCB byte count!\\n\");\n\n            }\n\n            // sends larger than MAX_ETH_FRAME_SIZE are allowed, up to 2600 bytes\n\n            uint8_t buf[2600];\n\n            uint16_t size = 0;\n\n            uint32_t tbd_address = cb_address + 0x10;\n\n            assert(tcb_bytes <= sizeof(buf));\n\n            while (size < tcb_bytes) {\n\n                uint32_t tx_buffer_address = ldl_phys(tbd_address);\n\n                uint16_t tx_buffer_size = lduw_phys(tbd_address + 4);\n\n                //~ uint16_t tx_buffer_el = lduw_phys(tbd_address + 6);\n\n                tbd_address += 8;\n\n                TRACE(RXTX, logout\n\n                    (\"TBD (simplified mode): buffer address 0x%08x, size 0x%04x\\n\",\n\n                     tx_buffer_address, tx_buffer_size));\n\n                tx_buffer_size = MIN(tx_buffer_size, sizeof(buf) - size);\n\n                cpu_physical_memory_read(tx_buffer_address, &buf[size],\n\n                                         tx_buffer_size);\n\n                size += tx_buffer_size;\n\n            }\n\n            if (tbd_array == 0xffffffff) {\n\n                /* Simplified mode. Was already handled by code above. */\n\n            } else {\n\n                /* Flexible mode. */\n\n                uint8_t tbd_count = 0;\n\n                if (device_supports_eTxCB(s) && !(s->configuration[6] & BIT(4))) {\n\n                    /* Extended Flexible TCB. */\n\n                    assert(tcb_bytes == 0);\n\n                    for (; tbd_count < 2; tbd_count++) {\n\n                        uint32_t tx_buffer_address = ldl_phys(tbd_address);\n\n                        uint16_t tx_buffer_size = lduw_phys(tbd_address + 4);\n\n                        uint16_t tx_buffer_el = lduw_phys(tbd_address + 6);\n\n                        tbd_address += 8;\n\n                        TRACE(RXTX, logout\n\n                            (\"TBD (extended flexible mode): buffer address 0x%08x, size 0x%04x\\n\",\n\n                             tx_buffer_address, tx_buffer_size));\n\n                        tx_buffer_size = MIN(tx_buffer_size, sizeof(buf) - size);\n\n                        cpu_physical_memory_read(tx_buffer_address, &buf[size],\n\n                                                 tx_buffer_size);\n\n                        size += tx_buffer_size;\n\n                        if (tx_buffer_el & 1) {\n\n                            break;\n\n                        }\n\n                    }\n\n                }\n\n                tbd_address = tbd_array;\n\n                for (; tbd_count < tx.tbd_count; tbd_count++) {\n\n                    uint32_t tx_buffer_address = ldl_phys(tbd_address);\n\n                    uint16_t tx_buffer_size = lduw_phys(tbd_address + 4);\n\n                    uint16_t tx_buffer_el = lduw_phys(tbd_address + 6);\n\n                    tbd_address += 8;\n\n                    TRACE(RXTX, logout\n\n                        (\"TBD (flexible mode): buffer address 0x%08x, size 0x%04x\\n\",\n\n                         tx_buffer_address, tx_buffer_size));\n\n                    tx_buffer_size = MIN(tx_buffer_size, sizeof(buf) - size);\n\n                    cpu_physical_memory_read(tx_buffer_address, &buf[size],\n\n                                             tx_buffer_size);\n\n                    size += tx_buffer_size;\n\n                    if (tx_buffer_el & 1) {\n\n                        break;\n\n                    }\n\n                }\n\n            }\n\n            TRACE(RXTX, logout(\"%p sending frame, len=%d,%s\\n\", s, size, nic_dump(buf, size)));\n\n            qemu_send_packet(s->vc, buf, size);\n\n            s->statistics.tx_good_frames++;\n\n            /* Transmit with bad status would raise an CX/TNO interrupt.\n\n             * (82557 only). Emulation never has bad status. */\n\n            //~ eepro100_cx_interrupt(s);\n\n            break;\n\n        case CmdTDR:\n\n            TRACE(OTHER, logout(\"load microcode\\n\"));\n\n            /* Starting with offset 8, the command contains\n\n             * 64 dwords microcode which we just ignore here. */\n\n            break;\n\n        default:\n\n            missing(\"undefined command\");\n\n        }\n\n        /* Write new status (success). */\n\n        stw_phys(cb_address, status | 0x8000 | 0x2000);\n\n        if (bit_i) {\n\n            /* CU completed action. */\n\n            eepro100_cx_interrupt(s);\n\n        }\n\n        if (bit_el) {\n\n            /* CU becomes idle. Terminate command loop. */\n\n            set_cu_state(s, cu_idle);\n\n            eepro100_cna_interrupt(s);\n\n        } else if (bit_s) {\n\n            /* CU becomes suspended. */\n\n            set_cu_state(s, cu_suspended);\n\n            eepro100_cna_interrupt(s);\n\n        } else {\n\n            /* More entries in list. */\n\n            TRACE(OTHER, logout(\"CU list with at least one more entry\\n\"));\n\n            goto next_command;\n\n        }\n\n        TRACE(OTHER, logout(\"CU list empty\\n\"));\n\n        /* List is empty. Now CU is idle or suspended. */\n\n        break;\n\n    case CU_RESUME:\n\n        if (get_cu_state(s) != cu_suspended) {\n\n            logout(\"bad CU resume from CU state %u\\n\", get_cu_state(s));\n\n            /* Workaround for bad Linux eepro100 driver which resumes\n\n             * from idle state. */\n\n            //~ missing(\"cu resume\");\n\n            set_cu_state(s, cu_suspended);\n\n        }\n\n        if (get_cu_state(s) == cu_suspended) {\n\n            TRACE(OTHER, logout(\"CU resuming\\n\"));\n\n            set_cu_state(s, cu_active);\n\n            goto next_command;\n\n        }\n\n        break;\n\n    case CU_STATSADDR:\n\n        /* Load dump counters address. */\n\n        s->statsaddr = s->pointer;\n\n        TRACE(OTHER, logout(\"val=0x%02x (status address)\\n\", val));\n\n        break;\n\n    case CU_SHOWSTATS:\n\n        /* Dump statistical counters. */\n\n        TRACE(OTHER, logout(\"val=0x%02x (dump stats)\\n\", val));\n\n        dump_statistics(s);\n\n        break;\n\n    case CU_CMD_BASE:\n\n        /* Load CU base. */\n\n        TRACE(OTHER, logout(\"val=0x%02x (CU base address)\\n\", val));\n\n        s->cu_base = s->pointer;\n\n        break;\n\n    case CU_DUMPSTATS:\n\n        /* Dump and reset statistical counters. */\n\n        TRACE(OTHER, logout(\"val=0x%02x (dump stats and reset)\\n\", val));\n\n        dump_statistics(s);\n\n        memset(&s->statistics, 0, sizeof(s->statistics));\n\n        break;\n\n    case CU_SRESUME:\n\n        /* CU static resume. */\n\n        missing(\"CU static resume\");\n\n        break;\n\n    default:\n\n        missing(\"Undefined CU command\");\n\n    }\n\n}\n", "idx": 25421}
{"project": "qemu", "commit_id": "80ee15a6b274dfcedb0ad7db8c9e7d392210d6a1", "target": 1, "func": "static int count_contiguous_clusters(uint64_t nb_clusters, int cluster_size,\n\n        uint64_t *l2_table, uint64_t start, uint64_t mask)\n\n{\n\n    int i;\n\n    uint64_t offset = be64_to_cpu(l2_table[0]) & ~mask;\n\n\n\n    if (!offset)\n\n        return 0;\n\n\n\n    for (i = start; i < start + nb_clusters; i++)\n\n        if (offset + i * cluster_size != (be64_to_cpu(l2_table[i]) & ~mask))\n\n            break;\n\n\n\n\treturn (i - start);\n\n}\n", "idx": 25423}
{"project": "qemu", "commit_id": "0c53d7342b4e8412f3b81eed67f053304813dc5d", "target": 1, "func": "static void gen_ove_ov(DisasContext *dc, TCGv ov)\n\n{\n\n    gen_helper_ove(cpu_env, ov);\n\n}\n", "idx": 25424}
{"project": "qemu", "commit_id": "2ba1eeb62c29d23238b95dc7e9ade3444b49f0a1", "target": 1, "func": "int dyngen_code(TCGContext *s, uint8_t *gen_code_buf)\n\n{\n\n#ifdef CONFIG_PROFILER\n\n    {\n\n        extern int64_t dyngen_op_count;\n\n        extern int dyngen_op_count_max;\n\n        int n;\n\n        n = (gen_opc_ptr - gen_opc_buf);\n\n        dyngen_op_count += n;\n\n        if (n > dyngen_op_count_max)\n\n            dyngen_op_count_max = n;\n\n    }\n\n#endif\n\n\n\n    tcg_gen_code_common(s, gen_code_buf, 0, NULL);\n\n\n\n    /* flush instruction cache */\n\n    flush_icache_range((unsigned long)gen_code_buf, \n\n                       (unsigned long)s->code_ptr);\n\n    return s->code_ptr -  gen_code_buf;\n\n}\n", "idx": 25431}
{"project": "qemu", "commit_id": "6bf45d59f98c898b7d7997a333765c8ee41236ea", "target": 1, "func": "static int alloc_refcount_block(BlockDriverState *bs,\n                                int64_t cluster_index, void **refcount_block)\n{\n    BDRVQcow2State *s = bs->opaque;\n    unsigned int refcount_table_index;\n    int64_t ret;\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC);\n    /* Find the refcount block for the given cluster */\n    refcount_table_index = cluster_index >> s->refcount_block_bits;\n    if (refcount_table_index < s->refcount_table_size) {\n        uint64_t refcount_block_offset =\n            s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;\n        /* If it's already there, we're done */\n        if (refcount_block_offset) {\n            if (offset_into_cluster(s, refcount_block_offset)) {\n                qcow2_signal_corruption(bs, true, -1, -1, \"Refblock offset %#\"\n                                        PRIx64 \" unaligned (reftable index: \"\n                                        \"%#x)\", refcount_block_offset,\n                                        refcount_table_index);\n             return load_refcount_block(bs, refcount_block_offset,\n                                        refcount_block);\n    /*\n     * If we came here, we need to allocate something. Something is at least\n     * a cluster for the new refcount block. It may also include a new refcount\n     * table if the old refcount table is too small.\n     *\n     * Note that allocating clusters here needs some special care:\n     *\n     * - We can't use the normal qcow2_alloc_clusters(), it would try to\n     *   increase the refcount and very likely we would end up with an endless\n     *   recursion. Instead we must place the refcount blocks in a way that\n     *   they can describe them themselves.\n     *\n     * - We need to consider that at this point we are inside update_refcounts\n     *   and potentially doing an initial refcount increase. This means that\n     *   some clusters have already been allocated by the caller, but their\n     *   refcount isn't accurate yet. If we allocate clusters for metadata, we\n     *   need to return -EAGAIN to signal the caller that it needs to restart\n     *   the search for free clusters.\n     *\n     * - alloc_clusters_noref and qcow2_free_clusters may load a different\n     *   refcount block into the cache\n     */\n    *refcount_block = NULL;\n    /* We write to the refcount table, so we might depend on L2 tables */\n    ret = qcow2_cache_flush(bs, s->l2_table_cache);\n    if (ret < 0) {\n        return ret;\n    /* Allocate the refcount block itself and mark it as used */\n    int64_t new_block = alloc_clusters_noref(bs, s->cluster_size);\n    if (new_block < 0) {\n        return new_block;\n#ifdef DEBUG_ALLOC2\n    fprintf(stderr, \"qcow2: Allocate refcount block %d for %\" PRIx64\n        \" at %\" PRIx64 \"\\n\",\n        refcount_table_index, cluster_index << s->cluster_bits, new_block);\n#endif\n    if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) {\n        /* Zero the new refcount block before updating it */\n        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,\n                                    refcount_block);\n        if (ret < 0) {\n            goto fail;\n        memset(*refcount_block, 0, s->cluster_size);\n        /* The block describes itself, need to update the cache */\n        int block_index = (new_block >> s->cluster_bits) &\n            (s->refcount_block_size - 1);\n        s->set_refcount(*refcount_block, block_index, 1);\n    } else {\n        /* Described somewhere else. This can recurse at most twice before we\n         * arrive at a block that describes itself. */\n        ret = update_refcount(bs, new_block, s->cluster_size, 1, false,\n                              QCOW2_DISCARD_NEVER);\n        if (ret < 0) {\n            goto fail;\n        ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n        if (ret < 0) {\n            goto fail;\n        /* Initialize the new refcount block only after updating its refcount,\n         * update_refcount uses the refcount cache itself */\n        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,\n                                    refcount_block);\n        if (ret < 0) {\n            goto fail;\n        memset(*refcount_block, 0, s->cluster_size);\n    /* Now the new refcount block needs to be written to disk */\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE);\n    qcow2_cache_entry_mark_dirty(bs, s->refcount_block_cache, *refcount_block);\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n    if (ret < 0) {\n        goto fail;\n    /* If the refcount table is big enough, just hook the block up there */\n    if (refcount_table_index < s->refcount_table_size) {\n        uint64_t data64 = cpu_to_be64(new_block);\n        BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP);\n        ret = bdrv_pwrite_sync(bs->file,\n            s->refcount_table_offset + refcount_table_index * sizeof(uint64_t),\n            &data64, sizeof(data64));\n        if (ret < 0) {\n            goto fail;\n        s->refcount_table[refcount_table_index] = new_block;\n        /* If there's a hole in s->refcount_table then it can happen\n         * that refcount_table_index < s->max_refcount_table_index */\n        s->max_refcount_table_index =\n            MAX(s->max_refcount_table_index, refcount_table_index);\n        /* The new refcount block may be where the caller intended to put its\n         * data, so let it restart the search. */\n        return -EAGAIN;\n    qcow2_cache_put(bs, s->refcount_block_cache, refcount_block);\n    /*\n     * If we come here, we need to grow the refcount table. Again, a new\n     * refcount table needs some space and we can't simply allocate to avoid\n     * endless recursion.\n     *\n     * Therefore let's grab new refcount blocks at the end of the image, which\n     * will describe themselves and the new refcount table. This way we can\n     * reference them only in the new table and do the switch to the new\n     * refcount table at once without producing an inconsistent state in\n     * between.\n     */\n    BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_GROW);\n    /* Calculate the number of refcount blocks needed so far; this will be the\n     * basis for calculating the index of the first cluster used for the\n     * self-describing refcount structures which we are about to create.\n     *\n     * Because we reached this point, there cannot be any refcount entries for\n     * cluster_index or higher indices yet. However, because new_block has been\n     * allocated to describe that cluster (and it will assume this role later\n     * on), we cannot use that index; also, new_block may actually have a higher\n     * cluster index than cluster_index, so it needs to be taken into account\n     * here (and 1 needs to be added to its value because that cluster is used).\n     */\n    uint64_t blocks_used = DIV_ROUND_UP(MAX(cluster_index + 1,\n                                            (new_block >> s->cluster_bits) + 1),\n                                        s->refcount_block_size);\n    /* Create the new refcount table and blocks */\n    uint64_t meta_offset = (blocks_used * s->refcount_block_size) *\n        s->cluster_size;\n    ret = qcow2_refcount_area(bs, meta_offset, 0, false,\n                              refcount_table_index, new_block);\n    if (ret < 0) {\n        return ret;\n    ret = load_refcount_block(bs, new_block, refcount_block);\n    if (ret < 0) {\n        return ret;\n    /* If we were trying to do the initial refcount update for some cluster\n     * allocation, we might have used the same clusters to store newly\n     * allocated metadata. Make the caller search some new space. */\n    return -EAGAIN;\nfail:\n    if (*refcount_block != NULL) {\n        qcow2_cache_put(bs, s->refcount_block_cache, refcount_block);\n    return ret;", "idx": 25432}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void moxie_cpu_initfn(Object *obj)\n\n{\n\n    CPUState *cs = CPU(obj);\n\n    MoxieCPU *cpu = MOXIE_CPU(obj);\n\n    static int inited;\n\n\n\n    cs->env_ptr = &cpu->env;\n\n    cpu_exec_init(cs, &error_abort);\n\n\n\n    if (tcg_enabled() && !inited) {\n\n        inited = 1;\n\n        moxie_translate_init();\n\n    }\n\n}\n", "idx": 25435}
{"project": "qemu", "commit_id": "b5eff355460643d09e533024360fe0522f368c07", "target": 1, "func": "static int vmdk_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    BDRVVmdkState *s = bs->opaque;\n\n    uint32_t magic;\n\n    int l1_size, i, ret;\n\n\n\n    if (parent_open)\n\n        // Parent must be opened as RO.\n\n        flags = BDRV_O_RDONLY;\n\n    fprintf(stderr, \"(VMDK) image open: flags=0x%x filename=%s\\n\", flags, bs->filename);\n\n\n\n    ret = bdrv_file_open(&s->hd, filename, flags | BDRV_O_AUTOGROW);\n\n    if (ret < 0)\n\n        return ret;\n\n    if (bdrv_pread(s->hd, 0, &magic, sizeof(magic)) != sizeof(magic))\n\n        goto fail;\n\n\n\n    magic = be32_to_cpu(magic);\n\n    if (magic == VMDK3_MAGIC) {\n\n        VMDK3Header header;\n\n\n\n        if (bdrv_pread(s->hd, sizeof(magic), &header, sizeof(header)) != sizeof(header))\n\n            goto fail;\n\n        s->cluster_sectors = le32_to_cpu(header.granularity);\n\n        s->l2_size = 1 << 9;\n\n        s->l1_size = 1 << 6;\n\n        bs->total_sectors = le32_to_cpu(header.disk_sectors);\n\n        s->l1_table_offset = le32_to_cpu(header.l1dir_offset) << 9;\n\n        s->l1_backup_table_offset = 0;\n\n        s->l1_entry_sectors = s->l2_size * s->cluster_sectors;\n\n    } else if (magic == VMDK4_MAGIC) {\n\n        VMDK4Header header;\n\n\n\n        if (bdrv_pread(s->hd, sizeof(magic), &header, sizeof(header)) != sizeof(header))\n\n            goto fail;\n\n        bs->total_sectors = le64_to_cpu(header.capacity);\n\n        s->cluster_sectors = le64_to_cpu(header.granularity);\n\n        s->l2_size = le32_to_cpu(header.num_gtes_per_gte);\n\n        s->l1_entry_sectors = s->l2_size * s->cluster_sectors;\n\n        if (s->l1_entry_sectors <= 0)\n\n            goto fail;\n\n        s->l1_size = (bs->total_sectors + s->l1_entry_sectors - 1)\n\n            / s->l1_entry_sectors;\n\n        s->l1_table_offset = le64_to_cpu(header.rgd_offset) << 9;\n\n        s->l1_backup_table_offset = le64_to_cpu(header.gd_offset) << 9;\n\n\n\n        if (parent_open)\n\n            s->is_parent = 1;\n\n        else\n\n            s->is_parent = 0;\n\n\n\n        // try to open parent images, if exist\n\n        if (vmdk_parent_open(bs, filename) != 0)\n\n            goto fail;\n\n        // write the CID once after the image creation\n\n        s->parent_cid = vmdk_read_cid(bs,1);\n\n    } else {\n\n        goto fail;\n\n    }\n\n\n\n    /* read the L1 table */\n\n    l1_size = s->l1_size * sizeof(uint32_t);\n\n    s->l1_table = qemu_malloc(l1_size);\n\n    if (!s->l1_table)\n\n        goto fail;\n\n    if (bdrv_pread(s->hd, s->l1_table_offset, s->l1_table, l1_size) != l1_size)\n\n        goto fail;\n\n    for(i = 0; i < s->l1_size; i++) {\n\n        le32_to_cpus(&s->l1_table[i]);\n\n    }\n\n\n\n    if (s->l1_backup_table_offset) {\n\n        s->l1_backup_table = qemu_malloc(l1_size);\n\n        if (!s->l1_backup_table)\n\n            goto fail;\n\n        if (bdrv_pread(s->hd, s->l1_backup_table_offset, s->l1_backup_table, l1_size) != l1_size)\n\n            goto fail;\n\n        for(i = 0; i < s->l1_size; i++) {\n\n            le32_to_cpus(&s->l1_backup_table[i]);\n\n        }\n\n    }\n\n\n\n    s->l2_cache = qemu_malloc(s->l2_size * L2_CACHE_SIZE * sizeof(uint32_t));\n\n    if (!s->l2_cache)\n\n        goto fail;\n\n    return 0;\n\n fail:\n\n    qemu_free(s->l1_backup_table);\n\n    qemu_free(s->l1_table);\n\n    qemu_free(s->l2_cache);\n\n    bdrv_delete(s->hd);\n\n    return -1;\n\n}\n", "idx": 25437}
{"project": "qemu", "commit_id": "129c7d1c536d0c67a8781cb09fb5bdb3d0f6a2d0", "target": 1, "func": "static SocketAddress *nbd_config(BDRVNBDState *s, QDict *options, Error **errp)\n\n{\n\n    SocketAddress *saddr = NULL;\n\n    QDict *addr = NULL;\n\n    QObject *crumpled_addr = NULL;\n\n    Visitor *iv = NULL;\n\n    Error *local_err = NULL;\n\n\n\n    qdict_extract_subqdict(options, &addr, \"server.\");\n\n    if (!qdict_size(addr)) {\n\n        error_setg(errp, \"NBD server address missing\");\n\n        goto done;\n\n    }\n\n\n\n    crumpled_addr = qdict_crumple(addr, errp);\n\n    if (!crumpled_addr) {\n\n        goto done;\n\n    }\n\n\n\n\n\n\n\n\n\n\n\n    iv = qobject_input_visitor_new(crumpled_addr);\n\n    visit_type_SocketAddress(iv, NULL, &saddr, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto done;\n\n    }\n\n\n\ndone:\n\n    QDECREF(addr);\n\n    qobject_decref(crumpled_addr);\n\n    visit_free(iv);\n\n    return saddr;\n\n}", "idx": 25438}
{"project": "qemu", "commit_id": "40f16dd1279e7f26357b3c4b3838a89ffc6153da", "target": 1, "func": "static void scsi_read_complete(void * opaque, int ret)\n\n{\n\n    SCSIGenericReq *r = (SCSIGenericReq *)opaque;\n\n    int len;\n\n\n\n    if (ret) {\n\n        DPRINTF(\"IO error ret %d\\n\", ret);\n\n        scsi_command_complete(r, ret);\n\n        return;\n\n    }\n\n    len = r->io_header.dxfer_len - r->io_header.resid;\n\n    DPRINTF(\"Data ready tag=0x%x len=%d\\n\", r->req.tag, len);\n\n\n\n    r->len = -1;\n\n    r->req.bus->complete(r->req.bus, SCSI_REASON_DATA, r->req.tag, len);\n\n    if (len == 0)\n\n        scsi_command_complete(r, 0);\n\n}\n", "idx": 25442}
{"project": "qemu", "commit_id": "4577b09a278fe9134ecb9192c2ae2ed67a0d0aa7", "target": 1, "func": "udp_listen(Slirp *slirp, uint32_t haddr, u_int hport, uint32_t laddr,\n\n           u_int lport, int flags)\n\n{\n\n\tstruct sockaddr_in addr;\n\n\tstruct socket *so;\n\n\tsocklen_t addrlen = sizeof(struct sockaddr_in);\n\n\n\n\tso = socreate(slirp);\n\n\tif (!so) {\n\n\n\n\tso->s = qemu_socket(AF_INET,SOCK_DGRAM,0);\n\n\n\n\n\n\tso->so_expire = curtime + SO_EXPIRE;\n\n\tinsque(so, &slirp->udb);\n\n\n\n\taddr.sin_family = AF_INET;\n\n\taddr.sin_addr.s_addr = haddr;\n\n\taddr.sin_port = hport;\n\n\n\n\tif (bind(so->s,(struct sockaddr *)&addr, addrlen) < 0) {\n\n\t\tudp_detach(so);\n\n\n\n\tsocket_set_fast_reuse(so->s);\n\n\n\n\tgetsockname(so->s,(struct sockaddr *)&addr,&addrlen);\n\n\tso->fhost.sin = addr;\n\n\tsotranslate_accept(so);\n\n\tso->so_lfamily = AF_INET;\n\n\tso->so_lport = lport;\n\n\tso->so_laddr.s_addr = laddr;\n\n\tif (flags != SS_FACCEPTONCE)\n\n\t   so->so_expire = 0;\n\n\n\n\tso->so_state &= SS_PERSISTENT_MASK;\n\n\tso->so_state |= SS_ISFCONNECTED | flags;\n\n\n\n\treturn so;\n", "idx": 25452}
{"project": "qemu", "commit_id": "12848bfc5d719bad536c5448205a3226be1fda47", "target": 1, "func": "static int local_post_create_passthrough(FsContext *fs_ctx, const char *path,\n\n        FsCred *credp)\n\n{\n\n    if (chmod(rpath(fs_ctx, path), credp->fc_mode & 07777) < 0) {\n\n        return -1;\n\n    }\n\n    if (chown(rpath(fs_ctx, path), credp->fc_uid, credp->fc_gid) < 0) {\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 25453}
{"project": "qemu", "commit_id": "7faa8075d898ae56d2c533c530569bb25ab86eaf", "target": 1, "func": "static int piix4_device_hotplug(DeviceState *qdev, PCIDevice *dev,\n\n\t\t\t\tPCIHotplugState state)\n\n{\n\n    int slot = PCI_SLOT(dev->devfn);\n\n    PIIX4PMState *s = DO_UPCAST(PIIX4PMState, dev,\n\n                                PCI_DEVICE(qdev));\n\n\n\n    /* Don't send event when device is enabled during qemu machine creation:\n\n     * it is present on boot, no hotplug event is necessary. We do send an\n\n     * event when the device is disabled later. */\n\n    if (state == PCI_COLDPLUG_ENABLED) {\n\n        return 0;\n\n    }\n\n\n\n    s->pci0_status.up = 0;\n\n    s->pci0_status.down = 0;\n\n    if (state == PCI_HOTPLUG_ENABLED) {\n\n        enable_device(s, slot);\n\n    } else {\n\n        disable_device(s, slot);\n\n    }\n\n\n\n    pm_update_sci(s);\n\n\n\n    return 0;\n\n}\n", "idx": 25454}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qmp_migrate_set_cache_size(int64_t value, Error **errp)\n\n{\n\n    MigrationState *s = migrate_get_current();\n\n    int64_t new_size;\n\n\n\n    /* Check for truncation */\n\n    if (value != (size_t)value) {\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                  \"exceeding address space\");\n\n        return;\n\n    }\n\n\n\n    /* Cache should not be larger than guest ram size */\n\n    if (value > ram_bytes_total()) {\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                  \"exceeds guest ram size \");\n\n        return;\n\n    }\n\n\n\n    new_size = xbzrle_cache_resize(value);\n\n    if (new_size < 0) {\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                  \"is smaller than page size\");\n\n        return;\n\n    }\n\n\n\n    s->xbzrle_cache_size = new_size;\n\n}\n", "idx": 25456}
{"project": "qemu", "commit_id": "70976a7926b42d87e0c575412b85a8f5c1e48fad", "target": 1, "func": "static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)\n\n{\n\n    if (n < 32) {\n\n#ifdef WORDS_BIGENDIAN\n\n        env->avr[n].u64[0] = ldq_p(mem_buf);\n\n        env->avr[n].u64[1] = ldq_p(mem_buf+8);\n\n#else\n\n        env->avr[n].u64[1] = ldq_p(mem_buf);\n\n        env->avr[n].u64[0] = ldq_p(mem_buf+8);\n\n#endif\n\n        return 16;\n\n    }\n\n    if (n == 33) {\n\n        env->vscr = ldl_p(mem_buf);\n\n        return 4;\n\n    }\n\n    if (n == 34) {\n\n        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);\n\n        return 4;\n\n    }\n\n    return 0;\n\n}\n", "idx": 25459}
{"project": "qemu", "commit_id": "84593a0807004d852132eaa56edf24d55793d480", "target": 1, "func": "static void ram_save_cleanup(void *opaque)\n\n{\n\n    RAMState **rsp = opaque;\n\n    RAMBlock *block;\n\n\n\n    /* caller have hold iothread lock or is in a bh, so there is\n\n     * no writing race against this migration_bitmap\n\n     */\n\n    memory_global_dirty_log_stop();\n\n\n\n    QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {\n\n        g_free(block->bmap);\n\n        block->bmap = NULL;\n\n        g_free(block->unsentmap);\n\n        block->unsentmap = NULL;\n\n    }\n\n\n\n    XBZRLE_cache_lock();\n\n    if (XBZRLE.cache) {\n\n        cache_fini(XBZRLE.cache);\n\n        g_free(XBZRLE.encoded_buf);\n\n        g_free(XBZRLE.current_buf);\n\n        g_free(XBZRLE.zero_target_page);\n\n        XBZRLE.cache = NULL;\n\n        XBZRLE.encoded_buf = NULL;\n\n        XBZRLE.current_buf = NULL;\n\n        XBZRLE.zero_target_page = NULL;\n\n    }\n\n    XBZRLE_cache_unlock();\n\n    compress_threads_save_cleanup();\n\n    ram_state_cleanup(rsp);\n\n}\n", "idx": 25462}
{"project": "qemu", "commit_id": "069eb7b2b8fc47c7cb52e5a4af23ea98d939e3da", "target": 1, "func": "static void es1370_class_init (ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS (klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS (klass);\n\n\n\n    k->realize = es1370_realize;\n\n\n    k->vendor_id = PCI_VENDOR_ID_ENSONIQ;\n\n    k->device_id = PCI_DEVICE_ID_ENSONIQ_ES1370;\n\n    k->class_id = PCI_CLASS_MULTIMEDIA_AUDIO;\n\n    k->subsystem_vendor_id = 0x4942;\n\n    k->subsystem_id = 0x4c4c;\n\n    set_bit(DEVICE_CATEGORY_SOUND, dc->categories);\n\n    dc->desc = \"ENSONIQ AudioPCI ES1370\";\n\n    dc->vmsd = &vmstate_es1370;\n\n}", "idx": 25465}
{"project": "qemu", "commit_id": "21ce148c7ec71ee32834061355a5ecfd1a11f90f", "target": 1, "func": "static inline int64_t add64(const int64_t a, const int64_t b)\n\n{\n\n\treturn a + b;\n\n}\n", "idx": 25467}
{"project": "qemu", "commit_id": "21b2f13ae21974e0fd7f8da99d84628a8000d1d7", "target": 1, "func": "static void mmubooke_dump_mmu(FILE *f, fprintf_function cpu_fprintf,\n\n                                 CPUPPCState *env)\n\n{\n\n    ppcemb_tlb_t *entry;\n\n    int i;\n\n\n\n    if (kvm_enabled() && !env->kvm_sw_tlb) {\n\n        cpu_fprintf(f, \"Cannot access KVM TLB\\n\");\n\n        return;\n\n    }\n\n\n\n    cpu_fprintf(f, \"\\nTLB:\\n\");\n\n    cpu_fprintf(f, \"Effective          Physical           Size PID   Prot     \"\n\n                \"Attr\\n\");\n\n\n\n    entry = &env->tlb.tlbe[0];\n\n    for (i = 0; i < env->nb_tlb; i++, entry++) {\n\n        hwaddr ea, pa;\n\n        target_ulong mask;\n\n        uint64_t size = (uint64_t)entry->size;\n\n        char size_buf[20];\n\n\n\n        /* Check valid flag */\n\n        if (!(entry->prot & PAGE_VALID)) {\n\n            continue;\n\n        }\n\n\n\n        mask = ~(entry->size - 1);\n\n        ea = entry->EPN & mask;\n\n        pa = entry->RPN & mask;\n\n#if (TARGET_PHYS_ADDR_SPACE_BITS >= 36)\n\n        /* Extend the physical address to 36 bits */\n\n        pa |= (hwaddr)(entry->RPN & 0xF) << 32;\n\n#endif\n\n        size /= 1024;\n\n        if (size >= 1024) {\n\n            snprintf(size_buf, sizeof(size_buf), \"%3\" PRId64 \"M\", size / 1024);\n\n        } else {\n\n            snprintf(size_buf, sizeof(size_buf), \"%3\" PRId64 \"k\", size);\n\n        }\n\n        cpu_fprintf(f, \"0x%016\" PRIx64 \" 0x%016\" PRIx64 \" %s %-5u %08x %08x\\n\",\n\n                    (uint64_t)ea, (uint64_t)pa, size_buf, (uint32_t)entry->PID,\n\n                    entry->prot, entry->attr);\n\n    }\n\n\n\n}\n", "idx": 25468}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static void slavio_timer_init_all(target_phys_addr_t addr, qemu_irq master_irq,\n\n                                  qemu_irq *cpu_irqs, unsigned int num_cpus)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    unsigned int i;\n\n\n\n    dev = qdev_create(NULL, \"slavio_timer\");\n\n    qdev_prop_set_uint32(dev, \"num_cpus\", num_cpus);\n\n    qdev_init(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, master_irq);\n\n    sysbus_mmio_map(s, 0, addr + SYS_TIMER_OFFSET);\n\n\n\n    for (i = 0; i < MAX_CPUS; i++) {\n\n        sysbus_mmio_map(s, i + 1, addr + (target_phys_addr_t)CPU_TIMER_OFFSET(i));\n\n        sysbus_connect_irq(s, i + 1, cpu_irqs[i]);\n\n    }\n\n}\n", "idx": 25469}
{"project": "qemu", "commit_id": "94ef4f337fb614f18b765a8e0e878a4c23cdedcd", "target": 1, "func": "static void vga_draw_text(VGACommonState *s, int full_update)\n\n{\n\n    DisplaySurface *surface = qemu_console_surface(s->con);\n\n    int cx, cy, cheight, cw, ch, cattr, height, width, ch_attr;\n\n    int cx_min, cx_max, linesize, x_incr, line, line1;\n\n    uint32_t offset, fgcol, bgcol, v, cursor_offset;\n\n    uint8_t *d1, *d, *src, *dest, *cursor_ptr;\n\n    const uint8_t *font_ptr, *font_base[2];\n\n    int dup9, line_offset;\n\n    uint32_t *palette;\n\n    uint32_t *ch_attr_ptr;\n\n    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL);\n\n\n\n    /* compute font data address (in plane 2) */\n\n    v = s->sr[VGA_SEQ_CHARACTER_MAP];\n\n    offset = (((v >> 4) & 1) | ((v << 1) & 6)) * 8192 * 4 + 2;\n\n    if (offset != s->font_offsets[0]) {\n\n        s->font_offsets[0] = offset;\n\n        full_update = 1;\n\n    }\n\n    font_base[0] = s->vram_ptr + offset;\n\n\n\n    offset = (((v >> 5) & 1) | ((v >> 1) & 6)) * 8192 * 4 + 2;\n\n    font_base[1] = s->vram_ptr + offset;\n\n    if (offset != s->font_offsets[1]) {\n\n        s->font_offsets[1] = offset;\n\n        full_update = 1;\n\n    }\n\n    if (s->plane_updated & (1 << 2) || s->has_chain4_alias) {\n\n        /* if the plane 2 was modified since the last display, it\n\n           indicates the font may have been modified */\n\n        s->plane_updated = 0;\n\n        full_update = 1;\n\n    }\n\n    full_update |= update_basic_params(s);\n\n\n\n    line_offset = s->line_offset;\n\n\n\n    vga_get_text_resolution(s, &width, &height, &cw, &cheight);\n\n    if ((height * width) <= 1) {\n\n        /* better than nothing: exit if transient size is too small */\n\n        return;\n\n    }\n\n    if ((height * width) > CH_ATTR_SIZE) {\n\n        /* better than nothing: exit if transient size is too big */\n\n        return;\n\n    }\n\n\n\n    if (width != s->last_width || height != s->last_height ||\n\n        cw != s->last_cw || cheight != s->last_ch || s->last_depth) {\n\n        s->last_scr_width = width * cw;\n\n        s->last_scr_height = height * cheight;\n\n        qemu_console_resize(s->con, s->last_scr_width, s->last_scr_height);\n\n        surface = qemu_console_surface(s->con);\n\n        dpy_text_resize(s->con, width, height);\n\n        s->last_depth = 0;\n\n        s->last_width = width;\n\n        s->last_height = height;\n\n        s->last_ch = cheight;\n\n        s->last_cw = cw;\n\n        full_update = 1;\n\n    }\n\n    full_update |= update_palette16(s);\n\n    palette = s->last_palette;\n\n    x_incr = cw * surface_bytes_per_pixel(surface);\n\n\n\n    if (full_update) {\n\n        s->full_update_text = 1;\n\n    }\n\n    if (s->full_update_gfx) {\n\n        s->full_update_gfx = 0;\n\n        full_update |= 1;\n\n    }\n\n\n\n    cursor_offset = ((s->cr[VGA_CRTC_CURSOR_HI] << 8) |\n\n                     s->cr[VGA_CRTC_CURSOR_LO]) - s->start_addr;\n\n    if (cursor_offset != s->cursor_offset ||\n\n        s->cr[VGA_CRTC_CURSOR_START] != s->cursor_start ||\n\n        s->cr[VGA_CRTC_CURSOR_END] != s->cursor_end) {\n\n      /* if the cursor position changed, we update the old and new\n\n         chars */\n\n        if (s->cursor_offset < CH_ATTR_SIZE)\n\n            s->last_ch_attr[s->cursor_offset] = -1;\n\n        if (cursor_offset < CH_ATTR_SIZE)\n\n            s->last_ch_attr[cursor_offset] = -1;\n\n        s->cursor_offset = cursor_offset;\n\n        s->cursor_start = s->cr[VGA_CRTC_CURSOR_START];\n\n        s->cursor_end = s->cr[VGA_CRTC_CURSOR_END];\n\n    }\n\n    cursor_ptr = s->vram_ptr + (s->start_addr + cursor_offset) * 4;\n\n    if (now >= s->cursor_blink_time) {\n\n        s->cursor_blink_time = now + VGA_TEXT_CURSOR_PERIOD_MS / 2;\n\n        s->cursor_visible_phase = !s->cursor_visible_phase;\n\n    }\n\n\n\n    dest = surface_data(surface);\n\n    linesize = surface_stride(surface);\n\n    ch_attr_ptr = s->last_ch_attr;\n\n    line = 0;\n\n    offset = s->start_addr * 4;\n\n    for(cy = 0; cy < height; cy++) {\n\n        d1 = dest;\n\n        src = s->vram_ptr + offset;\n\n        cx_min = width;\n\n        cx_max = -1;\n\n        for(cx = 0; cx < width; cx++) {\n\n            ch_attr = *(uint16_t *)src;\n\n            if (full_update || ch_attr != *ch_attr_ptr || src == cursor_ptr) {\n\n                if (cx < cx_min)\n\n                    cx_min = cx;\n\n                if (cx > cx_max)\n\n                    cx_max = cx;\n\n                *ch_attr_ptr = ch_attr;\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n                ch = ch_attr >> 8;\n\n                cattr = ch_attr & 0xff;\n\n#else\n\n                ch = ch_attr & 0xff;\n\n                cattr = ch_attr >> 8;\n\n#endif\n\n                font_ptr = font_base[(cattr >> 3) & 1];\n\n                font_ptr += 32 * 4 * ch;\n\n                bgcol = palette[cattr >> 4];\n\n                fgcol = palette[cattr & 0x0f];\n\n                if (cw == 16) {\n\n                    vga_draw_glyph16(d1, linesize,\n\n                                     font_ptr, cheight, fgcol, bgcol);\n\n                } else if (cw != 9) {\n\n                    vga_draw_glyph8(d1, linesize,\n\n                                    font_ptr, cheight, fgcol, bgcol);\n\n                } else {\n\n                    dup9 = 0;\n\n                    if (ch >= 0xb0 && ch <= 0xdf &&\n\n                        (s->ar[VGA_ATC_MODE] & 0x04)) {\n\n                        dup9 = 1;\n\n                    }\n\n                    vga_draw_glyph9(d1, linesize,\n\n                                    font_ptr, cheight, fgcol, bgcol, dup9);\n\n                }\n\n                if (src == cursor_ptr &&\n\n                    !(s->cr[VGA_CRTC_CURSOR_START] & 0x20) &&\n\n                    s->cursor_visible_phase) {\n\n                    int line_start, line_last, h;\n\n                    /* draw the cursor */\n\n                    line_start = s->cr[VGA_CRTC_CURSOR_START] & 0x1f;\n\n                    line_last = s->cr[VGA_CRTC_CURSOR_END] & 0x1f;\n\n                    /* XXX: check that */\n\n                    if (line_last > cheight - 1)\n\n                        line_last = cheight - 1;\n\n                    if (line_last >= line_start && line_start < cheight) {\n\n                        h = line_last - line_start + 1;\n\n                        d = d1 + linesize * line_start;\n\n                        if (cw == 16) {\n\n                            vga_draw_glyph16(d, linesize,\n\n                                             cursor_glyph, h, fgcol, bgcol);\n\n                        } else if (cw != 9) {\n\n                            vga_draw_glyph8(d, linesize,\n\n                                            cursor_glyph, h, fgcol, bgcol);\n\n                        } else {\n\n                            vga_draw_glyph9(d, linesize,\n\n                                            cursor_glyph, h, fgcol, bgcol, 1);\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            d1 += x_incr;\n\n            src += 4;\n\n            ch_attr_ptr++;\n\n        }\n\n        if (cx_max != -1) {\n\n            dpy_gfx_update(s->con, cx_min * cw, cy * cheight,\n\n                           (cx_max - cx_min + 1) * cw, cheight);\n\n        }\n\n        dest += linesize * cheight;\n\n        line1 = line + cheight;\n\n        offset += line_offset;\n\n        if (line < s->line_compare && line1 >= s->line_compare) {\n\n            offset = 0;\n\n        }\n\n        line = line1;\n\n    }\n\n}\n", "idx": 25472}
{"project": "qemu", "commit_id": "d470ad42acfc73c45d3e8ed5311a491160b4c100", "target": 1, "func": "static void secondary_do_checkpoint(BDRVReplicationState *s, Error **errp)\n{\n    Error *local_err = NULL;\n    int ret;\n    if (!s->secondary_disk->bs->job) {\n        error_setg(errp, \"Backup job was cancelled unexpectedly\");\n    backup_do_checkpoint(s->secondary_disk->bs->job, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n    ret = s->active_disk->bs->drv->bdrv_make_empty(s->active_disk->bs);\n    if (ret < 0) {\n        error_setg(errp, \"Cannot make active disk empty\");\n    ret = s->hidden_disk->bs->drv->bdrv_make_empty(s->hidden_disk->bs);\n    if (ret < 0) {\n        error_setg(errp, \"Cannot make hidden disk empty\");", "idx": 25478}
{"project": "qemu", "commit_id": "21ef45d71221b4577330fe3aacfb06afad91ad46", "target": 1, "func": "static void vnc_dpy_update(DisplayChangeListener *dcl,\n\n                           DisplayState *ds,\n\n                           int x, int y, int w, int h)\n\n{\n\n    int i;\n\n    VncDisplay *vd = ds->opaque;\n\n    struct VncSurface *s = &vd->guest;\n\n    int width = ds_get_width(ds);\n\n    int height = ds_get_height(ds);\n\n\n\n    h += y;\n\n\n\n    /* round x down to ensure the loop only spans one 16-pixel block per,\n\n       iteration.  otherwise, if (x % 16) != 0, the last iteration may span\n\n       two 16-pixel blocks but we only mark the first as dirty\n\n    */\n\n    w += (x % 16);\n\n    x -= (x % 16);\n\n\n\n    x = MIN(x, width);\n\n    y = MIN(y, height);\n\n    w = MIN(x + w, width) - x;\n\n    h = MIN(h, height);\n\n\n\n    for (; y < h; y++)\n\n        for (i = 0; i < w; i += 16)\n\n            set_bit((x + i) / 16, s->dirty[y]);\n\n}\n", "idx": 25479}
{"project": "qemu", "commit_id": "556c2b60714e7dae3ed0eb3488910435263dc09f", "target": 1, "func": "static int aio_read_f(BlockBackend *blk, int argc, char **argv)\n\n{\n\n    int nr_iov, c;\n\n    struct aio_ctx *ctx = g_new0(struct aio_ctx, 1);\n\n\n\n    ctx->blk = blk;\n\n    while ((c = getopt(argc, argv, \"CP:qv\")) != -1) {\n\n        switch (c) {\n\n        case 'C':\n\n            ctx->Cflag = 1;\n\n            break;\n\n        case 'P':\n\n            ctx->Pflag = 1;\n\n            ctx->pattern = parse_pattern(optarg);\n\n            if (ctx->pattern < 0) {\n\n                g_free(ctx);\n\n                return 0;\n\n            }\n\n            break;\n\n        case 'q':\n\n            ctx->qflag = 1;\n\n            break;\n\n        case 'v':\n\n            ctx->vflag = 1;\n\n            break;\n\n        default:\n\n            g_free(ctx);\n\n            return qemuio_command_usage(&aio_read_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind > argc - 2) {\n\n        g_free(ctx);\n\n        return qemuio_command_usage(&aio_read_cmd);\n\n    }\n\n\n\n    ctx->offset = cvtnum(argv[optind]);\n\n    if (ctx->offset < 0) {\n\n        print_cvtnum_err(ctx->offset, argv[optind]);\n\n        g_free(ctx);\n\n        return 0;\n\n    }\n\n    optind++;\n\n\n\n    if (ctx->offset & 0x1ff) {\n\n        printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n               ctx->offset);\n\n\n        g_free(ctx);\n\n        return 0;\n\n    }\n\n\n\n    nr_iov = argc - optind;\n\n    ctx->buf = create_iovec(blk, &ctx->qiov, &argv[optind], nr_iov, 0xab);\n\n    if (ctx->buf == NULL) {\n\n\n        g_free(ctx);\n\n        return 0;\n\n    }\n\n\n\n    gettimeofday(&ctx->t1, NULL);\n\n    block_acct_start(blk_get_stats(blk), &ctx->acct, ctx->qiov.size,\n\n                     BLOCK_ACCT_READ);\n\n    blk_aio_readv(blk, ctx->offset >> 9, &ctx->qiov,\n\n                  ctx->qiov.size >> 9, aio_read_done, ctx);\n\n    return 0;\n\n}", "idx": 25480}
{"project": "qemu", "commit_id": "78a52ad5acca7053b774fcc80290e7b7e224c80a", "target": 1, "func": "static int count_contiguous_clusters(uint64_t nb_clusters, int cluster_size,\n\n        uint64_t *l2_table, uint64_t stop_flags)\n\n{\n\n    int i;\n\n    uint64_t mask = stop_flags | L2E_OFFSET_MASK | QCOW2_CLUSTER_COMPRESSED;\n\n    uint64_t first_entry = be64_to_cpu(l2_table[0]);\n\n    uint64_t offset = first_entry & mask;\n\n\n\n    if (!offset)\n\n        return 0;\n\n\n\n    assert(qcow2_get_cluster_type(first_entry) != QCOW2_CLUSTER_COMPRESSED);\n\n\n\n    for (i = 0; i < nb_clusters; i++) {\n\n        uint64_t l2_entry = be64_to_cpu(l2_table[i]) & mask;\n\n        if (offset + (uint64_t) i * cluster_size != l2_entry) {\n\n            break;\n\n        }\n\n    }\n\n\n\n\treturn i;\n\n}\n", "idx": 25483}
{"project": "qemu", "commit_id": "5af2ae2305143f1805a696f9554231e1fc246edc", "target": 1, "func": "AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)\n\n{\n\n    PCIBus *bus = PCI_BUS(dev->bus);\n\n\n\n    if (bus->iommu_fn) {\n\n        return bus->iommu_fn(bus, bus->iommu_opaque, dev->devfn);\n\n    }\n\n\n\n    if (bus->parent_dev) {\n\n        /** We are ignoring the bus master DMA bit of the bridge\n\n         *  as it would complicate things such as VFIO for no good reason */\n\n        return pci_device_iommu_address_space(bus->parent_dev);\n\n    }\n\n\n\n    return &address_space_memory;\n\n}\n", "idx": 25484}
{"project": "qemu", "commit_id": "aab99135b63522267c6fdae04712cb2f02c8c7de", "target": 1, "func": "static void attach(sPAPRDRConnector *drc, DeviceState *d, void *fdt,\n                   int fdt_start_offset, bool coldplug, Error **errp)\n{\n    DPRINTFN(\"drc: %x, attach\", get_index(drc));\n    if (drc->isolation_state != SPAPR_DR_ISOLATION_STATE_ISOLATED) {\n        error_setg(errp, \"an attached device is still awaiting release\");\n        return;\n    if (drc->type == SPAPR_DR_CONNECTOR_TYPE_PCI) {\n        g_assert(drc->allocation_state == SPAPR_DR_ALLOCATION_STATE_USABLE);\n    g_assert(fdt || coldplug);\n    /* NOTE: setting initial isolation state to UNISOLATED means we can't\n     * detach unless guest has a userspace/kernel that moves this state\n     * back to ISOLATED in response to an unplug event, or this is done\n     * manually by the admin prior. if we force things while the guest\n     * may be accessing the device, we can easily crash the guest, so we\n     * we defer completion of removal in such cases to the reset() hook.\n     */\n    if (drc->type == SPAPR_DR_CONNECTOR_TYPE_PCI) {\n        drc->isolation_state = SPAPR_DR_ISOLATION_STATE_UNISOLATED;\n    drc->indicator_state = SPAPR_DR_INDICATOR_STATE_ACTIVE;\n    drc->dev = d;\n    drc->fdt = fdt;\n    drc->fdt_start_offset = fdt_start_offset;\n    drc->configured = coldplug;\n    /* 'logical' DR resources such as memory/cpus are in some cases treated\n     * as a pool of resources from which the guest is free to choose from\n     * based on only a count. for resources that can be assigned in this\n     * fashion, we must assume the resource is signalled immediately\n     * since a single hotplug request might make an arbitrary number of\n     * such attached resources available to the guest, as opposed to\n     * 'physical' DR resources such as PCI where each device/resource is\n     * signalled individually.\n     */\n    drc->signalled = (drc->type != SPAPR_DR_CONNECTOR_TYPE_PCI)\n                     ? true : coldplug;\n    object_property_add_link(OBJECT(drc), \"device\",\n                             object_get_typename(OBJECT(drc->dev)),\n                             (Object **)(&drc->dev),\n                             NULL, 0, NULL);", "idx": 25486}
{"project": "qemu", "commit_id": "b544c1aba8681c2fe5d6715fbd37cf6caf1bc7bb", "target": 1, "func": "static void coroutine_fn sd_write_done(SheepdogAIOCB *acb)\n\n{\n\n    BDRVSheepdogState *s = acb->common.bs->opaque;\n\n    struct iovec iov;\n\n    AIOReq *aio_req;\n\n    uint32_t offset, data_len, mn, mx;\n\n\n\n    mn = s->min_dirty_data_idx;\n\n    mx = s->max_dirty_data_idx;\n\n    if (mn <= mx) {\n\n        /* we need to update the vdi object. */\n\n        offset = sizeof(s->inode) - sizeof(s->inode.data_vdi_id) +\n\n            mn * sizeof(s->inode.data_vdi_id[0]);\n\n        data_len = (mx - mn + 1) * sizeof(s->inode.data_vdi_id[0]);\n\n\n\n        s->min_dirty_data_idx = UINT32_MAX;\n\n        s->max_dirty_data_idx = 0;\n\n\n\n        iov.iov_base = &s->inode;\n\n        iov.iov_len = sizeof(s->inode);\n\n        aio_req = alloc_aio_req(s, acb, vid_to_vdi_oid(s->inode.vdi_id),\n\n                                data_len, offset, 0, 0, offset);\n\n        QLIST_INSERT_HEAD(&s->inflight_aio_head, aio_req, aio_siblings);\n\n        add_aio_request(s, aio_req, &iov, 1, false, AIOCB_WRITE_UDATA);\n\n\n\n        acb->aio_done_func = sd_finish_aiocb;\n\n        acb->aiocb_type = AIOCB_WRITE_UDATA;\n\n        return;\n\n    }\n\n\n\n    sd_finish_aiocb(acb);\n\n}\n", "idx": 25487}
{"project": "qemu", "commit_id": "60be6340796e66b5ac8aac2d98dde5c79336a89c", "target": 1, "func": "void migration_bitmap_extend(ram_addr_t old, ram_addr_t new)\n\n{\n\n    /* called in qemu main thread, so there is\n\n     * no writing race against this migration_bitmap\n\n     */\n\n    if (migration_bitmap) {\n\n        unsigned long *old_bitmap = migration_bitmap, *bitmap;\n\n        bitmap = bitmap_new(new);\n\n\n\n        /* prevent migration_bitmap content from being set bit\n\n         * by migration_bitmap_sync_range() at the same time.\n\n         * it is safe to migration if migration_bitmap is cleared bit\n\n         * at the same time.\n\n         */\n\n        qemu_mutex_lock(&migration_bitmap_mutex);\n\n        bitmap_copy(bitmap, old_bitmap, old);\n\n        bitmap_set(bitmap, old, new - old);\n\n        atomic_rcu_set(&migration_bitmap, bitmap);\n\n        qemu_mutex_unlock(&migration_bitmap_mutex);\n\n        migration_dirty_pages += new - old;\n\n        synchronize_rcu();\n\n        g_free(old_bitmap);\n\n    }\n\n}\n", "idx": 25490}
{"project": "qemu", "commit_id": "49dd946bb5419681c8668b09a6d10f42bc707b78", "target": 1, "func": "static void coroutine_fn v9fs_walk(void *opaque)\n\n{\n\n    int name_idx;\n\n    V9fsQID *qids = NULL;\n\n    int i, err = 0;\n\n    V9fsPath dpath, path;\n\n    uint16_t nwnames;\n\n    struct stat stbuf;\n\n    size_t offset = 7;\n\n    int32_t fid, newfid;\n\n    V9fsString *wnames = NULL;\n\n    V9fsFidState *fidp;\n\n    V9fsFidState *newfidp = NULL;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n    V9fsQID qid;\n\n\n\n    err = pdu_unmarshal(pdu, offset, \"ddw\", &fid, &newfid, &nwnames);\n\n    if (err < 0) {\n\n        pdu_complete(pdu, err);\n\n        return ;\n\n    }\n\n    offset += err;\n\n\n\n    trace_v9fs_walk(pdu->tag, pdu->id, fid, newfid, nwnames);\n\n\n\n    if (nwnames && nwnames <= P9_MAXWELEM) {\n\n        wnames = g_malloc0(sizeof(wnames[0]) * nwnames);\n\n        qids   = g_malloc0(sizeof(qids[0]) * nwnames);\n\n        for (i = 0; i < nwnames; i++) {\n\n            err = pdu_unmarshal(pdu, offset, \"s\", &wnames[i]);\n\n            if (err < 0) {\n\n                goto out_nofid;\n\n            }\n\n            if (name_is_illegal(wnames[i].data)) {\n\n                err = -ENOENT;\n\n                goto out_nofid;\n\n            }\n\n            offset += err;\n\n        }\n\n    } else if (nwnames > P9_MAXWELEM) {\n\n        err = -EINVAL;\n\n        goto out_nofid;\n\n    }\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n\n\n    v9fs_path_init(&dpath);\n\n    v9fs_path_init(&path);\n\n\n\n    err = fid_to_qid(pdu, fidp, &qid);\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n\n\n    /*\n\n     * Both dpath and path initially poin to fidp.\n\n     * Needed to handle request with nwnames == 0\n\n     */\n\n    v9fs_path_copy(&dpath, &fidp->path);\n\n    v9fs_path_copy(&path, &fidp->path);\n\n    for (name_idx = 0; name_idx < nwnames; name_idx++) {\n\n        if (not_same_qid(&pdu->s->root_qid, &qid) ||\n\n            strcmp(\"..\", wnames[name_idx].data)) {\n\n            err = v9fs_co_name_to_path(pdu, &dpath, wnames[name_idx].data,\n\n                                       &path);\n\n            if (err < 0) {\n\n                goto out;\n\n            }\n\n\n\n            err = v9fs_co_lstat(pdu, &path, &stbuf);\n\n            if (err < 0) {\n\n                goto out;\n\n            }\n\n            stat_to_qid(&stbuf, &qid);\n\n            v9fs_path_copy(&dpath, &path);\n\n        }\n\n        memcpy(&qids[name_idx], &qid, sizeof(qid));\n\n    }\n\n    if (fid == newfid) {\n\n        BUG_ON(fidp->fid_type != P9_FID_NONE);\n\n        v9fs_path_copy(&fidp->path, &path);\n\n    } else {\n\n        newfidp = alloc_fid(s, newfid);\n\n        if (newfidp == NULL) {\n\n            err = -EINVAL;\n\n            goto out;\n\n        }\n\n        newfidp->uid = fidp->uid;\n\n        v9fs_path_copy(&newfidp->path, &path);\n\n    }\n\n    err = v9fs_walk_marshal(pdu, nwnames, qids);\n\n    trace_v9fs_walk_return(pdu->tag, pdu->id, nwnames, qids);\n\nout:\n\n    put_fid(pdu, fidp);\n\n    if (newfidp) {\n\n        put_fid(pdu, newfidp);\n\n    }\n\n    v9fs_path_free(&dpath);\n\n    v9fs_path_free(&path);\n\nout_nofid:\n\n    pdu_complete(pdu, err);\n\n    if (nwnames && nwnames <= P9_MAXWELEM) {\n\n        for (name_idx = 0; name_idx < nwnames; name_idx++) {\n\n            v9fs_string_free(&wnames[name_idx]);\n\n        }\n\n        g_free(wnames);\n\n        g_free(qids);\n\n    }\n\n}\n", "idx": 25491}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "int64_t qemu_ftell(QEMUFile *f)\n\n{\n\n    qemu_fflush(f);\n\n    return f->pos;\n\n}\n", "idx": 25492}
{"project": "qemu", "commit_id": "55a10996034cb2e633f0437cedd97f345183c0ec", "target": 1, "func": "InetSocketAddress *inet_parse(const char *str, Error **errp)\n\n{\n\n    InetSocketAddress *addr;\n\n    const char *optstr, *h;\n\n    char host[64];\n\n    char port[33];\n\n    int to;\n\n    int pos;\n\n\n\n    addr = g_new0(InetSocketAddress, 1);\n\n\n\n    /* parse address */\n\n    if (str[0] == ':') {\n\n        /* no host given */\n\n        host[0] = '\\0';\n\n        if (1 != sscanf(str, \":%32[^,]%n\", port, &pos)) {\n\n            error_setg(errp, \"error parsing port in address '%s'\", str);\n\n            goto fail;\n\n        }\n\n    } else if (str[0] == '[') {\n\n        /* IPv6 addr */\n\n        if (2 != sscanf(str, \"[%64[^]]]:%32[^,]%n\", host, port, &pos)) {\n\n            error_setg(errp, \"error parsing IPv6 address '%s'\", str);\n\n            goto fail;\n\n        }\n\n        addr->ipv6 = addr->has_ipv6 = true;\n\n    } else {\n\n        /* hostname or IPv4 addr */\n\n        if (2 != sscanf(str, \"%64[^:]:%32[^,]%n\", host, port, &pos)) {\n\n            error_setg(errp, \"error parsing address '%s'\", str);\n\n            goto fail;\n\n        }\n\n        if (host[strspn(host, \"0123456789.\")] == '\\0') {\n\n            addr->ipv4 = addr->has_ipv4 = true;\n\n        }\n\n    }\n\n\n\n    addr->host = g_strdup(host);\n\n    addr->port = g_strdup(port);\n\n\n\n    /* parse options */\n\n    optstr = str + pos;\n\n    h = strstr(optstr, \",to=\");\n\n    if (h) {\n\n        h += 4;\n\n        if (sscanf(h, \"%d%n\", &to, &pos) != 1 ||\n\n            (h[pos] != '\\0' && h[pos] != ',')) {\n\n            error_setg(errp, \"error parsing to= argument\");\n\n            goto fail;\n\n        }\n\n        addr->has_to = true;\n\n        addr->to = to;\n\n    }\n\n    if (strstr(optstr, \",ipv4\")) {\n\n        addr->ipv4 = addr->has_ipv4 = true;\n\n    }\n\n    if (strstr(optstr, \",ipv6\")) {\n\n        addr->ipv6 = addr->has_ipv6 = true;\n\n    }\n\n    return addr;\n\n\n\nfail:\n\n    qapi_free_InetSocketAddress(addr);\n\n    return NULL;\n\n}\n", "idx": 25494}
{"project": "qemu", "commit_id": "eebe0b7905642a986cbce7406d6ab7bf78f3e210", "target": 1, "func": "static int vnc_update_stats(VncDisplay *vd,  struct timeval * tv)\n\n{\n\n    int width = pixman_image_get_width(vd->guest.fb);\n\n    int height = pixman_image_get_height(vd->guest.fb);\n\n    int x, y;\n\n    struct timeval res;\n\n    int has_dirty = 0;\n\n\n\n    for (y = 0; y < height; y += VNC_STAT_RECT) {\n\n        for (x = 0; x < width; x += VNC_STAT_RECT) {\n\n            VncRectStat *rect = vnc_stat_rect(vd, x, y);\n\n\n\n            rect->updated = false;\n\n        }\n\n    }\n\n\n\n    qemu_timersub(tv, &VNC_REFRESH_STATS, &res);\n\n\n\n    if (timercmp(&vd->guest.last_freq_check, &res, >)) {\n\n        return has_dirty;\n\n    }\n\n    vd->guest.last_freq_check = *tv;\n\n\n\n    for (y = 0; y < height; y += VNC_STAT_RECT) {\n\n        for (x = 0; x < width; x += VNC_STAT_RECT) {\n\n            VncRectStat *rect= vnc_stat_rect(vd, x, y);\n\n            int count = ARRAY_SIZE(rect->times);\n\n            struct timeval min, max;\n\n\n\n            if (!timerisset(&rect->times[count - 1])) {\n\n                continue ;\n\n            }\n\n\n\n            max = rect->times[(rect->idx + count - 1) % count];\n\n            qemu_timersub(tv, &max, &res);\n\n\n\n            if (timercmp(&res, &VNC_REFRESH_LOSSY, >)) {\n\n                rect->freq = 0;\n\n                has_dirty += vnc_refresh_lossy_rect(vd, x, y);\n\n                memset(rect->times, 0, sizeof (rect->times));\n\n                continue ;\n\n            }\n\n\n\n            min = rect->times[rect->idx];\n\n            max = rect->times[(rect->idx + count - 1) % count];\n\n            qemu_timersub(&max, &min, &res);\n\n\n\n            rect->freq = res.tv_sec + res.tv_usec / 1000000.;\n\n            rect->freq /= count;\n\n            rect->freq = 1. / rect->freq;\n\n        }\n\n    }\n\n    return has_dirty;\n\n}\n", "idx": 25495}
{"project": "qemu", "commit_id": "6d1f252d8c1ba73bf6ed9af28731a9c9c3d473a2", "target": 1, "func": "static void iscsi_readcapacity_sync(IscsiLun *iscsilun, Error **errp)\n\n{\n\n    struct scsi_task *task = NULL;\n\n    struct scsi_readcapacity10 *rc10 = NULL;\n\n    struct scsi_readcapacity16 *rc16 = NULL;\n\n    int retries = ISCSI_CMD_RETRIES; \n\n\n\n    do {\n\n        if (task != NULL) {\n\n            scsi_free_scsi_task(task);\n\n            task = NULL;\n\n        }\n\n\n\n        switch (iscsilun->type) {\n\n        case TYPE_DISK:\n\n            task = iscsi_readcapacity16_sync(iscsilun->iscsi, iscsilun->lun);\n\n            if (task != NULL && task->status == SCSI_STATUS_GOOD) {\n\n                rc16 = scsi_datain_unmarshall(task);\n\n                if (rc16 == NULL) {\n\n                    error_setg(errp, \"iSCSI: Failed to unmarshall readcapacity16 data.\");\n\n                } else {\n\n                    iscsilun->block_size = rc16->block_length;\n\n                    iscsilun->num_blocks = rc16->returned_lba + 1;\n\n                    iscsilun->lbpme = !!rc16->lbpme;\n\n                    iscsilun->lbprz = !!rc16->lbprz;\n\n                    iscsilun->use_16_for_rw = (rc16->returned_lba > 0xffffffff);\n\n                }\n\n            }\n\n            break;\n\n        case TYPE_ROM:\n\n            task = iscsi_readcapacity10_sync(iscsilun->iscsi, iscsilun->lun, 0, 0);\n\n            if (task != NULL && task->status == SCSI_STATUS_GOOD) {\n\n                rc10 = scsi_datain_unmarshall(task);\n\n                if (rc10 == NULL) {\n\n                    error_setg(errp, \"iSCSI: Failed to unmarshall readcapacity10 data.\");\n\n                } else {\n\n                    iscsilun->block_size = rc10->block_size;\n\n                    if (rc10->lba == 0) {\n\n                        /* blank disk loaded */\n\n                        iscsilun->num_blocks = 0;\n\n                    } else {\n\n                        iscsilun->num_blocks = rc10->lba + 1;\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        default:\n\n            return;\n\n        }\n\n    } while (task != NULL && task->status == SCSI_STATUS_CHECK_CONDITION\n\n             && task->sense.key == SCSI_SENSE_UNIT_ATTENTION\n\n             && retries-- > 0);\n\n\n\n    if (task == NULL || task->status != SCSI_STATUS_GOOD) {\n\n        error_setg(errp, \"iSCSI: failed to send readcapacity10 command.\");\n\n\n\n\n\n    }\n\n    if (task) {\n\n        scsi_free_scsi_task(task);\n\n    }\n\n}", "idx": 25496}
{"project": "qemu", "commit_id": "967b75230b9720ea2b3ae49f38f8287026125f9f", "target": 1, "func": "static void pnv_chip_power9_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PnvChipClass *k = PNV_CHIP_CLASS(klass);\n\n\n\n    k->cpu_model = \"POWER9\";\n\n    k->chip_type = PNV_CHIP_POWER9;\n\n    k->chip_cfam_id = 0x100d104980000000ull; /* P9 Nimbus DD1.0 */\n\n    k->cores_mask = POWER9_CORE_MASK;\n\n    k->core_pir = pnv_chip_core_pir_p9;\n\n\n    dc->desc = \"PowerNV Chip POWER9\";\n\n}", "idx": 25498}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_float64(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    float64 *v = pv;\n\n\n\n    *v = make_float64(qemu_get_be64(f));\n\n    return 0;\n\n}\n", "idx": 25503}
{"project": "qemu", "commit_id": "30d335d68d93705eb346387c03bb6aca0f52454a", "target": 1, "func": "static PCIDevice *qemu_pci_hot_add_storage(Monitor *mon,\n\n                                           const char *devaddr,\n\n                                           const char *opts)\n\n{\n\n    PCIDevice *dev;\n\n    DriveInfo *dinfo = NULL;\n\n    int type = -1;\n\n    char buf[128];\n\n    PCIBus *bus;\n\n    int devfn;\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"if\", opts)) {\n\n        if (!strcmp(buf, \"scsi\"))\n\n            type = IF_SCSI;\n\n        else if (!strcmp(buf, \"virtio\")) {\n\n            type = IF_VIRTIO;\n\n        } else {\n\n            monitor_printf(mon, \"type %s not a hotpluggable PCI device.\\n\", buf);\n\n            return NULL;\n\n        }\n\n    } else {\n\n        monitor_printf(mon, \"no if= specified\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"file\", opts)) {\n\n        dinfo = add_init_drive(opts);\n\n        if (!dinfo)\n\n            return NULL;\n\n        if (dinfo->devaddr) {\n\n            monitor_printf(mon, \"Parameter addr not supported\\n\");\n\n            return NULL;\n\n        }\n\n    } else {\n\n        dinfo = NULL;\n\n    }\n\n\n\n    bus = pci_get_bus_devfn(&devfn, devaddr);\n\n    if (!bus) {\n\n        monitor_printf(mon, \"Invalid PCI device address %s\\n\", devaddr);\n\n        return NULL;\n\n    }\n\n\n\n    switch (type) {\n\n    case IF_SCSI:\n\n        if (!dinfo) {\n\n            monitor_printf(mon, \"scsi requires a backing file/device.\\n\");\n\n            return NULL;\n\n        }\n\n        dev = pci_create(bus, devfn, \"lsi53c895a\");\n\n        if (qdev_init(&dev->qdev) < 0)\n\n            dev = NULL;\n\n        if (dev) {\n\n            BusState *scsibus = QLIST_FIRST(&dev->qdev.child_bus);\n\n            scsi_bus_legacy_add_drive(DO_UPCAST(SCSIBus, qbus, scsibus),\n\n                                      dinfo, dinfo->unit);\n\n        }\n\n        break;\n\n    case IF_VIRTIO:\n\n        if (!dinfo) {\n\n            monitor_printf(mon, \"virtio requires a backing file/device.\\n\");\n\n            return NULL;\n\n        }\n\n        dev = pci_create(bus, devfn, \"virtio-blk-pci\");\n\n        qdev_prop_set_drive(&dev->qdev, \"drive\", dinfo);\n\n        if (qdev_init(&dev->qdev) < 0)\n\n            dev = NULL;\n\n        break;\n\n    default:\n\n        dev = NULL;\n\n    }\n\n    return dev;\n\n}\n", "idx": 25505}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static void omap_rfbi_transfer_start(struct omap_dss_s *s)\n\n{\n\n    void *data;\n\n    hwaddr len;\n\n    hwaddr data_addr;\n\n    int pitch;\n\n    static void *bounce_buffer;\n\n    static hwaddr bounce_len;\n\n\n\n    if (!s->rfbi.enable || s->rfbi.busy)\n\n        return;\n\n\n\n    if (s->rfbi.control & (1 << 1)) {\t\t\t\t/* BYPASS */\n\n        /* TODO: in non-Bypass mode we probably need to just assert the\n\n         * DRQ and wait for DMA to write the pixels.  */\n\n        fprintf(stderr, \"%s: Bypass mode unimplemented\\n\", __FUNCTION__);\n\n        return;\n\n    }\n\n\n\n    if (!(s->dispc.control & (1 << 11)))\t\t\t/* RFBIMODE */\n\n        return;\n\n    /* TODO: check that LCD output is enabled in DISPC.  */\n\n\n\n    s->rfbi.busy = 1;\n\n\n\n    len = s->rfbi.pixels * 2;\n\n\n\n    data_addr = s->dispc.l[0].addr[0];\n\n    data = cpu_physical_memory_map(data_addr, &len, 0);\n\n    if (data && len != s->rfbi.pixels * 2) {\n\n        cpu_physical_memory_unmap(data, len, 0, 0);\n\n        data = NULL;\n\n        len = s->rfbi.pixels * 2;\n\n    }\n\n    if (!data) {\n\n        if (len > bounce_len) {\n\n            bounce_buffer = g_realloc(bounce_buffer, len);\n\n        }\n\n        data = bounce_buffer;\n\n        cpu_physical_memory_read(data_addr, data, len);\n\n    }\n\n\n\n    /* TODO bpp */\n\n    s->rfbi.pixels = 0;\n\n\n\n    /* TODO: negative values */\n\n    pitch = s->dispc.l[0].nx + (s->dispc.l[0].rowinc - 1) / 2;\n\n\n\n    if ((s->rfbi.control & (1 << 2)) && s->rfbi.chip[0])\n\n        s->rfbi.chip[0]->block(s->rfbi.chip[0]->opaque, 1, data, len, pitch);\n\n    if ((s->rfbi.control & (1 << 3)) && s->rfbi.chip[1])\n\n        s->rfbi.chip[1]->block(s->rfbi.chip[1]->opaque, 1, data, len, pitch);\n\n\n\n    if (data != bounce_buffer) {\n\n        cpu_physical_memory_unmap(data, len, 0, len);\n\n    }\n\n\n\n    omap_rfbi_transfer_stop(s);\n\n\n\n    /* TODO */\n\n    s->dispc.irqst |= 1;\t\t\t\t\t/* FRAMEDONE */\n\n    omap_dispc_interrupt_update(s);\n\n}\n", "idx": 25506}
{"project": "qemu", "commit_id": "b49f7ead8d222bcb8df0388f3177002f3e33d046", "target": 0, "func": "void commit_active_start(const char *job_id, BlockDriverState *bs,\n\n                         BlockDriverState *base, int64_t speed,\n\n                         BlockdevOnError on_error,\n\n                         BlockCompletionFunc *cb,\n\n                         void *opaque, Error **errp)\n\n{\n\n    int64_t length, base_length;\n\n    int orig_base_flags;\n\n    int ret;\n\n    Error *local_err = NULL;\n\n\n\n    orig_base_flags = bdrv_get_flags(base);\n\n\n\n    if (bdrv_reopen(base, bs->open_flags, errp)) {\n\n        return;\n\n    }\n\n\n\n    length = bdrv_getlength(bs);\n\n    if (length < 0) {\n\n        error_setg_errno(errp, -length,\n\n                         \"Unable to determine length of %s\", bs->filename);\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    base_length = bdrv_getlength(base);\n\n    if (base_length < 0) {\n\n        error_setg_errno(errp, -base_length,\n\n                         \"Unable to determine length of %s\", base->filename);\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    if (length > base_length) {\n\n        ret = bdrv_truncate(base, length);\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret,\n\n                            \"Top image %s is larger than base image %s, and \"\n\n                             \"resize of base image failed\",\n\n                             bs->filename, base->filename);\n\n            goto error_restore_flags;\n\n        }\n\n    }\n\n\n\n    mirror_start_job(job_id, bs, base, NULL, speed, 0, 0,\n\n                     MIRROR_LEAVE_BACKING_CHAIN,\n\n                     on_error, on_error, false, cb, opaque, &local_err,\n\n                     &commit_active_job_driver, false, base);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    return;\n\n\n\nerror_restore_flags:\n\n    /* ignore error and errp for bdrv_reopen, because we want to propagate\n\n     * the original error */\n\n    bdrv_reopen(base, orig_base_flags, NULL);\n\n    return;\n\n}\n", "idx": 25507}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void virtio_blk_handle_flush(VirtIOBlockReq *req, MultiReqBuffer *mrb)\n\n{\n\n    block_acct_start(bdrv_get_stats(req->dev->bs), &req->acct, 0,\n\n                     BLOCK_ACCT_FLUSH);\n\n\n\n    /*\n\n     * Make sure all outstanding writes are posted to the backing device.\n\n     */\n\n    virtio_submit_multiwrite(req->dev->bs, mrb);\n\n    bdrv_aio_flush(req->dev->bs, virtio_blk_flush_complete, req);\n\n}\n", "idx": 25508}
{"project": "qemu", "commit_id": "2399d4e7cec22ecf1c51062d2ebfd45220dbaace", "target": 0, "func": "static void gen_store_exclusive(DisasContext *s, int rd, int rt, int rt2,\n\n                                TCGv_i64 addr, int size, int is_pair)\n\n{\n\n    /* if (env->exclusive_addr == addr && env->exclusive_val == [addr]\n\n     *     && (!is_pair || env->exclusive_high == [addr + datasize])) {\n\n     *     [addr] = {Rt};\n\n     *     if (is_pair) {\n\n     *         [addr + datasize] = {Rt2};\n\n     *     }\n\n     *     {Rd} = 0;\n\n     * } else {\n\n     *     {Rd} = 1;\n\n     * }\n\n     * env->exclusive_addr = -1;\n\n     */\n\n    TCGLabel *fail_label = gen_new_label();\n\n    TCGLabel *done_label = gen_new_label();\n\n    TCGv_i64 tmp;\n\n\n\n    tcg_gen_brcond_i64(TCG_COND_NE, addr, cpu_exclusive_addr, fail_label);\n\n\n\n    tmp = tcg_temp_new_i64();\n\n    if (is_pair) {\n\n        if (size == 2) {\n\n            if (s->be_data == MO_LE) {\n\n                tcg_gen_concat32_i64(tmp, cpu_reg(s, rt), cpu_reg(s, rt2));\n\n            } else {\n\n                tcg_gen_concat32_i64(tmp, cpu_reg(s, rt2), cpu_reg(s, rt));\n\n            }\n\n            tcg_gen_atomic_cmpxchg_i64(tmp, cpu_exclusive_addr,\n\n                                       cpu_exclusive_val, tmp,\n\n                                       get_mem_index(s),\n\n                                       MO_64 | MO_ALIGN | s->be_data);\n\n            tcg_gen_setcond_i64(TCG_COND_NE, tmp, tmp, cpu_exclusive_val);\n\n        } else if (s->be_data == MO_LE) {\n\n            gen_helper_paired_cmpxchg64_le(tmp, cpu_env, cpu_exclusive_addr,\n\n                                           cpu_reg(s, rt), cpu_reg(s, rt2));\n\n        } else {\n\n            gen_helper_paired_cmpxchg64_be(tmp, cpu_env, cpu_exclusive_addr,\n\n                                           cpu_reg(s, rt), cpu_reg(s, rt2));\n\n        }\n\n    } else {\n\n        tcg_gen_atomic_cmpxchg_i64(tmp, cpu_exclusive_addr, cpu_exclusive_val,\n\n                                   cpu_reg(s, rt), get_mem_index(s),\n\n                                   size | MO_ALIGN | s->be_data);\n\n        tcg_gen_setcond_i64(TCG_COND_NE, tmp, tmp, cpu_exclusive_val);\n\n    }\n\n    tcg_gen_mov_i64(cpu_reg(s, rd), tmp);\n\n    tcg_temp_free_i64(tmp);\n\n    tcg_gen_br(done_label);\n\n\n\n    gen_set_label(fail_label);\n\n    tcg_gen_movi_i64(cpu_reg(s, rd), 1);\n\n    gen_set_label(done_label);\n\n    tcg_gen_movi_i64(cpu_exclusive_addr, -1);\n\n}\n", "idx": 25509}
{"project": "qemu", "commit_id": "6fedcaa1c5419fa89c31fd34dabbd71861c615d2", "target": 0, "func": "uint16_t eeprom93xx_read(eeprom_t *eeprom)\n\n{\n\n    /* Return status of pin DO (0 or 1). */\n\n    logout(\"CS=%u DO=%u\\n\", eeprom->eecs, eeprom->eedo);\n\n    return (eeprom->eedo);\n\n}\n", "idx": 25510}
{"project": "qemu", "commit_id": "cb51ac2ffe3649eb8f5c65dccc2012f0ba2c6b12", "target": 0, "func": "void virt_acpi_build(VirtMachineState *vms, AcpiBuildTables *tables)\n\n{\n\n    VirtMachineClass *vmc = VIRT_MACHINE_GET_CLASS(vms);\n\n    GArray *table_offsets;\n\n    unsigned dsdt, rsdt;\n\n    GArray *tables_blob = tables->table_data;\n\n\n\n    table_offsets = g_array_new(false, true /* clear */,\n\n                                        sizeof(uint32_t));\n\n\n\n    bios_linker_loader_alloc(tables->linker,\n\n                             ACPI_BUILD_TABLE_FILE, tables_blob,\n\n                             64, false /* high memory */);\n\n\n\n    /* DSDT is pointed to by FADT */\n\n    dsdt = tables_blob->len;\n\n    build_dsdt(tables_blob, tables->linker, vms);\n\n\n\n    /* FADT MADT GTDT MCFG SPCR pointed to by RSDT */\n\n    acpi_add_table(table_offsets, tables_blob);\n\n    build_fadt(tables_blob, tables->linker, vms, dsdt);\n\n\n\n    acpi_add_table(table_offsets, tables_blob);\n\n    build_madt(tables_blob, tables->linker, vms);\n\n\n\n    acpi_add_table(table_offsets, tables_blob);\n\n    build_gtdt(tables_blob, tables->linker, vms);\n\n\n\n    acpi_add_table(table_offsets, tables_blob);\n\n    build_mcfg(tables_blob, tables->linker, vms);\n\n\n\n    acpi_add_table(table_offsets, tables_blob);\n\n    build_spcr(tables_blob, tables->linker, vms);\n\n\n\n    if (nb_numa_nodes > 0) {\n\n        acpi_add_table(table_offsets, tables_blob);\n\n        build_srat(tables_blob, tables->linker, vms);\n\n    }\n\n\n\n    if (its_class_name() && !vmc->no_its) {\n\n        acpi_add_table(table_offsets, tables_blob);\n\n        build_iort(tables_blob, tables->linker);\n\n    }\n\n\n\n    /* RSDT is pointed to by RSDP */\n\n    rsdt = tables_blob->len;\n\n    build_rsdt(tables_blob, tables->linker, table_offsets, NULL, NULL);\n\n\n\n    /* RSDP is in FSEG memory, so allocate it separately */\n\n    build_rsdp(tables->rsdp, tables->linker, rsdt);\n\n\n\n    /* Cleanup memory that's no longer used. */\n\n    g_array_free(table_offsets, true);\n\n}\n", "idx": 25511}
{"project": "qemu", "commit_id": "5fb8084f31e9df7f0b2d63cfd3d10645d29b5eab", "target": 0, "func": "static void versatile_init(QEMUMachineInitArgs *args, int board_id)\n\n{\n\n    ARMCPU *cpu;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    qemu_irq *cpu_pic;\n\n    qemu_irq pic[32];\n\n    qemu_irq sic[32];\n\n    DeviceState *dev, *sysctl;\n\n    SysBusDevice *busdev;\n\n    DeviceState *pl041;\n\n    PCIBus *pci_bus;\n\n    NICInfo *nd;\n\n    i2c_bus *i2c;\n\n    int n;\n\n    int done_smc = 0;\n\n    DriveInfo *dinfo;\n\n\n\n    if (!args->cpu_model) {\n\n        args->cpu_model = \"arm926\";\n\n    }\n\n    cpu = cpu_arm_init(args->cpu_model);\n\n    if (!cpu) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    memory_region_init_ram(ram, \"versatile.ram\", args->ram_size);\n\n    vmstate_register_ram_global(ram);\n\n    /* ??? RAM should repeat to fill physical memory space.  */\n\n    /* SDRAM at address zero.  */\n\n    memory_region_add_subregion(sysmem, 0, ram);\n\n\n\n    sysctl = qdev_create(NULL, \"realview_sysctl\");\n\n    qdev_prop_set_uint32(sysctl, \"sys_id\", 0x41007004);\n\n    qdev_prop_set_uint32(sysctl, \"proc_id\", 0x02000000);\n\n    qdev_init_nofail(sysctl);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(sysctl), 0, 0x10000000);\n\n\n\n    cpu_pic = arm_pic_init_cpu(cpu);\n\n    dev = sysbus_create_varargs(\"pl190\", 0x10140000,\n\n                                cpu_pic[ARM_PIC_CPU_IRQ],\n\n                                cpu_pic[ARM_PIC_CPU_FIQ], NULL);\n\n    for (n = 0; n < 32; n++) {\n\n        pic[n] = qdev_get_gpio_in(dev, n);\n\n    }\n\n    dev = sysbus_create_simple(\"versatilepb_sic\", 0x10003000, NULL);\n\n    for (n = 0; n < 32; n++) {\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), n, pic[n]);\n\n        sic[n] = qdev_get_gpio_in(dev, n);\n\n    }\n\n\n\n    sysbus_create_simple(\"pl050_keyboard\", 0x10006000, sic[3]);\n\n    sysbus_create_simple(\"pl050_mouse\", 0x10007000, sic[4]);\n\n\n\n    dev = qdev_create(NULL, \"versatile_pci\");\n\n    busdev = SYS_BUS_DEVICE(dev);\n\n    qdev_init_nofail(dev);\n\n    sysbus_mmio_map(busdev, 0, 0x41000000); /* PCI self-config */\n\n    sysbus_mmio_map(busdev, 1, 0x42000000); /* PCI config */\n\n    sysbus_connect_irq(busdev, 0, sic[27]);\n\n    sysbus_connect_irq(busdev, 1, sic[28]);\n\n    sysbus_connect_irq(busdev, 2, sic[29]);\n\n    sysbus_connect_irq(busdev, 3, sic[30]);\n\n    pci_bus = (PCIBus *)qdev_get_child_bus(dev, \"pci\");\n\n\n\n    /* The Versatile PCI bridge does not provide access to PCI IO space,\n\n       so many of the qemu PCI devices are not useable.  */\n\n    for(n = 0; n < nb_nics; n++) {\n\n        nd = &nd_table[n];\n\n\n\n        if (!done_smc && (!nd->model || strcmp(nd->model, \"smc91c111\") == 0)) {\n\n            smc91c111_init(nd, 0x10010000, sic[25]);\n\n            done_smc = 1;\n\n        } else {\n\n            pci_nic_init_nofail(nd, \"rtl8139\", NULL);\n\n        }\n\n    }\n\n    if (usb_enabled(false)) {\n\n        pci_create_simple(pci_bus, -1, \"pci-ohci\");\n\n    }\n\n    n = drive_get_max_bus(IF_SCSI);\n\n    while (n >= 0) {\n\n        pci_create_simple(pci_bus, -1, \"lsi53c895a\");\n\n        n--;\n\n    }\n\n\n\n    sysbus_create_simple(\"pl011\", 0x101f1000, pic[12]);\n\n    sysbus_create_simple(\"pl011\", 0x101f2000, pic[13]);\n\n    sysbus_create_simple(\"pl011\", 0x101f3000, pic[14]);\n\n    sysbus_create_simple(\"pl011\", 0x10009000, sic[6]);\n\n\n\n    sysbus_create_simple(\"pl080\", 0x10130000, pic[17]);\n\n    sysbus_create_simple(\"sp804\", 0x101e2000, pic[4]);\n\n    sysbus_create_simple(\"sp804\", 0x101e3000, pic[5]);\n\n\n\n    sysbus_create_simple(\"pl061\", 0x101e4000, pic[6]);\n\n    sysbus_create_simple(\"pl061\", 0x101e5000, pic[7]);\n\n    sysbus_create_simple(\"pl061\", 0x101e6000, pic[8]);\n\n    sysbus_create_simple(\"pl061\", 0x101e7000, pic[9]);\n\n\n\n    /* The versatile/PB actually has a modified Color LCD controller\n\n       that includes hardware cursor support from the PL111.  */\n\n    dev = sysbus_create_simple(\"pl110_versatile\", 0x10120000, pic[16]);\n\n    /* Wire up the mux control signals from the SYS_CLCD register */\n\n    qdev_connect_gpio_out(sysctl, 0, qdev_get_gpio_in(dev, 0));\n\n\n\n    sysbus_create_varargs(\"pl181\", 0x10005000, sic[22], sic[1], NULL);\n\n    sysbus_create_varargs(\"pl181\", 0x1000b000, sic[23], sic[2], NULL);\n\n\n\n    /* Add PL031 Real Time Clock. */\n\n    sysbus_create_simple(\"pl031\", 0x101e8000, pic[10]);\n\n\n\n    dev = sysbus_create_simple(\"versatile_i2c\", 0x10002000, NULL);\n\n    i2c = (i2c_bus *)qdev_get_child_bus(dev, \"i2c\");\n\n    i2c_create_slave(i2c, \"ds1338\", 0x68);\n\n\n\n    /* Add PL041 AACI Interface to the LM4549 codec */\n\n    pl041 = qdev_create(NULL, \"pl041\");\n\n    qdev_prop_set_uint32(pl041, \"nc_fifo_depth\", 512);\n\n    qdev_init_nofail(pl041);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(pl041), 0, 0x10004000);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(pl041), 0, sic[24]);\n\n\n\n    /* Memory map for Versatile/PB:  */\n\n    /* 0x10000000 System registers.  */\n\n    /* 0x10001000 PCI controller config registers.  */\n\n    /* 0x10002000 Serial bus interface.  */\n\n    /*  0x10003000 Secondary interrupt controller.  */\n\n    /* 0x10004000 AACI (audio).  */\n\n    /*  0x10005000 MMCI0.  */\n\n    /*  0x10006000 KMI0 (keyboard).  */\n\n    /*  0x10007000 KMI1 (mouse).  */\n\n    /* 0x10008000 Character LCD Interface.  */\n\n    /*  0x10009000 UART3.  */\n\n    /* 0x1000a000 Smart card 1.  */\n\n    /*  0x1000b000 MMCI1.  */\n\n    /*  0x10010000 Ethernet.  */\n\n    /* 0x10020000 USB.  */\n\n    /* 0x10100000 SSMC.  */\n\n    /* 0x10110000 MPMC.  */\n\n    /*  0x10120000 CLCD Controller.  */\n\n    /*  0x10130000 DMA Controller.  */\n\n    /*  0x10140000 Vectored interrupt controller.  */\n\n    /* 0x101d0000 AHB Monitor Interface.  */\n\n    /* 0x101e0000 System Controller.  */\n\n    /* 0x101e1000 Watchdog Interface.  */\n\n    /* 0x101e2000 Timer 0/1.  */\n\n    /* 0x101e3000 Timer 2/3.  */\n\n    /* 0x101e4000 GPIO port 0.  */\n\n    /* 0x101e5000 GPIO port 1.  */\n\n    /* 0x101e6000 GPIO port 2.  */\n\n    /* 0x101e7000 GPIO port 3.  */\n\n    /* 0x101e8000 RTC.  */\n\n    /* 0x101f0000 Smart card 0.  */\n\n    /*  0x101f1000 UART0.  */\n\n    /*  0x101f2000 UART1.  */\n\n    /*  0x101f3000 UART2.  */\n\n    /* 0x101f4000 SSPI.  */\n\n    /* 0x34000000 NOR Flash */\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    if (!pflash_cfi01_register(VERSATILE_FLASH_ADDR, NULL, \"versatile.flash\",\n\n                          VERSATILE_FLASH_SIZE, dinfo ? dinfo->bdrv : NULL,\n\n                          VERSATILE_FLASH_SECT_SIZE,\n\n                          VERSATILE_FLASH_SIZE / VERSATILE_FLASH_SECT_SIZE,\n\n                          4, 0x0089, 0x0018, 0x0000, 0x0, 0)) {\n\n        fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n    }\n\n\n\n    versatile_binfo.ram_size = args->ram_size;\n\n    versatile_binfo.kernel_filename = args->kernel_filename;\n\n    versatile_binfo.kernel_cmdline = args->kernel_cmdline;\n\n    versatile_binfo.initrd_filename = args->initrd_filename;\n\n    versatile_binfo.board_id = board_id;\n\n    arm_load_kernel(cpu, &versatile_binfo);\n\n}\n", "idx": 25512}
{"project": "qemu", "commit_id": "242acf3af4605adce933906bdc053b2414181ec7", "target": 0, "func": "sorecvfrom(so)\n\n\tstruct socket *so;\n\n{\n\n\tstruct sockaddr_in addr;\n\n\tint addrlen = sizeof(struct sockaddr_in);\n\n\n\n\tDEBUG_CALL(\"sorecvfrom\");\n\n\tDEBUG_ARG(\"so = %lx\", (long)so);\n\n\n\n\tif (so->so_type == IPPROTO_ICMP) {   /* This is a \"ping\" reply */\n\n\t  char buff[256];\n\n\t  int len;\n\n\n\n\t  len = recvfrom(so->s, buff, 256, 0,\n\n\t\t\t (struct sockaddr *)&addr, &addrlen);\n\n\t  /* XXX Check if reply is \"correct\"? */\n\n\n\n\t  if(len == -1 || len == 0) {\n\n\t    u_char code=ICMP_UNREACH_PORT;\n\n\n\n\t    if(errno == EHOSTUNREACH) code=ICMP_UNREACH_HOST;\n\n\t    else if(errno == ENETUNREACH) code=ICMP_UNREACH_NET;\n\n\n\n\t    DEBUG_MISC((dfd,\" udp icmp rx errno = %d-%s\\n\",\n\n\t\t\terrno,strerror(errno)));\n\n\t    icmp_error(so->so_m, ICMP_UNREACH,code, 0,strerror(errno));\n\n\t  } else {\n\n\t    icmp_reflect(so->so_m);\n\n\t    so->so_m = 0; /* Don't m_free() it again! */\n\n\t  }\n\n\t  /* No need for this socket anymore, udp_detach it */\n\n\t  udp_detach(so);\n\n\t} else {                            \t/* A \"normal\" UDP packet */\n\n\t  struct mbuf *m;\n\n\t  int len, n;\n\n\n\n\t  if (!(m = m_get())) return;\n\n\t  m->m_data += IF_MAXLINKHDR;\n\n\n\n\t  /*\n\n\t   * XXX Shouldn't FIONREAD packets destined for port 53,\n\n\t   * but I don't know the max packet size for DNS lookups\n\n\t   */\n\n\t  len = M_FREEROOM(m);\n\n\t  /* if (so->so_fport != htons(53)) { */\n\n\t  ioctlsocket(so->s, FIONREAD, &n);\n\n\n\n\t  if (n > len) {\n\n\t    n = (m->m_data - m->m_dat) + m->m_len + n + 1;\n\n\t    m_inc(m, n);\n\n\t    len = M_FREEROOM(m);\n\n\t  }\n\n\t  /* } */\n\n\n\n\t  m->m_len = recvfrom(so->s, m->m_data, len, 0,\n\n\t\t\t      (struct sockaddr *)&addr, &addrlen);\n\n\t  DEBUG_MISC((dfd, \" did recvfrom %d, errno = %d-%s\\n\",\n\n\t\t      m->m_len, errno,strerror(errno)));\n\n\t  if(m->m_len<0) {\n\n\t    u_char code=ICMP_UNREACH_PORT;\n\n\n\n\t    if(errno == EHOSTUNREACH) code=ICMP_UNREACH_HOST;\n\n\t    else if(errno == ENETUNREACH) code=ICMP_UNREACH_NET;\n\n\n\n\t    DEBUG_MISC((dfd,\" rx error, tx icmp ICMP_UNREACH:%i\\n\", code));\n\n\t    icmp_error(so->so_m, ICMP_UNREACH,code, 0,strerror(errno));\n\n\t    m_free(m);\n\n\t  } else {\n\n\t  /*\n\n\t   * Hack: domain name lookup will be used the most for UDP,\n\n\t   * and since they'll only be used once there's no need\n\n\t   * for the 4 minute (or whatever) timeout... So we time them\n\n\t   * out much quicker (10 seconds  for now...)\n\n\t   */\n\n\t    if (so->so_expire) {\n\n\t      if (so->so_fport == htons(53))\n\n\t\tso->so_expire = curtime + SO_EXPIREFAST;\n\n\t      else\n\n\t\tso->so_expire = curtime + SO_EXPIRE;\n\n\t    }\n\n\n\n\t    /*\t\tif (m->m_len == len) {\n\n\t     *\t\t\tm_inc(m, MINCSIZE);\n\n\t     *\t\t\tm->m_len = 0;\n\n\t     *\t\t}\n\n\t     */\n\n\n\n\t    /*\n\n\t     * If this packet was destined for CTL_ADDR,\n\n\t     * make it look like that's where it came from, done by udp_output\n\n\t     */\n\n\t    udp_output(so, m, &addr);\n\n\t  } /* rx error */\n\n\t} /* if ping packet */\n\n}\n", "idx": 25514}
{"project": "qemu", "commit_id": "f3172a0e2e7bd983cada19f11d9bb59400e0dd3d", "target": 0, "func": "static void sysctl_write(void *opaque, target_phys_addr_t addr, uint32_t value)\n\n{\n\n    MilkymistSysctlState *s = opaque;\n\n\n\n    trace_milkymist_sysctl_memory_write(addr, value);\n\n\n\n    addr >>= 2;\n\n    switch (addr) {\n\n    case R_GPIO_OUT:\n\n    case R_GPIO_INTEN:\n\n    case R_TIMER0_COUNTER:\n\n        if (value > s->regs[R_TIMER0_COUNTER]) {\n\n            value = s->regs[R_TIMER0_COUNTER];\n\n            error_report(\"milkymist_sysctl: timer0: trying to write a \"\n\n                    \"value greater than the limit. Clipping.\");\n\n        }\n\n        /* milkymist timer counts up */\n\n        value = s->regs[R_TIMER0_COUNTER] - value;\n\n        ptimer_set_count(s->ptimer0, value);\n\n        break;\n\n    case R_TIMER1_COUNTER:\n\n        if (value > s->regs[R_TIMER1_COUNTER]) {\n\n            value = s->regs[R_TIMER1_COUNTER];\n\n            error_report(\"milkymist_sysctl: timer1: trying to write a \"\n\n                    \"value greater than the limit. Clipping.\");\n\n        }\n\n        /* milkymist timer counts up */\n\n        value = s->regs[R_TIMER1_COUNTER] - value;\n\n        ptimer_set_count(s->ptimer1, value);\n\n        break;\n\n    case R_TIMER0_COMPARE:\n\n        ptimer_set_limit(s->ptimer0, value, 0);\n\n        s->regs[addr] = value;\n\n        break;\n\n    case R_TIMER1_COMPARE:\n\n        ptimer_set_limit(s->ptimer1, value, 0);\n\n        s->regs[addr] = value;\n\n        break;\n\n    case R_TIMER0_CONTROL:\n\n        s->regs[addr] = value;\n\n        if (s->regs[R_TIMER0_CONTROL] & CTRL_ENABLE) {\n\n            trace_milkymist_sysctl_start_timer1();\n\n            ptimer_run(s->ptimer0, 0);\n\n        } else {\n\n            trace_milkymist_sysctl_stop_timer1();\n\n            ptimer_stop(s->ptimer0);\n\n        }\n\n        break;\n\n    case R_TIMER1_CONTROL:\n\n        s->regs[addr] = value;\n\n        if (s->regs[R_TIMER1_CONTROL] & CTRL_ENABLE) {\n\n            trace_milkymist_sysctl_start_timer1();\n\n            ptimer_run(s->ptimer1, 0);\n\n        } else {\n\n            trace_milkymist_sysctl_stop_timer1();\n\n            ptimer_stop(s->ptimer1);\n\n        }\n\n        break;\n\n    case R_ICAP:\n\n        sysctl_icap_write(s, value);\n\n        break;\n\n    case R_SYSTEM_ID:\n\n        qemu_system_reset_request();\n\n        break;\n\n\n\n    case R_GPIO_IN:\n\n    case R_CAPABILITIES:\n\n        error_report(\"milkymist_sysctl: write to read-only register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n\n\n    default:\n\n        error_report(\"milkymist_sysctl: write access to unkown register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    }\n\n}\n", "idx": 25515}
{"project": "qemu", "commit_id": "b01fe89e91268c6b02720735643020746610e6d8", "target": 0, "func": "char *qmp_human_monitor_command(const char *command_line, bool has_cpu_index,\n\n                                int64_t cpu_index, Error **errp)\n\n{\n\n    char *output = NULL;\n\n    Monitor *old_mon, hmp;\n\n\n\n    memset(&hmp, 0, sizeof(hmp));\n\n    hmp.outbuf = qstring_new();\n\n    hmp.skip_flush = true;\n\n\n\n    old_mon = cur_mon;\n\n    cur_mon = &hmp;\n\n\n\n    if (has_cpu_index) {\n\n        int ret = monitor_set_cpu(cpu_index);\n\n        if (ret < 0) {\n\n            cur_mon = old_mon;\n\n            error_set(errp, QERR_INVALID_PARAMETER_VALUE, \"cpu-index\",\n\n                      \"a CPU number\");\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    handle_user_command(&hmp, command_line);\n\n    cur_mon = old_mon;\n\n\n\n    if (qstring_get_length(hmp.outbuf) > 0) {\n\n        output = g_strdup(qstring_get_str(hmp.outbuf));\n\n    } else {\n\n        output = g_strdup(\"\");\n\n    }\n\n\n\nout:\n\n    QDECREF(hmp.outbuf);\n\n    return output;\n\n}\n", "idx": 25516}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void do_screen_dump(int argc, const char **argv)\n\n{\n\n    if (argc != 2) {\n\n        help_cmd(argv[0]);\n\n        return;\n\n    }\n\n    vga_screen_dump(argv[1]);\n\n}\n", "idx": 25517}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static int rndis_get_response(USBNetState *s, uint8_t *buf)\n\n{\n\n    int ret = 0;\n\n    struct rndis_response *r = s->rndis_resp.tqh_first;\n\n\n\n    if (!r)\n\n        return ret;\n\n\n\n    TAILQ_REMOVE(&s->rndis_resp, r, entries);\n\n    ret = r->length;\n\n    memcpy(buf, r->buf, r->length);\n\n    qemu_free(r);\n\n\n\n    return ret;\n\n}\n", "idx": 25518}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,\n\n                          unsigned npfd, int64_t timeout)\n\n{\n\n    return false;\n\n}\n", "idx": 25519}
{"project": "qemu", "commit_id": "ef76dc59fa5203d146a2acf85a0ad5a5971a4824", "target": 0, "func": "START_TEST(single_quote_string)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        const char *decoded;\n\n    } test_cases[] = {\n\n        { \"'hello world'\", \"hello world\" },\n\n        { \"'the quick brown fox \\\\' jumped over the fence'\",\n\n          \"the quick brown fox ' jumped over the fence\" },\n\n        {}\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_json(test_cases[i].encoded);\n\n\n\n        fail_unless(obj != NULL);\n\n        fail_unless(qobject_type(obj) == QTYPE_QSTRING);\n\n        \n\n        str = qobject_to_qstring(obj);\n\n        fail_unless(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);\n\n\n\n        QDECREF(str);\n\n    }\n\n}\n", "idx": 25520}
{"project": "qemu", "commit_id": "03e6e5017757645f00b2f3b4f3a257973985e455", "target": 0, "func": "static inline void compute_hflags(CPUMIPSState *env)\n\n{\n\n    env->hflags &= ~(MIPS_HFLAG_COP1X | MIPS_HFLAG_64 | MIPS_HFLAG_CP0 |\n\n                     MIPS_HFLAG_F64 | MIPS_HFLAG_FPU | MIPS_HFLAG_KSU |\n\n                     MIPS_HFLAG_UX);\n\n    if (!(env->CP0_Status & (1 << CP0St_EXL)) &&\n\n        !(env->CP0_Status & (1 << CP0St_ERL)) &&\n\n        !(env->hflags & MIPS_HFLAG_DM)) {\n\n        env->hflags |= (env->CP0_Status >> CP0St_KSU) & MIPS_HFLAG_KSU;\n\n    }\n\n#if defined(TARGET_MIPS64)\n\n    if (((env->hflags & MIPS_HFLAG_KSU) != MIPS_HFLAG_UM) ||\n\n        (env->CP0_Status & (1 << CP0St_PX)) ||\n\n        (env->CP0_Status & (1 << CP0St_UX))) {\n\n        env->hflags |= MIPS_HFLAG_64;\n\n    }\n\n    if (env->CP0_Status & (1 << CP0St_UX)) {\n\n        env->hflags |= MIPS_HFLAG_UX;\n\n    }\n\n#endif\n\n    if ((env->CP0_Status & (1 << CP0St_CU0)) ||\n\n        !(env->hflags & MIPS_HFLAG_KSU)) {\n\n        env->hflags |= MIPS_HFLAG_CP0;\n\n    }\n\n    if (env->CP0_Status & (1 << CP0St_CU1)) {\n\n        env->hflags |= MIPS_HFLAG_FPU;\n\n    }\n\n    if (env->CP0_Status & (1 << CP0St_FR)) {\n\n        env->hflags |= MIPS_HFLAG_F64;\n\n    }\n\n    if (env->insn_flags & ISA_MIPS32R2) {\n\n        if (env->active_fpu.fcr0 & (1 << FCR0_F64)) {\n\n            env->hflags |= MIPS_HFLAG_COP1X;\n\n        }\n\n    } else if (env->insn_flags & ISA_MIPS32) {\n\n        if (env->hflags & MIPS_HFLAG_64) {\n\n            env->hflags |= MIPS_HFLAG_COP1X;\n\n        }\n\n    } else if (env->insn_flags & ISA_MIPS4) {\n\n        /* All supported MIPS IV CPUs use the XX (CU3) to enable\n\n           and disable the MIPS IV extensions to the MIPS III ISA.\n\n           Some other MIPS IV CPUs ignore the bit, so the check here\n\n           would be too restrictive for them.  */\n\n        if (env->CP0_Status & (1 << CP0St_CU3)) {\n\n            env->hflags |= MIPS_HFLAG_COP1X;\n\n        }\n\n    }\n\n}\n", "idx": 25521}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static void handle_9p_output(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    V9fsVirtioState *v = (V9fsVirtioState *)vdev;\n\n    V9fsState *s = &v->state;\n\n    V9fsPDU *pdu;\n\n    ssize_t len;\n\n\n\n    while ((pdu = pdu_alloc(s))) {\n\n        struct {\n\n            uint32_t size_le;\n\n            uint8_t id;\n\n            uint16_t tag_le;\n\n        } QEMU_PACKED out;\n\n        VirtQueueElement *elem = &v->elems[pdu->idx];\n\n\n\n        len = virtqueue_pop(vq, elem);\n\n        if (!len) {\n\n            pdu_free(pdu);\n\n            break;\n\n        }\n\n\n\n        BUG_ON(elem->out_num == 0 || elem->in_num == 0);\n\n        QEMU_BUILD_BUG_ON(sizeof out != 7);\n\n\n\n        len = iov_to_buf(elem->out_sg, elem->out_num, 0,\n\n                         &out, sizeof out);\n\n        BUG_ON(len != sizeof out);\n\n\n\n        pdu->size = le32_to_cpu(out.size_le);\n\n\n\n        pdu->id = out.id;\n\n        pdu->tag = le16_to_cpu(out.tag_le);\n\n\n\n        qemu_co_queue_init(&pdu->complete);\n\n        pdu_submit(pdu);\n\n    }\n\n}\n", "idx": 25522}
{"project": "qemu", "commit_id": "91cda45b69e45a089f9989979a65db3f710c9925", "target": 0, "func": "hwaddr ppc_hash64_get_phys_page_debug(CPUPPCState *env, target_ulong addr)\n\n{\n\n    struct mmu_ctx_hash64 ctx;\n\n\n\n    if (unlikely(ppc_hash64_get_physical_address(env, &ctx, addr, 0, ACCESS_INT)\n\n                 != 0)) {\n\n        return -1;\n\n    }\n\n\n\n    return ctx.raddr & TARGET_PAGE_MASK;\n\n}\n", "idx": 25523}
{"project": "qemu", "commit_id": "5d1abf234462d13bef3617cc2c55b6815703ddf2", "target": 0, "func": "int pcilg_service_call(S390CPU *cpu, uint8_t r1, uint8_t r2)\n\n{\n\n    CPUS390XState *env = &cpu->env;\n\n    S390PCIBusDevice *pbdev;\n\n    uint64_t offset;\n\n    uint64_t data;\n\n    uint8_t len;\n\n    uint32_t fh;\n\n    uint8_t pcias;\n\n\n\n    cpu_synchronize_state(CPU(cpu));\n\n\n\n    if (env->psw.mask & PSW_MASK_PSTATE) {\n\n        program_interrupt(env, PGM_PRIVILEGED, 4);\n\n        return 0;\n\n    }\n\n\n\n    if (r2 & 0x1) {\n\n        program_interrupt(env, PGM_SPECIFICATION, 4);\n\n        return 0;\n\n    }\n\n\n\n    fh = env->regs[r2] >> 32;\n\n    pcias = (env->regs[r2] >> 16) & 0xf;\n\n    len = env->regs[r2] & 0xf;\n\n    offset = env->regs[r2 + 1];\n\n\n\n    pbdev = s390_pci_find_dev_by_fh(fh);\n\n    if (!pbdev || !(pbdev->fh & FH_MASK_ENABLE)) {\n\n        DPRINTF(\"pcilg no pci dev\\n\");\n\n        setcc(cpu, ZPCI_PCI_LS_INVAL_HANDLE);\n\n        return 0;\n\n    }\n\n\n\n    if (pbdev->lgstg_blocked) {\n\n        setcc(cpu, ZPCI_PCI_LS_ERR);\n\n        s390_set_status_code(env, r2, ZPCI_PCI_ST_BLOCKED);\n\n        return 0;\n\n    }\n\n\n\n    if (pcias < 6) {\n\n        if ((8 - (offset & 0x7)) < len) {\n\n            program_interrupt(env, PGM_OPERAND, 4);\n\n            return 0;\n\n        }\n\n        MemoryRegion *mr = pbdev->pdev->io_regions[pcias].memory;\n\n        memory_region_dispatch_read(mr, offset, &data, len,\n\n                                    MEMTXATTRS_UNSPECIFIED);\n\n    } else if (pcias == 15) {\n\n        if ((4 - (offset & 0x3)) < len) {\n\n            program_interrupt(env, PGM_OPERAND, 4);\n\n            return 0;\n\n        }\n\n        data =  pci_host_config_read_common(\n\n                   pbdev->pdev, offset, pci_config_size(pbdev->pdev), len);\n\n\n\n        switch (len) {\n\n        case 1:\n\n            break;\n\n        case 2:\n\n            data = bswap16(data);\n\n            break;\n\n        case 4:\n\n            data = bswap32(data);\n\n            break;\n\n        case 8:\n\n            data = bswap64(data);\n\n            break;\n\n        default:\n\n            program_interrupt(env, PGM_OPERAND, 4);\n\n            return 0;\n\n        }\n\n    } else {\n\n        DPRINTF(\"invalid space\\n\");\n\n        setcc(cpu, ZPCI_PCI_LS_ERR);\n\n        s390_set_status_code(env, r2, ZPCI_PCI_ST_INVAL_AS);\n\n        return 0;\n\n    }\n\n\n\n    env->regs[r1] = data;\n\n    setcc(cpu, ZPCI_PCI_LS_OK);\n\n    return 0;\n\n}\n", "idx": 25525}
{"project": "qemu", "commit_id": "25b9fb107bc1f6735fdb3fce537792f5db95f78d", "target": 1, "func": "int kvm_arch_put_registers(CPUState *cs, int level)\n\n{\n\n    struct kvm_one_reg reg;\n\n    uint32_t fpr;\n\n    uint64_t val;\n\n    int i;\n\n    int ret;\n\n\n\n    ARMCPU *cpu = ARM_CPU(cs);\n\n    CPUARMState *env = &cpu->env;\n\n\n\n    /* If we are in AArch32 mode then we need to copy the AArch32 regs to the\n\n     * AArch64 registers before pushing them out to 64-bit KVM.\n\n     */\n\n    if (!is_a64(env)) {\n\n        aarch64_sync_32_to_64(env);\n\n    }\n\n\n\n    for (i = 0; i < 31; i++) {\n\n        reg.id = AARCH64_CORE_REG(regs.regs[i]);\n\n        reg.addr = (uintptr_t) &env->xregs[i];\n\n        ret = kvm_vcpu_ioctl(cs, KVM_SET_ONE_REG, &reg);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* KVM puts SP_EL0 in regs.sp and SP_EL1 in regs.sp_el1. On the\n\n     * QEMU side we keep the current SP in xregs[31] as well.\n\n     */\n\n    aarch64_save_sp(env, 1);\n\n\n\n    reg.id = AARCH64_CORE_REG(regs.sp);\n\n    reg.addr = (uintptr_t) &env->sp_el[0];\n\n    ret = kvm_vcpu_ioctl(cs, KVM_SET_ONE_REG, &reg);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    reg.id = AARCH64_CORE_REG(sp_el1);\n\n    reg.addr = (uintptr_t) &env->sp_el[1];\n\n    ret = kvm_vcpu_ioctl(cs, KVM_SET_ONE_REG, &reg);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    /* Note that KVM thinks pstate is 64 bit but we use a uint32_t */\n\n    if (is_a64(env)) {\n\n        val = pstate_read(env);\n\n    } else {\n\n        val = cpsr_read(env);\n\n    }\n\n    reg.id = AARCH64_CORE_REG(regs.pstate);\n\n    reg.addr = (uintptr_t) &val;\n\n    ret = kvm_vcpu_ioctl(cs, KVM_SET_ONE_REG, &reg);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    reg.id = AARCH64_CORE_REG(regs.pc);\n\n    reg.addr = (uintptr_t) &env->pc;\n\n    ret = kvm_vcpu_ioctl(cs, KVM_SET_ONE_REG, &reg);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    reg.id = AARCH64_CORE_REG(elr_el1);\n\n    reg.addr = (uintptr_t) &env->elr_el[1];\n\n    ret = kvm_vcpu_ioctl(cs, KVM_SET_ONE_REG, &reg);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    for (i = 0; i < KVM_NR_SPSR; i++) {\n\n        reg.id = AARCH64_CORE_REG(spsr[i]);\n\n        reg.addr = (uintptr_t) &env->banked_spsr[i - 1];\n\n        ret = kvm_vcpu_ioctl(cs, KVM_SET_ONE_REG, &reg);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* Advanced SIMD and FP registers\n\n     * We map Qn = regs[2n+1]:regs[2n]\n\n     */\n\n    for (i = 0; i < 32; i++) {\n\n        int rd = i << 1;\n\n        uint64_t fp_val[2];\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n        fp_val[0] = env->vfp.regs[rd + 1];\n\n        fp_val[1] = env->vfp.regs[rd];\n\n#else\n\n        fp_val[1] = env->vfp.regs[rd + 1];\n\n        fp_val[0] = env->vfp.regs[rd];\n\n#endif\n\n        reg.id = AARCH64_SIMD_CORE_REG(fp_regs.vregs[i]);\n\n        reg.addr = (uintptr_t)(&fp_val);\n\n        ret = kvm_vcpu_ioctl(cs, KVM_SET_ONE_REG, &reg);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    reg.addr = (uintptr_t)(&fpr);\n\n    fpr = vfp_get_fpsr(env);\n\n    reg.id = AARCH64_SIMD_CTRL_REG(fp_regs.fpsr);\n\n    ret = kvm_vcpu_ioctl(cs, KVM_SET_ONE_REG, &reg);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    fpr = vfp_get_fpcr(env);\n\n    reg.id = AARCH64_SIMD_CTRL_REG(fp_regs.fpcr);\n\n    ret = kvm_vcpu_ioctl(cs, KVM_SET_ONE_REG, &reg);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    if (!write_list_to_kvmstate(cpu)) {\n\n        return EINVAL;\n\n    }\n\n\n\n    kvm_arm_sync_mpstate_to_kvm(cpu);\n\n\n\n    return ret;\n\n}\n", "idx": 25529}
{"project": "qemu", "commit_id": "5b08fc106d3146ddc1447d82d4770fc402fc363b", "target": 0, "func": "static void sdl_refresh(DisplayState *ds)\n\n{\n\n    SDL_Event ev1, *ev = &ev1;\n\n    int mod_state;\n\n    int buttonstate = SDL_GetMouseState(NULL, NULL);\n\n\n\n    if (last_vm_running != vm_running) {\n\n        last_vm_running = vm_running;\n\n        sdl_update_caption();\n\n    }\n\n\n\n    vga_hw_update();\n\n    SDL_EnableUNICODE(!is_graphic_console());\n\n\n\n    while (SDL_PollEvent(ev)) {\n\n        switch (ev->type) {\n\n        case SDL_VIDEOEXPOSE:\n\n            sdl_update(ds, 0, 0, screen->w, screen->h);\n\n            break;\n\n        case SDL_KEYDOWN:\n\n        case SDL_KEYUP:\n\n            if (ev->type == SDL_KEYDOWN) {\n\n                if (!alt_grab) {\n\n                    mod_state = (SDL_GetModState() & gui_grab_code) ==\n\n                                gui_grab_code;\n\n                } else {\n\n                    mod_state = (SDL_GetModState() & (gui_grab_code | KMOD_LSHIFT)) ==\n\n                                (gui_grab_code | KMOD_LSHIFT);\n\n                }\n\n                gui_key_modifier_pressed = mod_state;\n\n                if (gui_key_modifier_pressed) {\n\n                    int keycode;\n\n                    keycode = sdl_keyevent_to_keycode(&ev->key);\n\n                    switch(keycode) {\n\n                    case 0x21: /* 'f' key on US keyboard */\n\n                        toggle_full_screen(ds);\n\n                        gui_keysym = 1;\n\n                        break;\n\n                    case 0x02 ... 0x0a: /* '1' to '9' keys */\n\n                        /* Reset the modifiers sent to the current console */\n\n                        reset_keys();\n\n                        console_select(keycode - 0x02);\n\n                        if (!is_graphic_console()) {\n\n                            /* display grab if going to a text console */\n\n                            if (gui_grab)\n\n                                sdl_grab_end();\n\n                        }\n\n                        gui_keysym = 1;\n\n                        break;\n\n                    default:\n\n                        break;\n\n                    }\n\n                } else if (!is_graphic_console()) {\n\n                    int keysym;\n\n                    keysym = 0;\n\n                    if (ev->key.keysym.mod & (KMOD_LCTRL | KMOD_RCTRL)) {\n\n                        switch(ev->key.keysym.sym) {\n\n                        case SDLK_UP: keysym = QEMU_KEY_CTRL_UP; break;\n\n                        case SDLK_DOWN: keysym = QEMU_KEY_CTRL_DOWN; break;\n\n                        case SDLK_LEFT: keysym = QEMU_KEY_CTRL_LEFT; break;\n\n                        case SDLK_RIGHT: keysym = QEMU_KEY_CTRL_RIGHT; break;\n\n                        case SDLK_HOME: keysym = QEMU_KEY_CTRL_HOME; break;\n\n                        case SDLK_END: keysym = QEMU_KEY_CTRL_END; break;\n\n                        case SDLK_PAGEUP: keysym = QEMU_KEY_CTRL_PAGEUP; break;\n\n                        case SDLK_PAGEDOWN: keysym = QEMU_KEY_CTRL_PAGEDOWN; break;\n\n                        default: break;\n\n                        }\n\n                    } else {\n\n                        switch(ev->key.keysym.sym) {\n\n                        case SDLK_UP: keysym = QEMU_KEY_UP; break;\n\n                        case SDLK_DOWN: keysym = QEMU_KEY_DOWN; break;\n\n                        case SDLK_LEFT: keysym = QEMU_KEY_LEFT; break;\n\n                        case SDLK_RIGHT: keysym = QEMU_KEY_RIGHT; break;\n\n                        case SDLK_HOME: keysym = QEMU_KEY_HOME; break;\n\n                        case SDLK_END: keysym = QEMU_KEY_END; break;\n\n                        case SDLK_PAGEUP: keysym = QEMU_KEY_PAGEUP; break;\n\n                        case SDLK_PAGEDOWN: keysym = QEMU_KEY_PAGEDOWN; break;\n\n                        case SDLK_BACKSPACE: keysym = QEMU_KEY_BACKSPACE; break;\n\n                        case SDLK_DELETE: keysym = QEMU_KEY_DELETE; break;\n\n                        default: break;\n\n                        }\n\n                    }\n\n                    if (keysym) {\n\n                        kbd_put_keysym(keysym);\n\n                    } else if (ev->key.keysym.unicode != 0) {\n\n                        kbd_put_keysym(ev->key.keysym.unicode);\n\n                    }\n\n                }\n\n            } else if (ev->type == SDL_KEYUP) {\n\n                if (!alt_grab) {\n\n                    mod_state = (ev->key.keysym.mod & gui_grab_code);\n\n                } else {\n\n                    mod_state = (ev->key.keysym.mod &\n\n                                 (gui_grab_code | KMOD_LSHIFT));\n\n                }\n\n                if (!mod_state) {\n\n                    if (gui_key_modifier_pressed) {\n\n                        gui_key_modifier_pressed = 0;\n\n                        if (gui_keysym == 0) {\n\n                            /* exit/enter grab if pressing Ctrl-Alt */\n\n                            if (!gui_grab) {\n\n                                /* if the application is not active,\n\n                                   do not try to enter grab state. It\n\n                                   prevents\n\n                                   'SDL_WM_GrabInput(SDL_GRAB_ON)'\n\n                                   from blocking all the application\n\n                                   (SDL bug). */\n\n                                if (SDL_GetAppState() & SDL_APPACTIVE)\n\n                                    sdl_grab_start();\n\n                            } else {\n\n                                sdl_grab_end();\n\n                            }\n\n                            /* SDL does not send back all the\n\n                               modifiers key, so we must correct it */\n\n                            reset_keys();\n\n                            break;\n\n                        }\n\n                        gui_keysym = 0;\n\n                    }\n\n                }\n\n            }\n\n            if (is_graphic_console() && !gui_keysym)\n\n                sdl_process_key(&ev->key);\n\n            break;\n\n        case SDL_QUIT:\n\n            if (!no_quit) {\n\n                qemu_system_shutdown_request();\n\n                vm_start();\t/* In case we're paused */\n\n            }\n\n            break;\n\n        case SDL_MOUSEMOTION:\n\n            if (gui_grab || kbd_mouse_is_absolute() ||\n\n                absolute_enabled) {\n\n                sdl_send_mouse_event(ev->motion.xrel, ev->motion.yrel, 0,\n\n                       ev->motion.x, ev->motion.y, ev->motion.state);\n\n            }\n\n            break;\n\n        case SDL_MOUSEBUTTONDOWN:\n\n        case SDL_MOUSEBUTTONUP:\n\n            {\n\n                SDL_MouseButtonEvent *bev = &ev->button;\n\n                if (!gui_grab && !kbd_mouse_is_absolute()) {\n\n                    if (ev->type == SDL_MOUSEBUTTONDOWN &&\n\n                        (bev->button == SDL_BUTTON_LEFT)) {\n\n                        /* start grabbing all events */\n\n                        sdl_grab_start();\n\n                    }\n\n                } else {\n\n                    int dz;\n\n                    dz = 0;\n\n                    if (ev->type == SDL_MOUSEBUTTONDOWN) {\n\n                        buttonstate |= SDL_BUTTON(bev->button);\n\n                    } else {\n\n                        buttonstate &= ~SDL_BUTTON(bev->button);\n\n                    }\n\n#ifdef SDL_BUTTON_WHEELUP\n\n                    if (bev->button == SDL_BUTTON_WHEELUP && ev->type == SDL_MOUSEBUTTONDOWN) {\n\n                        dz = -1;\n\n                    } else if (bev->button == SDL_BUTTON_WHEELDOWN && ev->type == SDL_MOUSEBUTTONDOWN) {\n\n                        dz = 1;\n\n                    }\n\n#endif\n\n                    sdl_send_mouse_event(0, 0, dz, bev->x, bev->y, buttonstate);\n\n                }\n\n            }\n\n            break;\n\n        case SDL_ACTIVEEVENT:\n\n            if (gui_grab && ev->active.state == SDL_APPINPUTFOCUS &&\n\n                !ev->active.gain && !gui_fullscreen_initial_grab) {\n\n                sdl_grab_end();\n\n            }\n\n            if (ev->active.state & SDL_APPACTIVE) {\n\n                if (ev->active.gain) {\n\n                    /* Back to default interval */\n\n                    ds->gui_timer_interval = 0;\n\n                } else {\n\n                    /* Sleeping interval */\n\n                    ds->gui_timer_interval = 500;\n\n                }\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 25531}
{"project": "qemu", "commit_id": "75af1f34cd5b07c3c7fcf86dfc99a42de48a600d", "target": 0, "func": "static int bdrv_check_byte_request(BlockDriverState *bs, int64_t offset,\n\n                                   size_t size)\n\n{\n\n    int64_t len;\n\n\n\n    if (size > INT_MAX) {\n\n        return -EIO;\n\n    }\n\n\n\n    if (!bdrv_is_inserted(bs))\n\n        return -ENOMEDIUM;\n\n\n\n    if (bs->growable)\n\n        return 0;\n\n\n\n    len = bdrv_getlength(bs);\n\n\n\n    if (offset < 0)\n\n        return -EIO;\n\n\n\n    if ((offset > len) || (len - offset < size))\n\n        return -EIO;\n\n\n\n    return 0;\n\n}\n", "idx": 25532}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static ssize_t vnc_tls_pull(gnutls_transport_ptr_t transport,\n\n                            void *data,\n\n                            size_t len) {\n\n    struct VncState *vs = (struct VncState *)transport;\n\n    int ret;\n\n\n\n retry:\n\n    ret = recv(vs->csock, data, len, 0);\n\n    if (ret < 0) {\n\n\tif (errno == EINTR)\n\n\t    goto retry;\n\n\treturn -1;\n\n    }\n\n    return ret;\n\n}\n", "idx": 25535}
{"project": "qemu", "commit_id": "c3f33667a64a6de0b92106c862247d97d81490ef", "target": 0, "func": "static bool pcie_aer_msg_root_port(PCIDevice *dev, const PCIEAERMsg *msg)\n\n{\n\n    bool msg_sent;\n\n    uint16_t cmd;\n\n    uint8_t *aer_cap;\n\n    uint32_t root_cmd;\n\n    uint32_t root_status;\n\n    bool msi_trigger;\n\n\n\n    msg_sent = false;\n\n    cmd = pci_get_word(dev->config + PCI_COMMAND);\n\n    aer_cap = dev->config + dev->exp.aer_cap;\n\n    root_cmd = pci_get_long(aer_cap + PCI_ERR_ROOT_COMMAND);\n\n    root_status = pci_get_long(aer_cap + PCI_ERR_ROOT_STATUS);\n\n    msi_trigger = false;\n\n\n\n    if (cmd & PCI_COMMAND_SERR) {\n\n        /* System Error.\n\n         *\n\n         * The way to report System Error is platform specific and\n\n         * it isn't implemented in qemu right now.\n\n         * So just discard the error for now.\n\n         * OS which cares of aer would receive errors via\n\n         * native aer mechanims, so this wouldn't matter.\n\n         */\n\n    }\n\n\n\n    /* Errro Message Received: Root Error Status register */\n\n    switch (msg->severity) {\n\n    case PCI_ERR_ROOT_CMD_COR_EN:\n\n        if (root_status & PCI_ERR_ROOT_COR_RCV) {\n\n            root_status |= PCI_ERR_ROOT_MULTI_COR_RCV;\n\n        } else {\n\n            if (root_cmd & PCI_ERR_ROOT_CMD_COR_EN) {\n\n                msi_trigger = true;\n\n            }\n\n            pci_set_word(aer_cap + PCI_ERR_ROOT_COR_SRC, msg->source_id);\n\n        }\n\n        root_status |= PCI_ERR_ROOT_COR_RCV;\n\n        break;\n\n    case PCI_ERR_ROOT_CMD_NONFATAL_EN:\n\n        if (!(root_status & PCI_ERR_ROOT_NONFATAL_RCV) &&\n\n            root_cmd & PCI_ERR_ROOT_CMD_NONFATAL_EN) {\n\n            msi_trigger = true;\n\n        }\n\n        root_status |= PCI_ERR_ROOT_NONFATAL_RCV;\n\n        break;\n\n    case PCI_ERR_ROOT_CMD_FATAL_EN:\n\n        if (!(root_status & PCI_ERR_ROOT_FATAL_RCV) &&\n\n            root_cmd & PCI_ERR_ROOT_CMD_FATAL_EN) {\n\n            msi_trigger = true;\n\n        }\n\n        if (!(root_status & PCI_ERR_ROOT_UNCOR_RCV)) {\n\n            root_status |= PCI_ERR_ROOT_FIRST_FATAL;\n\n        }\n\n        root_status |= PCI_ERR_ROOT_FATAL_RCV;\n\n        break;\n\n    default:\n\n        abort();\n\n        break;\n\n    }\n\n    if (pcie_aer_msg_is_uncor(msg)) {\n\n        if (root_status & PCI_ERR_ROOT_UNCOR_RCV) {\n\n            root_status |= PCI_ERR_ROOT_MULTI_UNCOR_RCV;\n\n        } else {\n\n            pci_set_word(aer_cap + PCI_ERR_ROOT_SRC, msg->source_id);\n\n        }\n\n        root_status |= PCI_ERR_ROOT_UNCOR_RCV;\n\n    }\n\n    pci_set_long(aer_cap + PCI_ERR_ROOT_STATUS, root_status);\n\n\n\n    if (root_cmd & msg->severity) {\n\n        /* 6.2.4.1.2 Interrupt Generation */\n\n        if (msix_enabled(dev)) {\n\n            if (msi_trigger) {\n\n                msix_notify(dev, pcie_aer_root_get_vector(dev));\n\n            }\n\n        } else if (msi_enabled(dev)) {\n\n            if (msi_trigger) {\n\n                msi_notify(dev, pcie_aer_root_get_vector(dev));\n\n            }\n\n        } else {\n\n            qemu_set_irq(dev->irq[dev->exp.aer_intx], 1);\n\n        }\n\n        msg_sent = true;\n\n    }\n\n    return msg_sent;\n\n}\n", "idx": 25536}
{"project": "qemu", "commit_id": "c3f8f61157625d0bb5bfc135047573de48fdc675", "target": 0, "func": "static void put_pci_irq_state(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    int i;\n\n    PCIDevice *s = container_of(pv, PCIDevice, config);\n\n\n\n    for (i = 0; i < PCI_NUM_PINS; ++i) {\n\n        qemu_put_be32(f, pci_irq_state(s, i));\n\n    }\n\n}\n", "idx": 25537}
{"project": "qemu", "commit_id": "348295838384941d1e5420d10e57366c4e303d45", "target": 0, "func": "static void data_plane_blk_remove_notifier(Notifier *n, void *data)\n\n{\n\n    VirtIOBlockDataPlane *s = container_of(n, VirtIOBlockDataPlane,\n\n                                           remove_notifier);\n\n    assert(s->conf->conf.blk == data);\n\n    data_plane_remove_op_blockers(s);\n\n}\n", "idx": 25538}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "static int nbd_co_send_request(NbdClientSession *s,\n\n    struct nbd_request *request,\n\n    QEMUIOVector *qiov, int offset)\n\n{\n\n    AioContext *aio_context;\n\n    int rc, ret;\n\n\n\n    qemu_co_mutex_lock(&s->send_mutex);\n\n    s->send_coroutine = qemu_coroutine_self();\n\n    aio_context = bdrv_get_aio_context(s->bs);\n\n    aio_set_fd_handler(aio_context, s->sock,\n\n                       nbd_reply_ready, nbd_restart_write, s);\n\n    if (qiov) {\n\n        if (!s->is_unix) {\n\n            socket_set_cork(s->sock, 1);\n\n        }\n\n        rc = nbd_send_request(s->sock, request);\n\n        if (rc >= 0) {\n\n            ret = qemu_co_sendv(s->sock, qiov->iov, qiov->niov,\n\n                                offset, request->len);\n\n            if (ret != request->len) {\n\n                rc = -EIO;\n\n            }\n\n        }\n\n        if (!s->is_unix) {\n\n            socket_set_cork(s->sock, 0);\n\n        }\n\n    } else {\n\n        rc = nbd_send_request(s->sock, request);\n\n    }\n\n    aio_set_fd_handler(aio_context, s->sock, nbd_reply_ready, NULL, s);\n\n    s->send_coroutine = NULL;\n\n    qemu_co_mutex_unlock(&s->send_mutex);\n\n    return rc;\n\n}\n", "idx": 25539}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t ac97_read(void *opaque, target_phys_addr_t addr,\n\n                          unsigned size)\n\n{\n\n    MilkymistAC97State *s = opaque;\n\n    uint32_t r = 0;\n\n\n\n    addr >>= 2;\n\n    switch (addr) {\n\n    case R_AC97_CTRL:\n\n    case R_AC97_ADDR:\n\n    case R_AC97_DATAOUT:\n\n    case R_AC97_DATAIN:\n\n    case R_D_CTRL:\n\n    case R_D_ADDR:\n\n    case R_D_REMAINING:\n\n    case R_U_CTRL:\n\n    case R_U_ADDR:\n\n    case R_U_REMAINING:\n\n        r = s->regs[addr];\n\n        break;\n\n\n\n    default:\n\n        error_report(\"milkymist_ac97: read access to unknown register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    }\n\n\n\n    trace_milkymist_ac97_memory_read(addr << 2, r);\n\n\n\n    return r;\n\n}\n", "idx": 25540}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "static void spr_write_ibatu_h (void *opaque, int sprn)\n\n{\n\n    DisasContext *ctx = opaque;\n\n\n\n    gen_op_store_ibatu((sprn - SPR_IBAT4U) / 2);\n\n    RET_STOP(ctx);\n\n}\n", "idx": 25541}
{"project": "qemu", "commit_id": "bd31c214c328bc6a2b2f5567623d964b65c8f44c", "target": 0, "func": "static int find_partition(BlockBackend *blk, int partition,\n\n                          off_t *offset, off_t *size)\n\n{\n\n    struct partition_record mbr[4];\n\n    uint8_t data[512];\n\n    int i;\n\n    int ext_partnum = 4;\n\n    int ret;\n\n\n\n    if ((ret = blk_read(blk, 0, data, 1)) < 0) {\n\n        error_report(\"error while reading: %s\", strerror(-ret));\n\n        exit(EXIT_FAILURE);\n\n    }\n\n\n\n    if (data[510] != 0x55 || data[511] != 0xaa) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        read_partition(&data[446 + 16 * i], &mbr[i]);\n\n\n\n        if (!mbr[i].system || !mbr[i].nb_sectors_abs) {\n\n            continue;\n\n        }\n\n\n\n        if (mbr[i].system == 0xF || mbr[i].system == 0x5) {\n\n            struct partition_record ext[4];\n\n            uint8_t data1[512];\n\n            int j;\n\n\n\n            if ((ret = blk_read(blk, mbr[i].start_sector_abs, data1, 1)) < 0) {\n\n                error_report(\"error while reading: %s\", strerror(-ret));\n\n                exit(EXIT_FAILURE);\n\n            }\n\n\n\n            for (j = 0; j < 4; j++) {\n\n                read_partition(&data1[446 + 16 * j], &ext[j]);\n\n                if (!ext[j].system || !ext[j].nb_sectors_abs) {\n\n                    continue;\n\n                }\n\n\n\n                if ((ext_partnum + j + 1) == partition) {\n\n                    *offset = (uint64_t)ext[j].start_sector_abs << 9;\n\n                    *size = (uint64_t)ext[j].nb_sectors_abs << 9;\n\n                    return 0;\n\n                }\n\n            }\n\n            ext_partnum += 4;\n\n        } else if ((i + 1) == partition) {\n\n            *offset = (uint64_t)mbr[i].start_sector_abs << 9;\n\n            *size = (uint64_t)mbr[i].nb_sectors_abs << 9;\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    return -ENOENT;\n\n}\n", "idx": 25542}
{"project": "qemu", "commit_id": "b3ceef24f4fee8d5ed96b8c4a5d3e80c0a651f0b", "target": 0, "func": "static void sun4m_common_init(int ram_size, int boot_device, DisplayState *ds,\n\n                              const char *kernel_filename, const char *kernel_cmdline,\n\n                              const char *initrd_filename, const char *cpu_model,\n\n                              unsigned int machine, int max_ram)\n\n{\n\n    if ((unsigned int)ram_size > (unsigned int)max_ram) {\n\n        fprintf(stderr, \"qemu: Too much memory for this machine: %d, maximum %d\\n\",\n\n                (unsigned int)ram_size / (1024 * 1024),\n\n                (unsigned int)max_ram / (1024 * 1024));\n\n        exit(1);\n\n    }\n\n    sun4m_hw_init(&hwdefs[machine], ram_size, ds, cpu_model);\n\n\n\n    sun4m_load_kernel(hwdefs[machine].vram_size, ram_size, boot_device,\n\n                      kernel_filename, kernel_cmdline, initrd_filename,\n\n                      hwdefs[machine].machine_id);\n\n}\n", "idx": 25543}
{"project": "qemu", "commit_id": "b172c56a6d849554f7e43adc95983a9d6c042689", "target": 0, "func": "static always_inline void _cpu_ppc_store_hdecr (CPUState *env, uint32_t hdecr,\n\n                                                uint32_t value, int is_excp)\n\n{\n\n    ppc_tb_t *tb_env = env->tb_env;\n\n\n\n    __cpu_ppc_store_decr(env, &tb_env->hdecr_next, tb_env->hdecr_timer,\n\n                         &cpu_ppc_hdecr_excp, hdecr, value, is_excp);\n\n}\n", "idx": 25544}
{"project": "qemu", "commit_id": "f22d85e9e67262db34504f4079745f9843da6a92", "target": 0, "func": "void qmp_disable_command(const char *name)\n\n{\n\n    QmpCommand *cmd;\n\n\n\n    QTAILQ_FOREACH(cmd, &qmp_commands, node) {\n\n        if (strcmp(cmd->name, name) == 0) {\n\n            cmd->enabled = false;\n\n            return;\n\n        }\n\n    }\n\n}\n", "idx": 25546}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void ref405ep_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    char *filename;\n\n    ppc4xx_bd_info_t bd;\n\n    CPUPPCState *env;\n\n    qemu_irq *pic;\n\n    MemoryRegion *bios;\n\n    MemoryRegion *sram = g_new(MemoryRegion, 1);\n\n    ram_addr_t bdloc;\n\n    MemoryRegion *ram_memories = g_malloc(2 * sizeof(*ram_memories));\n\n    hwaddr ram_bases[2], ram_sizes[2];\n\n    target_ulong sram_size;\n\n    long bios_size;\n\n    //int phy_addr = 0;\n\n    //static int phy_addr = 1;\n\n    target_ulong kernel_base, initrd_base;\n\n    long kernel_size, initrd_size;\n\n    int linux_boot;\n\n    int fl_idx, fl_sectors, len;\n\n    DriveInfo *dinfo;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n\n\n    /* XXX: fix this */\n\n    memory_region_allocate_system_memory(&ram_memories[0], NULL, \"ef405ep.ram\",\n\n                                         0x08000000);\n\n    ram_bases[0] = 0;\n\n    ram_sizes[0] = 0x08000000;\n\n    memory_region_init(&ram_memories[1], NULL, \"ef405ep.ram1\", 0);\n\n    ram_bases[1] = 0x00000000;\n\n    ram_sizes[1] = 0x00000000;\n\n    ram_size = 128 * 1024 * 1024;\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register cpu\\n\", __func__);\n\n#endif\n\n    env = ppc405ep_init(sysmem, ram_memories, ram_bases, ram_sizes,\n\n                        33333333, &pic, kernel_filename == NULL ? 0 : 1);\n\n    /* allocate SRAM */\n\n    sram_size = 512 * 1024;\n\n    memory_region_init_ram(sram, NULL, \"ef405ep.sram\", sram_size, &error_abort);\n\n    vmstate_register_ram_global(sram);\n\n    memory_region_add_subregion(sysmem, 0xFFF00000, sram);\n\n    /* allocate and load BIOS */\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register BIOS\\n\", __func__);\n\n#endif\n\n    fl_idx = 0;\n\n#ifdef USE_FLASH_BIOS\n\n    dinfo = drive_get(IF_PFLASH, 0, fl_idx);\n\n    if (dinfo) {\n\n        BlockDriverState *bs = blk_bs(blk_by_legacy_dinfo(dinfo));\n\n\n\n        bios_size = bdrv_getlength(bs);\n\n        fl_sectors = (bios_size + 65535) >> 16;\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"Register parallel flash %d size %lx\"\n\n               \" at addr %lx '%s' %d\\n\",\n\n               fl_idx, bios_size, -bios_size,\n\n               bdrv_get_device_name(bs), fl_sectors);\n\n#endif\n\n        pflash_cfi02_register((uint32_t)(-bios_size),\n\n                              NULL, \"ef405ep.bios\", bios_size,\n\n                              bs, 65536, fl_sectors, 1,\n\n                              2, 0x0001, 0x22DA, 0x0000, 0x0000, 0x555, 0x2AA,\n\n                              1);\n\n        fl_idx++;\n\n    } else\n\n#endif\n\n    {\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"Load BIOS from file\\n\");\n\n#endif\n\n        bios = g_new(MemoryRegion, 1);\n\n        memory_region_init_ram(bios, NULL, \"ef405ep.bios\", BIOS_SIZE,\n\n                               &error_abort);\n\n        vmstate_register_ram_global(bios);\n\n\n\n        if (bios_name == NULL)\n\n            bios_name = BIOS_FILENAME;\n\n        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n        if (filename) {\n\n            bios_size = load_image(filename, memory_region_get_ram_ptr(bios));\n\n            g_free(filename);\n\n            if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n                error_report(\"Could not load PowerPC BIOS '%s'\", bios_name);\n\n                exit(1);\n\n            }\n\n            bios_size = (bios_size + 0xfff) & ~0xfff;\n\n            memory_region_add_subregion(sysmem, (uint32_t)(-bios_size), bios);\n\n        } else if (!qtest_enabled() || kernel_filename != NULL) {\n\n            error_report(\"Could not load PowerPC BIOS '%s'\", bios_name);\n\n            exit(1);\n\n        } else {\n\n            /* Avoid an uninitialized variable warning */\n\n            bios_size = -1;\n\n        }\n\n        memory_region_set_readonly(bios, true);\n\n    }\n\n    /* Register FPGA */\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register FPGA\\n\", __func__);\n\n#endif\n\n    ref405ep_fpga_init(sysmem, 0xF0300000);\n\n    /* Register NVRAM */\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register NVRAM\\n\", __func__);\n\n#endif\n\n    m48t59_init(NULL, 0xF0000000, 0, 8192, 8);\n\n    /* Load kernel */\n\n    linux_boot = (kernel_filename != NULL);\n\n    if (linux_boot) {\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"%s: load kernel\\n\", __func__);\n\n#endif\n\n        memset(&bd, 0, sizeof(bd));\n\n        bd.bi_memstart = 0x00000000;\n\n        bd.bi_memsize = ram_size;\n\n        bd.bi_flashstart = -bios_size;\n\n        bd.bi_flashsize = -bios_size;\n\n        bd.bi_flashoffset = 0;\n\n        bd.bi_sramstart = 0xFFF00000;\n\n        bd.bi_sramsize = sram_size;\n\n        bd.bi_bootflags = 0;\n\n        bd.bi_intfreq = 133333333;\n\n        bd.bi_busfreq = 33333333;\n\n        bd.bi_baudrate = 115200;\n\n        bd.bi_s_version[0] = 'Q';\n\n        bd.bi_s_version[1] = 'M';\n\n        bd.bi_s_version[2] = 'U';\n\n        bd.bi_s_version[3] = '\\0';\n\n        bd.bi_r_version[0] = 'Q';\n\n        bd.bi_r_version[1] = 'E';\n\n        bd.bi_r_version[2] = 'M';\n\n        bd.bi_r_version[3] = 'U';\n\n        bd.bi_r_version[4] = '\\0';\n\n        bd.bi_procfreq = 133333333;\n\n        bd.bi_plb_busfreq = 33333333;\n\n        bd.bi_pci_busfreq = 33333333;\n\n        bd.bi_opbfreq = 33333333;\n\n        bdloc = ppc405_set_bootinfo(env, &bd, 0x00000001);\n\n        env->gpr[3] = bdloc;\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n        /* now we can load the kernel */\n\n        kernel_size = load_image_targphys(kernel_filename, kernel_base,\n\n                                          ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n        printf(\"Load kernel size %ld at \" TARGET_FMT_lx,\n\n               kernel_size, kernel_base);\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n        env->gpr[4] = initrd_base;\n\n        env->gpr[5] = initrd_size;\n\n        if (kernel_cmdline != NULL) {\n\n            len = strlen(kernel_cmdline);\n\n            bdloc -= ((len + 255) & ~255);\n\n            cpu_physical_memory_write(bdloc, kernel_cmdline, len + 1);\n\n            env->gpr[6] = bdloc;\n\n            env->gpr[7] = bdloc + len;\n\n        } else {\n\n            env->gpr[6] = 0;\n\n            env->gpr[7] = 0;\n\n        }\n\n        env->nip = KERNEL_LOAD_ADDR;\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n        bdloc = 0;\n\n    }\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"bdloc \" RAM_ADDR_FMT \"\\n\", bdloc);\n\n    printf(\"%s: Done\\n\", __func__);\n\n#endif\n\n}\n", "idx": 25547}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static int v9fs_synth_opendir(FsContext *ctx,\n\n                             V9fsPath *fs_path, V9fsFidOpenState *fs)\n\n{\n\n    V9fsSynthOpenState *synth_open;\n\n    V9fsSynthNode *node = *(V9fsSynthNode **)fs_path->data;\n\n\n\n    synth_open = g_malloc(sizeof(*synth_open));\n\n    synth_open->node = node;\n\n    node->open_count++;\n\n    fs->private = synth_open;\n\n    return 0;\n\n}\n", "idx": 25548}
{"project": "qemu", "commit_id": "e1f8c729fa890c67bb4532f22c22ace6fb0e1aaf", "target": 0, "func": "qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)\n\n{\n\n    PXA2xxPICState *s;\n\n    int iomemtype;\n\n    qemu_irq *qi;\n\n\n\n    s = (PXA2xxPICState *)\n\n            qemu_mallocz(sizeof(PXA2xxPICState));\n\n    if (!s)\n\n        return NULL;\n\n\n\n    s->cpu_env = env;\n\n\n\n    s->int_pending[0] = 0;\n\n    s->int_pending[1] = 0;\n\n    s->int_enabled[0] = 0;\n\n    s->int_enabled[1] = 0;\n\n    s->is_fiq[0] = 0;\n\n    s->is_fiq[1] = 0;\n\n\n\n    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);\n\n\n\n    /* Enable IC memory-mapped registers access.  */\n\n    iomemtype = cpu_register_io_memory(pxa2xx_pic_readfn,\n\n                    pxa2xx_pic_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(base, 0x00100000, iomemtype);\n\n\n\n    /* Enable IC coprocessor access.  */\n\n    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);\n\n\n\n    register_savevm(NULL, \"pxa2xx_pic\", 0, 0, pxa2xx_pic_save,\n\n                    pxa2xx_pic_load, s);\n\n\n\n    return qi;\n\n}\n", "idx": 25549}
{"project": "qemu", "commit_id": "4a917c39aed9ad7f648c435204a6586c4ca3f2f2", "target": 0, "func": "int net_init_vde(QemuOpts *opts, const NetClientOptions *new_opts,\n\n                 const char *name, VLANState *vlan)\n\n{\n\n    const char *sock;\n\n    const char *group;\n\n    int port, mode;\n\n\n\n    sock  = qemu_opt_get(opts, \"sock\");\n\n    group = qemu_opt_get(opts, \"group\");\n\n\n\n    port = qemu_opt_get_number(opts, \"port\", 0);\n\n    mode = qemu_opt_get_number(opts, \"mode\", 0700);\n\n\n\n    if (net_vde_init(vlan, \"vde\", name, sock, port, group, mode) == -1) {\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 25550}
{"project": "qemu", "commit_id": "53724ee565565f69560dbe17553bede8c0169379", "target": 0, "func": "void spapr_tce_reset(DMAContext *dma)\n\n{\n\n    if (dma) {\n\n        sPAPRTCETable *tcet = DO_UPCAST(sPAPRTCETable, dma, dma);\n\n        size_t table_size = (tcet->window_size >> SPAPR_TCE_PAGE_SHIFT)\n\n            * sizeof(sPAPRTCE);\n\n\n\n        memset(tcet->table, 0, table_size);\n\n    }\n\n}\n", "idx": 25551}
{"project": "qemu", "commit_id": "2e6fc7eb1a4af1b127df5f07b8bb28af891946fa", "target": 0, "func": "static void raw_reopen_commit(BDRVReopenState *state)\n\n{\n\n    BDRVRawState *new_s = state->opaque;\n\n    BDRVRawState *s = state->bs->opaque;\n\n\n\n    memcpy(s, new_s, sizeof(BDRVRawState));\n\n\n\n    g_free(state->opaque);\n\n    state->opaque = NULL;\n\n}\n", "idx": 25552}
{"project": "qemu", "commit_id": "7f0317cfc8da620cdb38cb5cfec5f82b8dd05403", "target": 1, "func": "static void mirror_start_job(BlockDriverState *bs, BlockDriverState *target,\n\n                             const char *replaces,\n\n                             int64_t speed, uint32_t granularity,\n\n                             int64_t buf_size,\n\n                             BlockMirrorBackingMode backing_mode,\n\n                             BlockdevOnError on_source_error,\n\n                             BlockdevOnError on_target_error,\n\n                             bool unmap,\n\n                             BlockCompletionFunc *cb,\n\n                             void *opaque, Error **errp,\n\n                             const BlockJobDriver *driver,\n\n                             bool is_none_mode, BlockDriverState *base)\n\n{\n\n    MirrorBlockJob *s;\n\n\n\n    if (granularity == 0) {\n\n        granularity = bdrv_get_default_bitmap_granularity(target);\n\n    }\n\n\n\n    assert ((granularity & (granularity - 1)) == 0);\n\n\n\n    if (buf_size < 0) {\n\n        error_setg(errp, \"Invalid parameter 'buf-size'\");\n\n        return;\n\n    }\n\n\n\n    if (buf_size == 0) {\n\n        buf_size = DEFAULT_MIRROR_BUF_SIZE;\n\n    }\n\n\n\n    s = block_job_create(driver, bs, speed, cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->target = blk_new();\n\n    blk_insert_bs(s->target, target);\n\n\n\n    s->replaces = g_strdup(replaces);\n\n    s->on_source_error = on_source_error;\n\n    s->on_target_error = on_target_error;\n\n    s->is_none_mode = is_none_mode;\n\n    s->backing_mode = backing_mode;\n\n    s->base = base;\n\n    s->granularity = granularity;\n\n    s->buf_size = ROUND_UP(buf_size, granularity);\n\n    s->unmap = unmap;\n\n\n\n    s->dirty_bitmap = bdrv_create_dirty_bitmap(bs, granularity, NULL, errp);\n\n    if (!s->dirty_bitmap) {\n\n        g_free(s->replaces);\n\n        blk_unref(s->target);\n\n        block_job_unref(&s->common);\n\n        return;\n\n    }\n\n\n\n    bdrv_op_block_all(target, s->common.blocker);\n\n\n\n    s->common.co = qemu_coroutine_create(mirror_run);\n\n    trace_mirror_start(bs, s, s->common.co, opaque);\n\n    qemu_coroutine_enter(s->common.co, s);\n\n}\n", "idx": 25555}
{"project": "qemu", "commit_id": "c547e5640d5b0993cdfb252331065c1a1d813bd8", "target": 1, "func": "static int blkdebug_debug_resume(BlockDriverState *bs, const char *tag)\n\n{\n\n    BDRVBlkdebugState *s = bs->opaque;\n\n    BlkdebugSuspendedReq *r;\n\n\n\n    QLIST_FOREACH(r, &s->suspended_reqs, next) {\n\n        if (!strcmp(r->tag, tag)) {\n\n            qemu_coroutine_enter(r->co, NULL);\n\n            return 0;\n\n        }\n\n    }\n\n    return -ENOENT;\n\n}\n", "idx": 25556}
{"project": "qemu", "commit_id": "42e38c1fd0199155d32f3464aedce282d3d7f6a1", "target": 1, "func": "static void virtio_blk_handle_write(VirtIOBlockReq *req, MultiReqBuffer *mrb)\n\n{\n\n    BlockRequest *blkreq;\n\n    uint64_t sector;\n\n\n\n    sector = virtio_ldq_p(VIRTIO_DEVICE(req->dev), &req->out.sector);\n\n\n\n    bdrv_acct_start(req->dev->bs, &req->acct, req->qiov.size, BDRV_ACCT_WRITE);\n\n\n\n    trace_virtio_blk_handle_write(req, sector, req->qiov.size / 512);\n\n\n\n    if (!virtio_blk_sect_range_ok(req->dev, sector, req->qiov.size)) {\n\n        virtio_blk_rw_complete(req, -EIO);\n\n        return;\n\n    }\n\n\n\n    if (mrb->num_writes == 32) {\n\n        virtio_submit_multiwrite(req->dev->bs, mrb);\n\n    }\n\n\n\n    blkreq = &mrb->blkreq[mrb->num_writes];\n\n    blkreq->sector = sector;\n\n    blkreq->nb_sectors = req->qiov.size / BDRV_SECTOR_SIZE;\n\n    blkreq->qiov = &req->qiov;\n\n    blkreq->cb = virtio_blk_rw_complete;\n\n    blkreq->opaque = req;\n\n    blkreq->error = 0;\n\n\n\n    mrb->num_writes++;\n\n}\n", "idx": 25558}
{"project": "qemu", "commit_id": "2343dd11a673597aa59813fd0cac2ae42e2e0312", "target": 1, "func": "static int ppce500_load_device_tree(MachineState *machine,\n\n                                    PPCE500Params *params,\n\n                                    hwaddr addr,\n\n                                    hwaddr initrd_base,\n\n                                    hwaddr initrd_size,\n\n                                    hwaddr kernel_base,\n\n                                    hwaddr kernel_size,\n\n                                    bool dry_run)\n\n{\n\n    CPUPPCState *env = first_cpu->env_ptr;\n\n    int ret = -1;\n\n    uint64_t mem_reg_property[] = { 0, cpu_to_be64(machine->ram_size) };\n\n    int fdt_size;\n\n    void *fdt;\n\n    uint8_t hypercall[16];\n\n    uint32_t clock_freq = 400000000;\n\n    uint32_t tb_freq = 400000000;\n\n    int i;\n\n    char compatible_sb[] = \"fsl,mpc8544-immr\\0simple-bus\";\n\n    char soc[128];\n\n    char mpic[128];\n\n    uint32_t mpic_ph;\n\n    uint32_t msi_ph;\n\n    char gutil[128];\n\n    char pci[128];\n\n    char msi[128];\n\n    uint32_t *pci_map = NULL;\n\n    int len;\n\n    uint32_t pci_ranges[14] =\n\n        {\n\n            0x2000000, 0x0, params->pci_mmio_bus_base,\n\n            params->pci_mmio_base >> 32, params->pci_mmio_base,\n\n            0x0, 0x20000000,\n\n\n\n            0x1000000, 0x0, 0x0,\n\n            params->pci_pio_base >> 32, params->pci_pio_base,\n\n            0x0, 0x10000,\n\n        };\n\n    QemuOpts *machine_opts = qemu_get_machine_opts();\n\n    const char *dtb_file = qemu_opt_get(machine_opts, \"dtb\");\n\n    const char *toplevel_compat = qemu_opt_get(machine_opts, \"dt_compatible\");\n\n\n\n    if (dtb_file) {\n\n        char *filename;\n\n        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, dtb_file);\n\n        if (!filename) {\n\n            goto out;\n\n        }\n\n\n\n        fdt = load_device_tree(filename, &fdt_size);\n\n\n        if (!fdt) {\n\n            goto out;\n\n        }\n\n        goto done;\n\n    }\n\n\n\n    fdt = create_device_tree(&fdt_size);\n\n    if (fdt == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    /* Manipulate device tree in memory. */\n\n    qemu_fdt_setprop_cell(fdt, \"/\", \"#address-cells\", 2);\n\n    qemu_fdt_setprop_cell(fdt, \"/\", \"#size-cells\", 2);\n\n\n\n    qemu_fdt_add_subnode(fdt, \"/memory\");\n\n    qemu_fdt_setprop_string(fdt, \"/memory\", \"device_type\", \"memory\");\n\n    qemu_fdt_setprop(fdt, \"/memory\", \"reg\", mem_reg_property,\n\n                     sizeof(mem_reg_property));\n\n\n\n    qemu_fdt_add_subnode(fdt, \"/chosen\");\n\n    if (initrd_size) {\n\n        ret = qemu_fdt_setprop_cell(fdt, \"/chosen\", \"linux,initrd-start\",\n\n                                    initrd_base);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"couldn't set /chosen/linux,initrd-start\\n\");\n\n        }\n\n\n\n        ret = qemu_fdt_setprop_cell(fdt, \"/chosen\", \"linux,initrd-end\",\n\n                                    (initrd_base + initrd_size));\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"couldn't set /chosen/linux,initrd-end\\n\");\n\n        }\n\n\n\n    }\n\n\n\n    if (kernel_base != -1ULL) {\n\n        qemu_fdt_setprop_cells(fdt, \"/chosen\", \"qemu,boot-kernel\",\n\n                                     kernel_base >> 32, kernel_base,\n\n                                     kernel_size >> 32, kernel_size);\n\n    }\n\n\n\n    ret = qemu_fdt_setprop_string(fdt, \"/chosen\", \"bootargs\",\n\n                                      machine->kernel_cmdline);\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /chosen/bootargs\\n\");\n\n\n\n    if (kvm_enabled()) {\n\n        /* Read out host's frequencies */\n\n        clock_freq = kvmppc_get_clockfreq();\n\n        tb_freq = kvmppc_get_tbfreq();\n\n\n\n        /* indicate KVM hypercall interface */\n\n        qemu_fdt_add_subnode(fdt, \"/hypervisor\");\n\n        qemu_fdt_setprop_string(fdt, \"/hypervisor\", \"compatible\",\n\n                                \"linux,kvm\");\n\n        kvmppc_get_hypercall(env, hypercall, sizeof(hypercall));\n\n        qemu_fdt_setprop(fdt, \"/hypervisor\", \"hcall-instructions\",\n\n                         hypercall, sizeof(hypercall));\n\n        /* if KVM supports the idle hcall, set property indicating this */\n\n        if (kvmppc_get_hasidle(env)) {\n\n            qemu_fdt_setprop(fdt, \"/hypervisor\", \"has-idle\", NULL, 0);\n\n        }\n\n    }\n\n\n\n    /* Create CPU nodes */\n\n    qemu_fdt_add_subnode(fdt, \"/cpus\");\n\n    qemu_fdt_setprop_cell(fdt, \"/cpus\", \"#address-cells\", 1);\n\n    qemu_fdt_setprop_cell(fdt, \"/cpus\", \"#size-cells\", 0);\n\n\n\n    /* We need to generate the cpu nodes in reverse order, so Linux can pick\n\n       the first node as boot node and be happy */\n\n    for (i = smp_cpus - 1; i >= 0; i--) {\n\n        CPUState *cpu;\n\n        PowerPCCPU *pcpu;\n\n        char cpu_name[128];\n\n        uint64_t cpu_release_addr = params->spin_base + (i * 0x20);\n\n\n\n        cpu = qemu_get_cpu(i);\n\n        if (cpu == NULL) {\n\n            continue;\n\n        }\n\n        env = cpu->env_ptr;\n\n        pcpu = POWERPC_CPU(cpu);\n\n\n\n        snprintf(cpu_name, sizeof(cpu_name), \"/cpus/PowerPC,8544@%x\",\n\n                 ppc_get_vcpu_dt_id(pcpu));\n\n        qemu_fdt_add_subnode(fdt, cpu_name);\n\n        qemu_fdt_setprop_cell(fdt, cpu_name, \"clock-frequency\", clock_freq);\n\n        qemu_fdt_setprop_cell(fdt, cpu_name, \"timebase-frequency\", tb_freq);\n\n        qemu_fdt_setprop_string(fdt, cpu_name, \"device_type\", \"cpu\");\n\n        qemu_fdt_setprop_cell(fdt, cpu_name, \"reg\",\n\n                              ppc_get_vcpu_dt_id(pcpu));\n\n        qemu_fdt_setprop_cell(fdt, cpu_name, \"d-cache-line-size\",\n\n                              env->dcache_line_size);\n\n        qemu_fdt_setprop_cell(fdt, cpu_name, \"i-cache-line-size\",\n\n                              env->icache_line_size);\n\n        qemu_fdt_setprop_cell(fdt, cpu_name, \"d-cache-size\", 0x8000);\n\n        qemu_fdt_setprop_cell(fdt, cpu_name, \"i-cache-size\", 0x8000);\n\n        qemu_fdt_setprop_cell(fdt, cpu_name, \"bus-frequency\", 0);\n\n        if (cpu->cpu_index) {\n\n            qemu_fdt_setprop_string(fdt, cpu_name, \"status\", \"disabled\");\n\n            qemu_fdt_setprop_string(fdt, cpu_name, \"enable-method\",\n\n                                    \"spin-table\");\n\n            qemu_fdt_setprop_u64(fdt, cpu_name, \"cpu-release-addr\",\n\n                                 cpu_release_addr);\n\n        } else {\n\n            qemu_fdt_setprop_string(fdt, cpu_name, \"status\", \"okay\");\n\n        }\n\n    }\n\n\n\n    qemu_fdt_add_subnode(fdt, \"/aliases\");\n\n    /* XXX These should go into their respective devices' code */\n\n    snprintf(soc, sizeof(soc), \"/soc@%\"PRIx64, params->ccsrbar_base);\n\n    qemu_fdt_add_subnode(fdt, soc);\n\n    qemu_fdt_setprop_string(fdt, soc, \"device_type\", \"soc\");\n\n    qemu_fdt_setprop(fdt, soc, \"compatible\", compatible_sb,\n\n                     sizeof(compatible_sb));\n\n    qemu_fdt_setprop_cell(fdt, soc, \"#address-cells\", 1);\n\n    qemu_fdt_setprop_cell(fdt, soc, \"#size-cells\", 1);\n\n    qemu_fdt_setprop_cells(fdt, soc, \"ranges\", 0x0,\n\n                           params->ccsrbar_base >> 32, params->ccsrbar_base,\n\n                           MPC8544_CCSRBAR_SIZE);\n\n    /* XXX should contain a reasonable value */\n\n    qemu_fdt_setprop_cell(fdt, soc, \"bus-frequency\", 0);\n\n\n\n    snprintf(mpic, sizeof(mpic), \"%s/pic@%llx\", soc, MPC8544_MPIC_REGS_OFFSET);\n\n    qemu_fdt_add_subnode(fdt, mpic);\n\n    qemu_fdt_setprop_string(fdt, mpic, \"device_type\", \"open-pic\");\n\n    qemu_fdt_setprop_string(fdt, mpic, \"compatible\", \"fsl,mpic\");\n\n    qemu_fdt_setprop_cells(fdt, mpic, \"reg\", MPC8544_MPIC_REGS_OFFSET,\n\n                           0x40000);\n\n    qemu_fdt_setprop_cell(fdt, mpic, \"#address-cells\", 0);\n\n    qemu_fdt_setprop_cell(fdt, mpic, \"#interrupt-cells\", 2);\n\n    mpic_ph = qemu_fdt_alloc_phandle(fdt);\n\n    qemu_fdt_setprop_cell(fdt, mpic, \"phandle\", mpic_ph);\n\n    qemu_fdt_setprop_cell(fdt, mpic, \"linux,phandle\", mpic_ph);\n\n    qemu_fdt_setprop(fdt, mpic, \"interrupt-controller\", NULL, 0);\n\n\n\n    /*\n\n     * We have to generate ser1 first, because Linux takes the first\n\n     * device it finds in the dt as serial output device. And we generate\n\n     * devices in reverse order to the dt.\n\n     */\n\n    if (serial_hds[1]) {\n\n        dt_serial_create(fdt, MPC8544_SERIAL1_REGS_OFFSET,\n\n                         soc, mpic, \"serial1\", 1, false);\n\n    }\n\n\n\n    if (serial_hds[0]) {\n\n        dt_serial_create(fdt, MPC8544_SERIAL0_REGS_OFFSET,\n\n                         soc, mpic, \"serial0\", 0, true);\n\n    }\n\n\n\n    snprintf(gutil, sizeof(gutil), \"%s/global-utilities@%llx\", soc,\n\n             MPC8544_UTIL_OFFSET);\n\n    qemu_fdt_add_subnode(fdt, gutil);\n\n    qemu_fdt_setprop_string(fdt, gutil, \"compatible\", \"fsl,mpc8544-guts\");\n\n    qemu_fdt_setprop_cells(fdt, gutil, \"reg\", MPC8544_UTIL_OFFSET, 0x1000);\n\n    qemu_fdt_setprop(fdt, gutil, \"fsl,has-rstcr\", NULL, 0);\n\n\n\n    snprintf(msi, sizeof(msi), \"/%s/msi@%llx\", soc, MPC8544_MSI_REGS_OFFSET);\n\n    qemu_fdt_add_subnode(fdt, msi);\n\n    qemu_fdt_setprop_string(fdt, msi, \"compatible\", \"fsl,mpic-msi\");\n\n    qemu_fdt_setprop_cells(fdt, msi, \"reg\", MPC8544_MSI_REGS_OFFSET, 0x200);\n\n    msi_ph = qemu_fdt_alloc_phandle(fdt);\n\n    qemu_fdt_setprop_cells(fdt, msi, \"msi-available-ranges\", 0x0, 0x100);\n\n    qemu_fdt_setprop_phandle(fdt, msi, \"interrupt-parent\", mpic);\n\n    qemu_fdt_setprop_cells(fdt, msi, \"interrupts\",\n\n        0xe0, 0x0,\n\n        0xe1, 0x0,\n\n        0xe2, 0x0,\n\n        0xe3, 0x0,\n\n        0xe4, 0x0,\n\n        0xe5, 0x0,\n\n        0xe6, 0x0,\n\n        0xe7, 0x0);\n\n    qemu_fdt_setprop_cell(fdt, msi, \"phandle\", msi_ph);\n\n    qemu_fdt_setprop_cell(fdt, msi, \"linux,phandle\", msi_ph);\n\n\n\n    snprintf(pci, sizeof(pci), \"/pci@%llx\",\n\n             params->ccsrbar_base + MPC8544_PCI_REGS_OFFSET);\n\n    qemu_fdt_add_subnode(fdt, pci);\n\n    qemu_fdt_setprop_cell(fdt, pci, \"cell-index\", 0);\n\n    qemu_fdt_setprop_string(fdt, pci, \"compatible\", \"fsl,mpc8540-pci\");\n\n    qemu_fdt_setprop_string(fdt, pci, \"device_type\", \"pci\");\n\n    qemu_fdt_setprop_cells(fdt, pci, \"interrupt-map-mask\", 0xf800, 0x0,\n\n                           0x0, 0x7);\n\n    pci_map = pci_map_create(fdt, qemu_fdt_get_phandle(fdt, mpic),\n\n                             params->pci_first_slot, params->pci_nr_slots,\n\n                             &len);\n\n    qemu_fdt_setprop(fdt, pci, \"interrupt-map\", pci_map, len);\n\n    qemu_fdt_setprop_phandle(fdt, pci, \"interrupt-parent\", mpic);\n\n    qemu_fdt_setprop_cells(fdt, pci, \"interrupts\", 24, 2);\n\n    qemu_fdt_setprop_cells(fdt, pci, \"bus-range\", 0, 255);\n\n    for (i = 0; i < 14; i++) {\n\n        pci_ranges[i] = cpu_to_be32(pci_ranges[i]);\n\n    }\n\n    qemu_fdt_setprop_cell(fdt, pci, \"fsl,msi\", msi_ph);\n\n    qemu_fdt_setprop(fdt, pci, \"ranges\", pci_ranges, sizeof(pci_ranges));\n\n    qemu_fdt_setprop_cells(fdt, pci, \"reg\",\n\n                           (params->ccsrbar_base + MPC8544_PCI_REGS_OFFSET) >> 32,\n\n                           (params->ccsrbar_base + MPC8544_PCI_REGS_OFFSET),\n\n                           0, 0x1000);\n\n    qemu_fdt_setprop_cell(fdt, pci, \"clock-frequency\", 66666666);\n\n    qemu_fdt_setprop_cell(fdt, pci, \"#interrupt-cells\", 1);\n\n    qemu_fdt_setprop_cell(fdt, pci, \"#size-cells\", 2);\n\n    qemu_fdt_setprop_cell(fdt, pci, \"#address-cells\", 3);\n\n    qemu_fdt_setprop_string(fdt, \"/aliases\", \"pci0\", pci);\n\n\n\n    if (params->has_mpc8xxx_gpio) {\n\n        create_dt_mpc8xxx_gpio(fdt, soc, mpic);\n\n    }\n\n\n\n    if (params->has_platform_bus) {\n\n        platform_bus_create_devtree(params, fdt, mpic);\n\n    }\n\n\n\n    params->fixup_devtree(params, fdt);\n\n\n\n    if (toplevel_compat) {\n\n        qemu_fdt_setprop(fdt, \"/\", \"compatible\", toplevel_compat,\n\n                         strlen(toplevel_compat) + 1);\n\n    }\n\n\n\ndone:\n\n    if (!dry_run) {\n\n        qemu_fdt_dumpdtb(fdt, fdt_size);\n\n        cpu_physical_memory_write(addr, fdt, fdt_size);\n\n    }\n\n    ret = fdt_size;\n\n\n\nout:\n\n    g_free(pci_map);\n\n\n\n    return ret;\n\n}", "idx": 25559}
{"project": "qemu", "commit_id": "3e831b40e015ba34dfb55ff11f767001839425ff", "target": 1, "func": "pvscsi_on_cmd_setup_rings(PVSCSIState *s)\n\n{\n\n    PVSCSICmdDescSetupRings *rc =\n\n        (PVSCSICmdDescSetupRings *) s->curr_cmd_data;\n\n\n\n    trace_pvscsi_on_cmd_arrived(\"PVSCSI_CMD_SETUP_RINGS\");\n\n\n\n    pvscsi_dbg_dump_tx_rings_config(rc);\n\n    pvscsi_ring_init_data(&s->rings, rc);\n\n    s->rings_info_valid = TRUE;\n\n    return PVSCSI_COMMAND_PROCESSING_SUCCEEDED;\n\n}\n", "idx": 25560}
{"project": "qemu", "commit_id": "636a30a890c50f734c90ee929e16492fbc6c73e3", "target": 1, "func": "static int parse_add_fd(QemuOpts *opts, void *opaque)\n\n{\n\n    int fd, dupfd, flags;\n\n    int64_t fdset_id;\n\n    const char *fd_opaque = NULL;\n\n\n\n    fd = qemu_opt_get_number(opts, \"fd\", -1);\n\n    fdset_id = qemu_opt_get_number(opts, \"set\", -1);\n\n    fd_opaque = qemu_opt_get(opts, \"opaque\");\n\n\n\n    if (fd < 0) {\n\n        qerror_report(ERROR_CLASS_GENERIC_ERROR,\n\n                      \"fd option is required and must be non-negative\");\n\n        return -1;\n\n    }\n\n\n\n    if (fd <= STDERR_FILENO) {\n\n        qerror_report(ERROR_CLASS_GENERIC_ERROR,\n\n                      \"fd cannot be a standard I/O stream\");\n\n        return -1;\n\n    }\n\n\n\n    /*\n\n     * All fds inherited across exec() necessarily have FD_CLOEXEC\n\n     * clear, while qemu sets FD_CLOEXEC on all other fds used internally.\n\n     */\n\n    flags = fcntl(fd, F_GETFD);\n\n    if (flags == -1 || (flags & FD_CLOEXEC)) {\n\n        qerror_report(ERROR_CLASS_GENERIC_ERROR,\n\n                      \"fd is not valid or already in use\");\n\n        return -1;\n\n    }\n\n\n\n    if (fdset_id < 0) {\n\n        qerror_report(ERROR_CLASS_GENERIC_ERROR,\n\n                      \"set option is required and must be non-negative\");\n\n        return -1;\n\n    }\n\n\n\n#ifdef F_DUPFD_CLOEXEC\n\n    dupfd = fcntl(fd, F_DUPFD_CLOEXEC, 0);\n\n#else\n\n    dupfd = dup(fd);\n\n    if (dupfd != -1) {\n\n        qemu_set_cloexec(dupfd);\n\n    }\n\n#endif\n\n    if (dupfd == -1) {\n\n        qerror_report(ERROR_CLASS_GENERIC_ERROR,\n\n                      \"Error duplicating fd: %s\", strerror(errno));\n\n        return -1;\n\n    }\n\n\n\n    /* add the duplicate fd, and optionally the opaque string, to the fd set */\n\n    monitor_fdset_add_fd(dupfd, true, fdset_id, fd_opaque ? true : false,\n\n                         fd_opaque, NULL);\n\n\n\n    return 0;\n\n}\n", "idx": 25562}
{"project": "qemu", "commit_id": "854e67fea6a6f181163a5467fc9ba04de8d181bb", "target": 1, "func": "void hmp_info_local_apic(Monitor *mon, const QDict *qdict)\n\n{\n\n    x86_cpu_dump_local_apic_state(mon_get_cpu(), (FILE *)mon, monitor_fprintf,\n\n                                  CPU_DUMP_FPU);\n\n}\n", "idx": 25565}
{"project": "qemu", "commit_id": "b8b08266bd58d26e9c6b529ab4130c13eaed3406", "target": 0, "func": "void monitor_vprintf(Monitor *mon, const char *fmt, va_list ap)\n\n{\n\n    if (!mon)\n\n        return;\n\n\n\n    if (mon->mc && !mon->mc->print_enabled) {\n\n        qemu_error_new(QERR_UNDEFINED_ERROR);\n\n    } else {\n\n        char buf[4096];\n\n        vsnprintf(buf, sizeof(buf), fmt, ap);\n\n        monitor_puts(mon, buf);\n\n    }\n\n}\n", "idx": 25567}
{"project": "qemu", "commit_id": "80db0e7822962554c91bef05d784c898e8ab1c3c", "target": 0, "func": "static void piix4_acpi_system_hot_add_init(MemoryRegion *parent,\n\n                                           PCIBus *bus, PIIX4PMState *s)\n\n{\n\n    memory_region_init_io(&s->io_gpe, OBJECT(s), &piix4_gpe_ops, s,\n\n                          \"acpi-gpe0\", GPE_LEN);\n\n    memory_region_add_subregion(parent, GPE_BASE, &s->io_gpe);\n\n\n\n    acpi_pcihp_init(OBJECT(s), &s->acpi_pci_hotplug, bus, parent,\n\n                    s->use_acpi_pci_hotplug);\n\n\n\n    s->cpu_hotplug_legacy = true;\n\n    object_property_add_bool(OBJECT(s), \"cpu-hotplug-legacy\",\n\n                             piix4_get_cpu_hotplug_legacy,\n\n                             piix4_set_cpu_hotplug_legacy,\n\n                             NULL);\n\n    legacy_acpi_cpu_hotplug_init(parent, OBJECT(s), &s->gpe_cpu,\n\n                                 PIIX4_CPU_HOTPLUG_IO_BASE);\n\n\n\n    if (s->acpi_memory_hotplug.is_enabled) {\n\n        acpi_memory_hotplug_init(parent, OBJECT(s), &s->acpi_memory_hotplug);\n\n    }\n\n}\n", "idx": 25568}
{"project": "qemu", "commit_id": "1c275925bfbbc2de84a8f0e09d1dd70bbefb6da3", "target": 0, "func": "long do_sigreturn(CPUX86State *env)\n\n{\n\n    struct sigframe *frame;\n\n    abi_ulong frame_addr = env->regs[R_ESP] - 8;\n\n    target_sigset_t target_set;\n\n    sigset_t set;\n\n    int eax, i;\n\n\n\n#if defined(DEBUG_SIGNAL)\n\n    fprintf(stderr, \"do_sigreturn\\n\");\n\n#endif\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))\n\n        goto badframe;\n\n    /* set blocked signals */\n\n    if (__get_user(target_set.sig[0], &frame->sc.oldmask))\n\n        goto badframe;\n\n    for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n        if (__get_user(target_set.sig[i], &frame->extramask[i - 1]))\n\n            goto badframe;\n\n    }\n\n\n\n    target_to_host_sigset_internal(&set, &target_set);\n\n    sigprocmask(SIG_SETMASK, &set, NULL);\n\n\n\n    /* restore registers */\n\n    if (restore_sigcontext(env, &frame->sc, &eax))\n\n        goto badframe;\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return eax;\n\n\n\nbadframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n", "idx": 25569}
{"project": "qemu", "commit_id": "90e496386fe7fd32c189561f846b7913f95b8cf4", "target": 0, "func": "static inline int fp_reg_hi_offset(int regno)\n\n{\n\n    return offsetof(CPUARMState, vfp.regs[regno * 2 + 1]);\n\n}\n", "idx": 25570}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "static void qstring_destroy_obj(QObject *obj)\n\n{\n\n    QString *qs;\n\n\n\n    assert(obj != NULL);\n\n    qs = qobject_to_qstring(obj);\n\n    g_free(qs->string);\n\n    g_free(qs);\n\n}\n", "idx": 25571}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static ssize_t vc_sendv_compat(VLANClientState *vc, const struct iovec *iov,\n\n                               int iovcnt)\n\n{\n\n    uint8_t buffer[4096];\n\n    size_t offset = 0;\n\n    int i;\n\n\n\n    for (i = 0; i < iovcnt; i++) {\n\n        size_t len;\n\n\n\n        len = MIN(sizeof(buffer) - offset, iov[i].iov_len);\n\n        memcpy(buffer + offset, iov[i].iov_base, len);\n\n        offset += len;\n\n    }\n\n\n\n    vc->receive(vc->opaque, buffer, offset);\n\n\n\n    return offset;\n\n}\n", "idx": 25572}
{"project": "qemu", "commit_id": "13b9414b5798539e2dbb87a570d96184fe21edf4", "target": 0, "func": "void do_blockdev_backup(BlockdevBackup *backup, BlockJobTxn *txn, Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *target_bs;\n\n    Error *local_err = NULL;\n\n    AioContext *aio_context;\n\n\n\n    if (!backup->has_speed) {\n\n        backup->speed = 0;\n\n    }\n\n    if (!backup->has_on_source_error) {\n\n        backup->on_source_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n    if (!backup->has_on_target_error) {\n\n        backup->on_target_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n    if (!backup->has_job_id) {\n\n        backup->job_id = NULL;\n\n    }\n\n\n\n    bs = qmp_get_root_bs(backup->device, errp);\n\n    if (!bs) {\n\n        return;\n\n    }\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n\n\n    target_bs = bdrv_lookup_bs(backup->target, backup->target, errp);\n\n    if (!target_bs) {\n\n        goto out;\n\n    }\n\n\n\n    if (bdrv_get_aio_context(target_bs) != aio_context) {\n\n        if (!bdrv_has_blk(target_bs)) {\n\n            /* The target BDS is not attached, we can safely move it to another\n\n             * AioContext. */\n\n            bdrv_set_aio_context(target_bs, aio_context);\n\n        } else {\n\n            error_setg(errp, \"Target is attached to a different thread from \"\n\n                             \"source.\");\n\n            goto out;\n\n        }\n\n    }\n\n    backup_start(backup->job_id, bs, target_bs, backup->speed, backup->sync,\n\n                 NULL, backup->on_source_error, backup->on_target_error,\n\n                 block_job_cb, bs, txn, &local_err);\n\n    if (local_err != NULL) {\n\n        error_propagate(errp, local_err);\n\n    }\n\nout:\n\n    aio_context_release(aio_context);\n\n}\n", "idx": 25573}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "bool aio_pending(AioContext *ctx)\n\n{\n\n    AioHandler *node;\n\n    bool result = false;\n\n\n\n    /*\n\n     * We have to walk very carefully in case aio_set_fd_handler is\n\n     * called while we're walking.\n\n     */\n\n    qemu_lockcnt_inc(&ctx->list_lock);\n\n    QLIST_FOREACH_RCU(node, &ctx->aio_handlers, node) {\n\n        if (node->pfd.revents && node->io_notify) {\n\n            result = true;\n\n            break;\n\n        }\n\n\n\n        if ((node->pfd.revents & G_IO_IN) && node->io_read) {\n\n            result = true;\n\n            break;\n\n        }\n\n        if ((node->pfd.revents & G_IO_OUT) && node->io_write) {\n\n            result = true;\n\n            break;\n\n        }\n\n    }\n\n\n\n    qemu_lockcnt_dec(&ctx->list_lock);\n\n    return result;\n\n}\n", "idx": 25574}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void input_visitor_test_add(const char *testpath,\n\n                                   TestInputVisitorData *data,\n\n                                   void (*test_func)(TestInputVisitorData *data, const void *user_data))\n\n{\n\n    g_test_add(testpath, TestInputVisitorData, data, NULL, test_func,\n\n               visitor_input_teardown);\n\n}\n", "idx": 25575}
{"project": "qemu", "commit_id": "7466bc49107fbd84336ba680f860d5eadd6def13", "target": 0, "func": "void qemu_spice_display_init(DisplayState *ds)\n\n{\n\n    assert(sdpy.ds == NULL);\n\n    sdpy.ds = ds;\n\n    sdpy.bufsize = (16 * 1024 * 1024);\n\n    sdpy.buf = qemu_malloc(sdpy.bufsize);\n\n    pthread_mutex_init(&sdpy.lock, NULL);\n\n    register_displaychangelistener(ds, &display_listener);\n\n\n\n    sdpy.qxl.base.sif = &dpy_interface.base;\n\n    qemu_spice_add_interface(&sdpy.qxl.base);\n\n    assert(sdpy.worker);\n\n\n\n    qemu_add_vm_change_state_handler(qemu_spice_vm_change_state_handler, &sdpy);\n\n    qemu_spice_create_host_memslot(&sdpy);\n\n    qemu_spice_create_host_primary(&sdpy);\n\n}\n", "idx": 25576}
{"project": "qemu", "commit_id": "e1f7b4812eab992de46c98b3726745afb042a7f0", "target": 0, "func": "static size_t get_request_size(VirtQueue *vq)\n\n{\n\n    unsigned int in, out;\n\n\n\n    virtqueue_get_avail_bytes(vq, &in, &out);\n\n    return in;\n\n}\n", "idx": 25578}
{"project": "qemu", "commit_id": "ee76a09fc72cfbfab2bb5529320ef7e460adffd8", "target": 0, "func": "static void spapr_populate_pa_features(PowerPCCPU *cpu, void *fdt, int offset,\n\n                                       bool legacy_guest)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    uint8_t pa_features_206[] = { 6, 0,\n\n        0xf6, 0x1f, 0xc7, 0x00, 0x80, 0xc0 };\n\n    uint8_t pa_features_207[] = { 24, 0,\n\n        0xf6, 0x1f, 0xc7, 0xc0, 0x80, 0xf0,\n\n        0x80, 0x00, 0x00, 0x00, 0x00, 0x00,\n\n        0x00, 0x00, 0x00, 0x00, 0x80, 0x00,\n\n        0x80, 0x00, 0x80, 0x00, 0x00, 0x00 };\n\n    uint8_t pa_features_300[] = { 66, 0,\n\n        /* 0: MMU|FPU|SLB|RUN|DABR|NX, 1: fri[nzpm]|DABRX|SPRG3|SLB0|PP110 */\n\n        /* 2: VPM|DS205|PPR|DS202|DS206, 3: LSD|URG, SSO, 5: LE|CFAR|EB|LSQ */\n\n        0xf6, 0x1f, 0xc7, 0xc0, 0x80, 0xf0, /* 0 - 5 */\n\n        /* 6: DS207 */\n\n        0x80, 0x00, 0x00, 0x00, 0x00, 0x00, /* 6 - 11 */\n\n        /* 16: Vector */\n\n        0x00, 0x00, 0x00, 0x00, 0x80, 0x00, /* 12 - 17 */\n\n        /* 18: Vec. Scalar, 20: Vec. XOR, 22: HTM */\n\n        0x80, 0x00, 0x80, 0x00, 0x00, 0x00, /* 18 - 23 */\n\n        /* 24: Ext. Dec, 26: 64 bit ftrs, 28: PM ftrs */\n\n        0x80, 0x00, 0x80, 0x00, 0x80, 0x00, /* 24 - 29 */\n\n        /* 30: MMR, 32: LE atomic, 34: EBB + ext EBB */\n\n        0x80, 0x00, 0x80, 0x00, 0xC0, 0x00, /* 30 - 35 */\n\n        /* 36: SPR SO, 38: Copy/Paste, 40: Radix MMU */\n\n        0x80, 0x00, 0x80, 0x00, 0x80, 0x00, /* 36 - 41 */\n\n        /* 42: PM, 44: PC RA, 46: SC vec'd */\n\n        0x80, 0x00, 0x80, 0x00, 0x80, 0x00, /* 42 - 47 */\n\n        /* 48: SIMD, 50: QP BFP, 52: String */\n\n        0x80, 0x00, 0x80, 0x00, 0x80, 0x00, /* 48 - 53 */\n\n        /* 54: DecFP, 56: DecI, 58: SHA */\n\n        0x80, 0x00, 0x80, 0x00, 0x80, 0x00, /* 54 - 59 */\n\n        /* 60: NM atomic, 62: RNG */\n\n        0x80, 0x00, 0x80, 0x00, 0x00, 0x00, /* 60 - 65 */\n\n    };\n\n    uint8_t *pa_features = NULL;\n\n    size_t pa_size;\n\n\n\n    if (ppc_check_compat(cpu, CPU_POWERPC_LOGICAL_2_06, 0, cpu->compat_pvr)) {\n\n        pa_features = pa_features_206;\n\n        pa_size = sizeof(pa_features_206);\n\n    }\n\n    if (ppc_check_compat(cpu, CPU_POWERPC_LOGICAL_2_07, 0, cpu->compat_pvr)) {\n\n        pa_features = pa_features_207;\n\n        pa_size = sizeof(pa_features_207);\n\n    }\n\n    if (ppc_check_compat(cpu, CPU_POWERPC_LOGICAL_3_00, 0, cpu->compat_pvr)) {\n\n        pa_features = pa_features_300;\n\n        pa_size = sizeof(pa_features_300);\n\n    }\n\n    if (!pa_features) {\n\n        return;\n\n    }\n\n\n\n    if (env->ci_large_pages) {\n\n        /*\n\n         * Note: we keep CI large pages off by default because a 64K capable\n\n         * guest provisioned with large pages might otherwise try to map a qemu\n\n         * framebuffer (or other kind of memory mapped PCI BAR) using 64K pages\n\n         * even if that qemu runs on a 4k host.\n\n         * We dd this bit back here if we are confident this is not an issue\n\n         */\n\n        pa_features[3] |= 0x20;\n\n    }\n\n    if (kvmppc_has_cap_htm() && pa_size > 24) {\n\n        pa_features[24] |= 0x80;    /* Transactional memory support */\n\n    }\n\n    if (legacy_guest && pa_size > 40) {\n\n        /* Workaround for broken kernels that attempt (guest) radix\n\n         * mode when they can't handle it, if they see the radix bit set\n\n         * in pa-features. So hide it from them. */\n\n        pa_features[40 + 2] &= ~0x80; /* Radix MMU */\n\n    }\n\n\n\n    _FDT((fdt_setprop(fdt, offset, \"ibm,pa-features\", pa_features, pa_size)));\n\n}\n", "idx": 25579}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void do_quit(int argc, const char **argv)\n\n{\n\n    exit(0);\n\n}\n", "idx": 25580}
{"project": "qemu", "commit_id": "c83c66c3b58893a4dc056e272822beb88fe9ec7f", "target": 0, "func": "void *block_job_create(const BlockJobType *job_type, BlockDriverState *bs,\n\n                       BlockDriverCompletionFunc *cb, void *opaque,\n\n                       Error **errp)\n\n{\n\n    BlockJob *job;\n\n\n\n    if (bs->job || bdrv_in_use(bs)) {\n\n        error_set(errp, QERR_DEVICE_IN_USE, bdrv_get_device_name(bs));\n\n        return NULL;\n\n    }\n\n    bdrv_set_in_use(bs, 1);\n\n\n\n    job = g_malloc0(job_type->instance_size);\n\n    job->job_type      = job_type;\n\n    job->bs            = bs;\n\n    job->cb            = cb;\n\n    job->opaque        = opaque;\n\n    bs->job = job;\n\n    return job;\n\n}\n", "idx": 25581}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_is_snapshot(BlockDriverState *bs)\n\n{\n\n    return !!(bs->open_flags & BDRV_O_SNAPSHOT);\n\n}\n", "idx": 25582}
{"project": "qemu", "commit_id": "63ffb564dca94f8bda01ed6d209784104630a4d2", "target": 0, "func": "static void pc_init1(ram_addr_t ram_size,\n\n                     const char *boot_device,\n\n                     const char *kernel_filename,\n\n                     const char *kernel_cmdline,\n\n                     const char *initrd_filename,\n\n                     const char *cpu_model,\n\n                     int pci_enabled,\n\n                     int kvmclock_enabled)\n\n{\n\n    int i;\n\n    ram_addr_t below_4g_mem_size, above_4g_mem_size;\n\n    PCIBus *pci_bus;\n\n    PCII440FXState *i440fx_state;\n\n    int piix3_devfn = -1;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq *isa_irq;\n\n    qemu_irq *i8259;\n\n    qemu_irq *cmos_s3;\n\n    qemu_irq *smi_irq;\n\n    IsaIrqState *isa_irq_state;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    FDCtrl *floppy_controller;\n\n    BusState *idebus[MAX_IDE_BUS];\n\n    ISADevice *rtc_state;\n\n\n\n    pc_cpus_init(cpu_model);\n\n\n\n    if (kvmclock_enabled) {\n\n        kvmclock_create();\n\n    }\n\n\n\n    /* allocate ram and load rom/bios */\n\n    pc_memory_init(ram_size, kernel_filename, kernel_cmdline, initrd_filename,\n\n                   &below_4g_mem_size, &above_4g_mem_size);\n\n\n\n    cpu_irq = pc_allocate_cpu_irq();\n\n    i8259 = i8259_init(cpu_irq[0]);\n\n    isa_irq_state = qemu_mallocz(sizeof(*isa_irq_state));\n\n    isa_irq_state->i8259 = i8259;\n\n    if (pci_enabled) {\n\n        ioapic_init(isa_irq_state);\n\n    }\n\n    isa_irq = qemu_allocate_irqs(isa_irq_handler, isa_irq_state, 24);\n\n\n\n    if (pci_enabled) {\n\n        pci_bus = i440fx_init(&i440fx_state, &piix3_devfn, isa_irq, ram_size);\n\n    } else {\n\n        pci_bus = NULL;\n\n        i440fx_state = NULL;\n\n        isa_bus_new(NULL);\n\n    }\n\n    isa_bus_irqs(isa_irq);\n\n\n\n    pc_register_ferr_irq(isa_reserve_irq(13));\n\n\n\n    pc_vga_init(pci_enabled? pci_bus: NULL);\n\n\n\n    /* init basic PC hardware */\n\n    pc_basic_device_init(isa_irq, &floppy_controller, &rtc_state);\n\n\n\n    for(i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!pci_enabled || (nd->model && strcmp(nd->model, \"ne2k_isa\") == 0))\n\n            pc_init_ne2k_isa(nd);\n\n        else\n\n            pci_nic_init_nofail(nd, \"e1000\", NULL);\n\n    }\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        hd[i] = drive_get(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        PCIDevice *dev;\n\n        dev = pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        idebus[0] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        idebus[1] = qdev_get_child_bus(&dev->qdev, \"ide.1\");\n\n    } else {\n\n        for(i = 0; i < MAX_IDE_BUS; i++) {\n\n            ISADevice *dev;\n\n            dev = isa_ide_init(ide_iobase[i], ide_iobase2[i], ide_irq[i],\n\n                               hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);\n\n            idebus[i] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        }\n\n    }\n\n\n\n    audio_init(isa_irq, pci_enabled ? pci_bus : NULL);\n\n\n\n    pc_cmos_init(below_4g_mem_size, above_4g_mem_size, boot_device,\n\n                 idebus[0], idebus[1], floppy_controller, rtc_state);\n\n\n\n    if (pci_enabled && usb_enabled) {\n\n        usb_uhci_piix3_init(pci_bus, piix3_devfn + 2);\n\n    }\n\n\n\n    if (pci_enabled && acpi_enabled) {\n\n        uint8_t *eeprom_buf = qemu_mallocz(8 * 256); /* XXX: make this persistent */\n\n        i2c_bus *smbus;\n\n\n\n        cmos_s3 = qemu_allocate_irqs(pc_cmos_set_s3_resume, rtc_state, 1);\n\n        smi_irq = qemu_allocate_irqs(pc_acpi_smi_interrupt, first_cpu, 1);\n\n        /* TODO: Populate SPD eeprom data.  */\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100,\n\n                              isa_reserve_irq(9), *cmos_s3, *smi_irq,\n\n                              kvm_enabled());\n\n        for (i = 0; i < 8; i++) {\n\n            DeviceState *eeprom;\n\n            eeprom = qdev_create((BusState *)smbus, \"smbus-eeprom\");\n\n            qdev_prop_set_uint8(eeprom, \"address\", 0x50 + i);\n\n            qdev_prop_set_ptr(eeprom, \"data\", eeprom_buf + (i * 256));\n\n            qdev_init_nofail(eeprom);\n\n        }\n\n    }\n\n\n\n    if (i440fx_state) {\n\n        i440fx_init_memory_mappings(i440fx_state);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pc_pci_device_init(pci_bus);\n\n    }\n\n}\n", "idx": 25583}
{"project": "qemu", "commit_id": "12f86b5b3e1bdf75e0a467d771c16cc42f3a1f1a", "target": 0, "func": "static void nvdimm_init_fit_buffer(NvdimmFitBuffer *fit_buf)\n\n{\n\n    qemu_mutex_init(&fit_buf->lock);\n\n    fit_buf->fit = g_array_new(false, true /* clear */, 1);\n\n}\n", "idx": 25584}
{"project": "qemu", "commit_id": "b7bad50ae81efeb180609eeecdb086ebc7536ed7", "target": 0, "func": "static void cryptodev_builtin_cleanup(\n\n             CryptoDevBackend *backend,\n\n             Error **errp)\n\n{\n\n    CryptoDevBackendBuiltin *builtin =\n\n                      CRYPTODEV_BACKEND_BUILTIN(backend);\n\n    size_t i;\n\n    int queues = backend->conf.peers.queues;\n\n    CryptoDevBackendClient *cc;\n\n\n\n    for (i = 0; i < MAX_NUM_SESSIONS; i++) {\n\n        if (builtin->sessions[i] != NULL) {\n\n            cryptodev_builtin_sym_close_session(\n\n                    backend, i, 0, errp);\n\n        }\n\n    }\n\n\n\n    assert(queues == 1);\n\n\n\n    for (i = 0; i < queues; i++) {\n\n        cc = backend->conf.peers.ccs[i];\n\n        if (cc) {\n\n            cryptodev_backend_free_client(cc);\n\n            backend->conf.peers.ccs[i] = NULL;\n\n        }\n\n    }\n\n\n\n    cryptodev_backend_set_ready(backend, false);\n\n}\n", "idx": 25585}
{"project": "qemu", "commit_id": "ce137829e7e58fcdc5ba63b5e256f972e80be438", "target": 1, "func": "static void clear_commits(BDRVVVFATState* s)\n\n{\n\n    int i;\n\nDLOG(fprintf(stderr, \"clear_commits (%d commits)\\n\", s->commits.next));\n\n    for (i = 0; i < s->commits.next; i++) {\n\n\tcommit_t* commit = array_get(&(s->commits), i);\n\n\tassert(commit->path || commit->action == ACTION_WRITEOUT);\n\n\tif (commit->action != ACTION_WRITEOUT) {\n\n\t    assert(commit->path);\n\n\t    free(commit->path);\n\n\t} else\n\n\t    assert(commit->path == NULL);\n\n    }\n\n    s->commits.next = 0;\n\n}\n", "idx": 25586}
{"project": "qemu", "commit_id": "019c2ab8623daee210df8b1085a33b1e83c9ee11", "target": 1, "func": "static void test_cipher(const void *opaque)\n\n{\n\n    const QCryptoCipherTestData *data = opaque;\n\n\n\n    QCryptoCipher *cipher;\n\n    Error *err = NULL;\n\n    uint8_t *key, *iv, *ciphertext, *plaintext, *outtext;\n\n    size_t nkey, niv, nciphertext, nplaintext;\n\n    char *outtexthex;\n\n\n\n    g_test_message(\"foo\");\n\n    nkey = unhex_string(data->key, &key);\n\n    niv = unhex_string(data->iv, &iv);\n\n    nciphertext = unhex_string(data->ciphertext, &ciphertext);\n\n    nplaintext = unhex_string(data->plaintext, &plaintext);\n\n\n\n    g_assert(nciphertext == nplaintext);\n\n\n\n    outtext = g_new0(uint8_t, nciphertext);\n\n\n\n    cipher = qcrypto_cipher_new(\n\n        data->alg, data->mode,\n\n        key, nkey,\n\n        &err);\n\n    g_assert(cipher != NULL);\n\n    g_assert(err == NULL);\n\n\n\n\n\n    if (iv) {\n\n        g_assert(qcrypto_cipher_setiv(cipher,\n\n                                      iv, niv,\n\n                                      &err) == 0);\n\n        g_assert(err == NULL);\n\n    }\n\n    g_assert(qcrypto_cipher_encrypt(cipher,\n\n                                    plaintext,\n\n                                    outtext,\n\n                                    nplaintext,\n\n                                    &err) == 0);\n\n    g_assert(err == NULL);\n\n\n\n    outtexthex = hex_string(outtext, nciphertext);\n\n\n\n    g_assert_cmpstr(outtexthex, ==, data->ciphertext);\n\n\n\n    g_free(outtext);\n\n    g_free(outtexthex);\n\n    g_free(key);\n\n    g_free(iv);\n\n    g_free(ciphertext);\n\n    g_free(plaintext);\n\n    qcrypto_cipher_free(cipher);\n\n}\n", "idx": 25587}
{"project": "qemu", "commit_id": "7e09797c299712cafa7bc05dd57c1b13afcc6039", "target": 1, "func": "static uint64_t pmsav5_insn_ap_read(CPUARMState *env, const ARMCPRegInfo *ri)\n\n{\n\n    return simple_mpu_ap_bits(env->cp15.c5_insn);\n\n}\n", "idx": 25588}
{"project": "qemu", "commit_id": "a9db86b223030bd40bdd81b160788196bc95fe6f", "target": 1, "func": "static int quorum_open(BlockDriverState *bs, QDict *options, int flags,\n\n                       Error **errp)\n\n{\n\n    BDRVQuorumState *s = bs->opaque;\n\n    Error *local_err = NULL;\n\n    QemuOpts *opts;\n\n    bool *opened;\n\n    QDict *sub = NULL;\n\n    QList *list = NULL;\n\n    const QListEntry *lentry;\n\n    int i;\n\n    int ret = 0;\n\n\n\n    qdict_flatten(options);\n\n    qdict_extract_subqdict(options, &sub, \"children.\");\n\n    qdict_array_split(sub, &list);\n\n\n\n    if (qdict_size(sub)) {\n\n        error_setg(&local_err, \"Invalid option children.%s\",\n\n                   qdict_first(sub)->key);\n\n        ret = -EINVAL;\n\n        goto exit;\n\n    }\n\n\n\n    /* count how many different children are present */\n\n    s->num_children = qlist_size(list);\n\n    if (s->num_children < 2) {\n\n        error_setg(&local_err,\n\n                   \"Number of provided children must be greater than 1\");\n\n        ret = -EINVAL;\n\n        goto exit;\n\n    }\n\n\n\n    opts = qemu_opts_create(&quorum_runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (local_err) {\n\n        ret = -EINVAL;\n\n        goto exit;\n\n    }\n\n\n\n    s->threshold = qemu_opt_get_number(opts, QUORUM_OPT_VOTE_THRESHOLD, 0);\n\n\n\n    /* and validate it against s->num_children */\n\n    ret = quorum_valid_threshold(s->threshold, s->num_children, &local_err);\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n\n\n    /* is the driver in blkverify mode */\n\n    if (qemu_opt_get_bool(opts, QUORUM_OPT_BLKVERIFY, false) &&\n\n        s->num_children == 2 && s->threshold == 2) {\n\n        s->is_blkverify = true;\n\n    } else if (qemu_opt_get_bool(opts, QUORUM_OPT_BLKVERIFY, false)) {\n\n        fprintf(stderr, \"blkverify mode is set by setting blkverify=on \"\n\n                \"and using two files with vote_threshold=2\\n\");\n\n    }\n\n\n\n    s->rewrite_corrupted = qemu_opt_get_bool(opts, QUORUM_OPT_REWRITE, false);\n\n    if (s->rewrite_corrupted && s->is_blkverify) {\n\n        error_setg(&local_err,\n\n                   \"rewrite-corrupted=on cannot be used with blkverify=on\");\n\n        ret = -EINVAL;\n\n        goto exit;\n\n    }\n\n\n\n    /* allocate the children BlockDriverState array */\n\n    s->bs = g_new0(BlockDriverState *, s->num_children);\n\n    opened = g_new0(bool, s->num_children);\n\n\n\n    for (i = 0, lentry = qlist_first(list); lentry;\n\n         lentry = qlist_next(lentry), i++) {\n\n        QDict *d;\n\n        QString *string;\n\n\n\n        switch (qobject_type(lentry->value))\n\n        {\n\n            /* List of options */\n\n            case QTYPE_QDICT:\n\n                d = qobject_to_qdict(lentry->value);\n\n                QINCREF(d);\n\n                ret = bdrv_open(&s->bs[i], NULL, NULL, d, flags, NULL,\n\n                                &local_err);\n\n                break;\n\n\n\n            /* QMP reference */\n\n            case QTYPE_QSTRING:\n\n                string = qobject_to_qstring(lentry->value);\n\n                ret = bdrv_open(&s->bs[i], NULL, qstring_get_str(string), NULL,\n\n                                flags, NULL, &local_err);\n\n                break;\n\n\n\n            default:\n\n                error_setg(&local_err, \"Specification of child block device %i \"\n\n                           \"is invalid\", i);\n\n                ret = -EINVAL;\n\n        }\n\n\n\n        if (ret < 0) {\n\n            goto close_exit;\n\n        }\n\n        opened[i] = true;\n\n    }\n\n\n\n    g_free(opened);\n\n    goto exit;\n\n\n\nclose_exit:\n\n    /* cleanup on error */\n\n    for (i = 0; i < s->num_children; i++) {\n\n        if (!opened[i]) {\n\n            continue;\n\n        }\n\n        bdrv_unref(s->bs[i]);\n\n    }\n\n    g_free(s->bs);\n\n    g_free(opened);\n\nexit:\n\n    /* propagate error */\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n    }\n\n    QDECREF(list);\n\n    QDECREF(sub);\n\n    return ret;\n\n}\n", "idx": 25591}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void virtual_css_bridge_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n\n\n    k->init = virtual_css_bridge_init;\n\n    dc->no_user = 1;\n\n}\n", "idx": 25597}
{"project": "qemu", "commit_id": "5f8b6491f20732e0a31e64bbf75b62def579e044", "target": 1, "func": "static void tracked_request_begin(BdrvTrackedRequest *req,\n\n                                  BlockDriverState *bs,\n\n                                  int64_t sector_num,\n\n                                  int nb_sectors, bool is_write)\n\n{\n\n    *req = (BdrvTrackedRequest){\n\n        .bs = bs,\n\n        .sector_num = sector_num,\n\n        .nb_sectors = nb_sectors,\n\n        .is_write = is_write,\n\n\n    };\n\n\n\n    qemu_co_queue_init(&req->wait_queue);\n\n\n\n    QLIST_INSERT_HEAD(&bs->tracked_requests, req, list);\n\n}", "idx": 25599}
{"project": "qemu", "commit_id": "c527e0afcd7d719abc3a5ca5e4c8ac2fe48b999f", "target": 1, "func": "vmxnet3_dump_rx_descr(struct Vmxnet3_RxDesc *descr)\n\n{\n\n    VMW_PKPRN(\"RX DESCR: addr %\" PRIx64 \", len: %d, gen: %d, rsvd: %d, \"\n\n              \"dtype: %d, ext1: %d, btype: %d\",\n\n              le64_to_cpu(descr->addr), descr->len, descr->gen,\n\n              descr->rsvd, descr->dtype, descr->ext1, descr->btype);\n\n}\n", "idx": 25600}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int usb_bt_handle_data(USBDevice *dev, USBPacket *p)\n\n{\n\n    struct USBBtState *s = (struct USBBtState *) dev->opaque;\n\n    int ret = 0;\n\n\n\n    if (!s->config)\n\n        goto fail;\n\n\n\n    switch (p->pid) {\n\n    case USB_TOKEN_IN:\n\n        switch (p->devep & 0xf) {\n\n        case USB_EVT_EP:\n\n            ret = usb_bt_fifo_dequeue(&s->evt, p);\n\n            break;\n\n\n\n        case USB_ACL_EP:\n\n            ret = usb_bt_fifo_dequeue(&s->acl, p);\n\n            break;\n\n\n\n        case USB_SCO_EP:\n\n            ret = usb_bt_fifo_dequeue(&s->sco, p);\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    case USB_TOKEN_OUT:\n\n        switch (p->devep & 0xf) {\n\n        case USB_ACL_EP:\n\n            usb_bt_fifo_out_enqueue(s, &s->outacl, s->hci->acl_send,\n\n                            usb_bt_hci_acl_complete, p->data, p->len);\n\n            break;\n\n\n\n        case USB_SCO_EP:\n\n            usb_bt_fifo_out_enqueue(s, &s->outsco, s->hci->sco_send,\n\n                            usb_bt_hci_sco_complete, p->data, p->len);\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    default:\n\n    fail:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 25602}
{"project": "qemu", "commit_id": "33f461e0c5d8efa21ef7e746be561fc57a1df106", "target": 1, "func": "static int coroutine_fn bdrv_aligned_preadv(BlockDriverState *bs,\n\n    BdrvTrackedRequest *req, int64_t offset, unsigned int bytes,\n\n    int64_t align, QEMUIOVector *qiov, int flags)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    int ret;\n\n\n\n    int64_t sector_num = offset >> BDRV_SECTOR_BITS;\n\n    unsigned int nb_sectors = bytes >> BDRV_SECTOR_BITS;\n\n\n\n    assert((offset & (BDRV_SECTOR_SIZE - 1)) == 0);\n\n    assert((bytes & (BDRV_SECTOR_SIZE - 1)) == 0);\n\n\n\n    /* Handle Copy on Read and associated serialisation */\n\n    if (flags & BDRV_REQ_COPY_ON_READ) {\n\n        /* If we touch the same cluster it counts as an overlap.  This\n\n         * guarantees that allocating writes will be serialized and not race\n\n         * with each other for the same cluster.  For example, in copy-on-read\n\n         * it ensures that the CoR read and write operations are atomic and\n\n         * guest writes cannot interleave between them. */\n\n        mark_request_serialising(req, bdrv_get_cluster_size(bs));\n\n    }\n\n\n\n    wait_serialising_requests(req);\n\n\n\n    if (flags & BDRV_REQ_COPY_ON_READ) {\n\n        int pnum;\n\n\n\n        ret = bdrv_is_allocated(bs, sector_num, nb_sectors, &pnum);\n\n        if (ret < 0) {\n\n            goto out;\n\n        }\n\n\n\n        if (!ret || pnum != nb_sectors) {\n\n            ret = bdrv_co_do_copy_on_readv(bs, sector_num, nb_sectors, qiov);\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    /* Forward the request to the BlockDriver */\n\n    if (!(bs->zero_beyond_eof && bs->growable)) {\n\n        ret = drv->bdrv_co_readv(bs, sector_num, nb_sectors, qiov);\n\n    } else {\n\n        /* Read zeros after EOF of growable BDSes */\n\n        int64_t len, total_sectors, max_nb_sectors;\n\n\n\n        len = bdrv_getlength(bs);\n\n        if (len < 0) {\n\n            ret = len;\n\n            goto out;\n\n        }\n\n\n\n        total_sectors = DIV_ROUND_UP(len, BDRV_SECTOR_SIZE);\n\n        max_nb_sectors = ROUND_UP(MAX(0, total_sectors - sector_num),\n\n                                  align >> BDRV_SECTOR_BITS);\n\n        if (max_nb_sectors > 0) {\n\n            ret = drv->bdrv_co_readv(bs, sector_num,\n\n                                     MIN(nb_sectors, max_nb_sectors), qiov);\n\n        } else {\n\n            ret = 0;\n\n        }\n\n\n\n        /* Reading beyond end of file is supposed to produce zeroes */\n\n        if (ret == 0 && total_sectors < sector_num + nb_sectors) {\n\n            uint64_t offset = MAX(0, total_sectors - sector_num);\n\n            uint64_t bytes = (sector_num + nb_sectors - offset) *\n\n                              BDRV_SECTOR_SIZE;\n\n            qemu_iovec_memset(qiov, offset * BDRV_SECTOR_SIZE, 0, bytes);\n\n        }\n\n    }\n\n\n\nout:\n\n    return ret;\n\n}\n", "idx": 25606}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static uint16_t nvme_identify_ns(NvmeCtrl *n, NvmeIdentify *c)\n\n{\n\n    NvmeNamespace *ns;\n\n    uint32_t nsid = le32_to_cpu(c->nsid);\n\n    uint64_t prp1 = le64_to_cpu(c->prp1);\n\n    uint64_t prp2 = le64_to_cpu(c->prp2);\n\n\n\n    if (nsid == 0 || nsid > n->num_namespaces) {\n\n        return NVME_INVALID_NSID | NVME_DNR;\n\n    }\n\n\n\n    ns = &n->namespaces[nsid - 1];\n\n    return nvme_dma_read_prp(n, (uint8_t *)&ns->id_ns, sizeof(ns->id_ns),\n\n        prp1, prp2);\n\n}\n", "idx": 25607}
{"project": "qemu", "commit_id": "6905b93447a42e606dfd126b90f75f4cd3c6fe94", "target": 1, "func": "void dpy_gfx_replace_surface(QemuConsole *con,\n                             DisplaySurface *surface)\n{\n    DisplayState *s = con->ds;\n    DisplaySurface *old_surface = con->surface;\n    DisplayChangeListener *dcl;\n    con->surface = surface;\n    QLIST_FOREACH(dcl, &s->listeners, next) {\n        if (con != (dcl->con ? dcl->con : active_console)) {\n            continue;\n        }\n        if (dcl->ops->dpy_gfx_switch) {\n            dcl->ops->dpy_gfx_switch(dcl, surface);\n        }\n    }\n    qemu_free_displaysurface(old_surface);\n}", "idx": 25608}
{"project": "qemu", "commit_id": "cb58a6d3611b2d0ff4ed29bb6b659c95a23cb2d5", "target": 1, "func": "static void patch_call(VAPICROMState *s, X86CPU *cpu, target_ulong ip,\n\n                       uint32_t target)\n\n{\n\n    uint32_t offset;\n\n\n\n    offset = cpu_to_le32(target - ip - 5);\n\n    patch_byte(cpu, ip, 0xe8); /* call near */\n\n    cpu_memory_rw_debug(CPU(cpu), ip + 1, (void *)&offset, sizeof(offset), 1);\n\n}\n", "idx": 25611}
{"project": "qemu", "commit_id": "db486cc334aafd3dbdaf107388e37fc3d6d3e171", "target": 1, "func": "static void range_merge(Range *range1, Range *range2)\n\n{\n\n    if (range1->end < range2->end) {\n\n        range1->end = range2->end;\n\n    }\n\n    if (range1->begin > range2->begin) {\n\n        range1->begin = range2->begin;\n\n    }\n\n}\n", "idx": 25614}
{"project": "qemu", "commit_id": "57d0a39d98b0d0e4712e736084667bcb5aed3474", "target": 0, "func": "static int ppc_hash64_pte_prot(CPUPPCState *env,\n\n                               ppc_slb_t *slb, ppc_hash_pte64_t pte)\n\n{\n\n    unsigned pp, key;\n\n    /* Some pp bit combinations have undefined behaviour, so default\n\n     * to no access in those cases */\n\n    int prot = 0;\n\n\n\n    key = !!(msr_pr ? (slb->vsid & SLB_VSID_KP)\n\n             : (slb->vsid & SLB_VSID_KS));\n\n    pp = (pte.pte1 & HPTE64_R_PP) | ((pte.pte1 & HPTE64_R_PP0) >> 61);\n\n\n\n    if (key == 0) {\n\n        switch (pp) {\n\n        case 0x0:\n\n        case 0x1:\n\n        case 0x2:\n\n            prot = PAGE_READ | PAGE_WRITE;\n\n            break;\n\n\n\n        case 0x3:\n\n        case 0x6:\n\n            prot = PAGE_READ;\n\n            break;\n\n        }\n\n    } else {\n\n        switch (pp) {\n\n        case 0x0:\n\n        case 0x6:\n\n            prot = 0;\n\n            break;\n\n\n\n        case 0x1:\n\n        case 0x3:\n\n            prot = PAGE_READ;\n\n            break;\n\n\n\n        case 0x2:\n\n            prot = PAGE_READ | PAGE_WRITE;\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* No execute if either noexec or guarded bits set */\n\n    if (!(pte.pte1 & HPTE64_R_N) || (pte.pte1 & HPTE64_R_G)) {\n\n        prot |= PAGE_EXEC;\n\n    }\n\n\n\n    return prot;\n\n}\n", "idx": 25617}
{"project": "qemu", "commit_id": "46c5874e9cd752ed8ded31af03472edd8fc3efc1", "target": 0, "func": "static void rtas_ibm_read_slot_reset_state2(PowerPCCPU *cpu,\n\n                                            sPAPREnvironment *spapr,\n\n                                            uint32_t token, uint32_t nargs,\n\n                                            target_ulong args, uint32_t nret,\n\n                                            target_ulong rets)\n\n{\n\n    sPAPRPHBState *sphb;\n\n    sPAPRPHBClass *spc;\n\n    uint64_t buid;\n\n    int state, ret;\n\n\n\n    if ((nargs != 3) || (nret != 4 && nret != 5)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    buid = ((uint64_t)rtas_ld(args, 1) << 32) | rtas_ld(args, 2);\n\n    sphb = find_phb(spapr, buid);\n\n    if (!sphb) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb);\n\n    if (!spc->eeh_get_state) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    ret = spc->eeh_get_state(sphb, &state);\n\n    rtas_st(rets, 0, ret);\n\n    if (ret != RTAS_OUT_SUCCESS) {\n\n        return;\n\n    }\n\n\n\n    rtas_st(rets, 1, state);\n\n    rtas_st(rets, 2, RTAS_EEH_SUPPORT);\n\n    rtas_st(rets, 3, RTAS_EEH_PE_UNAVAIL_INFO);\n\n    if (nret >= 5) {\n\n        rtas_st(rets, 4, RTAS_EEH_PE_RECOVER_INFO);\n\n    }\n\n    return;\n\n\n\nparam_error_exit:\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n", "idx": 25619}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_sysctl_write8(void *opaque, target_phys_addr_t addr,\n\n                uint32_t value)\n\n{\n\n    struct omap_sysctl_s *s = (struct omap_sysctl_s *) opaque;\n\n    int pad_offset, byte_offset;\n\n    int prev_value;\n\n\n\n    switch (addr) {\n\n    case 0x030 ... 0x140:\t/* CONTROL_PADCONF - only used in the POP */\n\n        pad_offset = (addr - 0x30) >> 2;\n\n        byte_offset = (addr - 0x30) & (4 - 1);\n\n\n\n        prev_value = s->padconf[pad_offset];\n\n        prev_value &= ~(0xff << (byte_offset * 8));\n\n        prev_value |= ((value & 0x1f1f1f1f) << (byte_offset * 8)) & 0x1f1f1f1f;\n\n        s->padconf[pad_offset] = prev_value;\n\n        break;\n\n\n\n    default:\n\n        OMAP_BAD_REG(addr);\n\n        break;\n\n    }\n\n}\n", "idx": 25620}
{"project": "qemu", "commit_id": "95b1416ae93106923f733941e52dfe55c4318643", "target": 0, "func": "static void l2tpv3_update_fd_handler(NetL2TPV3State *s)\n\n{\n\n    qemu_set_fd_handler2(s->fd,\n\n                         s->read_poll ? l2tpv3_can_send : NULL,\n\n                         s->read_poll ? net_l2tpv3_send     : NULL,\n\n                         s->write_poll ? l2tpv3_writable : NULL,\n\n                         s);\n\n}\n", "idx": 25621}
{"project": "qemu", "commit_id": "2ffcb18de0bc02ad8a836ec955584c02b70e0e24", "target": 0, "func": "int do_netdev_del(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    const char *id = qdict_get_str(qdict, \"id\");\n\n    VLANClientState *vc;\n\n\n\n    vc = qemu_find_netdev(id);\n\n    if (!vc || vc->info->type == NET_CLIENT_TYPE_NIC) {\n\n        qerror_report(QERR_DEVICE_NOT_FOUND, id);\n\n        return -1;\n\n    }\n\n    if (vc->peer) {\n\n        qerror_report(QERR_DEVICE_IN_USE, id);\n\n        return -1;\n\n    }\n\n    qemu_del_vlan_client(vc);\n\n    qemu_opts_del(qemu_opts_find(&qemu_netdev_opts, id));\n\n    return 0;\n\n}\n", "idx": 25622}
{"project": "qemu", "commit_id": "4fc9af53d88c0a2a810704a06cb39a7182982e4e", "target": 0, "func": "void bdrv_set_boot_sector(BlockDriverState *bs, const uint8_t *data, int size)\n\n{\n\n    bs->boot_sector_enabled = 1;\n\n    if (size > 512)\n\n        size = 512;\n\n    memcpy(bs->boot_sector_data, data, size);\n\n    memset(bs->boot_sector_data + size, 0, 512 - size);\n\n}\n", "idx": 25623}
{"project": "qemu", "commit_id": "59b060be184aff59cfa101c937c8139e66f452f2", "target": 0, "func": "int qcrypto_pbkdf2(QCryptoHashAlgorithm hash G_GNUC_UNUSED,\n\n                   const uint8_t *key G_GNUC_UNUSED,\n\n                   size_t nkey G_GNUC_UNUSED,\n\n                   const uint8_t *salt G_GNUC_UNUSED,\n\n                   size_t nsalt G_GNUC_UNUSED,\n\n                   unsigned int iterations G_GNUC_UNUSED,\n\n                   uint8_t *out G_GNUC_UNUSED,\n\n                   size_t nout G_GNUC_UNUSED,\n\n                   Error **errp)\n\n{\n\n    error_setg_errno(errp, ENOSYS,\n\n                     \"No crypto library supporting PBKDF in this build\");\n\n    return -1;\n\n}\n", "idx": 25624}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static void qmp_chardev_open_socket(Chardev *chr,\n\n                                    ChardevBackend *backend,\n\n                                    bool *be_opened,\n\n                                    Error **errp)\n\n{\n\n    SocketChardev *s = SOCKET_CHARDEV(chr);\n\n    ChardevSocket *sock = backend->u.socket.data;\n\n    SocketAddress *addr = sock->addr;\n\n    bool do_nodelay     = sock->has_nodelay ? sock->nodelay : false;\n\n    bool is_listen      = sock->has_server  ? sock->server  : true;\n\n    bool is_telnet      = sock->has_telnet  ? sock->telnet  : false;\n\n    bool is_tn3270      = sock->has_tn3270  ? sock->tn3270  : false;\n\n    bool is_waitconnect = sock->has_wait    ? sock->wait    : false;\n\n    int64_t reconnect   = sock->has_reconnect ? sock->reconnect : 0;\n\n    QIOChannelSocket *sioc = NULL;\n\n\n\n    s->is_listen = is_listen;\n\n    s->is_telnet = is_telnet;\n\n    s->is_tn3270 = is_tn3270;\n\n    s->do_nodelay = do_nodelay;\n\n    if (sock->tls_creds) {\n\n        Object *creds;\n\n        creds = object_resolve_path_component(\n\n            object_get_objects_root(), sock->tls_creds);\n\n        if (!creds) {\n\n            error_setg(errp, \"No TLS credentials with id '%s'\",\n\n                       sock->tls_creds);\n\n            goto error;\n\n        }\n\n        s->tls_creds = (QCryptoTLSCreds *)\n\n            object_dynamic_cast(creds,\n\n                                TYPE_QCRYPTO_TLS_CREDS);\n\n        if (!s->tls_creds) {\n\n            error_setg(errp, \"Object with id '%s' is not TLS credentials\",\n\n                       sock->tls_creds);\n\n            goto error;\n\n        }\n\n        object_ref(OBJECT(s->tls_creds));\n\n        if (is_listen) {\n\n            if (s->tls_creds->endpoint != QCRYPTO_TLS_CREDS_ENDPOINT_SERVER) {\n\n                error_setg(errp, \"%s\",\n\n                           \"Expected TLS credentials for server endpoint\");\n\n                goto error;\n\n            }\n\n        } else {\n\n            if (s->tls_creds->endpoint != QCRYPTO_TLS_CREDS_ENDPOINT_CLIENT) {\n\n                error_setg(errp, \"%s\",\n\n                           \"Expected TLS credentials for client endpoint\");\n\n                goto error;\n\n            }\n\n        }\n\n    }\n\n\n\n    s->addr = QAPI_CLONE(SocketAddress, sock->addr);\n\n\n\n    qemu_chr_set_feature(chr, QEMU_CHAR_FEATURE_RECONNECTABLE);\n\n    /* TODO SOCKET_ADDRESS_FD where fd has AF_UNIX */\n\n    if (addr->type == SOCKET_ADDRESS_KIND_UNIX) {\n\n        qemu_chr_set_feature(chr, QEMU_CHAR_FEATURE_FD_PASS);\n\n    }\n\n\n\n    /* be isn't opened until we get a connection */\n\n    *be_opened = false;\n\n\n\n    update_disconnected_filename(s);\n\n\n\n    if (is_listen) {\n\n        if (is_telnet || is_tn3270) {\n\n            s->do_telnetopt = 1;\n\n        }\n\n    } else if (reconnect > 0) {\n\n        s->reconnect_time = reconnect;\n\n    }\n\n\n\n    if (s->reconnect_time) {\n\n        sioc = qio_channel_socket_new();\n\n        tcp_chr_set_client_ioc_name(chr, sioc);\n\n        qio_channel_socket_connect_async(sioc, s->addr,\n\n                                         qemu_chr_socket_connected,\n\n                                         chr, NULL);\n\n    } else {\n\n        if (s->is_listen) {\n\n            char *name;\n\n            sioc = qio_channel_socket_new();\n\n\n\n            name = g_strdup_printf(\"chardev-tcp-listener-%s\", chr->label);\n\n            qio_channel_set_name(QIO_CHANNEL(sioc), name);\n\n            g_free(name);\n\n\n\n            if (qio_channel_socket_listen_sync(sioc, s->addr, errp) < 0) {\n\n                goto error;\n\n            }\n\n\n\n            qapi_free_SocketAddress(s->addr);\n\n            s->addr = socket_local_address(sioc->fd, errp);\n\n            update_disconnected_filename(s);\n\n\n\n            s->listen_ioc = sioc;\n\n            if (is_waitconnect &&\n\n                qemu_chr_wait_connected(chr, errp) < 0) {\n\n                return;\n\n            }\n\n            if (!s->ioc) {\n\n                s->listen_tag = qio_channel_add_watch(\n\n                    QIO_CHANNEL(s->listen_ioc), G_IO_IN,\n\n                    tcp_chr_accept, chr, NULL);\n\n            }\n\n        } else if (qemu_chr_wait_connected(chr, errp) < 0) {\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    return;\n\n\n\nerror:\n\n    if (sioc) {\n\n        object_unref(OBJECT(sioc));\n\n    }\n\n}\n", "idx": 25625}
{"project": "qemu", "commit_id": "7848c8d19f8556666df25044bbd5d8b29439c368", "target": 0, "func": "void helper_sysexit(CPUX86State *env, int dflag)\n\n{\n\n    int cpl;\n\n\n\n    cpl = env->hflags & HF_CPL_MASK;\n\n    if (env->sysenter_cs == 0 || cpl != 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, 0);\n\n    }\n\n    cpu_x86_set_cpl(env, 3);\n\n#ifdef TARGET_X86_64\n\n    if (dflag == 2) {\n\n        cpu_x86_load_seg_cache(env, R_CS, ((env->sysenter_cs + 32) & 0xfffc) |\n\n                               3, 0, 0xffffffff,\n\n                               DESC_G_MASK | DESC_B_MASK | DESC_P_MASK |\n\n                               DESC_S_MASK | (3 << DESC_DPL_SHIFT) |\n\n                               DESC_CS_MASK | DESC_R_MASK | DESC_A_MASK |\n\n                               DESC_L_MASK);\n\n        cpu_x86_load_seg_cache(env, R_SS, ((env->sysenter_cs + 40) & 0xfffc) |\n\n                               3, 0, 0xffffffff,\n\n                               DESC_G_MASK | DESC_B_MASK | DESC_P_MASK |\n\n                               DESC_S_MASK | (3 << DESC_DPL_SHIFT) |\n\n                               DESC_W_MASK | DESC_A_MASK);\n\n    } else\n\n#endif\n\n    {\n\n        cpu_x86_load_seg_cache(env, R_CS, ((env->sysenter_cs + 16) & 0xfffc) |\n\n                               3, 0, 0xffffffff,\n\n                               DESC_G_MASK | DESC_B_MASK | DESC_P_MASK |\n\n                               DESC_S_MASK | (3 << DESC_DPL_SHIFT) |\n\n                               DESC_CS_MASK | DESC_R_MASK | DESC_A_MASK);\n\n        cpu_x86_load_seg_cache(env, R_SS, ((env->sysenter_cs + 24) & 0xfffc) |\n\n                               3, 0, 0xffffffff,\n\n                               DESC_G_MASK | DESC_B_MASK | DESC_P_MASK |\n\n                               DESC_S_MASK | (3 << DESC_DPL_SHIFT) |\n\n                               DESC_W_MASK | DESC_A_MASK);\n\n    }\n\n    env->regs[R_ESP] = env->regs[R_ECX];\n\n    env->eip = env->regs[R_EDX];\n\n}\n", "idx": 25626}
{"project": "qemu", "commit_id": "a9899996c8bc8eb7686f64207ef2ce1137dd125b", "target": 0, "func": "static int slirp_guestfwd(SlirpState *s, const char *config_str,\n\n                          int legacy_format)\n\n{\n\n    struct in_addr server = { .s_addr = 0 };\n\n    struct GuestFwd *fwd;\n\n    const char *p;\n\n    char buf[128];\n\n    char *end;\n\n    int port;\n\n\n\n    p = config_str;\n\n    if (legacy_format) {\n\n        if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n            goto fail_syntax;\n\n        }\n\n    } else {\n\n        if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n            goto fail_syntax;\n\n        }\n\n        if (strcmp(buf, \"tcp\") && buf[0] != '\\0') {\n\n            goto fail_syntax;\n\n        }\n\n        if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n            goto fail_syntax;\n\n        }\n\n        if (buf[0] != '\\0' && !inet_aton(buf, &server)) {\n\n            goto fail_syntax;\n\n        }\n\n        if (get_str_sep(buf, sizeof(buf), &p, '-') < 0) {\n\n            goto fail_syntax;\n\n        }\n\n    }\n\n    port = strtol(buf, &end, 10);\n\n    if (*end != '\\0' || port < 1 || port > 65535) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    fwd = qemu_malloc(sizeof(struct GuestFwd));\n\n    snprintf(buf, sizeof(buf), \"guestfwd.tcp:%d\", port);\n\n    fwd->hd = qemu_chr_open(buf, p, NULL);\n\n    if (!fwd->hd) {\n\n        error_report(\"could not open guest forwarding device '%s'\", buf);\n\n        qemu_free(fwd);\n\n        return -1;\n\n    }\n\n\n\n    if (slirp_add_exec(s->slirp, 3, fwd->hd, &server, port) < 0) {\n\n        error_report(\"conflicting/invalid host:port in guest forwarding \"\n\n                     \"rule '%s'\", config_str);\n\n        qemu_free(fwd);\n\n        return -1;\n\n    }\n\n    fwd->server = server;\n\n    fwd->port = port;\n\n    fwd->slirp = s->slirp;\n\n\n\n    qemu_chr_add_handlers(fwd->hd, guestfwd_can_read, guestfwd_read,\n\n                          NULL, fwd);\n\n    return 0;\n\n\n\n fail_syntax:\n\n    error_report(\"invalid guest forwarding rule '%s'\", config_str);\n\n    return -1;\n\n}\n", "idx": 25627}
{"project": "qemu", "commit_id": "2174f12bdeb3974141784e14bbb7ad8c53178cd9", "target": 0, "func": "BlockAIOCB *laio_submit(BlockDriverState *bs, LinuxAioState *s, int fd,\n\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n        BlockCompletionFunc *cb, void *opaque, int type)\n\n{\n\n    struct qemu_laiocb *laiocb;\n\n    struct iocb *iocbs;\n\n    off_t offset = sector_num * 512;\n\n\n\n    laiocb = qemu_aio_get(&laio_aiocb_info, bs, cb, opaque);\n\n    laiocb->nbytes = nb_sectors * 512;\n\n    laiocb->ctx = s;\n\n    laiocb->ret = -EINPROGRESS;\n\n    laiocb->is_read = (type == QEMU_AIO_READ);\n\n    laiocb->qiov = qiov;\n\n\n\n    iocbs = &laiocb->iocb;\n\n\n\n    switch (type) {\n\n    case QEMU_AIO_WRITE:\n\n        io_prep_pwritev(iocbs, fd, qiov->iov, qiov->niov, offset);\n\n\tbreak;\n\n    case QEMU_AIO_READ:\n\n        io_prep_preadv(iocbs, fd, qiov->iov, qiov->niov, offset);\n\n\tbreak;\n\n    /* Currently Linux kernel does not support other operations */\n\n    default:\n\n        fprintf(stderr, \"%s: invalid AIO request type 0x%x.\\n\",\n\n                        __func__, type);\n\n        goto out_free_aiocb;\n\n    }\n\n    io_set_eventfd(&laiocb->iocb, event_notifier_get_fd(&s->e));\n\n\n\n    QSIMPLEQ_INSERT_TAIL(&s->io_q.pending, laiocb, next);\n\n    s->io_q.n++;\n\n    if (!s->io_q.blocked &&\n\n        (!s->io_q.plugged || s->io_q.n >= MAX_QUEUED_IO)) {\n\n        ioq_submit(s);\n\n    }\n\n    return &laiocb->common;\n\n\n\nout_free_aiocb:\n\n    qemu_aio_unref(laiocb);\n\n    return NULL;\n\n}\n", "idx": 25628}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "static void v9fs_rename(void *opaque)\n\n{\n\n    int32_t fid;\n\n    ssize_t err = 0;\n\n    size_t offset = 7;\n\n    V9fsString name;\n\n    int32_t newdirfid;\n\n    V9fsFidState *fidp;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    pdu_unmarshal(pdu, offset, \"dds\", &fid, &newdirfid, &name);\n\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n    BUG_ON(fidp->fid_type != P9_FID_NONE);\n\n    /* if fs driver is not path based, return EOPNOTSUPP */\n\n    if (!(pdu->s->ctx.export_flags & V9FS_PATHNAME_FSCONTEXT)) {\n\n        err = -EOPNOTSUPP;\n\n        goto out;\n\n    }\n\n    v9fs_path_write_lock(s);\n\n    err = v9fs_complete_rename(pdu, fidp, newdirfid, &name);\n\n    v9fs_path_unlock(s);\n\n    if (!err) {\n\n        err = offset;\n\n    }\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    complete_pdu(s, pdu, err);\n\n    v9fs_string_free(&name);\n\n}\n", "idx": 25630}
{"project": "qemu", "commit_id": "550830f9351291c585c963204ad9127998b1c1ce", "target": 0, "func": "static int coroutine_fn cow_co_is_allocated(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, int *num_same)\n\n{\n\n    int64_t bitnum = sector_num + sizeof(struct cow_header_v2) * 8;\n\n    uint64_t offset = (bitnum / 8) & -BDRV_SECTOR_SIZE;\n\n    bool first = true;\n\n    int changed = 0, same = 0;\n\n\n\n    do {\n\n        int ret;\n\n        uint8_t bitmap[BDRV_SECTOR_SIZE];\n\n\n\n        bitnum &= BITS_PER_BITMAP_SECTOR - 1;\n\n        int sector_bits = MIN(nb_sectors, BITS_PER_BITMAP_SECTOR - bitnum);\n\n\n\n        ret = bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap));\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        if (first) {\n\n            changed = cow_test_bit(bitnum, bitmap);\n\n            first = false;\n\n        }\n\n\n\n        same += cow_find_streak(bitmap, changed, bitnum, nb_sectors);\n\n\n\n        bitnum += sector_bits;\n\n        nb_sectors -= sector_bits;\n\n        offset += BDRV_SECTOR_SIZE;\n\n    } while (nb_sectors);\n\n\n\n    *num_same = same;\n\n    return changed;\n\n}\n", "idx": 25631}
{"project": "qemu", "commit_id": "ccea25f1c7cd3f0b12d878a5294620f5478729f8", "target": 0, "func": "void os_setup_post(void)\n\n{\n\n    int fd = 0;\n\n\n\n    if (daemonize) {\n\n        uint8_t status = 0;\n\n        ssize_t len;\n\n\n\n    again1:\n\n        len = write(daemon_pipe, &status, 1);\n\n        if (len == -1 && (errno == EINTR)) {\n\n            goto again1;\n\n        }\n\n        if (len != 1) {\n\n            exit(1);\n\n        }\n\n        if (chdir(\"/\")) {\n\n            perror(\"not able to chdir to /\");\n\n            exit(1);\n\n        }\n\n        TFR(fd = qemu_open(\"/dev/null\", O_RDWR));\n\n        if (fd == -1) {\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    change_root();\n\n    change_process_uid();\n\n\n\n    if (daemonize) {\n\n        dup2(fd, 0);\n\n        dup2(fd, 1);\n\n        dup2(fd, 2);\n\n\n\n        close(fd);\n\n    }\n\n}\n", "idx": 25632}
{"project": "qemu", "commit_id": "47405ab642101c8ea0472ae434ab4bd2bc1fa41f", "target": 0, "func": "void cpu_loop(CPUS390XState *env)\n\n{\n\n    CPUState *cs = CPU(s390_env_get_cpu(env));\n\n    int trapnr, n, sig;\n\n    target_siginfo_t info;\n\n    target_ulong addr;\n\n\n\n    while (1) {\n\n        cpu_exec_start(cs);\n\n        trapnr = cpu_s390x_exec(cs);\n\n        cpu_exec_end(cs);\n\n        switch (trapnr) {\n\n        case EXCP_INTERRUPT:\n\n            /* Just indicate that signals should be handled asap.  */\n\n            break;\n\n\n\n        case EXCP_SVC:\n\n            n = env->int_svc_code;\n\n            if (!n) {\n\n                /* syscalls > 255 */\n\n                n = env->regs[1];\n\n            }\n\n            env->psw.addr += env->int_svc_ilen;\n\n            env->regs[2] = do_syscall(env, n, env->regs[2], env->regs[3],\n\n                                      env->regs[4], env->regs[5],\n\n                                      env->regs[6], env->regs[7], 0, 0);\n\n            break;\n\n\n\n        case EXCP_DEBUG:\n\n            sig = gdb_handlesig(cs, TARGET_SIGTRAP);\n\n            if (sig) {\n\n                n = TARGET_TRAP_BRKPT;\n\n                goto do_signal_pc;\n\n            }\n\n            break;\n\n        case EXCP_PGM:\n\n            n = env->int_pgm_code;\n\n            switch (n) {\n\n            case PGM_OPERATION:\n\n            case PGM_PRIVILEGED:\n\n                sig = TARGET_SIGILL;\n\n                n = TARGET_ILL_ILLOPC;\n\n                goto do_signal_pc;\n\n            case PGM_PROTECTION:\n\n            case PGM_ADDRESSING:\n\n                sig = TARGET_SIGSEGV;\n\n                /* XXX: check env->error_code */\n\n                n = TARGET_SEGV_MAPERR;\n\n                addr = env->__excp_addr;\n\n                goto do_signal;\n\n            case PGM_EXECUTE:\n\n            case PGM_SPECIFICATION:\n\n            case PGM_SPECIAL_OP:\n\n            case PGM_OPERAND:\n\n            do_sigill_opn:\n\n                sig = TARGET_SIGILL;\n\n                n = TARGET_ILL_ILLOPN;\n\n                goto do_signal_pc;\n\n\n\n            case PGM_FIXPT_OVERFLOW:\n\n                sig = TARGET_SIGFPE;\n\n                n = TARGET_FPE_INTOVF;\n\n                goto do_signal_pc;\n\n            case PGM_FIXPT_DIVIDE:\n\n                sig = TARGET_SIGFPE;\n\n                n = TARGET_FPE_INTDIV;\n\n                goto do_signal_pc;\n\n\n\n            case PGM_DATA:\n\n                n = (env->fpc >> 8) & 0xff;\n\n                if (n == 0xff) {\n\n                    /* compare-and-trap */\n\n                    goto do_sigill_opn;\n\n                } else {\n\n                    /* An IEEE exception, simulated or otherwise.  */\n\n                    if (n & 0x80) {\n\n                        n = TARGET_FPE_FLTINV;\n\n                    } else if (n & 0x40) {\n\n                        n = TARGET_FPE_FLTDIV;\n\n                    } else if (n & 0x20) {\n\n                        n = TARGET_FPE_FLTOVF;\n\n                    } else if (n & 0x10) {\n\n                        n = TARGET_FPE_FLTUND;\n\n                    } else if (n & 0x08) {\n\n                        n = TARGET_FPE_FLTRES;\n\n                    } else {\n\n                        /* ??? Quantum exception; BFP, DFP error.  */\n\n                        goto do_sigill_opn;\n\n                    }\n\n                    sig = TARGET_SIGFPE;\n\n                    goto do_signal_pc;\n\n                }\n\n\n\n            default:\n\n                fprintf(stderr, \"Unhandled program exception: %#x\\n\", n);\n\n                cpu_dump_state(cs, stderr, fprintf, 0);\n\n                exit(EXIT_FAILURE);\n\n            }\n\n            break;\n\n\n\n        do_signal_pc:\n\n            addr = env->psw.addr;\n\n        do_signal:\n\n            info.si_signo = sig;\n\n            info.si_errno = 0;\n\n            info.si_code = n;\n\n            info._sifields._sigfault._addr = addr;\n\n            queue_signal(env, info.si_signo, &info);\n\n            break;\n\n\n\n        default:\n\n            fprintf(stderr, \"Unhandled trap: 0x%x\\n\", trapnr);\n\n            cpu_dump_state(cs, stderr, fprintf, 0);\n\n            exit(EXIT_FAILURE);\n\n        }\n\n        process_pending_signals (env);\n\n    }\n\n}\n", "idx": 25633}
{"project": "qemu", "commit_id": "64607d088132abdb25bf30d93e97d0c8df7b364c", "target": 0, "func": "Object *object_resolve_path_component(Object *parent, const gchar *part)\n\n{\n\n    ObjectProperty *prop = object_property_find(parent, part, NULL);\n\n    if (prop == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    if (object_property_is_link(prop)) {\n\n        LinkProperty *lprop = prop->opaque;\n\n        return *lprop->child;\n\n    } else if (object_property_is_child(prop)) {\n\n        return prop->opaque;\n\n    } else {\n\n        return NULL;\n\n    }\n\n}\n", "idx": 25634}
{"project": "qemu", "commit_id": "36b15c79aa1bef5fe7543f9f2629b6413720bbfb", "target": 0, "func": "static void *virtio_scsi_load_request(QEMUFile *f, SCSIRequest *sreq)\n\n{\n\n    SCSIBus *bus = sreq->bus;\n\n    VirtIOSCSI *s = container_of(bus, VirtIOSCSI, bus);\n\n    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(s);\n\n    VirtIOSCSIReq *req;\n\n    uint32_t n;\n\n\n\n    req = g_malloc(sizeof(*req));\n\n    qemu_get_be32s(f, &n);\n\n    assert(n < vs->conf.num_queues);\n\n    qemu_get_buffer(f, (unsigned char *)&req->elem, sizeof(req->elem));\n\n    /* TODO: add a way for SCSIBusInfo's load_request to fail,\n\n     * and fail migration instead of asserting here.\n\n     * When we do, we might be able to re-enable NDEBUG below.\n\n     */\n\n#ifdef NDEBUG\n\n#error building with NDEBUG is not supported\n\n#endif\n\n    assert(req->elem.in_num <= ARRAY_SIZE(req->elem.in_sg));\n\n    assert(req->elem.out_num <= ARRAY_SIZE(req->elem.out_sg));\n\n    virtio_scsi_parse_req(s, vs->cmd_vqs[n], req);\n\n\n\n    scsi_req_ref(sreq);\n\n    req->sreq = sreq;\n\n    if (req->sreq->cmd.mode != SCSI_XFER_NONE) {\n\n        int req_mode =\n\n            (req->elem.in_num > 1 ? SCSI_XFER_FROM_DEV : SCSI_XFER_TO_DEV);\n\n\n\n        assert(req->sreq->cmd.mode == req_mode);\n\n    }\n\n    return req;\n\n}\n", "idx": 25635}
{"project": "qemu", "commit_id": "c91e681a558fc21073ffc491b5a022d5f340fa0b", "target": 0, "func": "void qmp_migrate_set_cache_size(int64_t value, Error **errp)\n\n{\n\n    MigrationState *s = migrate_get_current();\n\n\n\n    /* Check for truncation */\n\n    if (value != (size_t)value) {\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                  \"exceeding address space\");\n\n        return;\n\n    }\n\n\n\n    s->xbzrle_cache_size = xbzrle_cache_resize(value);\n\n}\n", "idx": 25636}
{"project": "qemu", "commit_id": "53cb28cbfea038f8ad50132dc8a684e638c7d48b", "target": 0, "func": "static void phys_sections_free(PhysPageMap *map)\n\n{\n\n    while (map->sections_nb > 0) {\n\n        MemoryRegionSection *section = &map->sections[--map->sections_nb];\n\n        phys_section_destroy(section->mr);\n\n    }\n\n    g_free(map->sections);\n\n    g_free(map->nodes);\n\n    g_free(map);\n\n}\n", "idx": 25637}
{"project": "qemu", "commit_id": "cb77d1925ac4d673e19be58aa39fc53c5d2fed10", "target": 1, "func": "static QemuOpts *opts_parse(QemuOptsList *list, const char *params,\n                            int permit_abbrev, bool defaults)\n{\n    const char *firstname;\n    char value[1024], *id = NULL;\n    const char *p;\n    QemuOpts *opts;\n    Error *local_err = NULL;\n    assert(!permit_abbrev || list->implied_opt_name);\n    firstname = permit_abbrev ? list->implied_opt_name : NULL;\n    if (strncmp(params, \"id=\", 3) == 0) {\n        get_opt_value(value, sizeof(value), params+3);\n        id = value;\n    } else if ((p = strstr(params, \",id=\")) != NULL) {\n        get_opt_value(value, sizeof(value), p+4);\n        id = value;\n    }\n    opts = qemu_opts_create(list, id, !defaults, &local_err);\n    if (opts == NULL) {\n        if (error_is_set(&local_err)) {\n            qerror_report_err(local_err);\n            error_free(local_err);\n        }\n        return NULL;\n    }\n    if (opts_do_parse(opts, params, firstname, defaults) != 0) {\n        qemu_opts_del(opts);\n        return NULL;\n    }\n    return opts;\n}", "idx": 25647}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_bool(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    bool *v = pv;\n\n    *v = qemu_get_byte(f);\n\n    return 0;\n\n}\n", "idx": 25648}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static int disas_cp_insn(CPUState *env, DisasContext *s, uint32_t insn)\n\n{\n\n    TCGv tmp, tmp2;\n\n    uint32_t rd = (insn >> 12) & 0xf;\n\n    uint32_t cp = (insn >> 8) & 0xf;\n\n    if (IS_USER(s)) {\n\n        return 1;\n\n    }\n\n\n\n    if (insn & ARM_CP_RW_BIT) {\n\n        if (!env->cp[cp].cp_read)\n\n            return 1;\n\n        gen_set_pc_im(s->pc);\n\n        tmp = new_tmp();\n\n        tmp2 = tcg_const_i32(insn);\n\n        gen_helper_get_cp(tmp, cpu_env, tmp2);\n\n        tcg_temp_free(tmp2);\n\n        store_reg(s, rd, tmp);\n\n    } else {\n\n        if (!env->cp[cp].cp_write)\n\n            return 1;\n\n        gen_set_pc_im(s->pc);\n\n        tmp = load_reg(s, rd);\n\n        tmp2 = tcg_const_i32(insn);\n\n        gen_helper_set_cp(cpu_env, tmp2, tmp);\n\n        tcg_temp_free(tmp2);\n\n        dead_tmp(tmp);\n\n    }\n\n    return 0;\n\n}\n", "idx": 25651}
{"project": "qemu", "commit_id": "1b7f01d966f97b7820f3cdd471461cf0799a93cc", "target": 1, "func": "void qemu_co_rwlock_unlock(CoRwlock *lock)\n{\n    assert(qemu_in_coroutine());\n    if (lock->writer) {\n        lock->writer = false;\n        qemu_co_queue_restart_all(&lock->queue);\n    } else {\n        lock->reader--;\n        assert(lock->reader >= 0);\n        /* Wakeup only one waiting writer */\n        if (!lock->reader) {\n            qemu_co_queue_next(&lock->queue);\n        }\n    }\n}", "idx": 25653}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void do_addzeo (void)\n\n{\n\n    T1 = T0;\n\n    T0 += xer_ca;\n\n    if (likely(!((T1 ^ (-1)) & (T1 ^ T0) & (1 << 31)))) {\n\n        xer_ov = 0;\n\n    } else {\n\n        xer_so = 1;\n\n        xer_ov = 1;\n\n    }\n\n    if (likely(T0 >= T1)) {\n\n        xer_ca = 0;\n\n    } else {\n\n        xer_ca = 1;\n\n    }\n\n}\n", "idx": 25654}
{"project": "qemu", "commit_id": "5f81724d80a1492c73d329242663962139db739b", "target": 1, "func": "void ide_atapi_cmd_reply_end(IDEState *s)\n\n{\n\n    int byte_count_limit, size, ret;\n\n#ifdef DEBUG_IDE_ATAPI\n\n    printf(\"reply: tx_size=%d elem_tx_size=%d index=%d\\n\",\n\n           s->packet_transfer_size,\n\n           s->elementary_transfer_size,\n\n           s->io_buffer_index);\n\n#endif\n\n    if (s->packet_transfer_size <= 0) {\n\n        /* end of transfer */\n\n        ide_atapi_cmd_ok(s);\n\n        ide_set_irq(s->bus);\n\n#ifdef DEBUG_IDE_ATAPI\n\n        printf(\"status=0x%x\\n\", s->status);\n\n#endif\n\n    } else {\n\n        /* see if a new sector must be read */\n\n        if (s->lba != -1 && s->io_buffer_index >= s->cd_sector_size) {\n\n            ret = cd_read_sector(s, s->lba, s->io_buffer, s->cd_sector_size);\n\n            if (ret < 0) {\n\n                ide_atapi_io_error(s, ret);\n\n                return;\n\n            }\n\n            s->lba++;\n\n            s->io_buffer_index = 0;\n\n        }\n\n        if (s->elementary_transfer_size > 0) {\n\n            /* there are some data left to transmit in this elementary\n\n               transfer */\n\n            size = s->cd_sector_size - s->io_buffer_index;\n\n            if (size > s->elementary_transfer_size)\n\n                size = s->elementary_transfer_size;\n\n            s->packet_transfer_size -= size;\n\n            s->elementary_transfer_size -= size;\n\n            s->io_buffer_index += size;\n\n            ide_transfer_start(s, s->io_buffer + s->io_buffer_index - size,\n\n                               size, ide_atapi_cmd_reply_end);\n\n        } else {\n\n            /* a new transfer is needed */\n\n            s->nsector = (s->nsector & ~7) | ATAPI_INT_REASON_IO;\n\n            byte_count_limit = atapi_byte_count_limit(s);\n\n#ifdef DEBUG_IDE_ATAPI\n\n            printf(\"byte_count_limit=%d\\n\", byte_count_limit);\n\n#endif\n\n            size = s->packet_transfer_size;\n\n            if (size > byte_count_limit) {\n\n                /* byte count limit must be even if this case */\n\n                if (byte_count_limit & 1)\n\n                    byte_count_limit--;\n\n                size = byte_count_limit;\n\n            }\n\n            s->lcyl = size;\n\n            s->hcyl = size >> 8;\n\n            s->elementary_transfer_size = size;\n\n            /* we cannot transmit more than one sector at a time */\n\n            if (s->lba != -1) {\n\n                if (size > (s->cd_sector_size - s->io_buffer_index))\n\n                    size = (s->cd_sector_size - s->io_buffer_index);\n\n            }\n\n            s->packet_transfer_size -= size;\n\n            s->elementary_transfer_size -= size;\n\n            s->io_buffer_index += size;\n\n            ide_transfer_start(s, s->io_buffer + s->io_buffer_index - size,\n\n                               size, ide_atapi_cmd_reply_end);\n\n            ide_set_irq(s->bus);\n\n#ifdef DEBUG_IDE_ATAPI\n\n            printf(\"status=0x%x\\n\", s->status);\n\n#endif\n\n        }\n\n    }\n\n}\n", "idx": 25655}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "StrongARMState *sa1110_init(MemoryRegion *sysmem,\n\n                            unsigned int sdram_size, const char *rev)\n\n{\n\n    StrongARMState *s;\n\n    int i;\n\n\n\n    s = g_new0(StrongARMState, 1);\n\n\n\n    if (!rev) {\n\n        rev = \"sa1110-b5\";\n\n    }\n\n\n\n    if (strncmp(rev, \"sa1110\", 6)) {\n\n        error_report(\"Machine requires a SA1110 processor.\");\n\n        exit(1);\n\n    }\n\n\n\n    s->cpu = ARM_CPU(cpu_generic_init(TYPE_ARM_CPU, rev));\n\n\n\n    if (!s->cpu) {\n\n        error_report(\"Unable to find CPU definition\");\n\n        exit(1);\n\n    }\n\n\n\n    memory_region_allocate_system_memory(&s->sdram, NULL, \"strongarm.sdram\",\n\n                                         sdram_size);\n\n    memory_region_add_subregion(sysmem, SA_SDCS0, &s->sdram);\n\n\n\n    s->pic = sysbus_create_varargs(\"strongarm_pic\", 0x90050000,\n\n                    qdev_get_gpio_in(DEVICE(s->cpu), ARM_CPU_IRQ),\n\n                    qdev_get_gpio_in(DEVICE(s->cpu), ARM_CPU_FIQ),\n\n                    NULL);\n\n\n\n    sysbus_create_varargs(\"pxa25x-timer\", 0x90000000,\n\n                    qdev_get_gpio_in(s->pic, SA_PIC_OSTC0),\n\n                    qdev_get_gpio_in(s->pic, SA_PIC_OSTC1),\n\n                    qdev_get_gpio_in(s->pic, SA_PIC_OSTC2),\n\n                    qdev_get_gpio_in(s->pic, SA_PIC_OSTC3),\n\n                    NULL);\n\n\n\n    sysbus_create_simple(TYPE_STRONGARM_RTC, 0x90010000,\n\n                    qdev_get_gpio_in(s->pic, SA_PIC_RTC_ALARM));\n\n\n\n    s->gpio = strongarm_gpio_init(0x90040000, s->pic);\n\n\n\n    s->ppc = sysbus_create_varargs(TYPE_STRONGARM_PPC, 0x90060000, NULL);\n\n\n\n    for (i = 0; sa_serial[i].io_base; i++) {\n\n        DeviceState *dev = qdev_create(NULL, TYPE_STRONGARM_UART);\n\n        qdev_prop_set_chr(dev, \"chardev\", serial_hds[i]);\n\n        qdev_init_nofail(dev);\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0,\n\n                sa_serial[i].io_base);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0,\n\n                qdev_get_gpio_in(s->pic, sa_serial[i].irq));\n\n    }\n\n\n\n    s->ssp = sysbus_create_varargs(TYPE_STRONGARM_SSP, 0x80070000,\n\n                qdev_get_gpio_in(s->pic, SA_PIC_SSP), NULL);\n\n    s->ssp_bus = (SSIBus *)qdev_get_child_bus(s->ssp, \"ssi\");\n\n\n\n    return s;\n\n}\n", "idx": 25661}
{"project": "qemu", "commit_id": "7d61d892327d803ae43d14500601e48031b4632c", "target": 1, "func": "static abi_long do_sendrecvmsg_locked(int fd, struct target_msghdr *msgp,\n\n                                      int flags, int send)\n\n{\n\n    abi_long ret, len;\n\n    struct msghdr msg;\n\n    int count;\n\n    struct iovec *vec;\n\n    abi_ulong target_vec;\n\n\n\n    if (msgp->msg_name) {\n\n        msg.msg_namelen = tswap32(msgp->msg_namelen);\n\n        msg.msg_name = alloca(msg.msg_namelen+1);\n\n        ret = target_to_host_sockaddr(fd, msg.msg_name,\n\n                                      tswapal(msgp->msg_name),\n\n                                      msg.msg_namelen);\n\n        if (ret) {\n\n            goto out2;\n\n        }\n\n    } else {\n\n        msg.msg_name = NULL;\n\n        msg.msg_namelen = 0;\n\n    }\n\n    msg.msg_controllen = 2 * tswapal(msgp->msg_controllen);\n\n    msg.msg_control = alloca(msg.msg_controllen);\n\n    msg.msg_flags = tswap32(msgp->msg_flags);\n\n\n\n    count = tswapal(msgp->msg_iovlen);\n\n    target_vec = tswapal(msgp->msg_iov);\n\n    vec = lock_iovec(send ? VERIFY_READ : VERIFY_WRITE,\n\n                     target_vec, count, send);\n\n    if (vec == NULL) {\n\n        ret = -host_to_target_errno(errno);\n\n        goto out2;\n\n    }\n\n    msg.msg_iovlen = count;\n\n    msg.msg_iov = vec;\n\n\n\n    if (send) {\n\n        if (fd_trans_target_to_host_data(fd)) {\n\n            ret = fd_trans_target_to_host_data(fd)(msg.msg_iov->iov_base,\n\n                                                   msg.msg_iov->iov_len);\n\n        } else {\n\n            ret = target_to_host_cmsg(&msg, msgp);\n\n        }\n\n        if (ret == 0) {\n\n            ret = get_errno(safe_sendmsg(fd, &msg, flags));\n\n        }\n\n    } else {\n\n        ret = get_errno(safe_recvmsg(fd, &msg, flags));\n\n        if (!is_error(ret)) {\n\n            len = ret;\n\n            if (fd_trans_host_to_target_data(fd)) {\n\n                ret = fd_trans_host_to_target_data(fd)(msg.msg_iov->iov_base,\n\n                                                       len);\n\n            } else {\n\n                ret = host_to_target_cmsg(msgp, &msg);\n\n            }\n\n            if (!is_error(ret)) {\n\n                msgp->msg_namelen = tswap32(msg.msg_namelen);\n\n                if (msg.msg_name != NULL) {\n\n                    ret = host_to_target_sockaddr(tswapal(msgp->msg_name),\n\n                                    msg.msg_name, msg.msg_namelen);\n\n                    if (ret) {\n\n                        goto out;\n\n                    }\n\n                }\n\n\n\n                ret = len;\n\n            }\n\n        }\n\n    }\n\n\n\nout:\n\n    unlock_iovec(vec, target_vec, count, !send);\n\nout2:\n\n    return ret;\n\n}\n", "idx": 25663}
{"project": "qemu", "commit_id": "70afb8ff90e9d922ed729e6dbabaff6d67c461aa", "target": 1, "func": "void do_compare_and_swap32(void *cpu_env, int num)\n\n{\n\n#ifdef TARGET_I386\n\n    uint32_t old = ((CPUX86State*)cpu_env)->regs[R_EAX];\n\n    uint32_t *value = (uint32_t*)((CPUX86State*)cpu_env)->regs[R_ECX];\n\n    DPRINTF(\"commpage: compare_and_swap32(%x,new,%p)\\n\", old, value);\n\n\n\n    if(value && old == tswap32(*value))\n\n    {\n\n        uint32_t new = ((CPUX86State*)cpu_env)->regs[R_EDX];\n\n        *value = tswap32(new);\n\n        /* set zf flag */\n\n        ((CPUX86State*)cpu_env)->eflags |= 0x40;\n\n    }\n\n    else\n\n    {\n\n        ((CPUX86State*)cpu_env)->regs[R_EAX] = tswap32(*value);\n\n        /* unset zf flag */\n\n        ((CPUX86State*)cpu_env)->eflags &= ~0x40;\n\n    }\n\n#else\n\n    qerror(\"do_compare_and_swap32 unimplemented\");\n\n#endif\n\n}\n", "idx": 25666}
{"project": "qemu", "commit_id": "88be7b4be4aa17c88247e162bdd7577ea79db94f", "target": 1, "func": "BlockDriverState *bdrv_all_find_vmstate_bs(void)\n\n{\n\n    bool not_found = true;\n\n    BlockDriverState *bs;\n\n    BdrvNextIterator *it = NULL;\n\n\n\n    while (not_found && (it = bdrv_next(it, &bs))) {\n\n        AioContext *ctx = bdrv_get_aio_context(bs);\n\n\n\n        aio_context_acquire(ctx);\n\n        not_found = !bdrv_can_snapshot(bs);\n\n        aio_context_release(ctx);\n\n    }\n\n    return bs;\n\n}\n", "idx": 25668}
{"project": "qemu", "commit_id": "f53f4da9c68941fe70a3ca9e3fc792c8acf69c0c", "target": 1, "func": "int path_is_absolute(const char *path)\n\n{\n\n    const char *p;\n\n#ifdef _WIN32\n\n    /* specific case for names like: \"\\\\.\\d:\" */\n\n    if (*path == '/' || *path == '\\\\')\n\n        return 1;\n\n#endif\n\n    p = strchr(path, ':');\n\n    if (p)\n\n        p++;\n\n    else\n\n        p = path;\n\n#ifdef _WIN32\n\n    return (*p == '/' || *p == '\\\\');\n\n#else\n\n    return (*p == '/');\n\n#endif\n\n}\n", "idx": 25669}
{"project": "qemu", "commit_id": "15c2f669e3fb2bc97f7b42d1871f595c0ac24af8", "target": 1, "func": "opts_end_struct(Visitor *v, Error **errp)\n\n{\n\n    OptsVisitor *ov = to_ov(v);\n\n    GHashTableIter iter;\n\n    GQueue *any;\n\n\n\n    if (--ov->depth > 0) {\n\n        return;\n\n    }\n\n\n\n    /* we should have processed all (distinct) QemuOpt instances */\n\n    g_hash_table_iter_init(&iter, ov->unprocessed_opts);\n\n    if (g_hash_table_iter_next(&iter, NULL, (void **)&any)) {\n\n        const QemuOpt *first;\n\n\n\n        first = g_queue_peek_head(any);\n\n        error_setg(errp, QERR_INVALID_PARAMETER, first->name);\n\n    }\n\n    g_hash_table_destroy(ov->unprocessed_opts);\n\n    ov->unprocessed_opts = NULL;\n\n    if (ov->fake_id_opt) {\n\n        g_free(ov->fake_id_opt->name);\n\n        g_free(ov->fake_id_opt->str);\n\n        g_free(ov->fake_id_opt);\n\n    }\n\n    ov->fake_id_opt = NULL;\n\n}\n", "idx": 25670}
{"project": "qemu", "commit_id": "2f448e415f364d0ec4c5556993e44ca183e31c5c", "target": 1, "func": "static uint64_t macio_nvram_readb(void *opaque, hwaddr addr,\n\n                                  unsigned size)\n\n{\n\n    MacIONVRAMState *s = opaque;\n\n    uint32_t value;\n\n\n\n    addr = (addr >> s->it_shift) & (s->size - 1);\n\n    value = s->data[addr];\n\n    NVR_DPRINTF(\"readb addr %04x val %x\\n\", (int)addr, value);\n\n\n\n    return value;\n\n}\n", "idx": 25674}
{"project": "qemu", "commit_id": "58117c9bb429cd9552d998687aa99088eb1d8528", "target": 1, "func": "void HELPER(v7m_msr)(CPUARMState *env, uint32_t reg, uint32_t val)\n\n{\n\n    ARMCPU *cpu = arm_env_get_cpu(env);\n\n\n\n    switch (reg) {\n\n    case 0: /* APSR */\n\n        xpsr_write(env, val, 0xf8000000);\n\n        break;\n\n    case 1: /* IAPSR */\n\n        xpsr_write(env, val, 0xf8000000);\n\n        break;\n\n    case 2: /* EAPSR */\n\n        xpsr_write(env, val, 0xfe00fc00);\n\n        break;\n\n    case 3: /* xPSR */\n\n        xpsr_write(env, val, 0xfe00fc00);\n\n        break;\n\n    case 5: /* IPSR */\n\n        /* IPSR bits are readonly.  */\n\n        break;\n\n    case 6: /* EPSR */\n\n        xpsr_write(env, val, 0x0600fc00);\n\n        break;\n\n    case 7: /* IEPSR */\n\n        xpsr_write(env, val, 0x0600fc00);\n\n        break;\n\n    case 8: /* MSP */\n\n        if (env->v7m.current_sp)\n\n            env->v7m.other_sp = val;\n\n        else\n\n            env->regs[13] = val;\n\n        break;\n\n    case 9: /* PSP */\n\n        if (env->v7m.current_sp)\n\n            env->regs[13] = val;\n\n        else\n\n            env->v7m.other_sp = val;\n\n        break;\n\n    case 16: /* PRIMASK */\n\n        if (val & 1) {\n\n            env->daif |= PSTATE_I;\n\n        } else {\n\n            env->daif &= ~PSTATE_I;\n\n        }\n\n        break;\n\n    case 17: /* BASEPRI */\n\n        env->v7m.basepri = val & 0xff;\n\n        break;\n\n    case 18: /* BASEPRI_MAX */\n\n        val &= 0xff;\n\n        if (val != 0 && (val < env->v7m.basepri || env->v7m.basepri == 0))\n\n            env->v7m.basepri = val;\n\n        break;\n\n    case 19: /* FAULTMASK */\n\n        if (val & 1) {\n\n            env->daif |= PSTATE_F;\n\n        } else {\n\n            env->daif &= ~PSTATE_F;\n\n        }\n\n        break;\n\n    case 20: /* CONTROL */\n\n        env->v7m.control = val & 3;\n\n        switch_v7m_sp(env, (val & 2) != 0);\n\n        break;\n\n    default:\n\n        /* ??? For debugging only.  */\n\n        cpu_abort(CPU(cpu), \"Unimplemented system register write (%d)\\n\", reg);\n\n        return;\n\n    }\n\n}\n", "idx": 25675}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "static inline void vmxnet3_ring_read_curr_cell(Vmxnet3Ring *ring, void *buff)\n\n{\n\n    vmw_shmem_read(vmxnet3_ring_curr_cell_pa(ring), buff, ring->cell_size);\n\n}\n", "idx": 25676}
{"project": "qemu", "commit_id": "b946a1533209f61a93e34898aebb5b43154b99c3", "target": 1, "func": "PCIDevice *pci_pcnet_init(PCIBus *bus, NICInfo *nd, int devfn)\n\n{\n\n    PCNetState *d;\n\n    uint8_t *pci_conf;\n\n\n\n#if 0\n\n    printf(\"sizeof(RMD)=%d, sizeof(TMD)=%d\\n\",\n\n        sizeof(struct pcnet_RMD), sizeof(struct pcnet_TMD));\n\n#endif\n\n\n\n    d = (PCNetState *)pci_register_device(bus, \"PCNet\", sizeof(PCNetState),\n\n                                          devfn, NULL, NULL);\n\n\n\n    pci_conf = d->dev.config;\n\n\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_AMD);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_AMD_LANCE);\n\n    *(uint16_t *)&pci_conf[0x04] = cpu_to_le16(0x0007);\n\n    *(uint16_t *)&pci_conf[0x06] = cpu_to_le16(0x0280);\n\n    pci_conf[0x08] = 0x10;\n\n    pci_conf[0x09] = 0x00;\n\n    pci_config_set_class(pci_conf, PCI_CLASS_NETWORK_ETHERNET);\n\n    pci_conf[0x0e] = 0x00; // header_type\n\n\n\n    *(uint32_t *)&pci_conf[0x10] = cpu_to_le32(0x00000001);\n\n    *(uint32_t *)&pci_conf[0x14] = cpu_to_le32(0x00000000);\n\n\n\n    pci_conf[0x3d] = 1; // interrupt pin 0\n\n    pci_conf[0x3e] = 0x06;\n\n    pci_conf[0x3f] = 0xff;\n\n\n\n    /* Handler for memory-mapped I/O */\n\n    d->mmio_index =\n\n      cpu_register_io_memory(0, pcnet_mmio_read, pcnet_mmio_write, d);\n\n\n\n    pci_register_io_region((PCIDevice *)d, 0, PCNET_IOPORT_SIZE,\n\n                           PCI_ADDRESS_SPACE_IO, pcnet_ioport_map);\n\n\n\n    pci_register_io_region((PCIDevice *)d, 1, PCNET_PNPMMIO_SIZE,\n\n                           PCI_ADDRESS_SPACE_MEM, pcnet_mmio_map);\n\n\n\n    d->irq = d->dev.irq[0];\n\n    d->phys_mem_read = pci_physical_memory_read;\n\n    d->phys_mem_write = pci_physical_memory_write;\n\n    d->pci_dev = &d->dev;\n\n\n\n    pcnet_common_init(d, nd);\n\n    return (PCIDevice *)d;\n\n}\n", "idx": 25679}
{"project": "qemu", "commit_id": "eabc977973103527bbb8fed69c91cfaa6691f8ab", "target": 1, "func": "void aio_notify(AioContext *ctx)\n\n{\n\n    /* Write e.g. bh->scheduled before reading ctx->dispatching.  */\n\n    smp_mb();\n\n    if (!ctx->dispatching) {\n\n        event_notifier_set(&ctx->notifier);\n\n    }\n\n}\n", "idx": 25680}
{"project": "qemu", "commit_id": "d02532f08e207419e412ea7cd4eb8b36f04f426d", "target": 1, "func": "static void tb_invalidate_phys_page(tb_page_addr_t addr,\n\n                                    uintptr_t pc, void *puc)\n\n{\n\n    TranslationBlock *tb;\n\n    PageDesc *p;\n\n    int n;\n\n#ifdef TARGET_HAS_PRECISE_SMC\n\n    TranslationBlock *current_tb = NULL;\n\n    CPUState *cpu = current_cpu;\n\n    CPUArchState *env = NULL;\n\n    int current_tb_modified = 0;\n\n    target_ulong current_pc = 0;\n\n    target_ulong current_cs_base = 0;\n\n    int current_flags = 0;\n\n#endif\n\n\n\n    addr &= TARGET_PAGE_MASK;\n\n    p = page_find(addr >> TARGET_PAGE_BITS);\n\n    if (!p) {\n\n        return;\n\n    }\n\n    tb = p->first_tb;\n\n#ifdef TARGET_HAS_PRECISE_SMC\n\n    if (tb && pc != 0) {\n\n        current_tb = tb_find_pc(pc);\n\n    }\n\n    if (cpu != NULL) {\n\n        env = cpu->env_ptr;\n\n    }\n\n#endif\n\n    while (tb != NULL) {\n\n        n = (uintptr_t)tb & 3;\n\n        tb = (TranslationBlock *)((uintptr_t)tb & ~3);\n\n#ifdef TARGET_HAS_PRECISE_SMC\n\n        if (current_tb == tb &&\n\n            (current_tb->cflags & CF_COUNT_MASK) != 1) {\n\n                /* If we are modifying the current TB, we must stop\n\n                   its execution. We could be more precise by checking\n\n                   that the modification is after the current PC, but it\n\n                   would require a specialized function to partially\n\n                   restore the CPU state */\n\n\n\n            current_tb_modified = 1;\n\n            cpu_restore_state_from_tb(current_tb, env, pc);\n\n            cpu_get_tb_cpu_state(env, &current_pc, &current_cs_base,\n\n                                 &current_flags);\n\n        }\n\n#endif /* TARGET_HAS_PRECISE_SMC */\n\n        tb_phys_invalidate(tb, addr);\n\n        tb = tb->page_next[n];\n\n    }\n\n    p->first_tb = NULL;\n\n#ifdef TARGET_HAS_PRECISE_SMC\n\n    if (current_tb_modified) {\n\n        /* we generate a block containing just the instruction\n\n           modifying the memory. It will ensure that it cannot modify\n\n           itself */\n\n        cpu->current_tb = NULL;\n\n        tb_gen_code(env, current_pc, current_cs_base, current_flags, 1);\n\n        cpu_resume_from_signal(env, puc);\n\n    }\n\n#endif\n\n}\n", "idx": 25681}
{"project": "qemu", "commit_id": "456d60692310e7ac25cf822cc1e98192ad636ece", "target": 1, "func": "static CharDriverState* create_eventfd_chr_device(void * opaque, EventNotifier *n,\n\n                                                  int vector)\n\n{\n\n    /* create a event character device based on the passed eventfd */\n\n    IVShmemState *s = opaque;\n\n    CharDriverState * chr;\n\n    int eventfd = event_notifier_get_fd(n);\n\n\n\n    chr = qemu_chr_open_eventfd(eventfd);\n\n\n\n    if (chr == NULL) {\n\n        fprintf(stderr, \"creating eventfd for eventfd %d failed\\n\", eventfd);\n\n        exit(-1);\n\n    }\n\n\n\n\n    /* if MSI is supported we need multiple interrupts */\n\n    if (ivshmem_has_feature(s, IVSHMEM_MSI)) {\n\n        s->eventfd_table[vector].pdev = &s->dev;\n\n        s->eventfd_table[vector].vector = vector;\n\n\n\n        qemu_chr_add_handlers(chr, ivshmem_can_receive, fake_irqfd,\n\n                      ivshmem_event, &s->eventfd_table[vector]);\n\n    } else {\n\n        qemu_chr_add_handlers(chr, ivshmem_can_receive, ivshmem_receive,\n\n                      ivshmem_event, s);\n\n    }\n\n\n\n    return chr;\n\n\n\n}", "idx": 25682}
{"project": "qemu", "commit_id": "0d4abda8f7328c8911c1d020bb6961650eaf7801", "target": 1, "func": "static uint64_t pl011_read(void *opaque, target_phys_addr_t offset,\n\n                           unsigned size)\n\n{\n\n    pl011_state *s = (pl011_state *)opaque;\n\n    uint32_t c;\n\n\n\n    if (offset >= 0xfe0 && offset < 0x1000) {\n\n        return s->id[(offset - 0xfe0) >> 2];\n\n    }\n\n    switch (offset >> 2) {\n\n    case 0: /* UARTDR */\n\n        s->flags &= ~PL011_FLAG_RXFF;\n\n        c = s->read_fifo[s->read_pos];\n\n        if (s->read_count > 0) {\n\n            s->read_count--;\n\n            if (++s->read_pos == 16)\n\n                s->read_pos = 0;\n\n        }\n\n        if (s->read_count == 0) {\n\n            s->flags |= PL011_FLAG_RXFE;\n\n        }\n\n        if (s->read_count == s->read_trigger - 1)\n\n            s->int_level &= ~ PL011_INT_RX;\n\n        pl011_update(s);\n\n        qemu_chr_accept_input(s->chr);\n\n        return c;\n\n    case 1: /* UARTCR */\n\n        return 0;\n\n    case 6: /* UARTFR */\n\n        return s->flags;\n\n    case 8: /* UARTILPR */\n\n        return s->ilpr;\n\n    case 9: /* UARTIBRD */\n\n        return s->ibrd;\n\n    case 10: /* UARTFBRD */\n\n        return s->fbrd;\n\n    case 11: /* UARTLCR_H */\n\n        return s->lcr;\n\n    case 12: /* UARTCR */\n\n        return s->cr;\n\n    case 13: /* UARTIFLS */\n\n        return s->ifl;\n\n    case 14: /* UARTIMSC */\n\n        return s->int_enabled;\n\n    case 15: /* UARTRIS */\n\n        return s->int_level;\n\n    case 16: /* UARTMIS */\n\n        return s->int_level & s->int_enabled;\n\n    case 18: /* UARTDMACR */\n\n        return s->dmacr;\n\n    default:\n\n        hw_error(\"pl011_read: Bad offset %x\\n\", (int)offset);\n\n        return 0;\n\n    }\n\n}\n", "idx": 25685}
{"project": "qemu", "commit_id": "3a3b8502e6f0c8d30865c5f36d2c3ae4114000b5", "target": 1, "func": "static void xics_realize(DeviceState *dev, Error **errp)\n\n{\n\n    XICSState *icp = XICS(dev);\n\n    Error *error = NULL;\n\n    int i;\n\n\n\n    if (!icp->nr_servers) {\n\n        error_setg(errp, \"Number of servers needs to be greater 0\");\n\n        return;\n\n    }\n\n\n\n    /* Registration of global state belongs into realize */\n\n    spapr_rtas_register(\"ibm,set-xive\", rtas_set_xive);\n\n    spapr_rtas_register(\"ibm,get-xive\", rtas_get_xive);\n\n    spapr_rtas_register(\"ibm,int-off\", rtas_int_off);\n\n    spapr_rtas_register(\"ibm,int-on\", rtas_int_on);\n\n\n\n    spapr_register_hypercall(H_CPPR, h_cppr);\n\n    spapr_register_hypercall(H_IPI, h_ipi);\n\n    spapr_register_hypercall(H_XIRR, h_xirr);\n\n    spapr_register_hypercall(H_XIRR_X, h_xirr_x);\n\n    spapr_register_hypercall(H_EOI, h_eoi);\n\n    spapr_register_hypercall(H_IPOLL, h_ipoll);\n\n\n\n    object_property_set_bool(OBJECT(icp->ics), true, \"realized\", &error);\n\n    if (error) {\n\n        error_propagate(errp, error);\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < icp->nr_servers; i++) {\n\n        object_property_set_bool(OBJECT(&icp->ss[i]), true, \"realized\", &error);\n\n        if (error) {\n\n            error_propagate(errp, error);\n\n            return;\n\n        }\n\n    }\n\n}\n", "idx": 25686}
{"project": "qemu", "commit_id": "fae69416294223d84db425e58e7bbf6a08c45801", "target": 1, "func": "int nbd_trip(BlockDriverState *bs, int csock, off_t size,\n\n             uint64_t dev_offset, uint32_t nbdflags,\n\n             uint8_t *data)\n\n{\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n    int ret;\n\n\n\n    TRACE(\"Reading request.\");\n\n\n\n    if (nbd_receive_request(csock, &request) == -1)\n\n        return -1;\n\n\n\n    if (request.len > NBD_BUFFER_SIZE) {\n\n        LOG(\"len (%u) is larger than max len (%u)\",\n\n            request.len, NBD_BUFFER_SIZE);\n\n        errno = EINVAL;\n\n        return -1;\n\n    }\n\n\n\n    if ((request.from + request.len) < request.from) {\n\n        LOG(\"integer overflow detected! \"\n\n            \"you're probably being attacked\");\n\n        errno = EINVAL;\n\n        return -1;\n\n    }\n\n\n\n    if ((request.from + request.len) > size) {\n\n            LOG(\"From: %\" PRIu64 \", Len: %u, Size: %\" PRIu64\n\n            \", Offset: %\" PRIu64 \"\\n\",\n\n                    request.from, request.len, (uint64_t)size, dev_offset);\n\n        LOG(\"requested operation past EOF--bad client?\");\n\n        errno = EINVAL;\n\n        return -1;\n\n    }\n\n\n\n    TRACE(\"Decoding type\");\n\n\n\n    reply.handle = request.handle;\n\n    reply.error = 0;\n\n\n\n    switch (request.type & NBD_CMD_MASK_COMMAND) {\n\n    case NBD_CMD_READ:\n\n        TRACE(\"Request type is READ\");\n\n\n\n        ret = bdrv_read(bs, (request.from + dev_offset) / 512,\n\n                        data, request.len / 512);\n\n        if (ret < 0) {\n\n            LOG(\"reading from file failed\");\n\n            reply.error = -ret;\n\n            request.len = 0;\n\n        }\n\n\n\n        TRACE(\"Read %u byte(s)\", request.len);\n\n        if (nbd_do_send_reply(csock, &reply, data, request.len) < 0)\n\n            return -1;\n\n        break;\n\n    case NBD_CMD_WRITE:\n\n        TRACE(\"Request type is WRITE\");\n\n\n\n        TRACE(\"Reading %u byte(s)\", request.len);\n\n\n\n        if (read_sync(csock, data, request.len) != request.len) {\n\n            LOG(\"reading from socket failed\");\n\n            errno = EINVAL;\n\n            return -1;\n\n        }\n\n\n\n        if (nbdflags & NBD_FLAG_READ_ONLY) {\n\n            TRACE(\"Server is read-only, return error\");\n\n            reply.error = 1;\n\n        } else {\n\n            TRACE(\"Writing to device\");\n\n\n\n            ret = bdrv_write(bs, (request.from + dev_offset) / 512,\n\n                             data, request.len / 512);\n\n            if (ret < 0) {\n\n                LOG(\"writing to file failed\");\n\n                reply.error = -ret;\n\n                request.len = 0;\n\n            }\n\n\n\n            if (request.type & NBD_CMD_FLAG_FUA) {\n\n                ret = bdrv_flush(bs);\n\n                if (ret < 0) {\n\n                    LOG(\"flush failed\");\n\n                    reply.error = -ret;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (nbd_do_send_reply(csock, &reply, NULL, 0) < 0)\n\n            return -1;\n\n        break;\n\n    case NBD_CMD_DISC:\n\n        TRACE(\"Request type is DISCONNECT\");\n\n        errno = 0;\n\n        return 1;\n\n    case NBD_CMD_FLUSH:\n\n        TRACE(\"Request type is FLUSH\");\n\n\n\n        ret = bdrv_flush(bs);\n\n        if (ret < 0) {\n\n            LOG(\"flush failed\");\n\n            reply.error = -ret;\n\n        }\n\n\n\n        if (nbd_do_send_reply(csock, &reply, NULL, 0) < 0)\n\n            return -1;\n\n        break;\n\n    case NBD_CMD_TRIM:\n\n        TRACE(\"Request type is TRIM\");\n\n        ret = bdrv_discard(bs, (request.from + dev_offset) / 512,\n\n                           request.len / 512);\n\n        if (ret < 0) {\n\n            LOG(\"discard failed\");\n\n            reply.error = -ret;\n\n        }\n\n        if (nbd_do_send_reply(csock, &reply, NULL, 0) < 0)\n\n            return -1;\n\n        break;\n\n    default:\n\n        LOG(\"invalid request type (%u) received\", request.type);\n\n        errno = EINVAL;\n\n        return -1;\n\n    }\n\n\n\n    TRACE(\"Request/Reply complete\");\n\n\n\n    return 0;\n\n}\n", "idx": 25687}
{"project": "qemu", "commit_id": "cba933b2257ef0ad241756a0ff86bc0acda685ca", "target": 1, "func": "static void icp_pit_write(void *opaque, hwaddr offset,\n\n                          uint64_t value, unsigned size)\n\n{\n\n    icp_pit_state *s = (icp_pit_state *)opaque;\n\n    int n;\n\n\n\n    n = offset >> 8;\n\n    if (n > 2) {\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"%s: Bad timer %d\\n\", __func__, n);\n\n\n    }\n\n\n\n    arm_timer_write(s->timer[n], offset & 0xff, value);\n\n}", "idx": 25688}
{"project": "qemu", "commit_id": "adb435522b86b3fca2324cb8c94e17b55ae071f1", "target": 1, "func": "int qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,\n\n                                  int64_t size)\n\n{\n\n    int ret = qcow2_check_metadata_overlap(bs, ign, offset, size);\n\n\n\n    if (ret < 0) {\n\n        return ret;\n\n    } else if (ret > 0) {\n\n        int metadata_ol_bitnr = ffs(ret) - 1;\n\n        char *message;\n\n\n\n        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);\n\n\n\n        fprintf(stderr, \"qcow2: Preventing invalid write on metadata (overlaps \"\n\n                \"with %s); image marked as corrupt.\\n\",\n\n                metadata_ol_names[metadata_ol_bitnr]);\n\n        message = g_strdup_printf(\"Prevented %s overwrite\",\n\n                metadata_ol_names[metadata_ol_bitnr]);\n\n        qapi_event_send_block_image_corrupted(bdrv_get_device_name(bs),\n\n                                              message,\n\n                                              true,\n\n                                              offset,\n\n                                              true,\n\n                                              size,\n\n                                              true,\n\n                                              &error_abort);\n\n        g_free(message);\n\n\n\n        qcow2_mark_corrupt(bs);\n\n        bs->drv = NULL; /* make BDS unusable */\n\n        return -EIO;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 25691}
{"project": "qemu", "commit_id": "c165f7758009a4f793c1fc19ebb69cf55313450b", "target": 1, "func": "static int dmg_open(BlockDriverState *bs, QDict *options, int flags,\n                    Error **errp)\n{\n    BDRVDMGState *s = bs->opaque;\n    uint64_t info_begin, info_end, last_in_offset, last_out_offset;\n    uint32_t count, tmp;\n    uint32_t max_compressed_size = 1, max_sectors_per_chunk = 1, i;\n    int64_t offset;\n    int ret;\n    bs->read_only = 1;\n    s->n_chunks = 0;\n    s->offsets = s->lengths = s->sectors = s->sectorcounts = NULL;\n    /* read offset of info blocks */\n    offset = bdrv_getlength(bs->file);\n    if (offset < 0) {\n        ret = offset;\n    offset -= 0x1d8;\n    ret = read_uint64(bs, offset, &info_begin);\n    if (ret < 0) {\n    } else if (info_begin == 0) {\n    ret = read_uint32(bs, info_begin, &tmp);\n    if (ret < 0) {\n    } else if (tmp != 0x100) {\n    ret = read_uint32(bs, info_begin + 4, &count);\n    if (ret < 0) {\n    } else if (count == 0) {\n    info_end = info_begin + count;\n    offset = info_begin + 0x100;\n    /* read offsets */\n    last_in_offset = last_out_offset = 0;\n    while (offset < info_end) {\n        uint32_t type;\n        ret = read_uint32(bs, offset, &count);\n        if (ret < 0) {\n        } else if (count == 0) {\n        offset += 4;\n        ret = read_uint32(bs, offset, &type);\n        if (ret < 0) {\n        if (type == 0x6d697368 && count >= 244) {\n            size_t new_size;\n            uint32_t chunk_count;\n            offset += 4;\n            offset += 200;\n            chunk_count = (count - 204) / 40;\n            new_size = sizeof(uint64_t) * (s->n_chunks + chunk_count);\n            s->types = g_realloc(s->types, new_size / 2);\n            s->offsets = g_realloc(s->offsets, new_size);\n            s->lengths = g_realloc(s->lengths, new_size);\n            s->sectors = g_realloc(s->sectors, new_size);\n            s->sectorcounts = g_realloc(s->sectorcounts, new_size);\n            for (i = s->n_chunks; i < s->n_chunks + chunk_count; i++) {\n                ret = read_uint32(bs, offset, &s->types[i]);\n                if (ret < 0) {\n                offset += 4;\n                if (s->types[i] != 0x80000005 && s->types[i] != 1 &&\n                    s->types[i] != 2) {\n                    if (s->types[i] == 0xffffffff && i > 0) {\n                        last_in_offset = s->offsets[i - 1] + s->lengths[i - 1];\n                        last_out_offset = s->sectors[i - 1] +\n                                          s->sectorcounts[i - 1];\n                    chunk_count--;\n                    i--;\n                    offset += 36;\n                    continue;\n                offset += 4;\n                ret = read_uint64(bs, offset, &s->sectors[i]);\n                if (ret < 0) {\n                s->sectors[i] += last_out_offset;\n                offset += 8;\n                ret = read_uint64(bs, offset, &s->sectorcounts[i]);\n                if (ret < 0) {\n                offset += 8;\n                if (s->sectorcounts[i] > DMG_SECTORCOUNTS_MAX) {\n                    error_report(\"sector count %\" PRIu64 \" for chunk %u is \"\n                                 \"larger than max (%u)\",\n                                 s->sectorcounts[i], i, DMG_SECTORCOUNTS_MAX);\n                ret = read_uint64(bs, offset, &s->offsets[i]);\n                if (ret < 0) {\n                s->offsets[i] += last_in_offset;\n                offset += 8;\n                ret = read_uint64(bs, offset, &s->lengths[i]);\n                if (ret < 0) {\n                offset += 8;\n                if (s->lengths[i] > max_compressed_size) {\n                    max_compressed_size = s->lengths[i];\n                if (s->sectorcounts[i] > max_sectors_per_chunk) {\n                    max_sectors_per_chunk = s->sectorcounts[i];\n            s->n_chunks += chunk_count;\n    /* initialize zlib engine */\n    s->compressed_chunk = g_malloc(max_compressed_size + 1);\n    s->uncompressed_chunk = g_malloc(512 * max_sectors_per_chunk);\n    if (inflateInit(&s->zstream) != Z_OK) {\n    s->current_chunk = s->n_chunks;\n    qemu_co_mutex_init(&s->lock);\n    return 0;\nfail:\n    g_free(s->types);\n    g_free(s->offsets);\n    g_free(s->lengths);\n    g_free(s->sectors);\n    g_free(s->sectorcounts);\n    g_free(s->compressed_chunk);\n    g_free(s->uncompressed_chunk);\n    return ret;", "idx": 25692}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void bdrv_set_on_error(BlockDriverState *bs, BlockdevOnError on_read_error,\n\n                       BlockdevOnError on_write_error)\n\n{\n\n    bs->on_read_error = on_read_error;\n\n    bs->on_write_error = on_write_error;\n\n}\n", "idx": 25696}
{"project": "qemu", "commit_id": "4500bc98a6aab1734d865afaeade3509eb65b560", "target": 0, "func": "static void test_acpi_one(const char *params, test_data *data)\n\n{\n\n    char *args;\n\n    uint8_t signature_low;\n\n    uint8_t signature_high;\n\n    uint16_t signature;\n\n    int i;\n\n    const char *device = \"\";\n\n\n\n    if (!g_strcmp0(data->machine, MACHINE_Q35)) {\n\n        device = \",id=hd -device ide-hd,drive=hd\";\n\n    }\n\n\n\n    args = g_strdup_printf(\"-net none -display none %s -drive file=%s%s,\",\n\n                           params ? params : \"\", disk, device);\n\n    qtest_start(args);\n\n\n\n   /* Wait at most 1 minute */\n\n#define TEST_DELAY (1 * G_USEC_PER_SEC / 10)\n\n#define TEST_CYCLES MAX((60 * G_USEC_PER_SEC / TEST_DELAY), 1)\n\n\n\n    /* Poll until code has run and modified memory.  Once it has we know BIOS\n\n     * initialization is done.  TODO: check that IP reached the halt\n\n     * instruction.\n\n     */\n\n    for (i = 0; i < TEST_CYCLES; ++i) {\n\n        signature_low = readb(BOOT_SECTOR_ADDRESS + SIGNATURE_OFFSET);\n\n        signature_high = readb(BOOT_SECTOR_ADDRESS + SIGNATURE_OFFSET + 1);\n\n        signature = (signature_high << 8) | signature_low;\n\n        if (signature == SIGNATURE) {\n\n            break;\n\n        }\n\n        g_usleep(TEST_DELAY);\n\n    }\n\n    g_assert_cmphex(signature, ==, SIGNATURE);\n\n\n\n    test_acpi_rsdp_address(data);\n\n    test_acpi_rsdp_table(data);\n\n    test_acpi_rsdt_table(data);\n\n    test_acpi_fadt_table(data);\n\n    test_acpi_facs_table(data);\n\n    test_acpi_dsdt_table(data);\n\n    test_acpi_ssdt_tables(data);\n\n\n\n    if (iasl) {\n\n        test_acpi_asl(data);\n\n    }\n\n\n\n    qtest_quit(global_qtest);\n\n    g_free(args);\n\n}\n", "idx": 25697}
{"project": "qemu", "commit_id": "8caed3d564672e8bc6d2e4c6a35228afd01f4723", "target": 0, "func": "static void rocker_io_writel(void *opaque, hwaddr addr, uint32_t val)\n\n{\n\n    Rocker *r = opaque;\n\n\n\n    if (rocker_addr_is_desc_reg(r, addr)) {\n\n        unsigned index = ROCKER_RING_INDEX(addr);\n\n        unsigned offset = addr & ROCKER_DMA_DESC_MASK;\n\n\n\n        switch (offset) {\n\n        case ROCKER_DMA_DESC_ADDR_OFFSET:\n\n            r->lower32 = (uint64_t)val;\n\n            break;\n\n        case ROCKER_DMA_DESC_ADDR_OFFSET + 4:\n\n            desc_ring_set_base_addr(r->rings[index],\n\n                                    ((uint64_t)val) << 32 | r->lower32);\n\n            r->lower32 = 0;\n\n            break;\n\n        case ROCKER_DMA_DESC_SIZE_OFFSET:\n\n            desc_ring_set_size(r->rings[index], val);\n\n            break;\n\n        case ROCKER_DMA_DESC_HEAD_OFFSET:\n\n            if (desc_ring_set_head(r->rings[index], val)) {\n\n                rocker_msix_irq(r, desc_ring_get_msix_vector(r->rings[index]));\n\n            }\n\n            break;\n\n        case ROCKER_DMA_DESC_CTRL_OFFSET:\n\n            desc_ring_set_ctrl(r->rings[index], val);\n\n            break;\n\n        case ROCKER_DMA_DESC_CREDITS_OFFSET:\n\n            if (desc_ring_ret_credits(r->rings[index], val)) {\n\n                rocker_msix_irq(r, desc_ring_get_msix_vector(r->rings[index]));\n\n            }\n\n            break;\n\n        default:\n\n            DPRINTF(\"not implemented dma reg write(l) addr=0x\" TARGET_FMT_plx\n\n                    \" val=0x%08x (ring %d, addr=0x%02x)\\n\",\n\n                    addr, val, index, offset);\n\n            break;\n\n        }\n\n        return;\n\n    }\n\n\n\n    switch (addr) {\n\n    case ROCKER_TEST_REG:\n\n        r->test_reg = val;\n\n        break;\n\n    case ROCKER_TEST_REG64:\n\n    case ROCKER_TEST_DMA_ADDR:\n\n    case ROCKER_PORT_PHYS_ENABLE:\n\n        r->lower32 = (uint64_t)val;\n\n        break;\n\n    case ROCKER_TEST_REG64 + 4:\n\n        r->test_reg64 = ((uint64_t)val) << 32 | r->lower32;\n\n        r->lower32 = 0;\n\n        break;\n\n    case ROCKER_TEST_IRQ:\n\n        rocker_msix_irq(r, val);\n\n        break;\n\n    case ROCKER_TEST_DMA_SIZE:\n\n        r->test_dma_size = val;\n\n        break;\n\n    case ROCKER_TEST_DMA_ADDR + 4:\n\n        r->test_dma_addr = ((uint64_t)val) << 32 | r->lower32;\n\n        r->lower32 = 0;\n\n        break;\n\n    case ROCKER_TEST_DMA_CTRL:\n\n        rocker_test_dma_ctrl(r, val);\n\n        break;\n\n    case ROCKER_CONTROL:\n\n        rocker_control(r, val);\n\n        break;\n\n    case ROCKER_PORT_PHYS_ENABLE + 4:\n\n        rocker_port_phys_enable_write(r, ((uint64_t)val) << 32 | r->lower32);\n\n        r->lower32 = 0;\n\n        break;\n\n    default:\n\n        DPRINTF(\"not implemented write(l) addr=0x\" TARGET_FMT_plx\n\n                \" val=0x%08x\\n\", addr, val);\n\n        break;\n\n    }\n\n}\n", "idx": 25698}
{"project": "qemu", "commit_id": "5151355898699eb66fad0a710b8b6011690a0dfc", "target": 0, "func": "build_rsdt(GArray *table_data, GArray *linker, GArray *table_offsets)\n\n{\n\n    AcpiRsdtDescriptorRev1 *rsdt;\n\n    size_t rsdt_len;\n\n    int i;\n\n    const int table_data_len = (sizeof(uint32_t) * table_offsets->len);\n\n\n\n    rsdt_len = sizeof(*rsdt) + table_data_len;\n\n    rsdt = acpi_data_push(table_data, rsdt_len);\n\n    memcpy(rsdt->table_offset_entry, table_offsets->data, table_data_len);\n\n    for (i = 0; i < table_offsets->len; ++i) {\n\n        /* rsdt->table_offset_entry to be filled by Guest linker */\n\n        bios_linker_loader_add_pointer(linker,\n\n                                       ACPI_BUILD_TABLE_FILE,\n\n                                       ACPI_BUILD_TABLE_FILE,\n\n                                       table_data, &rsdt->table_offset_entry[i],\n\n                                       sizeof(uint32_t));\n\n    }\n\n    build_header(linker, table_data,\n\n                 (void *)rsdt, \"RSDT\", rsdt_len, 1, NULL, NULL);\n\n}\n", "idx": 25699}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "int nbd_client_session_co_writev(NbdClientSession *client, int64_t sector_num,\n\n                                 int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    int offset = 0;\n\n    int ret;\n\n    while (nb_sectors > NBD_MAX_SECTORS) {\n\n        ret = nbd_co_writev_1(client, sector_num,\n\n                              NBD_MAX_SECTORS, qiov, offset);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        offset += NBD_MAX_SECTORS * 512;\n\n        sector_num += NBD_MAX_SECTORS;\n\n        nb_sectors -= NBD_MAX_SECTORS;\n\n    }\n\n    return nbd_co_writev_1(client, sector_num, nb_sectors, qiov, offset);\n\n}\n", "idx": 25700}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int scsi_disk_emulate_mode_sense(SCSIDiskReq *r, uint8_t *outbuf)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint64_t nb_sectors;\n\n    bool dbd;\n\n    int page, buflen, ret, page_control;\n\n    uint8_t *p;\n\n    uint8_t dev_specific_param;\n\n\n\n    dbd = (r->req.cmd.buf[1] & 0x8) != 0;\n\n    page = r->req.cmd.buf[2] & 0x3f;\n\n    page_control = (r->req.cmd.buf[2] & 0xc0) >> 6;\n\n    DPRINTF(\"Mode Sense(%d) (page %d, xfer %zd, page_control %d)\\n\",\n\n        (r->req.cmd.buf[0] == MODE_SENSE) ? 6 : 10, page, r->req.cmd.xfer, page_control);\n\n    memset(outbuf, 0, r->req.cmd.xfer);\n\n    p = outbuf;\n\n\n\n    if (s->qdev.type == TYPE_DISK) {\n\n        dev_specific_param = s->features & (1 << SCSI_DISK_F_DPOFUA) ? 0x10 : 0;\n\n        if (bdrv_is_read_only(s->qdev.conf.bs)) {\n\n            dev_specific_param |= 0x80; /* Readonly.  */\n\n        }\n\n    } else {\n\n        /* MMC prescribes that CD/DVD drives have no block descriptors,\n\n         * and defines no device-specific parameter.  */\n\n        dev_specific_param = 0x00;\n\n        dbd = true;\n\n    }\n\n\n\n    if (r->req.cmd.buf[0] == MODE_SENSE) {\n\n        p[1] = 0; /* Default media type.  */\n\n        p[2] = dev_specific_param;\n\n        p[3] = 0; /* Block descriptor length.  */\n\n        p += 4;\n\n    } else { /* MODE_SENSE_10 */\n\n        p[2] = 0; /* Default media type.  */\n\n        p[3] = dev_specific_param;\n\n        p[6] = p[7] = 0; /* Block descriptor length.  */\n\n        p += 8;\n\n    }\n\n\n\n    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n    if (!dbd && nb_sectors) {\n\n        if (r->req.cmd.buf[0] == MODE_SENSE) {\n\n            outbuf[3] = 8; /* Block descriptor length  */\n\n        } else { /* MODE_SENSE_10 */\n\n            outbuf[7] = 8; /* Block descriptor length  */\n\n        }\n\n        nb_sectors /= (s->qdev.blocksize / 512);\n\n        if (nb_sectors > 0xffffff) {\n\n            nb_sectors = 0;\n\n        }\n\n        p[0] = 0; /* media density code */\n\n        p[1] = (nb_sectors >> 16) & 0xff;\n\n        p[2] = (nb_sectors >> 8) & 0xff;\n\n        p[3] = nb_sectors & 0xff;\n\n        p[4] = 0; /* reserved */\n\n        p[5] = 0; /* bytes 5-7 are the sector size in bytes */\n\n        p[6] = s->qdev.blocksize >> 8;\n\n        p[7] = 0;\n\n        p += 8;\n\n    }\n\n\n\n    if (page_control == 3) {\n\n        /* Saved Values */\n\n        scsi_check_condition(r, SENSE_CODE(SAVING_PARAMS_NOT_SUPPORTED));\n\n        return -1;\n\n    }\n\n\n\n    if (page == 0x3f) {\n\n        for (page = 0; page <= 0x3e; page++) {\n\n            mode_sense_page(s, page, &p, page_control);\n\n        }\n\n    } else {\n\n        ret = mode_sense_page(s, page, &p, page_control);\n\n        if (ret == -1) {\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    buflen = p - outbuf;\n\n    /*\n\n     * The mode data length field specifies the length in bytes of the\n\n     * following data that is available to be transferred. The mode data\n\n     * length does not include itself.\n\n     */\n\n    if (r->req.cmd.buf[0] == MODE_SENSE) {\n\n        outbuf[0] = buflen - 1;\n\n    } else { /* MODE_SENSE_10 */\n\n        outbuf[0] = ((buflen - 2) >> 8) & 0xff;\n\n        outbuf[1] = (buflen - 2) & 0xff;\n\n    }\n\n    return buflen;\n\n}\n", "idx": 25701}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static void qemu_chr_parse_pipe(QemuOpts *opts, ChardevBackend *backend,\n\n                                Error **errp)\n\n{\n\n    const char *device = qemu_opt_get(opts, \"path\");\n\n    ChardevHostdev *dev;\n\n\n\n    if (device == NULL) {\n\n        error_setg(errp, \"chardev: pipe: no device path given\");\n\n        return;\n\n    }\n\n    dev = backend->u.pipe = g_new0(ChardevHostdev, 1);\n\n    qemu_chr_parse_common(opts, qapi_ChardevHostdev_base(dev));\n\n    dev->device = g_strdup(device);\n\n}\n", "idx": 25702}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t apic_mem_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    DeviceState *d;\n\n    APICCommonState *s;\n\n    uint32_t val;\n\n    int index;\n\n\n\n    d = cpu_get_current_apic();\n\n    if (!d) {\n\n        return 0;\n\n    }\n\n    s = DO_UPCAST(APICCommonState, busdev.qdev, d);\n\n\n\n    index = (addr >> 4) & 0xff;\n\n    switch(index) {\n\n    case 0x02: /* id */\n\n        val = s->id << 24;\n\n        break;\n\n    case 0x03: /* version */\n\n        val = 0x11 | ((APIC_LVT_NB - 1) << 16); /* version 0x11 */\n\n        break;\n\n    case 0x08:\n\n        apic_sync_vapic(s, SYNC_FROM_VAPIC);\n\n        if (apic_report_tpr_access) {\n\n            cpu_report_tpr_access(s->cpu_env, TPR_ACCESS_READ);\n\n        }\n\n        val = s->tpr;\n\n        break;\n\n    case 0x09:\n\n        val = apic_get_arb_pri(s);\n\n        break;\n\n    case 0x0a:\n\n        /* ppr */\n\n        val = apic_get_ppr(s);\n\n        break;\n\n    case 0x0b:\n\n        val = 0;\n\n        break;\n\n    case 0x0d:\n\n        val = s->log_dest << 24;\n\n        break;\n\n    case 0x0e:\n\n        val = s->dest_mode << 28;\n\n        break;\n\n    case 0x0f:\n\n        val = s->spurious_vec;\n\n        break;\n\n    case 0x10 ... 0x17:\n\n        val = s->isr[index & 7];\n\n        break;\n\n    case 0x18 ... 0x1f:\n\n        val = s->tmr[index & 7];\n\n        break;\n\n    case 0x20 ... 0x27:\n\n        val = s->irr[index & 7];\n\n        break;\n\n    case 0x28:\n\n        val = s->esr;\n\n        break;\n\n    case 0x30:\n\n    case 0x31:\n\n        val = s->icr[index & 1];\n\n        break;\n\n    case 0x32 ... 0x37:\n\n        val = s->lvt[index - 0x32];\n\n        break;\n\n    case 0x38:\n\n        val = s->initial_count;\n\n        break;\n\n    case 0x39:\n\n        val = apic_get_current_count(s);\n\n        break;\n\n    case 0x3e:\n\n        val = s->divide_conf;\n\n        break;\n\n    default:\n\n        s->esr |= ESR_ILLEGAL_ADDRESS;\n\n        val = 0;\n\n        break;\n\n    }\n\n    trace_apic_mem_readl(addr, val);\n\n    return val;\n\n}\n", "idx": 25704}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static void bt_submit_sco(struct HCIInfo *info,\n\n                const uint8_t *data, int length)\n\n{\n\n    struct bt_hci_s *hci = hci_from_info(info);\n\n    uint16_t handle;\n\n    int datalen;\n\n\n\n    if (length < 3)\n\n        return;\n\n\n\n    handle = acl_handle((data[1] << 8) | data[0]);\n\n    datalen = data[2];\n\n    length -= 3;\n\n\n\n    if (bt_hci_handle_bad(hci, handle)) {\n\n        fprintf(stderr, \"%s: invalid SCO handle %03x\\n\",\n\n                        __FUNCTION__, handle);\n\n        return;\n\n    }\n\n\n\n    if (datalen > length) {\n\n        fprintf(stderr, \"%s: SCO packet too short (%iB < %iB)\\n\",\n\n                        __FUNCTION__, length, datalen);\n\n        return;\n\n    }\n\n\n\n    /* TODO */\n\n\n\n    /* TODO: increase counter and send EVT_NUM_COMP_PKTS if synchronous\n\n     * Flow Control is enabled.\n\n     * (See Read/Write_Synchronous_Flow_Control_Enable on page 513 and\n\n     * page 514.)  */\n\n}\n", "idx": 25705}
{"project": "qemu", "commit_id": "428c3ece97179557f2753071fb0ca97a03437267", "target": 0, "func": "static bool msi_is_masked(const PCIDevice *dev, unsigned int vector)\n\n{\n\n    uint16_t flags = pci_get_word(dev->config + msi_flags_off(dev));\n\n    uint32_t mask;\n\n    assert(vector < PCI_MSI_VECTORS_MAX);\n\n\n\n    if (!(flags & PCI_MSI_FLAGS_MASKBIT)) {\n\n        return false;\n\n    }\n\n\n\n    mask = pci_get_long(dev->config +\n\n                        msi_mask_off(dev, flags & PCI_MSI_FLAGS_64BIT));\n\n    return mask & (1U << vector);\n\n}\n", "idx": 25706}
{"project": "qemu", "commit_id": "334e8dad7a109d15cb20b090131374ae98682a50", "target": 0, "func": "static void do_v7m_exception_exit(ARMCPU *cpu)\n\n{\n\n    CPUARMState *env = &cpu->env;\n\n    uint32_t type;\n\n    uint32_t xpsr;\n\n    bool ufault = false;\n\n    bool return_to_sp_process = false;\n\n    bool return_to_handler = false;\n\n    bool rettobase = false;\n\n\n\n    /* We can only get here from an EXCP_EXCEPTION_EXIT, and\n\n     * gen_bx_excret() enforces the architectural rule\n\n     * that jumps to magic addresses don't have magic behaviour unless\n\n     * we're in Handler mode (compare pseudocode BXWritePC()).\n\n     */\n\n    assert(arm_v7m_is_handler_mode(env));\n\n\n\n    /* In the spec pseudocode ExceptionReturn() is called directly\n\n     * from BXWritePC() and gets the full target PC value including\n\n     * bit zero. In QEMU's implementation we treat it as a normal\n\n     * jump-to-register (which is then caught later on), and so split\n\n     * the target value up between env->regs[15] and env->thumb in\n\n     * gen_bx(). Reconstitute it.\n\n     */\n\n    type = env->regs[15];\n\n    if (env->thumb) {\n\n        type |= 1;\n\n    }\n\n\n\n    qemu_log_mask(CPU_LOG_INT, \"Exception return: magic PC %\" PRIx32\n\n                  \" previous exception %d\\n\",\n\n                  type, env->v7m.exception);\n\n\n\n    if (extract32(type, 5, 23) != extract32(-1, 5, 23)) {\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"M profile: zero high bits in exception \"\n\n                      \"exit PC value 0x%\" PRIx32 \" are UNPREDICTABLE\\n\", type);\n\n    }\n\n\n\n    if (env->v7m.exception != ARMV7M_EXCP_NMI) {\n\n        /* Auto-clear FAULTMASK on return from other than NMI.\n\n         * If the security extension is implemented then this only\n\n         * happens if the raw execution priority is >= 0; the\n\n         * value of the ES bit in the exception return value indicates\n\n         * which security state's faultmask to clear. (v8M ARM ARM R_KBNF.)\n\n         */\n\n        if (arm_feature(env, ARM_FEATURE_M_SECURITY)) {\n\n            int es = type & 1;\n\n            if (armv7m_nvic_raw_execution_priority(env->nvic) >= 0) {\n\n                env->v7m.faultmask[es] = 0;\n\n            }\n\n        } else {\n\n            env->v7m.faultmask[M_REG_NS] = 0;\n\n        }\n\n    }\n\n\n\n    switch (armv7m_nvic_complete_irq(env->nvic, env->v7m.exception)) {\n\n    case -1:\n\n        /* attempt to exit an exception that isn't active */\n\n        ufault = true;\n\n        break;\n\n    case 0:\n\n        /* still an irq active now */\n\n        break;\n\n    case 1:\n\n        /* we returned to base exception level, no nesting.\n\n         * (In the pseudocode this is written using \"NestedActivation != 1\"\n\n         * where we have 'rettobase == false'.)\n\n         */\n\n        rettobase = true;\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n\n\n    switch (type & 0xf) {\n\n    case 1: /* Return to Handler */\n\n        return_to_handler = true;\n\n        break;\n\n    case 13: /* Return to Thread using Process stack */\n\n        return_to_sp_process = true;\n\n        /* fall through */\n\n    case 9: /* Return to Thread using Main stack */\n\n        if (!rettobase &&\n\n            !(env->v7m.ccr[env->v7m.secure] & R_V7M_CCR_NONBASETHRDENA_MASK)) {\n\n            ufault = true;\n\n        }\n\n        break;\n\n    default:\n\n        ufault = true;\n\n    }\n\n\n\n    if (ufault) {\n\n        /* Bad exception return: instead of popping the exception\n\n         * stack, directly take a usage fault on the current stack.\n\n         */\n\n        env->v7m.cfsr |= R_V7M_CFSR_INVPC_MASK;\n\n        armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_USAGE);\n\n        v7m_exception_taken(cpu, type | 0xf0000000);\n\n        qemu_log_mask(CPU_LOG_INT, \"...taking UsageFault on existing \"\n\n                      \"stackframe: failed exception return integrity check\\n\");\n\n        return;\n\n    }\n\n\n\n    /* Switch to the target stack.  */\n\n    switch_v7m_sp(env, return_to_sp_process);\n\n    /* Pop registers.  */\n\n    env->regs[0] = v7m_pop(env);\n\n    env->regs[1] = v7m_pop(env);\n\n    env->regs[2] = v7m_pop(env);\n\n    env->regs[3] = v7m_pop(env);\n\n    env->regs[12] = v7m_pop(env);\n\n    env->regs[14] = v7m_pop(env);\n\n    env->regs[15] = v7m_pop(env);\n\n    if (env->regs[15] & 1) {\n\n        qemu_log_mask(LOG_GUEST_ERROR,\n\n                      \"M profile return from interrupt with misaligned \"\n\n                      \"PC is UNPREDICTABLE\\n\");\n\n        /* Actual hardware seems to ignore the lsbit, and there are several\n\n         * RTOSes out there which incorrectly assume the r15 in the stack\n\n         * frame should be a Thumb-style \"lsbit indicates ARM/Thumb\" value.\n\n         */\n\n        env->regs[15] &= ~1U;\n\n    }\n\n    xpsr = v7m_pop(env);\n\n    xpsr_write(env, xpsr, ~XPSR_SPREALIGN);\n\n    /* Undo stack alignment.  */\n\n    if (xpsr & XPSR_SPREALIGN) {\n\n        env->regs[13] |= 4;\n\n    }\n\n\n\n    /* The restored xPSR exception field will be zero if we're\n\n     * resuming in Thread mode. If that doesn't match what the\n\n     * exception return type specified then this is a UsageFault.\n\n     */\n\n    if (return_to_handler != arm_v7m_is_handler_mode(env)) {\n\n        /* Take an INVPC UsageFault by pushing the stack again. */\n\n        armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_USAGE);\n\n        env->v7m.cfsr |= R_V7M_CFSR_INVPC_MASK;\n\n        v7m_push_stack(cpu);\n\n        v7m_exception_taken(cpu, type | 0xf0000000);\n\n        qemu_log_mask(CPU_LOG_INT, \"...taking UsageFault on new stackframe: \"\n\n                      \"failed exception return integrity check\\n\");\n\n        return;\n\n    }\n\n\n\n    /* Otherwise, we have a successful exception exit. */\n\n    qemu_log_mask(CPU_LOG_INT, \"...successful exception return\\n\");\n\n}\n", "idx": 25707}
{"project": "qemu", "commit_id": "713d9675e0e31c627d08b6a33d3a92e4b8505b40", "target": 0, "func": "static int check_refcounts_l2(BlockDriverState *bs, BdrvCheckResult *res,\n\n    uint16_t *refcount_table, int refcount_table_size, int64_t l2_offset,\n\n    int flags)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t *l2_table, l2_entry;\n\n    uint64_t next_contiguous_offset = 0;\n\n    int i, l2_size, nb_csectors;\n\n\n\n    /* Read L2 table from disk */\n\n    l2_size = s->l2_size * sizeof(uint64_t);\n\n    l2_table = g_malloc(l2_size);\n\n\n\n    if (bdrv_pread(bs->file, l2_offset, l2_table, l2_size) != l2_size)\n\n        goto fail;\n\n\n\n    /* Do the actual checks */\n\n    for(i = 0; i < s->l2_size; i++) {\n\n        l2_entry = be64_to_cpu(l2_table[i]);\n\n\n\n        switch (qcow2_get_cluster_type(l2_entry)) {\n\n        case QCOW2_CLUSTER_COMPRESSED:\n\n            /* Compressed clusters don't have QCOW_OFLAG_COPIED */\n\n            if (l2_entry & QCOW_OFLAG_COPIED) {\n\n                fprintf(stderr, \"ERROR: cluster %\" PRId64 \": \"\n\n                    \"copied flag must never be set for compressed \"\n\n                    \"clusters\\n\", l2_entry >> s->cluster_bits);\n\n                l2_entry &= ~QCOW_OFLAG_COPIED;\n\n                res->corruptions++;\n\n            }\n\n\n\n            /* Mark cluster as used */\n\n            nb_csectors = ((l2_entry >> s->csize_shift) &\n\n                           s->csize_mask) + 1;\n\n            l2_entry &= s->cluster_offset_mask;\n\n            inc_refcounts(bs, res, refcount_table, refcount_table_size,\n\n                l2_entry & ~511, nb_csectors * 512);\n\n\n\n            if (flags & CHECK_FRAG_INFO) {\n\n                res->bfi.allocated_clusters++;\n\n                res->bfi.compressed_clusters++;\n\n\n\n                /* Compressed clusters are fragmented by nature.  Since they\n\n                 * take up sub-sector space but we only have sector granularity\n\n                 * I/O we need to re-read the same sectors even for adjacent\n\n                 * compressed clusters.\n\n                 */\n\n                res->bfi.fragmented_clusters++;\n\n            }\n\n            break;\n\n\n\n        case QCOW2_CLUSTER_ZERO:\n\n            if ((l2_entry & L2E_OFFSET_MASK) == 0) {\n\n                break;\n\n            }\n\n            /* fall through */\n\n\n\n        case QCOW2_CLUSTER_NORMAL:\n\n        {\n\n            uint64_t offset = l2_entry & L2E_OFFSET_MASK;\n\n\n\n            if (flags & CHECK_FRAG_INFO) {\n\n                res->bfi.allocated_clusters++;\n\n                if (next_contiguous_offset &&\n\n                    offset != next_contiguous_offset) {\n\n                    res->bfi.fragmented_clusters++;\n\n                }\n\n                next_contiguous_offset = offset + s->cluster_size;\n\n            }\n\n\n\n            /* Mark cluster as used */\n\n            inc_refcounts(bs, res, refcount_table,refcount_table_size,\n\n                offset, s->cluster_size);\n\n\n\n            /* Correct offsets are cluster aligned */\n\n            if (offset_into_cluster(s, offset)) {\n\n                fprintf(stderr, \"ERROR offset=%\" PRIx64 \": Cluster is not \"\n\n                    \"properly aligned; L2 entry corrupted.\\n\", offset);\n\n                res->corruptions++;\n\n            }\n\n            break;\n\n        }\n\n\n\n        case QCOW2_CLUSTER_UNALLOCATED:\n\n            break;\n\n\n\n        default:\n\n            abort();\n\n        }\n\n    }\n\n\n\n    g_free(l2_table);\n\n    return 0;\n\n\n\nfail:\n\n    fprintf(stderr, \"ERROR: I/O error in check_refcounts_l2\\n\");\n\n    g_free(l2_table);\n\n    return -EIO;\n\n}\n", "idx": 25708}
{"project": "qemu", "commit_id": "7385aed20db5d83979f683b9d0048674411e963c", "target": 0, "func": "static inline void gen_op_fcmpq(int fccno)\n\n{\n\n    switch (fccno) {\n\n    case 0:\n\n        gen_helper_fcmpq(cpu_env);\n\n        break;\n\n    case 1:\n\n        gen_helper_fcmpq_fcc1(cpu_env);\n\n        break;\n\n    case 2:\n\n        gen_helper_fcmpq_fcc2(cpu_env);\n\n        break;\n\n    case 3:\n\n        gen_helper_fcmpq_fcc3(cpu_env);\n\n        break;\n\n    }\n\n}\n", "idx": 25709}
{"project": "qemu", "commit_id": "9359a58b122187964d7465d48165680eadbf69d3", "target": 0, "func": "static void ehci_opreg_write(void *ptr, hwaddr addr,\n\n                             uint64_t val, unsigned size)\n\n{\n\n    EHCIState *s = ptr;\n\n    uint32_t *mmio = s->opreg + (addr >> 2);\n\n    uint32_t old = *mmio;\n\n    int i;\n\n\n\n    trace_usb_ehci_opreg_write(addr + s->opregbase, addr2str(addr), val);\n\n\n\n    switch (addr) {\n\n    case USBCMD:\n\n        if (val & USBCMD_HCRESET) {\n\n            ehci_reset(s);\n\n            val = s->usbcmd;\n\n            break;\n\n        }\n\n\n\n        /* not supporting dynamic frame list size at the moment */\n\n        if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {\n\n            fprintf(stderr, \"attempt to set frame list size -- value %d\\n\",\n\n                    (int)val & USBCMD_FLS);\n\n            val &= ~USBCMD_FLS;\n\n        }\n\n\n\n        if (val & USBCMD_IAAD) {\n\n            /*\n\n             * Process IAAD immediately, otherwise the Linux IAAD watchdog may\n\n             * trigger and re-use a qh without us seeing the unlink.\n\n             */\n\n            s->async_stepdown = 0;\n\n            qemu_bh_schedule(s->async_bh);\n\n            trace_usb_ehci_doorbell_ring();\n\n        }\n\n\n\n        if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) !=\n\n            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) {\n\n            if (s->pstate == EST_INACTIVE) {\n\n                SET_LAST_RUN_CLOCK(s);\n\n            }\n\n            s->usbcmd = val; /* Set usbcmd for ehci_update_halt() */\n\n            ehci_update_halt(s);\n\n            s->async_stepdown = 0;\n\n            qemu_bh_schedule(s->async_bh);\n\n        }\n\n        break;\n\n\n\n    case USBSTS:\n\n        val &= USBSTS_RO_MASK;              // bits 6 through 31 are RO\n\n        ehci_clear_usbsts(s, val);          // bits 0 through 5 are R/WC\n\n        val = s->usbsts;\n\n        ehci_update_irq(s);\n\n        break;\n\n\n\n    case USBINTR:\n\n        val &= USBINTR_MASK;\n\n        if (ehci_enabled(s) && (USBSTS_FLR & val)) {\n\n            qemu_bh_schedule(s->async_bh);\n\n        }\n\n        break;\n\n\n\n    case FRINDEX:\n\n        val &= 0x00003ff8; /* frindex is 14bits and always a multiple of 8 */\n\n        break;\n\n\n\n    case CONFIGFLAG:\n\n        val &= 0x1;\n\n        if (val) {\n\n            for(i = 0; i < NB_PORTS; i++)\n\n                handle_port_owner_write(s, i, 0);\n\n        }\n\n        break;\n\n\n\n    case PERIODICLISTBASE:\n\n        if (ehci_periodic_enabled(s)) {\n\n            fprintf(stderr,\n\n              \"ehci: PERIODIC list base register set while periodic schedule\\n\"\n\n              \"      is enabled and HC is enabled\\n\");\n\n        }\n\n        break;\n\n\n\n    case ASYNCLISTADDR:\n\n        if (ehci_async_enabled(s)) {\n\n            fprintf(stderr,\n\n              \"ehci: ASYNC list address register set while async schedule\\n\"\n\n              \"      is enabled and HC is enabled\\n\");\n\n        }\n\n        break;\n\n    }\n\n\n\n    *mmio = val;\n\n    trace_usb_ehci_opreg_change(addr + s->opregbase, addr2str(addr),\n\n                                *mmio, old);\n\n}\n", "idx": 25710}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static SocketAddressLegacy *tcp_build_address(const char *host_port, Error **errp)\n\n{\n\n    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);\n\n    SocketAddressLegacy *saddr;\n\n\n\n    if (inet_parse(iaddr, host_port, errp)) {\n\n        qapi_free_InetSocketAddress(iaddr);\n\n        return NULL;\n\n    }\n\n\n\n    saddr = g_new0(SocketAddressLegacy, 1);\n\n    saddr->type = SOCKET_ADDRESS_LEGACY_KIND_INET;\n\n    saddr->u.inet.data = iaddr;\n\n\n\n    return saddr;\n\n}\n", "idx": 25711}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int proxy_closedir(FsContext *ctx, V9fsFidOpenState *fs)\n\n{\n\n    return closedir(fs->dir);\n\n}\n", "idx": 25712}
{"project": "qemu", "commit_id": "ba5e6bfa1aee29a8f72c5538c565dfb9889cf273", "target": 0, "func": "static void vfio_bar_quirk_teardown(VFIOPCIDevice *vdev, int nr)\n\n{\n\n    VFIOBAR *bar = &vdev->bars[nr];\n\n\n\n    while (!QLIST_EMPTY(&bar->quirks)) {\n\n        VFIOQuirk *quirk = QLIST_FIRST(&bar->quirks);\n\n        memory_region_del_subregion(&bar->region.mem, &quirk->mem);\n\n        object_unparent(OBJECT(&quirk->mem));\n\n        QLIST_REMOVE(quirk, next);\n\n        g_free(quirk);\n\n    }\n\n}\n", "idx": 25713}
{"project": "qemu", "commit_id": "eaf944a43835399f12808aebd0d0a1db6249ed07", "target": 1, "func": "static int blkdebug_open(BlockDriverState *bs, QDict *options, int flags,\n\n                         Error **errp)\n\n{\n\n    BDRVBlkdebugState *s = bs->opaque;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n    const char *config;\n\n    uint64_t align;\n\n    int ret;\n\n\n\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    /* Read rules from config file or command line options */\n\n    config = qemu_opt_get(opts, \"config\");\n\n    ret = read_config(s, config, options, errp);\n\n    if (ret) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Set initial state */\n\n    s->state = 1;\n\n\n\n    /* Open the backing file */\n\n    ret = bdrv_open_image(&bs->file, qemu_opt_get(opts, \"x-image\"), options, \"image\",\n\n                          flags, true, false, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n    }\n\n\n\n    /* Set request alignment */\n\n    align = qemu_opt_get_size(opts, \"align\", bs->request_alignment);\n\n    if (align > 0 && align < INT_MAX && !(align & (align - 1))) {\n\n        bs->request_alignment = align;\n\n    } else {\n\n        error_setg(errp, \"Invalid alignment\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    ret = 0;\n\nfail:\n\n    qemu_opts_del(opts);\n\n    return ret;\n\n}\n", "idx": 25714}
{"project": "qemu", "commit_id": "d861b05ea30e6ac177de9b679da96194ebe21afc", "target": 1, "func": "static int ne2000_can_receive(void *opaque)\n\n{\n\n    NE2000State *s = opaque;\n\n    int avail, index, boundary;\n\n    \n\n    if (s->cmd & E8390_STOP)\n\n        return 0;\n\n    index = s->curpag << 8;\n\n    boundary = s->boundary << 8;\n\n    if (index < boundary)\n\n        avail = boundary - index;\n\n    else\n\n        avail = (s->stop - s->start) - (index - boundary);\n\n    if (avail < (MAX_ETH_FRAME_SIZE + 4))\n\n        return 0;\n\n    return MAX_ETH_FRAME_SIZE;\n\n}\n", "idx": 25715}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtoll_invalid(void)\n\n{\n\n    const char *str = \"   xxxx  \\t abc\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    int64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoll(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n", "idx": 25716}
{"project": "qemu", "commit_id": "baf35cb90204d75404892aa4e52628ae7a00669b", "target": 1, "func": "void qemu_aio_init(void)\n\n{\n\n    struct sigaction act;\n\n\n\n    aio_initialized = 1;\n\n\n\n    sigfillset(&act.sa_mask);\n\n    act.sa_flags = 0; /* do not restart syscalls to interrupt select() */\n\n    act.sa_handler = aio_signal_handler;\n\n    sigaction(aio_sig_num, &act, NULL);\n\n\n\n#if defined(__GLIBC__) && defined(__linux__)\n\n    {\n\n        /* XXX: aio thread exit seems to hang on RedHat 9 and this init\n\n           seems to fix the problem. */\n\n        struct aioinit ai;\n\n        memset(&ai, 0, sizeof(ai));\n\n        ai.aio_threads = 1;\n\n        ai.aio_num = 1;\n\n        ai.aio_idle_time = 365 * 100000;\n\n        aio_init(&ai);\n\n    }\n\n#endif\n\n}\n", "idx": 25717}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_type_enum(Visitor *v, int *obj, const char *strings[],\n\n                     const char *kind, const char *name, Error **errp)\n\n{\n\n    if (!error_is_set(errp)) {\n\n        v->type_enum(v, obj, strings, kind, name, errp);\n\n    }\n\n}\n", "idx": 25719}
{"project": "qemu", "commit_id": "77cb0f5aafc8e6d0c6d3c339f381c9b7921648e0", "target": 1, "func": "static void adb_keyboard_event(DeviceState *dev, QemuConsole *src,\n\n                               InputEvent *evt)\n\n{\n\n    KBDState *s = (KBDState *)dev;\n\n    int qcode, keycode;\n\n\n\n    qcode = qemu_input_key_value_to_qcode(evt->u.key.data->key);\n\n    if (qcode >= ARRAY_SIZE(qcode_to_adb_keycode)) {\n\n        return;\n\n    }\n\n    /* FIXME: take handler into account when translating qcode */\n\n    keycode = qcode_to_adb_keycode[qcode];\n\n    if (keycode == NO_KEY) {  /* We don't want to send this to the guest */\n\n        ADB_DPRINTF(\"Ignoring NO_KEY\\n\");\n\n        return;\n\n    }\n\n    if (evt->u.key.data->down == false) { /* if key release event */\n\n        keycode = keycode | 0x80;   /* create keyboard break code */\n\n    }\n\n\n\n    adb_kbd_put_keycode(s, keycode);\n\n}\n", "idx": 25721}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void iscsi_retry_timer_expired(void *opaque)\n\n{\n\n    struct IscsiTask *iTask = opaque;\n\n    iTask->complete = 1;\n\n    if (iTask->co) {\n\n        qemu_coroutine_enter(iTask->co, NULL);\n\n    }\n\n}\n", "idx": 25723}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void zynq_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    ObjectClass *cpu_oc;\n\n    ARMCPU *cpu;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ext_ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ocm_ram = g_new(MemoryRegion, 1);\n\n    DeviceState *dev;\n\n    SysBusDevice *busdev;\n\n    qemu_irq pic[64];\n\n    Error *err = NULL;\n\n    int n;\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"cortex-a9\";\n\n    }\n\n    cpu_oc = cpu_class_by_name(TYPE_ARM_CPU, cpu_model);\n\n\n\n    cpu = ARM_CPU(object_new(object_class_get_name(cpu_oc)));\n\n\n\n    /* By default A9 CPUs have EL3 enabled.  This board does not\n\n     * currently support EL3 so the CPU EL3 property is disabled before\n\n     * realization.\n\n     */\n\n    if (object_property_find(OBJECT(cpu), \"has_el3\", NULL)) {\n\n        object_property_set_bool(OBJECT(cpu), false, \"has_el3\", &err);\n\n        if (err) {\n\n            error_report_err(err);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    object_property_set_int(OBJECT(cpu), ZYNQ_BOARD_MIDR, \"midr\", &err);\n\n    if (err) {\n\n        error_report_err(err);\n\n        exit(1);\n\n    }\n\n\n\n    object_property_set_int(OBJECT(cpu), MPCORE_PERIPHBASE, \"reset-cbar\", &err);\n\n    if (err) {\n\n        error_report_err(err);\n\n        exit(1);\n\n    }\n\n    object_property_set_bool(OBJECT(cpu), true, \"realized\", &err);\n\n    if (err) {\n\n        error_report_err(err);\n\n        exit(1);\n\n    }\n\n\n\n    /* max 2GB ram */\n\n    if (ram_size > 0x80000000) {\n\n        ram_size = 0x80000000;\n\n    }\n\n\n\n    /* DDR remapped to address zero.  */\n\n    memory_region_allocate_system_memory(ext_ram, NULL, \"zynq.ext_ram\",\n\n                                         ram_size);\n\n    memory_region_add_subregion(address_space_mem, 0, ext_ram);\n\n\n\n    /* 256K of on-chip memory */\n\n    memory_region_init_ram(ocm_ram, NULL, \"zynq.ocm_ram\", 256 << 10,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(ocm_ram);\n\n    memory_region_add_subregion(address_space_mem, 0xFFFC0000, ocm_ram);\n\n\n\n    DriveInfo *dinfo = drive_get(IF_PFLASH, 0, 0);\n\n\n\n    /* AMD */\n\n    pflash_cfi02_register(0xe2000000, NULL, \"zynq.pflash\", FLASH_SIZE,\n\n                          dinfo ? blk_by_legacy_dinfo(dinfo) : NULL,\n\n                          FLASH_SECTOR_SIZE,\n\n                          FLASH_SIZE/FLASH_SECTOR_SIZE, 1,\n\n                          1, 0x0066, 0x0022, 0x0000, 0x0000, 0x0555, 0x2aa,\n\n                              0);\n\n\n\n    dev = qdev_create(NULL, \"xilinx,zynq_slcr\");\n\n    qdev_init_nofail(dev);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xF8000000);\n\n\n\n    dev = qdev_create(NULL, \"a9mpcore_priv\");\n\n    qdev_prop_set_uint32(dev, \"num-cpu\", 1);\n\n    qdev_init_nofail(dev);\n\n    busdev = SYS_BUS_DEVICE(dev);\n\n    sysbus_mmio_map(busdev, 0, MPCORE_PERIPHBASE);\n\n    sysbus_connect_irq(busdev, 0,\n\n                       qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_IRQ));\n\n\n\n    for (n = 0; n < 64; n++) {\n\n        pic[n] = qdev_get_gpio_in(dev, n);\n\n    }\n\n\n\n    zynq_init_spi_flashes(0xE0006000, pic[58-IRQ_OFFSET], false);\n\n    zynq_init_spi_flashes(0xE0007000, pic[81-IRQ_OFFSET], false);\n\n    zynq_init_spi_flashes(0xE000D000, pic[51-IRQ_OFFSET], true);\n\n\n\n    sysbus_create_simple(\"xlnx,ps7-usb\", 0xE0002000, pic[53-IRQ_OFFSET]);\n\n    sysbus_create_simple(\"xlnx,ps7-usb\", 0xE0003000, pic[76-IRQ_OFFSET]);\n\n\n\n    sysbus_create_simple(\"cadence_uart\", 0xE0000000, pic[59-IRQ_OFFSET]);\n\n    sysbus_create_simple(\"cadence_uart\", 0xE0001000, pic[82-IRQ_OFFSET]);\n\n\n\n    sysbus_create_varargs(\"cadence_ttc\", 0xF8001000,\n\n            pic[42-IRQ_OFFSET], pic[43-IRQ_OFFSET], pic[44-IRQ_OFFSET], NULL);\n\n    sysbus_create_varargs(\"cadence_ttc\", 0xF8002000,\n\n            pic[69-IRQ_OFFSET], pic[70-IRQ_OFFSET], pic[71-IRQ_OFFSET], NULL);\n\n\n\n    gem_init(&nd_table[0], 0xE000B000, pic[54-IRQ_OFFSET]);\n\n    gem_init(&nd_table[1], 0xE000C000, pic[77-IRQ_OFFSET]);\n\n\n\n    dev = qdev_create(NULL, \"generic-sdhci\");\n\n    qdev_init_nofail(dev);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xE0100000);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, pic[56-IRQ_OFFSET]);\n\n\n\n    dev = qdev_create(NULL, \"generic-sdhci\");\n\n    qdev_init_nofail(dev);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xE0101000);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, pic[79-IRQ_OFFSET]);\n\n\n\n    dev = qdev_create(NULL, \"pl330\");\n\n    qdev_prop_set_uint8(dev, \"num_chnls\",  8);\n\n    qdev_prop_set_uint8(dev, \"num_periph_req\",  4);\n\n    qdev_prop_set_uint8(dev, \"num_events\",  16);\n\n\n\n    qdev_prop_set_uint8(dev, \"data_width\",  64);\n\n    qdev_prop_set_uint8(dev, \"wr_cap\",  8);\n\n    qdev_prop_set_uint8(dev, \"wr_q_dep\",  16);\n\n    qdev_prop_set_uint8(dev, \"rd_cap\",  8);\n\n    qdev_prop_set_uint8(dev, \"rd_q_dep\",  16);\n\n    qdev_prop_set_uint16(dev, \"data_buffer_dep\",  256);\n\n\n\n    qdev_init_nofail(dev);\n\n    busdev = SYS_BUS_DEVICE(dev);\n\n    sysbus_mmio_map(busdev, 0, 0xF8003000);\n\n    sysbus_connect_irq(busdev, 0, pic[45-IRQ_OFFSET]); /* abort irq line */\n\n    for (n = 0; n < 8; ++n) { /* event irqs */\n\n        sysbus_connect_irq(busdev, n + 1, pic[dma_irqs[n] - IRQ_OFFSET]);\n\n    }\n\n\n\n    zynq_binfo.ram_size = ram_size;\n\n    zynq_binfo.kernel_filename = kernel_filename;\n\n    zynq_binfo.kernel_cmdline = kernel_cmdline;\n\n    zynq_binfo.initrd_filename = initrd_filename;\n\n    zynq_binfo.nb_cpus = 1;\n\n    zynq_binfo.board_id = 0xd32;\n\n    zynq_binfo.loader_start = 0;\n\n    arm_load_kernel(ARM_CPU(first_cpu), &zynq_binfo);\n\n}\n", "idx": 25724}
{"project": "qemu", "commit_id": "aedbe19297907143f17b733a7ff0e0534377bed1", "target": 1, "func": "int qemu_shutdown_requested_get(void)\n\n{\n\n    return shutdown_requested;\n\n}\n", "idx": 25725}
{"project": "qemu", "commit_id": "a005b3ef50439b5bc6b2eb0b5bda8e8c7c2368bf", "target": 1, "func": "static void spapr_phb_realize(DeviceState *dev, Error **errp)\n\n{\n\n    sPAPRMachineState *spapr = SPAPR_MACHINE(qdev_get_machine());\n\n    SysBusDevice *s = SYS_BUS_DEVICE(dev);\n\n    sPAPRPHBState *sphb = SPAPR_PCI_HOST_BRIDGE(s);\n\n    PCIHostState *phb = PCI_HOST_BRIDGE(s);\n\n    sPAPRPHBClass *info = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(s);\n\n    char *namebuf;\n\n    int i;\n\n    PCIBus *bus;\n\n    uint64_t msi_window_size = 4096;\n\n\n\n    if (sphb->index != (uint32_t)-1) {\n\n        hwaddr windows_base;\n\n\n\n        if ((sphb->buid != (uint64_t)-1) || (sphb->dma_liobn != (uint32_t)-1)\n\n            || (sphb->mem_win_addr != (hwaddr)-1)\n\n            || (sphb->io_win_addr != (hwaddr)-1)) {\n\n            error_setg(errp, \"Either \\\"index\\\" or other parameters must\"\n\n                       \" be specified for PAPR PHB, not both\");\n\n            return;\n\n        }\n\n\n\n        if (sphb->index > SPAPR_PCI_MAX_INDEX) {\n\n            error_setg(errp, \"\\\"index\\\" for PAPR PHB is too large (max %u)\",\n\n                       SPAPR_PCI_MAX_INDEX);\n\n            return;\n\n        }\n\n\n\n        sphb->buid = SPAPR_PCI_BASE_BUID + sphb->index;\n\n        sphb->dma_liobn = SPAPR_PCI_LIOBN(sphb->index, 0);\n\n\n\n        windows_base = SPAPR_PCI_WINDOW_BASE\n\n            + sphb->index * SPAPR_PCI_WINDOW_SPACING;\n\n        sphb->mem_win_addr = windows_base + SPAPR_PCI_MMIO_WIN_OFF;\n\n        sphb->io_win_addr = windows_base + SPAPR_PCI_IO_WIN_OFF;\n\n    }\n\n\n\n    if (sphb->buid == (uint64_t)-1) {\n\n        error_setg(errp, \"BUID not specified for PHB\");\n\n        return;\n\n    }\n\n\n\n    if (sphb->dma_liobn == (uint32_t)-1) {\n\n        error_setg(errp, \"LIOBN not specified for PHB\");\n\n        return;\n\n    }\n\n\n\n    if (sphb->mem_win_addr == (hwaddr)-1) {\n\n        error_setg(errp, \"Memory window address not specified for PHB\");\n\n        return;\n\n    }\n\n\n\n    if (sphb->io_win_addr == (hwaddr)-1) {\n\n        error_setg(errp, \"IO window address not specified for PHB\");\n\n        return;\n\n    }\n\n\n\n    if (spapr_pci_find_phb(spapr, sphb->buid)) {\n\n        error_setg(errp, \"PCI host bridges must have unique BUIDs\");\n\n        return;\n\n    }\n\n\n\n    sphb->dtbusname = g_strdup_printf(\"pci@%\" PRIx64, sphb->buid);\n\n\n\n    namebuf = alloca(strlen(sphb->dtbusname) + 32);\n\n\n\n    /* Initialize memory regions */\n\n    sprintf(namebuf, \"%s.mmio\", sphb->dtbusname);\n\n    memory_region_init(&sphb->memspace, OBJECT(sphb), namebuf, UINT64_MAX);\n\n\n\n    sprintf(namebuf, \"%s.mmio-alias\", sphb->dtbusname);\n\n    memory_region_init_alias(&sphb->memwindow, OBJECT(sphb),\n\n                             namebuf, &sphb->memspace,\n\n                             SPAPR_PCI_MEM_WIN_BUS_OFFSET, sphb->mem_win_size);\n\n    memory_region_add_subregion(get_system_memory(), sphb->mem_win_addr,\n\n                                &sphb->memwindow);\n\n\n\n    /* Initialize IO regions */\n\n    sprintf(namebuf, \"%s.io\", sphb->dtbusname);\n\n    memory_region_init(&sphb->iospace, OBJECT(sphb),\n\n                       namebuf, SPAPR_PCI_IO_WIN_SIZE);\n\n\n\n    sprintf(namebuf, \"%s.io-alias\", sphb->dtbusname);\n\n    memory_region_init_alias(&sphb->iowindow, OBJECT(sphb), namebuf,\n\n                             &sphb->iospace, 0, SPAPR_PCI_IO_WIN_SIZE);\n\n    memory_region_add_subregion(get_system_memory(), sphb->io_win_addr,\n\n                                &sphb->iowindow);\n\n\n\n    bus = pci_register_bus(dev, NULL,\n\n                           pci_spapr_set_irq, pci_spapr_map_irq, sphb,\n\n                           &sphb->memspace, &sphb->iospace,\n\n                           PCI_DEVFN(0, 0), PCI_NUM_PINS, TYPE_PCI_BUS);\n\n    phb->bus = bus;\n\n    qbus_set_hotplug_handler(BUS(phb->bus), DEVICE(sphb), NULL);\n\n\n\n    /*\n\n     * Initialize PHB address space.\n\n     * By default there will be at least one subregion for default\n\n     * 32bit DMA window.\n\n     * Later the guest might want to create another DMA window\n\n     * which will become another memory subregion.\n\n     */\n\n    sprintf(namebuf, \"%s.iommu-root\", sphb->dtbusname);\n\n\n\n    memory_region_init(&sphb->iommu_root, OBJECT(sphb),\n\n                       namebuf, UINT64_MAX);\n\n    address_space_init(&sphb->iommu_as, &sphb->iommu_root,\n\n                       sphb->dtbusname);\n\n\n\n    /*\n\n     * As MSI/MSIX interrupts trigger by writing at MSI/MSIX vectors,\n\n     * we need to allocate some memory to catch those writes coming\n\n     * from msi_notify()/msix_notify().\n\n     * As MSIMessage:addr is going to be the same and MSIMessage:data\n\n     * is going to be a VIRQ number, 4 bytes of the MSI MR will only\n\n     * be used.\n\n     *\n\n     * For KVM we want to ensure that this memory is a full page so that\n\n     * our memory slot is of page size granularity.\n\n     */\n\n#ifdef CONFIG_KVM\n\n    if (kvm_enabled()) {\n\n        msi_window_size = getpagesize();\n\n    }\n\n#endif\n\n\n\n    memory_region_init_io(&sphb->msiwindow, NULL, &spapr_msi_ops, spapr,\n\n                          \"msi\", msi_window_size);\n\n    memory_region_add_subregion(&sphb->iommu_root, SPAPR_PCI_MSI_WINDOW,\n\n                                &sphb->msiwindow);\n\n\n\n    pci_setup_iommu(bus, spapr_pci_dma_iommu, sphb);\n\n\n\n    pci_bus_set_route_irq_fn(bus, spapr_route_intx_pin_to_irq);\n\n\n\n    QLIST_INSERT_HEAD(&spapr->phbs, sphb, list);\n\n\n\n    /* Initialize the LSI table */\n\n    for (i = 0; i < PCI_NUM_PINS; i++) {\n\n        uint32_t irq;\n\n\n\n        irq = xics_alloc_block(spapr->icp, 0, 1, true, false);\n\n        if (!irq) {\n\n            error_setg(errp, \"spapr_allocate_lsi failed\");\n\n            return;\n\n        }\n\n\n\n        sphb->lsi_table[i].irq = irq;\n\n    }\n\n\n\n    /* allocate connectors for child PCI devices */\n\n    if (sphb->dr_enabled) {\n\n        for (i = 0; i < PCI_SLOT_MAX * 8; i++) {\n\n            spapr_dr_connector_new(OBJECT(phb),\n\n                                   SPAPR_DR_CONNECTOR_TYPE_PCI,\n\n                                   (sphb->index << 16) | i);\n\n        }\n\n    }\n\n\n\n    if (!info->finish_realize) {\n\n        error_setg(errp, \"finish_realize not defined\");\n\n        return;\n\n    }\n\n\n\n    info->finish_realize(sphb, errp);\n\n\n\n    sphb->msi = g_hash_table_new_full(g_int_hash, g_int_equal, g_free, g_free);\n\n}\n", "idx": 25726}
{"project": "qemu", "commit_id": "d3f8d37fe2d0c24ec8bac9c94d5b0e2dc09c0d2a", "target": 1, "func": "static int kvm_dirty_pages_log_change(target_phys_addr_t phys_addr, target_phys_addr_t end_addr,\n\n                                      unsigned flags,\n\n                                      unsigned mask)\n\n{\n\n    KVMState *s = kvm_state;\n\n    KVMSlot *mem = kvm_lookup_slot(s, phys_addr);\n\n    if (mem == NULL)  {\n\n            dprintf(\"invalid parameters %llx-%llx\\n\", phys_addr, end_addr);\n\n            return -EINVAL;\n\n    }\n\n\n\n    flags = (mem->flags & ~mask) | flags;\n\n    /* Nothing changed, no need to issue ioctl */\n\n    if (flags == mem->flags)\n\n            return 0;\n\n\n\n    mem->flags = flags;\n\n\n\n    return kvm_set_user_memory_region(s, mem);\n\n}\n", "idx": 25728}
{"project": "qemu", "commit_id": "47c6d3ecdfc3fc354cf996f873a9f854c2325160", "target": 1, "func": "static const QObject *qmp_input_get_object(QmpInputVisitor *qiv,\n\n                                           const char *name)\n\n{\n\n    const QObject *qobj;\n\n\n\n    if (qiv->nb_stack == 0) {\n\n        qobj = qiv->obj;\n\n    } else {\n\n        qobj = qiv->stack[qiv->nb_stack - 1].obj;\n\n    }\n\n\n\n    if (name && qobject_type(qobj) == QTYPE_QDICT) {\n\n        return qdict_get(qobject_to_qdict(qobj), name);\n\n    } else if (qiv->nb_stack > 0 && qobject_type(qobj) == QTYPE_QLIST) {\n\n        return qlist_entry_obj(qiv->stack[qiv->nb_stack - 1].entry);\n\n    }\n\n\n\n    return qobj;\n\n}\n", "idx": 25734}
{"project": "qemu", "commit_id": "b0ad5a455d7e5352d4c86ba945112011dbeadfb8", "target": 1, "func": "static inline int is_bit_set(BlockDriverState *bs, int64_t bitnum)\n\n{\n\n    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;\n\n    uint8_t bitmap;\n\n\n\n    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=\n\n\t    sizeof(bitmap)) {\n\n       return -errno;\n\n    }\n\n\n\n    return !!(bitmap & (1 << (bitnum % 8)));\n\n}\n", "idx": 25735}
{"project": "qemu", "commit_id": "e4858974ec36afd8a6b3a9e2b0ad8f357f28efc7", "target": 1, "func": "bool st_init(const char *file)\n\n{\n\n    pthread_t thread;\n\n    pthread_attr_t attr;\n\n    sigset_t set, oldset;\n\n    int ret;\n\n\n\n    pthread_attr_init(&attr);\n\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n\n\n    sigfillset(&set);\n\n    pthread_sigmask(SIG_SETMASK, &set, &oldset);\n\n    ret = pthread_create(&thread, &attr, writeout_thread, NULL);\n\n    pthread_sigmask(SIG_SETMASK, &oldset, NULL);\n\n\n\n    if (ret != 0) {\n\n        return false;\n\n    }\n\n\n\n    atexit(st_flush_trace_buffer);\n\n    st_set_trace_file(file);\n\n    return true;\n\n}\n", "idx": 25736}
{"project": "qemu", "commit_id": "469f3da42ef4af347fa7831e1cc0bd35d17f5b83", "target": 1, "func": "static void aspeed_soc_class_init(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    AspeedSoCClass *sc = ASPEED_SOC_CLASS(oc);\n\n\n\n    sc->info = (AspeedSoCInfo *) data;\n\n    dc->realize = aspeed_soc_realize;\n\n\n\n}", "idx": 25740}
{"project": "qemu", "commit_id": "0d4cc3e715f5794077895345577725539afe81eb", "target": 1, "func": "static int vpc_write(BlockDriverState *bs, int64_t sector_num,\n\n    const uint8_t *buf, int nb_sectors)\n\n{\n\n    BDRVVPCState *s = bs->opaque;\n\n    int64_t offset;\n\n    int64_t sectors, sectors_per_block;\n\n    int ret;\n\n    VHDFooter *footer =  (VHDFooter *) s->footer_buf;\n\n\n\n    if (cpu_to_be32(footer->type) == VHD_FIXED) {\n\n        return bdrv_write(bs->file, sector_num, buf, nb_sectors);\n\n    }\n\n    while (nb_sectors > 0) {\n\n        offset = get_sector_offset(bs, sector_num, 1);\n\n\n\n        sectors_per_block = s->block_size >> BDRV_SECTOR_BITS;\n\n        sectors = sectors_per_block - (sector_num % sectors_per_block);\n\n        if (sectors > nb_sectors) {\n\n            sectors = nb_sectors;\n\n        }\n\n\n\n        if (offset == -1) {\n\n            offset = alloc_block(bs, sector_num);\n\n            if (offset < 0)\n\n                return -1;\n\n        }\n\n\n\n        ret = bdrv_pwrite(bs->file, offset, buf, sectors * BDRV_SECTOR_SIZE);\n\n        if (ret != sectors * BDRV_SECTOR_SIZE) {\n\n            return -1;\n\n        }\n\n\n\n        nb_sectors -= sectors;\n\n        sector_num += sectors;\n\n        buf += sectors * BDRV_SECTOR_SIZE;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 25741}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void ibm_40p_init(MachineState *machine)\n\n{\n\n    CPUPPCState *env = NULL;\n\n    uint16_t cmos_checksum;\n\n    PowerPCCPU *cpu;\n\n    DeviceState *dev;\n\n    SysBusDevice *pcihost;\n\n    Nvram *m48t59 = NULL;\n\n    PCIBus *pci_bus;\n\n    ISABus *isa_bus;\n\n    void *fw_cfg;\n\n    int i;\n\n    uint32_t kernel_base = 0, initrd_base = 0;\n\n    long kernel_size = 0, initrd_size = 0;\n\n    char boot_device;\n\n\n\n    /* init CPU */\n\n    if (!machine->cpu_model) {\n\n        machine->cpu_model = \"604\";\n\n    }\n\n    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, machine->cpu_model));\n\n    if (!cpu) {\n\n        error_report(\"could not initialize CPU '%s'\",\n\n                     machine->cpu_model);\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n    if (PPC_INPUT(env) != PPC_FLAGS_INPUT_6xx) {\n\n        error_report(\"only 6xx bus is supported on this machine\");\n\n        exit(1);\n\n    }\n\n\n\n    if (env->flags & POWERPC_FLAG_RTC_CLK) {\n\n        /* POWER / PowerPC 601 RTC clock frequency is 7.8125 MHz */\n\n        cpu_ppc_tb_init(env, 7812500UL);\n\n    } else {\n\n        /* Set time-base frequency to 100 Mhz */\n\n        cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);\n\n    }\n\n    qemu_register_reset(ppc_prep_reset, cpu);\n\n\n\n    /* PCI host */\n\n    dev = qdev_create(NULL, \"raven-pcihost\");\n\n    if (!bios_name) {\n\n        bios_name = BIOS_FILENAME;\n\n    }\n\n    qdev_prop_set_string(dev, \"bios-name\", bios_name);\n\n    qdev_prop_set_uint32(dev, \"elf-machine\", PPC_ELF_MACHINE);\n\n    pcihost = SYS_BUS_DEVICE(dev);\n\n    object_property_add_child(qdev_get_machine(), \"raven\", OBJECT(dev), NULL);\n\n    qdev_init_nofail(dev);\n\n    pci_bus = PCI_BUS(qdev_get_child_bus(dev, \"pci.0\"));\n\n    if (!pci_bus) {\n\n        error_report(\"could not create PCI host controller\");\n\n        exit(1);\n\n    }\n\n\n\n    /* PCI -> ISA bridge */\n\n    dev = DEVICE(pci_create_simple(pci_bus, PCI_DEVFN(11, 0), \"i82378\"));\n\n    qdev_connect_gpio_out(dev, 0,\n\n                          cpu->env.irq_inputs[PPC6xx_INPUT_INT]);\n\n    sysbus_connect_irq(pcihost, 0, qdev_get_gpio_in(dev, 15));\n\n    sysbus_connect_irq(pcihost, 1, qdev_get_gpio_in(dev, 13));\n\n    sysbus_connect_irq(pcihost, 2, qdev_get_gpio_in(dev, 15));\n\n    sysbus_connect_irq(pcihost, 3, qdev_get_gpio_in(dev, 13));\n\n    isa_bus = ISA_BUS(qdev_get_child_bus(dev, \"isa.0\"));\n\n\n\n    /* Memory controller */\n\n    dev = DEVICE(isa_create(isa_bus, \"rs6000-mc\"));\n\n    qdev_prop_set_uint32(dev, \"ram-size\", machine->ram_size);\n\n    qdev_init_nofail(dev);\n\n\n\n    /* initialize CMOS checksums */\n\n    cmos_checksum = 0x6aa9;\n\n    qbus_walk_children(BUS(isa_bus), prep_set_cmos_checksum, NULL, NULL, NULL,\n\n                       &cmos_checksum);\n\n\n\n    /* add some more devices */\n\n    if (defaults_enabled()) {\n\n        isa_create_simple(isa_bus, \"i8042\");\n\n        m48t59 = NVRAM(isa_create_simple(isa_bus, \"isa-m48t59\"));\n\n\n\n        dev = DEVICE(isa_create(isa_bus, \"cs4231a\"));\n\n        qdev_prop_set_uint32(dev, \"iobase\", 0x830);\n\n        qdev_prop_set_uint32(dev, \"irq\", 10);\n\n        qdev_init_nofail(dev);\n\n\n\n        dev = DEVICE(isa_create(isa_bus, \"pc87312\"));\n\n        qdev_prop_set_uint32(dev, \"config\", 12);\n\n        qdev_init_nofail(dev);\n\n\n\n        dev = DEVICE(isa_create(isa_bus, \"prep-systemio\"));\n\n        qdev_prop_set_uint32(dev, \"ibm-planar-id\", 0xfc);\n\n        qdev_prop_set_uint32(dev, \"equipment\", 0xc0);\n\n        qdev_init_nofail(dev);\n\n\n\n        pci_create_simple(pci_bus, PCI_DEVFN(1, 0), \"lsi53c810\");\n\n\n\n        /* XXX: s3-trio at PCI_DEVFN(2, 0) */\n\n        pci_vga_init(pci_bus);\n\n\n\n        for (i = 0; i < nb_nics; i++) {\n\n            pci_nic_init_nofail(&nd_table[i], pci_bus, \"pcnet\",\n\n                                i == 0 ? \"3\" : NULL);\n\n        }\n\n    }\n\n\n\n    /* Prepare firmware configuration for OpenBIOS */\n\n    fw_cfg = fw_cfg_init_mem(CFG_ADDR, CFG_ADDR + 2);\n\n\n\n    if (machine->kernel_filename) {\n\n        /* load kernel */\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n        kernel_size = load_image_targphys(machine->kernel_filename,\n\n                                          kernel_base,\n\n                                          machine->ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            error_report(\"could not load kernel '%s'\",\n\n                         machine->kernel_filename);\n\n            exit(1);\n\n        }\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, kernel_base);\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\n\n        /* load initrd */\n\n        if (machine->initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image_targphys(machine->initrd_filename,\n\n                                              initrd_base,\n\n                                              machine->ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                error_report(\"could not load initial ram disk '%s'\",\n\n                             machine->initrd_filename);\n\n                exit(1);\n\n            }\n\n            fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, initrd_base);\n\n            fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\n\n        }\n\n        if (machine->kernel_cmdline && *machine->kernel_cmdline) {\n\n            fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);\n\n            pstrcpy_targphys(\"cmdline\", CMDLINE_ADDR, TARGET_PAGE_SIZE,\n\n                             machine->kernel_cmdline);\n\n            fw_cfg_add_string(fw_cfg, FW_CFG_CMDLINE_DATA,\n\n                              machine->kernel_cmdline);\n\n            fw_cfg_add_i32(fw_cfg, FW_CFG_CMDLINE_SIZE,\n\n                           strlen(machine->kernel_cmdline) + 1);\n\n        }\n\n        boot_device = 'm';\n\n    } else {\n\n        boot_device = machine->boot_order[0];\n\n    }\n\n\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MAX_CPUS, (uint16_t)max_cpus);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)machine->ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, ARCH_PREP);\n\n\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_WIDTH, graphic_width);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_HEIGHT, graphic_height);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_DEPTH, graphic_depth);\n\n\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_IS_KVM, kvm_enabled());\n\n    if (kvm_enabled()) {\n\n#ifdef CONFIG_KVM\n\n        uint8_t *hypercall;\n\n\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, kvmppc_get_tbfreq());\n\n        hypercall = g_malloc(16);\n\n        kvmppc_get_hypercall(env, hypercall, 16);\n\n        fw_cfg_add_bytes(fw_cfg, FW_CFG_PPC_KVM_HC, hypercall, 16);\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_KVM_PID, getpid());\n\n#endif\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, NANOSECONDS_PER_SECOND);\n\n    }\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, boot_device);\n\n    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);\n\n\n\n    /* Prepare firmware configuration for Open Hack'Ware */\n\n    if (m48t59) {\n\n        PPC_NVRAM_set_params(m48t59, NVRAM_SIZE, \"PREP\", ram_size,\n\n                             boot_device,\n\n                             kernel_base, kernel_size,\n\n                             machine->kernel_cmdline,\n\n                             initrd_base, initrd_size,\n\n                             /* XXX: need an option to load a NVRAM image */\n\n                             0,\n\n                             graphic_width, graphic_height, graphic_depth);\n\n    }\n\n}\n", "idx": 25746}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static void *iommu_init(target_phys_addr_t addr, uint32_t version, qemu_irq irq)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n\n\n    dev = qdev_create(NULL, \"iommu\");\n\n    qdev_prop_set_uint32(dev, \"version\", version);\n\n    qdev_init(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_mmio_map(s, 0, addr);\n\n\n\n    return s;\n\n}\n", "idx": 25747}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtoull_full_empty(void)\n\n{\n\n    const char *str = \"\";\n\n    uint64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoull(str, NULL, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 0);\n\n}\n", "idx": 25749}
{"project": "qemu", "commit_id": "d4d34b0d3f5af5c8e09980da0de2eebe9a27dc71", "target": 0, "func": "static void get_pointer(Object *obj, Visitor *v, Property *prop,\n\n                        const char *(*print)(void *ptr),\n\n                        const char *name, Error **errp)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    void **ptr = qdev_get_prop_ptr(dev, prop);\n\n    char *p;\n\n\n\n    p = (char *) (*ptr ? print(*ptr) : \"\");\n\n    visit_type_str(v, &p, name, errp);\n\n}\n", "idx": 25751}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t jazz_led_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned int size)\n\n{\n\n    LedState *s = opaque;\n\n    uint8_t val;\n\n\n\n    val = s->segments;\n\n    trace_jazz_led_read(addr, val);\n\n\n\n    return val;\n\n}\n", "idx": 25752}
{"project": "qemu", "commit_id": "7264961934130df50d151def5eb415efa2e28ec5", "target": 0, "func": "exynos4_boards_init_common(MachineState *machine,\n\n                           Exynos4BoardType board_type)\n\n{\n\n    Exynos4BoardState *s = g_new(Exynos4BoardState, 1);\n\n    MachineClass *mc = MACHINE_GET_CLASS(machine);\n\n\n\n    if (smp_cpus != EXYNOS4210_NCPUS && !qtest_enabled()) {\n\n        error_report(\"%s board supports only %d CPU cores, ignoring smp_cpus\"\n\n                     \" value\",\n\n                     mc->name, EXYNOS4210_NCPUS);\n\n    }\n\n\n\n    exynos4_board_binfo.ram_size = exynos4_board_ram_size[board_type];\n\n    exynos4_board_binfo.board_id = exynos4_board_id[board_type];\n\n    exynos4_board_binfo.smp_bootreg_addr =\n\n            exynos4_board_smp_bootreg_addr[board_type];\n\n    exynos4_board_binfo.kernel_filename = machine->kernel_filename;\n\n    exynos4_board_binfo.initrd_filename = machine->initrd_filename;\n\n    exynos4_board_binfo.kernel_cmdline = machine->kernel_cmdline;\n\n    exynos4_board_binfo.gic_cpu_if_addr =\n\n            EXYNOS4210_SMP_PRIVATE_BASE_ADDR + 0x100;\n\n\n\n    PRINT_DEBUG(\"\\n ram_size: %luMiB [0x%08lx]\\n\"\n\n            \" kernel_filename: %s\\n\"\n\n            \" kernel_cmdline: %s\\n\"\n\n            \" initrd_filename: %s\\n\",\n\n            exynos4_board_ram_size[board_type] / 1048576,\n\n            exynos4_board_ram_size[board_type],\n\n            machine->kernel_filename,\n\n            machine->kernel_cmdline,\n\n            machine->initrd_filename);\n\n\n\n    exynos4_boards_init_ram(s, get_system_memory(),\n\n                            exynos4_board_ram_size[board_type]);\n\n\n\n    s->soc = exynos4210_init(get_system_memory());\n\n\n\n    return s;\n\n}\n", "idx": 25753}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float32 HELPER(ucf64_divs)(float32 a, float32 b, CPUUniCore32State *env)\n\n{\n\n    return float32_div(a, b, &env->ucf64.fp_status);\n\n}\n", "idx": 25754}
{"project": "qemu", "commit_id": "fb7b5c0df6e3c501973ce4d57eb2b1d4344a519d", "target": 0, "func": "static void scsi_generic_class_initfn(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SCSIDeviceClass *sc = SCSI_DEVICE_CLASS(klass);\n\n\n\n    sc->realize      = scsi_generic_realize;\n\n    sc->unrealize    = scsi_unrealize;\n\n    sc->alloc_req    = scsi_new_request;\n\n    sc->parse_cdb    = scsi_generic_parse_cdb;\n\n    dc->fw_name = \"disk\";\n\n    dc->desc = \"pass through generic scsi device (/dev/sg*)\";\n\n    dc->reset = scsi_generic_reset;\n\n    dc->props = scsi_generic_properties;\n\n    dc->vmsd  = &vmstate_scsi_device;\n\n}\n", "idx": 25755}
{"project": "qemu", "commit_id": "91479dd0b5bd3b087b92ddd7bc3f2c54982cfe17", "target": 0, "func": "START_TEST(qlist_destroy_test)\n\n{\n\n    int i;\n\n    QList *qlist;\n\n\n\n    qlist = qlist_new();\n\n\n\n    for (i = 0; i < 42; i++)\n\n        qlist_append(qlist, qint_from_int(i));\n\n\n\n    QDECREF(qlist);\n\n}\n", "idx": 25756}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static void vnc_client_read(void *opaque)\n\n{\n\n    VncState *vs = opaque;\n\n    long ret;\n\n\n\n    buffer_reserve(&vs->input, 4096);\n\n\n\n#ifdef CONFIG_VNC_TLS\n\n    if (vs->tls_session) {\n\n\tret = gnutls_read(vs->tls_session, buffer_end(&vs->input), 4096);\n\n\tif (ret < 0) {\n\n\t    if (ret == GNUTLS_E_AGAIN)\n\n\t\terrno = EAGAIN;\n\n\t    else\n\n\t\terrno = EIO;\n\n\t    ret = -1;\n\n\t}\n\n    } else\n\n#endif /* CONFIG_VNC_TLS */\n\n\tret = recv(vs->csock, buffer_end(&vs->input), 4096, 0);\n\n    ret = vnc_client_io_error(vs, ret, socket_error());\n\n    if (!ret)\n\n\treturn;\n\n\n\n    vs->input.offset += ret;\n\n\n\n    while (vs->read_handler && vs->input.offset >= vs->read_handler_expect) {\n\n\tsize_t len = vs->read_handler_expect;\n\n\tint ret;\n\n\n\n\tret = vs->read_handler(vs, vs->input.buffer, len);\n\n\tif (vs->csock == -1)\n\n\t    return;\n\n\n\n\tif (!ret) {\n\n\t    memmove(vs->input.buffer, vs->input.buffer + len, (vs->input.offset - len));\n\n\t    vs->input.offset -= len;\n\n\t} else {\n\n\t    vs->read_handler_expect = ret;\n\n\t}\n\n    }\n\n}\n", "idx": 25757}
{"project": "qemu", "commit_id": "4171853cf4dfb88da93bf77a4c9d319d6ba2bdc6", "target": 0, "func": "POWERPC_FAMILY(e5500)(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);\n\n\n\n    dc->desc = \"e5500 core\";\n\n    pcc->init_proc = init_proc_e5500;\n\n    pcc->check_pow = check_pow_none;\n\n    pcc->insns_flags = PPC_INSNS_BASE | PPC_ISEL |\n\n                       PPC_WRTEE | PPC_RFDI | PPC_RFMCI |\n\n                       PPC_CACHE | PPC_CACHE_LOCK | PPC_CACHE_ICBI |\n\n                       PPC_CACHE_DCBZ | PPC_CACHE_DCBA |\n\n                       PPC_FLOAT | PPC_FLOAT_FRES |\n\n                       PPC_FLOAT_FRSQRTE | PPC_FLOAT_FSEL |\n\n                       PPC_FLOAT_STFIWX | PPC_WAIT |\n\n                       PPC_MEM_TLBSYNC | PPC_TLBIVAX | PPC_MEM_SYNC |\n\n                       PPC_64B | PPC_POPCNTB | PPC_POPCNTWD;\n\n    pcc->insns_flags2 = PPC2_BOOKE206 | PPC2_PRCNTL | PPC2_PERM_ISA206;\n\n    pcc->msr_mask = (1ull << MSR_CM) |\n\n                    (1ull << MSR_GS) |\n\n                    (1ull << MSR_UCLE) |\n\n                    (1ull << MSR_CE) |\n\n                    (1ull << MSR_EE) |\n\n                    (1ull << MSR_PR) |\n\n                    (1ull << MSR_FP) |\n\n                    (1ull << MSR_ME) |\n\n                    (1ull << MSR_FE0) |\n\n                    (1ull << MSR_DE) |\n\n                    (1ull << MSR_FE1) |\n\n                    (1ull << MSR_IR) |\n\n                    (1ull << MSR_DR) |\n\n                    (1ull << MSR_PX) |\n\n                    (1ull << MSR_RI);\n\n    pcc->mmu_model = POWERPC_MMU_BOOKE206;\n\n    pcc->excp_model = POWERPC_EXCP_BOOKE;\n\n    pcc->bus_model = PPC_FLAGS_INPUT_BookE;\n\n    /* FIXME: figure out the correct flag for e5500 */\n\n    pcc->bfd_mach = bfd_mach_ppc_e500;\n\n    pcc->flags = POWERPC_FLAG_CE | POWERPC_FLAG_DE |\n\n                 POWERPC_FLAG_PMM | POWERPC_FLAG_BUS_CLK;\n\n}\n", "idx": 25758}
{"project": "qemu", "commit_id": "beb3faaa0027c114e37317fdba38a8a7facf3f9b", "target": 0, "func": "int main()\n\n{\n\n    int rt, rs;\n\n    int achi, acli;\n\n    int dsp;\n\n    int acho, aclo;\n\n    int resulth, resultl;\n\n    int resdsp;\n\n\n\n    achi = 0x05;\n\n    acli = 0xB4CB;\n\n    rs  = 0xFF06;\n\n    rt  = 0xCB00;\n\n    resulth = 0x04;\n\n    resultl = 0x947438CB;\n\n\n\n    __asm\n\n        (\"mthi %2, $ac1\\n\\t\"\n\n         \"mtlo %3, $ac1\\n\\t\"\n\n         \"maq_s.w.phr $ac1, %4, %5\\n\\t\"\n\n         \"mfhi %0, $ac1\\n\\t\"\n\n         \"mflo %1, $ac1\\n\\t\"\n\n         : \"=r\"(acho), \"=r\"(aclo)\n\n         : \"r\"(achi), \"r\"(acli), \"r\"(rs), \"r\"(rt)\n\n        );\n\n    assert(resulth == acho);\n\n    assert(resultl == aclo);\n\n\n\n    achi = 0x06;\n\n    acli = 0xB4CB;\n\n    rs  = 0x8000;\n\n    rt  = 0x8000;\n\n    resulth = 0x6;\n\n    resultl = 0x8000b4ca;\n\n    resdsp = 1;\n\n\n\n    __asm\n\n        (\"mthi %3, $ac1\\n\\t\"\n\n         \"mtlo %4, $ac1\\n\\t\"\n\n         \"maq_s.w.phr $ac1, %5, %6\\n\\t\"\n\n         \"mfhi %0, $ac1\\n\\t\"\n\n         \"mflo %1, $ac1\\n\\t\"\n\n         \"rddsp %2\\n\\t\"\n\n         : \"=r\"(acho), \"=r\"(aclo), \"=r\"(dsp)\n\n         : \"r\"(achi), \"r\"(acli), \"r\"(rs), \"r\"(rt)\n\n        );\n\n    assert(resulth == acho);\n\n    assert(resultl == aclo);\n\n    assert(((dsp >> 17) & 0x01) == resdsp);\n\n\n\n    return 0;\n\n}\n", "idx": 25760}
{"project": "qemu", "commit_id": "27e0c9a1bbd166a67c16291016fba298a8e47140", "target": 0, "func": "int ide_init_drive(IDEState *s, BlockDriverState *bs, IDEDriveKind kind,\n\n                   const char *version, const char *serial)\n\n{\n\n    int cylinders, heads, secs;\n\n    uint64_t nb_sectors;\n\n\n\n    s->bs = bs;\n\n    s->drive_kind = kind;\n\n\n\n    bdrv_get_geometry(bs, &nb_sectors);\n\n    bdrv_guess_geometry(bs, &cylinders, &heads, &secs);\n\n    if (cylinders < 1 || cylinders > 16383) {\n\n        error_report(\"cyls must be between 1 and 16383\");\n\n        return -1;\n\n    }\n\n    if (heads < 1 || heads > 16) {\n\n        error_report(\"heads must be between 1 and 16\");\n\n        return -1;\n\n    }\n\n    if (secs < 1 || secs > 63) {\n\n        error_report(\"secs must be between 1 and 63\");\n\n        return -1;\n\n    }\n\n    s->cylinders = cylinders;\n\n    s->heads = heads;\n\n    s->sectors = secs;\n\n    s->nb_sectors = nb_sectors;\n\n    /* The SMART values should be preserved across power cycles\n\n       but they aren't.  */\n\n    s->smart_enabled = 1;\n\n    s->smart_autosave = 1;\n\n    s->smart_errors = 0;\n\n    s->smart_selftest_count = 0;\n\n    if (kind == IDE_CD) {\n\n        bdrv_set_dev_ops(bs, &ide_cd_block_ops, s);\n\n        bdrv_set_buffer_alignment(bs, 2048);\n\n    } else {\n\n        if (!bdrv_is_inserted(s->bs)) {\n\n            error_report(\"Device needs media, but drive is empty\");\n\n            return -1;\n\n        }\n\n        if (bdrv_is_read_only(bs)) {\n\n            error_report(\"Can't use a read-only drive\");\n\n            return -1;\n\n        }\n\n    }\n\n    if (serial) {\n\n        strncpy(s->drive_serial_str, serial, sizeof(s->drive_serial_str));\n\n    } else {\n\n        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),\n\n                 \"QM%05d\", s->drive_serial);\n\n    }\n\n    if (version) {\n\n        pstrcpy(s->version, sizeof(s->version), version);\n\n    } else {\n\n        pstrcpy(s->version, sizeof(s->version), QEMU_VERSION);\n\n    }\n\n\n\n    ide_reset(s);\n\n    bdrv_iostatus_enable(bs);\n\n    return 0;\n\n}\n", "idx": 25761}
{"project": "qemu", "commit_id": "517ff12c7d000fa1f5b1e989b22fb86a286f9cc2", "target": 0, "func": "int subch_device_load(SubchDev *s, QEMUFile *f)\n\n{\n\n    SubchDev *old_s;\n\n    Error *err = NULL;\n\n    uint16_t old_schid = s->schid;\n\n    uint16_t old_devno = s->devno;\n\n    int i;\n\n\n\n    s->cssid = qemu_get_byte(f);\n\n    s->ssid = qemu_get_byte(f);\n\n    s->schid = qemu_get_be16(f);\n\n    s->devno = qemu_get_be16(f);\n\n    if (s->devno != old_devno) {\n\n        /* Only possible if machine < 2.7 (no css_dev_path) */\n\n\n\n        error_setg(&err, \"%x != %x\", old_devno,  s->devno);\n\n        error_append_hint(&err, \"Devno mismatch, tried to load wrong section!\"\n\n                          \" Likely reason: some sequences of plug and unplug\"\n\n                          \" can break migration for machine versions prior to\"\n\n                          \" 2.7 (known design flaw).\\n\");\n\n        error_report_err(err);\n\n        return -EINVAL;\n\n    }\n\n    /* Re-assign subch. */\n\n    if (old_schid != s->schid) {\n\n        old_s = channel_subsys.css[s->cssid]->sch_set[s->ssid]->sch[old_schid];\n\n        /*\n\n         * (old_s != s) means that some other device has its correct\n\n         * subchannel already assigned (in load).\n\n         */\n\n        if (old_s == s) {\n\n            css_subch_assign(s->cssid, s->ssid, old_schid, s->devno, NULL);\n\n        }\n\n        /* It's OK to re-assign without a prior de-assign. */\n\n        css_subch_assign(s->cssid, s->ssid, s->schid, s->devno, s);\n\n    }\n\n    s->thinint_active = qemu_get_byte(f);\n\n    /* SCHIB */\n\n    /*     PMCW */\n\n    s->curr_status.pmcw.intparm = qemu_get_be32(f);\n\n    s->curr_status.pmcw.flags = qemu_get_be16(f);\n\n    s->curr_status.pmcw.devno = qemu_get_be16(f);\n\n    s->curr_status.pmcw.lpm = qemu_get_byte(f);\n\n    s->curr_status.pmcw.pnom  = qemu_get_byte(f);\n\n    s->curr_status.pmcw.lpum = qemu_get_byte(f);\n\n    s->curr_status.pmcw.pim = qemu_get_byte(f);\n\n    s->curr_status.pmcw.mbi = qemu_get_be16(f);\n\n    s->curr_status.pmcw.pom = qemu_get_byte(f);\n\n    s->curr_status.pmcw.pam = qemu_get_byte(f);\n\n    qemu_get_buffer(f, s->curr_status.pmcw.chpid, 8);\n\n    s->curr_status.pmcw.chars = qemu_get_be32(f);\n\n    /*     SCSW */\n\n    s->curr_status.scsw.flags = qemu_get_be16(f);\n\n    s->curr_status.scsw.ctrl = qemu_get_be16(f);\n\n    s->curr_status.scsw.cpa = qemu_get_be32(f);\n\n    s->curr_status.scsw.dstat = qemu_get_byte(f);\n\n    s->curr_status.scsw.cstat = qemu_get_byte(f);\n\n    s->curr_status.scsw.count = qemu_get_be16(f);\n\n    s->curr_status.mba = qemu_get_be64(f);\n\n    qemu_get_buffer(f, s->curr_status.mda, 4);\n\n    /* end SCHIB */\n\n    qemu_get_buffer(f, s->sense_data, 32);\n\n    s->channel_prog = qemu_get_be64(f);\n\n    /* last cmd */\n\n    s->last_cmd.cmd_code = qemu_get_byte(f);\n\n    s->last_cmd.flags = qemu_get_byte(f);\n\n    s->last_cmd.count = qemu_get_be16(f);\n\n    s->last_cmd.cda = qemu_get_be32(f);\n\n    s->last_cmd_valid = qemu_get_byte(f);\n\n    s->id.reserved = qemu_get_byte(f);\n\n    s->id.cu_type = qemu_get_be16(f);\n\n    s->id.cu_model = qemu_get_byte(f);\n\n    s->id.dev_type = qemu_get_be16(f);\n\n    s->id.dev_model = qemu_get_byte(f);\n\n    s->id.unused = qemu_get_byte(f);\n\n    for (i = 0; i < ARRAY_SIZE(s->id.ciw); i++) {\n\n        s->id.ciw[i].type = qemu_get_byte(f);\n\n        s->id.ciw[i].command = qemu_get_byte(f);\n\n        s->id.ciw[i].count = qemu_get_be16(f);\n\n    }\n\n    s->ccw_fmt_1 = qemu_get_byte(f);\n\n    s->ccw_no_data_cnt = qemu_get_byte(f);\n\n    /*\n\n     * Hack alert. We don't migrate the channel subsystem status (no\n\n     * device!), but we need to find out if the guest enabled mss/mcss-e.\n\n     * If the subchannel is enabled, it certainly was able to access it,\n\n     * so adjust the max_ssid/max_cssid values for relevant ssid/cssid\n\n     * values. This is not watertight, but better than nothing.\n\n     */\n\n    if (s->curr_status.pmcw.flags & PMCW_FLAGS_MASK_ENA) {\n\n        if (s->ssid) {\n\n            channel_subsys.max_ssid = MAX_SSID;\n\n        }\n\n        if (s->cssid != channel_subsys.default_cssid) {\n\n            channel_subsys.max_cssid = MAX_CSSID;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 25762}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void bdrv_init(void)\n\n{\n\n    module_call_init(MODULE_INIT_BLOCK);\n\n}\n", "idx": 25763}
{"project": "qemu", "commit_id": "eef5ad1086403d8ac8d91208a0e8dc34734b671c", "target": 0, "func": "void hmp_change(Monitor *mon, const QDict *qdict)\n\n{\n\n    const char *device = qdict_get_str(qdict, \"device\");\n\n    const char *target = qdict_get_str(qdict, \"target\");\n\n    const char *arg = qdict_get_try_str(qdict, \"arg\");\n\n    Error *err = NULL;\n\n\n\n    if (strcmp(device, \"vnc\") == 0 &&\n\n            (strcmp(target, \"passwd\") == 0 ||\n\n             strcmp(target, \"password\") == 0)) {\n\n        if (!arg) {\n\n            monitor_read_password(mon, hmp_change_read_arg, NULL);\n\n            return;\n\n        }\n\n    }\n\n\n\n    qmp_change(device, target, !!arg, arg, &err);\n\n    if (error_is_type(err, QERR_DEVICE_ENCRYPTED)) {\n\n        monitor_printf(mon, \"%s (%s) is encrypted.\\n\",\n\n                       error_get_field(err, \"device\"),\n\n                       error_get_field(err, \"filename\"));\n\n        if (!monitor_get_rs(mon)) {\n\n            monitor_printf(mon,\n\n                    \"terminal does not support password prompting\\n\");\n\n            error_free(err);\n\n            return;\n\n        }\n\n        readline_start(monitor_get_rs(mon), \"Password: \", 1,\n\n                       cb_hmp_change_bdrv_pwd, err);\n\n        return;\n\n    }\n\n    hmp_handle_error(mon, &err);\n\n}\n", "idx": 25764}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_loop(DisasContext *ctx, int r1, int32_t offset)\n\n{\n\n    int l1;\n\n    l1 = gen_new_label();\n\n\n\n    tcg_gen_subi_tl(cpu_gpr_a[r1], cpu_gpr_a[r1], 1);\n\n    tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_gpr_a[r1], -1, l1);\n\n    gen_goto_tb(ctx, 1, ctx->pc + offset);\n\n    gen_set_label(l1);\n\n    gen_goto_tb(ctx, 0, ctx->next_pc);\n\n}\n", "idx": 25765}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static void tight_send_compact_size(VncState *vs, size_t len)\n\n{\n\n    int lpc = 0;\n\n    int bytes = 0;\n\n    char buf[3] = {0, 0, 0};\n\n\n\n    buf[bytes++] = len & 0x7F;\n\n    if (len > 0x7F) {\n\n        buf[bytes-1] |= 0x80;\n\n        buf[bytes++] = (len >> 7) & 0x7F;\n\n        if (len > 0x3FFF) {\n\n            buf[bytes-1] |= 0x80;\n\n            buf[bytes++] = (len >> 14) & 0xFF;\n\n        }\n\n    }\n\n    for (lpc = 0; lpc < bytes; lpc++) {\n\n        vnc_write_u8(vs, buf[lpc]);\n\n    }\n\n}\n", "idx": 25766}
{"project": "qemu", "commit_id": "27a69bb088bee6d4efea254659422fb9c751b3c7", "target": 0, "func": "static inline void gen_evmwsmi(DisasContext *ctx)\n\n{\n\n    TCGv_i64 t0, t1;\n\n\n\n    if (unlikely(!ctx->spe_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_APU);\n\n        return;\n\n    }\n\n\n\n    t0 = tcg_temp_new_i64();\n\n    t1 = tcg_temp_new_i64();\n\n\n\n    /* t0 := rA; t1 := rB */\n\n#if defined(TARGET_PPC64)\n\n    tcg_gen_ext32s_tl(t0, cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_ext32s_tl(t1, cpu_gpr[rB(ctx->opcode)]);\n\n#else\n\n    tcg_gen_ext_tl_i64(t0, cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_ext_tl_i64(t1, cpu_gpr[rB(ctx->opcode)]);\n\n#endif\n\n\n\n    tcg_gen_mul_i64(t0, t0, t1);  /* t0 := rA * rB */\n\n\n\n    gen_store_gpr64(rD(ctx->opcode), t0); /* rD := t0 */\n\n\n\n    tcg_temp_free_i64(t0);\n\n    tcg_temp_free_i64(t1);\n\n}\n", "idx": 25767}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t subpage_ram_read(void *opaque, target_phys_addr_t addr,\n\n                                 unsigned size)\n\n{\n\n    ram_addr_t raddr = addr;\n\n    void *ptr = qemu_get_ram_ptr(raddr);\n\n    switch (size) {\n\n    case 1: return ldub_p(ptr);\n\n    case 2: return lduw_p(ptr);\n\n    case 4: return ldl_p(ptr);\n\n    default: abort();\n\n    }\n\n}\n", "idx": 25768}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qmp_input_type_any(Visitor *v, const char *name, QObject **obj,\n\n                               Error **errp)\n\n{\n\n    QmpInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qmp_input_get_object(qiv, name, true, errp);\n\n\n\n    *obj = NULL;\n\n    if (!qobj) {\n\n        return;\n\n    }\n\n\n\n    qobject_incref(qobj);\n\n    *obj = qobj;\n\n}\n", "idx": 25769}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "void gen_intermediate_code_internal(XtensaCPU *cpu,\n\n                                    TranslationBlock *tb, bool search_pc)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUXtensaState *env = &cpu->env;\n\n    DisasContext dc;\n\n    int insn_count = 0;\n\n    int j, lj = -1;\n\n    int max_insns = tb->cflags & CF_COUNT_MASK;\n\n    uint32_t pc_start = tb->pc;\n\n    uint32_t next_page_start =\n\n        (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n\n\n\n    if (max_insns == 0) {\n\n        max_insns = CF_COUNT_MASK;\n\n    }\n\n\n\n    dc.config = env->config;\n\n    dc.singlestep_enabled = cs->singlestep_enabled;\n\n    dc.tb = tb;\n\n    dc.pc = pc_start;\n\n    dc.ring = tb->flags & XTENSA_TBFLAG_RING_MASK;\n\n    dc.cring = (tb->flags & XTENSA_TBFLAG_EXCM) ? 0 : dc.ring;\n\n    dc.lbeg = env->sregs[LBEG];\n\n    dc.lend = env->sregs[LEND];\n\n    dc.is_jmp = DISAS_NEXT;\n\n    dc.ccount_delta = 0;\n\n    dc.debug = tb->flags & XTENSA_TBFLAG_DEBUG;\n\n    dc.icount = tb->flags & XTENSA_TBFLAG_ICOUNT;\n\n    dc.cpenable = (tb->flags & XTENSA_TBFLAG_CPENABLE_MASK) >>\n\n        XTENSA_TBFLAG_CPENABLE_SHIFT;\n\n    dc.window = ((tb->flags & XTENSA_TBFLAG_WINDOW_MASK) >>\n\n                 XTENSA_TBFLAG_WINDOW_SHIFT);\n\n\n\n    init_litbase(&dc);\n\n    init_sar_tracker(&dc);\n\n    if (dc.icount) {\n\n        dc.next_icount = tcg_temp_local_new_i32();\n\n    }\n\n\n\n    gen_tb_start(tb);\n\n\n\n    if (tb->flags & XTENSA_TBFLAG_EXCEPTION) {\n\n        tcg_gen_movi_i32(cpu_pc, dc.pc);\n\n        gen_exception(&dc, EXCP_DEBUG);\n\n    }\n\n\n\n    do {\n\n        check_breakpoint(env, &dc);\n\n\n\n        if (search_pc) {\n\n            j = tcg_op_buf_count();\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j) {\n\n                    tcg_ctx.gen_opc_instr_start[lj++] = 0;\n\n                }\n\n            }\n\n            tcg_ctx.gen_opc_pc[lj] = dc.pc;\n\n            tcg_ctx.gen_opc_instr_start[lj] = 1;\n\n            tcg_ctx.gen_opc_icount[lj] = insn_count;\n\n        }\n\n\n\n        if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {\n\n            tcg_gen_debug_insn_start(dc.pc);\n\n        }\n\n\n\n        ++dc.ccount_delta;\n\n\n\n        if (insn_count + 1 == max_insns && (tb->cflags & CF_LAST_IO)) {\n\n            gen_io_start();\n\n        }\n\n\n\n        if (dc.icount) {\n\n            int label = gen_new_label();\n\n\n\n            tcg_gen_addi_i32(dc.next_icount, cpu_SR[ICOUNT], 1);\n\n            tcg_gen_brcondi_i32(TCG_COND_NE, dc.next_icount, 0, label);\n\n            tcg_gen_mov_i32(dc.next_icount, cpu_SR[ICOUNT]);\n\n            if (dc.debug) {\n\n                gen_debug_exception(&dc, DEBUGCAUSE_IC);\n\n            }\n\n            gen_set_label(label);\n\n        }\n\n\n\n        if (dc.debug) {\n\n            gen_ibreak_check(env, &dc);\n\n        }\n\n\n\n        disas_xtensa_insn(env, &dc);\n\n        ++insn_count;\n\n        if (dc.icount) {\n\n            tcg_gen_mov_i32(cpu_SR[ICOUNT], dc.next_icount);\n\n        }\n\n        if (cs->singlestep_enabled) {\n\n            tcg_gen_movi_i32(cpu_pc, dc.pc);\n\n            gen_exception(&dc, EXCP_DEBUG);\n\n            break;\n\n        }\n\n    } while (dc.is_jmp == DISAS_NEXT &&\n\n            insn_count < max_insns &&\n\n            dc.pc < next_page_start &&\n\n            dc.pc + xtensa_insn_len(env, &dc) <= next_page_start &&\n\n            !tcg_op_buf_full());\n\n\n\n    reset_litbase(&dc);\n\n    reset_sar_tracker(&dc);\n\n    if (dc.icount) {\n\n        tcg_temp_free(dc.next_icount);\n\n    }\n\n\n\n    if (tb->cflags & CF_LAST_IO) {\n\n        gen_io_end();\n\n    }\n\n\n\n    if (dc.is_jmp == DISAS_NEXT) {\n\n        gen_jumpi(&dc, dc.pc, 0);\n\n    }\n\n    gen_tb_end(tb, insn_count);\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"----------------\\n\");\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n        log_target_disas(env, pc_start, dc.pc - pc_start, 0);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n    if (search_pc) {\n\n        j = tcg_op_buf_count();\n\n        memset(tcg_ctx.gen_opc_instr_start + lj + 1, 0,\n\n                (j - lj) * sizeof(tcg_ctx.gen_opc_instr_start[0]));\n\n    } else {\n\n        tb->size = dc.pc - pc_start;\n\n        tb->icount = insn_count;\n\n    }\n\n}\n", "idx": 25771}
{"project": "qemu", "commit_id": "4d9ab7d4ed46c63d047862d11946996005742a09", "target": 1, "func": "static target_ulong h_put_tce_indirect(PowerPCCPU *cpu,\n\n                                       sPAPRMachineState *spapr,\n\n                                       target_ulong opcode, target_ulong *args)\n\n{\n\n    int i;\n\n    target_ulong liobn = args[0];\n\n    target_ulong ioba = args[1];\n\n    target_ulong ioba1 = ioba;\n\n    target_ulong tce_list = args[2];\n\n    target_ulong npages = args[3];\n\n    target_ulong ret = H_PARAMETER, tce = 0;\n\n    sPAPRTCETable *tcet = spapr_tce_find_by_liobn(liobn);\n\n    CPUState *cs = CPU(cpu);\n\n    hwaddr page_mask, page_size;\n\n\n\n    if (!tcet) {\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    if ((npages > 512) || (tce_list & SPAPR_TCE_PAGE_MASK)) {\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    page_mask = IOMMU_PAGE_MASK(tcet->page_shift);\n\n    page_size = IOMMU_PAGE_SIZE(tcet->page_shift);\n\n    ioba &= page_mask;\n\n\n\n    for (i = 0; i < npages; ++i, ioba += page_size) {\n\n        target_ulong off = (tce_list & ~SPAPR_TCE_RW) +\n\n                                i * sizeof(target_ulong);\n\n        tce = ldq_be_phys(cs->as, off);\n\n\n\n        ret = put_tce_emu(tcet, ioba, tce);\n\n        if (ret) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* Trace last successful or the first problematic entry */\n\n    i = i ? (i - 1) : 0;\n\n    if (SPAPR_IS_PCI_LIOBN(liobn)) {\n\n        trace_spapr_iommu_pci_indirect(liobn, ioba1, tce_list, i, tce, ret);\n\n    } else {\n\n        trace_spapr_iommu_indirect(liobn, ioba1, tce_list, i, tce, ret);\n\n    }\n\n    return ret;\n\n}\n", "idx": 25773}
{"project": "qemu", "commit_id": "45b00c44ceffeac8143fb8857a12677234114f2b", "target": 1, "func": "ivshmem_server_parse_args(IvshmemServerArgs *args, int argc, char *argv[])\n\n{\n\n    int c;\n\n    unsigned long long v;\n\n    Error *errp = NULL;\n\n\n\n    while ((c = getopt(argc, argv,\n\n                       \"h\"  /* help */\n\n                       \"v\"  /* verbose */\n\n                       \"F\"  /* foreground */\n\n                       \"p:\" /* pid_file */\n\n                       \"S:\" /* unix_socket_path */\n\n                       \"m:\" /* shm_path */\n\n                       \"l:\" /* shm_size */\n\n                       \"n:\" /* n_vectors */\n\n                      )) != -1) {\n\n\n\n        switch (c) {\n\n        case 'h': /* help */\n\n            ivshmem_server_usage(argv[0], 0);\n\n            break;\n\n\n\n        case 'v': /* verbose */\n\n            args->verbose = 1;\n\n            break;\n\n\n\n        case 'F': /* foreground */\n\n            args->foreground = 1;\n\n            break;\n\n\n\n        case 'p': /* pid_file */\n\n            args->pid_file = strdup(optarg);\n\n            break;\n\n\n\n        case 'S': /* unix_socket_path */\n\n            args->unix_socket_path = strdup(optarg);\n\n            break;\n\n\n\n        case 'm': /* shm_path */\n\n            args->shm_path = strdup(optarg);\n\n            break;\n\n\n\n        case 'l': /* shm_size */\n\n            parse_option_size(\"shm_size\", optarg, &args->shm_size, &errp);\n\n            if (errp) {\n\n                fprintf(stderr, \"cannot parse shm size: %s\\n\",\n\n                        error_get_pretty(errp));\n\n                error_free(errp);\n\n                ivshmem_server_usage(argv[0], 1);\n\n            }\n\n            break;\n\n\n\n        case 'n': /* n_vectors */\n\n            if (parse_uint_full(optarg, &v, 0) < 0) {\n\n                fprintf(stderr, \"cannot parse n_vectors\\n\");\n\n                ivshmem_server_usage(argv[0], 1);\n\n            }\n\n            args->n_vectors = v;\n\n            break;\n\n\n\n        default:\n\n            ivshmem_server_usage(argv[0], 1);\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (args->n_vectors > IVSHMEM_SERVER_MAX_VECTORS) {\n\n        fprintf(stderr, \"too many requested vectors (max is %d)\\n\",\n\n                IVSHMEM_SERVER_MAX_VECTORS);\n\n        ivshmem_server_usage(argv[0], 1);\n\n    }\n\n\n\n    if (args->verbose == 1 && args->foreground == 0) {\n\n        fprintf(stderr, \"cannot use verbose in daemon mode\\n\");\n\n        ivshmem_server_usage(argv[0], 1);\n\n    }\n\n}\n", "idx": 25774}
{"project": "qemu", "commit_id": "9d7a4c6690ef9962a3b20034f65008f1ea15c1d6", "target": 1, "func": "void *g_try_malloc(size_t n_bytes)\n\n{\n\n    __coverity_negative_sink__(n_bytes);\n\n    return malloc(n_bytes == 0 ? 1 : n_bytes);\n\n}\n", "idx": 25775}
{"project": "qemu", "commit_id": "894e02804c862c6940b43a0a488164655d3fb3f0", "target": 1, "func": "static int nbd_negotiate_options(NBDClient *client, uint16_t myflags,\n\n                                 Error **errp)\n\n{\n\n    uint32_t flags;\n\n    bool fixedNewstyle = false;\n\n    bool no_zeroes = false;\n\n\n\n    /* Client sends:\n\n        [ 0 ..   3]   client flags\n\n\n\n       Then we loop until NBD_OPT_EXPORT_NAME or NBD_OPT_GO:\n\n        [ 0 ..   7]   NBD_OPTS_MAGIC\n\n        [ 8 ..  11]   NBD option\n\n        [12 ..  15]   Data length\n\n        ...           Rest of request\n\n\n\n        [ 0 ..   7]   NBD_OPTS_MAGIC\n\n        [ 8 ..  11]   Second NBD option\n\n        [12 ..  15]   Data length\n\n        ...           Rest of request\n\n    */\n\n\n\n    if (nbd_read(client->ioc, &flags, sizeof(flags), errp) < 0) {\n\n        error_prepend(errp, \"read failed: \");\n\n        return -EIO;\n\n    }\n\n    be32_to_cpus(&flags);\n\n    trace_nbd_negotiate_options_flags(flags);\n\n    if (flags & NBD_FLAG_C_FIXED_NEWSTYLE) {\n\n        fixedNewstyle = true;\n\n        flags &= ~NBD_FLAG_C_FIXED_NEWSTYLE;\n\n    }\n\n    if (flags & NBD_FLAG_C_NO_ZEROES) {\n\n        no_zeroes = true;\n\n        flags &= ~NBD_FLAG_C_NO_ZEROES;\n\n    }\n\n    if (flags != 0) {\n\n        error_setg(errp, \"Unknown client flags 0x%\" PRIx32 \" received\", flags);\n\n        return -EINVAL;\n\n    }\n\n\n\n    while (1) {\n\n        int ret;\n\n        uint32_t option, length;\n\n        uint64_t magic;\n\n\n\n        if (nbd_read(client->ioc, &magic, sizeof(magic), errp) < 0) {\n\n            error_prepend(errp, \"read failed: \");\n\n            return -EINVAL;\n\n        }\n\n        magic = be64_to_cpu(magic);\n\n        trace_nbd_negotiate_options_check_magic(magic);\n\n        if (magic != NBD_OPTS_MAGIC) {\n\n            error_setg(errp, \"Bad magic received\");\n\n            return -EINVAL;\n\n        }\n\n\n\n        if (nbd_read(client->ioc, &option,\n\n                     sizeof(option), errp) < 0) {\n\n            error_prepend(errp, \"read failed: \");\n\n            return -EINVAL;\n\n        }\n\n        option = be32_to_cpu(option);\n\n        client->opt = option;\n\n\n\n        if (nbd_read(client->ioc, &length, sizeof(length), errp) < 0) {\n\n            error_prepend(errp, \"read failed: \");\n\n            return -EINVAL;\n\n        }\n\n        length = be32_to_cpu(length);\n\n        client->optlen = length;\n\n\n\n        if (length > NBD_MAX_BUFFER_SIZE) {\n\n            error_setg(errp, \"len (%\" PRIu32\" ) is larger than max len (%u)\",\n\n                       length, NBD_MAX_BUFFER_SIZE);\n\n            return -EINVAL;\n\n        }\n\n\n\n        trace_nbd_negotiate_options_check_option(option,\n\n                                                 nbd_opt_lookup(option));\n\n        if (client->tlscreds &&\n\n            client->ioc == (QIOChannel *)client->sioc) {\n\n            QIOChannel *tioc;\n\n            if (!fixedNewstyle) {\n\n                error_setg(errp, \"Unsupported option 0x%\" PRIx32, option);\n\n                return -EINVAL;\n\n            }\n\n            switch (option) {\n\n            case NBD_OPT_STARTTLS:\n\n                if (length) {\n\n                    /* Unconditionally drop the connection if the client\n\n                     * can't start a TLS negotiation correctly */\n\n                    return nbd_reject_length(client, true, errp);\n\n                }\n\n                tioc = nbd_negotiate_handle_starttls(client, errp);\n\n                if (!tioc) {\n\n                    return -EIO;\n\n                }\n\n                ret = 0;\n\n                object_unref(OBJECT(client->ioc));\n\n                client->ioc = QIO_CHANNEL(tioc);\n\n                break;\n\n\n\n            case NBD_OPT_EXPORT_NAME:\n\n                /* No way to return an error to client, so drop connection */\n\n                error_setg(errp, \"Option 0x%x not permitted before TLS\",\n\n                           option);\n\n                return -EINVAL;\n\n\n\n            default:\n\n                if (nbd_drop(client->ioc, length, errp) < 0) {\n\n                    return -EIO;\n\n                }\n\n                ret = nbd_negotiate_send_rep_err(client,\n\n                                                 NBD_REP_ERR_TLS_REQD, errp,\n\n                                                 \"Option 0x%\" PRIx32\n\n                                                 \"not permitted before TLS\",\n\n                                                 option);\n\n                /* Let the client keep trying, unless they asked to\n\n                 * quit. In this mode, we've already sent an error, so\n\n                 * we can't ack the abort.  */\n\n                if (option == NBD_OPT_ABORT) {\n\n                    return 1;\n\n                }\n\n                break;\n\n            }\n\n        } else if (fixedNewstyle) {\n\n            switch (option) {\n\n            case NBD_OPT_LIST:\n\n                if (length) {\n\n                    ret = nbd_reject_length(client, false, errp);\n\n                } else {\n\n                    ret = nbd_negotiate_handle_list(client, errp);\n\n                }\n\n                break;\n\n\n\n            case NBD_OPT_ABORT:\n\n                /* NBD spec says we must try to reply before\n\n                 * disconnecting, but that we must also tolerate\n\n                 * guests that don't wait for our reply. */\n\n                nbd_negotiate_send_rep(client, NBD_REP_ACK, NULL);\n\n                return 1;\n\n\n\n            case NBD_OPT_EXPORT_NAME:\n\n                return nbd_negotiate_handle_export_name(client,\n\n                                                        myflags, no_zeroes,\n\n                                                        errp);\n\n\n\n            case NBD_OPT_INFO:\n\n            case NBD_OPT_GO:\n\n                ret = nbd_negotiate_handle_info(client, myflags, errp);\n\n                if (ret == 1) {\n\n                    assert(option == NBD_OPT_GO);\n\n                    return 0;\n\n                }\n\n                break;\n\n\n\n            case NBD_OPT_STARTTLS:\n\n                if (length) {\n\n                    ret = nbd_reject_length(client, false, errp);\n\n                } else if (client->tlscreds) {\n\n                    ret = nbd_negotiate_send_rep_err(client,\n\n                                                     NBD_REP_ERR_INVALID, errp,\n\n                                                     \"TLS already enabled\");\n\n                } else {\n\n                    ret = nbd_negotiate_send_rep_err(client,\n\n                                                     NBD_REP_ERR_POLICY, errp,\n\n                                                     \"TLS not configured\");\n\n                }\n\n                break;\n\n\n\n            case NBD_OPT_STRUCTURED_REPLY:\n\n                if (length) {\n\n                    ret = nbd_reject_length(client, false, errp);\n\n                } else if (client->structured_reply) {\n\n                    ret = nbd_negotiate_send_rep_err(\n\n                        client, NBD_REP_ERR_INVALID, errp,\n\n                        \"structured reply already negotiated\");\n\n                } else {\n\n                    ret = nbd_negotiate_send_rep(client, NBD_REP_ACK, errp);\n\n                    client->structured_reply = true;\n\n                    myflags |= NBD_FLAG_SEND_DF;\n\n                }\n\n                break;\n\n\n\n            default:\n\n                if (nbd_drop(client->ioc, length, errp) < 0) {\n\n                    return -EIO;\n\n                }\n\n                ret = nbd_negotiate_send_rep_err(client,\n\n                                                 NBD_REP_ERR_UNSUP, errp,\n\n                                                 \"Unsupported option 0x%\"\n\n                                                 PRIx32 \" (%s)\", option,\n\n                                                 nbd_opt_lookup(option));\n\n                break;\n\n            }\n\n        } else {\n\n            /*\n\n             * If broken new-style we should drop the connection\n\n             * for anything except NBD_OPT_EXPORT_NAME\n\n             */\n\n            switch (option) {\n\n            case NBD_OPT_EXPORT_NAME:\n\n                return nbd_negotiate_handle_export_name(client,\n\n                                                        myflags, no_zeroes,\n\n                                                        errp);\n\n\n\n            default:\n\n                error_setg(errp, \"Unsupported option 0x%\" PRIx32 \" (%s)\",\n\n                           option, nbd_opt_lookup(option));\n\n                return -EINVAL;\n\n            }\n\n        }\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n}\n", "idx": 25776}
{"project": "qemu", "commit_id": "5839e53bbc0fec56021d758aab7610df421ed8c8", "target": 1, "func": "static int sd_snapshot_goto(BlockDriverState *bs, const char *snapshot_id)\n\n{\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    BDRVSheepdogState *old_s;\n\n    char tag[SD_MAX_VDI_TAG_LEN];\n\n    uint32_t snapid = 0;\n\n    int ret = 0;\n\n\n\n    old_s = g_malloc(sizeof(BDRVSheepdogState));\n\n\n\n    memcpy(old_s, s, sizeof(BDRVSheepdogState));\n\n\n\n    snapid = strtoul(snapshot_id, NULL, 10);\n\n    if (snapid) {\n\n        tag[0] = 0;\n\n    } else {\n\n        pstrcpy(tag, sizeof(tag), snapshot_id);\n\n    }\n\n\n\n    ret = reload_inode(s, snapid, tag);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    ret = sd_create_branch(s);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    g_free(old_s);\n\n\n\n    return 0;\n\nout:\n\n    /* recover bdrv_sd_state */\n\n    memcpy(s, old_s, sizeof(BDRVSheepdogState));\n\n    g_free(old_s);\n\n\n\n    error_report(\"failed to open. recover old bdrv_sd_state.\");\n\n\n\n    return ret;\n\n}\n", "idx": 25779}
{"project": "qemu", "commit_id": "86d1bd70987cd11d85d01f52aa5824c63d910471", "target": 1, "func": "static int64_t allocate_clusters(BlockDriverState *bs, int64_t sector_num,\n\n                                 int nb_sectors, int *pnum)\n\n{\n\n    BDRVParallelsState *s = bs->opaque;\n\n    uint32_t idx, to_allocate, i;\n\n    int64_t pos, space;\n\n\n\n    pos = block_status(s, sector_num, nb_sectors, pnum);\n\n    if (pos > 0) {\n\n        return pos;\n\n    }\n\n\n\n    idx = sector_num / s->tracks;\n\n    if (idx >= s->bat_size) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    to_allocate = DIV_ROUND_UP(sector_num + *pnum, s->tracks) - idx;\n\n    space = to_allocate * s->tracks;\n\n    if (s->data_end + space > bdrv_getlength(bs->file->bs) >> BDRV_SECTOR_BITS) {\n\n        int ret;\n\n        space += s->prealloc_size;\n\n        if (s->prealloc_mode == PRL_PREALLOC_MODE_FALLOCATE) {\n\n            ret = bdrv_pwrite_zeroes(bs->file,\n\n                                     s->data_end << BDRV_SECTOR_BITS,\n\n                                     space << BDRV_SECTOR_BITS, 0);\n\n        } else {\n\n            ret = bdrv_truncate(bs->file,\n\n                                (s->data_end + space) << BDRV_SECTOR_BITS);\n\n        }\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < to_allocate; i++) {\n\n        s->bat_bitmap[idx + i] = cpu_to_le32(s->data_end / s->off_multiplier);\n\n        s->data_end += s->tracks;\n\n        bitmap_set(s->bat_dirty_bmap,\n\n                   bat_entry_off(idx + i) / s->bat_dirty_block, 1);\n\n    }\n\n\n\n    return bat2sect(s, idx) + sector_num % s->tracks;\n\n}\n", "idx": 25781}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void send_scsi_cdb_read10(QPCIDevice *dev, void *ide_base,\n\n                                 uint64_t lba, int nblocks)\n\n{\n\n    Read10CDB pkt = { .padding = 0 };\n\n    int i;\n\n\n\n    g_assert_cmpint(lba, <=, UINT32_MAX);\n\n    g_assert_cmpint(nblocks, <=, UINT16_MAX);\n\n    g_assert_cmpint(nblocks, >=, 0);\n\n\n\n    /* Construct SCSI CDB packet */\n\n    pkt.opcode = 0x28;\n\n    pkt.lba = cpu_to_be32(lba);\n\n    pkt.nblocks = cpu_to_be16(nblocks);\n\n\n\n    /* Send Packet */\n\n    for (i = 0; i < sizeof(Read10CDB)/2; i++) {\n\n        qpci_io_writew(dev, ide_base + reg_data,\n\n                       le16_to_cpu(((uint16_t *)&pkt)[i]));\n\n    }\n\n}\n", "idx": 25783}
{"project": "qemu", "commit_id": "17eb587aeb492fe68f8130b027154ff0921fc0b4", "target": 1, "func": "static int tftp_session_allocate(Slirp *slirp, struct sockaddr_storage *srcsas,\n\n                                 struct tftp_t *tp)\n\n{\n\n  struct tftp_session *spt;\n\n  int k;\n\n\n\n  for (k = 0; k < TFTP_SESSIONS_MAX; k++) {\n\n    spt = &slirp->tftp_sessions[k];\n\n\n\n    if (!tftp_session_in_use(spt))\n\n        goto found;\n\n\n\n    /* sessions time out after 5 inactive seconds */\n\n    if ((int)(curtime - spt->timestamp) > 5000) {\n\n        tftp_session_terminate(spt);\n\n        goto found;\n\n    }\n\n  }\n\n\n\n  return -1;\n\n\n\n found:\n\n  memset(spt, 0, sizeof(*spt));\n\n  spt->client_addr = *srcsas;\n\n  spt->fd = -1;\n\n  spt->block_size = 512;\n\n  spt->client_port = tp->udp.uh_sport;\n\n  spt->slirp = slirp;\n\n\n\n  tftp_session_update(spt);\n\n\n\n  return k;\n\n}\n", "idx": 25785}
{"project": "qemu", "commit_id": "14b6160099f0caf5dc9d62e637b007bc5d719a96", "target": 1, "func": "QBool *qobject_to_qbool(const QObject *obj)\n\n{\n\n    if (qobject_type(obj) != QTYPE_QBOOL)\n\n        return NULL;\n\n\n\n    return container_of(obj, QBool, base);\n\n}\n", "idx": 25786}
{"project": "qemu", "commit_id": "77319f22635e3f0ef86730503b4d18dd9a833529", "target": 1, "func": "static int handle_hypercall(S390CPU *cpu, struct kvm_run *run)\n\n{\n\n    CPUS390XState *env = &cpu->env;\n\n\n\n    cpu_synchronize_state(CPU(cpu));\n\n    env->regs[2] = s390_virtio_hypercall(env);\n\n\n\n    return 0;\n\n}\n", "idx": 25789}
{"project": "qemu", "commit_id": "18e5eec4db96a00907eb588a2b803401637c7f67", "target": 1, "func": "static int vapic_prepare(VAPICROMState *s)\n\n{\n\n    vapic_map_rom_writable(s);\n\n\n\n    if (patch_hypercalls(s) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    vapic_enable_tpr_reporting(true);\n\n\n\n    return 0;\n\n}\n", "idx": 25791}
{"project": "qemu", "commit_id": "955f5c7ba127746345a3d43b4d7c885ca159ae6b", "target": 1, "func": "void ahci_uninit(AHCIState *s)\n\n{\n\n    int i, j;\n\n\n\n    for (i = 0; i < s->ports; i++) {\n\n        AHCIDevice *ad = &s->dev[i];\n\n\n\n        for (j = 0; j < 2; j++) {\n\n            IDEState *s = &ad->port.ifs[j];\n\n\n\n            ide_exit(s);\n\n        }\n\n\n    }\n\n\n\n    g_free(s->dev);\n\n}", "idx": 25792}
{"project": "qemu", "commit_id": "e95205e1f9cd2c4262b7a7b1c992a94512c86d0e", "target": 1, "func": "static void cpu_unregister_map_client(void *_client)\n\n{\n\n    MapClient *client = (MapClient *)_client;\n\n\n\n    QLIST_REMOVE(client, link);\n\n    g_free(client);\n\n}\n", "idx": 25797}
{"project": "qemu", "commit_id": "08a655be71d0a130a5d9bf7816d096ec31c4f055", "target": 1, "func": "static void dump_iterate(DumpState *s, Error **errp)\n\n{\n\n    GuestPhysBlock *block;\n\n    int64_t size;\n\n    int ret;\n\n    Error *local_err = NULL;\n\n\n\n    while (1) {\n\n        block = s->next_block;\n\n\n\n        size = block->target_end - block->target_start;\n\n        if (s->has_filter) {\n\n            size -= s->start;\n\n            if (s->begin + s->length < block->target_end) {\n\n                size -= block->target_end - (s->begin + s->length);\n\n            }\n\n        }\n\n        write_memory(s, block, s->start, size, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n\n\n        ret = get_next_block(s, block);\n\n        if (ret == 1) {\n\n            dump_completed(s);\n\n        }\n\n    }\n\n}\n", "idx": 25802}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "fdctrl_t *fdctrl_init_sysbus(qemu_irq irq, int dma_chann,\n\n                             target_phys_addr_t mmio_base,\n\n                             DriveInfo **fds)\n\n{\n\n    fdctrl_t *fdctrl;\n\n    DeviceState *dev;\n\n    fdctrl_sysbus_t *sys;\n\n\n\n    dev = qdev_create(NULL, \"sysbus-fdc\");\n\n    sys = DO_UPCAST(fdctrl_sysbus_t, busdev.qdev, dev);\n\n    fdctrl = &sys->state;\n\n    fdctrl->dma_chann = dma_chann; /* FIXME */\n\n    qdev_prop_set_drive(dev, \"driveA\", fds[0]);\n\n    qdev_prop_set_drive(dev, \"driveB\", fds[1]);\n\n    if (qdev_init(dev) != 0)\n\n        return NULL;\n\n    sysbus_connect_irq(&sys->busdev, 0, irq);\n\n    sysbus_mmio_map(&sys->busdev, 0, mmio_base);\n\n\n\n    return fdctrl;\n\n}\n", "idx": 25803}
{"project": "qemu", "commit_id": "9a16c5950d9ce38671a1ac259dcde3e707767922", "target": 0, "func": "static void uhci_async_complete(USBPort *port, USBPacket *packet)\n\n{\n\n    UHCIAsync *async = container_of(packet, UHCIAsync, packet);\n\n    UHCIState *s = async->queue->uhci;\n\n\n\n    if (async->isoc) {\n\n        UHCI_TD td;\n\n        uint32_t link = async->td;\n\n        uint32_t int_mask = 0, val;\n\n\n\n        pci_dma_read(&s->dev, link & ~0xf, &td, sizeof(td));\n\n        le32_to_cpus(&td.link);\n\n        le32_to_cpus(&td.ctrl);\n\n        le32_to_cpus(&td.token);\n\n        le32_to_cpus(&td.buffer);\n\n\n\n        uhci_async_unlink(async);\n\n        uhci_complete_td(s, &td, async, &int_mask);\n\n        s->pending_int_mask |= int_mask;\n\n\n\n        /* update the status bits of the TD */\n\n        val = cpu_to_le32(td.ctrl);\n\n        pci_dma_write(&s->dev, (link & ~0xf) + 4, &val, sizeof(val));\n\n        uhci_async_free(async);\n\n    } else {\n\n        async->done = 1;\n\n        uhci_process_frame(s);\n\n    }\n\n}\n", "idx": 25804}
{"project": "qemu", "commit_id": "c4d9d19645a484298a67e9021060bc7c2b081d0f", "target": 0, "func": "int coroutine_fn thread_pool_submit_co(ThreadPoolFunc *func, void *arg)\n\n{\n\n    ThreadPoolCo tpc = { .co = qemu_coroutine_self(), .ret = -EINPROGRESS };\n\n    assert(qemu_in_coroutine());\n\n    thread_pool_submit_aio(func, arg, thread_pool_co_cb, &tpc);\n\n    qemu_coroutine_yield();\n\n    return tpc.ret;\n\n}\n", "idx": 25805}
{"project": "qemu", "commit_id": "fff23ee9a5de74ab111b3cea9eec56782e7d7c50", "target": 0, "func": "static void uhci_process_frame(UHCIState *s)\n\n{\n\n    uint32_t frame_addr, link, old_td_ctrl, val, int_mask;\n\n    uint32_t curr_qh;\n\n    int cnt, ret;\n\n    UHCI_TD td;\n\n    UHCI_QH qh;\n\n    QhDb qhdb;\n\n\n\n    frame_addr = s->fl_base_addr + ((s->frnum & 0x3ff) << 2);\n\n\n\n    DPRINTF(\"uhci: processing frame %d addr 0x%x\\n\" , s->frnum, frame_addr);\n\n\n\n    cpu_physical_memory_read(frame_addr, (uint8_t *)&link, 4);\n\n    le32_to_cpus(&link);\n\n\n\n    int_mask = 0;\n\n    curr_qh  = 0;\n\n\n\n    qhdb_reset(&qhdb);\n\n\n\n    for (cnt = FRAME_MAX_LOOPS; is_valid(link) && cnt; cnt--) {\n\n        if (is_qh(link)) {\n\n            /* QH */\n\n\n\n            if (qhdb_insert(&qhdb, link)) {\n\n                /*\n\n                 * We're going in circles. Which is not a bug because\n\n                 * HCD is allowed to do that as part of the BW management. \n\n                 * In our case though it makes no sense to spin here. Sync transations \n\n                 * are already done, and async completion handler will re-process \n\n                 * the frame when something is ready.\n\n                 */\n\n                DPRINTF(\"uhci: detected loop. qh 0x%x\\n\", link);\n\n                break;\n\n            }\n\n\n\n            cpu_physical_memory_read(link & ~0xf, (uint8_t *) &qh, sizeof(qh));\n\n            le32_to_cpus(&qh.link);\n\n            le32_to_cpus(&qh.el_link);\n\n\n\n            DPRINTF(\"uhci: QH 0x%x load. link 0x%x elink 0x%x\\n\",\n\n                    link, qh.link, qh.el_link);\n\n\n\n            if (!is_valid(qh.el_link)) {\n\n                /* QH w/o elements */\n\n                curr_qh = 0;\n\n                link = qh.link;\n\n            } else {\n\n                /* QH with elements */\n\n            \tcurr_qh = link;\n\n            \tlink = qh.el_link;\n\n            }\n\n            continue;\n\n        }\n\n\n\n        /* TD */\n\n        cpu_physical_memory_read(link & ~0xf, (uint8_t *) &td, sizeof(td));\n\n        le32_to_cpus(&td.link);\n\n        le32_to_cpus(&td.ctrl);\n\n        le32_to_cpus(&td.token);\n\n        le32_to_cpus(&td.buffer);\n\n\n\n        DPRINTF(\"uhci: TD 0x%x load. link 0x%x ctrl 0x%x token 0x%x qh 0x%x\\n\", \n\n                link, td.link, td.ctrl, td.token, curr_qh);\n\n\n\n        old_td_ctrl = td.ctrl;\n\n        ret = uhci_handle_td(s, link, &td, &int_mask);\n\n        if (old_td_ctrl != td.ctrl) {\n\n            /* update the status bits of the TD */\n\n            val = cpu_to_le32(td.ctrl);\n\n            cpu_physical_memory_write((link & ~0xf) + 4,\n\n                                      (const uint8_t *)&val, sizeof(val));\n\n        }\n\n\n\n        if (ret < 0) {\n\n            /* interrupted frame */\n\n            break;\n\n        }\n\n\n\n        if (ret == 2 || ret == 1) {\n\n            DPRINTF(\"uhci: TD 0x%x %s. link 0x%x ctrl 0x%x token 0x%x qh 0x%x\\n\",\n\n                    link, ret == 2 ? \"pend\" : \"skip\",\n\n                    td.link, td.ctrl, td.token, curr_qh);\n\n\n\n            link = curr_qh ? qh.link : td.link;\n\n            continue;\n\n        }\n\n\n\n        /* completed TD */\n\n\n\n        DPRINTF(\"uhci: TD 0x%x done. link 0x%x ctrl 0x%x token 0x%x qh 0x%x\\n\", \n\n                link, td.link, td.ctrl, td.token, curr_qh);\n\n\n\n        link = td.link;\n\n\n\n        if (curr_qh) {\n\n\t    /* update QH element link */\n\n            qh.el_link = link;\n\n            val = cpu_to_le32(qh.el_link);\n\n            cpu_physical_memory_write((curr_qh & ~0xf) + 4,\n\n                                          (const uint8_t *)&val, sizeof(val));\n\n\n\n            if (!depth_first(link)) {\n\n               /* done with this QH */\n\n\n\n               DPRINTF(\"uhci: QH 0x%x done. link 0x%x elink 0x%x\\n\",\n\n                       curr_qh, qh.link, qh.el_link);\n\n\n\n               curr_qh = 0;\n\n               link    = qh.link;\n\n            }\n\n        }\n\n\n\n        /* go to the next entry */\n\n    }\n\n\n\n    s->pending_int_mask |= int_mask;\n\n}\n", "idx": 25806}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static void virtio_input_handle_sts(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    VirtIOInputClass *vic = VIRTIO_INPUT_GET_CLASS(vdev);\n\n    VirtIOInput *vinput = VIRTIO_INPUT(vdev);\n\n    virtio_input_event event;\n\n    VirtQueueElement elem;\n\n    int len;\n\n\n\n    while (virtqueue_pop(vinput->sts, &elem)) {\n\n        memset(&event, 0, sizeof(event));\n\n        len = iov_to_buf(elem.out_sg, elem.out_num,\n\n                         0, &event, sizeof(event));\n\n        if (vic->handle_status) {\n\n            vic->handle_status(vinput, &event);\n\n        }\n\n        virtqueue_push(vinput->sts, &elem, len);\n\n    }\n\n    virtio_notify(vdev, vinput->sts);\n\n}\n", "idx": 25808}
{"project": "qemu", "commit_id": "3ac4b7c51e3ba181a86983ba2601a595ed8f3b1d", "target": 0, "func": "void qmp_guest_file_close(int64_t handle, Error **err)\n\n{\n\n    GuestFileHandle *gfh = guest_file_handle_find(handle, err);\n\n    int ret;\n\n\n\n    slog(\"guest-file-close called, handle: %ld\", handle);\n\n    if (!gfh) {\n\n        return;\n\n    }\n\n\n\n    ret = fclose(gfh->fh);\n\n    if (ret == -1) {\n\n        error_set(err, QERR_QGA_COMMAND_FAILED, \"fclose() failed\");\n\n        return;\n\n    }\n\n\n\n    QTAILQ_REMOVE(&guest_file_state.filehandles, gfh, next);\n\n    g_free(gfh);\n\n}\n", "idx": 25809}
{"project": "qemu", "commit_id": "2231f69b4e4523c43aa459cab18ab77c0e29b4d1", "target": 0, "func": "build_madt(GArray *table_data, BIOSLinker *linker, VirtGuestInfo *guest_info)\n\n{\n\n    int madt_start = table_data->len;\n\n    const MemMapEntry *memmap = guest_info->memmap;\n\n    const int *irqmap = guest_info->irqmap;\n\n    AcpiMultipleApicTable *madt;\n\n    AcpiMadtGenericDistributor *gicd;\n\n    AcpiMadtGenericMsiFrame *gic_msi;\n\n    int i;\n\n\n\n    madt = acpi_data_push(table_data, sizeof *madt);\n\n\n\n    gicd = acpi_data_push(table_data, sizeof *gicd);\n\n    gicd->type = ACPI_APIC_GENERIC_DISTRIBUTOR;\n\n    gicd->length = sizeof(*gicd);\n\n    gicd->base_address = memmap[VIRT_GIC_DIST].base;\n\n    gicd->version = guest_info->gic_version;\n\n\n\n    for (i = 0; i < guest_info->smp_cpus; i++) {\n\n        AcpiMadtGenericInterrupt *gicc = acpi_data_push(table_data,\n\n                                                     sizeof *gicc);\n\n        ARMCPU *armcpu = ARM_CPU(qemu_get_cpu(i));\n\n\n\n        gicc->type = ACPI_APIC_GENERIC_INTERRUPT;\n\n        gicc->length = sizeof(*gicc);\n\n        if (guest_info->gic_version == 2) {\n\n            gicc->base_address = memmap[VIRT_GIC_CPU].base;\n\n        }\n\n        gicc->cpu_interface_number = i;\n\n        gicc->arm_mpidr = armcpu->mp_affinity;\n\n        gicc->uid = i;\n\n        gicc->flags = cpu_to_le32(ACPI_GICC_ENABLED);\n\n\n\n        if (armcpu->has_pmu) {\n\n            gicc->performance_interrupt = cpu_to_le32(PPI(VIRTUAL_PMU_IRQ));\n\n        }\n\n    }\n\n\n\n    if (guest_info->gic_version == 3) {\n\n        AcpiMadtGenericTranslator *gic_its;\n\n        AcpiMadtGenericRedistributor *gicr = acpi_data_push(table_data,\n\n                                                         sizeof *gicr);\n\n\n\n        gicr->type = ACPI_APIC_GENERIC_REDISTRIBUTOR;\n\n        gicr->length = sizeof(*gicr);\n\n        gicr->base_address = cpu_to_le64(memmap[VIRT_GIC_REDIST].base);\n\n        gicr->range_length = cpu_to_le32(memmap[VIRT_GIC_REDIST].size);\n\n\n\n        if (its_class_name()) {\n\n            gic_its = acpi_data_push(table_data, sizeof *gic_its);\n\n            gic_its->type = ACPI_APIC_GENERIC_TRANSLATOR;\n\n            gic_its->length = sizeof(*gic_its);\n\n            gic_its->translation_id = 0;\n\n            gic_its->base_address = cpu_to_le64(memmap[VIRT_GIC_ITS].base);\n\n        }\n\n    } else {\n\n        gic_msi = acpi_data_push(table_data, sizeof *gic_msi);\n\n        gic_msi->type = ACPI_APIC_GENERIC_MSI_FRAME;\n\n        gic_msi->length = sizeof(*gic_msi);\n\n        gic_msi->gic_msi_frame_id = 0;\n\n        gic_msi->base_address = cpu_to_le64(memmap[VIRT_GIC_V2M].base);\n\n        gic_msi->flags = cpu_to_le32(1);\n\n        gic_msi->spi_count = cpu_to_le16(NUM_GICV2M_SPIS);\n\n        gic_msi->spi_base = cpu_to_le16(irqmap[VIRT_GIC_V2M] + ARM_SPI_BASE);\n\n    }\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)(table_data->data + madt_start), \"APIC\",\n\n                 table_data->len - madt_start, 3, NULL, NULL);\n\n}\n", "idx": 25810}
{"project": "qemu", "commit_id": "aad15de4275d2fc90acdf6101493dfee4e39b803", "target": 0, "func": "static int convert_read(ImgConvertState *s, int64_t sector_num, int nb_sectors,\n\n                        uint8_t *buf)\n\n{\n\n    int n;\n\n    int ret;\n\n\n\n    if (s->status == BLK_ZERO || s->status == BLK_BACKING_FILE) {\n\n        return 0;\n\n    }\n\n\n\n    assert(nb_sectors <= s->buf_sectors);\n\n    while (nb_sectors > 0) {\n\n        BlockBackend *blk;\n\n        int64_t bs_sectors;\n\n\n\n        /* In the case of compression with multiple source files, we can get a\n\n         * nb_sectors that spreads into the next part. So we must be able to\n\n         * read across multiple BDSes for one convert_read() call. */\n\n        convert_select_part(s, sector_num);\n\n        blk = s->src[s->src_cur];\n\n        bs_sectors = s->src_sectors[s->src_cur];\n\n\n\n        n = MIN(nb_sectors, bs_sectors - (sector_num - s->src_cur_offset));\n\n        ret = blk_read(blk, sector_num - s->src_cur_offset, buf, n);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        sector_num += n;\n\n        nb_sectors -= n;\n\n        buf += n * BDRV_SECTOR_SIZE;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 25811}
{"project": "qemu", "commit_id": "7bd427d801e1e3293a634d3c83beadaa90ffb911", "target": 0, "func": "static void qemu_announce_self_once(void *opaque)\n\n{\n\n    static int count = SELF_ANNOUNCE_ROUNDS;\n\n    QEMUTimer *timer = *(QEMUTimer **)opaque;\n\n\n\n    qemu_foreach_nic(qemu_announce_self_iter, NULL);\n\n\n\n    if (--count) {\n\n        /* delay 50ms, 150ms, 250ms, ... */\n\n        qemu_mod_timer(timer, qemu_get_clock(rt_clock) +\n\n                       50 + (SELF_ANNOUNCE_ROUNDS - count - 1) * 100);\n\n    } else {\n\n\t    qemu_del_timer(timer);\n\n\t    qemu_free_timer(timer);\n\n    }\n\n}\n", "idx": 25812}
{"project": "qemu", "commit_id": "d6cf84e1de0a167963f0803d6e39f6ca03e27eaa", "target": 0, "func": "int slirp_can_output(void)\n\n{\n\n    return !slirp_vc || qemu_can_send_packet(slirp_vc);\n\n}\n", "idx": 25813}
{"project": "qemu", "commit_id": "7f595609b49615b07c50b7182c4ef125c39cb5da", "target": 0, "func": "static void usb_tablet_class_initfn(ObjectClass *klass, void *data)\n\n{\n\n    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);\n\n\n\n    uc->init           = usb_tablet_initfn;\n\n    uc->product_desc   = \"QEMU USB Tablet\";\n\n    uc->usb_desc       = &desc_tablet;\n\n    uc->handle_packet  = usb_generic_handle_packet;\n\n    uc->handle_reset   = usb_hid_handle_reset;\n\n    uc->handle_control = usb_hid_handle_control;\n\n    uc->handle_data    = usb_hid_handle_data;\n\n    uc->handle_destroy = usb_hid_handle_destroy;\n\n}\n", "idx": 25814}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int nvme_init(PCIDevice *pci_dev)\n\n{\n\n    NvmeCtrl *n = NVME(pci_dev);\n\n    NvmeIdCtrl *id = &n->id_ctrl;\n\n\n\n    int i;\n\n    int64_t bs_size;\n\n    uint8_t *pci_conf;\n\n\n\n    if (!(n->conf.bs)) {\n\n        return -1;\n\n    }\n\n\n\n    bs_size = bdrv_getlength(n->conf.bs);\n\n    if (bs_size < 0) {\n\n        return -1;\n\n    }\n\n\n\n    blkconf_serial(&n->conf, &n->serial);\n\n    if (!n->serial) {\n\n        return -1;\n\n    }\n\n\n\n    pci_conf = pci_dev->config;\n\n    pci_conf[PCI_INTERRUPT_PIN] = 1;\n\n    pci_config_set_prog_interface(pci_dev->config, 0x2);\n\n    pci_config_set_class(pci_dev->config, PCI_CLASS_STORAGE_EXPRESS);\n\n    pcie_endpoint_cap_init(&n->parent_obj, 0x80);\n\n\n\n    n->num_namespaces = 1;\n\n    n->num_queues = 64;\n\n    n->reg_size = 1 << qemu_fls(0x1004 + 2 * (n->num_queues + 1) * 4);\n\n    n->ns_size = bs_size / (uint64_t)n->num_namespaces;\n\n\n\n    n->namespaces = g_new0(NvmeNamespace, n->num_namespaces);\n\n    n->sq = g_new0(NvmeSQueue *, n->num_queues);\n\n    n->cq = g_new0(NvmeCQueue *, n->num_queues);\n\n\n\n    memory_region_init_io(&n->iomem, OBJECT(n), &nvme_mmio_ops, n,\n\n                          \"nvme\", n->reg_size);\n\n    pci_register_bar(&n->parent_obj, 0,\n\n        PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_TYPE_64,\n\n        &n->iomem);\n\n    msix_init_exclusive_bar(&n->parent_obj, n->num_queues, 4);\n\n\n\n    id->vid = cpu_to_le16(pci_get_word(pci_conf + PCI_VENDOR_ID));\n\n    id->ssvid = cpu_to_le16(pci_get_word(pci_conf + PCI_SUBSYSTEM_VENDOR_ID));\n\n    strpadcpy((char *)id->mn, sizeof(id->mn), \"QEMU NVMe Ctrl\", ' ');\n\n    strpadcpy((char *)id->fr, sizeof(id->fr), \"1.0\", ' ');\n\n    strpadcpy((char *)id->sn, sizeof(id->sn), n->serial, ' ');\n\n    id->rab = 6;\n\n    id->ieee[0] = 0x00;\n\n    id->ieee[1] = 0x02;\n\n    id->ieee[2] = 0xb3;\n\n    id->oacs = cpu_to_le16(0);\n\n    id->frmw = 7 << 1;\n\n    id->lpa = 1 << 0;\n\n    id->sqes = (0x6 << 4) | 0x6;\n\n    id->cqes = (0x4 << 4) | 0x4;\n\n    id->nn = cpu_to_le32(n->num_namespaces);\n\n    id->psd[0].mp = cpu_to_le16(0x9c4);\n\n    id->psd[0].enlat = cpu_to_le32(0x10);\n\n    id->psd[0].exlat = cpu_to_le32(0x4);\n\n\n\n    n->bar.cap = 0;\n\n    NVME_CAP_SET_MQES(n->bar.cap, 0x7ff);\n\n    NVME_CAP_SET_CQR(n->bar.cap, 1);\n\n    NVME_CAP_SET_AMS(n->bar.cap, 1);\n\n    NVME_CAP_SET_TO(n->bar.cap, 0xf);\n\n    NVME_CAP_SET_CSS(n->bar.cap, 1);\n\n\n\n    n->bar.vs = 0x00010001;\n\n    n->bar.intmc = n->bar.intms = 0;\n\n\n\n    for (i = 0; i < n->num_namespaces; i++) {\n\n        NvmeNamespace *ns = &n->namespaces[i];\n\n        NvmeIdNs *id_ns = &ns->id_ns;\n\n        id_ns->nsfeat = 0;\n\n        id_ns->nlbaf = 0;\n\n        id_ns->flbas = 0;\n\n        id_ns->mc = 0;\n\n        id_ns->dpc = 0;\n\n        id_ns->dps = 0;\n\n        id_ns->lbaf[0].ds = BDRV_SECTOR_BITS;\n\n        id_ns->ncap  = id_ns->nuse = id_ns->nsze =\n\n            cpu_to_le64(n->ns_size >>\n\n                id_ns->lbaf[NVME_ID_NS_FLBAS_INDEX(ns->id_ns.flbas)].ds);\n\n    }\n\n    return 0;\n\n}\n", "idx": 25815}
{"project": "qemu", "commit_id": "24ce9a20260713e86377cfa78fb8699335759f4f", "target": 0, "func": "int blk_get_max_transfer_length(BlockBackend *blk)\n\n{\n\n    BlockDriverState *bs = blk_bs(blk);\n\n\n\n    if (bs) {\n\n        return bs->bl.max_transfer_length;\n\n    } else {\n\n        return 0;\n\n    }\n\n}\n", "idx": 25816}
{"project": "qemu", "commit_id": "0ac7cc2af500b948510f2481c22e84a57b0a2447", "target": 0, "func": "START_TEST(qstring_append_chr_test)\n\n{\n\n    int i;\n\n    QString *qstring;\n\n    const char *str = \"qstring append char unit-test\";\n\n\n\n    qstring = qstring_new();\n\n\n\n    for (i = 0; str[i]; i++)\n\n        qstring_append_chr(qstring, str[i]);\n\n\n\n    fail_unless(strcmp(str, qstring_get_str(qstring)) == 0);\n\n    QDECREF(qstring);\n\n}\n", "idx": 25817}
{"project": "qemu", "commit_id": "2e6fc7eb1a4af1b127df5f07b8bb28af891946fa", "target": 0, "func": "static int raw_co_ioctl(BlockDriverState *bs, unsigned long int req, void *buf)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    if (s->offset || s->has_size) {\n\n        return -ENOTSUP;\n\n    }\n\n    return bdrv_co_ioctl(bs->file->bs, req, buf);\n\n}\n", "idx": 25819}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void lsi_io_write(void *opaque, target_phys_addr_t addr,\n\n                         uint64_t val, unsigned size)\n\n{\n\n    LSIState *s = opaque;\n\n    lsi_reg_writeb(s, addr & 0xff, val);\n\n}\n", "idx": 25820}
{"project": "qemu", "commit_id": "94c3db85b4cc1d4e078859834a761bcc9d988780", "target": 0, "func": "void input_type_enum(Visitor *v, int *obj, const char *strings[],\n\n                     const char *kind, const char *name,\n\n                     Error **errp)\n\n{\n\n    int64_t value = 0;\n\n    char *enum_str;\n\n\n\n    assert(strings);\n\n\n\n    visit_type_str(v, &enum_str, name, errp);\n\n    if (error_is_set(errp)) {\n\n        return;\n\n    }\n\n\n\n    while (strings[value] != NULL) {\n\n        if (strcmp(strings[value], enum_str) == 0) {\n\n            break;\n\n        }\n\n        value++;\n\n    }\n\n\n\n    if (strings[value] == NULL) {\n\n        error_set(errp, QERR_INVALID_PARAMETER, name ? name : \"null\");\n\n        g_free(enum_str);\n\n        return;\n\n    }\n\n\n\n    g_free(enum_str);\n\n    *obj = value;\n\n}\n", "idx": 25821}
{"project": "qemu", "commit_id": "c19c1578f8a9b894f5e368e35139620a98bf6a69", "target": 0, "func": "int queue_signal(CPUArchState *env, int sig, target_siginfo_t *info)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(env);\n\n    TaskState *ts = cpu->opaque;\n\n    struct emulated_sigtable *k;\n\n    struct sigqueue *q, **pq;\n\n    abi_ulong handler;\n\n    int queue;\n\n\n\n    trace_user_queue_signal(env, sig);\n\n    k = &ts->sigtab[sig - 1];\n\n    queue = gdb_queuesig ();\n\n    handler = sigact_table[sig - 1]._sa_handler;\n\n\n\n    if (sig == TARGET_SIGSEGV && sigismember(&ts->signal_mask, SIGSEGV)) {\n\n        /* Guest has blocked SIGSEGV but we got one anyway. Assume this\n\n         * is a forced SIGSEGV (ie one the kernel handles via force_sig_info\n\n         * because it got a real MMU fault). A blocked SIGSEGV in that\n\n         * situation is treated as if using the default handler. This is\n\n         * not correct if some other process has randomly sent us a SIGSEGV\n\n         * via kill(), but that is not easy to distinguish at this point,\n\n         * so we assume it doesn't happen.\n\n         */\n\n        handler = TARGET_SIG_DFL;\n\n    }\n\n\n\n    if (!queue && handler == TARGET_SIG_DFL) {\n\n        if (sig == TARGET_SIGTSTP || sig == TARGET_SIGTTIN || sig == TARGET_SIGTTOU) {\n\n            kill(getpid(),SIGSTOP);\n\n            return 0;\n\n        } else\n\n        /* default handler : ignore some signal. The other are fatal */\n\n        if (sig != TARGET_SIGCHLD &&\n\n            sig != TARGET_SIGURG &&\n\n            sig != TARGET_SIGWINCH &&\n\n            sig != TARGET_SIGCONT) {\n\n            force_sig(sig);\n\n        } else {\n\n            return 0; /* indicate ignored */\n\n        }\n\n    } else if (!queue && handler == TARGET_SIG_IGN) {\n\n        /* ignore signal */\n\n        return 0;\n\n    } else if (!queue && handler == TARGET_SIG_ERR) {\n\n        force_sig(sig);\n\n    } else {\n\n        pq = &k->first;\n\n        if (sig < TARGET_SIGRTMIN) {\n\n            /* if non real time signal, we queue exactly one signal */\n\n            if (!k->pending)\n\n                q = &k->info;\n\n            else\n\n                return 0;\n\n        } else {\n\n            if (!k->pending) {\n\n                /* first signal */\n\n                q = &k->info;\n\n            } else {\n\n                q = alloc_sigqueue(env);\n\n                if (!q)\n\n                    return -EAGAIN;\n\n                while (*pq != NULL)\n\n                    pq = &(*pq)->next;\n\n            }\n\n        }\n\n        *pq = q;\n\n        q->info = *info;\n\n        q->next = NULL;\n\n        k->pending = 1;\n\n        /* signal that a new signal is pending */\n\n        atomic_set(&ts->signal_pending, 1);\n\n        return 1; /* indicates that the signal was queued */\n\n    }\n\n}\n", "idx": 25822}
{"project": "qemu", "commit_id": "2db59a76c421cdd1039d10e32a9798952d3ff5ba", "target": 1, "func": "void gen_intermediate_code_internal(XtensaCPU *cpu,\n\n                                    TranslationBlock *tb, bool search_pc)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUXtensaState *env = &cpu->env;\n\n    DisasContext dc;\n\n    int insn_count = 0;\n\n    int j, lj = -1;\n\n    uint16_t *gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE;\n\n    int max_insns = tb->cflags & CF_COUNT_MASK;\n\n    uint32_t pc_start = tb->pc;\n\n    uint32_t next_page_start =\n\n        (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n\n\n\n    if (max_insns == 0) {\n\n        max_insns = CF_COUNT_MASK;\n\n    }\n\n\n\n    dc.config = env->config;\n\n    dc.singlestep_enabled = cs->singlestep_enabled;\n\n    dc.tb = tb;\n\n    dc.pc = pc_start;\n\n    dc.ring = tb->flags & XTENSA_TBFLAG_RING_MASK;\n\n    dc.cring = (tb->flags & XTENSA_TBFLAG_EXCM) ? 0 : dc.ring;\n\n    dc.lbeg = env->sregs[LBEG];\n\n    dc.lend = env->sregs[LEND];\n\n    dc.is_jmp = DISAS_NEXT;\n\n    dc.ccount_delta = 0;\n\n    dc.debug = tb->flags & XTENSA_TBFLAG_DEBUG;\n\n    dc.icount = tb->flags & XTENSA_TBFLAG_ICOUNT;\n\n    dc.cpenable = (tb->flags & XTENSA_TBFLAG_CPENABLE_MASK) >>\n\n        XTENSA_TBFLAG_CPENABLE_SHIFT;\n\n\n\n    init_litbase(&dc);\n\n    init_sar_tracker(&dc);\n\n    reset_used_window(&dc);\n\n    if (dc.icount) {\n\n        dc.next_icount = tcg_temp_local_new_i32();\n\n    }\n\n\n\n    gen_tb_start();\n\n\n\n    if (tb->flags & XTENSA_TBFLAG_EXCEPTION) {\n\n        tcg_gen_movi_i32(cpu_pc, dc.pc);\n\n        gen_exception(&dc, EXCP_DEBUG);\n\n    }\n\n\n\n    do {\n\n        check_breakpoint(env, &dc);\n\n\n\n        if (search_pc) {\n\n            j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j) {\n\n                    tcg_ctx.gen_opc_instr_start[lj++] = 0;\n\n                }\n\n            }\n\n            tcg_ctx.gen_opc_pc[lj] = dc.pc;\n\n            tcg_ctx.gen_opc_instr_start[lj] = 1;\n\n            tcg_ctx.gen_opc_icount[lj] = insn_count;\n\n        }\n\n\n\n        if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {\n\n            tcg_gen_debug_insn_start(dc.pc);\n\n        }\n\n\n\n        ++dc.ccount_delta;\n\n\n\n        if (insn_count + 1 == max_insns && (tb->cflags & CF_LAST_IO)) {\n\n            gen_io_start();\n\n        }\n\n\n\n        if (dc.icount) {\n\n            int label = gen_new_label();\n\n\n\n            tcg_gen_addi_i32(dc.next_icount, cpu_SR[ICOUNT], 1);\n\n            tcg_gen_brcondi_i32(TCG_COND_NE, dc.next_icount, 0, label);\n\n            tcg_gen_mov_i32(dc.next_icount, cpu_SR[ICOUNT]);\n\n            if (dc.debug) {\n\n                gen_debug_exception(&dc, DEBUGCAUSE_IC);\n\n            }\n\n            gen_set_label(label);\n\n        }\n\n\n\n        if (dc.debug) {\n\n            gen_ibreak_check(env, &dc);\n\n        }\n\n\n\n        disas_xtensa_insn(env, &dc);\n\n        ++insn_count;\n\n        if (dc.icount) {\n\n            tcg_gen_mov_i32(cpu_SR[ICOUNT], dc.next_icount);\n\n        }\n\n        if (cs->singlestep_enabled) {\n\n            tcg_gen_movi_i32(cpu_pc, dc.pc);\n\n            gen_exception(&dc, EXCP_DEBUG);\n\n            break;\n\n        }\n\n    } while (dc.is_jmp == DISAS_NEXT &&\n\n            insn_count < max_insns &&\n\n            dc.pc < next_page_start &&\n\n            dc.pc + xtensa_insn_len(env, &dc) <= next_page_start &&\n\n            tcg_ctx.gen_opc_ptr < gen_opc_end);\n\n\n\n    reset_litbase(&dc);\n\n    reset_sar_tracker(&dc);\n\n    if (dc.icount) {\n\n        tcg_temp_free(dc.next_icount);\n\n    }\n\n\n\n    if (tb->cflags & CF_LAST_IO) {\n\n        gen_io_end();\n\n    }\n\n\n\n    if (dc.is_jmp == DISAS_NEXT) {\n\n        gen_jumpi(&dc, dc.pc, 0);\n\n    }\n\n    gen_tb_end(tb, insn_count);\n\n    *tcg_ctx.gen_opc_ptr = INDEX_op_end;\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"----------------\\n\");\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n        log_target_disas(env, pc_start, dc.pc - pc_start, 0);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n    if (search_pc) {\n\n        j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n        memset(tcg_ctx.gen_opc_instr_start + lj + 1, 0,\n\n                (j - lj) * sizeof(tcg_ctx.gen_opc_instr_start[0]));\n\n    } else {\n\n        tb->size = dc.pc - pc_start;\n\n        tb->icount = insn_count;\n\n    }\n\n}\n", "idx": 25825}
{"project": "qemu", "commit_id": "c745bfb4300206280ce6156b4bafe765f610057c", "target": 1, "func": "static void dump_map_entry(OutputFormat output_format, MapEntry *e,\n\n                           MapEntry *next)\n\n{\n\n    switch (output_format) {\n\n    case OFORMAT_HUMAN:\n\n        if ((e->flags & BDRV_BLOCK_DATA) &&\n\n            !(e->flags & BDRV_BLOCK_OFFSET_VALID)) {\n\n            error_report(\"File contains external, encrypted or compressed clusters.\");\n\n            exit(1);\n\n        }\n\n        if ((e->flags & (BDRV_BLOCK_DATA|BDRV_BLOCK_ZERO)) == BDRV_BLOCK_DATA) {\n\n            printf(\"%#-16\"PRIx64\"%#-16\"PRIx64\"%#-16\"PRIx64\"%s\\n\",\n\n                   e->start, e->length, e->offset, e->bs->filename);\n\n        }\n\n        /* This format ignores the distinction between 0, ZERO and ZERO|DATA.\n\n         * Modify the flags here to allow more coalescing.\n\n         */\n\n        if (next &&\n\n            (next->flags & (BDRV_BLOCK_DATA|BDRV_BLOCK_ZERO)) != BDRV_BLOCK_DATA) {\n\n            next->flags &= ~BDRV_BLOCK_DATA;\n\n            next->flags |= BDRV_BLOCK_ZERO;\n\n        }\n\n        break;\n\n    case OFORMAT_JSON:\n\n        printf(\"%s{ \\\"start\\\": %\"PRId64\", \\\"length\\\": %\"PRId64\", \\\"depth\\\": %d,\"\n\n               \" \\\"zero\\\": %s, \\\"data\\\": %s\",\n\n               (e->start == 0 ? \"[\" : \",\\n\"),\n\n               e->start, e->length, e->depth,\n\n               (e->flags & BDRV_BLOCK_ZERO) ? \"true\" : \"false\",\n\n               (e->flags & BDRV_BLOCK_DATA) ? \"true\" : \"false\");\n\n        if (e->flags & BDRV_BLOCK_OFFSET_VALID) {\n\n            printf(\", 'offset': %\"PRId64\"\", e->offset);\n\n        }\n\n        putchar('}');\n\n\n\n        if (!next) {\n\n            printf(\"]\\n\");\n\n        }\n\n        break;\n\n    }\n\n}\n", "idx": 25826}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "int escc_init(target_phys_addr_t base, qemu_irq irqA, qemu_irq irqB,\n\n              CharDriverState *chrA, CharDriverState *chrB,\n\n              int clock, int it_shift)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    SerialState *d;\n\n\n\n    dev = qdev_create(NULL, \"escc\");\n\n    qdev_prop_set_uint32(dev, \"disabled\", 0);\n\n    qdev_prop_set_uint32(dev, \"frequency\", clock);\n\n    qdev_prop_set_uint32(dev, \"it_shift\", it_shift);\n\n    qdev_prop_set_chr(dev, \"chrB\", chrB);\n\n    qdev_prop_set_chr(dev, \"chrA\", chrA);\n\n    qdev_prop_set_uint32(dev, \"chnBtype\", ser);\n\n    qdev_prop_set_uint32(dev, \"chnAtype\", ser);\n\n    qdev_init(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irqB);\n\n    sysbus_connect_irq(s, 1, irqA);\n\n    if (base) {\n\n        sysbus_mmio_map(s, 0, base);\n\n    }\n\n\n\n    d = FROM_SYSBUS(SerialState, s);\n\n    return d->mmio_index;\n\n}\n", "idx": 25827}
{"project": "qemu", "commit_id": "35914dc7240f7d81e22219217cfa826c2c383e7b", "target": 1, "func": "static void init_dev(tc58128_dev * dev, const char *filename)\n\n{\n\n    int ret, blocks;\n\n\n\n    dev->state = WAIT;\n\n    dev->flash_contents = g_malloc0(FLASH_SIZE);\n\n    memset(dev->flash_contents, 0xff, FLASH_SIZE);\n\n    if (!dev->flash_contents) {\n\n\tfprintf(stderr, \"could not alloc memory for flash\\n\");\n\n\texit(1);\n\n    }\n\n    if (filename) {\n\n\t/* Load flash image skipping the first block */\n\n\tret = load_image(filename, dev->flash_contents + 528 * 32);\n\n\tif (ret < 0) {\n\n\t    fprintf(stderr, \"ret=%d\\n\", ret);\n\n\t    fprintf(stderr, \"qemu: could not load flash image %s\\n\",\n\n\t\t    filename);\n\n\t    exit(1);\n\n\t} else {\n\n\t    /* Build first block with number of blocks */\n\n\t    blocks = (ret + 528 * 32 - 1) / (528 * 32);\n\n\t    dev->flash_contents[0] = blocks & 0xff;\n\n\t    dev->flash_contents[1] = (blocks >> 8) & 0xff;\n\n\t    dev->flash_contents[2] = (blocks >> 16) & 0xff;\n\n\t    dev->flash_contents[3] = (blocks >> 24) & 0xff;\n\n\t    fprintf(stderr, \"loaded %d bytes for %s into flash\\n\", ret,\n\n\t\t    filename);\n\n\t}\n\n    }\n\n}\n", "idx": 25830}
{"project": "qemu", "commit_id": "0280b3eb7c0519b43452c05cf51f8777d9e38975", "target": 1, "func": "static void ccw_machine_2_9_class_options(MachineClass *mc)\n\n{\n\n    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);\n\n\n\n    s390mc->gs_allowed = false;\n\n    ccw_machine_2_10_class_options(mc);\n\n    SET_MACHINE_COMPAT(mc, CCW_COMPAT_2_9);\n\n    s390mc->css_migration_enabled = false;\n\n}\n", "idx": 25831}
{"project": "qemu", "commit_id": "e53f27b9d9df73461308618151fa6e6392aebd85", "target": 1, "func": "static int tcp_get_msgfd(CharDriverState *chr)\n\n{\n\n    TCPCharDriver *s = chr->opaque;\n\n\n\n    return s->msgfd;\n\n}\n", "idx": 25839}
{"project": "qemu", "commit_id": "5e5557d97026d1d3325e0e7b0ba593366da2f3dc", "target": 1, "func": "static int qcow_make_empty(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint32_t l1_length = s->l1_size * sizeof(uint64_t);\n\n    int ret;\n\n\n\n    memset(s->l1_table, 0, l1_length);\n\n    if (bdrv_pwrite(bs->file, s->l1_table_offset, s->l1_table, l1_length) < 0)\n\n\treturn -1;\n\n    ret = bdrv_truncate(bs->file, s->l1_table_offset + l1_length);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    memset(s->l2_cache, 0, s->l2_size * L2_CACHE_SIZE * sizeof(uint64_t));\n\n    memset(s->l2_cache_offsets, 0, L2_CACHE_SIZE * sizeof(uint64_t));\n\n    memset(s->l2_cache_counts, 0, L2_CACHE_SIZE * sizeof(uint32_t));\n\n\n\n    return 0;\n\n}\n", "idx": 25842}
{"project": "qemu", "commit_id": "1ba4b6a553ad9ff4645af7fab8adfc6e810fcc69", "target": 1, "func": "void bdrv_append_temp_snapshot(BlockDriverState *bs, Error **errp)\n\n{\n\n    /* TODO: extra byte is a hack to ensure MAX_PATH space on Windows. */\n\n    char tmp_filename[PATH_MAX + 1];\n\n\n\n    int64_t total_size;\n\n    BlockDriver *bdrv_qcow2;\n\n    QEMUOptionParameter *create_options;\n\n    QDict *snapshot_options;\n\n    BlockDriverState *bs_snapshot;\n\n    Error *local_err;\n\n    int ret;\n\n\n\n    /* if snapshot, we create a temporary backing file and open it\n\n       instead of opening 'filename' directly */\n\n\n\n    /* Get the required size from the image */\n\n    total_size = bdrv_getlength(bs);\n\n    if (total_size < 0) {\n\n        error_setg_errno(errp, -total_size, \"Could not get image size\");\n\n        return;\n\n    }\n\n    total_size &= BDRV_SECTOR_MASK;\n\n\n\n    /* Create the temporary image */\n\n    ret = get_tmp_filename(tmp_filename, sizeof(tmp_filename));\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"Could not get temporary filename\");\n\n        return;\n\n    }\n\n\n\n    bdrv_qcow2 = bdrv_find_format(\"qcow2\");\n\n    create_options = parse_option_parameters(\"\", bdrv_qcow2->create_options,\n\n                                             NULL);\n\n\n\n    set_option_parameter_int(create_options, BLOCK_OPT_SIZE, total_size);\n\n\n\n    ret = bdrv_create(bdrv_qcow2, tmp_filename, create_options, &local_err);\n\n    free_option_parameters(create_options);\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"Could not create temporary overlay \"\n\n                         \"'%s': %s\", tmp_filename,\n\n                         error_get_pretty(local_err));\n\n        error_free(local_err);\n\n        return;\n\n    }\n\n\n\n    /* Prepare a new options QDict for the temporary file */\n\n    snapshot_options = qdict_new();\n\n    qdict_put(snapshot_options, \"file.driver\",\n\n              qstring_from_str(\"file\"));\n\n    qdict_put(snapshot_options, \"file.filename\",\n\n              qstring_from_str(tmp_filename));\n\n\n\n    bs_snapshot = bdrv_new(\"\", &error_abort);\n\n    bs_snapshot->is_temporary = 1;\n\n\n\n    ret = bdrv_open(&bs_snapshot, NULL, NULL, snapshot_options,\n\n                    bs->open_flags & ~BDRV_O_SNAPSHOT, bdrv_qcow2, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    bdrv_append(bs_snapshot, bs);\n\n}\n", "idx": 25844}
{"project": "qemu", "commit_id": "6bdcc018a6ed760b9dfe43539124e420aed83092", "target": 1, "func": "int nbd_client_co_flush(BlockDriverState *bs)\n\n{\n\n    NBDClientSession *client = nbd_get_client_session(bs);\n\n    NBDRequest request = { .type = NBD_CMD_FLUSH };\n\n    NBDReply reply;\n\n    ssize_t ret;\n\n\n\n    if (!(client->nbdflags & NBD_FLAG_SEND_FLUSH)) {\n\n        return 0;\n\n    }\n\n\n\n    request.from = 0;\n\n    request.len = 0;\n\n\n\n    nbd_coroutine_start(client, &request);\n\n    ret = nbd_co_send_request(bs, &request, NULL);\n\n    if (ret < 0) {\n\n        reply.error = -ret;\n\n    } else {\n\n        nbd_co_receive_reply(client, &request, &reply, NULL);\n\n    }\n\n    nbd_coroutine_end(bs, &request);\n\n    return -reply.error;\n\n}\n", "idx": 25845}
{"project": "qemu", "commit_id": "773b93ee0684a9b9d1f0029a936a251411289027", "target": 1, "func": "int do_sigaction(int sig, const struct target_sigaction *act,\n\n                 struct target_sigaction *oact)\n\n{\n\n    struct emulated_sigaction *k;\n\n\n\n    if (sig < 1 || sig > TARGET_NSIG)\n\n        return -EINVAL;\n\n    k = &sigact_table[sig - 1];\n\n#if defined(DEBUG_SIGNAL) && 0\n\n    fprintf(stderr, \"sigaction sig=%d act=0x%08x, oact=0x%08x\\n\", \n\n            sig, (int)act, (int)oact);\n\n#endif\n\n    if (oact) {\n\n        oact->_sa_handler = tswapl(k->sa._sa_handler);\n\n        oact->sa_flags = tswapl(k->sa.sa_flags);\n\n        oact->sa_restorer = tswapl(k->sa.sa_restorer);\n\n        oact->sa_mask = k->sa.sa_mask;\n\n    }\n\n    if (act) {\n\n        k->sa._sa_handler = tswapl(act->_sa_handler);\n\n        k->sa.sa_flags = tswapl(act->sa_flags);\n\n        k->sa.sa_restorer = tswapl(act->sa_restorer);\n\n        k->sa.sa_mask = act->sa_mask;\n\n    }\n\n    return 0;\n\n}\n", "idx": 25846}
{"project": "qemu", "commit_id": "4ed658ca925249021789d6a51fd6f99f68213f28", "target": 1, "func": "DeviceState *qdev_try_create(BusState *bus, const char *name)\n\n{\n\n    DeviceState *dev;\n\n\n\n\n\n\n    dev = DEVICE(object_new(name));\n\n    if (!dev) {\n\n\n\n\n\n    if (!bus) {\n\n        bus = sysbus_get_default();\n\n\n\n\n    qdev_set_parent_bus(dev, bus);\n\n    qdev_prop_set_globals(dev);\n\n\n\n    return dev;\n", "idx": 25847}
{"project": "qemu", "commit_id": "7453c96b78c2b09aa72924f933bb9616e5474194", "target": 1, "func": "static int check_refblocks(BlockDriverState *bs, BdrvCheckResult *res,\n\n                           BdrvCheckMode fix, bool *rebuild,\n\n                           uint16_t **refcount_table, int64_t *nb_clusters)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t i, size;\n\n    int ret;\n\n\n\n    for(i = 0; i < s->refcount_table_size; i++) {\n\n        uint64_t offset, cluster;\n\n        offset = s->refcount_table[i];\n\n        cluster = offset >> s->cluster_bits;\n\n\n\n        /* Refcount blocks are cluster aligned */\n\n        if (offset_into_cluster(s, offset)) {\n\n            fprintf(stderr, \"ERROR refcount block %\" PRId64 \" is not \"\n\n                \"cluster aligned; refcount table entry corrupted\\n\", i);\n\n            res->corruptions++;\n\n            *rebuild = true;\n\n            continue;\n\n        }\n\n\n\n        if (cluster >= *nb_clusters) {\n\n            fprintf(stderr, \"%s refcount block %\" PRId64 \" is outside image\\n\",\n\n                    fix & BDRV_FIX_ERRORS ? \"Repairing\" : \"ERROR\", i);\n\n\n\n            if (fix & BDRV_FIX_ERRORS) {\n\n                int64_t new_nb_clusters;\n\n\n\n                if (offset > INT64_MAX - s->cluster_size) {\n\n                    ret = -EINVAL;\n\n                    goto resize_fail;\n\n                }\n\n\n\n                ret = bdrv_truncate(bs->file, offset + s->cluster_size);\n\n                if (ret < 0) {\n\n                    goto resize_fail;\n\n                }\n\n                size = bdrv_getlength(bs->file);\n\n                if (size < 0) {\n\n                    ret = size;\n\n                    goto resize_fail;\n\n                }\n\n\n\n                new_nb_clusters = size_to_clusters(s, size);\n\n                assert(new_nb_clusters >= *nb_clusters);\n\n\n\n                ret = realloc_refcount_array(s, refcount_table,\n\n                                             nb_clusters, new_nb_clusters);\n\n                if (ret < 0) {\n\n                    res->check_errors++;\n\n                    return ret;\n\n                }\n\n\n\n                if (cluster >= *nb_clusters) {\n\n                    ret = -EINVAL;\n\n                    goto resize_fail;\n\n                }\n\n\n\n                res->corruptions_fixed++;\n\n                ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                                    offset, s->cluster_size);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                /* No need to check whether the refcount is now greater than 1:\n\n                 * This area was just allocated and zeroed, so it can only be\n\n                 * exactly 1 after inc_refcounts() */\n\n                continue;\n\n\n\nresize_fail:\n\n                res->corruptions++;\n\n                *rebuild = true;\n\n                fprintf(stderr, \"ERROR could not resize image: %s\\n\",\n\n                        strerror(-ret));\n\n            } else {\n\n                res->corruptions++;\n\n            }\n\n            continue;\n\n        }\n\n\n\n        if (offset != 0) {\n\n            ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                                offset, s->cluster_size);\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n            if ((*refcount_table)[cluster] != 1) {\n\n                fprintf(stderr, \"ERROR refcount block %\" PRId64\n\n                        \" refcount=%d\\n\", i, (*refcount_table)[cluster]);\n\n                res->corruptions++;\n\n                *rebuild = true;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 25850}
{"project": "qemu", "commit_id": "79d16c21a565927943486b26789caa62413ff371", "target": 1, "func": "static void virtio_gpu_reset(VirtIODevice *vdev)\n\n{\n\n    VirtIOGPU *g = VIRTIO_GPU(vdev);\n\n    struct virtio_gpu_simple_resource *res, *tmp;\n\n    int i;\n\n\n\n    g->enable = 0;\n\n\n\n    QTAILQ_FOREACH_SAFE(res, &g->reslist, next, tmp) {\n\n        virtio_gpu_resource_destroy(g, res);\n\n    }\n\n    for (i = 0; i < g->conf.max_outputs; i++) {\n\n#if 0\n\n        g->req_state[i].x = 0;\n\n        g->req_state[i].y = 0;\n\n        if (i == 0) {\n\n            g->req_state[0].width = 1024;\n\n            g->req_state[0].height = 768;\n\n        } else {\n\n            g->req_state[i].width = 0;\n\n            g->req_state[i].height = 0;\n\n        }\n\n#endif\n\n        g->scanout[i].resource_id = 0;\n\n        g->scanout[i].width = 0;\n\n        g->scanout[i].height = 0;\n\n        g->scanout[i].x = 0;\n\n        g->scanout[i].y = 0;\n\n        g->scanout[i].ds = NULL;\n\n    }\n\n    g->enabled_output_bitmask = 1;\n\n\n\n#ifdef CONFIG_VIRGL\n\n    if (g->use_virgl_renderer) {\n\n        virtio_gpu_virgl_reset(g);\n\n        g->use_virgl_renderer = 0;\n\n    }\n\n#endif\n\n}\n", "idx": 25852}
{"project": "qemu", "commit_id": "9745807191a81c45970f780166f44a7f93b18653", "target": 1, "func": "static void gen_divu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)\n\n{\n\n    TCGv sr_cy = tcg_temp_new();\n\n    TCGv t0 = tcg_temp_new();\n\n\n\n    tcg_gen_setcondi_tl(TCG_COND_EQ, sr_cy, srcb, 0);\n\n    /* The result of divide-by-zero is undefined.\n\n       Supress the host-side exception by dividing by 1.  */\n\n    tcg_gen_or_tl(t0, srcb, sr_cy);\n\n    tcg_gen_divu_tl(dest, srca, t0);\n\n    tcg_temp_free(t0);\n\n\n\n    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);\n\n\n\n    gen_ove_cy(dc, sr_cy);\n\n    tcg_temp_free(sr_cy);\n\n}\n", "idx": 25853}
{"project": "qemu", "commit_id": "77cb0f5aafc8e6d0c6d3c339f381c9b7921648e0", "target": 1, "func": "static void adb_mouse_class_init(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    ADBDeviceClass *adc = ADB_DEVICE_CLASS(oc);\n\n    ADBMouseClass *amc = ADB_MOUSE_CLASS(oc);\n\n\n\n    amc->parent_realize = dc->realize;\n\n    dc->realize = adb_mouse_realizefn;\n\n    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);\n\n\n\n    adc->devreq = adb_mouse_request;\n\n    dc->reset = adb_mouse_reset;\n\n    dc->vmsd = &vmstate_adb_mouse;\n\n}\n", "idx": 25858}
{"project": "qemu", "commit_id": "3178e2755ec5a7fb1afe583fb6ac2622c2c42184", "target": 1, "func": "static int do_sd_create(char *filename, int64_t vdi_size,\n\n                        uint32_t base_vid, uint32_t *vdi_id, int snapshot,\n\n                        const char *addr, const char *port)\n\n{\n\n    SheepdogVdiReq hdr;\n\n    SheepdogVdiRsp *rsp = (SheepdogVdiRsp *)&hdr;\n\n    int fd, ret;\n\n    unsigned int wlen, rlen = 0;\n\n    char buf[SD_MAX_VDI_LEN];\n\n\n\n    fd = connect_to_sdog(addr, port);\n\n    if (fd < 0) {\n\n        return fd;\n\n    }\n\n\n\n    memset(buf, 0, sizeof(buf));\n\n    strncpy(buf, filename, SD_MAX_VDI_LEN);\n\n\n\n    memset(&hdr, 0, sizeof(hdr));\n\n    hdr.opcode = SD_OP_NEW_VDI;\n\n    hdr.base_vdi_id = base_vid;\n\n\n\n    wlen = SD_MAX_VDI_LEN;\n\n\n\n    hdr.flags = SD_FLAG_CMD_WRITE;\n\n    hdr.snapid = snapshot;\n\n\n\n    hdr.data_length = wlen;\n\n    hdr.vdi_size = vdi_size;\n\n\n\n    ret = do_req(fd, (SheepdogReq *)&hdr, buf, &wlen, &rlen);\n\n\n\n    closesocket(fd);\n\n\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    if (rsp->result != SD_RES_SUCCESS) {\n\n        error_report(\"%s, %s\", sd_strerror(rsp->result), filename);\n\n        return -EIO;\n\n    }\n\n\n\n    if (vdi_id) {\n\n        *vdi_id = rsp->vdi_id;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 25860}
{"project": "qemu", "commit_id": "248de4a89915001e64176580d620d22b612e06f2", "target": 1, "func": "static void test_dma_fragmented(void)\n\n{\n\n    AHCIQState *ahci;\n\n    AHCICommand *cmd;\n\n    uint8_t px;\n\n    size_t bufsize = 4096;\n\n    unsigned char *tx = g_malloc(bufsize);\n\n    unsigned char *rx = g_malloc0(bufsize);\n\n    uint64_t ptr;\n\n\n\n    ahci = ahci_boot_and_enable(NULL);\n\n    px = ahci_port_select(ahci);\n\n    ahci_port_clear(ahci, px);\n\n\n\n    /* create pattern */\n\n    generate_pattern(tx, bufsize, AHCI_SECTOR_SIZE);\n\n\n\n    /* Create a DMA buffer in guest memory, and write our pattern to it. */\n\n    ptr = guest_alloc(ahci->parent->alloc, bufsize);\n\n    g_assert(ptr);\n\n    bufwrite(ptr, tx, bufsize);\n\n\n\n    cmd = ahci_command_create(CMD_WRITE_DMA);\n\n    ahci_command_adjust(cmd, 0, ptr, bufsize, 32);\n\n    ahci_command_commit(ahci, cmd, px);\n\n    ahci_command_issue(ahci, cmd);\n\n    ahci_command_verify(ahci, cmd);\n\n    g_free(cmd);\n\n\n\n    cmd = ahci_command_create(CMD_READ_DMA);\n\n    ahci_command_adjust(cmd, 0, ptr, bufsize, 32);\n\n    ahci_command_commit(ahci, cmd, px);\n\n    ahci_command_issue(ahci, cmd);\n\n    ahci_command_verify(ahci, cmd);\n\n    g_free(cmd);\n\n\n\n    /* Read back the guest's receive buffer into local memory */\n\n    bufread(ptr, rx, bufsize);\n\n    guest_free(ahci->parent->alloc, ptr);\n\n\n\n    g_assert_cmphex(memcmp(tx, rx, bufsize), ==, 0);\n\n\n\n    ahci_shutdown(ahci);\n\n\n\n    g_free(rx);\n\n    g_free(tx);\n\n}\n", "idx": 25862}
{"project": "qemu", "commit_id": "c5a49c63fa26e8825ad101dfe86339ae4c216539", "target": 1, "func": "void gen_intermediate_code(CPUState *cs, TranslationBlock * tb)\n\n{\n\n    CPUSPARCState *env = cs->env_ptr;\n\n    target_ulong pc_start, last_pc;\n\n    DisasContext dc1, *dc = &dc1;\n\n    int num_insns;\n\n    int max_insns;\n\n    unsigned int insn;\n\n\n\n    memset(dc, 0, sizeof(DisasContext));\n\n    dc->tb = tb;\n\n    pc_start = tb->pc;\n\n    dc->pc = pc_start;\n\n    last_pc = dc->pc;\n\n    dc->npc = (target_ulong) tb->cs_base;\n\n    dc->cc_op = CC_OP_DYNAMIC;\n\n    dc->mem_idx = tb->flags & TB_FLAG_MMU_MASK;\n\n    dc->def = &env->def;\n\n    dc->fpu_enabled = tb_fpu_enabled(tb->flags);\n\n    dc->address_mask_32bit = tb_am_enabled(tb->flags);\n\n    dc->singlestep = (cs->singlestep_enabled || singlestep);\n\n#ifndef CONFIG_USER_ONLY\n\n    dc->supervisor = (tb->flags & TB_FLAG_SUPER) != 0;\n\n#endif\n\n#ifdef TARGET_SPARC64\n\n    dc->fprs_dirty = 0;\n\n    dc->asi = (tb->flags >> TB_FLAG_ASI_SHIFT) & 0xff;\n\n#ifndef CONFIG_USER_ONLY\n\n    dc->hypervisor = (tb->flags & TB_FLAG_HYPER) != 0;\n\n#endif\n\n#endif\n\n\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0) {\n\n        max_insns = CF_COUNT_MASK;\n\n    }\n\n    if (max_insns > TCG_MAX_INSNS) {\n\n        max_insns = TCG_MAX_INSNS;\n\n    }\n\n\n\n    gen_tb_start(tb);\n\n    do {\n\n        if (dc->npc & JUMP_PC) {\n\n            assert(dc->jump_pc[1] == dc->pc + 4);\n\n            tcg_gen_insn_start(dc->pc, dc->jump_pc[0] | JUMP_PC);\n\n        } else {\n\n            tcg_gen_insn_start(dc->pc, dc->npc);\n\n        }\n\n        num_insns++;\n\n        last_pc = dc->pc;\n\n\n\n        if (unlikely(cpu_breakpoint_test(cs, dc->pc, BP_ANY))) {\n\n            if (dc->pc != pc_start) {\n\n                save_state(dc);\n\n            }\n\n            gen_helper_debug(cpu_env);\n\n            tcg_gen_exit_tb(0);\n\n            dc->is_br = 1;\n\n            goto exit_gen_loop;\n\n        }\n\n\n\n        if (num_insns == max_insns && (tb->cflags & CF_LAST_IO)) {\n\n            gen_io_start();\n\n        }\n\n\n\n        insn = cpu_ldl_code(env, dc->pc);\n\n\n\n        disas_sparc_insn(dc, insn);\n\n\n\n        if (dc->is_br)\n\n            break;\n\n        /* if the next PC is different, we abort now */\n\n        if (dc->pc != (last_pc + 4))\n\n            break;\n\n        /* if we reach a page boundary, we stop generation so that the\n\n           PC of a TT_TFAULT exception is always in the right page */\n\n        if ((dc->pc & (TARGET_PAGE_SIZE - 1)) == 0)\n\n            break;\n\n        /* if single step mode, we generate only one instruction and\n\n           generate an exception */\n\n        if (dc->singlestep) {\n\n            break;\n\n        }\n\n    } while (!tcg_op_buf_full() &&\n\n             (dc->pc - pc_start) < (TARGET_PAGE_SIZE - 32) &&\n\n             num_insns < max_insns);\n\n\n\n exit_gen_loop:\n\n    if (tb->cflags & CF_LAST_IO) {\n\n        gen_io_end();\n\n    }\n\n    if (!dc->is_br) {\n\n        if (dc->pc != DYNAMIC_PC &&\n\n            (dc->npc != DYNAMIC_PC && dc->npc != JUMP_PC)) {\n\n            /* static PC and NPC: we can use direct chaining */\n\n            gen_goto_tb(dc, 0, dc->pc, dc->npc);\n\n        } else {\n\n            if (dc->pc != DYNAMIC_PC) {\n\n                tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n            }\n\n            save_npc(dc);\n\n            tcg_gen_exit_tb(0);\n\n        }\n\n    }\n\n    gen_tb_end(tb, num_insns);\n\n\n\n    tb->size = last_pc + 4 - pc_start;\n\n    tb->icount = num_insns;\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)\n\n        && qemu_log_in_addr_range(pc_start)) {\n\n        qemu_log_lock();\n\n        qemu_log(\"--------------\\n\");\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n        log_target_disas(cs, pc_start, last_pc + 4 - pc_start, 0);\n\n        qemu_log(\"\\n\");\n\n        qemu_log_unlock();\n\n    }\n\n#endif\n\n}\n", "idx": 25864}
{"project": "qemu", "commit_id": "ba737541edddf9d0026460eb7b1d1c599b4c8ae9", "target": 1, "func": "static uint32_t pcihotplug_read(void *opaque, uint32_t addr)\n\n{\n\n    uint32_t val = 0;\n\n    struct pci_status *g = opaque;\n\n    switch (addr) {\n\n        case PCI_BASE:\n\n            val = g->up;\n\n            break;\n\n        case PCI_BASE + 4:\n\n            val = g->down;\n\n            break;\n\n        default:\n\n            break;\n\n    }\n\n\n\n    PIIX4_DPRINTF(\"pcihotplug read %x == %x\\n\", addr, val);\n\n    return val;\n\n}\n", "idx": 25865}
{"project": "qemu", "commit_id": "de9b05b807918d40db9e26ddd6a54ad2978ac5b7", "target": 1, "func": "static void cortex_a15_initfn(Object *obj)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(obj);\n\n    set_feature(&cpu->env, ARM_FEATURE_V7);\n\n    set_feature(&cpu->env, ARM_FEATURE_VFP4);\n\n    set_feature(&cpu->env, ARM_FEATURE_VFP_FP16);\n\n    set_feature(&cpu->env, ARM_FEATURE_NEON);\n\n    set_feature(&cpu->env, ARM_FEATURE_THUMB2EE);\n\n    set_feature(&cpu->env, ARM_FEATURE_ARM_DIV);\n\n    set_feature(&cpu->env, ARM_FEATURE_V7MP);\n\n    set_feature(&cpu->env, ARM_FEATURE_GENERIC_TIMER);\n\n    set_feature(&cpu->env, ARM_FEATURE_DUMMY_C15_REGS);\n\n\n    cpu->midr = 0x412fc0f1;\n\n    cpu->reset_fpsid = 0x410430f0;\n\n    cpu->mvfr0 = 0x10110222;\n\n    cpu->mvfr1 = 0x11111111;\n\n    cpu->ctr = 0x8444c004;\n\n    cpu->reset_sctlr = 0x00c50078;\n\n    cpu->id_pfr0 = 0x00001131;\n\n    cpu->id_pfr1 = 0x00011011;\n\n    cpu->id_dfr0 = 0x02010555;\n\n    cpu->id_afr0 = 0x00000000;\n\n    cpu->id_mmfr0 = 0x10201105;\n\n    cpu->id_mmfr1 = 0x20000000;\n\n    cpu->id_mmfr2 = 0x01240000;\n\n    cpu->id_mmfr3 = 0x02102211;\n\n    cpu->id_isar0 = 0x02101110;\n\n    cpu->id_isar1 = 0x13112111;\n\n    cpu->id_isar2 = 0x21232041;\n\n    cpu->id_isar3 = 0x11112131;\n\n    cpu->id_isar4 = 0x10011142;\n\n    cpu->clidr = 0x0a200023;\n\n    cpu->ccsidr[0] = 0x701fe00a; /* 32K L1 dcache */\n\n    cpu->ccsidr[1] = 0x201fe00a; /* 32K L1 icache */\n\n    cpu->ccsidr[2] = 0x711fe07a; /* 4096K L2 unified cache */\n\n    define_arm_cp_regs(cpu, cortexa15_cp_reginfo);\n\n}", "idx": 25866}
{"project": "qemu", "commit_id": "6f2d8978728c48ca46f5c01835438508aace5c64", "target": 1, "func": "void OPPROTO op_check_reservation_64 (void)\n\n{\n\n    if ((uint64_t)env->reserve == (uint64_t)(T0 & ~0x00000003))\n\n        env->reserve = -1;\n\n    RETURN();\n\n}\n", "idx": 25867}
{"project": "qemu", "commit_id": "3592fe0c919cf27a81d8e9f9b4f269553418bb01", "target": 1, "func": "static void serial_update_parameters(SerialState *s)\n\n{\n\n    int speed, parity, data_bits, stop_bits, frame_size;\n\n    QEMUSerialSetParams ssp;\n\n\n\n    if (s->divider == 0)\n\n        return;\n\n\n\n    /* Start bit. */\n\n    frame_size = 1;\n\n    if (s->lcr & 0x08) {\n\n        /* Parity bit. */\n\n        frame_size++;\n\n        if (s->lcr & 0x10)\n\n            parity = 'E';\n\n        else\n\n            parity = 'O';\n\n    } else {\n\n            parity = 'N';\n\n    }\n\n    if (s->lcr & 0x04)\n\n        stop_bits = 2;\n\n    else\n\n        stop_bits = 1;\n\n\n\n    data_bits = (s->lcr & 0x03) + 5;\n\n    frame_size += data_bits + stop_bits;\n\n    speed = s->baudbase / s->divider;\n\n    ssp.speed = speed;\n\n    ssp.parity = parity;\n\n    ssp.data_bits = data_bits;\n\n    ssp.stop_bits = stop_bits;\n\n    s->char_transmit_time =  (NANOSECONDS_PER_SECOND / speed) * frame_size;\n\n    qemu_chr_fe_ioctl(s->chr, CHR_IOCTL_SERIAL_SET_PARAMS, &ssp);\n\n\n\n    DPRINTF(\"speed=%d parity=%c data=%d stop=%d\\n\",\n\n           speed, parity, data_bits, stop_bits);\n\n}\n", "idx": 25871}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "int vnc_job_add_rect(VncJob *job, int x, int y, int w, int h)\n\n{\n\n    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));\n\n\n\n    entry->rect.x = x;\n\n    entry->rect.y = y;\n\n    entry->rect.w = w;\n\n    entry->rect.h = h;\n\n\n\n    vnc_lock_queue(queue);\n\n    QLIST_INSERT_HEAD(&job->rectangles, entry, next);\n\n    vnc_unlock_queue(queue);\n\n    return 1;\n\n}\n", "idx": 25872}
{"project": "qemu", "commit_id": "f3a06403b82c7f036564e4caf18b52ce6885fcfb", "target": 1, "func": "struct GuestFileRead *qmp_guest_file_read(int64_t handle, bool has_count,\n\n                                          int64_t count, Error **errp)\n\n{\n\n    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);\n\n    GuestFileRead *read_data = NULL;\n\n    guchar *buf;\n\n    FILE *fh;\n\n    size_t read_count;\n\n\n\n    if (!gfh) {\n\n        return NULL;\n\n    }\n\n\n\n    if (!has_count) {\n\n        count = QGA_READ_COUNT_DEFAULT;\n\n    } else if (count < 0) {\n\n        error_setg(errp, \"value '%\" PRId64 \"' is invalid for argument count\",\n\n                   count);\n\n        return NULL;\n\n    }\n\n\n\n    fh = gfh->fh;\n\n    buf = g_malloc0(count+1);\n\n    read_count = fread(buf, 1, count, fh);\n\n    if (ferror(fh)) {\n\n        error_setg_errno(errp, errno, \"failed to read file\");\n\n        slog(\"guest-file-read failed, handle: %\" PRId64, handle);\n\n    } else {\n\n        buf[read_count] = 0;\n\n        read_data = g_malloc0(sizeof(GuestFileRead));\n\n        read_data->count = read_count;\n\n        read_data->eof = feof(fh);\n\n        if (read_count) {\n\n            read_data->buf_b64 = g_base64_encode(buf, read_count);\n\n        }\n\n    }\n\n    g_free(buf);\n\n    clearerr(fh);\n\n\n\n    return read_data;\n\n}\n", "idx": 25875}
{"project": "qemu", "commit_id": "908bb9497bcb5543930cc345326afff939a6ffa4", "target": 1, "func": "static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,\n\n    int is_read)\n\n{\n\n    BlockInterfaceErrorAction action =\n\n        drive_get_on_error(req->dev->bs, is_read);\n\n    VirtIOBlock *s = req->dev;\n\n\n\n    if (action == BLOCK_ERR_IGNORE) {\n\n        bdrv_mon_event(req->dev->bs, BDRV_ACTION_IGNORE, is_read);\n\n        return 0;\n\n    }\n\n\n\n    if ((error == ENOSPC && action == BLOCK_ERR_STOP_ENOSPC)\n\n            || action == BLOCK_ERR_STOP_ANY) {\n\n        req->next = s->rq;\n\n        s->rq = req;\n\n        bdrv_mon_event(req->dev->bs, BDRV_ACTION_STOP, is_read);\n\n        vm_stop(0);\n\n    } else {\n\n        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);\n\n        bdrv_mon_event(req->dev->bs, BDRV_ACTION_REPORT, is_read);\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 25876}
{"project": "qemu", "commit_id": "a6b3167fa0e825aebb5a7cd8b437b6d41584a196", "target": 1, "func": "static BlockAIOCB *iscsi_aio_ioctl(BlockDriverState *bs,\n        unsigned long int req, void *buf,\n        BlockCompletionFunc *cb, void *opaque)\n{\n    IscsiLun *iscsilun = bs->opaque;\n    struct iscsi_context *iscsi = iscsilun->iscsi;\n    struct iscsi_data data;\n    IscsiAIOCB *acb;\n    acb = qemu_aio_get(&iscsi_aiocb_info, bs, cb, opaque);\n    acb->iscsilun = iscsilun;\n    acb->bh          = NULL;\n    acb->status      = -EINPROGRESS;\n    acb->buf         = NULL;\n    acb->ioh         = buf;\n    if (req != SG_IO) {\n        iscsi_ioctl_handle_emulated(acb, req, buf);\n        return &acb->common;\n    acb->task = malloc(sizeof(struct scsi_task));\n    if (acb->task == NULL) {\n        error_report(\"iSCSI: Failed to allocate task for scsi command. %s\",\n                     iscsi_get_error(iscsi));\n    memset(acb->task, 0, sizeof(struct scsi_task));\n    switch (acb->ioh->dxfer_direction) {\n    case SG_DXFER_TO_DEV:\n        acb->task->xfer_dir = SCSI_XFER_WRITE;\n        break;\n    case SG_DXFER_FROM_DEV:\n        acb->task->xfer_dir = SCSI_XFER_READ;\n        break;\n    default:\n        acb->task->xfer_dir = SCSI_XFER_NONE;\n        break;\n    acb->task->cdb_size = acb->ioh->cmd_len;\n    memcpy(&acb->task->cdb[0], acb->ioh->cmdp, acb->ioh->cmd_len);\n    acb->task->expxferlen = acb->ioh->dxfer_len;\n    data.size = 0;\n    if (acb->task->xfer_dir == SCSI_XFER_WRITE) {\n        if (acb->ioh->iovec_count == 0) {\n            data.data = acb->ioh->dxferp;\n            data.size = acb->ioh->dxfer_len;\n        } else {\n            scsi_task_set_iov_out(acb->task,\n                                 (struct scsi_iovec *) acb->ioh->dxferp,\n                                 acb->ioh->iovec_count);\n    if (iscsi_scsi_command_async(iscsi, iscsilun->lun, acb->task,\n                                 iscsi_aio_ioctl_cb,\n                                 (data.size > 0) ? &data : NULL,\n                                 acb) != 0) {\n        scsi_free_scsi_task(acb->task);\n    /* tell libiscsi to read straight into the buffer we got from ioctl */\n    if (acb->task->xfer_dir == SCSI_XFER_READ) {\n        if (acb->ioh->iovec_count == 0) {\n            scsi_task_add_data_in_buffer(acb->task,\n                                         acb->ioh->dxfer_len,\n                                         acb->ioh->dxferp);\n        } else {\n            scsi_task_set_iov_in(acb->task,\n                                 (struct scsi_iovec *) acb->ioh->dxferp,\n                                 acb->ioh->iovec_count);\n    iscsi_set_events(iscsilun);\n    return &acb->common;", "idx": 25878}
{"project": "qemu", "commit_id": "9732baf67850dac57dfc7dc8980bf408889a8973", "target": 1, "func": "static void *thread_function(void *data)\n\n{\n\n    GMainLoop *loop;\n\n    loop = g_main_loop_new(NULL, FALSE);\n\n    g_main_loop_run(loop);\n\n    return NULL;\n\n}\n", "idx": 25879}
{"project": "qemu", "commit_id": "63ea491d4efc1e02cda3d335db3a46c81adf14ee", "target": 1, "func": "static DisplaySurface* sdl_create_displaysurface(int width, int height)\n\n{\n\n    DisplaySurface *surface = (DisplaySurface*) g_malloc0(sizeof(DisplaySurface));\n\n    if (surface == NULL) {\n\n        fprintf(stderr, \"sdl_create_displaysurface: malloc failed\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    surface->width = width;\n\n    surface->height = height;\n\n\n\n    if (scaling_active) {\n\n        int linesize;\n\n        PixelFormat pf;\n\n        if (host_format.BytesPerPixel != 2 && host_format.BytesPerPixel != 4) {\n\n            linesize = width * 4;\n\n            pf = qemu_default_pixelformat(32);\n\n        } else {\n\n            linesize = width * host_format.BytesPerPixel;\n\n            pf = sdl_to_qemu_pixelformat(&host_format);\n\n        }\n\n        qemu_alloc_display(surface, width, height, linesize, pf, 0);\n\n        return surface;\n\n    }\n\n\n\n    if (host_format.BitsPerPixel == 16)\n\n        do_sdl_resize(width, height, 16);\n\n    else\n\n        do_sdl_resize(width, height, 32);\n\n\n\n    surface->pf = sdl_to_qemu_pixelformat(real_screen->format);\n\n    surface->linesize = real_screen->pitch;\n\n    surface->data = real_screen->pixels;\n\n\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n    surface->flags = QEMU_REALPIXELS_FLAG | QEMU_BIG_ENDIAN_FLAG;\n\n#else\n\n    surface->flags = QEMU_REALPIXELS_FLAG;\n\n#endif\n\n    allocator = 1;\n\n\n\n    return surface;\n\n}\n", "idx": 25880}
{"project": "qemu", "commit_id": "0fbc20740342713f282b118b4a446c4c43df3f4a", "target": 1, "func": "int kvm_irqchip_send_msi(KVMState *s, MSIMessage msg)\n\n{\n\n    struct kvm_msi msi;\n\n    KVMMSIRoute *route;\n\n\n\n    if (s->direct_msi) {\n\n        msi.address_lo = (uint32_t)msg.address;\n\n        msi.address_hi = msg.address >> 32;\n\n        msi.data = le32_to_cpu(msg.data);\n\n        msi.flags = 0;\n\n        memset(msi.pad, 0, sizeof(msi.pad));\n\n\n\n        return kvm_vm_ioctl(s, KVM_SIGNAL_MSI, &msi);\n\n    }\n\n\n\n    route = kvm_lookup_msi_route(s, msg);\n\n    if (!route) {\n\n        int virq;\n\n\n\n        virq = kvm_irqchip_get_virq(s);\n\n        if (virq < 0) {\n\n            return virq;\n\n        }\n\n\n\n        route = g_malloc(sizeof(KVMMSIRoute));\n\n        route->kroute.gsi = virq;\n\n        route->kroute.type = KVM_IRQ_ROUTING_MSI;\n\n        route->kroute.flags = 0;\n\n        route->kroute.u.msi.address_lo = (uint32_t)msg.address;\n\n        route->kroute.u.msi.address_hi = msg.address >> 32;\n\n        route->kroute.u.msi.data = le32_to_cpu(msg.data);\n\n\n\n        kvm_add_routing_entry(s, &route->kroute);\n\n        kvm_irqchip_commit_routes(s);\n\n\n\n        QTAILQ_INSERT_TAIL(&s->msi_hashtab[kvm_hash_msi(msg.data)], route,\n\n                           entry);\n\n    }\n\n\n\n    assert(route->kroute.type == KVM_IRQ_ROUTING_MSI);\n\n\n\n    return kvm_set_irq(s, route->kroute.gsi, 1);\n\n}\n", "idx": 25885}
{"project": "qemu", "commit_id": "0d2e91c17829729812bf5d22d20dd0f5d2554ec2", "target": 1, "func": "void sd_set_cb(SDState *sd, qemu_irq readonly, qemu_irq insert)\n\n{\n\n    sd->readonly_cb = readonly;\n\n    sd->inserted_cb = insert;\n\n    qemu_set_irq(readonly, bdrv_is_read_only(sd->bdrv));\n\n    qemu_set_irq(insert, bdrv_is_inserted(sd->bdrv));\n\n}\n", "idx": 25886}
{"project": "qemu", "commit_id": "089f26bb735fb414b79f5fa3753910d5339d2a1d", "target": 1, "func": "static void test_primitives(gconstpointer opaque)\n\n{\n\n    TestArgs *args = (TestArgs *) opaque;\n\n    const SerializeOps *ops = args->ops;\n\n    PrimitiveType *pt = args->test_data;\n\n    PrimitiveType *pt_copy = g_malloc0(sizeof(*pt_copy));\n\n    Error *err = NULL;\n\n    void *serialize_data;\n\n    char *double1, *double2;\n\n\n\n    pt_copy->type = pt->type;\n\n    ops->serialize(pt, &serialize_data, visit_primitive_type, &err);\n\n    ops->deserialize((void **)&pt_copy, serialize_data, visit_primitive_type, &err);\n\n\n\n    g_assert(err == NULL);\n\n    g_assert(pt_copy != NULL);\n\n    if (pt->type == PTYPE_STRING) {\n\n        g_assert_cmpstr(pt->value.string, ==, pt_copy->value.string);\n\n        g_free((char *)pt_copy->value.string);\n\n    } else if (pt->type == PTYPE_NUMBER) {\n\n        /* we serialize with %f for our reference visitors, so rather than fuzzy\n\n         * floating math to test \"equality\", just compare the formatted values\n\n         */\n\n        double1 = g_malloc0(calc_float_string_storage(pt->value.number));\n\n        double2 = g_malloc0(calc_float_string_storage(pt_copy->value.number));\n\n        g_assert_cmpstr(double1, ==, double2);\n\n        g_free(double1);\n\n        g_free(double2);\n\n    } else if (pt->type == PTYPE_BOOLEAN) {\n\n        g_assert_cmpint(!!pt->value.max, ==, !!pt->value.max);\n\n    } else {\n\n        g_assert_cmpint(pt->value.max, ==, pt_copy->value.max);\n\n    }\n\n\n\n    ops->cleanup(serialize_data);\n\n    g_free(args);\n\n    g_free(pt_copy);\n\n}\n", "idx": 25891}
{"project": "qemu", "commit_id": "8b3b720620a1137a1b794fc3ed64734236f94e06", "target": 1, "func": "static int qcow_write_snapshots(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    QCowSnapshot *sn;\n\n    QCowSnapshotHeader h;\n\n    int i, name_size, id_str_size, snapshots_size;\n\n    uint64_t data64;\n\n    uint32_t data32;\n\n    int64_t offset, snapshots_offset;\n\n\n\n    /* compute the size of the snapshots */\n\n    offset = 0;\n\n    for(i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        offset = align_offset(offset, 8);\n\n        offset += sizeof(h);\n\n        offset += strlen(sn->id_str);\n\n        offset += strlen(sn->name);\n\n    }\n\n    snapshots_size = offset;\n\n\n\n    snapshots_offset = qcow2_alloc_clusters(bs, snapshots_size);\n\n    offset = snapshots_offset;\n\n    if (offset < 0) {\n\n        return offset;\n\n    }\n\n\n\n    for(i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        memset(&h, 0, sizeof(h));\n\n        h.l1_table_offset = cpu_to_be64(sn->l1_table_offset);\n\n        h.l1_size = cpu_to_be32(sn->l1_size);\n\n        h.vm_state_size = cpu_to_be32(sn->vm_state_size);\n\n        h.date_sec = cpu_to_be32(sn->date_sec);\n\n        h.date_nsec = cpu_to_be32(sn->date_nsec);\n\n        h.vm_clock_nsec = cpu_to_be64(sn->vm_clock_nsec);\n\n\n\n        id_str_size = strlen(sn->id_str);\n\n        name_size = strlen(sn->name);\n\n        h.id_str_size = cpu_to_be16(id_str_size);\n\n        h.name_size = cpu_to_be16(name_size);\n\n        offset = align_offset(offset, 8);\n\n        if (bdrv_pwrite(bs->file, offset, &h, sizeof(h)) != sizeof(h))\n\n            goto fail;\n\n        offset += sizeof(h);\n\n        if (bdrv_pwrite(bs->file, offset, sn->id_str, id_str_size) != id_str_size)\n\n            goto fail;\n\n        offset += id_str_size;\n\n        if (bdrv_pwrite(bs->file, offset, sn->name, name_size) != name_size)\n\n            goto fail;\n\n        offset += name_size;\n\n    }\n\n\n\n    /* update the various header fields */\n\n    data64 = cpu_to_be64(snapshots_offset);\n\n    if (bdrv_pwrite(bs->file, offsetof(QCowHeader, snapshots_offset),\n\n                    &data64, sizeof(data64)) != sizeof(data64))\n\n        goto fail;\n\n    data32 = cpu_to_be32(s->nb_snapshots);\n\n    if (bdrv_pwrite(bs->file, offsetof(QCowHeader, nb_snapshots),\n\n                    &data32, sizeof(data32)) != sizeof(data32))\n\n        goto fail;\n\n\n\n    /* free the old snapshot table */\n\n    qcow2_free_clusters(bs, s->snapshots_offset, s->snapshots_size);\n\n    s->snapshots_offset = snapshots_offset;\n\n    s->snapshots_size = snapshots_size;\n\n    return 0;\n\n fail:\n\n    return -1;\n\n}\n", "idx": 25892}
{"project": "qemu", "commit_id": "02ffa034fb747f09a4f5658ed64871dcee4aaca2", "target": 1, "func": "void sigaction_invoke(struct sigaction *action,\n\n                      struct qemu_signalfd_siginfo *info)\n\n{\n\n    siginfo_t si = { 0 };\n\n    si.si_signo = info->ssi_signo;\n\n    si.si_errno = info->ssi_errno;\n\n    si.si_code = info->ssi_code;\n\n\n\n    /* Convert the minimal set of fields defined by POSIX.\n\n     * Positive si_code values are reserved for kernel-generated\n\n     * signals, where the valid siginfo fields are determined by\n\n     * the signal number.  But according to POSIX, it is unspecified\n\n     * whether SI_USER and SI_QUEUE have values less than or equal to\n\n     * zero.\n\n     */\n\n    if (info->ssi_code == SI_USER || info->ssi_code == SI_QUEUE ||\n\n        info->ssi_code <= 0) {\n\n        /* SIGTERM, etc.  */\n\n        si.si_pid = info->ssi_pid;\n\n        si.si_uid = info->ssi_uid;\n\n    } else if (info->ssi_signo == SIGILL || info->ssi_signo == SIGFPE ||\n\n               info->ssi_signo == SIGSEGV || info->ssi_signo == SIGBUS) {\n\n        si.si_addr = (void *)(uintptr_t)info->ssi_addr;\n\n    } else if (info->ssi_signo == SIGCHLD) {\n\n        si.si_pid = info->ssi_pid;\n\n        si.si_status = info->ssi_status;\n\n        si.si_uid = info->ssi_uid;\n\n    }\n\n    action->sa_sigaction(info->ssi_signo, &si, NULL);\n\n}\n", "idx": 25893}
{"project": "qemu", "commit_id": "7717f248eebdcfe6de400404d0cf65dcb3633308", "target": 1, "func": "static void openrisc_pic_cpu_handler(void *opaque, int irq, int level)\n\n{\n\n    OpenRISCCPU *cpu = (OpenRISCCPU *)opaque;\n\n    CPUState *cs = CPU(cpu);\n\n    uint32_t irq_bit = 1 << irq;\n\n\n\n    if (irq > 31 || irq < 0) {\n\n        return;\n\n    }\n\n\n\n    if (level) {\n\n        cpu->env.picsr |= irq_bit;\n\n    } else {\n\n        cpu->env.picsr &= ~irq_bit;\n\n    }\n\n\n\n    if (cpu->env.picsr & cpu->env.picmr) {\n\n        cpu_interrupt(cs, CPU_INTERRUPT_HARD);\n\n    } else {\n\n        cpu_reset_interrupt(cs, CPU_INTERRUPT_HARD);\n\n        cpu->env.picsr = 0;\n\n    }\n\n}\n", "idx": 25896}
{"project": "qemu", "commit_id": "90cbed4656108fec86d157ced39192e0774a6615", "target": 1, "func": "static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args,\n                            int opc)\n{\n    int addr_reg, data_reg, arg0, arg1, arg2, mem_index, s_bits;\n#if defined(CONFIG_SOFTMMU)\n    uint32_t *label1_ptr, *label2_ptr;\n    data_reg = *args++;\n    addr_reg = *args++;\n    mem_index = *args;\n    s_bits = opc & 3;\n    arg0 = TCG_REG_O0;\n    arg1 = TCG_REG_O1;\n    arg2 = TCG_REG_O2;\n#if defined(CONFIG_SOFTMMU)\n    /* srl addr_reg, x, arg1 */\n    tcg_out_arithi(s, arg1, addr_reg, TARGET_PAGE_BITS - CPU_TLB_ENTRY_BITS,\n                   SHIFT_SRL);\n    tcg_out_arithi(s, arg0, addr_reg, TARGET_PAGE_MASK | ((1 << s_bits) - 1),\n                   ARITH_AND);\n    /* and arg1, x, arg1 */\n    tcg_out_andi(s, arg1, (CPU_TLB_SIZE - 1) << CPU_TLB_ENTRY_BITS);\n    /* add arg1, x, arg1 */\n    tcg_out_addi(s, arg1, offsetof(CPUState,\n                                   tlb_table[mem_index][0].addr_read));\n    /* add env, arg1, arg1 */\n    tcg_out_arith(s, arg1, TCG_AREG0, arg1, ARITH_ADD);\n    /* ld [arg1], arg2 */\n    tcg_out32(s, TARGET_LD_OP | INSN_RD(arg2) | INSN_RS1(arg1) |\n              INSN_RS2(TCG_REG_G0));\n    /* subcc arg0, arg2, %g0 */\n    tcg_out_arith(s, TCG_REG_G0, arg0, arg2, ARITH_SUBCC);\n    /* will become:\n       be label1 */\n    label1_ptr = (uint32_t *)s->code_ptr;\n    tcg_out32(s, 0);\n    /* mov (delay slot) */\n    tcg_out_mov(s, arg0, addr_reg);\n    /* mov */\n    tcg_out_movi(s, TCG_TYPE_I32, arg1, mem_index);\n    /* XXX: move that code at the end of the TB */\n    /* qemu_ld_helper[s_bits](arg0, arg1) */\n    tcg_out32(s, CALL | ((((tcg_target_ulong)qemu_ld_helpers[s_bits]\n                           - (tcg_target_ulong)s->code_ptr) >> 2)\n                         & 0x3fffffff));\n    /* Store AREG0 in stack to avoid ugly glibc bugs that mangle\n       global registers */\n    // delay slot\n    tcg_out_ldst(s, TCG_AREG0, TCG_REG_CALL_STACK,\n                 TCG_TARGET_CALL_STACK_OFFSET - sizeof(long), HOST_ST_OP);\n    tcg_out_ldst(s, TCG_AREG0, TCG_REG_CALL_STACK,\n                 TCG_TARGET_CALL_STACK_OFFSET - sizeof(long), HOST_LD_OP);\n    /* data_reg = sign_extend(arg0) */\n    switch(opc) {\n    case 0 | 4:\n        /* sll arg0, 24/56, data_reg */\n        tcg_out_arithi(s, data_reg, arg0, (int)sizeof(tcg_target_long) * 8 - 8,\n                       HOST_SLL_OP);\n        /* sra data_reg, 24/56, data_reg */\n        tcg_out_arithi(s, data_reg, data_reg,\n                       (int)sizeof(tcg_target_long) * 8 - 8, HOST_SRA_OP);\n        break;\n    case 1 | 4:\n        /* sll arg0, 16/48, data_reg */\n        tcg_out_arithi(s, data_reg, arg0,\n                       (int)sizeof(tcg_target_long) * 8 - 16, HOST_SLL_OP);\n        /* sra data_reg, 16/48, data_reg */\n        tcg_out_arithi(s, data_reg, data_reg,\n                       (int)sizeof(tcg_target_long) * 8 - 16, HOST_SRA_OP);\n        break;\n    case 2 | 4:\n        /* sll arg0, 32, data_reg */\n        tcg_out_arithi(s, data_reg, arg0, 32, HOST_SLL_OP);\n        /* sra data_reg, 32, data_reg */\n        tcg_out_arithi(s, data_reg, data_reg, 32, HOST_SRA_OP);\n        break;\n    case 0:\n    case 1:\n    case 2:\n    case 3:\n    default:\n        /* mov */\n        tcg_out_mov(s, data_reg, arg0);\n        break;\n    }\n    /* will become:\n       ba label2 */\n    label2_ptr = (uint32_t *)s->code_ptr;\n    tcg_out32(s, 0);\n    /* nop (delay slot */\n    tcg_out_nop(s);\n    /* label1: */\n    *label1_ptr = (INSN_OP(0) | INSN_COND(COND_E, 0) | INSN_OP2(0x2) |\n                   INSN_OFF22((unsigned long)s->code_ptr -\n                              (unsigned long)label1_ptr));\n    /* ld [arg1 + x], arg1 */\n    tcg_out_ldst(s, arg1, arg1, offsetof(CPUTLBEntry, addend) -\n                 offsetof(CPUTLBEntry, addr_read), HOST_LD_OP);\n    /* add addr_reg, arg1, arg0 */\n    tcg_out_arith(s, arg0, addr_reg, arg1, ARITH_ADD);\n    arg0 = addr_reg;\n    switch(opc) {\n    case 0:\n        /* ldub [arg0], data_reg */\n        tcg_out_ldst(s, data_reg, arg0, 0, LDUB);\n        break;\n    case 0 | 4:\n        /* ldsb [arg0], data_reg */\n        tcg_out_ldst(s, data_reg, arg0, 0, LDSB);\n        break;\n    case 1:\n#ifdef TARGET_WORDS_BIGENDIAN\n        /* lduh [arg0], data_reg */\n        tcg_out_ldst(s, data_reg, arg0, 0, LDUH);\n        /* lduha [arg0] ASI_PRIMARY_LITTLE, data_reg */\n        tcg_out_ldst_asi(s, data_reg, arg0, 0, LDUHA, ASI_PRIMARY_LITTLE);\n        break;\n    case 1 | 4:\n#ifdef TARGET_WORDS_BIGENDIAN\n        /* ldsh [arg0], data_reg */\n        tcg_out_ldst(s, data_reg, arg0, 0, LDSH);\n        /* ldsha [arg0] ASI_PRIMARY_LITTLE, data_reg */\n        tcg_out_ldst_asi(s, data_reg, arg0, 0, LDSHA, ASI_PRIMARY_LITTLE);\n        break;\n    case 2:\n#ifdef TARGET_WORDS_BIGENDIAN\n        /* lduw [arg0], data_reg */\n        tcg_out_ldst(s, data_reg, arg0, 0, LDUW);\n        /* lduwa [arg0] ASI_PRIMARY_LITTLE, data_reg */\n        tcg_out_ldst_asi(s, data_reg, arg0, 0, LDUWA, ASI_PRIMARY_LITTLE);\n        break;\n    case 2 | 4:\n#ifdef TARGET_WORDS_BIGENDIAN\n        /* ldsw [arg0], data_reg */\n        tcg_out_ldst(s, data_reg, arg0, 0, LDSW);\n        /* ldswa [arg0] ASI_PRIMARY_LITTLE, data_reg */\n        tcg_out_ldst_asi(s, data_reg, arg0, 0, LDSWA, ASI_PRIMARY_LITTLE);\n        break;\n    case 3:\n#ifdef TARGET_WORDS_BIGENDIAN\n        /* ldx [arg0], data_reg */\n        tcg_out_ldst(s, data_reg, arg0, 0, LDX);\n        /* ldxa [arg0] ASI_PRIMARY_LITTLE, data_reg */\n        tcg_out_ldst_asi(s, data_reg, arg0, 0, LDXA, ASI_PRIMARY_LITTLE);\n        break;\n    default:\n        tcg_abort();\n    }\n#if defined(CONFIG_SOFTMMU)\n    /* label2: */\n    *label2_ptr = (INSN_OP(0) | INSN_COND(COND_A, 0) | INSN_OP2(0x2) |\n                   INSN_OFF22((unsigned long)s->code_ptr -\n                              (unsigned long)label2_ptr));\n}", "idx": 25900}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "static const char *vnc_auth_name(VncDisplay *vd) {\n\n    switch (vd->auth) {\n\n    case VNC_AUTH_INVALID:\n\n        return \"invalid\";\n\n    case VNC_AUTH_NONE:\n\n        return \"none\";\n\n    case VNC_AUTH_VNC:\n\n        return \"vnc\";\n\n    case VNC_AUTH_RA2:\n\n        return \"ra2\";\n\n    case VNC_AUTH_RA2NE:\n\n        return \"ra2ne\";\n\n    case VNC_AUTH_TIGHT:\n\n        return \"tight\";\n\n    case VNC_AUTH_ULTRA:\n\n        return \"ultra\";\n\n    case VNC_AUTH_TLS:\n\n        return \"tls\";\n\n    case VNC_AUTH_VENCRYPT:\n\n#ifdef CONFIG_VNC_TLS\n\n        switch (vd->subauth) {\n\n        case VNC_AUTH_VENCRYPT_PLAIN:\n\n            return \"vencrypt+plain\";\n\n        case VNC_AUTH_VENCRYPT_TLSNONE:\n\n            return \"vencrypt+tls+none\";\n\n        case VNC_AUTH_VENCRYPT_TLSVNC:\n\n            return \"vencrypt+tls+vnc\";\n\n        case VNC_AUTH_VENCRYPT_TLSPLAIN:\n\n            return \"vencrypt+tls+plain\";\n\n        case VNC_AUTH_VENCRYPT_X509NONE:\n\n            return \"vencrypt+x509+none\";\n\n        case VNC_AUTH_VENCRYPT_X509VNC:\n\n            return \"vencrypt+x509+vnc\";\n\n        case VNC_AUTH_VENCRYPT_X509PLAIN:\n\n            return \"vencrypt+x509+plain\";\n\n        case VNC_AUTH_VENCRYPT_TLSSASL:\n\n            return \"vencrypt+tls+sasl\";\n\n        case VNC_AUTH_VENCRYPT_X509SASL:\n\n            return \"vencrypt+x509+sasl\";\n\n        default:\n\n            return \"vencrypt\";\n\n        }\n\n#else\n\n        return \"vencrypt\";\n\n#endif\n\n    case VNC_AUTH_SASL:\n\n        return \"sasl\";\n\n    }\n\n    return \"unknown\";\n\n}\n", "idx": 25902}
{"project": "qemu", "commit_id": "787aaf5703a702094f395db6795e74230282cd62", "target": 1, "func": "static void cpu_x86_register(X86CPU *cpu, const char *name, Error **errp)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    x86_def_t def1, *def = &def1;\n\n\n\n    memset(def, 0, sizeof(*def));\n\n\n\n    if (cpu_x86_find_by_name(cpu, def, name) < 0) {\n\n        error_setg(errp, \"Unable to find CPU definition: %s\", name);\n\n        return;\n\n    }\n\n\n\n    if (kvm_enabled()) {\n\n        def->features[FEAT_KVM] |= kvm_default_features;\n\n    }\n\n    def->features[FEAT_1_ECX] |= CPUID_EXT_HYPERVISOR;\n\n\n\n    object_property_set_str(OBJECT(cpu), def->vendor, \"vendor\", errp);\n\n    object_property_set_int(OBJECT(cpu), def->level, \"level\", errp);\n\n    object_property_set_int(OBJECT(cpu), def->family, \"family\", errp);\n\n    object_property_set_int(OBJECT(cpu), def->model, \"model\", errp);\n\n    object_property_set_int(OBJECT(cpu), def->stepping, \"stepping\", errp);\n\n    env->features[FEAT_1_EDX] = def->features[FEAT_1_EDX];\n\n    env->features[FEAT_1_ECX] = def->features[FEAT_1_ECX];\n\n    env->features[FEAT_8000_0001_EDX] = def->features[FEAT_8000_0001_EDX];\n\n    env->features[FEAT_8000_0001_ECX] = def->features[FEAT_8000_0001_ECX];\n\n    object_property_set_int(OBJECT(cpu), def->xlevel, \"xlevel\", errp);\n\n    env->features[FEAT_KVM] = def->features[FEAT_KVM];\n\n    env->features[FEAT_SVM] = def->features[FEAT_SVM];\n\n    env->features[FEAT_C000_0001_EDX] = def->features[FEAT_C000_0001_EDX];\n\n    env->features[FEAT_7_0_EBX] = def->features[FEAT_7_0_EBX];\n\n    env->cpuid_xlevel2 = def->xlevel2;\n\n\n\n\n    object_property_set_str(OBJECT(cpu), def->model_id, \"model-id\", errp);\n\n}", "idx": 25903}
{"project": "qemu", "commit_id": "71d0770c4cec9f1dc04f4dadcbf7fd6c335030a9", "target": 1, "func": "int bdrv_pwrite(BlockDriverState *bs, int64_t offset,\n                const void *buf1, int count1)\n{\n    BlockDriver *drv = bs->drv;\n    if (!drv)\n        return -ENOMEDIUM;\n    if (!drv->bdrv_pwrite)\n        return bdrv_pwrite_em(bs, offset, buf1, count1);\n    return drv->bdrv_pwrite(bs, offset, buf1, count1);\n}", "idx": 25904}
{"project": "qemu", "commit_id": "e92f0e1910f0655a0edd8d87c5a7262d36517a89", "target": 1, "func": "static BlockAIOCB *blk_aio_prwv(BlockBackend *blk, int64_t offset, int bytes,\n\n                                QEMUIOVector *qiov, CoroutineEntry co_entry,\n\n                                BdrvRequestFlags flags,\n\n                                BlockCompletionFunc *cb, void *opaque)\n\n{\n\n    BlkAioEmAIOCB *acb;\n\n    Coroutine *co;\n\n\n\n    bdrv_inc_in_flight(blk_bs(blk));\n\n    acb = blk_aio_get(&blk_aio_em_aiocb_info, blk, cb, opaque);\n\n    acb->rwco = (BlkRwCo) {\n\n        .blk    = blk,\n\n        .offset = offset,\n\n        .qiov   = qiov,\n\n        .flags  = flags,\n\n        .ret    = NOT_DONE,\n\n    };\n\n    acb->bytes = bytes;\n\n    acb->has_returned = false;\n\n\n\n    co = qemu_coroutine_create(co_entry, acb);\n\n    qemu_coroutine_enter(co);\n\n\n\n    acb->has_returned = true;\n\n    if (acb->rwco.ret != NOT_DONE) {\n\n        aio_bh_schedule_oneshot(blk_get_aio_context(blk),\n\n                                blk_aio_complete_bh, acb);\n\n    }\n\n\n\n    return &acb->common;\n\n}\n", "idx": 25906}
{"project": "qemu", "commit_id": "b544c1aba8681c2fe5d6715fbd37cf6caf1bc7bb", "target": 1, "func": "static void coroutine_fn add_aio_request(BDRVSheepdogState *s, AIOReq *aio_req,\n\n                           struct iovec *iov, int niov, bool create,\n\n                           enum AIOCBState aiocb_type)\n\n{\n\n    int nr_copies = s->inode.nr_copies;\n\n    SheepdogObjReq hdr;\n\n    unsigned int wlen = 0;\n\n    int ret;\n\n    uint64_t oid = aio_req->oid;\n\n    unsigned int datalen = aio_req->data_len;\n\n    uint64_t offset = aio_req->offset;\n\n    uint8_t flags = aio_req->flags;\n\n    uint64_t old_oid = aio_req->base_oid;\n\n\n\n    if (!nr_copies) {\n\n        error_report(\"bug\");\n\n    }\n\n\n\n    memset(&hdr, 0, sizeof(hdr));\n\n\n\n    switch (aiocb_type) {\n\n    case AIOCB_FLUSH_CACHE:\n\n        hdr.opcode = SD_OP_FLUSH_VDI;\n\n        break;\n\n    case AIOCB_READ_UDATA:\n\n        hdr.opcode = SD_OP_READ_OBJ;\n\n        hdr.flags = flags;\n\n        break;\n\n    case AIOCB_WRITE_UDATA:\n\n        if (create) {\n\n            hdr.opcode = SD_OP_CREATE_AND_WRITE_OBJ;\n\n        } else {\n\n            hdr.opcode = SD_OP_WRITE_OBJ;\n\n        }\n\n        wlen = datalen;\n\n        hdr.flags = SD_FLAG_CMD_WRITE | flags;\n\n        break;\n\n    case AIOCB_DISCARD_OBJ:\n\n        hdr.opcode = SD_OP_DISCARD_OBJ;\n\n        break;\n\n    }\n\n\n\n    if (s->cache_flags) {\n\n        hdr.flags |= s->cache_flags;\n\n    }\n\n\n\n    hdr.oid = oid;\n\n    hdr.cow_oid = old_oid;\n\n    hdr.copies = s->inode.nr_copies;\n\n\n\n    hdr.data_length = datalen;\n\n    hdr.offset = offset;\n\n\n\n    hdr.id = aio_req->id;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    s->co_send = qemu_coroutine_self();\n\n    aio_set_fd_handler(s->aio_context, s->fd,\n\n                       co_read_response, co_write_request, s);\n\n    socket_set_cork(s->fd, 1);\n\n\n\n    /* send a header */\n\n    ret = qemu_co_send(s->fd, &hdr, sizeof(hdr));\n\n    if (ret != sizeof(hdr)) {\n\n        error_report(\"failed to send a req, %s\", strerror(errno));\n\n        goto out;\n\n    }\n\n\n\n    if (wlen) {\n\n        ret = qemu_co_sendv(s->fd, iov, niov, aio_req->iov_offset, wlen);\n\n        if (ret != wlen) {\n\n            error_report(\"failed to send a data, %s\", strerror(errno));\n\n        }\n\n    }\n\nout:\n\n    socket_set_cork(s->fd, 0);\n\n    aio_set_fd_handler(s->aio_context, s->fd, co_read_response, NULL, s);\n\n    s->co_send = NULL;\n\n    qemu_co_mutex_unlock(&s->lock);\n\n}\n", "idx": 25908}
{"project": "qemu", "commit_id": "9633fcc6a02f23e3ef00aa5fe3fe9c41f57c3456", "target": 1, "func": "static void init_proc_750gx (CPUPPCState *env)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_spr_7xx(env);\n\n    /* XXX : not implemented (XXX: different from 750fx) */\n\n    spr_register(env, SPR_L2CR, \"L2CR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, NULL,\n\n                 0x00000000);\n\n    /* Time base */\n\n    gen_tbl(env);\n\n    /* Thermal management */\n\n    gen_spr_thrm(env);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_750_THRM4, \"THRM4\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Hardware implementation registers */\n\n    /* XXX : not implemented (XXX: different from 750fx) */\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID1, \"HID1\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented (XXX: different from 750fx) */\n\n    spr_register(env, SPR_750FX_HID2, \"HID2\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Memory management */\n\n    gen_low_BATs(env);\n\n    /* PowerPC 750fx & 750gx has 8 DBATs and 8 IBATs */\n\n    gen_high_BATs(env);\n\n    init_excp_7x0(env);\n\n    env->dcache_line_size = 32;\n\n    env->icache_line_size = 32;\n\n    /* Allocate hardware IRQ controller */\n\n    ppc6xx_irq_init(env);\n\n}\n", "idx": 25909}
{"project": "qemu", "commit_id": "f56b9bc3ae20fc93815b34aa022be919941406ce", "target": 1, "func": "static int cloop_open(BlockDriverState *bs, QDict *options, int flags,\n\n                      Error **errp)\n\n{\n\n    BDRVCloopState *s = bs->opaque;\n\n    uint32_t offsets_size, max_compressed_block_size = 1, i;\n\n    int ret;\n\n\n\n    bs->read_only = 1;\n\n\n\n    /* read header */\n\n    ret = bdrv_pread(bs->file, 128, &s->block_size, 4);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    s->block_size = be32_to_cpu(s->block_size);\n\n    if (s->block_size % 512) {\n\n        error_setg(errp, \"block_size %u must be a multiple of 512\",\n\n                   s->block_size);\n\n        return -EINVAL;\n\n    }\n\n    if (s->block_size == 0) {\n\n        error_setg(errp, \"block_size cannot be zero\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* cloop's create_compressed_fs.c warns about block sizes beyond 256 KB but\n\n     * we can accept more.  Prevent ridiculous values like 4 GB - 1 since we\n\n     * need a buffer this big.\n\n     */\n\n    if (s->block_size > MAX_BLOCK_SIZE) {\n\n        error_setg(errp, \"block_size %u must be %u MB or less\",\n\n                   s->block_size,\n\n                   MAX_BLOCK_SIZE / (1024 * 1024));\n\n        return -EINVAL;\n\n    }\n\n\n\n    ret = bdrv_pread(bs->file, 128 + 4, &s->n_blocks, 4);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    s->n_blocks = be32_to_cpu(s->n_blocks);\n\n\n\n    /* read offsets */\n\n    if (s->n_blocks > UINT32_MAX / sizeof(uint64_t)) {\n\n        /* Prevent integer overflow */\n\n        error_setg(errp, \"n_blocks %u must be %zu or less\",\n\n                   s->n_blocks,\n\n                   UINT32_MAX / sizeof(uint64_t));\n\n        return -EINVAL;\n\n    }\n\n    offsets_size = s->n_blocks * sizeof(uint64_t);\n\n    if (offsets_size > 512 * 1024 * 1024) {\n\n        /* Prevent ridiculous offsets_size which causes memory allocation to\n\n         * fail or overflows bdrv_pread() size.  In practice the 512 MB\n\n         * offsets[] limit supports 16 TB images at 256 KB block size.\n\n         */\n\n        error_setg(errp, \"image requires too many offsets, \"\n\n                   \"try increasing block size\");\n\n        return -EINVAL;\n\n    }\n\n    s->offsets = g_malloc(offsets_size);\n\n\n\n    ret = bdrv_pread(bs->file, 128 + 4 + 4, s->offsets, offsets_size);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    for(i=0;i<s->n_blocks;i++) {\n\n        s->offsets[i] = be64_to_cpu(s->offsets[i]);\n\n        if (i > 0) {\n\n            uint32_t size = s->offsets[i] - s->offsets[i - 1];\n\n            if (size > max_compressed_block_size) {\n\n                max_compressed_block_size = size;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* initialize zlib engine */\n\n    s->compressed_block = g_malloc(max_compressed_block_size + 1);\n\n    s->uncompressed_block = g_malloc(s->block_size);\n\n    if (inflateInit(&s->zstream) != Z_OK) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    s->current_block = s->n_blocks;\n\n\n\n    s->sectors_per_block = s->block_size/512;\n\n    bs->total_sectors = s->n_blocks * s->sectors_per_block;\n\n    qemu_co_mutex_init(&s->lock);\n\n    return 0;\n\n\n\nfail:\n\n    g_free(s->offsets);\n\n    g_free(s->compressed_block);\n\n    g_free(s->uncompressed_block);\n\n    return ret;\n\n}\n", "idx": 25910}
{"project": "qemu", "commit_id": "a0fcac9c21dcbf481eeb5573a738f55023f5a953", "target": 1, "func": "static void spapr_tce_table_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    dc->vmsd = &vmstate_spapr_tce_table;\n\n    dc->init = spapr_tce_table_realize;\n\n    dc->reset = spapr_tce_reset;\n\n\n\n    QLIST_INIT(&spapr_tce_tables);\n\n\n\n    /* hcall-tce */\n\n    spapr_register_hypercall(H_PUT_TCE, h_put_tce);\n\n\n}", "idx": 25911}
{"project": "qemu", "commit_id": "0e3b800e71cb7759d099eabbd8ad4c4fe848e381", "target": 1, "func": "static void lan9118_eeprom_cmd(lan9118_state *s, int cmd, int addr)\n\n{\n\n    s->e2p_cmd = (s->e2p_cmd & 0x10) | (cmd << 28) | addr;\n\n    switch (cmd) {\n\n    case 0:\n\n        s->e2p_data = s->eeprom[addr];\n\n        DPRINTF(\"EEPROM Read %d = 0x%02x\\n\", addr, s->e2p_data);\n\n\n    case 1:\n\n        s->eeprom_writable = 0;\n\n        DPRINTF(\"EEPROM Write Disable\\n\");\n\n\n    case 2: /* EWEN */\n\n        s->eeprom_writable = 1;\n\n        DPRINTF(\"EEPROM Write Enable\\n\");\n\n\n    case 3: /* WRITE */\n\n        if (s->eeprom_writable) {\n\n            s->eeprom[addr] &= s->e2p_data;\n\n            DPRINTF(\"EEPROM Write %d = 0x%02x\\n\", addr, s->e2p_data);\n\n        } else {\n\n            DPRINTF(\"EEPROM Write %d (ignored)\\n\", addr);\n\n        }\n\n\n    case 4: /* WRAL */\n\n        if (s->eeprom_writable) {\n\n            for (addr = 0; addr < 128; addr++) {\n\n                s->eeprom[addr] &= s->e2p_data;\n\n            }\n\n            DPRINTF(\"EEPROM Write All 0x%02x\\n\", s->e2p_data);\n\n        } else {\n\n            DPRINTF(\"EEPROM Write All (ignored)\\n\");\n\n        }\n\n\n    case 5: /* ERASE */\n\n        if (s->eeprom_writable) {\n\n            s->eeprom[addr] = 0xff;\n\n            DPRINTF(\"EEPROM Erase %d\\n\", addr);\n\n        } else {\n\n            DPRINTF(\"EEPROM Erase %d (ignored)\\n\", addr);\n\n        }\n\n\n    case 6: /* ERAL */\n\n        if (s->eeprom_writable) {\n\n            memset(s->eeprom, 0xff, 128);\n\n            DPRINTF(\"EEPROM Erase All\\n\");\n\n        } else {\n\n            DPRINTF(\"EEPROM Erase All (ignored)\\n\");\n\n        }\n\n\n    case 7: /* RELOAD */\n\n        lan9118_reload_eeprom(s);\n\n\n    }\n\n}", "idx": 25913}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "static void spr_write_ibatl (void *opaque, int sprn)\n\n{\n\n    DisasContext *ctx = opaque;\n\n\n\n    gen_op_store_ibatl((sprn - SPR_IBAT0L) / 2);\n\n    RET_STOP(ctx);\n\n}\n", "idx": 25916}
{"project": "qemu", "commit_id": "c52ab08aee6f7d4717fc6b517174043126bd302f", "target": 0, "func": "static void gen_eob_inhibit_irq(DisasContext *s, bool inhibit)\n\n{\n\n    gen_update_cc_op(s);\n\n\n\n    /* If several instructions disable interrupts, only the first does it.  */\n\n    if (inhibit && !(s->flags & HF_INHIBIT_IRQ_MASK)) {\n\n        gen_set_hflag(s, HF_INHIBIT_IRQ_MASK);\n\n    } else {\n\n        gen_reset_hflag(s, HF_INHIBIT_IRQ_MASK);\n\n    }\n\n\n\n    if (s->tb->flags & HF_RF_MASK) {\n\n        gen_helper_reset_rf(cpu_env);\n\n    }\n\n    if (s->singlestep_enabled) {\n\n        gen_helper_debug(cpu_env);\n\n    } else if (s->tf) {\n\n        gen_helper_single_step(cpu_env);\n\n    } else {\n\n        tcg_gen_exit_tb(0);\n\n    }\n\n    s->is_jmp = DISAS_TB_JUMP;\n\n}\n", "idx": 25917}
{"project": "qemu", "commit_id": "dcfd14b3741983c466ad92fa2ae91eeafce3e5d5", "target": 0, "func": "void tb_invalidate_page_range(target_ulong start, target_ulong end)\n\n{\n\n    /* XXX: cannot enable it yet because it yields to MMU exception\n\n       where NIP != read address on PowerPC */\n\n#if 0\n\n    target_ulong phys_addr;\n\n    phys_addr = get_phys_addr_code(env, start);\n\n    tb_invalidate_phys_page_range(phys_addr, phys_addr + end - start, 0);\n\n#endif\n\n}\n", "idx": 25918}
{"project": "qemu", "commit_id": "70a0c19e83aa4c71c879d51e426e89e4b3d4e014", "target": 0, "func": "static bool kvmppc_is_pr(KVMState *ks)\n\n{\n\n    /* Assume KVM-PR if the GET_PVINFO capability is available */\n\n    return kvm_check_extension(ks, KVM_CAP_PPC_GET_PVINFO) != 0;\n\n}\n", "idx": 25919}
{"project": "qemu", "commit_id": "cd9ba1ebcf0439457f22b75b38533f6634f23c5f", "target": 0, "func": "void aio_set_fd_handler(AioContext *ctx,\n\n                        int fd,\n\n                        IOHandler *io_read,\n\n                        IOHandler *io_write,\n\n                        AioFlushHandler *io_flush,\n\n                        void *opaque)\n\n{\n\n    AioHandler *node;\n\n\n\n    node = find_aio_handler(ctx, fd);\n\n\n\n    /* Are we deleting the fd handler? */\n\n    if (!io_read && !io_write) {\n\n        if (node) {\n\n            /* If the lock is held, just mark the node as deleted */\n\n            if (ctx->walking_handlers)\n\n                node->deleted = 1;\n\n            else {\n\n                /* Otherwise, delete it for real.  We can't just mark it as\n\n                 * deleted because deleted nodes are only cleaned up after\n\n                 * releasing the walking_handlers lock.\n\n                 */\n\n                QLIST_REMOVE(node, node);\n\n                g_free(node);\n\n            }\n\n        }\n\n    } else {\n\n        if (node == NULL) {\n\n            /* Alloc and insert if it's not already there */\n\n            node = g_malloc0(sizeof(AioHandler));\n\n            node->fd = fd;\n\n            QLIST_INSERT_HEAD(&ctx->aio_handlers, node, node);\n\n        }\n\n        /* Update handler with latest information */\n\n        node->io_read = io_read;\n\n        node->io_write = io_write;\n\n        node->io_flush = io_flush;\n\n        node->opaque = opaque;\n\n    }\n\n}\n", "idx": 25920}
{"project": "qemu", "commit_id": "74b4c74d5efb0a489bdf0acc5b5d0197167e7649", "target": 0, "func": "static void sigp_store_status_at_address(CPUState *cs, run_on_cpu_data arg)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    SigpInfo *si = arg.host_ptr;\n\n    uint32_t address = si->param & 0x7ffffe00u;\n\n\n\n    /* cpu has to be stopped */\n\n    if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) {\n\n        set_sigp_status(si, SIGP_STAT_INCORRECT_STATE);\n\n        return;\n\n    }\n\n\n\n    cpu_synchronize_state(cs);\n\n\n\n    if (s390_store_status(cpu, address, false)) {\n\n        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);\n\n        return;\n\n    }\n\n    si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;\n\n}\n", "idx": 25921}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t gic_do_cpu_read(void *opaque, target_phys_addr_t addr,\n\n                                unsigned size)\n\n{\n\n    GICState **backref = (GICState **)opaque;\n\n    GICState *s = *backref;\n\n    int id = (backref - s->backref);\n\n    return gic_cpu_read(s, id, addr);\n\n}\n", "idx": 25922}
{"project": "qemu", "commit_id": "6b98bd649520d07df4d1b7a0a54ac73bf178519c", "target": 0, "func": "void bdrv_io_unplug(BlockDriverState *bs)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    if (drv && drv->bdrv_io_unplug) {\n\n        drv->bdrv_io_unplug(bs);\n\n    } else if (bs->file) {\n\n        bdrv_io_unplug(bs->file->bs);\n\n    }\n\n}\n", "idx": 25923}
{"project": "qemu", "commit_id": "9bc3a3a216e2689bfcdd36c3e079333bbdbf3ba0", "target": 0, "func": "static void ehci_advance_async_state(EHCIState *ehci)\n\n{\n\n    const int async = 1;\n\n\n\n    switch(ehci_get_state(ehci, async)) {\n\n    case EST_INACTIVE:\n\n        if (!ehci_async_enabled(ehci)) {\n\n            break;\n\n        }\n\n        ehci_set_state(ehci, async, EST_ACTIVE);\n\n        // No break, fall through to ACTIVE\n\n\n\n    case EST_ACTIVE:\n\n        if (!ehci_async_enabled(ehci)) {\n\n            ehci_queues_rip_all(ehci, async);\n\n            ehci_set_state(ehci, async, EST_INACTIVE);\n\n            break;\n\n        }\n\n\n\n        /* make sure guest has acknowledged the doorbell interrupt */\n\n        /* TO-DO: is this really needed? */\n\n        if (ehci->usbsts & USBSTS_IAA) {\n\n            DPRINTF(\"IAA status bit still set.\\n\");\n\n            break;\n\n        }\n\n\n\n        /* check that address register has been set */\n\n        if (ehci->asynclistaddr == 0) {\n\n            break;\n\n        }\n\n\n\n        ehci_set_state(ehci, async, EST_WAITLISTHEAD);\n\n        ehci_advance_state(ehci, async);\n\n\n\n        /* If the doorbell is set, the guest wants to make a change to the\n\n         * schedule. The host controller needs to release cached data.\n\n         * (section 4.8.2)\n\n         */\n\n        if (ehci->usbcmd & USBCMD_IAAD) {\n\n            /* Remove all unseen qhs from the async qhs queue */\n\n            ehci_queues_rip_unused(ehci, async, 1);\n\n            DPRINTF(\"ASYNC: doorbell request acknowledged\\n\");\n\n            ehci->usbcmd &= ~USBCMD_IAAD;\n\n            ehci_set_interrupt(ehci, USBSTS_IAA);\n\n        }\n\n        break;\n\n\n\n    default:\n\n        /* this should only be due to a developer mistake */\n\n        fprintf(stderr, \"ehci: Bad asynchronous state %d. \"\n\n                \"Resetting to active\\n\", ehci->astate);\n\n        assert(0);\n\n    }\n\n}\n", "idx": 25924}
{"project": "qemu", "commit_id": "54f254f973a1b2ed0f3571390f4de060adfe23e8", "target": 0, "func": "static void uhci_async_complete_packet(USBPacket * packet, void *opaque)\n\n{\n\n    UHCIState *s = opaque;\n\n    UHCI_QH qh;\n\n    UHCI_TD td;\n\n    uint32_t link;\n\n    uint32_t old_td_ctrl;\n\n    uint32_t val;\n\n    uint32_t frame_addr;\n\n    int ret;\n\n\n\n    /* Handle async isochronous packet completion */\n\n    frame_addr = s->async_frame_addr;\n\n    if (frame_addr) {\n\n        cpu_physical_memory_read(frame_addr, (uint8_t *)&link, 4);\n\n        le32_to_cpus(&link);\n\n\n\n        cpu_physical_memory_read(link & ~0xf, (uint8_t *)&td, sizeof(td));\n\n        le32_to_cpus(&td.link);\n\n        le32_to_cpus(&td.ctrl);\n\n        le32_to_cpus(&td.token);\n\n        le32_to_cpus(&td.buffer);\n\n        old_td_ctrl = td.ctrl;\n\n        ret = uhci_handle_td(s, &td, &s->pending_int_mask, 1);\n\n\n\n        /* update the status bits of the TD */\n\n        if (old_td_ctrl != td.ctrl) {\n\n            val = cpu_to_le32(td.ctrl);\n\n            cpu_physical_memory_write((link & ~0xf) + 4,\n\n                                      (const uint8_t *)&val,\n\n                                      sizeof(val));\n\n        }\n\n        if (ret == 2) {\n\n            s->async_frame_addr = frame_addr;\n\n        } else if (ret == 0) {\n\n            /* update qh element link */\n\n            val = cpu_to_le32(td.link);\n\n            cpu_physical_memory_write(frame_addr,\n\n                                      (const uint8_t *)&val,\n\n                                      sizeof(val));\n\n        }\n\n        return;\n\n    }\n\n\n\n    link = s->async_qh;\n\n    if (!link) {\n\n        /* This should never happen. It means a TD somehow got removed\n\n           without cancelling the associated async IO request.  */\n\n        return;\n\n    }\n\n    cpu_physical_memory_read(link & ~0xf, (uint8_t *)&qh, sizeof(qh));\n\n    le32_to_cpus(&qh.link);\n\n    le32_to_cpus(&qh.el_link);\n\n    /* Re-process the queue containing the async packet.  */\n\n    while (1) {\n\n        cpu_physical_memory_read(qh.el_link & ~0xf,\n\n                                 (uint8_t *)&td, sizeof(td));\n\n        le32_to_cpus(&td.link);\n\n        le32_to_cpus(&td.ctrl);\n\n        le32_to_cpus(&td.token);\n\n        le32_to_cpus(&td.buffer);\n\n        old_td_ctrl = td.ctrl;\n\n        ret = uhci_handle_td(s, &td, &s->pending_int_mask, 1);\n\n\n\n        /* update the status bits of the TD */\n\n        if (old_td_ctrl != td.ctrl) {\n\n            val = cpu_to_le32(td.ctrl);\n\n            cpu_physical_memory_write((qh.el_link & ~0xf) + 4,\n\n                                      (const uint8_t *)&val,\n\n                                      sizeof(val));\n\n        }\n\n        if (ret < 0)\n\n            break; /* interrupted frame */\n\n        if (ret == 2) {\n\n            s->async_qh = link;\n\n            break;\n\n        } else if (ret == 0) {\n\n            /* update qh element link */\n\n            qh.el_link = td.link;\n\n            val = cpu_to_le32(qh.el_link);\n\n            cpu_physical_memory_write((link & ~0xf) + 4,\n\n                                      (const uint8_t *)&val,\n\n                                      sizeof(val));\n\n            if (!(qh.el_link & 4))\n\n                break;\n\n        }\n\n        break;\n\n    }\n\n}\n", "idx": 25925}
{"project": "qemu", "commit_id": "f17fd4fdf0df3d2f3444399d04c38d22b9a3e1b7", "target": 0, "func": "static QDict *monitor_parse_arguments(Monitor *mon,\n\n                                      const char **endp,\n\n                                      const mon_cmd_t *cmd)\n\n{\n\n    const char *typestr;\n\n    char *key;\n\n    int c;\n\n    const char *p = *endp;\n\n    char buf[1024];\n\n    QDict *qdict = qdict_new();\n\n\n\n    /* parse the parameters */\n\n    typestr = cmd->args_type;\n\n    for(;;) {\n\n        typestr = key_get_info(typestr, &key);\n\n        if (!typestr)\n\n            break;\n\n        c = *typestr;\n\n        typestr++;\n\n        switch(c) {\n\n        case 'F':\n\n        case 'B':\n\n        case 's':\n\n            {\n\n                int ret;\n\n\n\n                while (qemu_isspace(*p))\n\n                    p++;\n\n                if (*typestr == '?') {\n\n                    typestr++;\n\n                    if (*p == '\\0') {\n\n                        /* no optional string: NULL argument */\n\n                        break;\n\n                    }\n\n                }\n\n                ret = get_str(buf, sizeof(buf), &p);\n\n                if (ret < 0) {\n\n                    switch(c) {\n\n                    case 'F':\n\n                        monitor_printf(mon, \"%s: filename expected\\n\",\n\n                                       cmd->name);\n\n                        break;\n\n                    case 'B':\n\n                        monitor_printf(mon, \"%s: block device name expected\\n\",\n\n                                       cmd->name);\n\n                        break;\n\n                    default:\n\n                        monitor_printf(mon, \"%s: string expected\\n\", cmd->name);\n\n                        break;\n\n                    }\n\n                    goto fail;\n\n                }\n\n                qdict_put(qdict, key, qstring_from_str(buf));\n\n            }\n\n            break;\n\n        case 'O':\n\n            {\n\n                QemuOptsList *opts_list;\n\n                QemuOpts *opts;\n\n\n\n                opts_list = qemu_find_opts(key);\n\n                if (!opts_list || opts_list->desc->name) {\n\n                    goto bad_type;\n\n                }\n\n                while (qemu_isspace(*p)) {\n\n                    p++;\n\n                }\n\n                if (!*p)\n\n                    break;\n\n                if (get_str(buf, sizeof(buf), &p) < 0) {\n\n                    goto fail;\n\n                }\n\n                opts = qemu_opts_parse_noisily(opts_list, buf, true);\n\n                if (!opts) {\n\n                    goto fail;\n\n                }\n\n                qemu_opts_to_qdict(opts, qdict);\n\n                qemu_opts_del(opts);\n\n            }\n\n            break;\n\n        case '/':\n\n            {\n\n                int count, format, size;\n\n\n\n                while (qemu_isspace(*p))\n\n                    p++;\n\n                if (*p == '/') {\n\n                    /* format found */\n\n                    p++;\n\n                    count = 1;\n\n                    if (qemu_isdigit(*p)) {\n\n                        count = 0;\n\n                        while (qemu_isdigit(*p)) {\n\n                            count = count * 10 + (*p - '0');\n\n                            p++;\n\n                        }\n\n                    }\n\n                    size = -1;\n\n                    format = -1;\n\n                    for(;;) {\n\n                        switch(*p) {\n\n                        case 'o':\n\n                        case 'd':\n\n                        case 'u':\n\n                        case 'x':\n\n                        case 'i':\n\n                        case 'c':\n\n                            format = *p++;\n\n                            break;\n\n                        case 'b':\n\n                            size = 1;\n\n                            p++;\n\n                            break;\n\n                        case 'h':\n\n                            size = 2;\n\n                            p++;\n\n                            break;\n\n                        case 'w':\n\n                            size = 4;\n\n                            p++;\n\n                            break;\n\n                        case 'g':\n\n                        case 'L':\n\n                            size = 8;\n\n                            p++;\n\n                            break;\n\n                        default:\n\n                            goto next;\n\n                        }\n\n                    }\n\n                next:\n\n                    if (*p != '\\0' && !qemu_isspace(*p)) {\n\n                        monitor_printf(mon, \"invalid char in format: '%c'\\n\",\n\n                                       *p);\n\n                        goto fail;\n\n                    }\n\n                    if (format < 0)\n\n                        format = default_fmt_format;\n\n                    if (format != 'i') {\n\n                        /* for 'i', not specifying a size gives -1 as size */\n\n                        if (size < 0)\n\n                            size = default_fmt_size;\n\n                        default_fmt_size = size;\n\n                    }\n\n                    default_fmt_format = format;\n\n                } else {\n\n                    count = 1;\n\n                    format = default_fmt_format;\n\n                    if (format != 'i') {\n\n                        size = default_fmt_size;\n\n                    } else {\n\n                        size = -1;\n\n                    }\n\n                }\n\n                qdict_put(qdict, \"count\", qint_from_int(count));\n\n                qdict_put(qdict, \"format\", qint_from_int(format));\n\n                qdict_put(qdict, \"size\", qint_from_int(size));\n\n            }\n\n            break;\n\n        case 'i':\n\n        case 'l':\n\n        case 'M':\n\n            {\n\n                int64_t val;\n\n\n\n                while (qemu_isspace(*p))\n\n                    p++;\n\n                if (*typestr == '?' || *typestr == '.') {\n\n                    if (*typestr == '?') {\n\n                        if (*p == '\\0') {\n\n                            typestr++;\n\n                            break;\n\n                        }\n\n                    } else {\n\n                        if (*p == '.') {\n\n                            p++;\n\n                            while (qemu_isspace(*p))\n\n                                p++;\n\n                        } else {\n\n                            typestr++;\n\n                            break;\n\n                        }\n\n                    }\n\n                    typestr++;\n\n                }\n\n                if (get_expr(mon, &val, &p))\n\n                    goto fail;\n\n                /* Check if 'i' is greater than 32-bit */\n\n                if ((c == 'i') && ((val >> 32) & 0xffffffff)) {\n\n                    monitor_printf(mon, \"\\'%s\\' has failed: \", cmd->name);\n\n                    monitor_printf(mon, \"integer is for 32-bit values\\n\");\n\n                    goto fail;\n\n                } else if (c == 'M') {\n\n                    if (val < 0) {\n\n                        monitor_printf(mon, \"enter a positive value\\n\");\n\n                        goto fail;\n\n                    }\n\n                    val <<= 20;\n\n                }\n\n                qdict_put(qdict, key, qint_from_int(val));\n\n            }\n\n            break;\n\n        case 'o':\n\n            {\n\n                int64_t val;\n\n                char *end;\n\n\n\n                while (qemu_isspace(*p)) {\n\n                    p++;\n\n                }\n\n                if (*typestr == '?') {\n\n                    typestr++;\n\n                    if (*p == '\\0') {\n\n                        break;\n\n                    }\n\n                }\n\n                val = qemu_strtosz_MiB(p, &end);\n\n                if (val < 0) {\n\n                    monitor_printf(mon, \"invalid size\\n\");\n\n                    goto fail;\n\n                }\n\n                qdict_put(qdict, key, qint_from_int(val));\n\n                p = end;\n\n            }\n\n            break;\n\n        case 'T':\n\n            {\n\n                double val;\n\n\n\n                while (qemu_isspace(*p))\n\n                    p++;\n\n                if (*typestr == '?') {\n\n                    typestr++;\n\n                    if (*p == '\\0') {\n\n                        break;\n\n                    }\n\n                }\n\n                if (get_double(mon, &val, &p) < 0) {\n\n                    goto fail;\n\n                }\n\n                if (p[0] && p[1] == 's') {\n\n                    switch (*p) {\n\n                    case 'm':\n\n                        val /= 1e3; p += 2; break;\n\n                    case 'u':\n\n                        val /= 1e6; p += 2; break;\n\n                    case 'n':\n\n                        val /= 1e9; p += 2; break;\n\n                    }\n\n                }\n\n                if (*p && !qemu_isspace(*p)) {\n\n                    monitor_printf(mon, \"Unknown unit suffix\\n\");\n\n                    goto fail;\n\n                }\n\n                qdict_put(qdict, key, qfloat_from_double(val));\n\n            }\n\n            break;\n\n        case 'b':\n\n            {\n\n                const char *beg;\n\n                bool val;\n\n\n\n                while (qemu_isspace(*p)) {\n\n                    p++;\n\n                }\n\n                beg = p;\n\n                while (qemu_isgraph(*p)) {\n\n                    p++;\n\n                }\n\n                if (p - beg == 2 && !memcmp(beg, \"on\", p - beg)) {\n\n                    val = true;\n\n                } else if (p - beg == 3 && !memcmp(beg, \"off\", p - beg)) {\n\n                    val = false;\n\n                } else {\n\n                    monitor_printf(mon, \"Expected 'on' or 'off'\\n\");\n\n                    goto fail;\n\n                }\n\n                qdict_put(qdict, key, qbool_from_bool(val));\n\n            }\n\n            break;\n\n        case '-':\n\n            {\n\n                const char *tmp = p;\n\n                int skip_key = 0;\n\n                /* option */\n\n\n\n                c = *typestr++;\n\n                if (c == '\\0')\n\n                    goto bad_type;\n\n                while (qemu_isspace(*p))\n\n                    p++;\n\n                if (*p == '-') {\n\n                    p++;\n\n                    if(c != *p) {\n\n                        if(!is_valid_option(p, typestr)) {\n\n                  \n\n                            monitor_printf(mon, \"%s: unsupported option -%c\\n\",\n\n                                           cmd->name, *p);\n\n                            goto fail;\n\n                        } else {\n\n                            skip_key = 1;\n\n                        }\n\n                    }\n\n                    if(skip_key) {\n\n                        p = tmp;\n\n                    } else {\n\n                        /* has option */\n\n                        p++;\n\n                        qdict_put(qdict, key, qbool_from_bool(true));\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 'S':\n\n            {\n\n                /* package all remaining string */\n\n                int len;\n\n\n\n                while (qemu_isspace(*p)) {\n\n                    p++;\n\n                }\n\n                if (*typestr == '?') {\n\n                    typestr++;\n\n                    if (*p == '\\0') {\n\n                        /* no remaining string: NULL argument */\n\n                        break;\n\n                    }\n\n                }\n\n                len = strlen(p);\n\n                if (len <= 0) {\n\n                    monitor_printf(mon, \"%s: string expected\\n\",\n\n                                   cmd->name);\n\n                    goto fail;\n\n                }\n\n                qdict_put(qdict, key, qstring_from_str(p));\n\n                p += len;\n\n            }\n\n            break;\n\n        default:\n\n        bad_type:\n\n            monitor_printf(mon, \"%s: unknown type '%c'\\n\", cmd->name, c);\n\n            goto fail;\n\n        }\n\n        g_free(key);\n\n        key = NULL;\n\n    }\n\n    /* check that all arguments were parsed */\n\n    while (qemu_isspace(*p))\n\n        p++;\n\n    if (*p != '\\0') {\n\n        monitor_printf(mon, \"%s: extraneous characters at the end of line\\n\",\n\n                       cmd->name);\n\n        goto fail;\n\n    }\n\n\n\n    return qdict;\n\n\n\nfail:\n\n    QDECREF(qdict);\n\n    g_free(key);\n\n    return NULL;\n\n}\n", "idx": 25927}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void visitor_input_teardown(TestInputVisitorData *data,\n\n                                   const void *unused)\n\n{\n\n    qobject_decref(data->obj);\n\n    data->obj = NULL;\n\n\n\n    if (data->qiv) {\n\n        visit_free(data->qiv);\n\n        data->qiv = NULL;\n\n    }\n\n}\n", "idx": 25928}
{"project": "qemu", "commit_id": "e5cb7e7677010f529d3f0f9dcdb385dea9446f8d", "target": 0, "func": "MigrationState *migrate_get_current(void)\n\n{\n\n    static bool once;\n\n    static MigrationState current_migration = {\n\n        .state = MIGRATION_STATUS_NONE,\n\n        .xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE,\n\n        .mbps = -1,\n\n        .parameters = {\n\n            .compress_level = DEFAULT_MIGRATE_COMPRESS_LEVEL,\n\n            .compress_threads = DEFAULT_MIGRATE_COMPRESS_THREAD_COUNT,\n\n            .decompress_threads = DEFAULT_MIGRATE_DECOMPRESS_THREAD_COUNT,\n\n            .cpu_throttle_initial = DEFAULT_MIGRATE_CPU_THROTTLE_INITIAL,\n\n            .cpu_throttle_increment = DEFAULT_MIGRATE_CPU_THROTTLE_INCREMENT,\n\n            .max_bandwidth = MAX_THROTTLE,\n\n            .downtime_limit = DEFAULT_MIGRATE_SET_DOWNTIME,\n\n            .x_checkpoint_delay = DEFAULT_MIGRATE_X_CHECKPOINT_DELAY,\n\n        },\n\n    };\n\n\n\n    if (!once) {\n\n        current_migration.parameters.tls_creds = g_strdup(\"\");\n\n        current_migration.parameters.tls_hostname = g_strdup(\"\");\n\n        once = true;\n\n    }\n\n    return &current_migration;\n\n}\n", "idx": 25929}
{"project": "qemu", "commit_id": "1f01e50b8330c24714ddca5841fdbb703076b121", "target": 0, "func": "static int coroutine_fn qed_aio_read_data(void *opaque, int ret,\n\n                                          uint64_t offset, size_t len)\n\n{\n\n    QEDAIOCB *acb = opaque;\n\n    BDRVQEDState *s = acb_to_s(acb);\n\n    BlockDriverState *bs = acb->bs;\n\n\n\n    /* Adjust offset into cluster */\n\n    offset += qed_offset_into_cluster(s, acb->cur_pos);\n\n\n\n    trace_qed_aio_read_data(s, acb, ret, offset, len);\n\n\n\n    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);\n\n\n\n    /* Handle zero cluster and backing file reads */\n\n    if (ret == QED_CLUSTER_ZERO) {\n\n        qemu_iovec_memset(&acb->cur_qiov, 0, 0, acb->cur_qiov.size);\n\n        return 0;\n\n    } else if (ret != QED_CLUSTER_FOUND) {\n\n        return qed_read_backing_file(s, acb->cur_pos, &acb->cur_qiov,\n\n                                     &acb->backing_qiov);\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);\n\n    ret = bdrv_co_preadv(bs->file, offset, acb->cur_qiov.size,\n\n                         &acb->cur_qiov, 0);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    return 0;\n\n}\n", "idx": 25930}
{"project": "qemu", "commit_id": "b40acf99bef69fa8ab0f9092ff162fde945eec12", "target": 0, "func": "static void portio_list_add_1(PortioList *piolist,\n\n                              const MemoryRegionPortio *pio_init,\n\n                              unsigned count, unsigned start,\n\n                              unsigned off_low, unsigned off_high)\n\n{\n\n    MemoryRegionPortio *pio;\n\n    MemoryRegionOps *ops;\n\n    MemoryRegion *region, *alias;\n\n    unsigned i;\n\n\n\n    /* Copy the sub-list and null-terminate it.  */\n\n    pio = g_new(MemoryRegionPortio, count + 1);\n\n    memcpy(pio, pio_init, sizeof(MemoryRegionPortio) * count);\n\n    memset(pio + count, 0, sizeof(MemoryRegionPortio));\n\n\n\n    /* Adjust the offsets to all be zero-based for the region.  */\n\n    for (i = 0; i < count; ++i) {\n\n        pio[i].offset -= off_low;\n\n    }\n\n\n\n    ops = g_new0(MemoryRegionOps, 1);\n\n    ops->old_portio = pio;\n\n\n\n    region = g_new(MemoryRegion, 1);\n\n    alias = g_new(MemoryRegion, 1);\n\n    /*\n\n     * Use an alias so that the callback is called with an absolute address,\n\n     * rather than an offset relative to to start + off_low.\n\n     */\n\n    memory_region_init_io(region, ops, piolist->opaque, piolist->name,\n\n                          INT64_MAX);\n\n    memory_region_init_alias(alias, piolist->name,\n\n                             region, start + off_low, off_high - off_low);\n\n    memory_region_add_subregion(piolist->address_space,\n\n                                start + off_low, alias);\n\n    piolist->regions[piolist->nr] = region;\n\n    piolist->aliases[piolist->nr] = alias;\n\n    ++piolist->nr;\n\n}\n", "idx": 25931}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static void tracked_request_end(BdrvTrackedRequest *req)\n\n{\n\n    if (req->serialising) {\n\n        req->bs->serialising_in_flight--;\n\n    }\n\n\n\n    QLIST_REMOVE(req, list);\n\n    qemu_co_queue_restart_all(&req->wait_queue);\n\n}\n", "idx": 25932}
{"project": "qemu", "commit_id": "e1b42f456fad6e797eaf795ed2e400c4e47d5eb4", "target": 0, "func": "static int bochs_read(BlockDriverState *bs, int64_t sector_num,\n\n                    uint8_t *buf, int nb_sectors)\n\n{\n\n    int ret;\n\n\n\n    while (nb_sectors > 0) {\n\n        int64_t block_offset = seek_to_sector(bs, sector_num);\n\n        if (block_offset >= 0) {\n\n            ret = bdrv_pread(bs->file, block_offset, buf, 512);\n\n            if (ret != 512) {\n\n                return -1;\n\n            }\n\n        } else\n\n            memset(buf, 0, 512);\n\n        nb_sectors--;\n\n        sector_num++;\n\n        buf += 512;\n\n    }\n\n    return 0;\n\n}\n", "idx": 25933}
{"project": "qemu", "commit_id": "5039d6e23586fe6bbedc5e4fe302b48a66890ade", "target": 0, "func": "static void ppc_prep_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    const char *boot_device = machine->boot_order;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    PowerPCCPU *cpu = NULL;\n\n    CPUPPCState *env = NULL;\n\n    Nvram *m48t59;\n\n#if 0\n\n    MemoryRegion *xcsr = g_new(MemoryRegion, 1);\n\n#endif\n\n    int linux_boot, i, nb_nics1;\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    uint32_t kernel_base, initrd_base;\n\n    long kernel_size, initrd_size;\n\n    DeviceState *dev;\n\n    PCIHostState *pcihost;\n\n    PCIBus *pci_bus;\n\n    PCIDevice *pci;\n\n    ISABus *isa_bus;\n\n    ISADevice *isa;\n\n    int ppc_boot_device;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n\n\n    sysctrl = g_malloc0(sizeof(sysctrl_t));\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (machine->cpu_model == NULL)\n\n        machine->cpu_model = \"602\";\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        cpu = cpu_ppc_init(machine->cpu_model);\n\n        if (cpu == NULL) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        env = &cpu->env;\n\n\n\n        if (env->flags & POWERPC_FLAG_RTC_CLK) {\n\n            /* POWER / PowerPC 601 RTC clock frequency is 7.8125 MHz */\n\n            cpu_ppc_tb_init(env, 7812500UL);\n\n        } else {\n\n            /* Set time-base frequency to 100 Mhz */\n\n            cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);\n\n        }\n\n        qemu_register_reset(ppc_prep_reset, cpu);\n\n    }\n\n\n\n    /* allocate RAM */\n\n    memory_region_allocate_system_memory(ram, NULL, \"ppc_prep.ram\", ram_size);\n\n    memory_region_add_subregion(sysmem, 0, ram);\n\n\n\n    if (linux_boot) {\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n        /* now we can load the kernel */\n\n        kernel_size = load_image_targphys(kernel_filename, kernel_base,\n\n                                          ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            hw_error(\"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                hw_error(\"qemu: could not load initial ram disk '%s'\\n\",\n\n                          initrd_filename);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n        ppc_boot_device = 'm';\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n        ppc_boot_device = '\\0';\n\n        /* For now, OHW cannot boot from the network. */\n\n        for (i = 0; boot_device[i] != '\\0'; i++) {\n\n            if (boot_device[i] >= 'a' && boot_device[i] <= 'f') {\n\n                ppc_boot_device = boot_device[i];\n\n                break;\n\n            }\n\n        }\n\n        if (ppc_boot_device == '\\0') {\n\n            fprintf(stderr, \"No valid boot device for Mac99 machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    if (PPC_INPUT(env) != PPC_FLAGS_INPUT_6xx) {\n\n        hw_error(\"Only 6xx bus is supported on PREP machine\\n\");\n\n    }\n\n\n\n    dev = qdev_create(NULL, \"raven-pcihost\");\n\n    if (bios_name == NULL) {\n\n        bios_name = BIOS_FILENAME;\n\n    }\n\n    qdev_prop_set_string(dev, \"bios-name\", bios_name);\n\n    qdev_prop_set_uint32(dev, \"elf-machine\", ELF_MACHINE);\n\n    pcihost = PCI_HOST_BRIDGE(dev);\n\n    object_property_add_child(qdev_get_machine(), \"raven\", OBJECT(dev), NULL);\n\n    qdev_init_nofail(dev);\n\n    pci_bus = (PCIBus *)qdev_get_child_bus(dev, \"pci.0\");\n\n    if (pci_bus == NULL) {\n\n        fprintf(stderr, \"Couldn't create PCI host controller.\\n\");\n\n        exit(1);\n\n    }\n\n    sysctrl->contiguous_map_irq = qdev_get_gpio_in(dev, 0);\n\n\n\n    /* PCI -> ISA bridge */\n\n    pci = pci_create_simple(pci_bus, PCI_DEVFN(1, 0), \"i82378\");\n\n    cpu = POWERPC_CPU(first_cpu);\n\n    qdev_connect_gpio_out(&pci->qdev, 0,\n\n                          cpu->env.irq_inputs[PPC6xx_INPUT_INT]);\n\n    qdev_connect_gpio_out(&pci->qdev, 1,\n\n                          qemu_allocate_irq(cpu_request_exit, NULL, 0));\n\n    sysbus_connect_irq(&pcihost->busdev, 0, qdev_get_gpio_in(&pci->qdev, 9));\n\n    sysbus_connect_irq(&pcihost->busdev, 1, qdev_get_gpio_in(&pci->qdev, 11));\n\n    sysbus_connect_irq(&pcihost->busdev, 2, qdev_get_gpio_in(&pci->qdev, 9));\n\n    sysbus_connect_irq(&pcihost->busdev, 3, qdev_get_gpio_in(&pci->qdev, 11));\n\n    isa_bus = ISA_BUS(qdev_get_child_bus(DEVICE(pci), \"isa.0\"));\n\n\n\n    /* Super I/O (parallel + serial ports) */\n\n    isa = isa_create(isa_bus, TYPE_PC87312);\n\n    dev = DEVICE(isa);\n\n    qdev_prop_set_uint8(dev, \"config\", 13); /* fdc, ser0, ser1, par0 */\n\n    qdev_init_nofail(dev);\n\n\n\n    /* init basic PC hardware */\n\n    pci_vga_init(pci_bus);\n\n\n\n    nb_nics1 = nb_nics;\n\n    if (nb_nics1 > NE2000_NB_MAX)\n\n        nb_nics1 = NE2000_NB_MAX;\n\n    for(i = 0; i < nb_nics1; i++) {\n\n        if (nd_table[i].model == NULL) {\n\n\t    nd_table[i].model = g_strdup(\"ne2k_isa\");\n\n        }\n\n        if (strcmp(nd_table[i].model, \"ne2k_isa\") == 0) {\n\n            isa_ne2000_init(isa_bus, ne2000_io[i], ne2000_irq[i],\n\n                            &nd_table[i]);\n\n        } else {\n\n            pci_nic_init_nofail(&nd_table[i], pci_bus, \"ne2k_pci\", NULL);\n\n        }\n\n    }\n\n\n\n    ide_drive_get(hd, ARRAY_SIZE(hd));\n\n    for(i = 0; i < MAX_IDE_BUS; i++) {\n\n        isa_ide_init(isa_bus, ide_iobase[i], ide_iobase2[i], ide_irq[i],\n\n                     hd[2 * i],\n\n\t\t     hd[2 * i + 1]);\n\n    }\n\n    isa_create_simple(isa_bus, \"i8042\");\n\n\n\n    cpu = POWERPC_CPU(first_cpu);\n\n    sysctrl->reset_irq = cpu->env.irq_inputs[PPC6xx_INPUT_HRESET];\n\n\n\n    portio_list_init(&prep_port_list, NULL, prep_portio_list, sysctrl, \"prep\");\n\n    portio_list_add(&prep_port_list, isa_address_space_io(isa), 0x0);\n\n\n\n    /* PowerPC control and status register group */\n\n#if 0\n\n    memory_region_init_io(xcsr, NULL, &PPC_XCSR_ops, NULL, \"ppc-xcsr\", 0x1000);\n\n    memory_region_add_subregion(sysmem, 0xFEFF0000, xcsr);\n\n#endif\n\n\n\n    if (usb_enabled()) {\n\n        pci_create_simple(pci_bus, -1, \"pci-ohci\");\n\n    }\n\n\n\n    m48t59 = m48t59_init_isa(isa_bus, 0x0074, NVRAM_SIZE, 2000, 59);\n\n    if (m48t59 == NULL)\n\n        return;\n\n    sysctrl->nvram = m48t59;\n\n\n\n    /* Initialise NVRAM */\n\n    PPC_NVRAM_set_params(m48t59, NVRAM_SIZE, \"PREP\", ram_size,\n\n                         ppc_boot_device,\n\n                         kernel_base, kernel_size,\n\n                         kernel_cmdline,\n\n                         initrd_base, initrd_size,\n\n                         /* XXX: need an option to load a NVRAM image */\n\n                         0,\n\n                         graphic_width, graphic_height, graphic_depth);\n\n}\n", "idx": 25934}
{"project": "qemu", "commit_id": "b6fcf32d9b851a83dedcb609091236b97cc4a985", "target": 0, "func": "static void visit_nested_struct_list(Visitor *v, void **native, Error **errp)\n\n{\n\n    visit_type_UserDefNestedList(v, (UserDefNestedList **)native, NULL, errp);\n\n}\n", "idx": 25935}
{"project": "qemu", "commit_id": "937470bb5470825e781ae50e92ff973a6b54d80f", "target": 1, "func": "Object *qio_task_get_source(QIOTask *task)\n\n{\n\n    object_ref(task->source);\n\n    return task->source;\n\n}\n", "idx": 25939}
{"project": "qemu", "commit_id": "4ae4b609ee2d5bcc9df6c03c21dc1fed527aada1", "target": 1, "func": "static void gen_ldx(DisasContext *dc, uint32_t code, uint32_t flags)\n\n{\n\n    I_TYPE(instr, code);\n\n\n\n    TCGv addr = tcg_temp_new();\n\n    TCGv data;\n\n\n\n    /*\n\n     * WARNING: Loads into R_ZERO are ignored, but we must generate the\n\n     *          memory access itself to emulate the CPU precisely. Load\n\n     *          from a protected page to R_ZERO will cause SIGSEGV on\n\n     *          the Nios2 CPU.\n\n     */\n\n    if (likely(instr.b != R_ZERO)) {\n\n        data = dc->cpu_R[instr.b];\n\n    } else {\n\n        data = tcg_temp_new();\n\n    }\n\n\n\n    tcg_gen_addi_tl(addr, load_gpr(dc, instr.a), instr.imm16s);\n\n    tcg_gen_qemu_ld_tl(data, addr, dc->mem_idx, flags);\n\n\n\n    if (unlikely(instr.b == R_ZERO)) {\n\n        tcg_temp_free(data);\n\n    }\n\n\n\n    tcg_temp_free(addr);\n\n}\n", "idx": 25940}
{"project": "qemu", "commit_id": "ff52aab2df5c5e10f231481961b88d25a3021724", "target": 1, "func": "static int handle_alloc(BlockDriverState *bs, uint64_t guest_offset,\n    uint64_t *host_offset, uint64_t *bytes, QCowL2Meta **m)\n{\n    BDRVQcowState *s = bs->opaque;\n    int l2_index;\n    uint64_t *l2_table;\n    uint64_t entry;\n    unsigned int nb_clusters;\n    int ret;\n    uint64_t alloc_cluster_offset;\n    trace_qcow2_handle_alloc(qemu_coroutine_self(), guest_offset, *host_offset,\n                             *bytes);\n    assert(*bytes > 0);\n    /*\n     * Calculate the number of clusters to look for. We stop at L2 table\n     * boundaries to keep things simple.\n     */\n    nb_clusters =\n        size_to_clusters(s, offset_into_cluster(s, guest_offset) + *bytes);\n    l2_index = offset_to_l2_index(s, guest_offset);\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n    /* Find L2 entry for the first involved cluster */\n    ret = get_cluster_table(bs, guest_offset, &l2_table, &l2_index);\n    if (ret < 0) {\n        return ret;\n    entry = be64_to_cpu(l2_table[l2_index]);\n    /* For the moment, overwrite compressed clusters one by one */\n    if (entry & QCOW_OFLAG_COMPRESSED) {\n        nb_clusters = 1;\n    } else {\n        nb_clusters = count_cow_clusters(s, nb_clusters, l2_table, l2_index);\n    /* This function is only called when there were no non-COW clusters, so if\n     * we can't find any unallocated or COW clusters either, something is\n     * wrong with our code. */\n    assert(nb_clusters > 0);\n    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n    if (ret < 0) {\n        return ret;\n    /* Allocate, if necessary at a given offset in the image file */\n    alloc_cluster_offset = start_of_cluster(s, *host_offset);\n    ret = do_alloc_cluster_offset(bs, guest_offset, &alloc_cluster_offset,\n                                  &nb_clusters);\n    if (ret < 0) {\n    /* Can't extend contiguous allocation */\n    if (nb_clusters == 0) {\n        *bytes = 0;\n        return 0;\n    /*\n     * Save info needed for meta data update.\n     *\n     * requested_sectors: Number of sectors from the start of the first\n     * newly allocated cluster to the end of the (possibly shortened\n     * before) write request.\n     *\n     * avail_sectors: Number of sectors from the start of the first\n     * newly allocated to the end of the last newly allocated cluster.\n     *\n     * nb_sectors: The number of sectors from the start of the first\n     * newly allocated cluster to the end of the area that the write\n     * request actually writes to (excluding COW at the end)\n     */\n    int requested_sectors =\n        (*bytes + offset_into_cluster(s, guest_offset))\n        >> BDRV_SECTOR_BITS;\n    int avail_sectors = nb_clusters\n                        << (s->cluster_bits - BDRV_SECTOR_BITS);\n    int alloc_n_start = offset_into_cluster(s, guest_offset)\n                        >> BDRV_SECTOR_BITS;\n    int nb_sectors = MIN(requested_sectors, avail_sectors);\n    QCowL2Meta *old_m = *m;\n    *m = g_malloc0(sizeof(**m));\n    **m = (QCowL2Meta) {\n        .next           = old_m,\n        .alloc_offset   = alloc_cluster_offset,\n        .offset         = start_of_cluster(s, guest_offset),\n        .nb_clusters    = nb_clusters,\n        .nb_available   = nb_sectors,\n        .cow_start = {\n            .offset     = 0,\n            .nb_sectors = alloc_n_start,\n        },\n        .cow_end = {\n            .offset     = nb_sectors * BDRV_SECTOR_SIZE,\n            .nb_sectors = avail_sectors - nb_sectors,\n        },\n    };\n    qemu_co_queue_init(&(*m)->dependent_requests);\n    QLIST_INSERT_HEAD(&s->cluster_allocs, *m, next_in_flight);\n    *host_offset = alloc_cluster_offset + offset_into_cluster(s, guest_offset);\n    *bytes = MIN(*bytes, (nb_sectors * BDRV_SECTOR_SIZE)\n                         - offset_into_cluster(s, guest_offset));\n    assert(*bytes != 0);\n    return 1;\nfail:\n    if (*m && (*m)->nb_clusters > 0) {\n        QLIST_REMOVE(*m, next_in_flight);\n    return ret;", "idx": 25942}
{"project": "qemu", "commit_id": "791230d8bbd5c09d80845755a54074cd2d8b5a22", "target": 1, "func": "int qcow2_check_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n                          BdrvCheckMode fix)\n{\n    BDRVQcowState *s = bs->opaque;\n    BdrvCheckResult pre_compare_res;\n    int64_t size, highest_cluster, nb_clusters;\n    uint16_t *refcount_table = NULL;\n    bool rebuild = false;\n    int ret;\n    size = bdrv_getlength(bs->file);\n    if (size < 0) {\n        res->check_errors++;\n        return size;\n    nb_clusters = size_to_clusters(s, size);\n    if (nb_clusters > INT_MAX) {\n        res->check_errors++;\n        return -EFBIG;\n    res->bfi.total_clusters =\n        size_to_clusters(s, bs->total_sectors * BDRV_SECTOR_SIZE);\n    ret = calculate_refcounts(bs, res, fix, &rebuild, &refcount_table,\n    /* In case we don't need to rebuild the refcount structure (but want to fix\n     * something), this function is immediately called again, in which case the\n     * result should be ignored */\n    pre_compare_res = *res;\n    compare_refcounts(bs, res, 0, &rebuild, &highest_cluster, refcount_table,\n                      nb_clusters);\n    if (rebuild && (fix & BDRV_FIX_ERRORS)) {\n        fprintf(stderr, \"Rebuilding refcount structure\\n\");\n        ret = rebuild_refcount_structure(bs, res, &refcount_table,\n    } else if (fix) {\n            fprintf(stderr, \"ERROR need to rebuild refcount structures\\n\");\n            res->check_errors++;\n            ret = -EIO;\n        if (res->leaks || res->corruptions) {\n            *res = pre_compare_res;\n            compare_refcounts(bs, res, fix, &rebuild, &highest_cluster,\n                              refcount_table, nb_clusters);\n    /* check OFLAG_COPIED */\n    ret = check_oflag_copied(bs, res, fix);\n    res->image_end_offset = (highest_cluster + 1) * s->cluster_size;\n    ret = 0;\nfail:\n    g_free(refcount_table);\n    return ret;", "idx": 25944}
{"project": "qemu", "commit_id": "c31bc98e3bcf52fe1cd4b9b7a70869330eae80ea", "target": 1, "func": "static inline void softusb_read_pmem(MilkymistSoftUsbState *s,\n\n        uint32_t offset, uint8_t *buf, uint32_t len)\n\n{\n\n    if (offset + len >= s->pmem_size) {\n\n        error_report(\"milkymist_softusb: read pmem out of bounds \"\n\n                \"at offset 0x%x, len %d\", offset, len);\n\n\n        return;\n\n    }\n\n\n\n    memcpy(buf, s->pmem_ptr + offset, len);\n\n}", "idx": 25946}
{"project": "qemu", "commit_id": "97225170f6ee6d0ad8653916c7a5e4508cbffc18", "target": 1, "func": "static void pmac_ide_atapi_transfer_cb(void *opaque, int ret)\n\n{\n\n    DBDMA_io *io = opaque;\n\n    MACIOIDEState *m = io->opaque;\n\n    IDEState *s = idebus_active_if(&m->bus);\n\n    int64_t offset;\n\n\n\n    MACIO_DPRINTF(\"pmac_ide_atapi_transfer_cb\\n\");\n\n\n\n    if (ret < 0) {\n\n        MACIO_DPRINTF(\"DMA error: %d\\n\", ret);\n\n        ide_atapi_io_error(s, ret);\n\n        goto done;\n\n    }\n\n\n\n    if (!m->dma_active) {\n\n        MACIO_DPRINTF(\"waiting for data (%#x - %#x - %x)\\n\",\n\n                      s->nsector, io->len, s->status);\n\n        /* data not ready yet, wait for the channel to get restarted */\n\n        io->processing = false;\n\n        return;\n\n    }\n\n\n\n    if (s->io_buffer_size <= 0) {\n\n        MACIO_DPRINTF(\"End of IDE transfer\\n\");\n\n        ide_atapi_cmd_ok(s);\n\n        m->dma_active = false;\n\n        goto done;\n\n    }\n\n\n\n    if (io->len == 0) {\n\n        MACIO_DPRINTF(\"End of DMA transfer\\n\");\n\n        goto done;\n\n    }\n\n\n\n    if (s->lba == -1) {\n\n        /* Non-block ATAPI transfer - just copy to RAM */\n\n        s->io_buffer_size = MIN(s->io_buffer_size, io->len);\n\n        cpu_physical_memory_write(io->addr, s->io_buffer, s->io_buffer_size);\n\n        ide_atapi_cmd_ok(s);\n\n        m->dma_active = false;\n\n        goto done;\n\n    }\n\n\n\n    /* Calculate current offset */\n\n    offset = (int64_t)(s->lba << 11) + s->io_buffer_index;\n\n\n\n    pmac_dma_read(s->blk, offset, io->len, pmac_ide_atapi_transfer_cb, io);\n\n    return;\n\n\n\ndone:\n\n    if (ret < 0) {\n\n        block_acct_failed(blk_get_stats(s->blk), &s->acct);\n\n    } else {\n\n        block_acct_done(blk_get_stats(s->blk), &s->acct);\n\n    }\n\n    io->dma_end(opaque);\n\n}\n", "idx": 25951}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_tlbsx_440(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    TCGv t0;\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    t0 = tcg_temp_new();\n\n    gen_addr_reg_index(ctx, t0);\n\n    gen_helper_440_tlbsx(cpu_gpr[rD(ctx->opcode)], cpu_env, t0);\n\n    tcg_temp_free(t0);\n\n    if (Rc(ctx->opcode)) {\n\n        TCGLabel *l1 = gen_new_label();\n\n        tcg_gen_trunc_tl_i32(cpu_crf[0], cpu_so);\n\n        tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_gpr[rD(ctx->opcode)], -1, l1);\n\n        tcg_gen_ori_i32(cpu_crf[0], cpu_crf[0], 0x02);\n\n        gen_set_label(l1);\n\n    }\n\n#endif\n\n}\n", "idx": 25955}
{"project": "qemu", "commit_id": "111049a4ecefc9cf1ac75c773f4c5c165f27fe63", "target": 1, "func": "static void blockdev_backup_prepare(BlkActionState *common, Error **errp)\n\n{\n\n    BlockdevBackupState *state = DO_UPCAST(BlockdevBackupState, common, common);\n\n    BlockdevBackup *backup;\n\n    BlockDriverState *bs, *target;\n\n    Error *local_err = NULL;\n\n\n\n    assert(common->action->type == TRANSACTION_ACTION_KIND_BLOCKDEV_BACKUP);\n\n    backup = common->action->u.blockdev_backup.data;\n\n\n\n    bs = qmp_get_root_bs(backup->device, errp);\n\n    if (!bs) {\n\n        return;\n\n    }\n\n\n\n    target = bdrv_lookup_bs(backup->target, backup->target, errp);\n\n    if (!target) {\n\n        return;\n\n    }\n\n\n\n    /* AioContext is released in .clean() */\n\n    state->aio_context = bdrv_get_aio_context(bs);\n\n    if (state->aio_context != bdrv_get_aio_context(target)) {\n\n        state->aio_context = NULL;\n\n        error_setg(errp, \"Backup between two IO threads is not implemented\");\n\n        return;\n\n    }\n\n    aio_context_acquire(state->aio_context);\n\n    state->bs = bs;\n\n    bdrv_drained_begin(state->bs);\n\n\n\n    do_blockdev_backup(backup, common->block_job_txn, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    state->job = state->bs->job;\n\n}\n", "idx": 25956}
{"project": "qemu", "commit_id": "df83eabd5245828cbca32060aa191d8b03bc5d50", "target": 1, "func": "static int guest_get_network_stats(const char *name,\n\n                       GuestNetworkInterfaceStat *stats)\n\n{\n\n    DWORD if_index = 0;\n\n    MIB_IFROW a_mid_ifrow;\n\n    memset(&a_mid_ifrow, 0, sizeof(a_mid_ifrow));\n\n    if_index = get_interface_index(name);\n\n    a_mid_ifrow.dwIndex = if_index;\n\n    if (NO_ERROR == GetIfEntry(&a_mid_ifrow)) {\n\n        stats->rx_bytes = a_mid_ifrow.dwInOctets;\n\n        stats->rx_packets = a_mid_ifrow.dwInUcastPkts;\n\n        stats->rx_errs = a_mid_ifrow.dwInErrors;\n\n        stats->rx_dropped = a_mid_ifrow.dwInDiscards;\n\n        stats->tx_bytes = a_mid_ifrow.dwOutOctets;\n\n        stats->tx_packets = a_mid_ifrow.dwOutUcastPkts;\n\n        stats->tx_errs = a_mid_ifrow.dwOutErrors;\n\n        stats->tx_dropped = a_mid_ifrow.dwOutDiscards;\n\n        return 0;\n\n    }\n\n    return -1;\n\n}\n", "idx": 25957}
{"project": "qemu", "commit_id": "dc38852aaa4ac187d8b44201f75fc2835241912d", "target": 0, "func": "static int discard_f(BlockBackend *blk, int argc, char **argv)\n\n{\n\n    struct timeval t1, t2;\n\n    int Cflag = 0, qflag = 0;\n\n    int c, ret;\n\n    int64_t offset, count;\n\n\n\n    while ((c = getopt(argc, argv, \"Cq\")) != -1) {\n\n        switch (c) {\n\n        case 'C':\n\n            Cflag = 1;\n\n            break;\n\n        case 'q':\n\n            qflag = 1;\n\n            break;\n\n        default:\n\n            return qemuio_command_usage(&discard_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind != argc - 2) {\n\n        return qemuio_command_usage(&discard_cmd);\n\n    }\n\n\n\n    offset = cvtnum(argv[optind]);\n\n    if (offset < 0) {\n\n        print_cvtnum_err(offset, argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    optind++;\n\n    count = cvtnum(argv[optind]);\n\n    if (count < 0) {\n\n        print_cvtnum_err(count, argv[optind]);\n\n        return 0;\n\n    } else if (count >> BDRV_SECTOR_BITS > INT_MAX) {\n\n        printf(\"length cannot exceed %\"PRIu64\", given %s\\n\",\n\n               (uint64_t)INT_MAX << BDRV_SECTOR_BITS,\n\n               argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    gettimeofday(&t1, NULL);\n\n    ret = blk_discard(blk, offset >> BDRV_SECTOR_BITS,\n\n                      count >> BDRV_SECTOR_BITS);\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (ret < 0) {\n\n        printf(\"discard failed: %s\\n\", strerror(-ret));\n\n        goto out;\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    if (!qflag) {\n\n        t2 = tsub(t2, t1);\n\n        print_report(\"discard\", &t2, offset, count, count, 1, Cflag);\n\n    }\n\n\n\nout:\n\n    return 0;\n\n}\n", "idx": 25958}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void arm_load_kernel(ARMCPU *cpu, struct arm_boot_info *info)\n\n{\n\n    CPUARMState *env = &cpu->env;\n\n    int kernel_size;\n\n    int initrd_size;\n\n    int n;\n\n    int is_linux = 0;\n\n    uint64_t elf_entry;\n\n    target_phys_addr_t entry;\n\n    int big_endian;\n\n    QemuOpts *machine_opts;\n\n\n\n    /* Load the kernel.  */\n\n    if (!info->kernel_filename) {\n\n        fprintf(stderr, \"Kernel image must be specified\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    machine_opts = qemu_opts_find(qemu_find_opts(\"machine\"), 0);\n\n    if (machine_opts) {\n\n        info->dtb_filename = qemu_opt_get(machine_opts, \"dtb\");\n\n    } else {\n\n        info->dtb_filename = NULL;\n\n    }\n\n\n\n    if (!info->secondary_cpu_reset_hook) {\n\n        info->secondary_cpu_reset_hook = default_reset_secondary;\n\n    }\n\n    if (!info->write_secondary_boot) {\n\n        info->write_secondary_boot = default_write_secondary;\n\n    }\n\n\n\n    if (info->nb_cpus == 0)\n\n        info->nb_cpus = 1;\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    big_endian = 1;\n\n#else\n\n    big_endian = 0;\n\n#endif\n\n\n\n    /* Assume that raw images are linux kernels, and ELF images are not.  */\n\n    kernel_size = load_elf(info->kernel_filename, NULL, NULL, &elf_entry,\n\n                           NULL, NULL, big_endian, ELF_MACHINE, 1);\n\n    entry = elf_entry;\n\n    if (kernel_size < 0) {\n\n        kernel_size = load_uimage(info->kernel_filename, &entry, NULL,\n\n                                  &is_linux);\n\n    }\n\n    if (kernel_size < 0) {\n\n        entry = info->loader_start + KERNEL_LOAD_ADDR;\n\n        kernel_size = load_image_targphys(info->kernel_filename, entry,\n\n                                          info->ram_size - KERNEL_LOAD_ADDR);\n\n        is_linux = 1;\n\n    }\n\n    if (kernel_size < 0) {\n\n        fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                info->kernel_filename);\n\n        exit(1);\n\n    }\n\n    info->entry = entry;\n\n    if (is_linux) {\n\n        if (info->initrd_filename) {\n\n            initrd_size = load_image_targphys(info->initrd_filename,\n\n                                              info->loader_start\n\n                                              + INITRD_LOAD_ADDR,\n\n                                              info->ram_size\n\n                                              - INITRD_LOAD_ADDR);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr, \"qemu: could not load initrd '%s'\\n\",\n\n                        info->initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_size = 0;\n\n        }\n\n        info->initrd_size = initrd_size;\n\n\n\n        bootloader[4] = info->board_id;\n\n\n\n        /* for device tree boot, we pass the DTB directly in r2. Otherwise\n\n         * we point to the kernel args.\n\n         */\n\n        if (info->dtb_filename) {\n\n            /* Place the DTB after the initrd in memory */\n\n            target_phys_addr_t dtb_start = TARGET_PAGE_ALIGN(info->loader_start\n\n                                                             + INITRD_LOAD_ADDR\n\n                                                             + initrd_size);\n\n            if (load_dtb(dtb_start, info)) {\n\n                exit(1);\n\n            }\n\n            bootloader[5] = dtb_start;\n\n        } else {\n\n            bootloader[5] = info->loader_start + KERNEL_ARGS_ADDR;\n\n            if (info->ram_size >= (1ULL << 32)) {\n\n                fprintf(stderr, \"qemu: RAM size must be less than 4GB to boot\"\n\n                        \" Linux kernel using ATAGS (try passing a device tree\"\n\n                        \" using -dtb)\\n\");\n\n                exit(1);\n\n            }\n\n        }\n\n        bootloader[6] = entry;\n\n        for (n = 0; n < sizeof(bootloader) / 4; n++) {\n\n            bootloader[n] = tswap32(bootloader[n]);\n\n        }\n\n        rom_add_blob_fixed(\"bootloader\", bootloader, sizeof(bootloader),\n\n                           info->loader_start);\n\n        if (info->nb_cpus > 1) {\n\n            info->write_secondary_boot(cpu, info);\n\n        }\n\n    }\n\n    info->is_linux = is_linux;\n\n\n\n    for (; env; env = env->next_cpu) {\n\n        cpu = arm_env_get_cpu(env);\n\n        env->boot_info = info;\n\n        qemu_register_reset(do_cpu_reset, cpu);\n\n    }\n\n}\n", "idx": 25959}
{"project": "qemu", "commit_id": "db39fcf1f690b02d612e2bfc00980700887abe03", "target": 0, "func": "static CharDriverState *qemu_chr_open_null(void)\n\n{\n\n    CharDriverState *chr;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n    chr->chr_write = null_chr_write;\n\n    chr->explicit_be_open = true;\n\n    return chr;\n\n}\n", "idx": 25960}
{"project": "qemu", "commit_id": "028b0da424ba85049557c61f9f0a8a6698352b41", "target": 0, "func": "static bool nvic_rettobase(NVICState *s)\n\n{\n\n    int irq, nhand = 0;\n\n\n\n    for (irq = ARMV7M_EXCP_RESET; irq < s->num_irq; irq++) {\n\n        if (s->vectors[irq].active) {\n\n            nhand++;\n\n            if (nhand == 2) {\n\n                return 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 25961}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static void qemu_chr_parse_spice_port(QemuOpts *opts, ChardevBackend *backend,\n\n                                      Error **errp)\n\n{\n\n    const char *name = qemu_opt_get(opts, \"name\");\n\n    ChardevSpicePort *spiceport;\n\n\n\n    if (name == NULL) {\n\n        error_setg(errp, \"chardev: spice port: no name given\");\n\n        return;\n\n    }\n\n    spiceport = backend->u.spiceport = g_new0(ChardevSpicePort, 1);\n\n    qemu_chr_parse_common(opts, qapi_ChardevSpicePort_base(spiceport));\n\n    spiceport->fqdn = g_strdup(name);\n\n}\n", "idx": 25962}
{"project": "qemu", "commit_id": "7e01376daea75e888c370aab521a7d4aeaf2ffd1", "target": 0, "func": "void ioinst_handle_xsch(S390CPU *cpu, uint64_t reg1)\n\n{\n\n    int cssid, ssid, schid, m;\n\n    SubchDev *sch;\n\n    int ret = -ENODEV;\n\n    int cc;\n\n\n\n    if (ioinst_disassemble_sch_ident(reg1, &m, &cssid, &ssid, &schid)) {\n\n        program_interrupt(&cpu->env, PGM_OPERAND, 2);\n\n        return;\n\n    }\n\n    trace_ioinst_sch_id(\"xsch\", cssid, ssid, schid);\n\n    sch = css_find_subch(m, cssid, ssid, schid);\n\n    if (sch && css_subch_visible(sch)) {\n\n        ret = css_do_xsch(sch);\n\n    }\n\n    switch (ret) {\n\n    case -ENODEV:\n\n        cc = 3;\n\n        break;\n\n    case -EBUSY:\n\n        cc = 2;\n\n        break;\n\n    case 0:\n\n        cc = 0;\n\n        break;\n\n    default:\n\n        cc = 1;\n\n        break;\n\n    }\n\n    setcc(cpu, cc);\n\n}\n", "idx": 25963}
{"project": "qemu", "commit_id": "37f51384ae05bd50f83308339dbffa3e78404874", "target": 0, "func": "static int vtd_dev_to_context_entry(IntelIOMMUState *s, uint8_t bus_num,\n\n                                    uint8_t devfn, VTDContextEntry *ce)\n\n{\n\n    VTDRootEntry re;\n\n    int ret_fr;\n\n    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(s);\n\n\n\n    ret_fr = vtd_get_root_entry(s, bus_num, &re);\n\n    if (ret_fr) {\n\n        return ret_fr;\n\n    }\n\n\n\n    if (!vtd_root_entry_present(&re)) {\n\n        /* Not error - it's okay we don't have root entry. */\n\n        trace_vtd_re_not_present(bus_num);\n\n        return -VTD_FR_ROOT_ENTRY_P;\n\n    }\n\n\n\n    if (re.rsvd || (re.val & VTD_ROOT_ENTRY_RSVD(VTD_HOST_ADDRESS_WIDTH))) {\n\n        trace_vtd_re_invalid(re.rsvd, re.val);\n\n        return -VTD_FR_ROOT_ENTRY_RSVD;\n\n    }\n\n\n\n    ret_fr = vtd_get_context_entry_from_root(&re, devfn, ce);\n\n    if (ret_fr) {\n\n        return ret_fr;\n\n    }\n\n\n\n    if (!vtd_ce_present(ce)) {\n\n        /* Not error - it's okay we don't have context entry. */\n\n        trace_vtd_ce_not_present(bus_num, devfn);\n\n        return -VTD_FR_CONTEXT_ENTRY_P;\n\n    }\n\n\n\n    if ((ce->hi & VTD_CONTEXT_ENTRY_RSVD_HI) ||\n\n               (ce->lo & VTD_CONTEXT_ENTRY_RSVD_LO(VTD_HOST_ADDRESS_WIDTH))) {\n\n        trace_vtd_ce_invalid(ce->hi, ce->lo);\n\n        return -VTD_FR_CONTEXT_ENTRY_RSVD;\n\n    }\n\n\n\n    /* Check if the programming of context-entry is valid */\n\n    if (!vtd_is_level_supported(s, vtd_ce_get_level(ce))) {\n\n        trace_vtd_ce_invalid(ce->hi, ce->lo);\n\n        return -VTD_FR_CONTEXT_ENTRY_INV;\n\n    }\n\n\n\n    /* Do translation type check */\n\n    if (!vtd_ce_type_check(x86_iommu, ce)) {\n\n        trace_vtd_ce_invalid(ce->hi, ce->lo);\n\n        return -VTD_FR_CONTEXT_ENTRY_INV;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 25964}
{"project": "qemu", "commit_id": "3b22c4707decb706b10ce023534f8b79413ff9fe", "target": 0, "func": "static void do_interrupt_real(int intno, int is_int, int error_code,\n\n                                 unsigned int next_eip)\n\n{\n\n    SegmentCache *dt;\n\n    uint8_t *ptr, *ssp;\n\n    int selector;\n\n    uint32_t offset, esp;\n\n    uint32_t old_cs, old_eip;\n\n\n\n    /* real mode (simpler !) */\n\n    dt = &env->idt;\n\n    if (intno * 4 + 3 > dt->limit)\n\n        raise_exception_err(EXCP0D_GPF, intno * 8 + 2);\n\n    ptr = dt->base + intno * 4;\n\n    offset = lduw(ptr);\n\n    selector = lduw(ptr + 2);\n\n    esp = env->regs[R_ESP];\n\n    ssp = env->segs[R_SS].base;\n\n    if (is_int)\n\n        old_eip = next_eip;\n\n    else\n\n        old_eip = env->eip;\n\n    old_cs = env->segs[R_CS].selector;\n\n    esp -= 2;\n\n    stw(ssp + (esp & 0xffff), compute_eflags());\n\n    esp -= 2;\n\n    stw(ssp + (esp & 0xffff), old_cs);\n\n    esp -= 2;\n\n    stw(ssp + (esp & 0xffff), old_eip);\n\n    \n\n    /* update processor state */\n\n    env->regs[R_ESP] = (env->regs[R_ESP] & ~0xffff) | (esp & 0xffff);\n\n    env->eip = offset;\n\n    env->segs[R_CS].selector = selector;\n\n    env->segs[R_CS].base = (uint8_t *)(selector << 4);\n\n    env->eflags &= ~(IF_MASK | TF_MASK | AC_MASK | RF_MASK);\n\n}\n", "idx": 25965}
{"project": "qemu", "commit_id": "2374e73edafff0586cbfb67c333c5a7588f81fd5", "target": 0, "func": "uint64_t helper_stl_c_raw(uint64_t t0, uint64_t t1)\n\n{\n\n    uint64_t ret;\n\n\n\n    if (t1 == env->lock) {\n\n        stl_raw(t1, t0);\n\n        ret = 0;\n\n    } else\n\n        ret = 1;\n\n\n\n    env->lock = 1;\n\n\n\n    return ret;\n\n}\n", "idx": 25967}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "int AUD_read (SWVoiceIn *sw, void *buf, int size)\n\n{\n\n    int bytes;\n\n\n\n    if (!sw) {\n\n        /* XXX: Consider options */\n\n        return size;\n\n    }\n\n\n\n    if (!sw->hw->enabled) {\n\n        dolog (\"Reading from disabled voice %s\\n\", SW_NAME (sw));\n\n        return 0;\n\n    }\n\n\n\n    bytes = sw->hw->pcm_ops->read (sw, buf, size);\n\n    return bytes;\n\n}\n", "idx": 25968}
{"project": "qemu", "commit_id": "7bd427d801e1e3293a634d3c83beadaa90ffb911", "target": 0, "func": "QEMUFile *qemu_fopen_ops_buffered(void *opaque,\n\n                                  size_t bytes_per_sec,\n\n                                  BufferedPutFunc *put_buffer,\n\n                                  BufferedPutReadyFunc *put_ready,\n\n                                  BufferedWaitForUnfreezeFunc *wait_for_unfreeze,\n\n                                  BufferedCloseFunc *close)\n\n{\n\n    QEMUFileBuffered *s;\n\n\n\n    s = qemu_mallocz(sizeof(*s));\n\n\n\n    s->opaque = opaque;\n\n    s->xfer_limit = bytes_per_sec / 10;\n\n    s->put_buffer = put_buffer;\n\n    s->put_ready = put_ready;\n\n    s->wait_for_unfreeze = wait_for_unfreeze;\n\n    s->close = close;\n\n\n\n    s->file = qemu_fopen_ops(s, buffered_put_buffer, NULL,\n\n                             buffered_close, buffered_rate_limit,\n\n                             buffered_set_rate_limit,\n\n\t\t\t     buffered_get_rate_limit);\n\n\n\n    s->timer = qemu_new_timer(rt_clock, buffered_rate_tick, s);\n\n\n\n    qemu_mod_timer(s->timer, qemu_get_clock(rt_clock) + 100);\n\n\n\n    return s->file;\n\n}\n", "idx": 25969}
{"project": "qemu", "commit_id": "8297be80f7cf71e09617669a8bd8b2836dcfd4c3", "target": 0, "func": "int keysym2scancode(void *kbd_layout, int keysym)\n\n{\n\n    kbd_layout_t *k = kbd_layout;\n\n    if (keysym < MAX_NORMAL_KEYCODE) {\n\n        if (k->keysym2keycode[keysym] == 0) {\n\n            trace_keymap_unmapped(keysym);\n\n            fprintf(stderr, \"Warning: no scancode found for keysym %d\\n\",\n\n                    keysym);\n\n        }\n\n        return k->keysym2keycode[keysym];\n\n    } else {\n\n        int i;\n\n#ifdef XK_ISO_Left_Tab\n\n        if (keysym == XK_ISO_Left_Tab) {\n\n            keysym = XK_Tab;\n\n        }\n\n#endif\n\n        for (i = 0; i < k->extra_count; i++) {\n\n            if (k->keysym2keycode_extra[i].keysym == keysym) {\n\n                return k->keysym2keycode_extra[i].keycode;\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 25970}
{"project": "qemu", "commit_id": "cd42d5b23691ad73edfd6dbcfc935a960a9c5a65", "target": 0, "func": "gen_intermediate_code_internal(M68kCPU *cpu, TranslationBlock *tb,\n\n                               bool search_pc)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUM68KState *env = &cpu->env;\n\n    DisasContext dc1, *dc = &dc1;\n\n    uint16_t *gen_opc_end;\n\n    CPUBreakpoint *bp;\n\n    int j, lj;\n\n    target_ulong pc_start;\n\n    int pc_offset;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    /* generate intermediate code */\n\n    pc_start = tb->pc;\n\n\n\n    dc->tb = tb;\n\n\n\n    gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE;\n\n\n\n    dc->env = env;\n\n    dc->is_jmp = DISAS_NEXT;\n\n    dc->pc = pc_start;\n\n    dc->cc_op = CC_OP_DYNAMIC;\n\n    dc->singlestep_enabled = cs->singlestep_enabled;\n\n    dc->fpcr = env->fpcr;\n\n    dc->user = (env->sr & SR_S) == 0;\n\n    dc->is_mem = 0;\n\n    dc->done_mac = 0;\n\n    lj = -1;\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0)\n\n        max_insns = CF_COUNT_MASK;\n\n\n\n    gen_tb_start();\n\n    do {\n\n        pc_offset = dc->pc - pc_start;\n\n        gen_throws_exception = NULL;\n\n        if (unlikely(!QTAILQ_EMPTY(&cs->breakpoints))) {\n\n            QTAILQ_FOREACH(bp, &cs->breakpoints, entry) {\n\n                if (bp->pc == dc->pc) {\n\n                    gen_exception(dc, dc->pc, EXCP_DEBUG);\n\n                    dc->is_jmp = DISAS_JUMP;\n\n                    break;\n\n                }\n\n            }\n\n            if (dc->is_jmp)\n\n                break;\n\n        }\n\n        if (search_pc) {\n\n            j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    tcg_ctx.gen_opc_instr_start[lj++] = 0;\n\n            }\n\n            tcg_ctx.gen_opc_pc[lj] = dc->pc;\n\n            tcg_ctx.gen_opc_instr_start[lj] = 1;\n\n            tcg_ctx.gen_opc_icount[lj] = num_insns;\n\n        }\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))\n\n            gen_io_start();\n\n        dc->insn_pc = dc->pc;\n\n\tdisas_m68k_insn(env, dc);\n\n        num_insns++;\n\n    } while (!dc->is_jmp && tcg_ctx.gen_opc_ptr < gen_opc_end &&\n\n             !cs->singlestep_enabled &&\n\n             !singlestep &&\n\n             (pc_offset) < (TARGET_PAGE_SIZE - 32) &&\n\n             num_insns < max_insns);\n\n\n\n    if (tb->cflags & CF_LAST_IO)\n\n        gen_io_end();\n\n    if (unlikely(cs->singlestep_enabled)) {\n\n        /* Make sure the pc is updated, and raise a debug exception.  */\n\n        if (!dc->is_jmp) {\n\n            gen_flush_cc_op(dc);\n\n            tcg_gen_movi_i32(QREG_PC, dc->pc);\n\n        }\n\n        gen_helper_raise_exception(cpu_env, tcg_const_i32(EXCP_DEBUG));\n\n    } else {\n\n        switch(dc->is_jmp) {\n\n        case DISAS_NEXT:\n\n            gen_flush_cc_op(dc);\n\n            gen_jmp_tb(dc, 0, dc->pc);\n\n            break;\n\n        default:\n\n        case DISAS_JUMP:\n\n        case DISAS_UPDATE:\n\n            gen_flush_cc_op(dc);\n\n            /* indicate that the hash table must be used to find the next TB */\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        case DISAS_TB_JUMP:\n\n            /* nothing more to generate */\n\n            break;\n\n        }\n\n    }\n\n    gen_tb_end(tb, num_insns);\n\n    *tcg_ctx.gen_opc_ptr = INDEX_op_end;\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"----------------\\n\");\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n        log_target_disas(env, pc_start, dc->pc - pc_start, 0);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n    if (search_pc) {\n\n        j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            tcg_ctx.gen_opc_instr_start[lj++] = 0;\n\n    } else {\n\n        tb->size = dc->pc - pc_start;\n\n        tb->icount = num_insns;\n\n    }\n\n\n\n    //optimize_flags();\n\n    //expand_target_qops();\n\n}\n", "idx": 25971}
{"project": "qemu", "commit_id": "a3251186fc6a04d421e9c4b65aa04ec32379ec38", "target": 0, "func": "static CCPrepare gen_prepare_eflags_c(DisasContext *s, TCGv reg)\n\n{\n\n    TCGv t0, t1;\n\n    int size, shift;\n\n\n\n    switch (s->cc_op) {\n\n    case CC_OP_SUBB ... CC_OP_SUBQ:\n\n        /* (DATA_TYPE)(CC_DST + CC_SRC) < (DATA_TYPE)CC_SRC */\n\n        size = s->cc_op - CC_OP_SUBB;\n\n        t1 = gen_ext_tl(cpu_tmp0, cpu_cc_src, size, false);\n\n        /* If no temporary was used, be careful not to alias t1 and t0.  */\n\n        t0 = TCGV_EQUAL(t1, cpu_cc_src) ? cpu_tmp0 : reg;\n\n        tcg_gen_add_tl(t0, cpu_cc_dst, cpu_cc_src);\n\n        gen_extu(size, t0);\n\n        goto add_sub;\n\n\n\n    case CC_OP_ADDB ... CC_OP_ADDQ:\n\n        /* (DATA_TYPE)CC_DST < (DATA_TYPE)CC_SRC */\n\n        size = s->cc_op - CC_OP_ADDB;\n\n        t1 = gen_ext_tl(cpu_tmp0, cpu_cc_src, size, false);\n\n        t0 = gen_ext_tl(reg, cpu_cc_dst, size, false);\n\n    add_sub:\n\n        return (CCPrepare) { .cond = TCG_COND_LTU, .reg = t0,\n\n                             .reg2 = t1, .mask = -1, .use_reg2 = true };\n\n\n\n    case CC_OP_SBBB ... CC_OP_SBBQ:\n\n        /* (DATA_TYPE)(CC_DST + CC_SRC + 1) <= (DATA_TYPE)CC_SRC */\n\n        size = s->cc_op - CC_OP_SBBB;\n\n        t1 = gen_ext_tl(cpu_tmp0, cpu_cc_src, size, false);\n\n        if (TCGV_EQUAL(t1, reg) && TCGV_EQUAL(reg, cpu_cc_src)) {\n\n            tcg_gen_mov_tl(cpu_tmp0, cpu_cc_src);\n\n            t1 = cpu_tmp0;\n\n        }\n\n\n\n        tcg_gen_add_tl(reg, cpu_cc_dst, cpu_cc_src);\n\n        tcg_gen_addi_tl(reg, reg, 1);\n\n        gen_extu(size, reg);\n\n        t0 = reg;\n\n        goto adc_sbb;\n\n\n\n    case CC_OP_ADCB ... CC_OP_ADCQ:\n\n        /* (DATA_TYPE)CC_DST <= (DATA_TYPE)CC_SRC */\n\n        size = s->cc_op - CC_OP_ADCB;\n\n        t1 = gen_ext_tl(cpu_tmp0, cpu_cc_src, size, false);\n\n        t0 = gen_ext_tl(reg, cpu_cc_dst, size, false);\n\n    adc_sbb:\n\n        return (CCPrepare) { .cond = TCG_COND_LEU, .reg = t0,\n\n                             .reg2 = t1, .mask = -1, .use_reg2 = true };\n\n\n\n    case CC_OP_LOGICB ... CC_OP_LOGICQ:\n\n        return (CCPrepare) { .cond = TCG_COND_NEVER, .mask = -1 };\n\n\n\n    case CC_OP_INCB ... CC_OP_INCQ:\n\n    case CC_OP_DECB ... CC_OP_DECQ:\n\n        return (CCPrepare) { .cond = TCG_COND_NE, .reg = cpu_cc_src,\n\n                             .mask = -1, .no_setcond = true };\n\n\n\n    case CC_OP_SHLB ... CC_OP_SHLQ:\n\n        /* (CC_SRC >> (DATA_BITS - 1)) & 1 */\n\n        size = s->cc_op - CC_OP_SHLB;\n\n        shift = (8 << size) - 1;\n\n        return (CCPrepare) { .cond = TCG_COND_NE, .reg = cpu_cc_src,\n\n                             .mask = (target_ulong)1 << shift };\n\n\n\n    case CC_OP_MULB ... CC_OP_MULQ:\n\n        return (CCPrepare) { .cond = TCG_COND_NE,\n\n                             .reg = cpu_cc_src, .mask = -1 };\n\n\n\n    case CC_OP_EFLAGS:\n\n    case CC_OP_SARB ... CC_OP_SARQ:\n\n        /* CC_SRC & 1 */\n\n        return (CCPrepare) { .cond = TCG_COND_NE,\n\n                             .reg = cpu_cc_src, .mask = CC_C };\n\n\n\n    default:\n\n       /* The need to compute only C from CC_OP_DYNAMIC is important\n\n          in efficiently implementing e.g. INC at the start of a TB.  */\n\n       gen_update_cc_op(s);\n\n       gen_helper_cc_compute_c(cpu_tmp2_i32, cpu_env, cpu_cc_op);\n\n       tcg_gen_extu_i32_tl(reg, cpu_tmp2_i32);\n\n       return (CCPrepare) { .cond = TCG_COND_NE, .reg = reg,\n\n                            .mask = -1, .no_setcond = true };\n\n    }\n\n}\n", "idx": 25972}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void pflash_cfi01_realize(DeviceState *dev, Error **errp)\n\n{\n\n    pflash_t *pfl = CFI_PFLASH01(dev);\n\n    uint64_t total_len;\n\n    int ret;\n\n    uint64_t blocks_per_device, device_len;\n\n    int num_devices;\n\n    Error *local_err = NULL;\n\n\n\n    total_len = pfl->sector_len * pfl->nb_blocs;\n\n\n\n    /* These are only used to expose the parameters of each device\n\n     * in the cfi_table[].\n\n     */\n\n    num_devices = pfl->device_width ? (pfl->bank_width / pfl->device_width) : 1;\n\n    blocks_per_device = pfl->nb_blocs / num_devices;\n\n    device_len = pfl->sector_len * blocks_per_device;\n\n\n\n    /* XXX: to be fixed */\n\n#if 0\n\n    if (total_len != (8 * 1024 * 1024) && total_len != (16 * 1024 * 1024) &&\n\n        total_len != (32 * 1024 * 1024) && total_len != (64 * 1024 * 1024))\n\n        return NULL;\n\n#endif\n\n\n\n    memory_region_init_rom_device(\n\n        &pfl->mem, OBJECT(dev),\n\n        pfl->be ? &pflash_cfi01_ops_be : &pflash_cfi01_ops_le, pfl,\n\n        pfl->name, total_len, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    vmstate_register_ram(&pfl->mem, DEVICE(pfl));\n\n    pfl->storage = memory_region_get_ram_ptr(&pfl->mem);\n\n    sysbus_init_mmio(SYS_BUS_DEVICE(dev), &pfl->mem);\n\n\n\n    if (pfl->bs) {\n\n        /* read the initial flash content */\n\n        ret = bdrv_read(pfl->bs, 0, pfl->storage, total_len >> 9);\n\n\n\n        if (ret < 0) {\n\n            vmstate_unregister_ram(&pfl->mem, DEVICE(pfl));\n\n            error_setg(errp, \"failed to read the initial flash content\");\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (pfl->bs) {\n\n        pfl->ro = bdrv_is_read_only(pfl->bs);\n\n    } else {\n\n        pfl->ro = 0;\n\n    }\n\n\n\n    /* Default to devices being used at their maximum device width. This was\n\n     * assumed before the device_width support was added.\n\n     */\n\n    if (!pfl->max_device_width) {\n\n        pfl->max_device_width = pfl->device_width;\n\n    }\n\n\n\n    pfl->timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, pflash_timer, pfl);\n\n    pfl->wcycle = 0;\n\n    pfl->cmd = 0;\n\n    pfl->status = 0;\n\n    /* Hardcoded CFI table */\n\n    pfl->cfi_len = 0x52;\n\n    /* Standard \"QRY\" string */\n\n    pfl->cfi_table[0x10] = 'Q';\n\n    pfl->cfi_table[0x11] = 'R';\n\n    pfl->cfi_table[0x12] = 'Y';\n\n    /* Command set (Intel) */\n\n    pfl->cfi_table[0x13] = 0x01;\n\n    pfl->cfi_table[0x14] = 0x00;\n\n    /* Primary extended table address (none) */\n\n    pfl->cfi_table[0x15] = 0x31;\n\n    pfl->cfi_table[0x16] = 0x00;\n\n    /* Alternate command set (none) */\n\n    pfl->cfi_table[0x17] = 0x00;\n\n    pfl->cfi_table[0x18] = 0x00;\n\n    /* Alternate extended table (none) */\n\n    pfl->cfi_table[0x19] = 0x00;\n\n    pfl->cfi_table[0x1A] = 0x00;\n\n    /* Vcc min */\n\n    pfl->cfi_table[0x1B] = 0x45;\n\n    /* Vcc max */\n\n    pfl->cfi_table[0x1C] = 0x55;\n\n    /* Vpp min (no Vpp pin) */\n\n    pfl->cfi_table[0x1D] = 0x00;\n\n    /* Vpp max (no Vpp pin) */\n\n    pfl->cfi_table[0x1E] = 0x00;\n\n    /* Reserved */\n\n    pfl->cfi_table[0x1F] = 0x07;\n\n    /* Timeout for min size buffer write */\n\n    pfl->cfi_table[0x20] = 0x07;\n\n    /* Typical timeout for block erase */\n\n    pfl->cfi_table[0x21] = 0x0a;\n\n    /* Typical timeout for full chip erase (4096 ms) */\n\n    pfl->cfi_table[0x22] = 0x00;\n\n    /* Reserved */\n\n    pfl->cfi_table[0x23] = 0x04;\n\n    /* Max timeout for buffer write */\n\n    pfl->cfi_table[0x24] = 0x04;\n\n    /* Max timeout for block erase */\n\n    pfl->cfi_table[0x25] = 0x04;\n\n    /* Max timeout for chip erase */\n\n    pfl->cfi_table[0x26] = 0x00;\n\n    /* Device size */\n\n    pfl->cfi_table[0x27] = ctz32(device_len); /* + 1; */\n\n    /* Flash device interface (8 & 16 bits) */\n\n    pfl->cfi_table[0x28] = 0x02;\n\n    pfl->cfi_table[0x29] = 0x00;\n\n    /* Max number of bytes in multi-bytes write */\n\n    if (pfl->bank_width == 1) {\n\n        pfl->cfi_table[0x2A] = 0x08;\n\n    } else {\n\n        pfl->cfi_table[0x2A] = 0x0B;\n\n    }\n\n    pfl->writeblock_size = 1 << pfl->cfi_table[0x2A];\n\n\n\n    pfl->cfi_table[0x2B] = 0x00;\n\n    /* Number of erase block regions (uniform) */\n\n    pfl->cfi_table[0x2C] = 0x01;\n\n    /* Erase block region 1 */\n\n    pfl->cfi_table[0x2D] = blocks_per_device - 1;\n\n    pfl->cfi_table[0x2E] = (blocks_per_device - 1) >> 8;\n\n    pfl->cfi_table[0x2F] = pfl->sector_len >> 8;\n\n    pfl->cfi_table[0x30] = pfl->sector_len >> 16;\n\n\n\n    /* Extended */\n\n    pfl->cfi_table[0x31] = 'P';\n\n    pfl->cfi_table[0x32] = 'R';\n\n    pfl->cfi_table[0x33] = 'I';\n\n\n\n    pfl->cfi_table[0x34] = '1';\n\n    pfl->cfi_table[0x35] = '0';\n\n\n\n    pfl->cfi_table[0x36] = 0x00;\n\n    pfl->cfi_table[0x37] = 0x00;\n\n    pfl->cfi_table[0x38] = 0x00;\n\n    pfl->cfi_table[0x39] = 0x00;\n\n\n\n    pfl->cfi_table[0x3a] = 0x00;\n\n\n\n    pfl->cfi_table[0x3b] = 0x00;\n\n    pfl->cfi_table[0x3c] = 0x00;\n\n\n\n    pfl->cfi_table[0x3f] = 0x01; /* Number of protection fields */\n\n}\n", "idx": 25973}
{"project": "qemu", "commit_id": "f0267ef7115656119bf00ed77857789adc036bda", "target": 0, "func": "static long do_rt_sigreturn_v2(CPUARMState *env)\n\n{\n\n    abi_ulong frame_addr;\n\n    struct rt_sigframe_v2 *frame = NULL;\n\n\n\n    /*\n\n     * Since we stacked the signal on a 64-bit boundary,\n\n     * then 'sp' should be word aligned here.  If it's\n\n     * not, then the user is trying to mess with us.\n\n     */\n\n    frame_addr = env->regs[13];\n\n    trace_user_do_rt_sigreturn(env, frame_addr);\n\n    if (frame_addr & 7) {\n\n        goto badframe;\n\n    }\n\n\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1)) {\n\n        goto badframe;\n\n    }\n\n\n\n    if (do_sigframe_return_v2(env, frame_addr, &frame->uc)) {\n\n        goto badframe;\n\n    }\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return env->regs[0];\n\n\n\nbadframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV /* , current */);\n\n    return 0;\n\n}\n", "idx": 25974}
{"project": "qemu", "commit_id": "4c8d0d27676778febad3802a95218d5ceaca171e", "target": 0, "func": "void qemu_fd_register(int fd)\n\n{\n\n    WSAEventSelect(fd, qemu_event_handle, FD_READ | FD_ACCEPT | FD_CLOSE |\n\n                   FD_CONNECT | FD_WRITE | FD_OOB);\n\n}\n", "idx": 25975}
{"project": "qemu", "commit_id": "2da9b7d456278bccc6ce889ae350f2867155d7e8", "target": 0, "func": "void bdrv_drain_all_begin(void)\n\n{\n\n    /* Always run first iteration so any pending completion BHs run */\n\n    bool waited = true;\n\n    BlockDriverState *bs;\n\n    BdrvNextIterator it;\n\n    GSList *aio_ctxs = NULL, *ctx;\n\n\n\n    block_job_pause_all();\n\n\n\n    for (bs = bdrv_first(&it); bs; bs = bdrv_next(&it)) {\n\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n\n\n        aio_context_acquire(aio_context);\n\n        bdrv_parent_drained_begin(bs);\n\n        aio_disable_external(aio_context);\n\n        aio_context_release(aio_context);\n\n\n\n        if (!g_slist_find(aio_ctxs, aio_context)) {\n\n            aio_ctxs = g_slist_prepend(aio_ctxs, aio_context);\n\n        }\n\n    }\n\n\n\n    /* Note that completion of an asynchronous I/O operation can trigger any\n\n     * number of other I/O operations on other devices---for example a\n\n     * coroutine can submit an I/O request to another device in response to\n\n     * request completion.  Therefore we must keep looping until there was no\n\n     * more activity rather than simply draining each device independently.\n\n     */\n\n    while (waited) {\n\n        waited = false;\n\n\n\n        for (ctx = aio_ctxs; ctx != NULL; ctx = ctx->next) {\n\n            AioContext *aio_context = ctx->data;\n\n\n\n            aio_context_acquire(aio_context);\n\n            for (bs = bdrv_first(&it); bs; bs = bdrv_next(&it)) {\n\n                if (aio_context == bdrv_get_aio_context(bs)) {\n\n                    /* FIXME Calling this multiple times is wrong */\n\n                    bdrv_drain_invoke(bs, true);\n\n                    waited |= bdrv_drain_recurse(bs, true);\n\n                }\n\n            }\n\n            aio_context_release(aio_context);\n\n        }\n\n    }\n\n\n\n    g_slist_free(aio_ctxs);\n\n}\n", "idx": 25976}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static size_t qemu_rdma_save_page(QEMUFile *f, void *opaque,\n\n                                  ram_addr_t block_offset, ram_addr_t offset,\n\n                                  size_t size, int *bytes_sent)\n\n{\n\n    QEMUFileRDMA *rfile = opaque;\n\n    RDMAContext *rdma = rfile->rdma;\n\n    int ret;\n\n\n\n    CHECK_ERROR_STATE();\n\n\n\n    qemu_fflush(f);\n\n\n\n    if (size > 0) {\n\n        /*\n\n         * Add this page to the current 'chunk'. If the chunk\n\n         * is full, or the page doen't belong to the current chunk,\n\n         * an actual RDMA write will occur and a new chunk will be formed.\n\n         */\n\n        ret = qemu_rdma_write(f, rdma, block_offset, offset, size);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"rdma migration: write error! %d\\n\", ret);\n\n            goto err;\n\n        }\n\n\n\n        /*\n\n         * We always return 1 bytes because the RDMA\n\n         * protocol is completely asynchronous. We do not yet know\n\n         * whether an  identified chunk is zero or not because we're\n\n         * waiting for other pages to potentially be merged with\n\n         * the current chunk. So, we have to call qemu_update_position()\n\n         * later on when the actual write occurs.\n\n         */\n\n        if (bytes_sent) {\n\n            *bytes_sent = 1;\n\n        }\n\n    } else {\n\n        uint64_t index, chunk;\n\n\n\n        /* TODO: Change QEMUFileOps prototype to be signed: size_t => long\n\n        if (size < 0) {\n\n            ret = qemu_rdma_drain_cq(f, rdma);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"rdma: failed to synchronously drain\"\n\n                                \" completion queue before unregistration.\\n\");\n\n                goto err;\n\n            }\n\n        }\n\n        */\n\n\n\n        ret = qemu_rdma_search_ram_block(rdma, block_offset,\n\n                                         offset, size, &index, &chunk);\n\n\n\n        if (ret) {\n\n            fprintf(stderr, \"ram block search failed\\n\");\n\n            goto err;\n\n        }\n\n\n\n        qemu_rdma_signal_unregister(rdma, index, chunk, 0);\n\n\n\n        /*\n\n         * TODO: Synchronous, guaranteed unregistration (should not occur during\n\n         * fast-path). Otherwise, unregisters will process on the next call to\n\n         * qemu_rdma_drain_cq()\n\n        if (size < 0) {\n\n            qemu_rdma_unregister_waiting(rdma);\n\n        }\n\n        */\n\n    }\n\n\n\n    /*\n\n     * Drain the Completion Queue if possible, but do not block,\n\n     * just poll.\n\n     *\n\n     * If nothing to poll, the end of the iteration will do this\n\n     * again to make sure we don't overflow the request queue.\n\n     */\n\n    while (1) {\n\n        uint64_t wr_id, wr_id_in;\n\n        int ret = qemu_rdma_poll(rdma, &wr_id_in, NULL);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"rdma migration: polling error! %d\\n\", ret);\n\n            goto err;\n\n        }\n\n\n\n        wr_id = wr_id_in & RDMA_WRID_TYPE_MASK;\n\n\n\n        if (wr_id == RDMA_WRID_NONE) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    return RAM_SAVE_CONTROL_DELAYED;\n\nerr:\n\n    rdma->error_state = ret;\n\n    return ret;\n\n}\n", "idx": 25977}
{"project": "qemu", "commit_id": "6b5166f8a82888638bb9aba9dc49aa7fa25f292f", "target": 1, "func": "int xen_be_init(void)\n\n{\n\n    xenstore = xs_daemon_open();\n\n    if (!xenstore) {\n\n        xen_be_printf(NULL, 0, \"can't connect to xenstored\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (qemu_set_fd_handler(xs_fileno(xenstore), xenstore_update, NULL, NULL) < 0) {\n\n        goto err;\n\n    }\n\n\n\n    if (xen_xc == XC_HANDLER_INITIAL_VALUE) {\n\n        /* Check if xen_init() have been called */\n\n        goto err;\n\n    }\n\n    return 0;\n\n\n\nerr:\n\n    qemu_set_fd_handler(xs_fileno(xenstore), NULL, NULL, NULL);\n\n    xs_daemon_close(xenstore);\n\n    xenstore = NULL;\n\n\n\n    return -1;\n\n}\n", "idx": 25978}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "static struct pxa2xx_i2s_s *pxa2xx_i2s_init(target_phys_addr_t base,\n\n                qemu_irq irq, struct pxa2xx_dma_state_s *dma)\n\n{\n\n    int iomemtype;\n\n    struct pxa2xx_i2s_s *s = (struct pxa2xx_i2s_s *)\n\n            qemu_mallocz(sizeof(struct pxa2xx_i2s_s));\n\n\n\n    s->base = base;\n\n    s->irq = irq;\n\n    s->dma = dma;\n\n    s->data_req = pxa2xx_i2s_data_req;\n\n\n\n    pxa2xx_i2s_reset(s);\n\n\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_i2s_readfn,\n\n                    pxa2xx_i2s_writefn, s);\n\n    cpu_register_physical_memory(s->base & 0xfff00000, 0xfffff, iomemtype);\n\n\n\n    register_savevm(\"pxa2xx_i2s\", base, 0,\n\n                    pxa2xx_i2s_save, pxa2xx_i2s_load, s);\n\n\n\n    return s;\n\n}\n", "idx": 25980}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void perf_nesting(void)\n\n{\n\n    unsigned int i, maxcycles, maxnesting;\n\n    double duration;\n\n\n\n    maxcycles = 10000;\n\n    maxnesting = 1000;\n\n    Coroutine *root;\n\n\n\n    g_test_timer_start();\n\n    for (i = 0; i < maxcycles; i++) {\n\n        NestData nd = {\n\n            .n_enter  = 0,\n\n            .n_return = 0,\n\n            .max      = maxnesting,\n\n        };\n\n        root = qemu_coroutine_create(nest);\n\n        qemu_coroutine_enter(root, &nd);\n\n    }\n\n    duration = g_test_timer_elapsed();\n\n\n\n    g_test_message(\"Nesting %u iterations of %u depth each: %f s\\n\",\n\n        maxcycles, maxnesting, duration);\n\n}\n", "idx": 25982}
{"project": "qemu", "commit_id": "ff71a4545c0d9b452e77a91ab1c46f79a10a9eca", "target": 1, "func": "static abi_long do_socketcall(int num, abi_ulong vptr)\n\n{\n\n    static const unsigned ac[] = { /* number of arguments per call */\n\n        [SOCKOP_socket] = 3,      /* domain, type, protocol */\n\n        [SOCKOP_bind] = 3,        /* sockfd, addr, addrlen */\n\n        [SOCKOP_connect] = 3,     /* sockfd, addr, addrlen */\n\n        [SOCKOP_listen] = 2,      /* sockfd, backlog */\n\n        [SOCKOP_accept] = 3,      /* sockfd, addr, addrlen */\n\n        [SOCKOP_accept4] = 4,     /* sockfd, addr, addrlen, flags */\n\n        [SOCKOP_getsockname] = 3, /* sockfd, addr, addrlen */\n\n        [SOCKOP_getpeername] = 3, /* sockfd, addr, addrlen */\n\n        [SOCKOP_socketpair] = 4,  /* domain, type, protocol, tab */\n\n        [SOCKOP_send] = 4,        /* sockfd, msg, len, flags */\n\n        [SOCKOP_recv] = 4,        /* sockfd, msg, len, flags */\n\n        [SOCKOP_sendto] = 6,      /* sockfd, msg, len, flags, addr, addrlen */\n\n        [SOCKOP_recvfrom] = 6,    /* sockfd, msg, len, flags, addr, addrlen */\n\n        [SOCKOP_shutdown] = 2,    /* sockfd, how */\n\n        [SOCKOP_sendmsg] = 3,     /* sockfd, msg, flags */\n\n        [SOCKOP_recvmsg] = 3,     /* sockfd, msg, flags */\n\n        [SOCKOP_sendmmsg] = 4,    /* sockfd, msgvec, vlen, flags */\n\n        [SOCKOP_recvmmsg] = 4,    /* sockfd, msgvec, vlen, flags */\n\n        [SOCKOP_setsockopt] = 5,  /* sockfd, level, optname, optval, optlen */\n\n        [SOCKOP_getsockopt] = 5,  /* sockfd, level, optname, optval, optlen */\n\n    };\n\n    abi_long a[6]; /* max 6 args */\n\n\n\n    /* first, collect the arguments in a[] according to ac[] */\n\n    if (num >= 0 && num < ARRAY_SIZE(ac)) {\n\n        unsigned i;\n\n        assert(ARRAY_SIZE(a) >= ac[num]); /* ensure we have space for args */\n\n        for (i = 0; i < ac[num]; ++i) {\n\n            if (get_user_ual(a[i], vptr + i * sizeof(abi_long)) != 0) {\n\n                return -TARGET_EFAULT;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* now when we have the args, actually handle the call */\n\n    switch (num) {\n\n    case SOCKOP_socket: /* domain, type, protocol */\n\n        return do_socket(a[0], a[1], a[2]);\n\n    case SOCKOP_bind: /* sockfd, addr, addrlen */\n\n        return do_bind(a[0], a[1], a[2]);\n\n    case SOCKOP_connect: /* sockfd, addr, addrlen */\n\n        return do_connect(a[0], a[1], a[2]);\n\n    case SOCKOP_listen: /* sockfd, backlog */\n\n        return get_errno(listen(a[0], a[1]));\n\n    case SOCKOP_accept: /* sockfd, addr, addrlen */\n\n        return do_accept4(a[0], a[1], a[2], 0);\n\n    case SOCKOP_accept4: /* sockfd, addr, addrlen, flags */\n\n        return do_accept4(a[0], a[1], a[2], a[3]);\n\n    case SOCKOP_getsockname: /* sockfd, addr, addrlen */\n\n        return do_getsockname(a[0], a[1], a[2]);\n\n    case SOCKOP_getpeername: /* sockfd, addr, addrlen */\n\n        return do_getpeername(a[0], a[1], a[2]);\n\n    case SOCKOP_socketpair: /* domain, type, protocol, tab */\n\n        return do_socketpair(a[0], a[1], a[2], a[3]);\n\n    case SOCKOP_send: /* sockfd, msg, len, flags */\n\n        return do_sendto(a[0], a[1], a[2], a[3], 0, 0);\n\n    case SOCKOP_recv: /* sockfd, msg, len, flags */\n\n        return do_recvfrom(a[0], a[1], a[2], a[3], 0, 0);\n\n    case SOCKOP_sendto: /* sockfd, msg, len, flags, addr, addrlen */\n\n        return do_sendto(a[0], a[1], a[2], a[3], a[4], a[5]);\n\n    case SOCKOP_recvfrom: /* sockfd, msg, len, flags, addr, addrlen */\n\n        return do_recvfrom(a[0], a[1], a[2], a[3], a[4], a[5]);\n\n    case SOCKOP_shutdown: /* sockfd, how */\n\n        return get_errno(shutdown(a[0], a[1]));\n\n    case SOCKOP_sendmsg: /* sockfd, msg, flags */\n\n        return do_sendrecvmsg(a[0], a[1], a[2], 1);\n\n    case SOCKOP_recvmsg: /* sockfd, msg, flags */\n\n        return do_sendrecvmsg(a[0], a[1], a[2], 0);\n\n    case SOCKOP_sendmmsg: /* sockfd, msgvec, vlen, flags */\n\n        return do_sendrecvmmsg(a[0], a[1], a[2], a[3], 1);\n\n    case SOCKOP_recvmmsg: /* sockfd, msgvec, vlen, flags */\n\n        return do_sendrecvmmsg(a[0], a[1], a[2], a[3], 0);\n\n    case SOCKOP_setsockopt: /* sockfd, level, optname, optval, optlen */\n\n        return do_setsockopt(a[0], a[1], a[2], a[3], a[4]);\n\n    case SOCKOP_getsockopt: /* sockfd, level, optname, optval, optlen */\n\n        return do_getsockopt(a[0], a[1], a[2], a[3], a[4]);\n\n    default:\n\n        gemu_log(\"Unsupported socketcall: %d\\n\", num);\n\n        return -TARGET_ENOSYS;\n\n    }\n\n}\n", "idx": 25984}
{"project": "qemu", "commit_id": "6da67de6803e93cbb7e93ac3497865832f8c00ea", "target": 1, "func": "static MemTxResult address_space_write_continue(AddressSpace *as, hwaddr addr,\n\n                                                MemTxAttrs attrs,\n\n                                                const uint8_t *buf,\n\n                                                int len, hwaddr addr1,\n\n                                                hwaddr l, MemoryRegion *mr)\n\n{\n\n    uint8_t *ptr;\n\n    uint64_t val;\n\n    MemTxResult result = MEMTX_OK;\n\n    bool release_lock = false;\n\n\n\n    for (;;) {\n\n        if (!memory_access_is_direct(mr, true)) {\n\n            release_lock |= prepare_mmio_access(mr);\n\n            l = memory_access_size(mr, l, addr1);\n\n            /* XXX: could force current_cpu to NULL to avoid\n\n               potential bugs */\n\n            switch (l) {\n\n            case 8:\n\n                /* 64 bit write access */\n\n                val = ldq_p(buf);\n\n                result |= memory_region_dispatch_write(mr, addr1, val, 8,\n\n                                                       attrs);\n\n                break;\n\n            case 4:\n\n                /* 32 bit write access */\n\n                val = ldl_p(buf);\n\n                result |= memory_region_dispatch_write(mr, addr1, val, 4,\n\n                                                       attrs);\n\n                break;\n\n            case 2:\n\n                /* 16 bit write access */\n\n                val = lduw_p(buf);\n\n                result |= memory_region_dispatch_write(mr, addr1, val, 2,\n\n                                                       attrs);\n\n                break;\n\n            case 1:\n\n                /* 8 bit write access */\n\n                val = ldub_p(buf);\n\n                result |= memory_region_dispatch_write(mr, addr1, val, 1,\n\n                                                       attrs);\n\n                break;\n\n            default:\n\n                abort();\n\n            }\n\n        } else {\n\n            /* RAM case */\n\n            ptr = qemu_map_ram_ptr(mr->ram_block, addr1);\n\n            memcpy(ptr, buf, l);\n\n            invalidate_and_set_dirty(mr, addr1, l);\n\n        }\n\n\n\n        if (release_lock) {\n\n            qemu_mutex_unlock_iothread();\n\n            release_lock = false;\n\n        }\n\n\n\n        len -= l;\n\n        buf += l;\n\n        addr += l;\n\n\n\n        if (!len) {\n\n            break;\n\n        }\n\n\n\n        l = len;\n\n        mr = address_space_translate(as, addr, &addr1, &l, true);\n\n    }\n\n\n\n    return result;\n\n}\n", "idx": 25985}
{"project": "qemu", "commit_id": "27bb0b2d6f80f058bdb6fcc8fcdfa69b0c8a6d71", "target": 1, "func": "void hpet_init(qemu_irq *irq) {\n\n    int i, iomemtype;\n\n    HPETState *s;\n\n\n\n    DPRINTF (\"hpet_init\\n\");\n\n\n\n    s = qemu_mallocz(sizeof(HPETState));\n\n    hpet_statep = s;\n\n    s->irqs = irq;\n\n    for (i=0; i<HPET_NUM_TIMERS; i++) {\n\n        HPETTimer *timer = &s->timer[i];\n\n        timer->qemu_timer = qemu_new_timer(vm_clock, hpet_timer, timer);\n\n    }\n\n    vmstate_register(-1, &vmstate_hpet, s);\n\n    qemu_register_reset(hpet_reset, s);\n\n    /* HPET Area */\n\n    iomemtype = cpu_register_io_memory(hpet_ram_read,\n\n                                       hpet_ram_write, s);\n\n    cpu_register_physical_memory(HPET_BASE, 0x400, iomemtype);\n\n}\n", "idx": 25986}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_type_int64(Visitor *v, int64_t *obj, const char *name, Error **errp)\n\n{\n\n    if (!error_is_set(errp)) {\n\n        if (v->type_int64) {\n\n            v->type_int64(v, obj, name, errp);\n\n        } else {\n\n            v->type_int(v, obj, name, errp);\n\n        }\n\n    }\n\n}\n", "idx": 25987}
{"project": "qemu", "commit_id": "e8a095dadb70e2ea6d5169d261920db3747bfa45", "target": 1, "func": "void bdrv_detach_aio_context(BlockDriverState *bs)\n\n{\n\n    BdrvAioNotifier *baf;\n\n    BdrvChild *child;\n\n\n\n    if (!bs->drv) {\n\n        return;\n\n    }\n\n\n\n    QLIST_FOREACH(baf, &bs->aio_notifiers, list) {\n\n        baf->detach_aio_context(baf->opaque);\n\n    }\n\n\n\n    if (bs->drv->bdrv_detach_aio_context) {\n\n        bs->drv->bdrv_detach_aio_context(bs);\n\n    }\n\n    QLIST_FOREACH(child, &bs->children, next) {\n\n        bdrv_detach_aio_context(child->bs);\n\n    }\n\n\n\n    bs->aio_context = NULL;\n\n}\n", "idx": 25989}
{"project": "qemu", "commit_id": "fe463b7dbc16cc66f3b9a8b7be197fb340378fa3", "target": 0, "func": "void cpu_ppc_reset (void *opaque)\n\n{\n\n    CPUPPCState *env;\n\n    target_ulong msr;\n\n\n\n    env = opaque;\n\n    msr = (target_ulong)0;\n\n    if (0) {\n\n        /* XXX: find a suitable condition to enable the hypervisor mode */\n\n        msr |= (target_ulong)MSR_HVB;\n\n    }\n\n    msr |= (target_ulong)0 << MSR_AP; /* TO BE CHECKED */\n\n    msr |= (target_ulong)0 << MSR_SA; /* TO BE CHECKED */\n\n    msr |= (target_ulong)1 << MSR_EP;\n\n#if defined (DO_SINGLE_STEP) && 0\n\n    /* Single step trace mode */\n\n    msr |= (target_ulong)1 << MSR_SE;\n\n    msr |= (target_ulong)1 << MSR_BE;\n\n#endif\n\n#if defined(CONFIG_USER_ONLY)\n\n    msr |= (target_ulong)1 << MSR_FP; /* Allow floating point usage */\n\n    msr |= (target_ulong)1 << MSR_PR;\n\n#else\n\n    env->nip = env->hreset_vector | env->excp_prefix;\n\n    if (env->mmu_model != POWERPC_MMU_REAL)\n\n        ppc_tlb_invalidate_all(env);\n\n#endif\n\n    env->msr = msr;\n\n    hreg_compute_hflags(env);\n\n    env->reserve = (target_ulong)-1ULL;\n\n    /* Be sure no exception or interrupt is pending */\n\n    env->pending_interrupts = 0;\n\n    env->exception_index = POWERPC_EXCP_NONE;\n\n    env->error_code = 0;\n\n    /* Flush all TLBs */\n\n    tlb_flush(env, 1);\n\n}\n", "idx": 25990}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_sti_write(void *opaque, target_phys_addr_t addr,\n\n                           uint64_t value, unsigned size)\n\n{\n\n    struct omap_sti_s *s = (struct omap_sti_s *) opaque;\n\n\n\n    if (size != 4) {\n\n        return omap_badwidth_write32(opaque, addr, value);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x00:\t/* STI_REVISION */\n\n    case 0x14:\t/* STI_SYSSTATUS / STI_RX_STATUS / XTI_SYSSTATUS */\n\n        OMAP_RO_REG(addr);\n\n        return;\n\n\n\n    case 0x10:\t/* STI_SYSCONFIG */\n\n        if (value & (1 << 1))\t\t\t\t/* SOFTRESET */\n\n            omap_sti_reset(s);\n\n        s->sysconfig = value & 0xfe;\n\n        break;\n\n\n\n    case 0x18:\t/* STI_IRQSTATUS */\n\n        s->irqst &= ~value;\n\n        omap_sti_interrupt_update(s);\n\n        break;\n\n\n\n    case 0x1c:\t/* STI_IRQSETEN / STI_IRQCLREN */\n\n        s->irqen = value & 0xffff;\n\n        omap_sti_interrupt_update(s);\n\n        break;\n\n\n\n    case 0x2c:\t/* STI_CLK_CTRL / XTI_SCLKCRTL */\n\n        s->clkcontrol = value & 0xff;\n\n        break;\n\n\n\n    case 0x30:\t/* STI_SERIAL_CFG / XTI_SCONFIG */\n\n        s->serial_config = value & 0xff;\n\n        break;\n\n\n\n    case 0x24:\t/* STI_ER / STI_DR / XTI_TRACESELECT */\n\n    case 0x28:\t/* STI_RX_DR / XTI_RXDATA */\n\n        /* TODO */\n\n        return;\n\n\n\n    default:\n\n        OMAP_BAD_REG(addr);\n\n        return;\n\n    }\n\n}\n", "idx": 25991}
{"project": "qemu", "commit_id": "880a7578381d1c7ed4d41c7599ae3cc06567a824", "target": 0, "func": "static void gdb_chr_event(void *opaque, int event)\n\n{\n\n    switch (event) {\n\n    case CHR_EVENT_RESET:\n\n        vm_stop(EXCP_INTERRUPT);\n\n        gdb_syscall_state = opaque;\n\n        gdb_has_xml = 0;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 25992}
{"project": "qemu", "commit_id": "e4c8f004c55d9da3eae3e14df740238bf805b5d6", "target": 0, "func": "static void release_keys(void *opaque)\n\n{\n\n    int keycode;\n\n\n\n    while (nb_pending_keycodes > 0) {\n\n        nb_pending_keycodes--;\n\n        keycode = keycodes[nb_pending_keycodes];\n\n        if (keycode & 0x80)\n\n            kbd_put_keycode(0xe0);\n\n        kbd_put_keycode(keycode | 0x80);\n\n    }\n\n}\n", "idx": 25993}
{"project": "qemu", "commit_id": "ef546f1275f6563e8934dd5e338d29d9f9909ca6", "target": 0, "func": "static int virtio_scsi_parse_req(VirtIOSCSIReq *req,\n\n                                 unsigned req_size, unsigned resp_size)\n\n{\n\n    VirtIODevice *vdev = (VirtIODevice *) req->dev;\n\n    size_t in_size, out_size;\n\n\n\n    if (iov_to_buf(req->elem.out_sg, req->elem.out_num, 0,\n\n                   &req->req, req_size) < req_size) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (qemu_iovec_concat_iov(&req->resp_iov,\n\n                              req->elem.in_sg, req->elem.in_num, 0,\n\n                              resp_size) < resp_size) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    req->resp_size = resp_size;\n\n\n\n    /* Old BIOSes left some padding by mistake after the req_size/resp_size.\n\n     * As a workaround, always consider the first buffer as the virtio-scsi\n\n     * request/response, making the payload start at the second element\n\n     * of the iovec.\n\n     *\n\n     * The actual length of the response header, stored in req->resp_size,\n\n     * does not change.\n\n     *\n\n     * TODO: always disable this workaround for virtio 1.0 devices.\n\n     */\n\n    if ((vdev->guest_features & (1 << VIRTIO_F_ANY_LAYOUT)) == 0) {\n\n        req_size = req->elem.out_sg[0].iov_len;\n\n        resp_size = req->elem.in_sg[0].iov_len;\n\n    }\n\n\n\n    out_size = qemu_sgl_concat(req, req->elem.out_sg,\n\n                               &req->elem.out_addr[0], req->elem.out_num,\n\n                               req_size);\n\n    in_size = qemu_sgl_concat(req, req->elem.in_sg,\n\n                              &req->elem.in_addr[0], req->elem.in_num,\n\n                              resp_size);\n\n\n\n    if (out_size && in_size) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    if (out_size) {\n\n        req->mode = SCSI_XFER_TO_DEV;\n\n    } else if (in_size) {\n\n        req->mode = SCSI_XFER_FROM_DEV;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 25994}
{"project": "qemu", "commit_id": "8df1426e44176512be1b6456e90d100d1af907e1", "target": 0, "func": "void pc_dimm_memory_unplug(DeviceState *dev, MemoryHotplugState *hpms,\n\n                           MemoryRegion *mr)\n\n{\n\n    PCDIMMDevice *dimm = PC_DIMM(dev);\n\n\n\n    numa_unset_mem_node_id(dimm->addr, memory_region_size(mr), dimm->node);\n\n    memory_region_del_subregion(&hpms->mr, mr);\n\n    vmstate_unregister_ram(mr, dev);\n\n}\n", "idx": 25995}
{"project": "qemu", "commit_id": "73aaec4a39b3cf11082303a6cf6bcde8796c09c6", "target": 0, "func": "static void kvm_handle_internal_error(CPUState *env, struct kvm_run *run)\n\n{\n\n\n\n    if (kvm_check_extension(kvm_state, KVM_CAP_INTERNAL_ERROR_DATA)) {\n\n        int i;\n\n\n\n        fprintf(stderr, \"KVM internal error. Suberror: %d\\n\",\n\n                run->internal.suberror);\n\n\n\n        for (i = 0; i < run->internal.ndata; ++i) {\n\n            fprintf(stderr, \"extra data[%d]: %\"PRIx64\"\\n\",\n\n                    i, (uint64_t)run->internal.data[i]);\n\n        }\n\n    }\n\n    cpu_dump_state(env, stderr, fprintf, 0);\n\n    if (run->internal.suberror == KVM_INTERNAL_ERROR_EMULATION) {\n\n        fprintf(stderr, \"emulation failure\\n\");\n\n        if (!kvm_arch_stop_on_emulation_error(env)) {\n\n            return;\n\n        }\n\n    }\n\n    /* FIXME: Should trigger a qmp message to let management know\n\n     * something went wrong.\n\n     */\n\n    vm_stop(0);\n\n}\n", "idx": 25996}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,\n\n                             hwaddr size)\n\n{\n\n    assert(mr->terminates);\n\n    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,\n\n                                        memory_region_get_dirty_log_mask(mr));\n\n}\n", "idx": 25997}
{"project": "qemu", "commit_id": "34975e536f3531ad852d724a46280b882ec1bc9d", "target": 0, "func": "static void xenfb_mouse_event(DeviceState *dev, QemuConsole *src,\n\n                              InputEvent *evt)\n\n{\n\n    struct XenInput *xenfb = (struct XenInput *)dev;\n\n    InputBtnEvent *btn;\n\n    InputMoveEvent *move;\n\n    QemuConsole *con;\n\n    DisplaySurface *surface;\n\n    int scale;\n\n\n\n    switch (evt->type) {\n\n    case INPUT_EVENT_KIND_BTN:\n\n        btn = evt->u.btn.data;\n\n        switch (btn->button) {\n\n        case INPUT_BUTTON_LEFT:\n\n            xenfb_send_key(xenfb, btn->down, BTN_LEFT);\n\n            break;\n\n        case INPUT_BUTTON_RIGHT:\n\n            xenfb_send_key(xenfb, btn->down, BTN_LEFT + 1);\n\n            break;\n\n        case INPUT_BUTTON_MIDDLE:\n\n            xenfb_send_key(xenfb, btn->down, BTN_LEFT + 2);\n\n            break;\n\n        case INPUT_BUTTON_WHEEL_UP:\n\n            if (btn->down) {\n\n                xenfb->wheel--;\n\n            }\n\n            break;\n\n        case INPUT_BUTTON_WHEEL_DOWN:\n\n            if (btn->down) {\n\n                xenfb->wheel++;\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case INPUT_EVENT_KIND_ABS:\n\n        move = evt->u.abs.data;\n\n        con = qemu_console_lookup_by_index(0);\n\n        if (!con) {\n\n            xen_pv_printf(&xenfb->c.xendev, 0, \"No QEMU console available\");\n\n            return;\n\n        }\n\n        surface = qemu_console_surface(con);\n\n        switch (move->axis) {\n\n        case INPUT_AXIS_X:\n\n            scale = surface_width(surface) - 1;\n\n            break;\n\n        case INPUT_AXIS_Y:\n\n            scale = surface_height(surface) - 1;\n\n            break;\n\n        default:\n\n            scale = 0x8000;\n\n            break;\n\n        }\n\n        xenfb->axis[move->axis] = move->value * scale / 0x7fff;\n\n        break;\n\n\n\n    case INPUT_EVENT_KIND_REL:\n\n        move = evt->u.rel.data;\n\n        xenfb->axis[move->axis] += move->value;\n\n        break;\n\n\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 25999}
{"project": "qemu", "commit_id": "db39fcf1f690b02d612e2bfc00980700887abe03", "target": 0, "func": "static CharDriverState *qemu_chr_open_socket_fd(int fd, bool do_nodelay,\n\n                                                bool is_listen, bool is_telnet,\n\n                                                bool is_waitconnect,\n\n                                                Error **errp)\n\n{\n\n    CharDriverState *chr = NULL;\n\n    TCPCharDriver *s = NULL;\n\n    char host[NI_MAXHOST], serv[NI_MAXSERV];\n\n    const char *left = \"\", *right = \"\";\n\n    struct sockaddr_storage ss;\n\n    socklen_t ss_len = sizeof(ss);\n\n\n\n    memset(&ss, 0, ss_len);\n\n    if (getsockname(fd, (struct sockaddr *) &ss, &ss_len) != 0) {\n\n        error_setg_errno(errp, errno, \"getsockname\");\n\n        return NULL;\n\n    }\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n    s = g_malloc0(sizeof(TCPCharDriver));\n\n\n\n    s->connected = 0;\n\n    s->fd = -1;\n\n    s->listen_fd = -1;\n\n    s->read_msgfds = 0;\n\n    s->read_msgfds_num = 0;\n\n    s->write_msgfds = 0;\n\n    s->write_msgfds_num = 0;\n\n\n\n    chr->filename = g_malloc(256);\n\n    switch (ss.ss_family) {\n\n#ifndef _WIN32\n\n    case AF_UNIX:\n\n        s->is_unix = 1;\n\n        snprintf(chr->filename, 256, \"unix:%s%s\",\n\n                 ((struct sockaddr_un *)(&ss))->sun_path,\n\n                 is_listen ? \",server\" : \"\");\n\n        break;\n\n#endif\n\n    case AF_INET6:\n\n        left  = \"[\";\n\n        right = \"]\";\n\n        /* fall through */\n\n    case AF_INET:\n\n        s->do_nodelay = do_nodelay;\n\n        getnameinfo((struct sockaddr *) &ss, ss_len, host, sizeof(host),\n\n                    serv, sizeof(serv), NI_NUMERICHOST | NI_NUMERICSERV);\n\n        snprintf(chr->filename, 256, \"%s:%s%s%s:%s%s\",\n\n                 is_telnet ? \"telnet\" : \"tcp\",\n\n                 left, host, right, serv,\n\n                 is_listen ? \",server\" : \"\");\n\n        break;\n\n    }\n\n\n\n    chr->opaque = s;\n\n    chr->chr_write = tcp_chr_write;\n\n    chr->chr_sync_read = tcp_chr_sync_read;\n\n    chr->chr_close = tcp_chr_close;\n\n    chr->get_msgfds = tcp_get_msgfds;\n\n    chr->set_msgfds = tcp_set_msgfds;\n\n    chr->chr_add_client = tcp_chr_add_client;\n\n    chr->chr_add_watch = tcp_chr_add_watch;\n\n    chr->chr_update_read_handler = tcp_chr_update_read_handler;\n\n    /* be isn't opened until we get a connection */\n\n    chr->explicit_be_open = true;\n\n\n\n    if (is_listen) {\n\n        s->listen_fd = fd;\n\n        s->listen_chan = io_channel_from_socket(s->listen_fd);\n\n        s->listen_tag = g_io_add_watch(s->listen_chan, G_IO_IN, tcp_chr_accept, chr);\n\n        if (is_telnet) {\n\n            s->do_telnetopt = 1;\n\n        }\n\n    } else {\n\n        s->connected = 1;\n\n        s->fd = fd;\n\n        socket_set_nodelay(fd);\n\n        s->chan = io_channel_from_socket(s->fd);\n\n        tcp_chr_connect(chr);\n\n    }\n\n\n\n    if (is_listen && is_waitconnect) {\n\n        fprintf(stderr, \"QEMU waiting for connection on: %s\\n\",\n\n                chr->filename);\n\n        tcp_chr_accept(s->listen_chan, G_IO_IN, chr);\n\n        qemu_set_nonblock(s->listen_fd);\n\n    }\n\n    return chr;\n\n}\n", "idx": 26000}
{"project": "qemu", "commit_id": "8aaf42ed0f203da63860b0a3ab3ff2bdfe9b4cb0", "target": 0, "func": "static void dhcp_decode(const struct bootp_t *bp, int *pmsg_type,\n\n                        const struct in_addr **preq_addr)\n\n{\n\n    const uint8_t *p, *p_end;\n\n    int len, tag;\n\n\n\n    *pmsg_type = 0;\n\n    *preq_addr = NULL;\n\n\n\n    p = bp->bp_vend;\n\n    p_end = p + DHCP_OPT_LEN;\n\n    if (memcmp(p, rfc1533_cookie, 4) != 0)\n\n        return;\n\n    p += 4;\n\n    while (p < p_end) {\n\n        tag = p[0];\n\n        if (tag == RFC1533_PAD) {\n\n            p++;\n\n        } else if (tag == RFC1533_END) {\n\n            break;\n\n        } else {\n\n            p++;\n\n            if (p >= p_end)\n\n                break;\n\n            len = *p++;\n\n            DPRINTF(\"dhcp: tag=%d len=%d\\n\", tag, len);\n\n\n\n            switch(tag) {\n\n            case RFC2132_MSG_TYPE:\n\n                if (len >= 1)\n\n                    *pmsg_type = p[0];\n\n                break;\n\n            case RFC2132_REQ_ADDR:\n\n                if (len >= 4)\n\n                    *preq_addr = (struct in_addr *)p;\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n            p += len;\n\n        }\n\n    }\n\n    if (*pmsg_type == DHCPREQUEST && !*preq_addr && bp->bp_ciaddr.s_addr) {\n\n        *preq_addr = &bp->bp_ciaddr;\n\n    }\n\n}\n", "idx": 26001}
{"project": "qemu", "commit_id": "5d739a4787a53da8d787551c8de27ad39fabdb34", "target": 0, "func": "static void virtio_setup(uint64_t dev_info)\n\n{\n\n    struct schib schib;\n\n    int i;\n\n    int r;\n\n    bool found = false;\n\n    bool check_devno = false;\n\n    uint16_t dev_no = -1;\n\n    blk_schid.one = 1;\n\n\n\n    if (dev_info != -1) {\n\n        check_devno = true;\n\n        dev_no = dev_info & 0xffff;\n\n        debug_print_int(\"device no. \", dev_no);\n\n        blk_schid.ssid = (dev_info >> 16) & 0x3;\n\n        if (blk_schid.ssid != 0) {\n\n            debug_print_int(\"ssid \", blk_schid.ssid);\n\n            if (enable_mss_facility() != 0) {\n\n                virtio_panic(\"Failed to enable mss facility\\n\");\n\n            }\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < 0x10000; i++) {\n\n        blk_schid.sch_no = i;\n\n        r = stsch_err(blk_schid, &schib);\n\n        if (r == 3) {\n\n            break;\n\n        }\n\n        if (schib.pmcw.dnv) {\n\n            if (!check_devno || (schib.pmcw.dev == dev_no)) {\n\n                if (virtio_is_blk(blk_schid)) {\n\n                    found = true;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!found) {\n\n        virtio_panic(\"No virtio-blk device found!\\n\");\n\n    }\n\n\n\n    virtio_setup_block(blk_schid);\n\n}\n", "idx": 26002}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static void vnc_display_print_local_addr(VncDisplay *vd)\n\n{\n\n    SocketAddressLegacy *addr;\n\n    Error *err = NULL;\n\n\n\n    if (!vd->nlsock) {\n\n        return;\n\n    }\n\n\n\n    addr = qio_channel_socket_get_local_address(vd->lsock[0], &err);\n\n    if (!addr) {\n\n        return;\n\n    }\n\n\n\n    if (addr->type != SOCKET_ADDRESS_LEGACY_KIND_INET) {\n\n        qapi_free_SocketAddressLegacy(addr);\n\n        return;\n\n    }\n\n    error_printf_unless_qmp(\"VNC server running on %s:%s\\n\",\n\n                            addr->u.inet.data->host,\n\n                            addr->u.inet.data->port);\n\n    qapi_free_SocketAddressLegacy(addr);\n\n}\n", "idx": 26003}
{"project": "qemu", "commit_id": "26a83ad0e793465b74a8b06a65f2f6fdc5615413", "target": 0, "func": "void memory_region_init_ram(MemoryRegion *mr,\n\n                            const char *name,\n\n                            uint64_t size)\n\n{\n\n    memory_region_init(mr, name, size);\n\n    mr->ram = true;\n\n    mr->terminates = true;\n\n    mr->destructor = memory_region_destructor_ram;\n\n    mr->ram_addr = qemu_ram_alloc(size, mr);\n\n    mr->backend_registered = true;\n\n}\n", "idx": 26004}
{"project": "qemu", "commit_id": "678421650dc166cd6cb35bb2bc0baf1b481b40ca", "target": 0, "func": "static uint64_t pchip_read(void *opaque, hwaddr addr, unsigned size)\n\n{\n\n    TyphoonState *s = opaque;\n\n    uint64_t ret = 0;\n\n\n\n    if (addr & 4) {\n\n        return s->latch_tmp;\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x0000:\n\n        /* WSBA0: Window Space Base Address Register.  */\n\n        ret = s->pchip.win[0].base_addr;\n\n        break;\n\n    case 0x0040:\n\n        /* WSBA1 */\n\n        ret = s->pchip.win[1].base_addr;\n\n        break;\n\n    case 0x0080:\n\n        /* WSBA2 */\n\n        ret = s->pchip.win[2].base_addr;\n\n        break;\n\n    case 0x00c0:\n\n        /* WSBA3 */\n\n        ret = s->pchip.win[3].base_addr;\n\n        break;\n\n\n\n    case 0x0100:\n\n        /* WSM0: Window Space Mask Register.  */\n\n        ret = s->pchip.win[0].mask;\n\n        break;\n\n    case 0x0140:\n\n        /* WSM1 */\n\n        ret = s->pchip.win[1].mask;\n\n        break;\n\n    case 0x0180:\n\n        /* WSM2 */\n\n        ret = s->pchip.win[2].mask;\n\n        break;\n\n    case 0x01c0:\n\n        /* WSM3 */\n\n        ret = s->pchip.win[3].mask;\n\n        break;\n\n\n\n    case 0x0200:\n\n        /* TBA0: Translated Base Address Register.  */\n\n        ret = (uint64_t)s->pchip.win[0].translated_base_pfn << 10;\n\n        break;\n\n    case 0x0240:\n\n        /* TBA1 */\n\n        ret = (uint64_t)s->pchip.win[1].translated_base_pfn << 10;\n\n        break;\n\n    case 0x0280:\n\n        /* TBA2 */\n\n        ret = (uint64_t)s->pchip.win[2].translated_base_pfn << 10;\n\n        break;\n\n    case 0x02c0:\n\n        /* TBA3 */\n\n        ret = (uint64_t)s->pchip.win[3].translated_base_pfn << 10;\n\n        break;\n\n\n\n    case 0x0300:\n\n        /* PCTL: Pchip Control Register.  */\n\n        ret = s->pchip.ctl;\n\n        break;\n\n    case 0x0340:\n\n        /* PLAT: Pchip Master Latency Register.  */\n\n        break;\n\n    case 0x03c0:\n\n        /* PERROR: Pchip Error Register.  */\n\n        break;\n\n    case 0x0400:\n\n        /* PERRMASK: Pchip Error Mask Register.  */\n\n        break;\n\n    case 0x0440:\n\n        /* PERRSET: Pchip Error Set Register.  */\n\n        break;\n\n    case 0x0480:\n\n        /* TLBIV: Translation Buffer Invalidate Virtual Register (WO).  */\n\n        break;\n\n    case 0x04c0:\n\n        /* TLBIA: Translation Buffer Invalidate All Register (WO).  */\n\n        break;\n\n    case 0x0500: /* PMONCTL */\n\n    case 0x0540: /* PMONCNT */\n\n    case 0x0800: /* SPRST */\n\n        break;\n\n\n\n    default:\n\n        cpu_unassigned_access(current_cpu, addr, false, false, 0, size);\n\n        return -1;\n\n    }\n\n\n\n    s->latch_tmp = ret >> 32;\n\n    return ret;\n\n}\n", "idx": 26005}
{"project": "qemu", "commit_id": "36eb6e096729f9aade3a6af7dbe4d0a990335d7e", "target": 0, "func": "void cpu_x86_update_dr7(CPUX86State *env, uint32_t new_dr7)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < DR7_MAX_BP; i++) {\n\n        hw_breakpoint_remove(env, i);\n\n    }\n\n    env->dr[7] = new_dr7;\n\n    for (i = 0; i < DR7_MAX_BP; i++) {\n\n        hw_breakpoint_insert(env, i);\n\n    }\n\n}\n", "idx": 26006}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void slavio_serial_ms_kbd_init(target_phys_addr_t base, qemu_irq irq,\n\n                               int disabled, int clock, int it_shift)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n\n\n    dev = qdev_create(NULL, \"escc\");\n\n    qdev_prop_set_uint32(dev, \"disabled\", disabled);\n\n    qdev_prop_set_uint32(dev, \"frequency\", clock);\n\n    qdev_prop_set_uint32(dev, \"it_shift\", it_shift);\n\n    qdev_prop_set_chr(dev, \"chrB\", NULL);\n\n    qdev_prop_set_chr(dev, \"chrA\", NULL);\n\n    qdev_prop_set_uint32(dev, \"chnBtype\", mouse);\n\n    qdev_prop_set_uint32(dev, \"chnAtype\", kbd);\n\n    qdev_init_nofail(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_connect_irq(s, 1, irq);\n\n    sysbus_mmio_map(s, 0, base);\n\n}\n", "idx": 26007}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static int v9fs_synth_lstat(FsContext *fs_ctx,\n\n                            V9fsPath *fs_path, struct stat *stbuf)\n\n{\n\n    V9fsSynthNode *node = *(V9fsSynthNode **)fs_path->data;\n\n\n\n    v9fs_synth_fill_statbuf(node, stbuf);\n\n    return 0;\n\n}\n", "idx": 26008}
{"project": "qemu", "commit_id": "7a2c4b82340d621bff462672b29c88d2020d68c1", "target": 0, "func": "static void cmd_read_toc_pma_atip(IDEState *s, uint8_t* buf)\n\n{\n\n    int format, msf, start_track, len;\n\n    uint64_t total_sectors = s->nb_sectors >> 2;\n\n    int max_len;\n\n\n\n    if (total_sectors == 0) {\n\n        ide_atapi_cmd_error(s, SENSE_NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n\n        return;\n\n    }\n\n\n\n    max_len = ube16_to_cpu(buf + 7);\n\n    format = buf[9] >> 6;\n\n    msf = (buf[1] >> 1) & 1;\n\n    start_track = buf[6];\n\n\n\n    switch(format) {\n\n    case 0:\n\n        len = cdrom_read_toc(total_sectors, buf, msf, start_track);\n\n        if (len < 0)\n\n            goto error_cmd;\n\n        ide_atapi_cmd_reply(s, len, max_len);\n\n        break;\n\n    case 1:\n\n        /* multi session : only a single session defined */\n\n        memset(buf, 0, 12);\n\n        buf[1] = 0x0a;\n\n        buf[2] = 0x01;\n\n        buf[3] = 0x01;\n\n        ide_atapi_cmd_reply(s, 12, max_len);\n\n        break;\n\n    case 2:\n\n        len = cdrom_read_toc_raw(total_sectors, buf, msf, start_track);\n\n        if (len < 0)\n\n            goto error_cmd;\n\n        ide_atapi_cmd_reply(s, len, max_len);\n\n        break;\n\n    default:\n\n    error_cmd:\n\n        ide_atapi_cmd_error(s, SENSE_ILLEGAL_REQUEST,\n\n                            ASC_INV_FIELD_IN_CMD_PACKET);\n\n    }\n\n}\n", "idx": 26010}
{"project": "qemu", "commit_id": "af4b6c54c141c1e2d3637fc15b912e82b88828cf", "target": 0, "func": "static always_inline void gen_intermediate_code_internal (CPUState *env,\n\n                                                          TranslationBlock *tb,\n\n                                                          int search_pc)\n\n{\n\n    DisasContext ctx, *ctxp = &ctx;\n\n    opc_handler_t **table, *handler;\n\n    target_ulong pc_start;\n\n    uint16_t *gen_opc_end;\n\n    CPUBreakpoint *bp;\n\n    int j, lj = -1;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    pc_start = tb->pc;\n\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n    ctx.nip = pc_start;\n\n    ctx.tb = tb;\n\n    ctx.exception = POWERPC_EXCP_NONE;\n\n    ctx.spr_cb = env->spr_cb;\n\n    ctx.mem_idx = env->mmu_idx;\n\n    ctx.access_type = -1;\n\n    ctx.le_mode = env->hflags & (1 << MSR_LE) ? 1 : 0;\n\n#if defined(TARGET_PPC64)\n\n    ctx.sf_mode = msr_sf;\n\n#endif\n\n    ctx.fpu_enabled = msr_fp;\n\n    if ((env->flags & POWERPC_FLAG_SPE) && msr_spe)\n\n        ctx.spe_enabled = msr_spe;\n\n    else\n\n        ctx.spe_enabled = 0;\n\n    if ((env->flags & POWERPC_FLAG_VRE) && msr_vr)\n\n        ctx.altivec_enabled = msr_vr;\n\n    else\n\n        ctx.altivec_enabled = 0;\n\n    if ((env->flags & POWERPC_FLAG_SE) && msr_se)\n\n        ctx.singlestep_enabled = CPU_SINGLE_STEP;\n\n    else\n\n        ctx.singlestep_enabled = 0;\n\n    if ((env->flags & POWERPC_FLAG_BE) && msr_be)\n\n        ctx.singlestep_enabled |= CPU_BRANCH_STEP;\n\n    if (unlikely(env->singlestep_enabled))\n\n        ctx.singlestep_enabled |= GDBSTUB_SINGLE_STEP;\n\n#if defined (DO_SINGLE_STEP) && 0\n\n    /* Single step trace mode */\n\n    msr_se = 1;\n\n#endif\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0)\n\n        max_insns = CF_COUNT_MASK;\n\n\n\n    gen_icount_start();\n\n    /* Set env in case of segfault during code fetch */\n\n    while (ctx.exception == POWERPC_EXCP_NONE && gen_opc_ptr < gen_opc_end) {\n\n        if (unlikely(!TAILQ_EMPTY(&env->breakpoints))) {\n\n            TAILQ_FOREACH(bp, &env->breakpoints, entry) {\n\n                if (bp->pc == ctx.nip) {\n\n                    gen_debug_exception(ctxp);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (unlikely(search_pc)) {\n\n            j = gen_opc_ptr - gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    gen_opc_instr_start[lj++] = 0;\n\n                gen_opc_pc[lj] = ctx.nip;\n\n                gen_opc_instr_start[lj] = 1;\n\n                gen_opc_icount[lj] = num_insns;\n\n            }\n\n        }\n\n        LOG_DISAS(\"----------------\\n\");\n\n        LOG_DISAS(\"nip=\" ADDRX \" super=%d ir=%d\\n\",\n\n                  ctx.nip, ctx.mem_idx, (int)msr_ir);\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))\n\n            gen_io_start();\n\n        if (unlikely(ctx.le_mode)) {\n\n            ctx.opcode = bswap32(ldl_code(ctx.nip));\n\n        } else {\n\n            ctx.opcode = ldl_code(ctx.nip);\n\n        }\n\n        LOG_DISAS(\"translate opcode %08x (%02x %02x %02x) (%s)\\n\",\n\n                    ctx.opcode, opc1(ctx.opcode), opc2(ctx.opcode),\n\n                    opc3(ctx.opcode), little_endian ? \"little\" : \"big\");\n\n        ctx.nip += 4;\n\n        table = env->opcodes;\n\n        num_insns++;\n\n        handler = table[opc1(ctx.opcode)];\n\n        if (is_indirect_opcode(handler)) {\n\n            table = ind_table(handler);\n\n            handler = table[opc2(ctx.opcode)];\n\n            if (is_indirect_opcode(handler)) {\n\n                table = ind_table(handler);\n\n                handler = table[opc3(ctx.opcode)];\n\n            }\n\n        }\n\n        /* Is opcode *REALLY* valid ? */\n\n        if (unlikely(handler->handler == &gen_invalid)) {\n\n            if (qemu_log_enabled()) {\n\n                qemu_log(\"invalid/unsupported opcode: \"\n\n                          \"%02x - %02x - %02x (%08x) \" ADDRX \" %d\\n\",\n\n                          opc1(ctx.opcode), opc2(ctx.opcode),\n\n                          opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, (int)msr_ir);\n\n            } else {\n\n                printf(\"invalid/unsupported opcode: \"\n\n                       \"%02x - %02x - %02x (%08x) \" ADDRX \" %d\\n\",\n\n                       opc1(ctx.opcode), opc2(ctx.opcode),\n\n                       opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, (int)msr_ir);\n\n            }\n\n        } else {\n\n            if (unlikely((ctx.opcode & handler->inval) != 0)) {\n\n                if (qemu_log_enabled()) {\n\n                    qemu_log(\"invalid bits: %08x for opcode: \"\n\n                              \"%02x - %02x - %02x (%08x) \" ADDRX \"\\n\",\n\n                              ctx.opcode & handler->inval, opc1(ctx.opcode),\n\n                              opc2(ctx.opcode), opc3(ctx.opcode),\n\n                              ctx.opcode, ctx.nip - 4);\n\n                } else {\n\n                    printf(\"invalid bits: %08x for opcode: \"\n\n                           \"%02x - %02x - %02x (%08x) \" ADDRX \"\\n\",\n\n                           ctx.opcode & handler->inval, opc1(ctx.opcode),\n\n                           opc2(ctx.opcode), opc3(ctx.opcode),\n\n                           ctx.opcode, ctx.nip - 4);\n\n                }\n\n                gen_inval_exception(ctxp, POWERPC_EXCP_INVAL_INVAL);\n\n                break;\n\n            }\n\n        }\n\n        (*(handler->handler))(&ctx);\n\n#if defined(DO_PPC_STATISTICS)\n\n        handler->count++;\n\n#endif\n\n        /* Check trace mode exceptions */\n\n        if (unlikely(ctx.singlestep_enabled & CPU_SINGLE_STEP &&\n\n                     (ctx.nip <= 0x100 || ctx.nip > 0xF00) &&\n\n                     ctx.exception != POWERPC_SYSCALL &&\n\n                     ctx.exception != POWERPC_EXCP_TRAP &&\n\n                     ctx.exception != POWERPC_EXCP_BRANCH)) {\n\n            gen_exception(ctxp, POWERPC_EXCP_TRACE);\n\n        } else if (unlikely(((ctx.nip & (TARGET_PAGE_SIZE - 1)) == 0) ||\n\n                            (env->singlestep_enabled) ||\n\n                            num_insns >= max_insns)) {\n\n            /* if we reach a page boundary or are single stepping, stop\n\n             * generation\n\n             */\n\n            break;\n\n        }\n\n#if defined (DO_SINGLE_STEP)\n\n        break;\n\n#endif\n\n    }\n\n    if (tb->cflags & CF_LAST_IO)\n\n        gen_io_end();\n\n    if (ctx.exception == POWERPC_EXCP_NONE) {\n\n        gen_goto_tb(&ctx, 0, ctx.nip);\n\n    } else if (ctx.exception != POWERPC_EXCP_BRANCH) {\n\n        if (unlikely(env->singlestep_enabled)) {\n\n            gen_debug_exception(ctxp);\n\n        }\n\n        /* Generate the return instruction */\n\n        tcg_gen_exit_tb(0);\n\n    }\n\n    gen_icount_end(tb, num_insns);\n\n    *gen_opc_ptr = INDEX_op_end;\n\n    if (unlikely(search_pc)) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n    } else {\n\n        tb->size = ctx.nip - pc_start;\n\n        tb->icount = num_insns;\n\n    }\n\n#if defined(DEBUG_DISAS)\n\n    qemu_log_mask(CPU_LOG_TB_CPU, \"---------------- excp: %04x\\n\", ctx.exception);\n\n    log_cpu_state_mask(CPU_LOG_TB_CPU, env, 0);\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        int flags;\n\n        flags = env->bfd_mach;\n\n        flags |= ctx.le_mode << 16;\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n        log_target_disas(pc_start, ctx.nip - pc_start, flags);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n}\n", "idx": 26013}
{"project": "qemu", "commit_id": "eacc324914c2dc7aecec3b4ea920252b685b5c8e", "target": 0, "func": "static int slb_lookup (CPUPPCState *env, target_ulong eaddr,\n\n                       target_ulong *vsid, target_ulong *page_mask, int *attr)\n\n{\n\n    target_phys_addr_t sr_base;\n\n    target_ulong mask;\n\n    uint64_t tmp64;\n\n    uint32_t tmp;\n\n    int n, ret;\n\n    int slb_nr;\n\n\n\n    ret = -5;\n\n    sr_base = env->spr[SPR_ASR];\n\n#if defined(DEBUG_SLB)\n\n    if (loglevel != 0) {\n\n        fprintf(logfile, \"%s: eaddr \" ADDRX \" base \" PADDRX \"\\n\",\n\n                __func__, eaddr, sr_base);\n\n    }\n\n#endif\n\n    mask = 0x0000000000000000ULL; /* Avoid gcc warning */\n\n    slb_nr = env->slb_nr;\n\n    for (n = 0; n < slb_nr; n++) {\n\n        tmp64 = ldq_phys(sr_base);\n\n        tmp = ldl_phys(sr_base + 8);\n\n#if defined(DEBUG_SLB)\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"%s: seg %d \" PADDRX \" %016\" PRIx64 \" %08\"\n\n                    PRIx32 \"\\n\", __func__, n, sr_base, tmp64, tmp);\n\n        }\n\n#endif\n\n        if (tmp64 & 0x0000000008000000ULL) {\n\n            /* SLB entry is valid */\n\n            switch (tmp64 & 0x0000000006000000ULL) {\n\n            case 0x0000000000000000ULL:\n\n                /* 256 MB segment */\n\n                mask = 0xFFFFFFFFF0000000ULL;\n\n                break;\n\n            case 0x0000000002000000ULL:\n\n                /* 1 TB segment */\n\n                mask = 0xFFFF000000000000ULL;\n\n                break;\n\n            case 0x0000000004000000ULL:\n\n            case 0x0000000006000000ULL:\n\n                /* Reserved => segment is invalid */\n\n                continue;\n\n            }\n\n            if ((eaddr & mask) == (tmp64 & mask)) {\n\n                /* SLB match */\n\n                *vsid = ((tmp64 << 24) | (tmp >> 8)) & 0x0003FFFFFFFFFFFFULL;\n\n                *page_mask = ~mask;\n\n                *attr = tmp & 0xFF;\n\n                ret = 0;\n\n                break;\n\n            }\n\n        }\n\n        sr_base += 12;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 26014}
{"project": "qemu", "commit_id": "7fd669a1c49743073e53166798244f15b1a8e0d2", "target": 0, "func": "static const mon_cmd_t *monitor_parse_command(Monitor *mon,\n\n                                              const char *cmdline,\n\n                                              QDict *qdict)\n\n{\n\n    const char *p, *typestr;\n\n    int c;\n\n    const mon_cmd_t *cmd;\n\n    char cmdname[256];\n\n    char buf[1024];\n\n    char *key;\n\n\n\n#ifdef DEBUG\n\n    monitor_printf(mon, \"command='%s'\\n\", cmdline);\n\n#endif\n\n\n\n    /* extract the command name */\n\n    p = get_command_name(cmdline, cmdname, sizeof(cmdname));\n\n    if (!p)\n\n        return NULL;\n\n\n\n    /* find the command */\n\n    for(cmd = mon_cmds; cmd->name != NULL; cmd++) {\n\n        if (compare_cmd(cmdname, cmd->name))\n\n            break;\n\n    }\n\n\n\n    if (cmd->name == NULL) {\n\n        monitor_printf(mon, \"unknown command: '%s'\\n\", cmdname);\n\n        return NULL;\n\n    }\n\n\n\n    /* parse the parameters */\n\n    typestr = cmd->args_type;\n\n    for(;;) {\n\n        typestr = key_get_info(typestr, &key);\n\n        if (!typestr)\n\n            break;\n\n        c = *typestr;\n\n        typestr++;\n\n        switch(c) {\n\n        case 'F':\n\n        case 'B':\n\n        case 's':\n\n            {\n\n                int ret;\n\n\n\n                while (qemu_isspace(*p))\n\n                    p++;\n\n                if (*typestr == '?') {\n\n                    typestr++;\n\n                    if (*p == '\\0') {\n\n                        /* no optional string: NULL argument */\n\n                        break;\n\n                    }\n\n                }\n\n                ret = get_str(buf, sizeof(buf), &p);\n\n                if (ret < 0) {\n\n                    switch(c) {\n\n                    case 'F':\n\n                        monitor_printf(mon, \"%s: filename expected\\n\",\n\n                                       cmdname);\n\n                        break;\n\n                    case 'B':\n\n                        monitor_printf(mon, \"%s: block device name expected\\n\",\n\n                                       cmdname);\n\n                        break;\n\n                    default:\n\n                        monitor_printf(mon, \"%s: string expected\\n\", cmdname);\n\n                        break;\n\n                    }\n\n                    goto fail;\n\n                }\n\n                qdict_put(qdict, key, qstring_from_str(buf));\n\n            }\n\n            break;\n\n        case '/':\n\n            {\n\n                int count, format, size;\n\n\n\n                while (qemu_isspace(*p))\n\n                    p++;\n\n                if (*p == '/') {\n\n                    /* format found */\n\n                    p++;\n\n                    count = 1;\n\n                    if (qemu_isdigit(*p)) {\n\n                        count = 0;\n\n                        while (qemu_isdigit(*p)) {\n\n                            count = count * 10 + (*p - '0');\n\n                            p++;\n\n                        }\n\n                    }\n\n                    size = -1;\n\n                    format = -1;\n\n                    for(;;) {\n\n                        switch(*p) {\n\n                        case 'o':\n\n                        case 'd':\n\n                        case 'u':\n\n                        case 'x':\n\n                        case 'i':\n\n                        case 'c':\n\n                            format = *p++;\n\n                            break;\n\n                        case 'b':\n\n                            size = 1;\n\n                            p++;\n\n                            break;\n\n                        case 'h':\n\n                            size = 2;\n\n                            p++;\n\n                            break;\n\n                        case 'w':\n\n                            size = 4;\n\n                            p++;\n\n                            break;\n\n                        case 'g':\n\n                        case 'L':\n\n                            size = 8;\n\n                            p++;\n\n                            break;\n\n                        default:\n\n                            goto next;\n\n                        }\n\n                    }\n\n                next:\n\n                    if (*p != '\\0' && !qemu_isspace(*p)) {\n\n                        monitor_printf(mon, \"invalid char in format: '%c'\\n\",\n\n                                       *p);\n\n                        goto fail;\n\n                    }\n\n                    if (format < 0)\n\n                        format = default_fmt_format;\n\n                    if (format != 'i') {\n\n                        /* for 'i', not specifying a size gives -1 as size */\n\n                        if (size < 0)\n\n                            size = default_fmt_size;\n\n                        default_fmt_size = size;\n\n                    }\n\n                    default_fmt_format = format;\n\n                } else {\n\n                    count = 1;\n\n                    format = default_fmt_format;\n\n                    if (format != 'i') {\n\n                        size = default_fmt_size;\n\n                    } else {\n\n                        size = -1;\n\n                    }\n\n                }\n\n                qdict_put(qdict, \"count\", qint_from_int(count));\n\n                qdict_put(qdict, \"format\", qint_from_int(format));\n\n                qdict_put(qdict, \"size\", qint_from_int(size));\n\n            }\n\n            break;\n\n        case 'i':\n\n        case 'l':\n\n            {\n\n                int64_t val;\n\n\n\n                while (qemu_isspace(*p))\n\n                    p++;\n\n                if (*typestr == '?' || *typestr == '.') {\n\n                    if (*typestr == '?') {\n\n                        if (*p == '\\0') {\n\n                            typestr++;\n\n                            break;\n\n                        }\n\n                    } else {\n\n                        if (*p == '.') {\n\n                            p++;\n\n                            while (qemu_isspace(*p))\n\n                                p++;\n\n                        } else {\n\n                            typestr++;\n\n                            break;\n\n                        }\n\n                    }\n\n                    typestr++;\n\n                }\n\n                if (get_expr(mon, &val, &p))\n\n                    goto fail;\n\n                /* Check if 'i' is greater than 32-bit */\n\n                if ((c == 'i') && ((val >> 32) & 0xffffffff)) {\n\n                    monitor_printf(mon, \"\\'%s\\' has failed: \", cmdname);\n\n                    monitor_printf(mon, \"integer is for 32-bit values\\n\");\n\n                    goto fail;\n\n                }\n\n                qdict_put(qdict, key, qint_from_int(val));\n\n            }\n\n            break;\n\n        case '-':\n\n            {\n\n                const char *tmp = p;\n\n                int has_option, skip_key = 0;\n\n                /* option */\n\n\n\n                c = *typestr++;\n\n                if (c == '\\0')\n\n                    goto bad_type;\n\n                while (qemu_isspace(*p))\n\n                    p++;\n\n                has_option = 0;\n\n                if (*p == '-') {\n\n                    p++;\n\n                    if(c != *p) {\n\n                        if(!is_valid_option(p, typestr)) {\n\n                  \n\n                            monitor_printf(mon, \"%s: unsupported option -%c\\n\",\n\n                                           cmdname, *p);\n\n                            goto fail;\n\n                        } else {\n\n                            skip_key = 1;\n\n                        }\n\n                    }\n\n                    if(skip_key) {\n\n                        p = tmp;\n\n                    } else {\n\n                        p++;\n\n                        has_option = 1;\n\n                    }\n\n                }\n\n                qdict_put(qdict, key, qint_from_int(has_option));\n\n            }\n\n            break;\n\n        default:\n\n        bad_type:\n\n            monitor_printf(mon, \"%s: unknown type '%c'\\n\", cmdname, c);\n\n            goto fail;\n\n        }\n\n        qemu_free(key);\n\n        key = NULL;\n\n    }\n\n    /* check that all arguments were parsed */\n\n    while (qemu_isspace(*p))\n\n        p++;\n\n    if (*p != '\\0') {\n\n        monitor_printf(mon, \"%s: extraneous characters at the end of line\\n\",\n\n                       cmdname);\n\n        goto fail;\n\n    }\n\n\n\n    return cmd;\n\n\n\nfail:\n\n    qemu_free(key);\n\n    return NULL;\n\n}\n", "idx": 26015}
{"project": "qemu", "commit_id": "d85f4222b4681da7ebf8a90b26e085a68fa2c55a", "target": 0, "func": "static coroutine_fn int qcow_co_writev(BlockDriverState *bs, int64_t sector_num,\n\n                          int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    uint64_t cluster_offset;\n\n    int ret = 0, n;\n\n    struct iovec hd_iov;\n\n    QEMUIOVector hd_qiov;\n\n    uint8_t *buf;\n\n    void *orig_buf;\n\n\n\n    s->cluster_cache_offset = -1; /* disable compressed cache */\n\n\n\n    /* We must always copy the iov when encrypting, so we\n\n     * don't modify the original data buffer during encryption */\n\n    if (bs->encrypted || qiov->niov > 1) {\n\n        buf = orig_buf = qemu_try_blockalign(bs, qiov->size);\n\n        if (buf == NULL) {\n\n            return -ENOMEM;\n\n        }\n\n        qemu_iovec_to_buf(qiov, 0, buf, qiov->size);\n\n    } else {\n\n        orig_buf = NULL;\n\n        buf = (uint8_t *)qiov->iov->iov_base;\n\n    }\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (nb_sectors != 0) {\n\n\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        n = s->cluster_sectors - index_in_cluster;\n\n        if (n > nb_sectors) {\n\n            n = nb_sectors;\n\n        }\n\n        cluster_offset = get_cluster_offset(bs, sector_num << 9, 1, 0,\n\n                                            index_in_cluster,\n\n                                            index_in_cluster + n);\n\n        if (!cluster_offset || (cluster_offset & 511) != 0) {\n\n            ret = -EIO;\n\n            break;\n\n        }\n\n        if (bs->encrypted) {\n\n            Error *err = NULL;\n\n            assert(s->cipher);\n\n            if (encrypt_sectors(s, sector_num, buf, n, true, &err) < 0) {\n\n                error_free(err);\n\n                ret = -EIO;\n\n                break;\n\n            }\n\n        }\n\n\n\n        hd_iov.iov_base = (void *)buf;\n\n        hd_iov.iov_len = n * 512;\n\n        qemu_iovec_init_external(&hd_qiov, &hd_iov, 1);\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        ret = bdrv_co_writev(bs->file,\n\n                             (cluster_offset >> 9) + index_in_cluster,\n\n                             n, &hd_qiov);\n\n        qemu_co_mutex_lock(&s->lock);\n\n        if (ret < 0) {\n\n            break;\n\n        }\n\n        ret = 0;\n\n\n\n        nb_sectors -= n;\n\n        sector_num += n;\n\n        buf += n * 512;\n\n    }\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    qemu_vfree(orig_buf);\n\n\n\n    return ret;\n\n}\n", "idx": 26016}
{"project": "qemu", "commit_id": "7e7e2ebc942da8285931ceabf12823e165dced8b", "target": 0, "func": "static void start_auth_vencrypt_subauth(VncState *vs)\n\n{\n\n    switch (vs->vd->subauth) {\n\n    case VNC_AUTH_VENCRYPT_TLSNONE:\n\n    case VNC_AUTH_VENCRYPT_X509NONE:\n\n       VNC_DEBUG(\"Accept TLS auth none\\n\");\n\n       vnc_write_u32(vs, 0); /* Accept auth completion */\n\n       start_client_init(vs);\n\n       break;\n\n\n\n    case VNC_AUTH_VENCRYPT_TLSVNC:\n\n    case VNC_AUTH_VENCRYPT_X509VNC:\n\n       VNC_DEBUG(\"Start TLS auth VNC\\n\");\n\n       start_auth_vnc(vs);\n\n       break;\n\n\n\n#ifdef CONFIG_VNC_SASL\n\n    case VNC_AUTH_VENCRYPT_TLSSASL:\n\n    case VNC_AUTH_VENCRYPT_X509SASL:\n\n      VNC_DEBUG(\"Start TLS auth SASL\\n\");\n\n      return start_auth_sasl(vs);\n\n#endif /* CONFIG_VNC_SASL */\n\n\n\n    default: /* Should not be possible, but just in case */\n\n       VNC_DEBUG(\"Reject subauth %d server bug\\n\", vs->vd->auth);\n\n       vnc_write_u8(vs, 1);\n\n       if (vs->minor >= 8) {\n\n           static const char err[] = \"Unsupported authentication type\";\n\n           vnc_write_u32(vs, sizeof(err));\n\n           vnc_write(vs, err, sizeof(err));\n\n       }\n\n       vnc_client_error(vs);\n\n    }\n\n}\n", "idx": 26017}
{"project": "qemu", "commit_id": "bf328399da57450feaeaa24c2539a351e41713db", "target": 0, "func": "static int list_pci(ClpReqRspListPci *rrb, uint8_t *cc)\n\n{\n\n    S390PCIBusDevice *pbdev;\n\n    uint32_t res_code, initial_l2, g_l2, finish;\n\n    int rc, idx;\n\n    uint64_t resume_token;\n\n\n\n    rc = 0;\n\n    if (lduw_p(&rrb->request.hdr.len) != 32) {\n\n        res_code = CLP_RC_LEN;\n\n        rc = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    if ((ldl_p(&rrb->request.fmt) & CLP_MASK_FMT) != 0) {\n\n        res_code = CLP_RC_FMT;\n\n        rc = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    if ((ldl_p(&rrb->request.fmt) & ~CLP_MASK_FMT) != 0 ||\n\n        ldq_p(&rrb->request.reserved1) != 0 ||\n\n        ldq_p(&rrb->request.reserved2) != 0) {\n\n        res_code = CLP_RC_RESNOT0;\n\n        rc = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    resume_token = ldq_p(&rrb->request.resume_token);\n\n\n\n    if (resume_token) {\n\n        pbdev = s390_pci_find_dev_by_idx(resume_token);\n\n        if (!pbdev) {\n\n            res_code = CLP_RC_LISTPCI_BADRT;\n\n            rc = -EINVAL;\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    if (lduw_p(&rrb->response.hdr.len) < 48) {\n\n        res_code = CLP_RC_8K;\n\n        rc = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    initial_l2 = lduw_p(&rrb->response.hdr.len);\n\n    if ((initial_l2 - LIST_PCI_HDR_LEN) % sizeof(ClpFhListEntry)\n\n        != 0) {\n\n        res_code = CLP_RC_LEN;\n\n        rc = -EINVAL;\n\n        *cc = 3;\n\n        goto out;\n\n    }\n\n\n\n    stl_p(&rrb->response.fmt, 0);\n\n    stq_p(&rrb->response.reserved1, 0);\n\n    stq_p(&rrb->response.reserved2, 0);\n\n    stl_p(&rrb->response.mdd, FH_MASK_SHM);\n\n    stw_p(&rrb->response.max_fn, PCI_MAX_FUNCTIONS);\n\n    rrb->response.entry_size = sizeof(ClpFhListEntry);\n\n    finish = 0;\n\n    idx = resume_token;\n\n    g_l2 = LIST_PCI_HDR_LEN;\n\n    do {\n\n        pbdev = s390_pci_find_dev_by_idx(idx);\n\n        if (!pbdev) {\n\n            finish = 1;\n\n            break;\n\n        }\n\n        stw_p(&rrb->response.fh_list[idx - resume_token].device_id,\n\n            pci_get_word(pbdev->pdev->config + PCI_DEVICE_ID));\n\n        stw_p(&rrb->response.fh_list[idx - resume_token].vendor_id,\n\n            pci_get_word(pbdev->pdev->config + PCI_VENDOR_ID));\n\n        /* Ignore RESERVED devices. */\n\n        stl_p(&rrb->response.fh_list[idx - resume_token].config,\n\n            pbdev->state == ZPCI_FS_STANDBY ? 0 : 1 << 31);\n\n        stl_p(&rrb->response.fh_list[idx - resume_token].fid, pbdev->fid);\n\n        stl_p(&rrb->response.fh_list[idx - resume_token].fh, pbdev->fh);\n\n\n\n        g_l2 += sizeof(ClpFhListEntry);\n\n        /* Add endian check for DPRINTF? */\n\n        DPRINTF(\"g_l2 %d vendor id 0x%x device id 0x%x fid 0x%x fh 0x%x\\n\",\n\n            g_l2,\n\n            lduw_p(&rrb->response.fh_list[idx - resume_token].vendor_id),\n\n            lduw_p(&rrb->response.fh_list[idx - resume_token].device_id),\n\n            ldl_p(&rrb->response.fh_list[idx - resume_token].fid),\n\n            ldl_p(&rrb->response.fh_list[idx - resume_token].fh));\n\n        idx++;\n\n    } while (g_l2 < initial_l2);\n\n\n\n    if (finish == 1) {\n\n        resume_token = 0;\n\n    } else {\n\n        resume_token = idx;\n\n    }\n\n    stq_p(&rrb->response.resume_token, resume_token);\n\n    stw_p(&rrb->response.hdr.len, g_l2);\n\n    stw_p(&rrb->response.hdr.rsp, CLP_RC_OK);\n\nout:\n\n    if (rc) {\n\n        DPRINTF(\"list pci failed rc 0x%x\\n\", rc);\n\n        stw_p(&rrb->response.hdr.rsp, res_code);\n\n    }\n\n    return rc;\n\n}\n", "idx": 26018}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void disas_test_b_imm(DisasContext *s, uint32_t insn)\n\n{\n\n    unsigned int bit_pos, op, rt;\n\n    uint64_t addr;\n\n    int label_match;\n\n    TCGv_i64 tcg_cmp;\n\n\n\n    bit_pos = (extract32(insn, 31, 1) << 5) | extract32(insn, 19, 5);\n\n    op = extract32(insn, 24, 1); /* 0: TBZ; 1: TBNZ */\n\n    addr = s->pc + sextract32(insn, 5, 14) * 4 - 4;\n\n    rt = extract32(insn, 0, 5);\n\n\n\n    tcg_cmp = tcg_temp_new_i64();\n\n    tcg_gen_andi_i64(tcg_cmp, cpu_reg(s, rt), (1ULL << bit_pos));\n\n    label_match = gen_new_label();\n\n    tcg_gen_brcondi_i64(op ? TCG_COND_NE : TCG_COND_EQ,\n\n                        tcg_cmp, 0, label_match);\n\n    tcg_temp_free_i64(tcg_cmp);\n\n    gen_goto_tb(s, 0, s->pc);\n\n    gen_set_label(label_match);\n\n    gen_goto_tb(s, 1, addr);\n\n}\n", "idx": 26019}
{"project": "qemu", "commit_id": "65c0f1e9558c7c762cdb333406243fff1d687117", "target": 0, "func": "static QObject *parse_escape(JSONParserContext *ctxt, QList **tokens, va_list *ap)\n\n{\n\n    QObject *token = NULL, *obj;\n\n    QList *working = qlist_copy(*tokens);\n\n\n\n    if (ap == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    token = qlist_pop(working);\n\n    if (token == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_is_escape(token, \"%p\")) {\n\n        obj = va_arg(*ap, QObject *);\n\n    } else if (token_is_escape(token, \"%i\")) {\n\n        obj = QOBJECT(qbool_from_int(va_arg(*ap, int)));\n\n    } else if (token_is_escape(token, \"%d\")) {\n\n        obj = QOBJECT(qint_from_int(va_arg(*ap, int)));\n\n    } else if (token_is_escape(token, \"%ld\")) {\n\n        obj = QOBJECT(qint_from_int(va_arg(*ap, long)));\n\n    } else if (token_is_escape(token, \"%lld\") ||\n\n               token_is_escape(token, \"%I64d\")) {\n\n        obj = QOBJECT(qint_from_int(va_arg(*ap, long long)));\n\n    } else if (token_is_escape(token, \"%s\")) {\n\n        obj = QOBJECT(qstring_from_str(va_arg(*ap, const char *)));\n\n    } else if (token_is_escape(token, \"%f\")) {\n\n        obj = QOBJECT(qfloat_from_double(va_arg(*ap, double)));\n\n    } else {\n\n        goto out;\n\n    }\n\n\n\n    qobject_decref(token);\n\n    QDECREF(*tokens);\n\n    *tokens = working;\n\n\n\n    return obj;\n\n\n\nout:\n\n    qobject_decref(token);\n\n    QDECREF(working);\n\n\n\n    return NULL;\n\n}\n", "idx": 26020}
{"project": "qemu", "commit_id": "defdb20e1a8ac3a7200aaf190d7fb20a5ac8bcea", "target": 0, "func": "ParallelState *parallel_mm_init(target_phys_addr_t base, int it_shift, qemu_irq irq, CharDriverState *chr)\n\n{\n\n    ParallelState *s;\n\n    int io_sw;\n\n\n\n    s = qemu_mallocz(sizeof(ParallelState));\n\n    s->irq = irq;\n\n    s->chr = chr;\n\n    s->it_shift = it_shift;\n\n    qemu_register_reset(parallel_reset, s);\n\n\n\n    io_sw = cpu_register_io_memory(parallel_mm_read_sw, parallel_mm_write_sw,\n\n                                   s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(base, 8 << it_shift, io_sw);\n\n    return s;\n\n}\n", "idx": 26021}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "int float32_le( float32 a, float32 b STATUS_PARAM )\n\n{\n\n    flag aSign, bSign;\n\n\n\n    if (    ( ( extractFloat32Exp( a ) == 0xFF ) && extractFloat32Frac( a ) )\n\n         || ( ( extractFloat32Exp( b ) == 0xFF ) && extractFloat32Frac( b ) )\n\n       ) {\n\n        float_raise( float_flag_invalid STATUS_VAR);\n\n        return 0;\n\n    }\n\n    aSign = extractFloat32Sign( a );\n\n    bSign = extractFloat32Sign( b );\n\n    if ( aSign != bSign ) return aSign || ( (bits32) ( ( a | b )<<1 ) == 0 );\n\n    return ( a == b ) || ( aSign ^ ( a < b ) );\n\n\n\n}\n", "idx": 26022}
{"project": "qemu", "commit_id": "bb5fc20f7c1c65e95030da3629dd0d7a0cce38cd", "target": 0, "func": "USBDevice *usb_msd_init(const char *filename, BlockDriverState **pbs)\n\n{\n\n    MSDState *s;\n\n    BlockDriverState *bdrv;\n\n    BlockDriver *drv = NULL;\n\n    const char *p1;\n\n    char fmt[32];\n\n\n\n    p1 = strchr(filename, ':');\n\n    if (p1++) {\n\n        const char *p2;\n\n\n\n        if (strstart(filename, \"format=\", &p2)) {\n\n            int len = MIN(p1 - p2, sizeof(fmt));\n\n            pstrcpy(fmt, len, p2);\n\n\n\n            drv = bdrv_find_format(fmt);\n\n            if (!drv) {\n\n                printf(\"invalid format %s\\n\", fmt);\n\n                return NULL;\n\n            }\n\n        } else if (*filename != ':') {\n\n            printf(\"unrecognized USB mass-storage option %s\\n\", filename);\n\n            return NULL;\n\n        }\n\n\n\n        filename = p1;\n\n    }\n\n\n\n    if (!*filename) {\n\n        printf(\"block device specification needed\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    s = qemu_mallocz(sizeof(MSDState));\n\n\n\n    bdrv = bdrv_new(\"usb\");\n\n    if (bdrv_open2(bdrv, filename, 0, drv) < 0)\n\n        goto fail;\n\n    s->bs = bdrv;\n\n    *pbs = bdrv;\n\n\n\n    s->dev.speed = USB_SPEED_FULL;\n\n    s->dev.handle_packet = usb_generic_handle_packet;\n\n\n\n    s->dev.handle_reset = usb_msd_handle_reset;\n\n    s->dev.handle_control = usb_msd_handle_control;\n\n    s->dev.handle_data = usb_msd_handle_data;\n\n    s->dev.handle_destroy = usb_msd_handle_destroy;\n\n\n\n    snprintf(s->dev.devname, sizeof(s->dev.devname), \"QEMU USB MSD(%.16s)\",\n\n             filename);\n\n\n\n    s->scsi_dev = scsi_disk_init(bdrv, 0, usb_msd_command_complete, s);\n\n    usb_msd_handle_reset((USBDevice *)s);\n\n    return (USBDevice *)s;\n\n fail:\n\n    qemu_free(s);\n\n    return NULL;\n\n}\n", "idx": 26024}
{"project": "qemu", "commit_id": "0d82d0e8b98cf0ea03a45f8542d835ebd3a84cd3", "target": 0, "func": "static int buffered_rate_limit(void *opaque)\n\n{\n\n    QEMUFileBuffered *s = opaque;\n\n    int ret;\n\n\n\n    ret = qemu_file_get_error(s->file);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    if (s->bytes_xfer > s->xfer_limit)\n\n        return 1;\n\n\n\n    return 0;\n\n}\n", "idx": 26025}
{"project": "qemu", "commit_id": "a3f1afb43a09e4577571c044c48f2ba9e6e4ad06", "target": 0, "func": "static int alloc_refcount_block(BlockDriverState *bs,\n\n                                int64_t cluster_index, void **refcount_block)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    unsigned int refcount_table_index;\n\n    int ret;\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC);\n\n\n\n    /* Find the refcount block for the given cluster */\n\n    refcount_table_index = cluster_index >> s->refcount_block_bits;\n\n\n\n    if (refcount_table_index < s->refcount_table_size) {\n\n\n\n        uint64_t refcount_block_offset =\n\n            s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;\n\n\n\n        /* If it's already there, we're done */\n\n        if (refcount_block_offset) {\n\n            if (offset_into_cluster(s, refcount_block_offset)) {\n\n                qcow2_signal_corruption(bs, true, -1, -1, \"Refblock offset %#\"\n\n                                        PRIx64 \" unaligned (reftable index: \"\n\n                                        \"%#x)\", refcount_block_offset,\n\n                                        refcount_table_index);\n\n                return -EIO;\n\n            }\n\n\n\n             return load_refcount_block(bs, refcount_block_offset,\n\n                                        refcount_block);\n\n        }\n\n    }\n\n\n\n    /*\n\n     * If we came here, we need to allocate something. Something is at least\n\n     * a cluster for the new refcount block. It may also include a new refcount\n\n     * table if the old refcount table is too small.\n\n     *\n\n     * Note that allocating clusters here needs some special care:\n\n     *\n\n     * - We can't use the normal qcow2_alloc_clusters(), it would try to\n\n     *   increase the refcount and very likely we would end up with an endless\n\n     *   recursion. Instead we must place the refcount blocks in a way that\n\n     *   they can describe them themselves.\n\n     *\n\n     * - We need to consider that at this point we are inside update_refcounts\n\n     *   and potentially doing an initial refcount increase. This means that\n\n     *   some clusters have already been allocated by the caller, but their\n\n     *   refcount isn't accurate yet. If we allocate clusters for metadata, we\n\n     *   need to return -EAGAIN to signal the caller that it needs to restart\n\n     *   the search for free clusters.\n\n     *\n\n     * - alloc_clusters_noref and qcow2_free_clusters may load a different\n\n     *   refcount block into the cache\n\n     */\n\n\n\n    *refcount_block = NULL;\n\n\n\n    /* We write to the refcount table, so we might depend on L2 tables */\n\n    ret = qcow2_cache_flush(bs, s->l2_table_cache);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* Allocate the refcount block itself and mark it as used */\n\n    int64_t new_block = alloc_clusters_noref(bs, s->cluster_size);\n\n    if (new_block < 0) {\n\n        return new_block;\n\n    }\n\n\n\n#ifdef DEBUG_ALLOC2\n\n    fprintf(stderr, \"qcow2: Allocate refcount block %d for %\" PRIx64\n\n        \" at %\" PRIx64 \"\\n\",\n\n        refcount_table_index, cluster_index << s->cluster_bits, new_block);\n\n#endif\n\n\n\n    if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) {\n\n        /* Zero the new refcount block before updating it */\n\n        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,\n\n                                    refcount_block);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        memset(*refcount_block, 0, s->cluster_size);\n\n\n\n        /* The block describes itself, need to update the cache */\n\n        int block_index = (new_block >> s->cluster_bits) &\n\n            (s->refcount_block_size - 1);\n\n        s->set_refcount(*refcount_block, block_index, 1);\n\n    } else {\n\n        /* Described somewhere else. This can recurse at most twice before we\n\n         * arrive at a block that describes itself. */\n\n        ret = update_refcount(bs, new_block, s->cluster_size, 1, false,\n\n                              QCOW2_DISCARD_NEVER);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        /* Initialize the new refcount block only after updating its refcount,\n\n         * update_refcount uses the refcount cache itself */\n\n        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,\n\n                                    refcount_block);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        memset(*refcount_block, 0, s->cluster_size);\n\n    }\n\n\n\n    /* Now the new refcount block needs to be written to disk */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE);\n\n    qcow2_cache_entry_mark_dirty(bs, s->refcount_block_cache, *refcount_block);\n\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n\n    if (ret < 0) {\n\n        goto fail_block;\n\n    }\n\n\n\n    /* If the refcount table is big enough, just hook the block up there */\n\n    if (refcount_table_index < s->refcount_table_size) {\n\n        uint64_t data64 = cpu_to_be64(new_block);\n\n        BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP);\n\n        ret = bdrv_pwrite_sync(bs->file,\n\n            s->refcount_table_offset + refcount_table_index * sizeof(uint64_t),\n\n            &data64, sizeof(data64));\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        s->refcount_table[refcount_table_index] = new_block;\n\n\n\n        /* The new refcount block may be where the caller intended to put its\n\n         * data, so let it restart the search. */\n\n        return -EAGAIN;\n\n    }\n\n\n\n    ret = qcow2_cache_put(bs, s->refcount_block_cache, refcount_block);\n\n    if (ret < 0) {\n\n        goto fail_block;\n\n    }\n\n\n\n    /*\n\n     * If we come here, we need to grow the refcount table. Again, a new\n\n     * refcount table needs some space and we can't simply allocate to avoid\n\n     * endless recursion.\n\n     *\n\n     * Therefore let's grab new refcount blocks at the end of the image, which\n\n     * will describe themselves and the new refcount table. This way we can\n\n     * reference them only in the new table and do the switch to the new\n\n     * refcount table at once without producing an inconsistent state in\n\n     * between.\n\n     */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_GROW);\n\n\n\n    /* Calculate the number of refcount blocks needed so far; this will be the\n\n     * basis for calculating the index of the first cluster used for the\n\n     * self-describing refcount structures which we are about to create.\n\n     *\n\n     * Because we reached this point, there cannot be any refcount entries for\n\n     * cluster_index or higher indices yet. However, because new_block has been\n\n     * allocated to describe that cluster (and it will assume this role later\n\n     * on), we cannot use that index; also, new_block may actually have a higher\n\n     * cluster index than cluster_index, so it needs to be taken into account\n\n     * here (and 1 needs to be added to its value because that cluster is used).\n\n     */\n\n    uint64_t blocks_used = DIV_ROUND_UP(MAX(cluster_index + 1,\n\n                                            (new_block >> s->cluster_bits) + 1),\n\n                                        s->refcount_block_size);\n\n\n\n    if (blocks_used > QCOW_MAX_REFTABLE_SIZE / sizeof(uint64_t)) {\n\n        return -EFBIG;\n\n    }\n\n\n\n    /* And now we need at least one block more for the new metadata */\n\n    uint64_t table_size = next_refcount_table_size(s, blocks_used + 1);\n\n    uint64_t last_table_size;\n\n    uint64_t blocks_clusters;\n\n    do {\n\n        uint64_t table_clusters =\n\n            size_to_clusters(s, table_size * sizeof(uint64_t));\n\n        blocks_clusters = 1 +\n\n            ((table_clusters + s->refcount_block_size - 1)\n\n            / s->refcount_block_size);\n\n        uint64_t meta_clusters = table_clusters + blocks_clusters;\n\n\n\n        last_table_size = table_size;\n\n        table_size = next_refcount_table_size(s, blocks_used +\n\n            ((meta_clusters + s->refcount_block_size - 1)\n\n            / s->refcount_block_size));\n\n\n\n    } while (last_table_size != table_size);\n\n\n\n#ifdef DEBUG_ALLOC2\n\n    fprintf(stderr, \"qcow2: Grow refcount table %\" PRId32 \" => %\" PRId64 \"\\n\",\n\n        s->refcount_table_size, table_size);\n\n#endif\n\n\n\n    /* Create the new refcount table and blocks */\n\n    uint64_t meta_offset = (blocks_used * s->refcount_block_size) *\n\n        s->cluster_size;\n\n    uint64_t table_offset = meta_offset + blocks_clusters * s->cluster_size;\n\n    uint64_t *new_table = g_try_new0(uint64_t, table_size);\n\n    void *new_blocks = g_try_malloc0(blocks_clusters * s->cluster_size);\n\n\n\n    assert(table_size > 0 && blocks_clusters > 0);\n\n    if (new_table == NULL || new_blocks == NULL) {\n\n        ret = -ENOMEM;\n\n        goto fail_table;\n\n    }\n\n\n\n    /* Fill the new refcount table */\n\n    memcpy(new_table, s->refcount_table,\n\n        s->refcount_table_size * sizeof(uint64_t));\n\n    new_table[refcount_table_index] = new_block;\n\n\n\n    int i;\n\n    for (i = 0; i < blocks_clusters; i++) {\n\n        new_table[blocks_used + i] = meta_offset + (i * s->cluster_size);\n\n    }\n\n\n\n    /* Fill the refcount blocks */\n\n    uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t));\n\n    int block = 0;\n\n    for (i = 0; i < table_clusters + blocks_clusters; i++) {\n\n        s->set_refcount(new_blocks, block++, 1);\n\n    }\n\n\n\n    /* Write refcount blocks to disk */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS);\n\n    ret = bdrv_pwrite_sync(bs->file, meta_offset, new_blocks,\n\n        blocks_clusters * s->cluster_size);\n\n    g_free(new_blocks);\n\n    new_blocks = NULL;\n\n    if (ret < 0) {\n\n        goto fail_table;\n\n    }\n\n\n\n    /* Write refcount table to disk */\n\n    for(i = 0; i < table_size; i++) {\n\n        cpu_to_be64s(&new_table[i]);\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE);\n\n    ret = bdrv_pwrite_sync(bs->file, table_offset, new_table,\n\n        table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        goto fail_table;\n\n    }\n\n\n\n    for(i = 0; i < table_size; i++) {\n\n        be64_to_cpus(&new_table[i]);\n\n    }\n\n\n\n    /* Hook up the new refcount table in the qcow2 header */\n\n    uint8_t data[12];\n\n    cpu_to_be64w((uint64_t*)data, table_offset);\n\n    cpu_to_be32w((uint32_t*)(data + 8), table_clusters);\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE);\n\n    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset),\n\n        data, sizeof(data));\n\n    if (ret < 0) {\n\n        goto fail_table;\n\n    }\n\n\n\n    /* And switch it in memory */\n\n    uint64_t old_table_offset = s->refcount_table_offset;\n\n    uint64_t old_table_size = s->refcount_table_size;\n\n\n\n    g_free(s->refcount_table);\n\n    s->refcount_table = new_table;\n\n    s->refcount_table_size = table_size;\n\n    s->refcount_table_offset = table_offset;\n\n\n\n    /* Free old table. */\n\n    qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t),\n\n                        QCOW2_DISCARD_OTHER);\n\n\n\n    ret = load_refcount_block(bs, new_block, refcount_block);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* If we were trying to do the initial refcount update for some cluster\n\n     * allocation, we might have used the same clusters to store newly\n\n     * allocated metadata. Make the caller search some new space. */\n\n    return -EAGAIN;\n\n\n\nfail_table:\n\n    g_free(new_blocks);\n\n    g_free(new_table);\n\nfail_block:\n\n    if (*refcount_block != NULL) {\n\n        qcow2_cache_put(bs, s->refcount_block_cache, refcount_block);\n\n    }\n\n    return ret;\n\n}\n", "idx": 26026}
{"project": "qemu", "commit_id": "9eeb8306d56e8fd831bbbac6e3cfe69a40312a33", "target": 0, "func": "abi_long do_sigaltstack(abi_ulong uss_addr, abi_ulong uoss_addr, abi_ulong sp)\n\n{\n\n    int ret;\n\n    struct target_sigaltstack oss;\n\n\n\n    /* XXX: test errors */\n\n    if(uoss_addr)\n\n    {\n\n        __put_user(target_sigaltstack_used.ss_sp, &oss.ss_sp);\n\n        __put_user(target_sigaltstack_used.ss_size, &oss.ss_size);\n\n        __put_user(sas_ss_flags(sp), &oss.ss_flags);\n\n    }\n\n\n\n    if(uss_addr)\n\n    {\n\n        struct target_sigaltstack *uss;\n\n        struct target_sigaltstack ss;\n\n\n\n\tret = -TARGET_EFAULT;\n\n        if (!lock_user_struct(VERIFY_READ, uss, uss_addr, 1)\n\n\t    || __get_user(ss.ss_sp, &uss->ss_sp)\n\n\t    || __get_user(ss.ss_size, &uss->ss_size)\n\n\t    || __get_user(ss.ss_flags, &uss->ss_flags))\n\n            goto out;\n\n        unlock_user_struct(uss, uss_addr, 0);\n\n\n\n\tret = -TARGET_EPERM;\n\n\tif (on_sig_stack(sp))\n\n            goto out;\n\n\n\n\tret = -TARGET_EINVAL;\n\n\tif (ss.ss_flags != TARGET_SS_DISABLE\n\n            && ss.ss_flags != TARGET_SS_ONSTACK\n\n            && ss.ss_flags != 0)\n\n            goto out;\n\n\n\n\tif (ss.ss_flags == TARGET_SS_DISABLE) {\n\n            ss.ss_size = 0;\n\n            ss.ss_sp = 0;\n\n\t} else {\n\n            ret = -TARGET_ENOMEM;\n\n            if (ss.ss_size < MINSIGSTKSZ)\n\n                goto out;\n\n\t}\n\n\n\n        target_sigaltstack_used.ss_sp = ss.ss_sp;\n\n        target_sigaltstack_used.ss_size = ss.ss_size;\n\n    }\n\n\n\n    if (uoss_addr) {\n\n        ret = -TARGET_EFAULT;\n\n        if (copy_to_user(uoss_addr, &oss, sizeof(oss)))\n\n            goto out;\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    return ret;\n\n}\n", "idx": 26027}
{"project": "qemu", "commit_id": "57b6bdf37c64985cf02b8737c550d52759059c9d", "target": 1, "func": "static void external_snapshot_prepare(BlkTransactionState *common,\n\n                                      Error **errp)\n\n{\n\n    BlockDriver *drv;\n\n    int flags, ret;\n\n    QDict *options = NULL;\n\n    Error *local_err = NULL;\n\n    bool has_device = false;\n\n    const char *device;\n\n    bool has_node_name = false;\n\n    const char *node_name;\n\n    bool has_snapshot_node_name = false;\n\n    const char *snapshot_node_name;\n\n    const char *new_image_file;\n\n    const char *format = \"qcow2\";\n\n    enum NewImageMode mode = NEW_IMAGE_MODE_ABSOLUTE_PATHS;\n\n    ExternalSnapshotState *state =\n\n                             DO_UPCAST(ExternalSnapshotState, common, common);\n\n    TransactionAction *action = common->action;\n\n\n\n    /* get parameters */\n\n    g_assert(action->kind == TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT_SYNC);\n\n\n\n    has_device = action->blockdev_snapshot_sync->has_device;\n\n    device = action->blockdev_snapshot_sync->device;\n\n    has_node_name = action->blockdev_snapshot_sync->has_node_name;\n\n    node_name = action->blockdev_snapshot_sync->node_name;\n\n    has_snapshot_node_name =\n\n        action->blockdev_snapshot_sync->has_snapshot_node_name;\n\n    snapshot_node_name = action->blockdev_snapshot_sync->snapshot_node_name;\n\n\n\n    new_image_file = action->blockdev_snapshot_sync->snapshot_file;\n\n    if (action->blockdev_snapshot_sync->has_format) {\n\n        format = action->blockdev_snapshot_sync->format;\n\n    }\n\n    if (action->blockdev_snapshot_sync->has_mode) {\n\n        mode = action->blockdev_snapshot_sync->mode;\n\n    }\n\n\n\n    /* start processing */\n\n    drv = bdrv_find_format(format);\n\n    if (!drv) {\n\n        error_set(errp, QERR_INVALID_BLOCK_FORMAT, format);\n\n        return;\n\n    }\n\n\n\n    state->old_bs = bdrv_lookup_bs(has_device ? device : NULL,\n\n                                   has_node_name ? node_name : NULL,\n\n                                   &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    if (has_node_name && !has_snapshot_node_name) {\n\n        error_setg(errp, \"New snapshot node name missing\");\n\n        return;\n\n    }\n\n\n\n    if (has_snapshot_node_name && bdrv_find_node(snapshot_node_name)) {\n\n        error_setg(errp, \"New snapshot node name already existing\");\n\n        return;\n\n    }\n\n\n\n    if (!bdrv_is_inserted(state->old_bs)) {\n\n        error_set(errp, QERR_DEVICE_HAS_NO_MEDIUM, device);\n\n        return;\n\n    }\n\n\n\n    if (bdrv_in_use(state->old_bs)) {\n\n        error_set(errp, QERR_DEVICE_IN_USE, device);\n\n        return;\n\n    }\n\n\n\n    if (!bdrv_is_read_only(state->old_bs)) {\n\n        if (bdrv_flush(state->old_bs)) {\n\n            error_set(errp, QERR_IO_ERROR);\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (!bdrv_is_first_non_filter(state->old_bs)) {\n\n        error_set(errp, QERR_FEATURE_DISABLED, \"snapshot\");\n\n        return;\n\n    }\n\n\n\n    flags = state->old_bs->open_flags;\n\n\n\n    /* create new image w/backing file */\n\n    if (mode != NEW_IMAGE_MODE_EXISTING) {\n\n        bdrv_img_create(new_image_file, format,\n\n                        state->old_bs->filename,\n\n                        state->old_bs->drv->format_name,\n\n                        NULL, -1, flags, &local_err, false);\n\n        if (error_is_set(&local_err)) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (has_snapshot_node_name) {\n\n        options = qdict_new();\n\n        qdict_put(options, \"node-name\",\n\n                  qstring_from_str(snapshot_node_name));\n\n    }\n\n\n\n    /* We will manually add the backing_hd field to the bs later */\n\n    state->new_bs = bdrv_new(\"\");\n\n    /* TODO Inherit bs->options or only take explicit options with an\n\n     * extended QMP command? */\n\n    ret = bdrv_open(state->new_bs, new_image_file, options,\n\n                    flags | BDRV_O_NO_BACKING, drv, &local_err);\n\n    if (ret != 0) {\n\n        error_propagate(errp, local_err);\n\n    }\n\n\n\n    QDECREF(options);\n\n}\n", "idx": 26029}
{"project": "qemu", "commit_id": "51cc2e783af5586b2e742ce9e5b2762dc50ad325", "target": 1, "func": "static void mmu_init (CPUMIPSState *env, const mips_def_t *def)\n\n{\n\n    env->tlb = qemu_mallocz(sizeof(CPUMIPSTLBContext));\n\n\n\n    switch (def->mmu_type) {\n\n        case MMU_TYPE_NONE:\n\n            no_mmu_init(env, def);\n\n            break;\n\n        case MMU_TYPE_R4000:\n\n            r4k_mmu_init(env, def);\n\n            break;\n\n        case MMU_TYPE_FMT:\n\n            fixed_mmu_init(env, def);\n\n            break;\n\n        case MMU_TYPE_R3000:\n\n        case MMU_TYPE_R6000:\n\n        case MMU_TYPE_R8000:\n\n        default:\n\n            cpu_abort(env, \"MMU type not supported\\n\");\n\n    }\n\n    env->CP0_Random = env->tlb->nb_tlb - 1;\n\n    env->tlb->tlb_in_use = env->tlb->nb_tlb;\n\n}\n", "idx": 26035}
{"project": "qemu", "commit_id": "45ed0be146b7433d1123f09eb1a984210a311625", "target": 1, "func": "static void gen_spr_power8_tce_address_control(CPUPPCState *env)\n\n{\n\n    spr_register(env, SPR_TAR, \"TAR\",\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n}\n", "idx": 26039}
{"project": "qemu", "commit_id": "265ca29a7162a9437efabdb3b133237eef49ab7b", "target": 1, "func": "int load_uboot(const char *filename, target_ulong *ep, int *is_linux)\n\n{\n\n\n\n    int fd;\n\n    int size;\n\n    uboot_image_header_t h;\n\n    uboot_image_header_t *hdr = &h;\n\n    uint8_t *data = NULL;\n\n\n\n    fd = open(filename, O_RDONLY | O_BINARY);\n\n    if (fd < 0)\n\n        return -1;\n\n\n\n    size = read(fd, hdr, sizeof(uboot_image_header_t));\n\n    if (size < 0)\n\n        goto fail;\n\n\n\n    bswap_uboot_header(hdr);\n\n\n\n    if (hdr->ih_magic != IH_MAGIC)\n\n        goto fail;\n\n\n\n    /* TODO: Implement Multi-File images.  */\n\n    if (hdr->ih_type == IH_TYPE_MULTI) {\n\n        fprintf(stderr, \"Unable to load multi-file u-boot images\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    /* TODO: Implement compressed images.  */\n\n    if (hdr->ih_comp != IH_COMP_NONE) {\n\n        fprintf(stderr, \"Unable to load compressed u-boot images\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    /* TODO: Check CPU type.  */\n\n    if (is_linux) {\n\n        if (hdr->ih_type == IH_TYPE_KERNEL && hdr->ih_os == IH_OS_LINUX)\n\n            *is_linux = 1;\n\n        else\n\n            *is_linux = 0;\n\n    }\n\n\n\n    *ep = hdr->ih_ep;\n\n    data = qemu_malloc(hdr->ih_size);\n\n    if (!data)\n\n        goto fail;\n\n\n\n    if (read(fd, data, hdr->ih_size) != hdr->ih_size) {\n\n        fprintf(stderr, \"Error reading file\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    cpu_physical_memory_write_rom(hdr->ih_load, data, hdr->ih_size);\n\n\n\n    return hdr->ih_size;\n\n\n\nfail:\n\n    if (data)\n\n        qemu_free(data);\n\n    close(fd);\n\n    return -1;\n\n}\n", "idx": 26041}
{"project": "qemu", "commit_id": "25408c09502be036e5575754fe54019ed4ed5dfa", "target": 1, "func": "static int64_t alloc_refcount_block(BlockDriverState *bs, int64_t cluster_index)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    unsigned int refcount_table_index;\n\n    int ret;\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC);\n\n\n\n    /* Find the refcount block for the given cluster */\n\n    refcount_table_index = cluster_index >> (s->cluster_bits - REFCOUNT_SHIFT);\n\n\n\n    if (refcount_table_index < s->refcount_table_size) {\n\n\n\n        uint64_t refcount_block_offset =\n\n            s->refcount_table[refcount_table_index];\n\n\n\n        /* If it's already there, we're done */\n\n        if (refcount_block_offset) {\n\n            if (refcount_block_offset != s->refcount_block_cache_offset) {\n\n                ret = load_refcount_block(bs, refcount_block_offset);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n            }\n\n            return refcount_block_offset;\n\n        }\n\n    }\n\n\n\n    /*\n\n     * If we came here, we need to allocate something. Something is at least\n\n     * a cluster for the new refcount block. It may also include a new refcount\n\n     * table if the old refcount table is too small.\n\n     *\n\n     * Note that allocating clusters here needs some special care:\n\n     *\n\n     * - We can't use the normal qcow2_alloc_clusters(), it would try to\n\n     *   increase the refcount and very likely we would end up with an endless\n\n     *   recursion. Instead we must place the refcount blocks in a way that\n\n     *   they can describe them themselves.\n\n     *\n\n     * - We need to consider that at this point we are inside update_refcounts\n\n     *   and doing the initial refcount increase. This means that some clusters\n\n     *   have already been allocated by the caller, but their refcount isn't\n\n     *   accurate yet. free_cluster_index tells us where this allocation ends\n\n     *   as long as we don't overwrite it by freeing clusters.\n\n     *\n\n     * - alloc_clusters_noref and qcow2_free_clusters may load a different\n\n     *   refcount block into the cache\n\n     */\n\n\n\n    if (cache_refcount_updates) {\n\n        ret = write_refcount_block(bs);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* Allocate the refcount block itself and mark it as used */\n\n    uint64_t new_block = alloc_clusters_noref(bs, s->cluster_size);\n\n    memset(s->refcount_block_cache, 0, s->cluster_size);\n\n    s->refcount_block_cache_offset = new_block;\n\n\n\n#ifdef DEBUG_ALLOC2\n\n    fprintf(stderr, \"qcow2: Allocate refcount block %d for %\" PRIx64\n\n        \" at %\" PRIx64 \"\\n\",\n\n        refcount_table_index, cluster_index << s->cluster_bits, new_block);\n\n#endif\n\n\n\n    if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) {\n\n        /* The block describes itself, need to update the cache */\n\n        int block_index = (new_block >> s->cluster_bits) &\n\n            ((1 << (s->cluster_bits - REFCOUNT_SHIFT)) - 1);\n\n        s->refcount_block_cache[block_index] = cpu_to_be16(1);\n\n    } else {\n\n        /* Described somewhere else. This can recurse at most twice before we\n\n         * arrive at a block that describes itself. */\n\n        ret = update_refcount(bs, new_block, s->cluster_size, 1);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n    }\n\n\n\n    /* Now the new refcount block needs to be written to disk */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE);\n\n    ret = bdrv_pwrite(bs->file, new_block, s->refcount_block_cache,\n\n        s->cluster_size);\n\n    if (ret < 0) {\n\n        goto fail_block;\n\n    }\n\n\n\n    /* If the refcount table is big enough, just hook the block up there */\n\n    if (refcount_table_index < s->refcount_table_size) {\n\n        uint64_t data64 = cpu_to_be64(new_block);\n\n        BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP);\n\n        ret = bdrv_pwrite(bs->file,\n\n            s->refcount_table_offset + refcount_table_index * sizeof(uint64_t),\n\n            &data64, sizeof(data64));\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        s->refcount_table[refcount_table_index] = new_block;\n\n        return new_block;\n\n    }\n\n\n\n    /*\n\n     * If we come here, we need to grow the refcount table. Again, a new\n\n     * refcount table needs some space and we can't simply allocate to avoid\n\n     * endless recursion.\n\n     *\n\n     * Therefore let's grab new refcount blocks at the end of the image, which\n\n     * will describe themselves and the new refcount table. This way we can\n\n     * reference them only in the new table and do the switch to the new\n\n     * refcount table at once without producing an inconsistent state in\n\n     * between.\n\n     */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_GROW);\n\n\n\n    /* Calculate the number of refcount blocks needed so far */\n\n    uint64_t refcount_block_clusters = 1 << (s->cluster_bits - REFCOUNT_SHIFT);\n\n    uint64_t blocks_used = (s->free_cluster_index +\n\n        refcount_block_clusters - 1) / refcount_block_clusters;\n\n\n\n    /* And now we need at least one block more for the new metadata */\n\n    uint64_t table_size = next_refcount_table_size(s, blocks_used + 1);\n\n    uint64_t last_table_size;\n\n    uint64_t blocks_clusters;\n\n    do {\n\n        uint64_t table_clusters = size_to_clusters(s, table_size);\n\n        blocks_clusters = 1 +\n\n            ((table_clusters + refcount_block_clusters - 1)\n\n            / refcount_block_clusters);\n\n        uint64_t meta_clusters = table_clusters + blocks_clusters;\n\n\n\n        last_table_size = table_size;\n\n        table_size = next_refcount_table_size(s, blocks_used +\n\n            ((meta_clusters + refcount_block_clusters - 1)\n\n            / refcount_block_clusters));\n\n\n\n    } while (last_table_size != table_size);\n\n\n\n#ifdef DEBUG_ALLOC2\n\n    fprintf(stderr, \"qcow2: Grow refcount table %\" PRId32 \" => %\" PRId64 \"\\n\",\n\n        s->refcount_table_size, table_size);\n\n#endif\n\n\n\n    /* Create the new refcount table and blocks */\n\n    uint64_t meta_offset = (blocks_used * refcount_block_clusters) *\n\n        s->cluster_size;\n\n    uint64_t table_offset = meta_offset + blocks_clusters * s->cluster_size;\n\n    uint16_t *new_blocks = qemu_mallocz(blocks_clusters * s->cluster_size);\n\n    uint64_t *new_table = qemu_mallocz(table_size * sizeof(uint64_t));\n\n\n\n    assert(meta_offset >= (s->free_cluster_index * s->cluster_size));\n\n\n\n    /* Fill the new refcount table */\n\n    memcpy(new_table, s->refcount_table,\n\n        s->refcount_table_size * sizeof(uint64_t));\n\n    new_table[refcount_table_index] = new_block;\n\n\n\n    int i;\n\n    for (i = 0; i < blocks_clusters; i++) {\n\n        new_table[blocks_used + i] = meta_offset + (i * s->cluster_size);\n\n    }\n\n\n\n    /* Fill the refcount blocks */\n\n    uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t));\n\n    int block = 0;\n\n    for (i = 0; i < table_clusters + blocks_clusters; i++) {\n\n        new_blocks[block++] = cpu_to_be16(1);\n\n    }\n\n\n\n    /* Write refcount blocks to disk */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS);\n\n    ret = bdrv_pwrite(bs->file, meta_offset, new_blocks,\n\n        blocks_clusters * s->cluster_size);\n\n    qemu_free(new_blocks);\n\n    if (ret < 0) {\n\n        goto fail_table;\n\n    }\n\n\n\n    /* Write refcount table to disk */\n\n    for(i = 0; i < table_size; i++) {\n\n        cpu_to_be64s(&new_table[i]);\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE);\n\n    ret = bdrv_pwrite(bs->file, table_offset, new_table,\n\n        table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        goto fail_table;\n\n    }\n\n\n\n    for(i = 0; i < table_size; i++) {\n\n        cpu_to_be64s(&new_table[i]);\n\n    }\n\n\n\n    /* Hook up the new refcount table in the qcow2 header */\n\n    uint8_t data[12];\n\n    cpu_to_be64w((uint64_t*)data, table_offset);\n\n    cpu_to_be32w((uint32_t*)(data + 8), table_clusters);\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE);\n\n    ret = bdrv_pwrite(bs->file, offsetof(QCowHeader, refcount_table_offset),\n\n        data, sizeof(data));\n\n    if (ret < 0) {\n\n        goto fail_table;\n\n    }\n\n\n\n    /* And switch it in memory */\n\n    uint64_t old_table_offset = s->refcount_table_offset;\n\n    uint64_t old_table_size = s->refcount_table_size;\n\n\n\n    qemu_free(s->refcount_table);\n\n    s->refcount_table = new_table;\n\n    s->refcount_table_size = table_size;\n\n    s->refcount_table_offset = table_offset;\n\n\n\n    /* Free old table. Remember, we must not change free_cluster_index */\n\n    uint64_t old_free_cluster_index = s->free_cluster_index;\n\n    qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t));\n\n    s->free_cluster_index = old_free_cluster_index;\n\n\n\n    ret = load_refcount_block(bs, new_block);\n\n    if (ret < 0) {\n\n        goto fail_block;\n\n    }\n\n\n\n    return new_block;\n\n\n\nfail_table:\n\n    qemu_free(new_table);\n\nfail_block:\n\n    s->refcount_block_cache_offset = 0;\n\n    return ret;\n\n}\n", "idx": 26042}
{"project": "qemu", "commit_id": "bb00021de0b5908bc2c3ca467ad9a2b0c9c36459", "target": 1, "func": "void bdrv_set_backing_hd(BlockDriverState *bs, BlockDriverState *backing_hd)\n\n{\n\n\n\n    if (bs->backing_hd) {\n\n        assert(bs->backing_blocker);\n\n        bdrv_op_unblock_all(bs->backing_hd, bs->backing_blocker);\n\n    } else if (backing_hd) {\n\n        error_setg(&bs->backing_blocker,\n\n                   \"device is used as backing hd of '%s'\",\n\n                   bdrv_get_device_name(bs));\n\n    }\n\n\n\n    bs->backing_hd = backing_hd;\n\n    if (!backing_hd) {\n\n        error_free(bs->backing_blocker);\n\n        bs->backing_blocker = NULL;\n\n        goto out;\n\n    }\n\n    bs->open_flags &= ~BDRV_O_NO_BACKING;\n\n    pstrcpy(bs->backing_file, sizeof(bs->backing_file), backing_hd->filename);\n\n    pstrcpy(bs->backing_format, sizeof(bs->backing_format),\n\n            backing_hd->drv ? backing_hd->drv->format_name : \"\");\n\n\n\n    bdrv_op_block_all(bs->backing_hd, bs->backing_blocker);\n\n    /* Otherwise we won't be able to commit due to check in bdrv_commit */\n\n    bdrv_op_unblock(bs->backing_hd, BLOCK_OP_TYPE_COMMIT,\n\n                    bs->backing_blocker);\n\nout:\n\n    bdrv_refresh_limits(bs, NULL);\n\n}\n", "idx": 26044}
{"project": "qemu", "commit_id": "a1f0cce2ac0243572ff72aa561da67fe3766a395", "target": 1, "func": "static void scsi_command_complete(void *opaque, int ret)\n\n{\n\n    SCSIGenericReq *r = (SCSIGenericReq *)opaque;\n\n    SCSIGenericState *s = DO_UPCAST(SCSIGenericState, qdev, r->req.dev);\n\n\n\n    r->req.aiocb = NULL;\n\n    s->driver_status = r->io_header.driver_status;\n\n    if (s->driver_status & SG_ERR_DRIVER_SENSE)\n\n        s->senselen = r->io_header.sb_len_wr;\n\n\n\n    if (ret != 0)\n\n        r->req.status = BUSY;\n\n    else {\n\n        if (s->driver_status & SG_ERR_DRIVER_TIMEOUT) {\n\n            r->req.status = BUSY;\n\n            BADF(\"Driver Timeout\\n\");\n\n        } else if (r->io_header.status)\n\n            r->req.status = r->io_header.status;\n\n        else if (s->driver_status & SG_ERR_DRIVER_SENSE)\n\n            r->req.status = CHECK_CONDITION;\n\n        else\n\n            r->req.status = GOOD;\n\n    }\n\n    DPRINTF(\"Command complete 0x%p tag=0x%x status=%d\\n\",\n\n            r, r->req.tag, r->req.status);\n\n\n\n    scsi_req_complete(&r->req);\n\n}\n", "idx": 26045}
{"project": "qemu", "commit_id": "7453c96b78c2b09aa72924f933bb9616e5474194", "target": 1, "func": "static int QEMU_WARN_UNUSED_RESULT update_refcount(BlockDriverState *bs,\n\n                                                   int64_t offset,\n\n                                                   int64_t length,\n\n                                                   uint64_t addend,\n\n                                                   bool decrease,\n\n                                                   enum qcow2_discard_type type)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t start, last, cluster_offset;\n\n    uint16_t *refcount_block = NULL;\n\n    int64_t old_table_index = -1;\n\n    int ret;\n\n\n\n#ifdef DEBUG_ALLOC2\n\n    fprintf(stderr, \"update_refcount: offset=%\" PRId64 \" size=%\" PRId64\n\n            \" addend=%s%\" PRIu64 \"\\n\", offset, length, decrease ? \"-\" : \"\",\n\n            addend);\n\n#endif\n\n    if (length < 0) {\n\n        return -EINVAL;\n\n    } else if (length == 0) {\n\n        return 0;\n\n    }\n\n\n\n    if (decrease) {\n\n        qcow2_cache_set_dependency(bs, s->refcount_block_cache,\n\n            s->l2_table_cache);\n\n    }\n\n\n\n    start = start_of_cluster(s, offset);\n\n    last = start_of_cluster(s, offset + length - 1);\n\n    for(cluster_offset = start; cluster_offset <= last;\n\n        cluster_offset += s->cluster_size)\n\n    {\n\n        int block_index;\n\n        uint64_t refcount;\n\n        int64_t cluster_index = cluster_offset >> s->cluster_bits;\n\n        int64_t table_index = cluster_index >> s->refcount_block_bits;\n\n\n\n        /* Load the refcount block and allocate it if needed */\n\n        if (table_index != old_table_index) {\n\n            if (refcount_block) {\n\n                ret = qcow2_cache_put(bs, s->refcount_block_cache,\n\n                    (void**) &refcount_block);\n\n                if (ret < 0) {\n\n                    goto fail;\n\n                }\n\n            }\n\n\n\n            ret = alloc_refcount_block(bs, cluster_index, &refcount_block);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n        }\n\n        old_table_index = table_index;\n\n\n\n        qcow2_cache_entry_mark_dirty(s->refcount_block_cache, refcount_block);\n\n\n\n        /* we can update the count and save it */\n\n        block_index = cluster_index & (s->refcount_block_size - 1);\n\n\n\n        refcount = be16_to_cpu(refcount_block[block_index]);\n\n        if (decrease ? (refcount - addend > refcount)\n\n                     : (refcount + addend < refcount ||\n\n                        refcount + addend > s->refcount_max))\n\n        {\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n        if (decrease) {\n\n            refcount -= addend;\n\n        } else {\n\n            refcount += addend;\n\n        }\n\n        if (refcount == 0 && cluster_index < s->free_cluster_index) {\n\n            s->free_cluster_index = cluster_index;\n\n        }\n\n        refcount_block[block_index] = cpu_to_be16(refcount);\n\n\n\n        if (refcount == 0 && s->discard_passthrough[type]) {\n\n            update_refcount_discard(bs, cluster_offset, s->cluster_size);\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\nfail:\n\n    if (!s->cache_discards) {\n\n        qcow2_process_discards(bs, ret);\n\n    }\n\n\n\n    /* Write last changed block to disk */\n\n    if (refcount_block) {\n\n        int wret;\n\n        wret = qcow2_cache_put(bs, s->refcount_block_cache,\n\n            (void**) &refcount_block);\n\n        if (wret < 0) {\n\n            return ret < 0 ? ret : wret;\n\n        }\n\n    }\n\n\n\n    /*\n\n     * Try do undo any updates if an error is returned (This may succeed in\n\n     * some cases like ENOSPC for allocating a new refcount block)\n\n     */\n\n    if (ret < 0) {\n\n        int dummy;\n\n        dummy = update_refcount(bs, offset, cluster_offset - offset, addend,\n\n                                !decrease, QCOW2_DISCARD_NEVER);\n\n        (void)dummy;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 26046}
{"project": "qemu", "commit_id": "a1abf40d6be2fc4b40d90ae3b46442f4a671776b", "target": 1, "func": "void laio_cleanup(void *s_)\n{\n    struct qemu_laio_state *s = s_;\n    event_notifier_cleanup(&s->e);\n    g_free(s);", "idx": 26049}
{"project": "qemu", "commit_id": "07fb61760cdea7c3f1b9c897513986945bca8e89", "target": 1, "func": "static void pc_compat_2_0(MachineState *machine)\n\n{\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    smbios_legacy_mode = true;\n\n    has_reserved_memory = false;\n\n}", "idx": 26050}
{"project": "qemu", "commit_id": "71200fb9664c2967a1cdd22b68b0da3a8b2b3eb7", "target": 1, "func": "static CharDriverState *qemu_chr_open_msmouse(const char *id,\n\n                                              ChardevBackend *backend,\n\n                                              ChardevReturn *ret,\n\n                                              Error **errp)\n\n{\n\n    ChardevCommon *common = backend->u.msmouse.data;\n\n    MouseState *mouse;\n\n    CharDriverState *chr;\n\n\n\n    chr = qemu_chr_alloc(common, errp);\n\n\n\n\n    chr->chr_write = msmouse_chr_write;\n\n    chr->chr_close = msmouse_chr_close;\n\n    chr->chr_accept_input = msmouse_chr_accept_input;\n\n    chr->explicit_be_open = true;\n\n\n\n    mouse = g_new0(MouseState, 1);\n\n    mouse->hs = qemu_input_handler_register((DeviceState *)mouse,\n\n                                            &msmouse_handler);\n\n\n\n    mouse->chr = chr;\n\n    chr->opaque = mouse;\n\n\n\n    return chr;\n", "idx": 26051}
{"project": "qemu", "commit_id": "3c85e74fbf9e5a39d8d13ef91a5f3dd91f0bc8a8", "target": 1, "func": "int kvm_arch_on_sigbus_vcpu(CPUState *env, int code, void *addr)\n\n{\n\n#ifdef KVM_CAP_MCE\n\n    ram_addr_t ram_addr;\n\n    target_phys_addr_t paddr;\n\n\n\n    if ((env->mcg_cap & MCG_SER_P) && addr\n\n        && (code == BUS_MCEERR_AR || code == BUS_MCEERR_AO)) {\n\n        if (qemu_ram_addr_from_host(addr, &ram_addr) ||\n\n            !kvm_physical_memory_addr_from_ram(env->kvm_state, ram_addr,\n\n                                               &paddr)) {\n\n            fprintf(stderr, \"Hardware memory error for memory used by \"\n\n                    \"QEMU itself instead of guest system!\\n\");\n\n            /* Hope we are lucky for AO MCE */\n\n            if (code == BUS_MCEERR_AO) {\n\n                return 0;\n\n            } else {\n\n                hardware_memory_error();\n\n            }\n\n        }\n\n\n        kvm_mce_inject(env, paddr, code);\n\n    } else\n\n#endif /* KVM_CAP_MCE */\n\n    {\n\n        if (code == BUS_MCEERR_AO) {\n\n            return 0;\n\n        } else if (code == BUS_MCEERR_AR) {\n\n            hardware_memory_error();\n\n        } else {\n\n            return 1;\n\n        }\n\n    }\n\n    return 0;\n\n}", "idx": 26052}
{"project": "qemu", "commit_id": "08546bcfb260c28141e27cf3367c443528602fc0", "target": 0, "func": "static void qcow2_cache_table_release(BlockDriverState *bs, Qcow2Cache *c,\n\n                                      int i, int num_tables)\n\n{\n\n/* Using MADV_DONTNEED to discard memory is a Linux-specific feature */\n\n#ifdef CONFIG_LINUX\n\n    BDRVQcow2State *s = bs->opaque;\n\n    void *t = qcow2_cache_get_table_addr(bs, c, i);\n\n    int align = getpagesize();\n\n    size_t mem_size = (size_t) s->cluster_size * num_tables;\n\n    size_t offset = QEMU_ALIGN_UP((uintptr_t) t, align) - (uintptr_t) t;\n\n    size_t length = QEMU_ALIGN_DOWN(mem_size - offset, align);\n\n    if (length > 0) {\n\n        madvise((uint8_t *) t + offset, length, MADV_DONTNEED);\n\n    }\n\n#endif\n\n}\n", "idx": 26056}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "static void qpi_init(void)\n\n{\n\n    kqemu_comm_base = 0xff000000 | 1;\n\n    qpi_io_memory = cpu_register_io_memory(\n\n                                           qpi_mem_read, \n\n                                           qpi_mem_write, NULL);\n\n    cpu_register_physical_memory(kqemu_comm_base & ~0xfff, \n\n                                 0x1000, qpi_io_memory);\n\n}\n", "idx": 26057}
{"project": "qemu", "commit_id": "7bccf57383cca60a778d5c543ac80c9f62d89ef2", "target": 0, "func": "tight_detect_smooth_image(VncState *vs, int w, int h)\n\n{\n\n    uint errors;\n\n    int compression = vs->tight.compression;\n\n    int quality = vs->tight.quality;\n\n\n\n    if (!vs->vd->lossy) {\n\n        return 0;\n\n    }\n\n\n\n    if (ds_get_bytes_per_pixel(vs->ds) == 1 ||\n\n        vs->clientds.pf.bytes_per_pixel == 1 ||\n\n        w < VNC_TIGHT_DETECT_MIN_WIDTH || h < VNC_TIGHT_DETECT_MIN_HEIGHT) {\n\n        return 0;\n\n    }\n\n\n\n    if (vs->tight.quality != -1) {\n\n        if (w * h < VNC_TIGHT_JPEG_MIN_RECT_SIZE) {\n\n            return 0;\n\n        }\n\n    } else {\n\n        if (w * h < tight_conf[compression].gradient_min_rect_size) {\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    if (vs->clientds.pf.bytes_per_pixel == 4) {\n\n        if (vs->tight.pixel24) {\n\n            errors = tight_detect_smooth_image24(vs, w, h);\n\n            if (vs->tight.quality != -1) {\n\n                return (errors < tight_conf[quality].jpeg_threshold24);\n\n            }\n\n            return (errors < tight_conf[compression].gradient_threshold24);\n\n        } else {\n\n            errors = tight_detect_smooth_image32(vs, w, h);\n\n        }\n\n    } else {\n\n        errors = tight_detect_smooth_image16(vs, w, h);\n\n    }\n\n    if (quality != -1) {\n\n        return (errors < tight_conf[quality].jpeg_threshold);\n\n    }\n\n    return (errors < tight_conf[compression].gradient_threshold);\n\n}\n", "idx": 26058}
{"project": "qemu", "commit_id": "2fb50a33401a2415b71ddc291e8a77bcd2f9e547", "target": 0, "func": "static void armv7m_nvic_clear_pending(void *opaque, int irq)\n\n{\n\n    NVICState *s = (NVICState *)opaque;\n\n    VecInfo *vec;\n\n\n\n    assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);\n\n\n\n    vec = &s->vectors[irq];\n\n    trace_nvic_clear_pending(irq, vec->enabled, vec->prio);\n\n    if (vec->pending) {\n\n        vec->pending = 0;\n\n        nvic_irq_update(s);\n\n    }\n\n}\n", "idx": 26059}
{"project": "qemu", "commit_id": "363e13f86eb60bce1e112a35a4c107505a69c9fe", "target": 0, "func": "static void vararg_string(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *decoded;\n\n    } test_cases[] = {\n\n        { \"hello world\" },\n\n        { \"the quick brown fox jumped over the fence\" },\n\n        {}\n\n    };\n\n\n\n    for (i = 0; test_cases[i].decoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_jsonf(\"%s\", test_cases[i].decoded);\n\n\n\n        g_assert(obj != NULL);\n\n        g_assert(qobject_type(obj) == QTYPE_QSTRING);\n\n        \n\n        str = qobject_to_qstring(obj);\n\n        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);\n\n\n\n        QDECREF(str);\n\n    }\n\n}\n", "idx": 26061}
{"project": "qemu", "commit_id": "d0d7708ba29cbcc343364a46bff981e0ff88366f", "target": 0, "func": "static CharDriverState *qemu_chr_open_pp_fd(int fd, Error **errp)\n\n{\n\n    CharDriverState *chr;\n\n    ParallelCharDriver *drv;\n\n\n\n    if (ioctl(fd, PPCLAIM) < 0) {\n\n        error_setg_errno(errp, errno, \"not a parallel port\");\n\n        close(fd);\n\n        return NULL;\n\n    }\n\n\n\n    drv = g_new0(ParallelCharDriver, 1);\n\n    drv->fd = fd;\n\n    drv->mode = IEEE1284_MODE_COMPAT;\n\n\n\n    chr = qemu_chr_alloc();\n\n    chr->chr_write = null_chr_write;\n\n    chr->chr_ioctl = pp_ioctl;\n\n    chr->chr_close = pp_close;\n\n    chr->opaque = drv;\n\n\n\n    return chr;\n\n}\n", "idx": 26062}
{"project": "qemu", "commit_id": "13f59ae8157e8ec238fa8aefe5309909a1eeb7e2", "target": 0, "func": "static QError *qerror_from_info(const char *fmt, va_list *va)\n\n{\n\n    QError *qerr;\n\n\n\n    qerr = qerror_new();\n\n    loc_save(&qerr->loc);\n\n\n\n    qerr->error = error_obj_from_fmt_no_fail(fmt, va);\n\n    qerr->err_msg = qerror_format(fmt, qerr->error);\n\n\n\n    return qerr;\n\n}\n", "idx": 26063}
{"project": "qemu", "commit_id": "cc84de9570ffe01a9c3c169bd62ab9586a9a080c", "target": 0, "func": "static void unblock_io_signals(void)\n\n{\n\n    sigset_t set;\n\n\n\n    sigemptyset(&set);\n\n    sigaddset(&set, SIGUSR2);\n\n    sigaddset(&set, SIGIO);\n\n    sigaddset(&set, SIGALRM);\n\n    pthread_sigmask(SIG_UNBLOCK, &set, NULL);\n\n\n\n    sigemptyset(&set);\n\n    sigaddset(&set, SIGUSR1);\n\n    pthread_sigmask(SIG_BLOCK, &set, NULL);\n\n}\n", "idx": 26064}
{"project": "qemu", "commit_id": "7385aed20db5d83979f683b9d0048674411e963c", "target": 0, "func": "float32 helper_fqtos(CPUSPARCState *env)\n\n{\n\n    float32 ret;\n\n    clear_float_exceptions(env);\n\n    ret = float128_to_float32(QT1, &env->fp_status);\n\n    check_ieee_exceptions(env);\n\n    return ret;\n\n}\n", "idx": 26065}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "float32 float32_round_to_int( float32 a STATUS_PARAM)\n\n{\n\n    flag aSign;\n\n    int16 aExp;\n\n    bits32 lastBitMask, roundBitsMask;\n\n    int8 roundingMode;\n\n    float32 z;\n\n\n\n    aExp = extractFloat32Exp( a );\n\n    if ( 0x96 <= aExp ) {\n\n        if ( ( aExp == 0xFF ) && extractFloat32Frac( a ) ) {\n\n            return propagateFloat32NaN( a, a STATUS_VAR );\n\n        }\n\n        return a;\n\n    }\n\n    if ( aExp <= 0x7E ) {\n\n        if ( (bits32) ( a<<1 ) == 0 ) return a;\n\n        STATUS(float_exception_flags) |= float_flag_inexact;\n\n        aSign = extractFloat32Sign( a );\n\n        switch ( STATUS(float_rounding_mode) ) {\n\n         case float_round_nearest_even:\n\n            if ( ( aExp == 0x7E ) && extractFloat32Frac( a ) ) {\n\n                return packFloat32( aSign, 0x7F, 0 );\n\n            }\n\n            break;\n\n         case float_round_down:\n\n            return aSign ? 0xBF800000 : 0;\n\n         case float_round_up:\n\n            return aSign ? 0x80000000 : 0x3F800000;\n\n        }\n\n        return packFloat32( aSign, 0, 0 );\n\n    }\n\n    lastBitMask = 1;\n\n    lastBitMask <<= 0x96 - aExp;\n\n    roundBitsMask = lastBitMask - 1;\n\n    z = a;\n\n    roundingMode = STATUS(float_rounding_mode);\n\n    if ( roundingMode == float_round_nearest_even ) {\n\n        z += lastBitMask>>1;\n\n        if ( ( z & roundBitsMask ) == 0 ) z &= ~ lastBitMask;\n\n    }\n\n    else if ( roundingMode != float_round_to_zero ) {\n\n        if ( extractFloat32Sign( z ) ^ ( roundingMode == float_round_up ) ) {\n\n            z += roundBitsMask;\n\n        }\n\n    }\n\n    z &= ~ roundBitsMask;\n\n    if ( z != a ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n    return z;\n\n\n\n}\n", "idx": 26066}
{"project": "qemu", "commit_id": "13b9414b5798539e2dbb87a570d96184fe21edf4", "target": 0, "func": "static void do_drive_backup(DriveBackup *backup, BlockJobTxn *txn, Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *target_bs;\n\n    BlockDriverState *source = NULL;\n\n    BdrvDirtyBitmap *bmap = NULL;\n\n    AioContext *aio_context;\n\n    QDict *options = NULL;\n\n    Error *local_err = NULL;\n\n    int flags;\n\n    int64_t size;\n\n\n\n    if (!backup->has_speed) {\n\n        backup->speed = 0;\n\n    }\n\n    if (!backup->has_on_source_error) {\n\n        backup->on_source_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n    if (!backup->has_on_target_error) {\n\n        backup->on_target_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n    if (!backup->has_mode) {\n\n        backup->mode = NEW_IMAGE_MODE_ABSOLUTE_PATHS;\n\n    }\n\n    if (!backup->has_job_id) {\n\n        backup->job_id = NULL;\n\n    }\n\n\n\n    bs = qmp_get_root_bs(backup->device, errp);\n\n    if (!bs) {\n\n        return;\n\n    }\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n\n\n    if (!backup->has_format) {\n\n        backup->format = backup->mode == NEW_IMAGE_MODE_EXISTING ?\n\n                         NULL : (char*) bs->drv->format_name;\n\n    }\n\n\n\n    /* Early check to avoid creating target */\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_BACKUP_SOURCE, errp)) {\n\n        goto out;\n\n    }\n\n\n\n    flags = bs->open_flags | BDRV_O_RDWR;\n\n\n\n    /* See if we have a backing HD we can use to create our new image\n\n     * on top of. */\n\n    if (backup->sync == MIRROR_SYNC_MODE_TOP) {\n\n        source = backing_bs(bs);\n\n        if (!source) {\n\n            backup->sync = MIRROR_SYNC_MODE_FULL;\n\n        }\n\n    }\n\n    if (backup->sync == MIRROR_SYNC_MODE_NONE) {\n\n        source = bs;\n\n    }\n\n\n\n    size = bdrv_getlength(bs);\n\n    if (size < 0) {\n\n        error_setg_errno(errp, -size, \"bdrv_getlength failed\");\n\n        goto out;\n\n    }\n\n\n\n    if (backup->mode != NEW_IMAGE_MODE_EXISTING) {\n\n        assert(backup->format);\n\n        if (source) {\n\n            bdrv_img_create(backup->target, backup->format, source->filename,\n\n                            source->drv->format_name, NULL,\n\n                            size, flags, &local_err, false);\n\n        } else {\n\n            bdrv_img_create(backup->target, backup->format, NULL, NULL, NULL,\n\n                            size, flags, &local_err, false);\n\n        }\n\n    }\n\n\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto out;\n\n    }\n\n\n\n    if (backup->format) {\n\n        options = qdict_new();\n\n        qdict_put(options, \"driver\", qstring_from_str(backup->format));\n\n    }\n\n\n\n    target_bs = bdrv_open(backup->target, NULL, options, flags, errp);\n\n    if (!target_bs) {\n\n        goto out;\n\n    }\n\n\n\n    bdrv_set_aio_context(target_bs, aio_context);\n\n\n\n    if (backup->has_bitmap) {\n\n        bmap = bdrv_find_dirty_bitmap(bs, backup->bitmap);\n\n        if (!bmap) {\n\n            error_setg(errp, \"Bitmap '%s' could not be found\", backup->bitmap);\n\n            bdrv_unref(target_bs);\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    backup_start(backup->job_id, bs, target_bs, backup->speed, backup->sync,\n\n                 bmap, backup->on_source_error, backup->on_target_error,\n\n                 block_job_cb, bs, txn, &local_err);\n\n    bdrv_unref(target_bs);\n\n    if (local_err != NULL) {\n\n        error_propagate(errp, local_err);\n\n        goto out;\n\n    }\n\n\n\nout:\n\n    aio_context_release(aio_context);\n\n}\n", "idx": 26067}
{"project": "qemu", "commit_id": "d85f4222b4681da7ebf8a90b26e085a68fa2c55a", "target": 0, "func": "static int encrypt_sectors(BDRVQcowState *s, int64_t sector_num,\n\n                           uint8_t *buf, int nb_sectors, bool enc,\n\n                           Error **errp)\n\n{\n\n    union {\n\n        uint64_t ll[2];\n\n        uint8_t b[16];\n\n    } ivec;\n\n    int i;\n\n    int ret;\n\n\n\n    for(i = 0; i < nb_sectors; i++) {\n\n        ivec.ll[0] = cpu_to_le64(sector_num);\n\n        ivec.ll[1] = 0;\n\n        if (qcrypto_cipher_setiv(s->cipher,\n\n                                 ivec.b, G_N_ELEMENTS(ivec.b),\n\n                                 errp) < 0) {\n\n            return -1;\n\n        }\n\n        if (enc) {\n\n            ret = qcrypto_cipher_encrypt(s->cipher,\n\n                                         buf, buf,\n\n                                         512,\n\n                                         errp);\n\n        } else {\n\n            ret = qcrypto_cipher_decrypt(s->cipher,\n\n                                         buf, buf,\n\n                                         512,\n\n                                         errp);\n\n        }\n\n        if (ret < 0) {\n\n            return -1;\n\n        }\n\n        sector_num++;\n\n        buf += 512;\n\n    }\n\n    return 0;\n\n}\n", "idx": 26068}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "func": "static int scsi_qdev_exit(DeviceState *qdev)\n\n{\n\n    SCSIDevice *dev = SCSI_DEVICE(qdev);\n\n\n\n    if (dev->vmsentry) {\n\n        qemu_del_vm_change_state_handler(dev->vmsentry);\n\n    }\n\n    scsi_device_destroy(dev);\n\n    return 0;\n\n}\n", "idx": 26069}
{"project": "qemu", "commit_id": "a12a712a7dfbd2e2f4882ef2c90a9b2162166dd7", "target": 0, "func": "static void nbd_teardown_connection(BlockDriverState *bs)\n\n{\n\n    NBDClientSession *client = nbd_get_client_session(bs);\n\n\n\n    if (!client->ioc) { /* Already closed */\n\n        return;\n\n    }\n\n\n\n    /* finish any pending coroutines */\n\n    qio_channel_shutdown(client->ioc,\n\n                         QIO_CHANNEL_SHUTDOWN_BOTH,\n\n                         NULL);\n\n    nbd_recv_coroutines_enter_all(bs);\n\n\n\n    nbd_client_detach_aio_context(bs);\n\n    object_unref(OBJECT(client->sioc));\n\n    client->sioc = NULL;\n\n    object_unref(OBJECT(client->ioc));\n\n    client->ioc = NULL;\n\n}\n", "idx": 26070}
{"project": "qemu", "commit_id": "08844473820c93541fc47bdfeae0f2cc88cfab59", "target": 0, "func": "static int coroutine_fn bdrv_driver_pwritev(BlockDriverState *bs,\n\n                                            uint64_t offset, uint64_t bytes,\n\n                                            QEMUIOVector *qiov, int flags)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    int64_t sector_num = offset >> BDRV_SECTOR_BITS;\n\n    unsigned int nb_sectors = bytes >> BDRV_SECTOR_BITS;\n\n    int ret;\n\n\n\n    assert((offset & (BDRV_SECTOR_SIZE - 1)) == 0);\n\n    assert((bytes & (BDRV_SECTOR_SIZE - 1)) == 0);\n\n    assert((bytes >> BDRV_SECTOR_BITS) <= BDRV_REQUEST_MAX_SECTORS);\n\n\n\n    if (drv->bdrv_co_writev_flags) {\n\n        ret = drv->bdrv_co_writev_flags(bs, sector_num, nb_sectors, qiov,\n\n                                        flags);\n\n    } else {\n\n        assert(drv->supported_write_flags == 0);\n\n        ret = drv->bdrv_co_writev(bs, sector_num, nb_sectors, qiov);\n\n    }\n\n\n\n    if (ret == 0 && (flags & BDRV_REQ_FUA) &&\n\n        !(drv->supported_write_flags & BDRV_REQ_FUA))\n\n    {\n\n        ret = bdrv_co_flush(bs);\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 26072}
{"project": "qemu", "commit_id": "b3ceef24f4fee8d5ed96b8c4a5d3e80c0a651f0b", "target": 0, "func": "static void ss10_init(int ram_size, int vga_ram_size, int boot_device,\n\n                            DisplayState *ds, const char **fd_filename, int snapshot,\n\n                            const char *kernel_filename, const char *kernel_cmdline,\n\n                            const char *initrd_filename, const char *cpu_model)\n\n{\n\n    if (cpu_model == NULL)\n\n        cpu_model = \"TI SuperSparc II\";\n\n    sun4m_common_init(ram_size, boot_device, ds, kernel_filename,\n\n                      kernel_cmdline, initrd_filename, cpu_model,\n\n                      1, PROM_ADDR); // XXX prom overlap, actually first 4GB ok\n\n}\n", "idx": 26073}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t bonito_readl(void *opaque, target_phys_addr_t addr,\n\n                             unsigned size)\n\n{\n\n    PCIBonitoState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = (addr - BONITO_REGBASE) >> 2;\n\n\n\n    DPRINTF(\"bonito_readl \"TARGET_FMT_plx\"\\n\", addr);\n\n    switch (saddr) {\n\n    case BONITO_INTISR:\n\n        return s->regs[saddr];\n\n    default:\n\n        return s->regs[saddr];\n\n    }\n\n}\n", "idx": 26074}
{"project": "qemu", "commit_id": "5f8632d3c3d7bc5ef24166ba7cf90fcfb2adbf7d", "target": 1, "func": "static void pc_init_isa(MachineState *machine)\n\n{\n\n    has_pci_info = false;\n\n    has_acpi_build = false;\n\n    smbios_defaults = false;\n\n\n\n\n\n\n    if (!machine->cpu_model) {\n\n        machine->cpu_model = \"486\";\n\n    }\n\n    x86_cpu_compat_disable_kvm_features(FEAT_KVM, KVM_FEATURE_PV_EOI);\n\n    enable_compat_apic_id_mode();\n\n    pc_init1(machine, 0, 1);\n\n}", "idx": 26078}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static void slavio_misc_init(target_phys_addr_t base,\n\n                             target_phys_addr_t aux1_base,\n\n                             target_phys_addr_t aux2_base, qemu_irq irq,\n\n                             qemu_irq fdc_tc)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n\n\n    dev = qdev_create(NULL, \"slavio_misc\");\n\n    qdev_init(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    if (base) {\n\n        /* 8 bit registers */\n\n        /* Slavio control */\n\n        sysbus_mmio_map(s, 0, base + MISC_CFG);\n\n        /* Diagnostics */\n\n        sysbus_mmio_map(s, 1, base + MISC_DIAG);\n\n        /* Modem control */\n\n        sysbus_mmio_map(s, 2, base + MISC_MDM);\n\n        /* 16 bit registers */\n\n        /* ss600mp diag LEDs */\n\n        sysbus_mmio_map(s, 3, base + MISC_LEDS);\n\n        /* 32 bit registers */\n\n        /* System control */\n\n        sysbus_mmio_map(s, 4, base + MISC_SYS);\n\n    }\n\n    if (aux1_base) {\n\n        /* AUX 1 (Misc System Functions) */\n\n        sysbus_mmio_map(s, 5, aux1_base);\n\n    }\n\n    if (aux2_base) {\n\n        /* AUX 2 (Software Powerdown Control) */\n\n        sysbus_mmio_map(s, 6, aux2_base);\n\n    }\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_connect_irq(s, 1, fdc_tc);\n\n    qemu_system_powerdown = qdev_get_gpio_in(dev, 0);\n\n}\n", "idx": 26090}
{"project": "qemu", "commit_id": "6f2d8978728c48ca46f5c01835438508aace5c64", "target": 1, "func": "int mmu40x_get_physical_address (CPUState *env, mmu_ctx_t *ctx,\n\n                                 target_ulong address, int rw, int access_type)\n\n{\n\n    ppcemb_tlb_t *tlb;\n\n    target_phys_addr_t raddr;\n\n    int i, ret, zsel, zpr, pr;\n\n\n\n    ret = -1;\n\n    raddr = -1;\n\n    pr = msr_pr;\n\n    for (i = 0; i < env->nb_tlb; i++) {\n\n        tlb = &env->tlb[i].tlbe;\n\n        if (ppcemb_tlb_check(env, tlb, &raddr, address,\n\n                             env->spr[SPR_40x_PID], 0, i) < 0)\n\n            continue;\n\n        zsel = (tlb->attr >> 4) & 0xF;\n\n        zpr = (env->spr[SPR_40x_ZPR] >> (28 - (2 * zsel))) & 0x3;\n\n#if defined (DEBUG_SOFTWARE_TLB)\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"%s: TLB %d zsel %d zpr %d rw %d attr %08x\\n\",\n\n                    __func__, i, zsel, zpr, rw, tlb->attr);\n\n        }\n\n#endif\n\n        /* Check execute enable bit */\n\n        switch (zpr) {\n\n        case 0x2:\n\n            if (pr != 0)\n\n                goto check_perms;\n\n            /* No break here */\n\n        case 0x3:\n\n            /* All accesses granted */\n\n            ctx->prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n            ret = 0;\n\n            break;\n\n        case 0x0:\n\n            if (pr != 0) {\n\n                ctx->prot = 0;\n\n                ret = -2;\n\n                break;\n\n            }\n\n            /* No break here */\n\n        case 0x1:\n\n        check_perms:\n\n            /* Check from TLB entry */\n\n            /* XXX: there is a problem here or in the TLB fill code... */\n\n            ctx->prot = tlb->prot;\n\n            ctx->prot |= PAGE_EXEC;\n\n            ret = check_prot(ctx->prot, rw, access_type);\n\n            break;\n\n        }\n\n        if (ret >= 0) {\n\n            ctx->raddr = raddr;\n\n#if defined (DEBUG_SOFTWARE_TLB)\n\n            if (loglevel != 0) {\n\n                fprintf(logfile, \"%s: access granted \" ADDRX \" => \" REGX\n\n                        \" %d %d\\n\", __func__, address, ctx->raddr, ctx->prot,\n\n                        ret);\n\n            }\n\n#endif\n\n            return 0;\n\n        }\n\n    }\n\n#if defined (DEBUG_SOFTWARE_TLB)\n\n    if (loglevel != 0) {\n\n        fprintf(logfile, \"%s: access refused \" ADDRX \" => \" REGX\n\n                \" %d %d\\n\", __func__, address, raddr, ctx->prot,\n\n                ret);\n\n    }\n\n#endif\n\n\n\n    return ret;\n\n}\n", "idx": 26094}
{"project": "qemu", "commit_id": "c6d2283068026035a6468aae9dcde953bd7521ac", "target": 1, "func": "int bdrv_get_dirty(BlockDriverState *bs, int64_t sector)\n\n{\n\n    int64_t chunk = sector / (int64_t)BDRV_SECTORS_PER_DIRTY_CHUNK;\n\n\n\n    if (bs->dirty_bitmap != NULL &&\n\n        (sector << BDRV_SECTOR_BITS) <= bdrv_getlength(bs)) {\n\n        return bs->dirty_bitmap[chunk];\n\n    } else {\n\n        return 0;\n\n    }\n\n}\n", "idx": 26095}
{"project": "qemu", "commit_id": "b45c03f585ea9bb1af76c73e82195418c294919d", "target": 1, "func": "static struct omap_eac_s *omap_eac_init(struct omap_target_agent_s *ta,\n\n                qemu_irq irq, qemu_irq *drq, omap_clk fclk, omap_clk iclk)\n\n{\n\n    struct omap_eac_s *s = (struct omap_eac_s *)\n\n            g_malloc0(sizeof(struct omap_eac_s));\n\n\n\n    s->irq = irq;\n\n    s->codec.rxdrq = *drq ++;\n\n    s->codec.txdrq = *drq;\n\n    omap_eac_reset(s);\n\n\n\n    AUD_register_card(\"OMAP EAC\", &s->codec.card);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &omap_eac_ops, s, \"omap.eac\",\n\n                          omap_l4_region_size(ta, 0));\n\n    omap_l4_attach(ta, 0, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 26102}
{"project": "qemu", "commit_id": "df39076850958b842ac9e414dc3ab2895f1877bf", "target": 1, "func": "bool runstate_needs_reset(void)\n\n{\n\n    return runstate_check(RUN_STATE_INTERNAL_ERROR) ||\n\n        runstate_check(RUN_STATE_SHUTDOWN) ||\n\n        runstate_check(RUN_STATE_GUEST_PANICKED);\n\n}\n", "idx": 26103}
{"project": "qemu", "commit_id": "4a9c9ea0d318bec2f67848c5ceaf4ad5bcb91d09", "target": 1, "func": "int64_t bdrv_getlength(BlockDriverState *bs)\n\n{\n\n    int64_t ret = bdrv_nb_sectors(bs);\n\n\n\n\n    return ret < 0 ? ret : ret * BDRV_SECTOR_SIZE;\n\n}", "idx": 26104}
{"project": "qemu", "commit_id": "016d2e1dfa21b64a524d3629fdd317d4c25bc3b8", "target": 1, "func": "long do_rt_sigreturn(CPUSH4State *regs)\n\n{\n\n    struct target_rt_sigframe *frame;\n\n    abi_ulong frame_addr;\n\n    sigset_t blocked;\n\n    target_ulong r0;\n\n\n\n#if defined(DEBUG_SIGNAL)\n\n    fprintf(stderr, \"do_rt_sigreturn\\n\");\n\n#endif\n\n    frame_addr = regs->gregs[15];\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))\n\n   \tgoto badframe;\n\n\n\n    target_to_host_sigset(&blocked, &frame->uc.tuc_sigmask);\n\n    do_sigprocmask(SIG_SETMASK, &blocked, NULL);\n\n\n\n    if (restore_sigcontext(regs, &frame->uc.tuc_mcontext, &r0))\n\n        goto badframe;\n\n\n\n    if (do_sigaltstack(frame_addr +\n\n\t\t       offsetof(struct target_rt_sigframe, uc.tuc_stack),\n\n\t\t       0, get_sp_from_cpustate(regs)) == -EFAULT)\n\n        goto badframe;\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return r0;\n\n\n\nbadframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n", "idx": 26107}
{"project": "qemu", "commit_id": "7b3621f47a990c5099c6385728347f69a8d0e55c", "target": 1, "func": "static void pty_chr_close(struct CharDriverState *chr)\n\n{\n\n    PtyCharDriver *s = chr->opaque;\n\n    int fd;\n\n\n\n    remove_fd_in_watch(chr);\n\n    fd = g_io_channel_unix_get_fd(s->fd);\n\n    g_io_channel_unref(s->fd);\n\n    close(fd);\n\n    if (s->timer_tag) {\n\n        g_source_remove(s->timer_tag);\n\n        s->timer_tag = 0;\n\n    }\n\n    g_free(s);\n\n    qemu_chr_be_event(chr, CHR_EVENT_CLOSED);\n\n}\n", "idx": 26109}
{"project": "qemu", "commit_id": "871d2f079661323a7645b388eb5ae8d7eeb3117c", "target": 0, "func": "static void bdrv_put_buffer(void *opaque, const uint8_t *buf,\n\n                            int64_t pos, int size)\n\n{\n\n    QEMUFileBdrv *s = opaque;\n\n    bdrv_pwrite(s->bs, s->base_offset + pos, buf, size);\n\n}\n", "idx": 26113}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static void block_dirty_bitmap_add_abort(BlkActionState *common)\n\n{\n\n    BlockDirtyBitmapAdd *action;\n\n    BlockDirtyBitmapState *state = DO_UPCAST(BlockDirtyBitmapState,\n\n                                             common, common);\n\n\n\n    action = common->action->u.block_dirty_bitmap_add;\n\n    /* Should not be able to fail: IF the bitmap was added via .prepare(),\n\n     * then the node reference and bitmap name must have been valid.\n\n     */\n\n    if (state->prepared) {\n\n        qmp_block_dirty_bitmap_remove(action->node, action->name, &error_abort);\n\n    }\n\n}\n", "idx": 26115}
{"project": "qemu", "commit_id": "026aeffcb4752054830ba203020ed6eb05bcaba8", "target": 0, "func": "static int cirrus_bitblt_common_patterncopy(CirrusVGAState *s, bool videosrc)\n\n{\n\n    uint32_t patternsize;\n\n    uint8_t *dst;\n\n    uint8_t *src;\n\n\n\n    dst = s->vga.vram_ptr + s->cirrus_blt_dstaddr;\n\n\n\n    if (videosrc) {\n\n        switch (s->vga.get_bpp(&s->vga)) {\n\n        case 8:\n\n            patternsize = 64;\n\n            break;\n\n        case 15:\n\n        case 16:\n\n            patternsize = 128;\n\n            break;\n\n        case 24:\n\n        case 32:\n\n        default:\n\n            patternsize = 256;\n\n            break;\n\n        }\n\n        s->cirrus_blt_srcaddr &= ~(patternsize - 1);\n\n        if (s->cirrus_blt_srcaddr + patternsize > s->vga.vram_size) {\n\n            return 0;\n\n        }\n\n        src = s->vga.vram_ptr + s->cirrus_blt_srcaddr;\n\n    } else {\n\n        src = s->cirrus_bltbuf;\n\n    }\n\n\n\n    if (blit_is_unsafe(s, true)) {\n\n        return 0;\n\n    }\n\n\n\n    (*s->cirrus_rop) (s, dst, src,\n\n                      s->cirrus_blt_dstpitch, 0,\n\n                      s->cirrus_blt_width, s->cirrus_blt_height);\n\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\n                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\n                             s->cirrus_blt_height);\n\n    return 1;\n\n}\n", "idx": 26116}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void qemu_clock_init(QEMUClockType type)\n\n{\n\n    QEMUClock *clock = qemu_clock_ptr(type);\n\n\n\n    /* Assert that the clock of type TYPE has not been initialized yet. */\n\n    assert(main_loop_tlg.tl[type] == NULL);\n\n\n\n    clock->type = type;\n\n    clock->enabled = (type == QEMU_CLOCK_VIRTUAL ? false : true);\n\n    clock->last = INT64_MIN;\n\n    QLIST_INIT(&clock->timerlists);\n\n    notifier_list_init(&clock->reset_notifiers);\n\n    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);\n\n}\n", "idx": 26117}
{"project": "qemu", "commit_id": "7bb5d6ade6d8afbcad72a871f712370ffae457c6", "target": 0, "func": "static void pc_dimm_init(Object *obj)\n\n{\n\n    PCDIMMDevice *dimm = PC_DIMM(obj);\n\n\n\n    object_property_add(obj, PC_DIMM_SIZE_PROP, \"int\", pc_dimm_get_size,\n\n                        NULL, NULL, NULL, &error_abort);\n\n    object_property_add_link(obj, PC_DIMM_MEMDEV_PROP, TYPE_MEMORY_BACKEND,\n\n                             (Object **)&dimm->hostmem,\n\n                             qdev_prop_allow_set_link_before_realize,\n\n                             OBJ_PROP_LINK_UNREF_ON_RELEASE,\n\n                             &error_abort);\n\n}\n", "idx": 26118}
{"project": "qemu", "commit_id": "1a6245a5b0b4e8d822c739b403fc67c8a7bc8d12", "target": 0, "func": "static int nbd_handle_export_name(NBDClient *client, uint32_t length)\n\n{\n\n    int rc = -EINVAL, csock = client->sock;\n\n    char name[256];\n\n\n\n    /* Client sends:\n\n        [20 ..  xx]   export name (length bytes)\n\n     */\n\n    TRACE(\"Checking length\");\n\n    if (length > 255) {\n\n        LOG(\"Bad length received\");\n\n        goto fail;\n\n    }\n\n    if (read_sync(csock, name, length) != length) {\n\n        LOG(\"read failed\");\n\n        goto fail;\n\n    }\n\n    name[length] = '\\0';\n\n\n\n    client->exp = nbd_export_find(name);\n\n    if (!client->exp) {\n\n        LOG(\"export not found\");\n\n        goto fail;\n\n    }\n\n\n\n    QTAILQ_INSERT_TAIL(&client->exp->clients, client, next);\n\n    nbd_export_get(client->exp);\n\n    rc = 0;\n\nfail:\n\n    return rc;\n\n}\n", "idx": 26119}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_insn_3401(TCGContext *s, AArch64Insn insn, TCGType ext,\n\n                              TCGReg rd, TCGReg rn, uint64_t aimm)\n\n{\n\n    if (aimm > 0xfff) {\n\n        assert((aimm & 0xfff) == 0);\n\n        aimm >>= 12;\n\n        assert(aimm <= 0xfff);\n\n        aimm |= 1 << 12;  /* apply LSL 12 */\n\n    }\n\n    tcg_out32(s, insn | ext << 31 | aimm << 10 | rn << 5 | rd);\n\n}\n", "idx": 26120}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int proxy_mkdir(FsContext *fs_ctx, V9fsPath *dir_path,\n\n                       const char *name, FsCred *credp)\n\n{\n\n    int retval;\n\n    V9fsString fullname;\n\n\n\n    v9fs_string_init(&fullname);\n\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);\n\n\n\n    retval = v9fs_request(fs_ctx->private, T_MKDIR, NULL, \"sddd\", &fullname,\n\n                          credp->fc_mode, credp->fc_uid, credp->fc_gid);\n\n    v9fs_string_free(&fullname);\n\n    if (retval < 0) {\n\n        errno = -retval;\n\n        retval = -1;\n\n    }\n\n    v9fs_string_free(&fullname);\n\n    return retval;\n\n}\n", "idx": 26121}
{"project": "qemu", "commit_id": "b227a8e9aa5f27d29f77ba90d5eb9d0662a1175e", "target": 0, "func": "static always_inline int find_pte (CPUState *env, mmu_ctx_t *ctx,\n\n                                   int h, int rw)\n\n{\n\n#if defined(TARGET_PPC64)\n\n    if (env->mmu_model == POWERPC_MMU_64B)\n\n        return find_pte64(ctx, h, rw);\n\n#endif\n\n\n\n    return find_pte32(ctx, h, rw);\n\n}\n", "idx": 26122}
{"project": "qemu", "commit_id": "e33e94f92298c96e0928cefab00ea5bae0a1cd19", "target": 0, "func": "static always_inline uint64_t float_zero_divide_excp (uint64_t arg1, uint64_t arg2)\n\n{\n\n    env->fpscr |= 1 << FPSCR_ZX;\n\n    env->fpscr &= ~((1 << FPSCR_FR) | (1 << FPSCR_FI));\n\n    /* Update the floating-point exception summary */\n\n    env->fpscr |= 1 << FPSCR_FX;\n\n    if (fpscr_ze != 0) {\n\n        /* Update the floating-point enabled exception summary */\n\n        env->fpscr |= 1 << FPSCR_FEX;\n\n        if (msr_fe0 != 0 || msr_fe1 != 0) {\n\n            helper_raise_exception_err(POWERPC_EXCP_PROGRAM,\n\n                                       POWERPC_EXCP_FP | POWERPC_EXCP_FP_ZX);\n\n        }\n\n    } else {\n\n        /* Set the result to infinity */\n\n        arg1 = ((arg1 ^ arg2) & 0x8000000000000000ULL);\n\n        arg1 |= 0x7FFULL << 52;\n\n    }\n\n    return arg1;\n\n}\n", "idx": 26123}
{"project": "qemu", "commit_id": "2c62f08ddbf3fa80dc7202eb9a2ea60ae44e2cc5", "target": 0, "func": "void *s1d13745_init(qemu_irq gpio_int)\n\n{\n\n    BlizzardState *s = (BlizzardState *) g_malloc0(sizeof(*s));\n\n    DisplaySurface *surface;\n\n\n\n    s->fb = g_malloc(0x180000);\n\n\n\n    s->con = graphic_console_init(blizzard_update_display,\n\n                                  blizzard_invalidate_display,\n\n                                  blizzard_screen_dump, NULL, s);\n\n    surface = qemu_console_surface(s->con);\n\n\n\n    switch (surface_bits_per_pixel(surface)) {\n\n    case 0:\n\n        s->line_fn_tab[0] = s->line_fn_tab[1] =\n\n                g_malloc0(sizeof(blizzard_fn_t) * 0x10);\n\n        break;\n\n    case 8:\n\n        s->line_fn_tab[0] = blizzard_draw_fn_8;\n\n        s->line_fn_tab[1] = blizzard_draw_fn_r_8;\n\n        break;\n\n    case 15:\n\n        s->line_fn_tab[0] = blizzard_draw_fn_15;\n\n        s->line_fn_tab[1] = blizzard_draw_fn_r_15;\n\n        break;\n\n    case 16:\n\n        s->line_fn_tab[0] = blizzard_draw_fn_16;\n\n        s->line_fn_tab[1] = blizzard_draw_fn_r_16;\n\n        break;\n\n    case 24:\n\n        s->line_fn_tab[0] = blizzard_draw_fn_24;\n\n        s->line_fn_tab[1] = blizzard_draw_fn_r_24;\n\n        break;\n\n    case 32:\n\n        s->line_fn_tab[0] = blizzard_draw_fn_32;\n\n        s->line_fn_tab[1] = blizzard_draw_fn_r_32;\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"%s: Bad color depth\\n\", __FUNCTION__);\n\n        exit(1);\n\n    }\n\n\n\n    blizzard_reset(s);\n\n\n\n    return s;\n\n}\n", "idx": 26124}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "static void pxb_pcie_dev_realize(PCIDevice *dev, Error **errp)\n\n{\n\n    if (!pci_bus_is_express(dev->bus)) {\n\n        error_setg(errp, \"pxb-pcie devices cannot reside on a PCI bus\");\n\n        return;\n\n    }\n\n\n\n    pxb_dev_realize_common(dev, true, errp);\n\n}\n", "idx": 26126}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "static int float64_is_unordered(int sig, float64 a, float64 b STATUS_PARAM)\n\n{\n\n    if (float64_is_signaling_nan(a) ||\n\n        float64_is_signaling_nan(b) ||\n\n        (sig && (float64_is_nan(a) || float64_is_nan(b)))) {\n\n        float_raise(float_flag_invalid, status);\n\n        return 1;\n\n    } else if (float64_is_nan(a) || float64_is_nan(b)) {\n\n        return 1;\n\n    } else {\n\n        return 0;\n\n    }\n\n}\n", "idx": 26127}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qmp_input_type_str(Visitor *v, const char *name, char **obj,\n\n                               Error **errp)\n\n{\n\n    QmpInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qmp_input_get_object(qiv, name, true, errp);\n\n    QString *qstr;\n\n\n\n    *obj = NULL;\n\n    if (!qobj) {\n\n        return;\n\n    }\n\n    qstr = qobject_to_qstring(qobj);\n\n    if (!qstr) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"string\");\n\n        return;\n\n    }\n\n\n\n    *obj = g_strdup(qstring_get_str(qstr));\n\n}\n", "idx": 26128}
{"project": "qemu", "commit_id": "48a402e693cbea9582472159931aa6799a6c80c7", "target": 0, "func": "static int curl_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    BDRVCURLState *s = bs->opaque;\n\n    CURLState *state = NULL;\n\n    double d;\n\n\n\n    #define RA_OPTSTR \":readahead=\"\n\n    char *file;\n\n    char *ra;\n\n    const char *ra_val;\n\n    int parse_state = 0;\n\n\n\n    static int inited = 0;\n\n\n\n    file = strdup(filename);\n\n    s->readahead_size = READ_AHEAD_SIZE;\n\n\n\n    /* Parse a trailing \":readahead=#:\" param, if present. */\n\n    ra = file + strlen(file) - 1;\n\n    while (ra >= file) {\n\n        if (parse_state == 0) {\n\n            if (*ra == ':')\n\n                parse_state++;\n\n            else\n\n                break;\n\n        } else if (parse_state == 1) {\n\n            if (*ra > '9' || *ra < '0') {\n\n                char *opt_start = ra - strlen(RA_OPTSTR) + 1;\n\n                if (opt_start > file &&\n\n                    strncmp(opt_start, RA_OPTSTR, strlen(RA_OPTSTR)) == 0) {\n\n                    ra_val = ra + 1;\n\n                    ra -= strlen(RA_OPTSTR) - 1;\n\n                    *ra = '\\0';\n\n                    s->readahead_size = atoi(ra_val);\n\n                    break;\n\n                } else {\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        ra--;\n\n    }\n\n\n\n    if ((s->readahead_size & 0x1ff) != 0) {\n\n        fprintf(stderr, \"HTTP_READAHEAD_SIZE %Zd is not a multiple of 512\\n\",\n\n                s->readahead_size);\n\n        goto out_noclean;\n\n    }\n\n\n\n    if (!inited) {\n\n        curl_global_init(CURL_GLOBAL_ALL);\n\n        inited = 1;\n\n    }\n\n\n\n    DPRINTF(\"CURL: Opening %s\\n\", file);\n\n    s->url = file;\n\n    state = curl_init_state(s);\n\n    if (!state)\n\n        goto out_noclean;\n\n\n\n    // Get file size\n\n\n\n    curl_easy_setopt(state->curl, CURLOPT_NOBODY, 1);\n\n    curl_easy_setopt(state->curl, CURLOPT_WRITEFUNCTION, (void *)curl_size_cb);\n\n    if (curl_easy_perform(state->curl))\n\n        goto out;\n\n    curl_easy_getinfo(state->curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &d);\n\n    curl_easy_setopt(state->curl, CURLOPT_WRITEFUNCTION, (void *)curl_read_cb);\n\n    curl_easy_setopt(state->curl, CURLOPT_NOBODY, 0);\n\n    if (d)\n\n        s->len = (size_t)d;\n\n    else if(!s->len)\n\n        goto out;\n\n    DPRINTF(\"CURL: Size = %lld\\n\", (long long)s->len);\n\n\n\n    curl_clean_state(state);\n\n    curl_easy_cleanup(state->curl);\n\n    state->curl = NULL;\n\n\n\n    // Now we know the file exists and its size, so let's\n\n    // initialize the multi interface!\n\n\n\n    s->multi = curl_multi_init();\n\n    curl_multi_setopt( s->multi, CURLMOPT_SOCKETDATA, s); \n\n    curl_multi_setopt( s->multi, CURLMOPT_SOCKETFUNCTION, curl_sock_cb ); \n\n    curl_multi_do(s);\n\n\n\n    return 0;\n\n\n\nout:\n\n    fprintf(stderr, \"CURL: Error opening file: %s\\n\", state->errmsg);\n\n    curl_easy_cleanup(state->curl);\n\n    state->curl = NULL;\n\nout_noclean:\n\n    qemu_free(file);\n\n    return -EINVAL;\n\n}\n", "idx": 26129}
{"project": "qemu", "commit_id": "18b21a2f83a26c3d6a9e7f0bdc4e8eb2b177e8f6", "target": 0, "func": "static void gen_ldarx(DisasContext *ctx)\n\n{\n\n    TCGv t0;\n\n    gen_set_access_type(ctx, ACCESS_RES);\n\n    t0 = tcg_temp_local_new();\n\n    gen_addr_reg_index(ctx, t0);\n\n    gen_check_align(ctx, t0, 0x07);\n\n    gen_qemu_ld64(ctx, cpu_gpr[rD(ctx->opcode)], t0);\n\n    tcg_gen_mov_tl(cpu_reserve, t0);\n\n    tcg_temp_free(t0);\n\n}\n", "idx": 26130}
{"project": "qemu", "commit_id": "3eff1f46f08a360a4ae9f834ce9fef4c45bf6f0f", "target": 0, "func": "static void virtio_scsi_handle_ctrl(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    VirtIOSCSI *s = (VirtIOSCSI *)vdev;\n\n    VirtIOSCSIReq *req;\n\n\n\n    while ((req = virtio_scsi_pop_req(s, vq))) {\n\n        int type;\n\n\n\n        if (iov_to_buf(req->elem.out_sg, req->elem.out_num, 0,\n\n                       &type, sizeof(type)) < sizeof(type)) {\n\n            virtio_scsi_bad_req();\n\n            continue;\n\n        }\n\n\n\n        tswap32s(&req->req.tmf->type);\n\n        if (req->req.tmf->type == VIRTIO_SCSI_T_TMF) {\n\n            if (virtio_scsi_parse_req(req, sizeof(VirtIOSCSICtrlTMFReq),\n\n                                      sizeof(VirtIOSCSICtrlTMFResp)) < 0) {\n\n                virtio_scsi_bad_req();\n\n            } else {\n\n                virtio_scsi_do_tmf(s, req);\n\n            }\n\n\n\n        } else if (req->req.tmf->type == VIRTIO_SCSI_T_AN_QUERY ||\n\n                   req->req.tmf->type == VIRTIO_SCSI_T_AN_SUBSCRIBE) {\n\n            if (virtio_scsi_parse_req(req, sizeof(VirtIOSCSICtrlANReq),\n\n                                      sizeof(VirtIOSCSICtrlANResp)) < 0) {\n\n                virtio_scsi_bad_req();\n\n            } else {\n\n                req->resp.an->event_actual = 0;\n\n                req->resp.an->response = VIRTIO_SCSI_S_OK;\n\n            }\n\n        }\n\n        virtio_scsi_complete_req(req);\n\n    }\n\n}\n", "idx": 26131}
{"project": "qemu", "commit_id": "de9b05b807918d40db9e26ddd6a54ad2978ac5b7", "target": 1, "func": "void arm_cpu_realize(ARMCPU *cpu)\n\n{\n\n    /* This function is called by cpu_arm_init() because it\n\n     * needs to do common actions based on feature bits, etc\n\n     * that have been set by the subclass init functions.\n\n     * When we have QOM realize support it should become\n\n     * a true realize function instead.\n\n     */\n\n    CPUARMState *env = &cpu->env;\n\n    /* Some features automatically imply others: */\n\n    if (arm_feature(env, ARM_FEATURE_V7)) {\n\n        set_feature(env, ARM_FEATURE_VAPA);\n\n        set_feature(env, ARM_FEATURE_THUMB2);\n\n        set_feature(env, ARM_FEATURE_MPIDR);\n\n        if (!arm_feature(env, ARM_FEATURE_M)) {\n\n            set_feature(env, ARM_FEATURE_V6K);\n\n        } else {\n\n            set_feature(env, ARM_FEATURE_V6);\n\n\n\n    if (arm_feature(env, ARM_FEATURE_V6K)) {\n\n        set_feature(env, ARM_FEATURE_V6);\n\n        set_feature(env, ARM_FEATURE_MVFR);\n\n\n    if (arm_feature(env, ARM_FEATURE_V6)) {\n\n        set_feature(env, ARM_FEATURE_V5);\n\n        if (!arm_feature(env, ARM_FEATURE_M)) {\n\n            set_feature(env, ARM_FEATURE_AUXCR);\n\n\n\n    if (arm_feature(env, ARM_FEATURE_V5)) {\n\n        set_feature(env, ARM_FEATURE_V4T);\n\n\n    if (arm_feature(env, ARM_FEATURE_M)) {\n\n        set_feature(env, ARM_FEATURE_THUMB_DIV);\n\n\n    if (arm_feature(env, ARM_FEATURE_ARM_DIV)) {\n\n        set_feature(env, ARM_FEATURE_THUMB_DIV);\n\n\n    if (arm_feature(env, ARM_FEATURE_VFP4)) {\n\n        set_feature(env, ARM_FEATURE_VFP3);\n\n\n    if (arm_feature(env, ARM_FEATURE_VFP3)) {\n\n        set_feature(env, ARM_FEATURE_VFP);\n\n\n\n\n\n\n\n    register_cp_regs_for_features(cpu);\n", "idx": 26132}
{"project": "qemu", "commit_id": "d470ad42acfc73c45d3e8ed5311a491160b4c100", "target": 1, "func": "static void replication_start(ReplicationState *rs, ReplicationMode mode,\n                              Error **errp)\n{\n    BlockDriverState *bs = rs->opaque;\n    BDRVReplicationState *s;\n    BlockDriverState *top_bs;\n    int64_t active_length, hidden_length, disk_length;\n    AioContext *aio_context;\n    Error *local_err = NULL;\n    BlockJob *job;\n    aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(aio_context);\n    s = bs->opaque;\n    if (s->stage != BLOCK_REPLICATION_NONE) {\n        error_setg(errp, \"Block replication is running or done\");\n        aio_context_release(aio_context);\n        return;\n    }\n    if (s->mode != mode) {\n        error_setg(errp, \"The parameter mode's value is invalid, needs %d,\"\n                   \" but got %d\", s->mode, mode);\n        aio_context_release(aio_context);\n        return;\n    }\n    switch (s->mode) {\n    case REPLICATION_MODE_PRIMARY:\n        break;\n    case REPLICATION_MODE_SECONDARY:\n        s->active_disk = bs->file;\n        if (!s->active_disk || !s->active_disk->bs ||\n                                    !s->active_disk->bs->backing) {\n            error_setg(errp, \"Active disk doesn't have backing file\");\n            aio_context_release(aio_context);\n            return;\n        }\n        s->hidden_disk = s->active_disk->bs->backing;\n        if (!s->hidden_disk->bs || !s->hidden_disk->bs->backing) {\n            error_setg(errp, \"Hidden disk doesn't have backing file\");\n            aio_context_release(aio_context);\n            return;\n        }\n        s->secondary_disk = s->hidden_disk->bs->backing;\n        if (!s->secondary_disk->bs || !bdrv_has_blk(s->secondary_disk->bs)) {\n            error_setg(errp, \"The secondary disk doesn't have block backend\");\n            aio_context_release(aio_context);\n            return;\n        }\n        /* verify the length */\n        active_length = bdrv_getlength(s->active_disk->bs);\n        hidden_length = bdrv_getlength(s->hidden_disk->bs);\n        disk_length = bdrv_getlength(s->secondary_disk->bs);\n        if (active_length < 0 || hidden_length < 0 || disk_length < 0 ||\n            active_length != hidden_length || hidden_length != disk_length) {\n            error_setg(errp, \"Active disk, hidden disk, secondary disk's length\"\n                       \" are not the same\");\n            aio_context_release(aio_context);\n            return;\n        }\n        if (!s->active_disk->bs->drv->bdrv_make_empty ||\n            !s->hidden_disk->bs->drv->bdrv_make_empty) {\n            error_setg(errp,\n                       \"Active disk or hidden disk doesn't support make_empty\");\n            aio_context_release(aio_context);\n            return;\n        }\n        /* reopen the backing file in r/w mode */\n        reopen_backing_file(bs, true, &local_err);\n        if (local_err) {\n            error_propagate(errp, local_err);\n            aio_context_release(aio_context);\n            return;\n        }\n        /* start backup job now */\n        error_setg(&s->blocker,\n                   \"Block device is in use by internal backup job\");\n        top_bs = bdrv_lookup_bs(s->top_id, s->top_id, NULL);\n        if (!top_bs || !bdrv_is_root_node(top_bs) ||\n            !check_top_bs(top_bs, bs)) {\n            error_setg(errp, \"No top_bs or it is invalid\");\n            reopen_backing_file(bs, false, NULL);\n            aio_context_release(aio_context);\n            return;\n        }\n        bdrv_op_block_all(top_bs, s->blocker);\n        bdrv_op_unblock(top_bs, BLOCK_OP_TYPE_DATAPLANE, s->blocker);\n        job = backup_job_create(NULL, s->secondary_disk->bs, s->hidden_disk->bs,\n                                0, MIRROR_SYNC_MODE_NONE, NULL, false,\n                                BLOCKDEV_ON_ERROR_REPORT,\n                                BLOCKDEV_ON_ERROR_REPORT, BLOCK_JOB_INTERNAL,\n                                backup_job_completed, bs, NULL, &local_err);\n        if (local_err) {\n            error_propagate(errp, local_err);\n            backup_job_cleanup(bs);\n            aio_context_release(aio_context);\n            return;\n        }\n        block_job_start(job);\n        break;\n    default:\n        aio_context_release(aio_context);\n        abort();\n    }\n    s->stage = BLOCK_REPLICATION_RUNNING;\n    if (s->mode == REPLICATION_MODE_SECONDARY) {\n        secondary_do_checkpoint(s, errp);\n    }\n    s->error = 0;\n    aio_context_release(aio_context);\n}", "idx": 26134}
{"project": "qemu", "commit_id": "586502189edf9fd0f89a83de96717a2ea826fdb0", "target": 1, "func": "static CharDriverState *qemu_chr_open_pty(QemuOpts *opts)\n\n{\n\n    CharDriverState *chr;\n\n    PtyCharDriver *s;\n\n    struct termios tty;\n\n    int master_fd, slave_fd, len;\n\n#if defined(__OpenBSD__) || defined(__DragonFly__)\n\n    char pty_name[PATH_MAX];\n\n#define q_ptsname(x) pty_name\n\n#else\n\n    char *pty_name = NULL;\n\n#define q_ptsname(x) ptsname(x)\n\n#endif\n\n\n\n    if (openpty(&master_fd, &slave_fd, pty_name, NULL, NULL) < 0) {\n\n        return NULL;\n\n    }\n\n\n\n    /* Set raw attributes on the pty. */\n\n    tcgetattr(slave_fd, &tty);\n\n    cfmakeraw(&tty);\n\n    tcsetattr(slave_fd, TCSAFLUSH, &tty);\n\n    close(slave_fd);\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n\n\n    len = strlen(q_ptsname(master_fd)) + 5;\n\n    chr->filename = g_malloc(len);\n\n    snprintf(chr->filename, len, \"pty:%s\", q_ptsname(master_fd));\n\n    qemu_opt_set(opts, \"path\", q_ptsname(master_fd));\n\n    fprintf(stderr, \"char device redirected to %s\\n\", q_ptsname(master_fd));\n\n\n\n    s = g_malloc0(sizeof(PtyCharDriver));\n\n    chr->opaque = s;\n\n    chr->chr_write = pty_chr_write;\n\n    chr->chr_update_read_handler = pty_chr_update_read_handler;\n\n    chr->chr_close = pty_chr_close;\n\n\n\n    s->fd = master_fd;\n\n    s->timer = qemu_new_timer_ms(rt_clock, pty_chr_timer, chr);\n\n\n\n    return chr;\n\n}\n", "idx": 26136}
{"project": "qemu", "commit_id": "760d88d1d0c409f1afe6f1c91539487413e8b2a9", "target": 1, "func": "int cpu_get_dump_info(ArchDumpInfo *info,\n\n                      const struct GuestPhysBlockList *guest_phys_blocks)\n\n{\n\n    PowerPCCPU *cpu = POWERPC_CPU(first_cpu);\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);\n\n\n\n    info->d_machine = EM_PPC64;\n\n    info->d_class = ELFCLASS64;\n\n    if ((*pcc->interrupts_big_endian)(cpu)) {\n\n        info->d_endian = ELFDATA2MSB;\n\n    } else {\n\n        info->d_endian = ELFDATA2LSB;\n\n\n\n\n\n\n\n\n\n    return 0;\n", "idx": 26137}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "static void tcp_chr_accept(void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    TCPCharDriver *s = chr->opaque;\n\n    struct sockaddr_in saddr;\n\n#ifndef _WIN32\n\n    struct sockaddr_un uaddr;\n\n#endif\n\n    struct sockaddr *addr;\n\n    socklen_t len;\n\n    int fd;\n\n\n\n    for(;;) {\n\n#ifndef _WIN32\n\n\tif (s->is_unix) {\n\n\t    len = sizeof(uaddr);\n\n\t    addr = (struct sockaddr *)&uaddr;\n\n\t} else\n\n#endif\n\n\t{\n\n\t    len = sizeof(saddr);\n\n\t    addr = (struct sockaddr *)&saddr;\n\n\t}\n\n        fd = accept(s->listen_fd, addr, &len);\n\n        if (fd < 0 && errno != EINTR) {\n\n            return;\n\n        } else if (fd >= 0) {\n\n            if (s->do_telnetopt)\n\n                tcp_chr_telnet_init(fd);\n\n            break;\n\n        }\n\n    }\n\n    socket_set_nonblock(fd);\n\n    if (s->do_nodelay)\n\n        socket_set_nodelay(fd);\n\n    s->fd = fd;\n\n    qemu_set_fd_handler(s->listen_fd, NULL, NULL, NULL);\n\n    tcp_chr_connect(chr);\n\n}\n", "idx": 26141}
{"project": "qemu", "commit_id": "a1f0cce2ac0243572ff72aa561da67fe3766a395", "target": 1, "func": "static int execute_command(BlockDriverState *bdrv,\n\n                           SCSIGenericReq *r, int direction,\n\n\t\t\t   BlockDriverCompletionFunc *complete)\n\n{\n\n    SCSIGenericState *s = DO_UPCAST(SCSIGenericState, qdev, r->req.dev);\n\n\n\n    r->io_header.interface_id = 'S';\n\n    r->io_header.dxfer_direction = direction;\n\n    r->io_header.dxferp = r->buf;\n\n    r->io_header.dxfer_len = r->buflen;\n\n    r->io_header.cmdp = r->req.cmd.buf;\n\n    r->io_header.cmd_len = r->req.cmd.len;\n\n    r->io_header.mx_sb_len = sizeof(s->sensebuf);\n\n    r->io_header.sbp = s->sensebuf;\n\n    r->io_header.timeout = MAX_UINT;\n\n    r->io_header.usr_ptr = r;\n\n    r->io_header.flags |= SG_FLAG_DIRECT_IO;\n\n\n\n    r->req.aiocb = bdrv_aio_ioctl(bdrv, SG_IO, &r->io_header, complete, r);\n\n    if (r->req.aiocb == NULL) {\n\n        BADF(\"execute_command: read failed !\\n\");\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 26144}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_int8(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    int8_t *v = pv;\n\n    qemu_get_s8s(f, v);\n\n    return 0;\n\n}\n", "idx": 26145}
{"project": "qemu", "commit_id": "fea505221eaf87889000378d4d33ad0dfd5f4d9d", "target": 0, "func": "static void handle_msr(DisasContext *s, uint32_t insn, unsigned int op0,\n\n                       unsigned int op1, unsigned int op2,\n\n                       unsigned int crn, unsigned int crm, unsigned int rt)\n\n{\n\n    unsupported_encoding(s, insn);\n\n}\n", "idx": 26146}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void validate_teardown(TestInputVisitorData *data,\n\n                               const void *unused)\n\n{\n\n    qobject_decref(data->obj);\n\n    data->obj = NULL;\n\n\n\n    if (data->qiv) {\n\n        visit_free(data->qiv);\n\n        data->qiv = NULL;\n\n    }\n\n}\n", "idx": 26147}
{"project": "qemu", "commit_id": "b9bec74bcb16519a876ec21cd5277c526a9b512d", "target": 0, "func": "int kvm_arch_remove_hw_breakpoint(target_ulong addr,\n\n                                  target_ulong len, int type)\n\n{\n\n    int n;\n\n\n\n    n = find_hw_breakpoint(addr, (type == GDB_BREAKPOINT_HW) ? 1 : len, type);\n\n    if (n < 0)\n\n        return -ENOENT;\n\n\n\n    nb_hw_breakpoint--;\n\n    hw_breakpoint[n] = hw_breakpoint[nb_hw_breakpoint];\n\n\n\n    return 0;\n\n}\n", "idx": 26148}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_out_native_list_int8(TestOutputVisitorData *data,\n\n                                              const void *unused)\n\n{\n\n    test_native_list(data, unused, USER_DEF_NATIVE_LIST_UNION_KIND_S8);\n\n}\n", "idx": 26149}
{"project": "qemu", "commit_id": "f0ddf11b23260f0af84fb529486a8f9ba2d19401", "target": 0, "func": "void HELPER(cas2l)(CPUM68KState *env, uint32_t regs, uint32_t a1, uint32_t a2)\n\n{\n\n    uint32_t Dc1 = extract32(regs, 9, 3);\n\n    uint32_t Dc2 = extract32(regs, 6, 3);\n\n    uint32_t Du1 = extract32(regs, 3, 3);\n\n    uint32_t Du2 = extract32(regs, 0, 3);\n\n    uint32_t c1 = env->dregs[Dc1];\n\n    uint32_t c2 = env->dregs[Dc2];\n\n    uint32_t u1 = env->dregs[Du1];\n\n    uint32_t u2 = env->dregs[Du2];\n\n    uint32_t l1, l2;\n\n    uintptr_t ra = GETPC();\n\n#if defined(CONFIG_ATOMIC64) && !defined(CONFIG_USER_ONLY)\n\n    int mmu_idx = cpu_mmu_index(env, 0);\n\n    TCGMemOpIdx oi;\n\n#endif\n\n\n\n    if (parallel_cpus) {\n\n        /* We're executing in a parallel context -- must be atomic.  */\n\n#ifdef CONFIG_ATOMIC64\n\n        uint64_t c, u, l;\n\n        if ((a1 & 7) == 0 && a2 == a1 + 4) {\n\n            c = deposit64(c2, 32, 32, c1);\n\n            u = deposit64(u2, 32, 32, u1);\n\n#ifdef CONFIG_USER_ONLY\n\n            l = helper_atomic_cmpxchgq_be(env, a1, c, u);\n\n#else\n\n            oi = make_memop_idx(MO_BEQ, mmu_idx);\n\n            l = helper_atomic_cmpxchgq_be_mmu(env, a1, c, u, oi, ra);\n\n#endif\n\n            l1 = l >> 32;\n\n            l2 = l;\n\n        } else if ((a2 & 7) == 0 && a1 == a2 + 4) {\n\n            c = deposit64(c1, 32, 32, c2);\n\n            u = deposit64(u1, 32, 32, u2);\n\n#ifdef CONFIG_USER_ONLY\n\n            l = helper_atomic_cmpxchgq_be(env, a2, c, u);\n\n#else\n\n            oi = make_memop_idx(MO_BEQ, mmu_idx);\n\n            l = helper_atomic_cmpxchgq_be_mmu(env, a2, c, u, oi, ra);\n\n#endif\n\n            l2 = l >> 32;\n\n            l1 = l;\n\n        } else\n\n#endif\n\n        {\n\n            /* Tell the main loop we need to serialize this insn.  */\n\n            cpu_loop_exit_atomic(ENV_GET_CPU(env), ra);\n\n        }\n\n    } else {\n\n        /* We're executing in a serial context -- no need to be atomic.  */\n\n        l1 = cpu_ldl_data_ra(env, a1, ra);\n\n        l2 = cpu_ldl_data_ra(env, a2, ra);\n\n        if (l1 == c1 && l2 == c2) {\n\n            cpu_stl_data_ra(env, a1, u1, ra);\n\n            cpu_stl_data_ra(env, a2, u2, ra);\n\n        }\n\n    }\n\n\n\n    if (c1 != l1) {\n\n        env->cc_n = l1;\n\n        env->cc_v = c1;\n\n    } else {\n\n        env->cc_n = l2;\n\n        env->cc_v = c2;\n\n    }\n\n    env->cc_op = CC_OP_CMPL;\n\n    env->dregs[Dc1] = l1;\n\n    env->dregs[Dc2] = l2;\n\n}\n", "idx": 26150}
{"project": "qemu", "commit_id": "786a4ea82ec9c87e3a895cf41081029b285a5fe5", "target": 0, "func": "static inline hwaddr booke206_page_size_to_tlb(uint64_t size)\n\n{\n\n    return (ffs(size >> 10) - 1) >> 1;\n\n}\n", "idx": 26151}
{"project": "qemu", "commit_id": "601b9a9008c5a612d76073bb3f178621cff41980", "target": 0, "func": "uint32_t HELPER(sigp)(CPUS390XState *env, uint64_t order_code, uint32_t r1,\n\n                      uint64_t cpu_addr)\n\n{\n\n    int cc = SIGP_CC_ORDER_CODE_ACCEPTED;\n\n\n\n    HELPER_LOG(\"%s: %016\" PRIx64 \" %08x %016\" PRIx64 \"\\n\",\n\n               __func__, order_code, r1, cpu_addr);\n\n\n\n    /* Remember: Use \"R1 or R1 + 1, whichever is the odd-numbered register\"\n\n       as parameter (input). Status (output) is always R1. */\n\n\n\n    switch (order_code) {\n\n    case SIGP_SET_ARCH:\n\n        /* switch arch */\n\n        break;\n\n    case SIGP_SENSE:\n\n        /* enumerate CPU status */\n\n        if (cpu_addr) {\n\n            /* XXX implement when SMP comes */\n\n            return 3;\n\n        }\n\n        env->regs[r1] &= 0xffffffff00000000ULL;\n\n        cc = 1;\n\n        break;\n\n#if !defined(CONFIG_USER_ONLY)\n\n    case SIGP_RESTART:\n\n        qemu_system_reset_request();\n\n        cpu_loop_exit(CPU(s390_env_get_cpu(env)));\n\n        break;\n\n    case SIGP_STOP:\n\n        qemu_system_shutdown_request();\n\n        cpu_loop_exit(CPU(s390_env_get_cpu(env)));\n\n        break;\n\n#endif\n\n    default:\n\n        /* unknown sigp */\n\n        fprintf(stderr, \"XXX unknown sigp: 0x%\" PRIx64 \"\\n\", order_code);\n\n        cc = SIGP_CC_NOT_OPERATIONAL;\n\n    }\n\n\n\n    return cc;\n\n}\n", "idx": 26152}
{"project": "qemu", "commit_id": "8917c3bdba37d6fe4393db0fad3fabbde9530d6b", "target": 0, "func": "sofcantrcvmore(struct socket *so)\n\n{\n\n\tif ((so->so_state & SS_NOFDREF) == 0) {\n\n\t\tshutdown(so->s,0);\n\n\t\tif(global_writefds) {\n\n\t\t  FD_CLR(so->s,global_writefds);\n\n\t\t}\n\n\t}\n\n\tso->so_state &= ~(SS_ISFCONNECTING);\n\n\tif (so->so_state & SS_FCANTSENDMORE) {\n\n\t   so->so_state &= SS_PERSISTENT_MASK;\n\n\t   so->so_state |= SS_NOFDREF; /* Don't select it */\n\n\t} else {\n\n\t   so->so_state |= SS_FCANTRCVMORE;\n\n\t}\n\n}\n", "idx": 26153}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void cpu_breakpoint_remove_all(CPUState *env, int mask)\n\n{\n\n#if defined(TARGET_HAS_ICE)\n\n    CPUBreakpoint *bp, *next;\n\n\n\n    TAILQ_FOREACH_SAFE(bp, &env->breakpoints, entry, next) {\n\n        if (bp->flags & mask)\n\n            cpu_breakpoint_remove_by_ref(env, bp);\n\n    }\n\n#endif\n\n}\n", "idx": 26155}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_reg_alloc_mov(TCGContext *s, const TCGOpDef *def,\n\n                              const TCGArg *args, uint16_t dead_args,\n\n                              uint8_t sync_args)\n\n{\n\n    TCGRegSet allocated_regs;\n\n    TCGTemp *ts, *ots;\n\n    TCGType otype, itype;\n\n\n\n    tcg_regset_set(allocated_regs, s->reserved_regs);\n\n    ots = &s->temps[args[0]];\n\n    ts = &s->temps[args[1]];\n\n\n\n    /* Note that otype != itype for no-op truncation.  */\n\n    otype = ots->type;\n\n    itype = ts->type;\n\n\n\n    /* If the source value is not in a register, and we're going to be\n\n       forced to have it in a register in order to perform the copy,\n\n       then copy the SOURCE value into its own register first.  That way\n\n       we don't have to reload SOURCE the next time it is used. */\n\n    if (((NEED_SYNC_ARG(0) || ots->fixed_reg) && ts->val_type != TEMP_VAL_REG)\n\n        || ts->val_type == TEMP_VAL_MEM) {\n\n        temp_load(s, ts, tcg_target_available_regs[itype], allocated_regs);\n\n    }\n\n\n\n    if (IS_DEAD_ARG(0) && !ots->fixed_reg) {\n\n        /* mov to a non-saved dead register makes no sense (even with\n\n           liveness analysis disabled). */\n\n        assert(NEED_SYNC_ARG(0));\n\n        /* The code above should have moved the temp to a register. */\n\n        assert(ts->val_type == TEMP_VAL_REG);\n\n        if (!ots->mem_allocated) {\n\n            temp_allocate_frame(s, args[0]);\n\n        }\n\n        if (ots->indirect_reg) {\n\n            tcg_regset_set_reg(allocated_regs, ts->reg);\n\n            temp_load(s, ots->mem_base,\n\n                      tcg_target_available_regs[TCG_TYPE_PTR],\n\n                      allocated_regs);\n\n        }\n\n        tcg_out_st(s, otype, ts->reg, ots->mem_base->reg, ots->mem_offset);\n\n        if (IS_DEAD_ARG(1)) {\n\n            temp_dead(s, ts);\n\n        }\n\n        temp_dead(s, ots);\n\n    } else if (ts->val_type == TEMP_VAL_CONST) {\n\n        /* propagate constant */\n\n        if (ots->val_type == TEMP_VAL_REG) {\n\n            s->reg_to_temp[ots->reg] = NULL;\n\n        }\n\n        ots->val_type = TEMP_VAL_CONST;\n\n        ots->val = ts->val;\n\n        if (IS_DEAD_ARG(1)) {\n\n            temp_dead(s, ts);\n\n        }\n\n    } else {\n\n        /* The code in the first if block should have moved the\n\n           temp to a register. */\n\n        assert(ts->val_type == TEMP_VAL_REG);\n\n        if (IS_DEAD_ARG(1) && !ts->fixed_reg && !ots->fixed_reg) {\n\n            /* the mov can be suppressed */\n\n            if (ots->val_type == TEMP_VAL_REG) {\n\n                s->reg_to_temp[ots->reg] = NULL;\n\n            }\n\n            ots->reg = ts->reg;\n\n            temp_dead(s, ts);\n\n        } else {\n\n            if (ots->val_type != TEMP_VAL_REG) {\n\n                /* When allocating a new register, make sure to not spill the\n\n                   input one. */\n\n                tcg_regset_set_reg(allocated_regs, ts->reg);\n\n                ots->reg = tcg_reg_alloc(s, tcg_target_available_regs[otype],\n\n                                         allocated_regs, ots->indirect_base);\n\n            }\n\n            tcg_out_mov(s, otype, ots->reg, ts->reg);\n\n        }\n\n        ots->val_type = TEMP_VAL_REG;\n\n        ots->mem_coherent = 0;\n\n        s->reg_to_temp[ots->reg] = ots;\n\n        if (NEED_SYNC_ARG(0)) {\n\n            tcg_reg_sync(s, ots->reg, allocated_regs);\n\n        }\n\n    }\n\n}\n", "idx": 26156}
{"project": "qemu", "commit_id": "f8b6cc0070aab8b75bd082582c829be1353f395f", "target": 0, "func": "static void scsi_destroy(SCSIDevice *d)\n\n{\n\n    SCSIGenericState *s = DO_UPCAST(SCSIGenericState, qdev, d);\n\n    SCSIGenericReq *r;\n\n\n\n    while (!QTAILQ_EMPTY(&s->qdev.requests)) {\n\n        r = DO_UPCAST(SCSIGenericReq, req, QTAILQ_FIRST(&s->qdev.requests));\n\n        scsi_remove_request(r);\n\n    }\n\n    blockdev_mark_auto_del(s->qdev.conf.dinfo->bdrv);\n\n}\n", "idx": 26157}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static inline int onenand_prog_main(OneNANDState *s, int sec, int secn,\n\n                void *src)\n\n{\n\n    int result = 0;\n\n\n\n    if (secn > 0) {\n\n        uint32_t size = (uint32_t)secn * 512;\n\n        const uint8_t *sp = (const uint8_t *)src;\n\n        uint8_t *dp = 0;\n\n        if (s->bdrv_cur) {\n\n            dp = g_malloc(size);\n\n            if (!dp || bdrv_read(s->bdrv_cur, sec, dp, secn) < 0) {\n\n                result = 1;\n\n            }\n\n        } else {\n\n            if (sec + secn > s->secs_cur) {\n\n                result = 1;\n\n            } else {\n\n                dp = (uint8_t *)s->current + (sec << 9);\n\n            }\n\n        }\n\n        if (!result) {\n\n            uint32_t i;\n\n            for (i = 0; i < size; i++) {\n\n                dp[i] &= sp[i];\n\n            }\n\n            if (s->bdrv_cur) {\n\n                result = bdrv_write(s->bdrv_cur, sec, dp, secn) < 0;\n\n            }\n\n        }\n\n        if (dp && s->bdrv_cur) {\n\n            g_free(dp);\n\n        }\n\n    }\n\n\n\n    return result;\n\n}\n", "idx": 26158}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "static inline void kqemu_save_seg(SegmentCache *sc,\n\n                                  const struct kqemu_segment_cache *ksc)\n\n{\n\n    sc->selector = ksc->selector;\n\n    sc->flags = ksc->flags;\n\n    sc->limit = ksc->limit;\n\n    sc->base = ksc->base;\n\n}\n", "idx": 26159}
{"project": "qemu", "commit_id": "943cec86d0864464ab29b42940c49d1ccbe8d268", "target": 0, "func": "static int nbd_receive_list(QIOChannel *ioc, char **name, Error **errp)\n\n{\n\n    uint64_t magic;\n\n    uint32_t opt;\n\n    uint32_t type;\n\n    uint32_t len;\n\n    uint32_t namelen;\n\n    int error;\n\n\n\n    *name = NULL;\n\n    if (read_sync(ioc, &magic, sizeof(magic)) != sizeof(magic)) {\n\n        error_setg(errp, \"failed to read list option magic\");\n\n        return -1;\n\n    }\n\n    magic = be64_to_cpu(magic);\n\n    if (magic != NBD_REP_MAGIC) {\n\n        error_setg(errp, \"Unexpected option list magic\");\n\n        return -1;\n\n    }\n\n    if (read_sync(ioc, &opt, sizeof(opt)) != sizeof(opt)) {\n\n        error_setg(errp, \"failed to read list option\");\n\n        return -1;\n\n    }\n\n    opt = be32_to_cpu(opt);\n\n    if (opt != NBD_OPT_LIST) {\n\n        error_setg(errp, \"Unexpected option type %\" PRIx32 \" expected %x\",\n\n                   opt, NBD_OPT_LIST);\n\n        return -1;\n\n    }\n\n\n\n    if (read_sync(ioc, &type, sizeof(type)) != sizeof(type)) {\n\n        error_setg(errp, \"failed to read list option type\");\n\n        return -1;\n\n    }\n\n    type = be32_to_cpu(type);\n\n    error = nbd_handle_reply_err(ioc, opt, type, errp);\n\n    if (error <= 0) {\n\n        return error;\n\n    }\n\n\n\n    if (read_sync(ioc, &len, sizeof(len)) != sizeof(len)) {\n\n        error_setg(errp, \"failed to read option length\");\n\n        return -1;\n\n    }\n\n    len = be32_to_cpu(len);\n\n\n\n    if (type == NBD_REP_ACK) {\n\n        if (len != 0) {\n\n            error_setg(errp, \"length too long for option end\");\n\n            return -1;\n\n        }\n\n    } else if (type == NBD_REP_SERVER) {\n\n        if (len < sizeof(namelen) || len > NBD_MAX_BUFFER_SIZE) {\n\n            error_setg(errp, \"incorrect option length\");\n\n            return -1;\n\n        }\n\n        if (read_sync(ioc, &namelen, sizeof(namelen)) != sizeof(namelen)) {\n\n            error_setg(errp, \"failed to read option name length\");\n\n            return -1;\n\n        }\n\n        namelen = be32_to_cpu(namelen);\n\n        len -= sizeof(namelen);\n\n        if (len < namelen) {\n\n            error_setg(errp, \"incorrect option name length\");\n\n            return -1;\n\n        }\n\n        if (namelen > 255) {\n\n            error_setg(errp, \"export name length too long %\" PRIu32, namelen);\n\n            return -1;\n\n        }\n\n\n\n        *name = g_new0(char, namelen + 1);\n\n        if (read_sync(ioc, *name, namelen) != namelen) {\n\n            error_setg(errp, \"failed to read export name\");\n\n            g_free(*name);\n\n            *name = NULL;\n\n            return -1;\n\n        }\n\n        (*name)[namelen] = '\\0';\n\n        len -= namelen;\n\n        if (len) {\n\n            char *buf = g_malloc(len + 1);\n\n            if (read_sync(ioc, buf, len) != len) {\n\n                error_setg(errp, \"failed to read export description\");\n\n                g_free(*name);\n\n                g_free(buf);\n\n                *name = NULL;\n\n                return -1;\n\n            }\n\n            buf[len] = '\\0';\n\n            TRACE(\"Ignoring export description: %s\", buf);\n\n            g_free(buf);\n\n        }\n\n    } else {\n\n        error_setg(errp, \"Unexpected reply type %\" PRIx32 \" expected %x\",\n\n                   type, NBD_REP_SERVER);\n\n        return -1;\n\n    }\n\n    return 1;\n\n}\n", "idx": 26160}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_mpu_timer_write(void *opaque, target_phys_addr_t addr,\n\n                                 uint64_t value, unsigned size)\n\n{\n\n    struct omap_mpu_timer_s *s = (struct omap_mpu_timer_s *) opaque;\n\n\n\n    if (size != 4) {\n\n        return omap_badwidth_write32(opaque, addr, value);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x00:\t/* CNTL_TIMER */\n\n        omap_timer_sync(s);\n\n        s->enable = (value >> 5) & 1;\n\n        s->ptv = (value >> 2) & 7;\n\n        s->ar = (value >> 1) & 1;\n\n        s->st = value & 1;\n\n        omap_timer_update(s);\n\n        return;\n\n\n\n    case 0x04:\t/* LOAD_TIM */\n\n        s->reset_val = value;\n\n        return;\n\n\n\n    case 0x08:\t/* READ_TIM */\n\n        OMAP_RO_REG(addr);\n\n        break;\n\n\n\n    default:\n\n        OMAP_BAD_REG(addr);\n\n    }\n\n}\n", "idx": 26161}
{"project": "qemu", "commit_id": "d6085e3ace20bc9b0fa625d8d79b22668710e217", "target": 0, "func": "bool qemu_peer_has_vnet_hdr(NetClientState *nc)\n\n{\n\n    if (!nc->peer || !nc->peer->info->has_vnet_hdr) {\n\n        return false;\n\n    }\n\n\n\n    return nc->peer->info->has_vnet_hdr(nc->peer);\n\n}\n", "idx": 26162}
{"project": "qemu", "commit_id": "57407ea44cc0a3d630b9b89a2be011f1955ce5c1", "target": 0, "func": "static void vmxnet3_cleanup(NetClientState *nc)\n\n{\n\n    VMXNET3State *s = qemu_get_nic_opaque(nc);\n\n    s->nic = NULL;\n\n}\n", "idx": 26163}
{"project": "qemu", "commit_id": "5e755519ac9d867f7da13f58a9d0c262db82e14c", "target": 0, "func": "void op_cp1_enabled(void)\n\n{\n\n    if (!(env->CP0_Status & (1 << CP0St_CU1))) {\n\n        CALL_FROM_TB2(do_raise_exception_err, EXCP_CpU, 1);\n\n    }\n\n    RETURN();\n\n}\n", "idx": 26164}
{"project": "qemu", "commit_id": "ac1970fbe8ad5a70174f462109ac0f6c7bf1bc43", "target": 0, "func": "static void core_region_add(MemoryListener *listener,\n\n                            MemoryRegionSection *section)\n\n{\n\n    cpu_register_physical_memory_log(section, section->readonly);\n\n}\n", "idx": 26166}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "static void kvm_mce_inj_srao_memscrub(CPUState *env, target_phys_addr_t paddr)\n\n{\n\n    struct kvm_x86_mce mce = {\n\n        .bank = 9,\n\n        .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN\n\n                  | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S\n\n                  | 0xc0,\n\n        .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV,\n\n        .addr = paddr,\n\n        .misc = (MCM_ADDR_PHYS << 6) | 0xc,\n\n    };\n\n    int r;\n\n\n\n    r = kvm_set_mce(env, &mce);\n\n    if (r < 0) {\n\n        fprintf(stderr, \"kvm_set_mce: %s\\n\", strerror(errno));\n\n        abort();\n\n    }\n\n    kvm_mce_broadcast_rest(env);\n\n}\n", "idx": 26167}
{"project": "qemu", "commit_id": "832390a5ed11e6c516db0986bf302d098e3ae36c", "target": 1, "func": "static int img_check(int argc, char **argv)\n\n{\n\n    int c, ret;\n\n    OutputFormat output_format = OFORMAT_HUMAN;\n\n    const char *filename, *fmt, *output, *cache;\n\n    BlockBackend *blk;\n\n    BlockDriverState *bs;\n\n    int fix = 0;\n\n    int flags = BDRV_O_FLAGS | BDRV_O_CHECK;\n\n    ImageCheck *check;\n\n    bool quiet = false;\n\n\n\n    fmt = NULL;\n\n    output = NULL;\n\n    cache = BDRV_DEFAULT_CACHE;\n\n    for(;;) {\n\n        int option_index = 0;\n\n        static const struct option long_options[] = {\n\n            {\"help\", no_argument, 0, 'h'},\n\n            {\"format\", required_argument, 0, 'f'},\n\n            {\"repair\", required_argument, 0, 'r'},\n\n            {\"output\", required_argument, 0, OPTION_OUTPUT},\n\n            {0, 0, 0, 0}\n\n        };\n\n        c = getopt_long(argc, argv, \"hf:r:T:q\",\n\n                        long_options, &option_index);\n\n        if (c == -1) {\n\n            break;\n\n        }\n\n        switch(c) {\n\n        case '?':\n\n        case 'h':\n\n            help();\n\n            break;\n\n        case 'f':\n\n            fmt = optarg;\n\n            break;\n\n        case 'r':\n\n            flags |= BDRV_O_RDWR;\n\n\n\n            if (!strcmp(optarg, \"leaks\")) {\n\n                fix = BDRV_FIX_LEAKS;\n\n            } else if (!strcmp(optarg, \"all\")) {\n\n                fix = BDRV_FIX_LEAKS | BDRV_FIX_ERRORS;\n\n            } else {\n\n                error_exit(\"Unknown option value for -r \"\n\n                           \"(expecting 'leaks' or 'all'): %s\", optarg);\n\n            }\n\n            break;\n\n        case OPTION_OUTPUT:\n\n            output = optarg;\n\n            break;\n\n        case 'T':\n\n            cache = optarg;\n\n            break;\n\n        case 'q':\n\n            quiet = true;\n\n            break;\n\n        }\n\n    }\n\n    if (optind != argc - 1) {\n\n        error_exit(\"Expecting one image file name\");\n\n    }\n\n    filename = argv[optind++];\n\n\n\n    if (output && !strcmp(output, \"json\")) {\n\n        output_format = OFORMAT_JSON;\n\n    } else if (output && !strcmp(output, \"human\")) {\n\n        output_format = OFORMAT_HUMAN;\n\n    } else if (output) {\n\n        error_report(\"--output must be used with human or json as argument.\");\n\n        return 1;\n\n    }\n\n\n\n    ret = bdrv_parse_cache_flags(cache, &flags);\n\n    if (ret < 0) {\n\n        error_report(\"Invalid source cache option: %s\", cache);\n\n        return 1;\n\n    }\n\n\n\n    blk = img_open(\"image\", filename, fmt, flags, true, quiet);\n\n    if (!blk) {\n\n        return 1;\n\n    }\n\n    bs = blk_bs(blk);\n\n\n\n    check = g_new0(ImageCheck, 1);\n\n    ret = collect_image_check(bs, check, filename, fmt, fix);\n\n\n\n    if (ret == -ENOTSUP) {\n\n        error_report(\"This image format does not support checks\");\n\n        ret = 63;\n\n        goto fail;\n\n    }\n\n\n\n    if (check->corruptions_fixed || check->leaks_fixed) {\n\n        int corruptions_fixed, leaks_fixed;\n\n\n\n        leaks_fixed         = check->leaks_fixed;\n\n        corruptions_fixed   = check->corruptions_fixed;\n\n\n\n        if (output_format == OFORMAT_HUMAN) {\n\n            qprintf(quiet,\n\n                    \"The following inconsistencies were found and repaired:\\n\\n\"\n\n                    \"    %\" PRId64 \" leaked clusters\\n\"\n\n                    \"    %\" PRId64 \" corruptions\\n\\n\"\n\n                    \"Double checking the fixed image now...\\n\",\n\n                    check->leaks_fixed,\n\n                    check->corruptions_fixed);\n\n        }\n\n\n\n        ret = collect_image_check(bs, check, filename, fmt, 0);\n\n\n\n        check->leaks_fixed          = leaks_fixed;\n\n        check->corruptions_fixed    = corruptions_fixed;\n\n    }\n\n\n\n    switch (output_format) {\n\n    case OFORMAT_HUMAN:\n\n        dump_human_image_check(check, quiet);\n\n        break;\n\n    case OFORMAT_JSON:\n\n        dump_json_image_check(check, quiet);\n\n        break;\n\n    }\n\n\n\n    if (ret || check->check_errors) {\n\n        ret = 1;\n\n        goto fail;\n\n    }\n\n\n\n    if (check->corruptions) {\n\n        ret = 2;\n\n    } else if (check->leaks) {\n\n        ret = 3;\n\n    } else {\n\n        ret = 0;\n\n    }\n\n\n\nfail:\n\n    qapi_free_ImageCheck(check);\n\n    blk_unref(blk);\n\n    return ret;\n\n}\n", "idx": 26171}
{"project": "qemu", "commit_id": "1e9b65bb1bad51735cab6c861c29b592dccabf0e", "target": 1, "func": "void error_setg_win32(Error **errp, int win32_err, const char *fmt, ...)\n\n{\n\n    va_list ap;\n\n    char *msg1, *msg2;\n\n\n\n    if (errp == NULL) {\n\n        return;\n\n    }\n\n\n\n    va_start(ap, fmt);\n\n    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);\n\n    va_end(ap);\n\n\n\n    if (win32_err != 0) {\n\n        msg1 = (*errp)->msg;\n\n        msg2 = g_win32_error_message(win32_err);\n\n        (*errp)->msg = g_strdup_printf(\"%s: %s (error: %x)\", msg1, msg2,\n\n                                       (unsigned)win32_err);\n\n        g_free(msg2);\n\n        g_free(msg1);\n\n    }\n\n}\n", "idx": 26175}
{"project": "qemu", "commit_id": "de82815db1c89da058b7fb941dab137d6d9ab738", "target": 1, "func": "int qcow2_snapshot_load_tmp(BlockDriverState *bs,\n\n                            const char *snapshot_id,\n\n                            const char *name,\n\n                            Error **errp)\n\n{\n\n    int i, snapshot_index;\n\n    BDRVQcowState *s = bs->opaque;\n\n    QCowSnapshot *sn;\n\n    uint64_t *new_l1_table;\n\n    int new_l1_bytes;\n\n    int ret;\n\n\n\n    assert(bs->read_only);\n\n\n\n    /* Search the snapshot */\n\n    snapshot_index = find_snapshot_by_id_and_name(bs, snapshot_id, name);\n\n    if (snapshot_index < 0) {\n\n        error_setg(errp,\n\n                   \"Can't find snapshot\");\n\n        return -ENOENT;\n\n    }\n\n    sn = &s->snapshots[snapshot_index];\n\n\n\n    /* Allocate and read in the snapshot's L1 table */\n\n    if (sn->l1_size > QCOW_MAX_L1_SIZE) {\n\n        error_setg(errp, \"Snapshot L1 table too large\");\n\n        return -EFBIG;\n\n    }\n\n    new_l1_bytes = sn->l1_size * sizeof(uint64_t);\n\n    new_l1_table = g_malloc0(align_offset(new_l1_bytes, 512));\n\n\n\n    ret = bdrv_pread(bs->file, sn->l1_table_offset, new_l1_table, new_l1_bytes);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to read l1 table for snapshot\");\n\n        g_free(new_l1_table);\n\n        return ret;\n\n    }\n\n\n\n    /* Switch the L1 table */\n\n    g_free(s->l1_table);\n\n\n\n    s->l1_size = sn->l1_size;\n\n    s->l1_table_offset = sn->l1_table_offset;\n\n    s->l1_table = new_l1_table;\n\n\n\n    for(i = 0;i < s->l1_size; i++) {\n\n        be64_to_cpus(&s->l1_table[i]);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 26176}
{"project": "qemu", "commit_id": "63fa06dc978f3669dbfd9443b33cde9e2a7f4b41", "target": 1, "func": "static int vdi_create(const char *filename, QEMUOptionParameter *options,\n\n                      Error **errp)\n\n{\n\n    int fd;\n\n    int result = 0;\n\n    uint64_t bytes = 0;\n\n    uint32_t blocks;\n\n    size_t block_size = DEFAULT_CLUSTER_SIZE;\n\n    uint32_t image_type = VDI_TYPE_DYNAMIC;\n\n    VdiHeader header;\n\n    size_t i;\n\n    size_t bmap_size;\n\n\n\n    logout(\"\\n\");\n\n\n\n    /* Read out options. */\n\n    while (options && options->name) {\n\n        if (!strcmp(options->name, BLOCK_OPT_SIZE)) {\n\n            bytes = options->value.n;\n\n#if defined(CONFIG_VDI_BLOCK_SIZE)\n\n        } else if (!strcmp(options->name, BLOCK_OPT_CLUSTER_SIZE)) {\n\n            if (options->value.n) {\n\n                /* TODO: Additional checks (SECTOR_SIZE * 2^n, ...). */\n\n                block_size = options->value.n;\n\n            }\n\n#endif\n\n#if defined(CONFIG_VDI_STATIC_IMAGE)\n\n        } else if (!strcmp(options->name, BLOCK_OPT_STATIC)) {\n\n            if (options->value.n) {\n\n                image_type = VDI_TYPE_STATIC;\n\n            }\n\n#endif\n\n        }\n\n        options++;\n\n    }\n\n\n\n    fd = qemu_open(filename,\n\n                   O_WRONLY | O_CREAT | O_TRUNC | O_BINARY | O_LARGEFILE,\n\n                   0644);\n\n    if (fd < 0) {\n\n        return -errno;\n\n    }\n\n\n\n    /* We need enough blocks to store the given disk size,\n\n       so always round up. */\n\n    blocks = (bytes + block_size - 1) / block_size;\n\n\n\n    bmap_size = blocks * sizeof(uint32_t);\n\n    bmap_size = ((bmap_size + SECTOR_SIZE - 1) & ~(SECTOR_SIZE -1));\n\n\n\n    memset(&header, 0, sizeof(header));\n\n    pstrcpy(header.text, sizeof(header.text), VDI_TEXT);\n\n    header.signature = VDI_SIGNATURE;\n\n    header.version = VDI_VERSION_1_1;\n\n    header.header_size = 0x180;\n\n    header.image_type = image_type;\n\n    header.offset_bmap = 0x200;\n\n    header.offset_data = 0x200 + bmap_size;\n\n    header.sector_size = SECTOR_SIZE;\n\n    header.disk_size = bytes;\n\n    header.block_size = block_size;\n\n    header.blocks_in_image = blocks;\n\n    if (image_type == VDI_TYPE_STATIC) {\n\n        header.blocks_allocated = blocks;\n\n    }\n\n    uuid_generate(header.uuid_image);\n\n    uuid_generate(header.uuid_last_snap);\n\n    /* There is no need to set header.uuid_link or header.uuid_parent here. */\n\n#if defined(CONFIG_VDI_DEBUG)\n\n    vdi_header_print(&header);\n\n#endif\n\n    vdi_header_to_le(&header);\n\n    if (write(fd, &header, sizeof(header)) < 0) {\n\n        result = -errno;\n\n    }\n\n\n\n    if (bmap_size > 0) {\n\n        uint32_t *bmap = g_malloc0(bmap_size);\n\n        for (i = 0; i < blocks; i++) {\n\n            if (image_type == VDI_TYPE_STATIC) {\n\n                bmap[i] = i;\n\n            } else {\n\n                bmap[i] = VDI_UNALLOCATED;\n\n            }\n\n        }\n\n        if (write(fd, bmap, bmap_size) < 0) {\n\n            result = -errno;\n\n        }\n\n        g_free(bmap);\n\n    }\n\n\n\n    if (image_type == VDI_TYPE_STATIC) {\n\n        if (ftruncate(fd, sizeof(header) + bmap_size + blocks * block_size)) {\n\n            result = -errno;\n\n        }\n\n    }\n\n\n\n    if (close(fd) < 0) {\n\n        result = -errno;\n\n    }\n\n\n\n    return result;\n\n}\n", "idx": 26177}
{"project": "qemu", "commit_id": "8f5d58ef2c92d7b82d9a6eeefd7c8854a183ba4a", "target": 1, "func": "void object_property_add_link(Object *obj, const char *name,\n\n                              const char *type, Object **child,\n\n                              void (*check)(Object *, const char *,\n\n                                            Object *, Error **),\n\n                              ObjectPropertyLinkFlags flags,\n\n                              Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    LinkProperty *prop = g_malloc(sizeof(*prop));\n\n    gchar *full_type;\n\n    ObjectProperty *op;\n\n\n\n    prop->child = child;\n\n    prop->check = check;\n\n    prop->flags = flags;\n\n\n\n    full_type = g_strdup_printf(\"link<%s>\", type);\n\n\n\n    op = object_property_add(obj, name, full_type,\n\n                             object_get_link_property,\n\n                             check ? object_set_link_property : NULL,\n\n                             object_release_link_property,\n\n                             prop,\n\n                             &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        g_free(prop);\n\n        goto out;\n\n    }\n\n\n\n    op->resolve = object_resolve_link_property;\n\n\n\nout:\n\n    g_free(full_type);\n\n}\n", "idx": 26184}
{"project": "qemu", "commit_id": "2b5d5953eec0cc541857c3df812bdf8421596ab2", "target": 1, "func": "static int alloc_refcount_block(BlockDriverState *bs,\n    int64_t cluster_index, uint16_t **refcount_block)\n{\n    BDRVQcowState *s = bs->opaque;\n    unsigned int refcount_table_index;\n    int ret;\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC);\n    /* Find the refcount block for the given cluster */\n    refcount_table_index = cluster_index >> (s->cluster_bits - REFCOUNT_SHIFT);\n    if (refcount_table_index < s->refcount_table_size) {\n        uint64_t refcount_block_offset =\n            s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;\n        /* If it's already there, we're done */\n        if (refcount_block_offset) {\n             return load_refcount_block(bs, refcount_block_offset,\n                 (void**) refcount_block);\n    /*\n     * If we came here, we need to allocate something. Something is at least\n     * a cluster for the new refcount block. It may also include a new refcount\n     * table if the old refcount table is too small.\n     *\n     * Note that allocating clusters here needs some special care:\n     *\n     * - We can't use the normal qcow2_alloc_clusters(), it would try to\n     *   increase the refcount and very likely we would end up with an endless\n     *   recursion. Instead we must place the refcount blocks in a way that\n     *   they can describe them themselves.\n     *\n     * - We need to consider that at this point we are inside update_refcounts\n     *   and potentially doing an initial refcount increase. This means that\n     *   some clusters have already been allocated by the caller, but their\n     *   refcount isn't accurate yet. If we allocate clusters for metadata, we\n     *   need to return -EAGAIN to signal the caller that it needs to restart\n     *   the search for free clusters.\n     *\n     * - alloc_clusters_noref and qcow2_free_clusters may load a different\n     *   refcount block into the cache\n     */\n    *refcount_block = NULL;\n    /* We write to the refcount table, so we might depend on L2 tables */\n    ret = qcow2_cache_flush(bs, s->l2_table_cache);\n    if (ret < 0) {\n        return ret;\n    /* Allocate the refcount block itself and mark it as used */\n    int64_t new_block = alloc_clusters_noref(bs, s->cluster_size);\n    if (new_block < 0) {\n        return new_block;\n#ifdef DEBUG_ALLOC2\n    fprintf(stderr, \"qcow2: Allocate refcount block %d for %\" PRIx64\n        \" at %\" PRIx64 \"\\n\",\n        refcount_table_index, cluster_index << s->cluster_bits, new_block);\n#endif\n    if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) {\n        /* Zero the new refcount block before updating it */\n        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,\n            (void**) refcount_block);\n        if (ret < 0) {\n            goto fail_block;\n        memset(*refcount_block, 0, s->cluster_size);\n        /* The block describes itself, need to update the cache */\n        int block_index = (new_block >> s->cluster_bits) &\n            ((1 << (s->cluster_bits - REFCOUNT_SHIFT)) - 1);\n        (*refcount_block)[block_index] = cpu_to_be16(1);\n    } else {\n        /* Described somewhere else. This can recurse at most twice before we\n         * arrive at a block that describes itself. */\n        ret = update_refcount(bs, new_block, s->cluster_size, 1,\n                              QCOW2_DISCARD_NEVER);\n        if (ret < 0) {\n            goto fail_block;\n        ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n        if (ret < 0) {\n            goto fail_block;\n        /* Initialize the new refcount block only after updating its refcount,\n         * update_refcount uses the refcount cache itself */\n        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,\n            (void**) refcount_block);\n        if (ret < 0) {\n            goto fail_block;\n        memset(*refcount_block, 0, s->cluster_size);\n    /* Now the new refcount block needs to be written to disk */\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE);\n    qcow2_cache_entry_mark_dirty(s->refcount_block_cache, *refcount_block);\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n    if (ret < 0) {\n        goto fail_block;\n    /* If the refcount table is big enough, just hook the block up there */\n    if (refcount_table_index < s->refcount_table_size) {\n        uint64_t data64 = cpu_to_be64(new_block);\n        BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP);\n        ret = bdrv_pwrite_sync(bs->file,\n            s->refcount_table_offset + refcount_table_index * sizeof(uint64_t),\n            &data64, sizeof(data64));\n        if (ret < 0) {\n            goto fail_block;\n        s->refcount_table[refcount_table_index] = new_block;\n        /* The new refcount block may be where the caller intended to put its\n         * data, so let it restart the search. */\n        return -EAGAIN;\n    ret = qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);\n    if (ret < 0) {\n        goto fail_block;\n    /*\n     * If we come here, we need to grow the refcount table. Again, a new\n     * refcount table needs some space and we can't simply allocate to avoid\n     * endless recursion.\n     *\n     * Therefore let's grab new refcount blocks at the end of the image, which\n     * will describe themselves and the new refcount table. This way we can\n     * reference them only in the new table and do the switch to the new\n     * refcount table at once without producing an inconsistent state in\n     * between.\n     */\n    BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_GROW);\n    /* Calculate the number of refcount blocks needed so far */\n    uint64_t refcount_block_clusters = 1 << (s->cluster_bits - REFCOUNT_SHIFT);\n    uint64_t blocks_used = DIV_ROUND_UP(cluster_index, refcount_block_clusters);\n    /* And now we need at least one block more for the new metadata */\n    uint64_t table_size = next_refcount_table_size(s, blocks_used + 1);\n    uint64_t last_table_size;\n    uint64_t blocks_clusters;\n    do {\n        uint64_t table_clusters =\n            size_to_clusters(s, table_size * sizeof(uint64_t));\n        blocks_clusters = 1 +\n            ((table_clusters + refcount_block_clusters - 1)\n            / refcount_block_clusters);\n        uint64_t meta_clusters = table_clusters + blocks_clusters;\n        last_table_size = table_size;\n        table_size = next_refcount_table_size(s, blocks_used +\n            ((meta_clusters + refcount_block_clusters - 1)\n            / refcount_block_clusters));\n    } while (last_table_size != table_size);\n#ifdef DEBUG_ALLOC2\n    fprintf(stderr, \"qcow2: Grow refcount table %\" PRId32 \" => %\" PRId64 \"\\n\",\n        s->refcount_table_size, table_size);\n#endif\n    /* Create the new refcount table and blocks */\n    uint64_t meta_offset = (blocks_used * refcount_block_clusters) *\n        s->cluster_size;\n    uint64_t table_offset = meta_offset + blocks_clusters * s->cluster_size;\n    uint16_t *new_blocks = g_malloc0(blocks_clusters * s->cluster_size);\n    uint64_t *new_table = g_malloc0(table_size * sizeof(uint64_t));\n    /* Fill the new refcount table */\n    memcpy(new_table, s->refcount_table,\n        s->refcount_table_size * sizeof(uint64_t));\n    new_table[refcount_table_index] = new_block;\n    int i;\n    for (i = 0; i < blocks_clusters; i++) {\n        new_table[blocks_used + i] = meta_offset + (i * s->cluster_size);\n    /* Fill the refcount blocks */\n    uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t));\n    int block = 0;\n    for (i = 0; i < table_clusters + blocks_clusters; i++) {\n        new_blocks[block++] = cpu_to_be16(1);\n    /* Write refcount blocks to disk */\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS);\n    ret = bdrv_pwrite_sync(bs->file, meta_offset, new_blocks,\n        blocks_clusters * s->cluster_size);\n    g_free(new_blocks);\n    if (ret < 0) {\n        goto fail_table;\n    /* Write refcount table to disk */\n    for(i = 0; i < table_size; i++) {\n        cpu_to_be64s(&new_table[i]);\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE);\n    ret = bdrv_pwrite_sync(bs->file, table_offset, new_table,\n        table_size * sizeof(uint64_t));\n    if (ret < 0) {\n        goto fail_table;\n    for(i = 0; i < table_size; i++) {\n        be64_to_cpus(&new_table[i]);\n    /* Hook up the new refcount table in the qcow2 header */\n    uint8_t data[12];\n    cpu_to_be64w((uint64_t*)data, table_offset);\n    cpu_to_be32w((uint32_t*)(data + 8), table_clusters);\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE);\n    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset),\n        data, sizeof(data));\n    if (ret < 0) {\n        goto fail_table;\n    /* And switch it in memory */\n    uint64_t old_table_offset = s->refcount_table_offset;\n    uint64_t old_table_size = s->refcount_table_size;\n    g_free(s->refcount_table);\n    s->refcount_table = new_table;\n    s->refcount_table_size = table_size;\n    s->refcount_table_offset = table_offset;\n    /* Free old table. */\n    qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t),\n                        QCOW2_DISCARD_OTHER);\n    ret = load_refcount_block(bs, new_block, (void**) refcount_block);\n    if (ret < 0) {\n        return ret;\n    /* If we were trying to do the initial refcount update for some cluster\n     * allocation, we might have used the same clusters to store newly\n     * allocated metadata. Make the caller search some new space. */\n    return -EAGAIN;\nfail_table:\n    g_free(new_table);\nfail_block:\n    if (*refcount_block != NULL) {\n        qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);\n    return ret;", "idx": 26185}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(test_ctrz)\n\n{\n\n    T0 = (regs->ctr == 0);\n\n    RETURN();\n\n}\n", "idx": 26186}
{"project": "qemu", "commit_id": "fe3c546c5ff2a6210f9a4d8561cc64051ca8603e", "target": 1, "func": "static void usb_net_handle_dataout(USBNetState *s, USBPacket *p)\n\n{\n\n    int sz = sizeof(s->out_buf) - s->out_ptr;\n\n    struct rndis_packet_msg_type *msg =\n\n            (struct rndis_packet_msg_type *) s->out_buf;\n\n    uint32_t len;\n\n\n\n#ifdef TRAFFIC_DEBUG\n\n    fprintf(stderr, \"usbnet: data out len %zu\\n\", p->iov.size);\n\n    iov_hexdump(p->iov.iov, p->iov.niov, stderr, \"usbnet\", p->iov.size);\n\n#endif\n\n\n\n    if (sz > p->iov.size) {\n\n        sz = p->iov.size;\n\n    }\n\n    usb_packet_copy(p, &s->out_buf[s->out_ptr], sz);\n\n    s->out_ptr += sz;\n\n\n\n    if (!is_rndis(s)) {\n\n        if (p->iov.size < 64) {\n\n            qemu_send_packet(qemu_get_queue(s->nic), s->out_buf, s->out_ptr);\n\n            s->out_ptr = 0;\n\n        }\n\n        return;\n\n    }\n\n    len = le32_to_cpu(msg->MessageLength);\n\n    if (s->out_ptr < 8 || s->out_ptr < len) {\n\n        return;\n\n    }\n\n    if (le32_to_cpu(msg->MessageType) == RNDIS_PACKET_MSG) {\n\n        uint32_t offs = 8 + le32_to_cpu(msg->DataOffset);\n\n        uint32_t size = le32_to_cpu(msg->DataLength);\n\n        if (offs + size <= len)\n\n            qemu_send_packet(qemu_get_queue(s->nic), s->out_buf + offs, size);\n\n    }\n\n    s->out_ptr -= len;\n\n    memmove(s->out_buf, &s->out_buf[len], s->out_ptr);\n\n}\n", "idx": 26187}
{"project": "qemu", "commit_id": "b923ab3112ed5ab47c2ff35776f17ab54c60d651", "target": 1, "func": "static void quiesce_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SCLPEventClass *k = SCLP_EVENT_CLASS(klass);\n\n\n\n    dc->reset = quiesce_reset;\n\n    dc->vmsd = &vmstate_sclpquiesce;\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    k->init = quiesce_init;\n\n\n\n    k->get_send_mask = send_mask;\n\n    k->get_receive_mask = receive_mask;\n\n    k->can_handle_event = can_handle_event;\n\n    k->read_event_data = read_event_data;\n\n    k->write_event_data = NULL;\n\n}\n", "idx": 26188}
{"project": "qemu", "commit_id": "b9ce1454e14ec918acb90d899ce7724f69682f45", "target": 0, "func": "int qemu_get_buffer(QEMUFile *f, uint8_t *buf, int size1)\n\n{\n\n    int size, l;\n\n\n\n    if (f->is_write)\n\n        abort();\n\n\n\n    size = size1;\n\n    while (size > 0) {\n\n        l = f->buf_size - f->buf_index;\n\n        if (l == 0) {\n\n            qemu_fill_buffer(f);\n\n            l = f->buf_size - f->buf_index;\n\n            if (l == 0)\n\n                break;\n\n        }\n\n        if (l > size)\n\n            l = size;\n\n        memcpy(buf, f->buf + f->buf_index, l);\n\n        f->buf_index += l;\n\n        buf += l;\n\n        size -= l;\n\n    }\n\n    return size1 - size;\n\n}\n", "idx": 26191}
{"project": "qemu", "commit_id": "1964a397063967acc5ce71a2a24ed26e74824ee1", "target": 0, "func": "int qemu_file_rate_limit(QEMUFile *f)\n\n{\n\n    if (f->ops->rate_limit)\n\n        return f->ops->rate_limit(f->opaque);\n\n\n\n    return 0;\n\n}\n", "idx": 26192}
{"project": "qemu", "commit_id": "850f49de9b57511dcaf2cd7e45059f8f38fadf3b", "target": 0, "func": "qcrypto_block_luks_create(QCryptoBlock *block,\n\n                          QCryptoBlockCreateOptions *options,\n\n                          const char *optprefix,\n\n                          QCryptoBlockInitFunc initfunc,\n\n                          QCryptoBlockWriteFunc writefunc,\n\n                          void *opaque,\n\n                          Error **errp)\n\n{\n\n    QCryptoBlockLUKS *luks;\n\n    QCryptoBlockCreateOptionsLUKS luks_opts;\n\n    Error *local_err = NULL;\n\n    uint8_t *masterkey = NULL;\n\n    uint8_t *slotkey = NULL;\n\n    uint8_t *splitkey = NULL;\n\n    size_t splitkeylen = 0;\n\n    size_t i;\n\n    QCryptoCipher *cipher = NULL;\n\n    QCryptoIVGen *ivgen = NULL;\n\n    char *password;\n\n    const char *cipher_alg;\n\n    const char *cipher_mode;\n\n    const char *ivgen_alg;\n\n    const char *ivgen_hash_alg = NULL;\n\n    const char *hash_alg;\n\n    char *cipher_mode_spec = NULL;\n\n    QCryptoCipherAlgorithm ivcipheralg = 0;\n\n    uint64_t iters;\n\n\n\n    memcpy(&luks_opts, &options->u.luks, sizeof(luks_opts));\n\n    if (!luks_opts.has_iter_time) {\n\n        luks_opts.iter_time = 2000;\n\n    }\n\n    if (!luks_opts.has_cipher_alg) {\n\n        luks_opts.cipher_alg = QCRYPTO_CIPHER_ALG_AES_256;\n\n    }\n\n    if (!luks_opts.has_cipher_mode) {\n\n        luks_opts.cipher_mode = QCRYPTO_CIPHER_MODE_XTS;\n\n    }\n\n    if (!luks_opts.has_ivgen_alg) {\n\n        luks_opts.ivgen_alg = QCRYPTO_IVGEN_ALG_PLAIN64;\n\n    }\n\n    if (!luks_opts.has_hash_alg) {\n\n        luks_opts.hash_alg = QCRYPTO_HASH_ALG_SHA256;\n\n    }\n\n    if (luks_opts.ivgen_alg == QCRYPTO_IVGEN_ALG_ESSIV) {\n\n        if (!luks_opts.has_ivgen_hash_alg) {\n\n            luks_opts.ivgen_hash_alg = QCRYPTO_HASH_ALG_SHA256;\n\n            luks_opts.has_ivgen_hash_alg = true;\n\n        }\n\n    }\n\n    /* Note we're allowing ivgen_hash_alg to be set even for\n\n     * non-essiv iv generators that don't need a hash. It will\n\n     * be silently ignored, for compatibility with dm-crypt */\n\n\n\n    if (!options->u.luks.key_secret) {\n\n        error_setg(errp, \"Parameter '%skey-secret' is required for cipher\",\n\n                   optprefix ? optprefix : \"\");\n\n        return -1;\n\n    }\n\n    password = qcrypto_secret_lookup_as_utf8(luks_opts.key_secret, errp);\n\n    if (!password) {\n\n        return -1;\n\n    }\n\n\n\n    luks = g_new0(QCryptoBlockLUKS, 1);\n\n    block->opaque = luks;\n\n\n\n    memcpy(luks->header.magic, qcrypto_block_luks_magic,\n\n           QCRYPTO_BLOCK_LUKS_MAGIC_LEN);\n\n\n\n    /* We populate the header in native endianness initially and\n\n     * then convert everything to big endian just before writing\n\n     * it out to disk\n\n     */\n\n    luks->header.version = QCRYPTO_BLOCK_LUKS_VERSION;\n\n    qcrypto_block_luks_uuid_gen(luks->header.uuid);\n\n\n\n    cipher_alg = qcrypto_block_luks_cipher_alg_lookup(luks_opts.cipher_alg,\n\n                                                      errp);\n\n    if (!cipher_alg) {\n\n        goto error;\n\n    }\n\n\n\n    cipher_mode = QCryptoCipherMode_str(luks_opts.cipher_mode);\n\n    ivgen_alg = QCryptoIVGenAlgorithm_str(luks_opts.ivgen_alg);\n\n    if (luks_opts.has_ivgen_hash_alg) {\n\n        ivgen_hash_alg = QCryptoHashAlgorithm_str(luks_opts.ivgen_hash_alg);\n\n        cipher_mode_spec = g_strdup_printf(\"%s-%s:%s\", cipher_mode, ivgen_alg,\n\n                                           ivgen_hash_alg);\n\n    } else {\n\n        cipher_mode_spec = g_strdup_printf(\"%s-%s\", cipher_mode, ivgen_alg);\n\n    }\n\n    hash_alg = QCryptoHashAlgorithm_str(luks_opts.hash_alg);\n\n\n\n\n\n    if (strlen(cipher_alg) >= QCRYPTO_BLOCK_LUKS_CIPHER_NAME_LEN) {\n\n        error_setg(errp, \"Cipher name '%s' is too long for LUKS header\",\n\n                   cipher_alg);\n\n        goto error;\n\n    }\n\n    if (strlen(cipher_mode_spec) >= QCRYPTO_BLOCK_LUKS_CIPHER_MODE_LEN) {\n\n        error_setg(errp, \"Cipher mode '%s' is too long for LUKS header\",\n\n                   cipher_mode_spec);\n\n        goto error;\n\n    }\n\n    if (strlen(hash_alg) >= QCRYPTO_BLOCK_LUKS_HASH_SPEC_LEN) {\n\n        error_setg(errp, \"Hash name '%s' is too long for LUKS header\",\n\n                   hash_alg);\n\n        goto error;\n\n    }\n\n\n\n    if (luks_opts.ivgen_alg == QCRYPTO_IVGEN_ALG_ESSIV) {\n\n        ivcipheralg = qcrypto_block_luks_essiv_cipher(luks_opts.cipher_alg,\n\n                                                      luks_opts.ivgen_hash_alg,\n\n                                                      &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            goto error;\n\n        }\n\n    } else {\n\n        ivcipheralg = luks_opts.cipher_alg;\n\n    }\n\n\n\n    strcpy(luks->header.cipher_name, cipher_alg);\n\n    strcpy(luks->header.cipher_mode, cipher_mode_spec);\n\n    strcpy(luks->header.hash_spec, hash_alg);\n\n\n\n    luks->header.key_bytes = qcrypto_cipher_get_key_len(luks_opts.cipher_alg);\n\n    if (luks_opts.cipher_mode == QCRYPTO_CIPHER_MODE_XTS) {\n\n        luks->header.key_bytes *= 2;\n\n    }\n\n\n\n    /* Generate the salt used for hashing the master key\n\n     * with PBKDF later\n\n     */\n\n    if (qcrypto_random_bytes(luks->header.master_key_salt,\n\n                             QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                             errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n    /* Generate random master key */\n\n    masterkey = g_new0(uint8_t, luks->header.key_bytes);\n\n    if (qcrypto_random_bytes(masterkey,\n\n                             luks->header.key_bytes, errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Setup the block device payload encryption objects */\n\n    block->cipher = qcrypto_cipher_new(luks_opts.cipher_alg,\n\n                                       luks_opts.cipher_mode,\n\n                                       masterkey, luks->header.key_bytes,\n\n                                       errp);\n\n    if (!block->cipher) {\n\n        goto error;\n\n    }\n\n\n\n    block->kdfhash = luks_opts.hash_alg;\n\n    block->niv = qcrypto_cipher_get_iv_len(luks_opts.cipher_alg,\n\n                                           luks_opts.cipher_mode);\n\n    block->ivgen = qcrypto_ivgen_new(luks_opts.ivgen_alg,\n\n                                     ivcipheralg,\n\n                                     luks_opts.ivgen_hash_alg,\n\n                                     masterkey, luks->header.key_bytes,\n\n                                     errp);\n\n\n\n    if (!block->ivgen) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Determine how many iterations we need to hash the master\n\n     * key, in order to have 1 second of compute time used\n\n     */\n\n    iters = qcrypto_pbkdf2_count_iters(luks_opts.hash_alg,\n\n                                       masterkey, luks->header.key_bytes,\n\n                                       luks->header.master_key_salt,\n\n                                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                                       QCRYPTO_BLOCK_LUKS_DIGEST_LEN,\n\n                                       &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    if (iters > (ULLONG_MAX / luks_opts.iter_time)) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu too large to scale\",\n\n                         (unsigned long long)iters);\n\n        goto error;\n\n    }\n\n\n\n    /* iter_time was in millis, but count_iters reported for secs */\n\n    iters = iters * luks_opts.iter_time / 1000;\n\n\n\n    /* Why /= 8 ?  That matches cryptsetup, but there's no\n\n     * explanation why they chose /= 8... Probably so that\n\n     * if all 8 keyslots are active we only spend 1 second\n\n     * in total time to check all keys */\n\n    iters /= 8;\n\n    if (iters > UINT32_MAX) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu larger than %u\",\n\n                         (unsigned long long)iters, UINT32_MAX);\n\n        goto error;\n\n    }\n\n    iters = MAX(iters, QCRYPTO_BLOCK_LUKS_MIN_MASTER_KEY_ITERS);\n\n    luks->header.master_key_iterations = iters;\n\n\n\n    /* Hash the master key, saving the result in the LUKS\n\n     * header. This hash is used when opening the encrypted\n\n     * device to verify that the user password unlocked a\n\n     * valid master key\n\n     */\n\n    if (qcrypto_pbkdf2(luks_opts.hash_alg,\n\n                       masterkey, luks->header.key_bytes,\n\n                       luks->header.master_key_salt,\n\n                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                       luks->header.master_key_iterations,\n\n                       luks->header.master_key_digest,\n\n                       QCRYPTO_BLOCK_LUKS_DIGEST_LEN,\n\n                       errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Although LUKS has multiple key slots, we're just going\n\n     * to use the first key slot */\n\n    splitkeylen = luks->header.key_bytes * QCRYPTO_BLOCK_LUKS_STRIPES;\n\n    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {\n\n        luks->header.key_slots[i].active = i == 0 ?\n\n            QCRYPTO_BLOCK_LUKS_KEY_SLOT_ENABLED :\n\n            QCRYPTO_BLOCK_LUKS_KEY_SLOT_DISABLED;\n\n        luks->header.key_slots[i].stripes = QCRYPTO_BLOCK_LUKS_STRIPES;\n\n\n\n        /* This calculation doesn't match that shown in the spec,\n\n         * but instead follows the cryptsetup implementation.\n\n         */\n\n        luks->header.key_slots[i].key_offset =\n\n            (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n             QCRYPTO_BLOCK_LUKS_SECTOR_SIZE) +\n\n            (ROUND_UP(DIV_ROUND_UP(splitkeylen, QCRYPTO_BLOCK_LUKS_SECTOR_SIZE),\n\n                      (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n                       QCRYPTO_BLOCK_LUKS_SECTOR_SIZE)) * i);\n\n    }\n\n\n\n    if (qcrypto_random_bytes(luks->header.key_slots[0].salt,\n\n                             QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                             errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n    /* Again we determine how many iterations are required to\n\n     * hash the user password while consuming 1 second of compute\n\n     * time */\n\n    iters = qcrypto_pbkdf2_count_iters(luks_opts.hash_alg,\n\n                                       (uint8_t *)password, strlen(password),\n\n                                       luks->header.key_slots[0].salt,\n\n                                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                                       luks->header.key_bytes,\n\n                                       &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    if (iters > (ULLONG_MAX / luks_opts.iter_time)) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu too large to scale\",\n\n                         (unsigned long long)iters);\n\n        goto error;\n\n    }\n\n\n\n    /* iter_time was in millis, but count_iters reported for secs */\n\n    iters = iters * luks_opts.iter_time / 1000;\n\n\n\n    if (iters > UINT32_MAX) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu larger than %u\",\n\n                         (unsigned long long)iters, UINT32_MAX);\n\n        goto error;\n\n    }\n\n\n\n    luks->header.key_slots[0].iterations =\n\n        MAX(iters, QCRYPTO_BLOCK_LUKS_MIN_SLOT_KEY_ITERS);\n\n\n\n\n\n    /* Generate a key that we'll use to encrypt the master\n\n     * key, from the user's password\n\n     */\n\n    slotkey = g_new0(uint8_t, luks->header.key_bytes);\n\n    if (qcrypto_pbkdf2(luks_opts.hash_alg,\n\n                       (uint8_t *)password, strlen(password),\n\n                       luks->header.key_slots[0].salt,\n\n                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                       luks->header.key_slots[0].iterations,\n\n                       slotkey, luks->header.key_bytes,\n\n                       errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Setup the encryption objects needed to encrypt the\n\n     * master key material\n\n     */\n\n    cipher = qcrypto_cipher_new(luks_opts.cipher_alg,\n\n                                luks_opts.cipher_mode,\n\n                                slotkey, luks->header.key_bytes,\n\n                                errp);\n\n    if (!cipher) {\n\n        goto error;\n\n    }\n\n\n\n    ivgen = qcrypto_ivgen_new(luks_opts.ivgen_alg,\n\n                              ivcipheralg,\n\n                              luks_opts.ivgen_hash_alg,\n\n                              slotkey, luks->header.key_bytes,\n\n                              errp);\n\n    if (!ivgen) {\n\n        goto error;\n\n    }\n\n\n\n    /* Before storing the master key, we need to vastly\n\n     * increase its size, as protection against forensic\n\n     * disk data recovery */\n\n    splitkey = g_new0(uint8_t, splitkeylen);\n\n\n\n    if (qcrypto_afsplit_encode(luks_opts.hash_alg,\n\n                               luks->header.key_bytes,\n\n                               luks->header.key_slots[0].stripes,\n\n                               masterkey,\n\n                               splitkey,\n\n                               errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n    /* Now we encrypt the split master key with the key generated\n\n     * from the user's password, before storing it */\n\n    if (qcrypto_block_encrypt_helper(cipher, block->niv, ivgen,\n\n                                     QCRYPTO_BLOCK_LUKS_SECTOR_SIZE,\n\n                                     0,\n\n                                     splitkey,\n\n                                     splitkeylen,\n\n                                     errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* The total size of the LUKS headers is the partition header + key\n\n     * slot headers, rounded up to the nearest sector, combined with\n\n     * the size of each master key material region, also rounded up\n\n     * to the nearest sector */\n\n    luks->header.payload_offset =\n\n        (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n         QCRYPTO_BLOCK_LUKS_SECTOR_SIZE) +\n\n        (ROUND_UP(DIV_ROUND_UP(splitkeylen, QCRYPTO_BLOCK_LUKS_SECTOR_SIZE),\n\n                  (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n                   QCRYPTO_BLOCK_LUKS_SECTOR_SIZE)) *\n\n         QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS);\n\n\n\n    block->payload_offset = luks->header.payload_offset *\n\n        QCRYPTO_BLOCK_LUKS_SECTOR_SIZE;\n\n\n\n    /* Reserve header space to match payload offset */\n\n    initfunc(block, block->payload_offset, opaque, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    /* Everything on disk uses Big Endian, so flip header fields\n\n     * before writing them */\n\n    cpu_to_be16s(&luks->header.version);\n\n    cpu_to_be32s(&luks->header.payload_offset);\n\n    cpu_to_be32s(&luks->header.key_bytes);\n\n    cpu_to_be32s(&luks->header.master_key_iterations);\n\n\n\n    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {\n\n        cpu_to_be32s(&luks->header.key_slots[i].active);\n\n        cpu_to_be32s(&luks->header.key_slots[i].iterations);\n\n        cpu_to_be32s(&luks->header.key_slots[i].key_offset);\n\n        cpu_to_be32s(&luks->header.key_slots[i].stripes);\n\n    }\n\n\n\n\n\n    /* Write out the partition header and key slot headers */\n\n    writefunc(block, 0,\n\n              (const uint8_t *)&luks->header,\n\n              sizeof(luks->header),\n\n              opaque,\n\n              &local_err);\n\n\n\n    /* Delay checking local_err until we've byte-swapped */\n\n\n\n    /* Byte swap the header back to native, in case we need\n\n     * to read it again later */\n\n    be16_to_cpus(&luks->header.version);\n\n    be32_to_cpus(&luks->header.payload_offset);\n\n    be32_to_cpus(&luks->header.key_bytes);\n\n    be32_to_cpus(&luks->header.master_key_iterations);\n\n\n\n    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {\n\n        be32_to_cpus(&luks->header.key_slots[i].active);\n\n        be32_to_cpus(&luks->header.key_slots[i].iterations);\n\n        be32_to_cpus(&luks->header.key_slots[i].key_offset);\n\n        be32_to_cpus(&luks->header.key_slots[i].stripes);\n\n    }\n\n\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    /* Write out the master key material, starting at the\n\n     * sector immediately following the partition header. */\n\n    if (writefunc(block,\n\n                  luks->header.key_slots[0].key_offset *\n\n                  QCRYPTO_BLOCK_LUKS_SECTOR_SIZE,\n\n                  splitkey, splitkeylen,\n\n                  opaque,\n\n                  errp) != splitkeylen) {\n\n        goto error;\n\n    }\n\n\n\n    luks->cipher_alg = luks_opts.cipher_alg;\n\n    luks->cipher_mode = luks_opts.cipher_mode;\n\n    luks->ivgen_alg = luks_opts.ivgen_alg;\n\n    luks->ivgen_hash_alg = luks_opts.ivgen_hash_alg;\n\n    luks->hash_alg = luks_opts.hash_alg;\n\n\n\n    memset(masterkey, 0, luks->header.key_bytes);\n\n    g_free(masterkey);\n\n    memset(slotkey, 0, luks->header.key_bytes);\n\n    g_free(slotkey);\n\n    g_free(splitkey);\n\n    g_free(password);\n\n    g_free(cipher_mode_spec);\n\n\n\n    qcrypto_ivgen_free(ivgen);\n\n    qcrypto_cipher_free(cipher);\n\n\n\n    return 0;\n\n\n\n error:\n\n    if (masterkey) {\n\n        memset(masterkey, 0, luks->header.key_bytes);\n\n    }\n\n    g_free(masterkey);\n\n    if (slotkey) {\n\n        memset(slotkey, 0, luks->header.key_bytes);\n\n    }\n\n    g_free(slotkey);\n\n    g_free(splitkey);\n\n    g_free(password);\n\n    g_free(cipher_mode_spec);\n\n\n\n    qcrypto_ivgen_free(ivgen);\n\n    qcrypto_cipher_free(cipher);\n\n\n\n    g_free(luks);\n\n    return -1;\n\n}\n", "idx": 26193}
{"project": "qemu", "commit_id": "424e4a87d20027acf52e65f322a2100460162a49", "target": 0, "func": "static void pc_cmos_init_late(void *opaque)\n\n{\n\n    pc_cmos_init_late_arg *arg = opaque;\n\n    ISADevice *s = arg->rtc_state;\n\n    int16_t cylinders;\n\n    int8_t heads, sectors;\n\n    int val;\n\n    int i, trans;\n\n    Object *container;\n\n    CheckFdcState state = { 0 };\n\n\n\n    val = 0;\n\n    if (ide_get_geometry(arg->idebus[0], 0,\n\n                         &cylinders, &heads, &sectors) >= 0) {\n\n        cmos_init_hd(s, 0x19, 0x1b, cylinders, heads, sectors);\n\n        val |= 0xf0;\n\n    }\n\n    if (ide_get_geometry(arg->idebus[0], 1,\n\n                         &cylinders, &heads, &sectors) >= 0) {\n\n        cmos_init_hd(s, 0x1a, 0x24, cylinders, heads, sectors);\n\n        val |= 0x0f;\n\n    }\n\n    rtc_set_memory(s, 0x12, val);\n\n\n\n    val = 0;\n\n    for (i = 0; i < 4; i++) {\n\n        /* NOTE: ide_get_geometry() returns the physical\n\n           geometry.  It is always such that: 1 <= sects <= 63, 1\n\n           <= heads <= 16, 1 <= cylinders <= 16383. The BIOS\n\n           geometry can be different if a translation is done. */\n\n        if (ide_get_geometry(arg->idebus[i / 2], i % 2,\n\n                             &cylinders, &heads, &sectors) >= 0) {\n\n            trans = ide_get_bios_chs_trans(arg->idebus[i / 2], i % 2) - 1;\n\n            assert((trans & ~3) == 0);\n\n            val |= trans << (i * 2);\n\n        }\n\n    }\n\n    rtc_set_memory(s, 0x39, val);\n\n\n\n    /*\n\n     * Locate the FDC at IO address 0x3f0, and configure the CMOS registers\n\n     * accordingly.\n\n     */\n\n    for (i = 0; i < ARRAY_SIZE(fdc_container_path); i++) {\n\n        container = container_get(qdev_get_machine(), fdc_container_path[i]);\n\n        object_child_foreach(container, check_fdc, &state);\n\n    }\n\n\n\n    if (state.multiple) {\n\n        error_report(\"warning: multiple floppy disk controllers with \"\n\n                     \"iobase=0x3f0 have been found;\\n\"\n\n                     \"the one being picked for CMOS setup might not reflect \"\n\n                     \"your intent\");\n\n    }\n\n    pc_cmos_init_floppy(s, state.floppy);\n\n\n\n    qemu_unregister_reset(pc_cmos_init_late, opaque);\n\n}\n", "idx": 26194}
{"project": "qemu", "commit_id": "2bd3e04c3b3c76d573435a299a4d85bad0021a90", "target": 0, "func": "static void kvm_mce_broadcast_rest(CPUState *env)\n\n{\n\n    CPUState *cenv;\n\n    int family, model, cpuver = env->cpuid_version;\n\n\n\n    family = (cpuver >> 8) & 0xf;\n\n    model = ((cpuver >> 12) & 0xf0) + ((cpuver >> 4) & 0xf);\n\n\n\n    /* Broadcast MCA signal for processor version 06H_EH and above */\n\n    if ((family == 6 && model >= 14) || family > 6) {\n\n        for (cenv = first_cpu; cenv != NULL; cenv = cenv->next_cpu) {\n\n            if (cenv == env) {\n\n                continue;\n\n            }\n\n            kvm_inject_x86_mce(cenv, 1, MCI_STATUS_VAL | MCI_STATUS_UC,\n\n                               MCG_STATUS_MCIP | MCG_STATUS_RIPV, 0, 0,\n\n                               ABORT_ON_ERROR);\n\n        }\n\n    }\n\n}\n", "idx": 26195}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static struct omap_lpg_s *omap_lpg_init(MemoryRegion *system_memory,\n\n                                        target_phys_addr_t base, omap_clk clk)\n\n{\n\n    struct omap_lpg_s *s = (struct omap_lpg_s *)\n\n            g_malloc0(sizeof(struct omap_lpg_s));\n\n\n\n    s->tm = qemu_new_timer_ms(vm_clock, omap_lpg_tick, s);\n\n\n\n    omap_lpg_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_lpg_ops, s, \"omap-lpg\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n\n\n    omap_clk_adduser(clk, qemu_allocate_irqs(omap_lpg_clk_update, s, 1)[0]);\n\n\n\n    return s;\n\n}\n", "idx": 26196}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static int vapic_enable(VAPICROMState *s, CPUX86State *env)\n\n{\n\n    int cpu_number = get_kpcr_number(env);\n\n    target_phys_addr_t vapic_paddr;\n\n    static const uint8_t enabled = 1;\n\n\n\n    if (cpu_number < 0) {\n\n        return -1;\n\n    }\n\n    vapic_paddr = s->vapic_paddr +\n\n        (((target_phys_addr_t)cpu_number) << VAPIC_CPU_SHIFT);\n\n    cpu_physical_memory_rw(vapic_paddr + offsetof(VAPICState, enabled),\n\n                           (void *)&enabled, sizeof(enabled), 1);\n\n    apic_enable_vapic(env->apic_state, vapic_paddr);\n\n\n\n    s->state = VAPIC_ACTIVE;\n\n\n\n    return 0;\n\n}\n", "idx": 26197}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_id_write(void *opaque, target_phys_addr_t addr,\n\n                          uint64_t value, unsigned size)\n\n{\n\n    if (size != 4) {\n\n        return omap_badwidth_write32(opaque, addr, value);\n\n    }\n\n\n\n    OMAP_BAD_REG(addr);\n\n}\n", "idx": 26198}
{"project": "qemu", "commit_id": "f186d64d8fda4bb22c15beb8e45b7814fbd8b51e", "target": 0, "func": "void replay_finish_event(void)\n\n{\n\n    replay_has_unread_data = 0;\n\n    replay_fetch_data_kind();\n\n}\n", "idx": 26199}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void scsi_unmap_complete(void *opaque, int ret)\n\n{\n\n    UnmapCBData *data = opaque;\n\n    SCSIDiskReq *r = data->r;\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint64_t sector_num;\n\n    uint32_t nb_sectors;\n\n\n\n    r->req.aiocb = NULL;\n\n    if (r->req.io_canceled) {\n\n        scsi_req_cancel_complete(&r->req);\n\n        goto done;\n\n    }\n\n\n\n    if (ret < 0) {\n\n        if (scsi_handle_rw_error(r, -ret)) {\n\n            goto done;\n\n        }\n\n    }\n\n\n\n    if (data->count > 0) {\n\n        sector_num = ldq_be_p(&data->inbuf[0]);\n\n        nb_sectors = ldl_be_p(&data->inbuf[8]) & 0xffffffffULL;\n\n        if (!check_lba_range(s, sector_num, nb_sectors)) {\n\n            scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE));\n\n            goto done;\n\n        }\n\n\n\n        r->req.aiocb = bdrv_aio_discard(s->qdev.conf.bs,\n\n                                        sector_num * (s->qdev.blocksize / 512),\n\n                                        nb_sectors * (s->qdev.blocksize / 512),\n\n                                        scsi_unmap_complete, data);\n\n        data->count--;\n\n        data->inbuf += 16;\n\n        return;\n\n    }\n\n\n\n    scsi_req_complete(&r->req, GOOD);\n\n\n\ndone:\n\n    scsi_req_unref(&r->req);\n\n    g_free(data);\n\n}\n", "idx": 26200}
{"project": "qemu", "commit_id": "b25b387fa5928e516cb2c9e7fde68e958bd7e50a", "target": 0, "func": "static int64_t coroutine_fn qcow2_co_get_block_status(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, int *pnum, BlockDriverState **file)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t cluster_offset;\n\n    int index_in_cluster, ret;\n\n    unsigned int bytes;\n\n    int64_t status = 0;\n\n\n\n    bytes = MIN(INT_MAX, nb_sectors * BDRV_SECTOR_SIZE);\n\n    qemu_co_mutex_lock(&s->lock);\n\n    ret = qcow2_get_cluster_offset(bs, sector_num << 9, &bytes,\n\n                                   &cluster_offset);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    *pnum = bytes >> BDRV_SECTOR_BITS;\n\n\n\n    if (cluster_offset != 0 && ret != QCOW2_CLUSTER_COMPRESSED &&\n\n        !s->cipher) {\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        cluster_offset |= (index_in_cluster << BDRV_SECTOR_BITS);\n\n        *file = bs->file->bs;\n\n        status |= BDRV_BLOCK_OFFSET_VALID | cluster_offset;\n\n    }\n\n    if (ret == QCOW2_CLUSTER_ZERO_PLAIN || ret == QCOW2_CLUSTER_ZERO_ALLOC) {\n\n        status |= BDRV_BLOCK_ZERO;\n\n    } else if (ret != QCOW2_CLUSTER_UNALLOCATED) {\n\n        status |= BDRV_BLOCK_DATA;\n\n    }\n\n    return status;\n\n}\n", "idx": 26202}
{"project": "qemu", "commit_id": "cdb3081269347fd9271fd1b7a9df312e2953bdd9", "target": 0, "func": "static void vfio_iommu_map_notify(Notifier *n, void *data)\n\n{\n\n    VFIOGuestIOMMU *giommu = container_of(n, VFIOGuestIOMMU, n);\n\n    VFIOContainer *container = giommu->container;\n\n    IOMMUTLBEntry *iotlb = data;\n\n    hwaddr iova = iotlb->iova + giommu->iommu_offset;\n\n    MemoryRegion *mr;\n\n    hwaddr xlat;\n\n    hwaddr len = iotlb->addr_mask + 1;\n\n    void *vaddr;\n\n    int ret;\n\n\n\n    trace_vfio_iommu_map_notify(iova, iova + iotlb->addr_mask);\n\n\n\n    if (iotlb->target_as != &address_space_memory) {\n\n        error_report(\"Wrong target AS \\\"%s\\\", only system memory is allowed\",\n\n                     iotlb->target_as->name ? iotlb->target_as->name : \"none\");\n\n        return;\n\n    }\n\n\n\n    /*\n\n     * The IOMMU TLB entry we have just covers translation through\n\n     * this IOMMU to its immediate target.  We need to translate\n\n     * it the rest of the way through to memory.\n\n     */\n\n    rcu_read_lock();\n\n    mr = address_space_translate(&address_space_memory,\n\n                                 iotlb->translated_addr,\n\n                                 &xlat, &len, iotlb->perm & IOMMU_WO);\n\n    if (!memory_region_is_ram(mr)) {\n\n        error_report(\"iommu map to non memory area %\"HWADDR_PRIx\"\",\n\n                     xlat);\n\n        goto out;\n\n    }\n\n    /*\n\n     * Translation truncates length to the IOMMU page size,\n\n     * check that it did not truncate too much.\n\n     */\n\n    if (len & iotlb->addr_mask) {\n\n        error_report(\"iommu has granularity incompatible with target AS\");\n\n        goto out;\n\n    }\n\n\n\n    if ((iotlb->perm & IOMMU_RW) != IOMMU_NONE) {\n\n        vaddr = memory_region_get_ram_ptr(mr) + xlat;\n\n        ret = vfio_dma_map(container, iova,\n\n                           iotlb->addr_mask + 1, vaddr,\n\n                           !(iotlb->perm & IOMMU_WO) || mr->readonly);\n\n        if (ret) {\n\n            error_report(\"vfio_dma_map(%p, 0x%\"HWADDR_PRIx\", \"\n\n                         \"0x%\"HWADDR_PRIx\", %p) = %d (%m)\",\n\n                         container, iova,\n\n                         iotlb->addr_mask + 1, vaddr, ret);\n\n        }\n\n    } else {\n\n        ret = vfio_dma_unmap(container, iova, iotlb->addr_mask + 1);\n\n        if (ret) {\n\n            error_report(\"vfio_dma_unmap(%p, 0x%\"HWADDR_PRIx\", \"\n\n                         \"0x%\"HWADDR_PRIx\") = %d (%m)\",\n\n                         container, iova,\n\n                         iotlb->addr_mask + 1, ret);\n\n        }\n\n    }\n\nout:\n\n    rcu_read_unlock();\n\n}\n", "idx": 26203}
{"project": "qemu", "commit_id": "4baef2679e029c76707be1e2ed54bf3dd21693fe", "target": 0, "func": "int qemu_strtoi64(const char *nptr, const char **endptr, int base,\n\n                 int64_t *result)\n\n{\n\n    char *ep;\n\n    int err = 0;\n\n    if (!nptr) {\n\n        if (endptr) {\n\n            *endptr = nptr;\n\n        }\n\n        err = -EINVAL;\n\n    } else {\n\n        errno = 0;\n\n        /* FIXME This assumes int64_t is long long */\n\n        *result = strtoll(nptr, &ep, base);\n\n        err = check_strtox_error(nptr, ep, endptr, errno);\n\n    }\n\n    return err;\n\n}\n", "idx": 26204}
{"project": "qemu", "commit_id": "88571882516a7cb4291a329c537eb79fd126e1f2", "target": 0, "func": "static int qemu_rdma_exchange_get_response(RDMAContext *rdma,\n\n                RDMAControlHeader *head, int expecting, int idx)\n\n{\n\n    int ret = qemu_rdma_block_for_wrid(rdma, RDMA_WRID_RECV_CONTROL + idx);\n\n\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"rdma migration: recv polling control error!\\n\");\n\n        return ret;\n\n    }\n\n\n\n    network_to_control((void *) rdma->wr_data[idx].control);\n\n    memcpy(head, rdma->wr_data[idx].control, sizeof(RDMAControlHeader));\n\n\n\n    DDDPRINTF(\"CONTROL: %s receiving...\\n\", control_desc[expecting]);\n\n\n\n    if (expecting == RDMA_CONTROL_NONE) {\n\n        DDDPRINTF(\"Surprise: got %s (%d)\\n\",\n\n                  control_desc[head->type], head->type);\n\n    } else if (head->type != expecting || head->type == RDMA_CONTROL_ERROR) {\n\n        fprintf(stderr, \"Was expecting a %s (%d) control message\"\n\n                \", but got: %s (%d), length: %d\\n\",\n\n                control_desc[expecting], expecting,\n\n                control_desc[head->type], head->type, head->len);\n\n        return -EIO;\n\n    }\n\n    if (head->len > RDMA_CONTROL_MAX_BUFFER - sizeof(*head)) {\n\n        fprintf(stderr, \"too long length: %d\\n\", head->len);\n\n        return -EINVAL;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 26205}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_tcmi_init(MemoryRegion *memory, target_phys_addr_t base,\n\n                struct omap_mpu_state_s *mpu)\n\n{\n\n    memory_region_init_io(&mpu->tcmi_iomem, &omap_tcmi_ops, mpu,\n\n                          \"omap-tcmi\", 0x100);\n\n    memory_region_add_subregion(memory, base, &mpu->tcmi_iomem);\n\n    omap_tcmi_reset(mpu);\n\n}\n", "idx": 26206}
{"project": "qemu", "commit_id": "fc9f38c3c0f42b7e98957b646976ee5b63f23806", "target": 0, "func": "static void spapr_machine_2_5_class_options(MachineClass *mc)\n\n{\n\n    sPAPRMachineClass *smc = SPAPR_MACHINE_CLASS(mc);\n\n\n\n    mc->alias = \"pseries\";\n\n    mc->is_default = 1;\n\n    smc->dr_lmb_enabled = true;\n\n}\n", "idx": 26207}
{"project": "qemu", "commit_id": "e1d177b922f52569e900e96d611caa09655bdec9", "target": 1, "func": "static int disas_thumb2_insn(CPUState *env, DisasContext *s, uint16_t insn_hw1)\n\n{\n\n    uint32_t insn, imm, shift, offset;\n\n    uint32_t rd, rn, rm, rs;\n\n    TCGv tmp;\n\n    TCGv tmp2;\n\n    TCGv tmp3;\n\n    TCGv addr;\n\n    TCGv_i64 tmp64;\n\n    int op;\n\n    int shiftop;\n\n    int conds;\n\n    int logic_cc;\n\n\n\n    if (!(arm_feature(env, ARM_FEATURE_THUMB2)\n\n          || arm_feature (env, ARM_FEATURE_M))) {\n\n        /* Thumb-1 cores may need to treat bl and blx as a pair of\n\n           16-bit instructions to get correct prefetch abort behavior.  */\n\n        insn = insn_hw1;\n\n        if ((insn & (1 << 12)) == 0) {\n\n            /* Second half of blx.  */\n\n            offset = ((insn & 0x7ff) << 1);\n\n            tmp = load_reg(s, 14);\n\n            tcg_gen_addi_i32(tmp, tmp, offset);\n\n            tcg_gen_andi_i32(tmp, tmp, 0xfffffffc);\n\n\n\n            tmp2 = tcg_temp_new_i32();\n\n            tcg_gen_movi_i32(tmp2, s->pc | 1);\n\n            store_reg(s, 14, tmp2);\n\n            gen_bx(s, tmp);\n\n            return 0;\n\n        }\n\n        if (insn & (1 << 11)) {\n\n            /* Second half of bl.  */\n\n            offset = ((insn & 0x7ff) << 1) | 1;\n\n            tmp = load_reg(s, 14);\n\n            tcg_gen_addi_i32(tmp, tmp, offset);\n\n\n\n            tmp2 = tcg_temp_new_i32();\n\n            tcg_gen_movi_i32(tmp2, s->pc | 1);\n\n            store_reg(s, 14, tmp2);\n\n            gen_bx(s, tmp);\n\n            return 0;\n\n        }\n\n        if ((s->pc & ~TARGET_PAGE_MASK) == 0) {\n\n            /* Instruction spans a page boundary.  Implement it as two\n\n               16-bit instructions in case the second half causes an\n\n               prefetch abort.  */\n\n            offset = ((int32_t)insn << 21) >> 9;\n\n            tcg_gen_movi_i32(cpu_R[14], s->pc + 2 + offset);\n\n            return 0;\n\n        }\n\n        /* Fall through to 32-bit decode.  */\n\n    }\n\n\n\n    insn = lduw_code(s->pc);\n\n    s->pc += 2;\n\n    insn |= (uint32_t)insn_hw1 << 16;\n\n\n\n    if ((insn & 0xf800e800) != 0xf000e800) {\n\n        ARCH(6T2);\n\n    }\n\n\n\n    rn = (insn >> 16) & 0xf;\n\n    rs = (insn >> 12) & 0xf;\n\n    rd = (insn >> 8) & 0xf;\n\n    rm = insn & 0xf;\n\n    switch ((insn >> 25) & 0xf) {\n\n    case 0: case 1: case 2: case 3:\n\n        /* 16-bit instructions.  Should never happen.  */\n\n        abort();\n\n    case 4:\n\n        if (insn & (1 << 22)) {\n\n            /* Other load/store, table branch.  */\n\n            if (insn & 0x01200000) {\n\n                /* Load/store doubleword.  */\n\n                if (rn == 15) {\n\n                    addr = tcg_temp_new_i32();\n\n                    tcg_gen_movi_i32(addr, s->pc & ~3);\n\n                } else {\n\n                    addr = load_reg(s, rn);\n\n                }\n\n                offset = (insn & 0xff) * 4;\n\n                if ((insn & (1 << 23)) == 0)\n\n                    offset = -offset;\n\n                if (insn & (1 << 24)) {\n\n                    tcg_gen_addi_i32(addr, addr, offset);\n\n                    offset = 0;\n\n                }\n\n                if (insn & (1 << 20)) {\n\n                    /* ldrd */\n\n                    tmp = gen_ld32(addr, IS_USER(s));\n\n                    store_reg(s, rs, tmp);\n\n                    tcg_gen_addi_i32(addr, addr, 4);\n\n                    tmp = gen_ld32(addr, IS_USER(s));\n\n                    store_reg(s, rd, tmp);\n\n                } else {\n\n                    /* strd */\n\n                    tmp = load_reg(s, rs);\n\n                    gen_st32(tmp, addr, IS_USER(s));\n\n                    tcg_gen_addi_i32(addr, addr, 4);\n\n                    tmp = load_reg(s, rd);\n\n                    gen_st32(tmp, addr, IS_USER(s));\n\n                }\n\n                if (insn & (1 << 21)) {\n\n                    /* Base writeback.  */\n\n                    if (rn == 15)\n\n                        goto illegal_op;\n\n                    tcg_gen_addi_i32(addr, addr, offset - 4);\n\n                    store_reg(s, rn, addr);\n\n                } else {\n\n                    tcg_temp_free_i32(addr);\n\n                }\n\n            } else if ((insn & (1 << 23)) == 0) {\n\n                /* Load/store exclusive word.  */\n\n                addr = tcg_temp_local_new();\n\n                load_reg_var(s, addr, rn);\n\n                tcg_gen_addi_i32(addr, addr, (insn & 0xff) << 2);\n\n                if (insn & (1 << 20)) {\n\n                    gen_load_exclusive(s, rs, 15, addr, 2);\n\n                } else {\n\n                    gen_store_exclusive(s, rd, rs, 15, addr, 2);\n\n                }\n\n                tcg_temp_free(addr);\n\n            } else if ((insn & (1 << 6)) == 0) {\n\n                /* Table Branch.  */\n\n                if (rn == 15) {\n\n                    addr = tcg_temp_new_i32();\n\n                    tcg_gen_movi_i32(addr, s->pc);\n\n                } else {\n\n                    addr = load_reg(s, rn);\n\n                }\n\n                tmp = load_reg(s, rm);\n\n                tcg_gen_add_i32(addr, addr, tmp);\n\n                if (insn & (1 << 4)) {\n\n                    /* tbh */\n\n                    tcg_gen_add_i32(addr, addr, tmp);\n\n                    tcg_temp_free_i32(tmp);\n\n                    tmp = gen_ld16u(addr, IS_USER(s));\n\n                } else { /* tbb */\n\n                    tcg_temp_free_i32(tmp);\n\n                    tmp = gen_ld8u(addr, IS_USER(s));\n\n                }\n\n                tcg_temp_free_i32(addr);\n\n                tcg_gen_shli_i32(tmp, tmp, 1);\n\n                tcg_gen_addi_i32(tmp, tmp, s->pc);\n\n                store_reg(s, 15, tmp);\n\n            } else {\n\n                /* Load/store exclusive byte/halfword/doubleword.  */\n\n                ARCH(7);\n\n                op = (insn >> 4) & 0x3;\n\n                if (op == 2) {\n\n                    goto illegal_op;\n\n                }\n\n                addr = tcg_temp_local_new();\n\n                load_reg_var(s, addr, rn);\n\n                if (insn & (1 << 20)) {\n\n                    gen_load_exclusive(s, rs, rd, addr, op);\n\n                } else {\n\n                    gen_store_exclusive(s, rm, rs, rd, addr, op);\n\n                }\n\n                tcg_temp_free(addr);\n\n            }\n\n        } else {\n\n            /* Load/store multiple, RFE, SRS.  */\n\n            if (((insn >> 23) & 1) == ((insn >> 24) & 1)) {\n\n                /* Not available in user mode.  */\n\n                if (IS_USER(s))\n\n                    goto illegal_op;\n\n                if (insn & (1 << 20)) {\n\n                    /* rfe */\n\n                    addr = load_reg(s, rn);\n\n                    if ((insn & (1 << 24)) == 0)\n\n                        tcg_gen_addi_i32(addr, addr, -8);\n\n                    /* Load PC into tmp and CPSR into tmp2.  */\n\n                    tmp = gen_ld32(addr, 0);\n\n                    tcg_gen_addi_i32(addr, addr, 4);\n\n                    tmp2 = gen_ld32(addr, 0);\n\n                    if (insn & (1 << 21)) {\n\n                        /* Base writeback.  */\n\n                        if (insn & (1 << 24)) {\n\n                            tcg_gen_addi_i32(addr, addr, 4);\n\n                        } else {\n\n                            tcg_gen_addi_i32(addr, addr, -4);\n\n                        }\n\n                        store_reg(s, rn, addr);\n\n                    } else {\n\n                        tcg_temp_free_i32(addr);\n\n                    }\n\n                    gen_rfe(s, tmp, tmp2);\n\n                } else {\n\n                    /* srs */\n\n                    op = (insn & 0x1f);\n\n                    addr = tcg_temp_new_i32();\n\n                    tmp = tcg_const_i32(op);\n\n                    gen_helper_get_r13_banked(addr, cpu_env, tmp);\n\n                    tcg_temp_free_i32(tmp);\n\n                    if ((insn & (1 << 24)) == 0) {\n\n                        tcg_gen_addi_i32(addr, addr, -8);\n\n                    }\n\n                    tmp = load_reg(s, 14);\n\n                    gen_st32(tmp, addr, 0);\n\n                    tcg_gen_addi_i32(addr, addr, 4);\n\n                    tmp = tcg_temp_new_i32();\n\n                    gen_helper_cpsr_read(tmp);\n\n                    gen_st32(tmp, addr, 0);\n\n                    if (insn & (1 << 21)) {\n\n                        if ((insn & (1 << 24)) == 0) {\n\n                            tcg_gen_addi_i32(addr, addr, -4);\n\n                        } else {\n\n                            tcg_gen_addi_i32(addr, addr, 4);\n\n                        }\n\n                        tmp = tcg_const_i32(op);\n\n                        gen_helper_set_r13_banked(cpu_env, tmp, addr);\n\n                        tcg_temp_free_i32(tmp);\n\n                    } else {\n\n                        tcg_temp_free_i32(addr);\n\n                    }\n\n                }\n\n            } else {\n\n                int i;\n\n                /* Load/store multiple.  */\n\n                addr = load_reg(s, rn);\n\n                offset = 0;\n\n                for (i = 0; i < 16; i++) {\n\n                    if (insn & (1 << i))\n\n                        offset += 4;\n\n                }\n\n                if (insn & (1 << 24)) {\n\n                    tcg_gen_addi_i32(addr, addr, -offset);\n\n                }\n\n\n\n                for (i = 0; i < 16; i++) {\n\n                    if ((insn & (1 << i)) == 0)\n\n                        continue;\n\n                    if (insn & (1 << 20)) {\n\n                        /* Load.  */\n\n                        tmp = gen_ld32(addr, IS_USER(s));\n\n                        if (i == 15) {\n\n                            gen_bx(s, tmp);\n\n                        } else {\n\n                            store_reg(s, i, tmp);\n\n                        }\n\n                    } else {\n\n                        /* Store.  */\n\n                        tmp = load_reg(s, i);\n\n                        gen_st32(tmp, addr, IS_USER(s));\n\n                    }\n\n                    tcg_gen_addi_i32(addr, addr, 4);\n\n                }\n\n                if (insn & (1 << 21)) {\n\n                    /* Base register writeback.  */\n\n                    if (insn & (1 << 24)) {\n\n                        tcg_gen_addi_i32(addr, addr, -offset);\n\n                    }\n\n                    /* Fault if writeback register is in register list.  */\n\n                    if (insn & (1 << rn))\n\n                        goto illegal_op;\n\n                    store_reg(s, rn, addr);\n\n                } else {\n\n                    tcg_temp_free_i32(addr);\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    case 5:\n\n\n\n        op = (insn >> 21) & 0xf;\n\n        if (op == 6) {\n\n            /* Halfword pack.  */\n\n            tmp = load_reg(s, rn);\n\n            tmp2 = load_reg(s, rm);\n\n            shift = ((insn >> 10) & 0x1c) | ((insn >> 6) & 0x3);\n\n            if (insn & (1 << 5)) {\n\n                /* pkhtb */\n\n                if (shift == 0)\n\n                    shift = 31;\n\n                tcg_gen_sari_i32(tmp2, tmp2, shift);\n\n                tcg_gen_andi_i32(tmp, tmp, 0xffff0000);\n\n                tcg_gen_ext16u_i32(tmp2, tmp2);\n\n            } else {\n\n                /* pkhbt */\n\n                if (shift)\n\n                    tcg_gen_shli_i32(tmp2, tmp2, shift);\n\n                tcg_gen_ext16u_i32(tmp, tmp);\n\n                tcg_gen_andi_i32(tmp2, tmp2, 0xffff0000);\n\n            }\n\n            tcg_gen_or_i32(tmp, tmp, tmp2);\n\n            tcg_temp_free_i32(tmp2);\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            /* Data processing register constant shift.  */\n\n            if (rn == 15) {\n\n                tmp = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(tmp, 0);\n\n            } else {\n\n                tmp = load_reg(s, rn);\n\n            }\n\n            tmp2 = load_reg(s, rm);\n\n\n\n            shiftop = (insn >> 4) & 3;\n\n            shift = ((insn >> 6) & 3) | ((insn >> 10) & 0x1c);\n\n            conds = (insn & (1 << 20)) != 0;\n\n            logic_cc = (conds && thumb2_logic_op(op));\n\n            gen_arm_shift_im(tmp2, shiftop, shift, logic_cc);\n\n            if (gen_thumb2_data_op(s, op, conds, 0, tmp, tmp2))\n\n                goto illegal_op;\n\n            tcg_temp_free_i32(tmp2);\n\n            if (rd != 15) {\n\n                store_reg(s, rd, tmp);\n\n            } else {\n\n                tcg_temp_free_i32(tmp);\n\n            }\n\n        }\n\n        break;\n\n    case 13: /* Misc data processing.  */\n\n        op = ((insn >> 22) & 6) | ((insn >> 7) & 1);\n\n        if (op < 4 && (insn & 0xf000) != 0xf000)\n\n            goto illegal_op;\n\n        switch (op) {\n\n        case 0: /* Register controlled shift.  */\n\n            tmp = load_reg(s, rn);\n\n            tmp2 = load_reg(s, rm);\n\n            if ((insn & 0x70) != 0)\n\n                goto illegal_op;\n\n            op = (insn >> 21) & 3;\n\n            logic_cc = (insn & (1 << 20)) != 0;\n\n            gen_arm_shift_reg(tmp, op, tmp2, logic_cc);\n\n            if (logic_cc)\n\n                gen_logic_CC(tmp);\n\n            store_reg_bx(env, s, rd, tmp);\n\n            break;\n\n        case 1: /* Sign/zero extend.  */\n\n            tmp = load_reg(s, rm);\n\n            shift = (insn >> 4) & 3;\n\n            /* ??? In many cases it's not neccessary to do a\n\n               rotate, a shift is sufficient.  */\n\n            if (shift != 0)\n\n                tcg_gen_rotri_i32(tmp, tmp, shift * 8);\n\n            op = (insn >> 20) & 7;\n\n            switch (op) {\n\n            case 0: gen_sxth(tmp);   break;\n\n            case 1: gen_uxth(tmp);   break;\n\n            case 2: gen_sxtb16(tmp); break;\n\n            case 3: gen_uxtb16(tmp); break;\n\n            case 4: gen_sxtb(tmp);   break;\n\n            case 5: gen_uxtb(tmp);   break;\n\n            default: goto illegal_op;\n\n            }\n\n            if (rn != 15) {\n\n                tmp2 = load_reg(s, rn);\n\n                if ((op >> 1) == 1) {\n\n                    gen_add16(tmp, tmp2);\n\n                } else {\n\n                    tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                    tcg_temp_free_i32(tmp2);\n\n                }\n\n            }\n\n            store_reg(s, rd, tmp);\n\n            break;\n\n        case 2: /* SIMD add/subtract.  */\n\n            op = (insn >> 20) & 7;\n\n            shift = (insn >> 4) & 7;\n\n            if ((op & 3) == 3 || (shift & 3) == 3)\n\n                goto illegal_op;\n\n            tmp = load_reg(s, rn);\n\n            tmp2 = load_reg(s, rm);\n\n            gen_thumb2_parallel_addsub(op, shift, tmp, tmp2);\n\n            tcg_temp_free_i32(tmp2);\n\n            store_reg(s, rd, tmp);\n\n            break;\n\n        case 3: /* Other data processing.  */\n\n            op = ((insn >> 17) & 0x38) | ((insn >> 4) & 7);\n\n            if (op < 4) {\n\n                /* Saturating add/subtract.  */\n\n                tmp = load_reg(s, rn);\n\n                tmp2 = load_reg(s, rm);\n\n                if (op & 1)\n\n                    gen_helper_double_saturate(tmp, tmp);\n\n                if (op & 2)\n\n                    gen_helper_sub_saturate(tmp, tmp2, tmp);\n\n                else\n\n                    gen_helper_add_saturate(tmp, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp2);\n\n            } else {\n\n                tmp = load_reg(s, rn);\n\n                switch (op) {\n\n                case 0x0a: /* rbit */\n\n                    gen_helper_rbit(tmp, tmp);\n\n                    break;\n\n                case 0x08: /* rev */\n\n                    tcg_gen_bswap32_i32(tmp, tmp);\n\n                    break;\n\n                case 0x09: /* rev16 */\n\n                    gen_rev16(tmp);\n\n                    break;\n\n                case 0x0b: /* revsh */\n\n                    gen_revsh(tmp);\n\n                    break;\n\n                case 0x10: /* sel */\n\n                    tmp2 = load_reg(s, rm);\n\n                    tmp3 = tcg_temp_new_i32();\n\n                    tcg_gen_ld_i32(tmp3, cpu_env, offsetof(CPUState, GE));\n\n                    gen_helper_sel_flags(tmp, tmp3, tmp, tmp2);\n\n                    tcg_temp_free_i32(tmp3);\n\n                    tcg_temp_free_i32(tmp2);\n\n                    break;\n\n                case 0x18: /* clz */\n\n                    gen_helper_clz(tmp, tmp);\n\n                    break;\n\n                default:\n\n                    goto illegal_op;\n\n                }\n\n            }\n\n            store_reg(s, rd, tmp);\n\n            break;\n\n        case 4: case 5: /* 32-bit multiply.  Sum of absolute differences.  */\n\n            op = (insn >> 4) & 0xf;\n\n            tmp = load_reg(s, rn);\n\n            tmp2 = load_reg(s, rm);\n\n            switch ((insn >> 20) & 7) {\n\n            case 0: /* 32 x 32 -> 32 */\n\n                tcg_gen_mul_i32(tmp, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp2);\n\n                if (rs != 15) {\n\n                    tmp2 = load_reg(s, rs);\n\n                    if (op)\n\n                        tcg_gen_sub_i32(tmp, tmp2, tmp);\n\n                    else\n\n                        tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                    tcg_temp_free_i32(tmp2);\n\n                }\n\n                break;\n\n            case 1: /* 16 x 16 -> 32 */\n\n                gen_mulxy(tmp, tmp2, op & 2, op & 1);\n\n                tcg_temp_free_i32(tmp2);\n\n                if (rs != 15) {\n\n                    tmp2 = load_reg(s, rs);\n\n                    gen_helper_add_setq(tmp, tmp, tmp2);\n\n                    tcg_temp_free_i32(tmp2);\n\n                }\n\n                break;\n\n            case 2: /* Dual multiply add.  */\n\n            case 4: /* Dual multiply subtract.  */\n\n                if (op)\n\n                    gen_swap_half(tmp2);\n\n                gen_smul_dual(tmp, tmp2);\n\n                /* This addition cannot overflow.  */\n\n                if (insn & (1 << 22)) {\n\n                    tcg_gen_sub_i32(tmp, tmp, tmp2);\n\n                } else {\n\n                    tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                }\n\n                tcg_temp_free_i32(tmp2);\n\n                if (rs != 15)\n\n                  {\n\n                    tmp2 = load_reg(s, rs);\n\n                    gen_helper_add_setq(tmp, tmp, tmp2);\n\n                    tcg_temp_free_i32(tmp2);\n\n                  }\n\n                break;\n\n            case 3: /* 32 * 16 -> 32msb */\n\n                if (op)\n\n                    tcg_gen_sari_i32(tmp2, tmp2, 16);\n\n                else\n\n                    gen_sxth(tmp2);\n\n                tmp64 = gen_muls_i64_i32(tmp, tmp2);\n\n                tcg_gen_shri_i64(tmp64, tmp64, 16);\n\n                tmp = tcg_temp_new_i32();\n\n                tcg_gen_trunc_i64_i32(tmp, tmp64);\n\n                tcg_temp_free_i64(tmp64);\n\n                if (rs != 15)\n\n                  {\n\n                    tmp2 = load_reg(s, rs);\n\n                    gen_helper_add_setq(tmp, tmp, tmp2);\n\n                    tcg_temp_free_i32(tmp2);\n\n                  }\n\n                break;\n\n            case 5: case 6: /* 32 * 32 -> 32msb (SMMUL, SMMLA, SMMLS) */\n\n                tmp64 = gen_muls_i64_i32(tmp, tmp2);\n\n                if (rs != 15) {\n\n                    tmp = load_reg(s, rs);\n\n                    if (insn & (1 << 20)) {\n\n                        tmp64 = gen_addq_msw(tmp64, tmp);\n\n                    } else {\n\n                        tmp64 = gen_subq_msw(tmp64, tmp);\n\n                    }\n\n                }\n\n                if (insn & (1 << 4)) {\n\n                    tcg_gen_addi_i64(tmp64, tmp64, 0x80000000u);\n\n                }\n\n                tcg_gen_shri_i64(tmp64, tmp64, 32);\n\n                tmp = tcg_temp_new_i32();\n\n                tcg_gen_trunc_i64_i32(tmp, tmp64);\n\n                tcg_temp_free_i64(tmp64);\n\n                break;\n\n            case 7: /* Unsigned sum of absolute differences.  */\n\n                gen_helper_usad8(tmp, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp2);\n\n                if (rs != 15) {\n\n                    tmp2 = load_reg(s, rs);\n\n                    tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                    tcg_temp_free_i32(tmp2);\n\n                }\n\n                break;\n\n            }\n\n            store_reg(s, rd, tmp);\n\n            break;\n\n        case 6: case 7: /* 64-bit multiply, Divide.  */\n\n            op = ((insn >> 4) & 0xf) | ((insn >> 16) & 0x70);\n\n            tmp = load_reg(s, rn);\n\n            tmp2 = load_reg(s, rm);\n\n            if ((op & 0x50) == 0x10) {\n\n                /* sdiv, udiv */\n\n                if (!arm_feature(env, ARM_FEATURE_DIV))\n\n                    goto illegal_op;\n\n                if (op & 0x20)\n\n                    gen_helper_udiv(tmp, tmp, tmp2);\n\n                else\n\n                    gen_helper_sdiv(tmp, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp2);\n\n                store_reg(s, rd, tmp);\n\n            } else if ((op & 0xe) == 0xc) {\n\n                /* Dual multiply accumulate long.  */\n\n                if (op & 1)\n\n                    gen_swap_half(tmp2);\n\n                gen_smul_dual(tmp, tmp2);\n\n                if (op & 0x10) {\n\n                    tcg_gen_sub_i32(tmp, tmp, tmp2);\n\n                } else {\n\n                    tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                }\n\n                tcg_temp_free_i32(tmp2);\n\n                /* BUGFIX */\n\n                tmp64 = tcg_temp_new_i64();\n\n                tcg_gen_ext_i32_i64(tmp64, tmp);\n\n                tcg_temp_free_i32(tmp);\n\n                gen_addq(s, tmp64, rs, rd);\n\n                gen_storeq_reg(s, rs, rd, tmp64);\n\n                tcg_temp_free_i64(tmp64);\n\n            } else {\n\n                if (op & 0x20) {\n\n                    /* Unsigned 64-bit multiply  */\n\n                    tmp64 = gen_mulu_i64_i32(tmp, tmp2);\n\n                } else {\n\n                    if (op & 8) {\n\n                        /* smlalxy */\n\n                        gen_mulxy(tmp, tmp2, op & 2, op & 1);\n\n                        tcg_temp_free_i32(tmp2);\n\n                        tmp64 = tcg_temp_new_i64();\n\n                        tcg_gen_ext_i32_i64(tmp64, tmp);\n\n                        tcg_temp_free_i32(tmp);\n\n                    } else {\n\n                        /* Signed 64-bit multiply  */\n\n                        tmp64 = gen_muls_i64_i32(tmp, tmp2);\n\n                    }\n\n                }\n\n                if (op & 4) {\n\n                    /* umaal */\n\n                    gen_addq_lo(s, tmp64, rs);\n\n                    gen_addq_lo(s, tmp64, rd);\n\n                } else if (op & 0x40) {\n\n                    /* 64-bit accumulate.  */\n\n                    gen_addq(s, tmp64, rs, rd);\n\n                }\n\n                gen_storeq_reg(s, rs, rd, tmp64);\n\n                tcg_temp_free_i64(tmp64);\n\n            }\n\n            break;\n\n        }\n\n        break;\n\n    case 6: case 7: case 14: case 15:\n\n        /* Coprocessor.  */\n\n        if (((insn >> 24) & 3) == 3) {\n\n            /* Translate into the equivalent ARM encoding.  */\n\n            insn = (insn & 0xe2ffffff) | ((insn & (1 << 28)) >> 4) | (1 << 28);\n\n            if (disas_neon_data_insn(env, s, insn))\n\n                goto illegal_op;\n\n        } else {\n\n            if (insn & (1 << 28))\n\n                goto illegal_op;\n\n            if (disas_coproc_insn (env, s, insn))\n\n                goto illegal_op;\n\n        }\n\n        break;\n\n    case 8: case 9: case 10: case 11:\n\n        if (insn & (1 << 15)) {\n\n            /* Branches, misc control.  */\n\n            if (insn & 0x5000) {\n\n                /* Unconditional branch.  */\n\n                /* signextend(hw1[10:0]) -> offset[:12].  */\n\n                offset = ((int32_t)insn << 5) >> 9 & ~(int32_t)0xfff;\n\n                /* hw1[10:0] -> offset[11:1].  */\n\n                offset |= (insn & 0x7ff) << 1;\n\n                /* (~hw2[13, 11] ^ offset[24]) -> offset[23,22]\n\n                   offset[24:22] already have the same value because of the\n\n                   sign extension above.  */\n\n                offset ^= ((~insn) & (1 << 13)) << 10;\n\n                offset ^= ((~insn) & (1 << 11)) << 11;\n\n\n\n                if (insn & (1 << 14)) {\n\n                    /* Branch and link.  */\n\n                    tcg_gen_movi_i32(cpu_R[14], s->pc | 1);\n\n                }\n\n\n\n                offset += s->pc;\n\n                if (insn & (1 << 12)) {\n\n                    /* b/bl */\n\n                    gen_jmp(s, offset);\n\n                } else {\n\n                    /* blx */\n\n                    offset &= ~(uint32_t)2;\n\n                    gen_bx_im(s, offset);\n\n                }\n\n            } else if (((insn >> 23) & 7) == 7) {\n\n                /* Misc control */\n\n                if (insn & (1 << 13))\n\n                    goto illegal_op;\n\n\n\n                if (insn & (1 << 26)) {\n\n                    /* Secure monitor call (v6Z) */\n\n                    goto illegal_op; /* not implemented.  */\n\n                } else {\n\n                    op = (insn >> 20) & 7;\n\n                    switch (op) {\n\n                    case 0: /* msr cpsr.  */\n\n                        if (IS_M(env)) {\n\n                            tmp = load_reg(s, rn);\n\n                            addr = tcg_const_i32(insn & 0xff);\n\n                            gen_helper_v7m_msr(cpu_env, addr, tmp);\n\n                            tcg_temp_free_i32(addr);\n\n                            tcg_temp_free_i32(tmp);\n\n                            gen_lookup_tb(s);\n\n                            break;\n\n                        }\n\n                        /* fall through */\n\n                    case 1: /* msr spsr.  */\n\n                        if (IS_M(env))\n\n                            goto illegal_op;\n\n                        tmp = load_reg(s, rn);\n\n                        if (gen_set_psr(s,\n\n                              msr_mask(env, s, (insn >> 8) & 0xf, op == 1),\n\n                              op == 1, tmp))\n\n                            goto illegal_op;\n\n                        break;\n\n                    case 2: /* cps, nop-hint.  */\n\n                        if (((insn >> 8) & 7) == 0) {\n\n                            gen_nop_hint(s, insn & 0xff);\n\n                        }\n\n                        /* Implemented as NOP in user mode.  */\n\n                        if (IS_USER(s))\n\n                            break;\n\n                        offset = 0;\n\n                        imm = 0;\n\n                        if (insn & (1 << 10)) {\n\n                            if (insn & (1 << 7))\n\n                                offset |= CPSR_A;\n\n                            if (insn & (1 << 6))\n\n                                offset |= CPSR_I;\n\n                            if (insn & (1 << 5))\n\n                                offset |= CPSR_F;\n\n                            if (insn & (1 << 9))\n\n                                imm = CPSR_A | CPSR_I | CPSR_F;\n\n                        }\n\n                        if (insn & (1 << 8)) {\n\n                            offset |= 0x1f;\n\n                            imm |= (insn & 0x1f);\n\n                        }\n\n                        if (offset) {\n\n                            gen_set_psr_im(s, offset, 0, imm);\n\n                        }\n\n                        break;\n\n                    case 3: /* Special control operations.  */\n\n                        ARCH(7);\n\n                        op = (insn >> 4) & 0xf;\n\n                        switch (op) {\n\n                        case 2: /* clrex */\n\n                            gen_clrex(s);\n\n                            break;\n\n                        case 4: /* dsb */\n\n                        case 5: /* dmb */\n\n                        case 6: /* isb */\n\n                            /* These execute as NOPs.  */\n\n                            break;\n\n                        default:\n\n                            goto illegal_op;\n\n                        }\n\n                        break;\n\n                    case 4: /* bxj */\n\n                        /* Trivial implementation equivalent to bx.  */\n\n                        tmp = load_reg(s, rn);\n\n                        gen_bx(s, tmp);\n\n                        break;\n\n                    case 5: /* Exception return.  */\n\n                        if (IS_USER(s)) {\n\n                            goto illegal_op;\n\n                        }\n\n                        if (rn != 14 || rd != 15) {\n\n                            goto illegal_op;\n\n                        }\n\n                        tmp = load_reg(s, rn);\n\n                        tcg_gen_subi_i32(tmp, tmp, insn & 0xff);\n\n                        gen_exception_return(s, tmp);\n\n                        break;\n\n                    case 6: /* mrs cpsr.  */\n\n                        tmp = tcg_temp_new_i32();\n\n                        if (IS_M(env)) {\n\n                            addr = tcg_const_i32(insn & 0xff);\n\n                            gen_helper_v7m_mrs(tmp, cpu_env, addr);\n\n                            tcg_temp_free_i32(addr);\n\n                        } else {\n\n                            gen_helper_cpsr_read(tmp);\n\n                        }\n\n                        store_reg(s, rd, tmp);\n\n                        break;\n\n                    case 7: /* mrs spsr.  */\n\n                        /* Not accessible in user mode.  */\n\n                        if (IS_USER(s) || IS_M(env))\n\n                            goto illegal_op;\n\n                        tmp = load_cpu_field(spsr);\n\n                        store_reg(s, rd, tmp);\n\n                        break;\n\n                    }\n\n                }\n\n            } else {\n\n                /* Conditional branch.  */\n\n                op = (insn >> 22) & 0xf;\n\n                /* Generate a conditional jump to next instruction.  */\n\n                s->condlabel = gen_new_label();\n\n                gen_test_cc(op ^ 1, s->condlabel);\n\n                s->condjmp = 1;\n\n\n\n                /* offset[11:1] = insn[10:0] */\n\n                offset = (insn & 0x7ff) << 1;\n\n                /* offset[17:12] = insn[21:16].  */\n\n                offset |= (insn & 0x003f0000) >> 4;\n\n                /* offset[31:20] = insn[26].  */\n\n                offset |= ((int32_t)((insn << 5) & 0x80000000)) >> 11;\n\n                /* offset[18] = insn[13].  */\n\n                offset |= (insn & (1 << 13)) << 5;\n\n                /* offset[19] = insn[11].  */\n\n                offset |= (insn & (1 << 11)) << 8;\n\n\n\n                /* jump to the offset */\n\n                gen_jmp(s, s->pc + offset);\n\n            }\n\n        } else {\n\n            /* Data processing immediate.  */\n\n            if (insn & (1 << 25)) {\n\n                if (insn & (1 << 24)) {\n\n                    if (insn & (1 << 20))\n\n                        goto illegal_op;\n\n                    /* Bitfield/Saturate.  */\n\n                    op = (insn >> 21) & 7;\n\n                    imm = insn & 0x1f;\n\n                    shift = ((insn >> 6) & 3) | ((insn >> 10) & 0x1c);\n\n                    if (rn == 15) {\n\n                        tmp = tcg_temp_new_i32();\n\n                        tcg_gen_movi_i32(tmp, 0);\n\n                    } else {\n\n                        tmp = load_reg(s, rn);\n\n                    }\n\n                    switch (op) {\n\n                    case 2: /* Signed bitfield extract.  */\n\n                        imm++;\n\n                        if (shift + imm > 32)\n\n                            goto illegal_op;\n\n                        if (imm < 32)\n\n                            gen_sbfx(tmp, shift, imm);\n\n                        break;\n\n                    case 6: /* Unsigned bitfield extract.  */\n\n                        imm++;\n\n                        if (shift + imm > 32)\n\n                            goto illegal_op;\n\n                        if (imm < 32)\n\n                            gen_ubfx(tmp, shift, (1u << imm) - 1);\n\n                        break;\n\n                    case 3: /* Bitfield insert/clear.  */\n\n                        if (imm < shift)\n\n                            goto illegal_op;\n\n                        imm = imm + 1 - shift;\n\n                        if (imm != 32) {\n\n                            tmp2 = load_reg(s, rd);\n\n                            gen_bfi(tmp, tmp2, tmp, shift, (1u << imm) - 1);\n\n                            tcg_temp_free_i32(tmp2);\n\n                        }\n\n                        break;\n\n                    case 7:\n\n                        goto illegal_op;\n\n                    default: /* Saturate.  */\n\n                        if (shift) {\n\n                            if (op & 1)\n\n                                tcg_gen_sari_i32(tmp, tmp, shift);\n\n                            else\n\n                                tcg_gen_shli_i32(tmp, tmp, shift);\n\n                        }\n\n                        tmp2 = tcg_const_i32(imm);\n\n                        if (op & 4) {\n\n                            /* Unsigned.  */\n\n                            if ((op & 1) && shift == 0)\n\n                                gen_helper_usat16(tmp, tmp, tmp2);\n\n                            else\n\n                                gen_helper_usat(tmp, tmp, tmp2);\n\n                        } else {\n\n                            /* Signed.  */\n\n                            if ((op & 1) && shift == 0)\n\n                                gen_helper_ssat16(tmp, tmp, tmp2);\n\n                            else\n\n                                gen_helper_ssat(tmp, tmp, tmp2);\n\n                        }\n\n                        tcg_temp_free_i32(tmp2);\n\n                        break;\n\n                    }\n\n                    store_reg(s, rd, tmp);\n\n                } else {\n\n                    imm = ((insn & 0x04000000) >> 15)\n\n                          | ((insn & 0x7000) >> 4) | (insn & 0xff);\n\n                    if (insn & (1 << 22)) {\n\n                        /* 16-bit immediate.  */\n\n                        imm |= (insn >> 4) & 0xf000;\n\n                        if (insn & (1 << 23)) {\n\n                            /* movt */\n\n                            tmp = load_reg(s, rd);\n\n                            tcg_gen_ext16u_i32(tmp, tmp);\n\n                            tcg_gen_ori_i32(tmp, tmp, imm << 16);\n\n                        } else {\n\n                            /* movw */\n\n                            tmp = tcg_temp_new_i32();\n\n                            tcg_gen_movi_i32(tmp, imm);\n\n                        }\n\n                    } else {\n\n                        /* Add/sub 12-bit immediate.  */\n\n                        if (rn == 15) {\n\n                            offset = s->pc & ~(uint32_t)3;\n\n                            if (insn & (1 << 23))\n\n                                offset -= imm;\n\n                            else\n\n                                offset += imm;\n\n                            tmp = tcg_temp_new_i32();\n\n                            tcg_gen_movi_i32(tmp, offset);\n\n                        } else {\n\n                            tmp = load_reg(s, rn);\n\n                            if (insn & (1 << 23))\n\n                                tcg_gen_subi_i32(tmp, tmp, imm);\n\n                            else\n\n                                tcg_gen_addi_i32(tmp, tmp, imm);\n\n                        }\n\n                    }\n\n                    store_reg(s, rd, tmp);\n\n                }\n\n            } else {\n\n                int shifter_out = 0;\n\n                /* modified 12-bit immediate.  */\n\n                shift = ((insn & 0x04000000) >> 23) | ((insn & 0x7000) >> 12);\n\n                imm = (insn & 0xff);\n\n                switch (shift) {\n\n                case 0: /* XY */\n\n                    /* Nothing to do.  */\n\n                    break;\n\n                case 1: /* 00XY00XY */\n\n                    imm |= imm << 16;\n\n                    break;\n\n                case 2: /* XY00XY00 */\n\n                    imm |= imm << 16;\n\n                    imm <<= 8;\n\n                    break;\n\n                case 3: /* XYXYXYXY */\n\n                    imm |= imm << 16;\n\n                    imm |= imm << 8;\n\n                    break;\n\n                default: /* Rotated constant.  */\n\n                    shift = (shift << 1) | (imm >> 7);\n\n                    imm |= 0x80;\n\n                    imm = imm << (32 - shift);\n\n                    shifter_out = 1;\n\n                    break;\n\n                }\n\n                tmp2 = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(tmp2, imm);\n\n                rn = (insn >> 16) & 0xf;\n\n                if (rn == 15) {\n\n                    tmp = tcg_temp_new_i32();\n\n                    tcg_gen_movi_i32(tmp, 0);\n\n                } else {\n\n                    tmp = load_reg(s, rn);\n\n                }\n\n                op = (insn >> 21) & 0xf;\n\n                if (gen_thumb2_data_op(s, op, (insn & (1 << 20)) != 0,\n\n                                       shifter_out, tmp, tmp2))\n\n                    goto illegal_op;\n\n                tcg_temp_free_i32(tmp2);\n\n                rd = (insn >> 8) & 0xf;\n\n                if (rd != 15) {\n\n                    store_reg(s, rd, tmp);\n\n                } else {\n\n                    tcg_temp_free_i32(tmp);\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    case 12: /* Load/store single data item.  */\n\n        {\n\n        int postinc = 0;\n\n        int writeback = 0;\n\n        int user;\n\n        if ((insn & 0x01100000) == 0x01000000) {\n\n            if (disas_neon_ls_insn(env, s, insn))\n\n                goto illegal_op;\n\n            break;\n\n        }\n\n        op = ((insn >> 21) & 3) | ((insn >> 22) & 4);\n\n        if (rs == 15) {\n\n            if (!(insn & (1 << 20))) {\n\n                goto illegal_op;\n\n            }\n\n            if (op != 2) {\n\n                /* Byte or halfword load space with dest == r15 : memory hints.\n\n                 * Catch them early so we don't emit pointless addressing code.\n\n                 * This space is a mix of:\n\n                 *  PLD/PLDW/PLI,  which we implement as NOPs (note that unlike\n\n                 *     the ARM encodings, PLDW space doesn't UNDEF for non-v7MP\n\n                 *     cores)\n\n                 *  unallocated hints, which must be treated as NOPs\n\n                 *  UNPREDICTABLE space, which we NOP or UNDEF depending on\n\n                 *     which is easiest for the decoding logic\n\n                 *  Some space which must UNDEF\n\n                 */\n\n                int op1 = (insn >> 23) & 3;\n\n                int op2 = (insn >> 6) & 0x3f;\n\n                if (op & 2) {\n\n                    goto illegal_op;\n\n                }\n\n                if (rn == 15) {\n\n                    /* UNPREDICTABLE or unallocated hint */\n\n                    return 0;\n\n                }\n\n                if (op1 & 1) {\n\n                    return 0; /* PLD* or unallocated hint */\n\n                }\n\n                if ((op2 == 0) || ((op2 & 0x3c) == 0x30)) {\n\n                    return 0; /* PLD* or unallocated hint */\n\n                }\n\n                /* UNDEF space, or an UNPREDICTABLE */\n\n                return 1;\n\n            }\n\n        }\n\n        user = IS_USER(s);\n\n        if (rn == 15) {\n\n            addr = tcg_temp_new_i32();\n\n            /* PC relative.  */\n\n            /* s->pc has already been incremented by 4.  */\n\n            imm = s->pc & 0xfffffffc;\n\n            if (insn & (1 << 23))\n\n                imm += insn & 0xfff;\n\n            else\n\n                imm -= insn & 0xfff;\n\n            tcg_gen_movi_i32(addr, imm);\n\n        } else {\n\n            addr = load_reg(s, rn);\n\n            if (insn & (1 << 23)) {\n\n                /* Positive offset.  */\n\n                imm = insn & 0xfff;\n\n                tcg_gen_addi_i32(addr, addr, imm);\n\n            } else {\n\n                imm = insn & 0xff;\n\n                switch ((insn >> 8) & 0xf) {\n\n                case 0x0: /* Shifted Register.  */\n\n                    shift = (insn >> 4) & 0xf;\n\n                    if (shift > 3) {\n\n                        tcg_temp_free_i32(addr);\n\n                        goto illegal_op;\n\n                    }\n\n                    tmp = load_reg(s, rm);\n\n                    if (shift)\n\n                        tcg_gen_shli_i32(tmp, tmp, shift);\n\n                    tcg_gen_add_i32(addr, addr, tmp);\n\n                    tcg_temp_free_i32(tmp);\n\n                    break;\n\n                case 0xc: /* Negative offset.  */\n\n                    tcg_gen_addi_i32(addr, addr, -imm);\n\n                    break;\n\n                case 0xe: /* User privilege.  */\n\n                    tcg_gen_addi_i32(addr, addr, imm);\n\n                    user = 1;\n\n                    break;\n\n                case 0x9: /* Post-decrement.  */\n\n                    imm = -imm;\n\n                    /* Fall through.  */\n\n                case 0xb: /* Post-increment.  */\n\n                    postinc = 1;\n\n                    writeback = 1;\n\n                    break;\n\n                case 0xd: /* Pre-decrement.  */\n\n                    imm = -imm;\n\n                    /* Fall through.  */\n\n                case 0xf: /* Pre-increment.  */\n\n                    tcg_gen_addi_i32(addr, addr, imm);\n\n                    writeback = 1;\n\n                    break;\n\n                default:\n\n                    tcg_temp_free_i32(addr);\n\n                    goto illegal_op;\n\n                }\n\n            }\n\n        }\n\n        if (insn & (1 << 20)) {\n\n            /* Load.  */\n\n            switch (op) {\n\n            case 0: tmp = gen_ld8u(addr, user); break;\n\n            case 4: tmp = gen_ld8s(addr, user); break;\n\n            case 1: tmp = gen_ld16u(addr, user); break;\n\n            case 5: tmp = gen_ld16s(addr, user); break;\n\n            case 2: tmp = gen_ld32(addr, user); break;\n\n            default:\n\n                tcg_temp_free_i32(addr);\n\n                goto illegal_op;\n\n            }\n\n            if (rs == 15) {\n\n                gen_bx(s, tmp);\n\n            } else {\n\n                store_reg(s, rs, tmp);\n\n            }\n\n        } else {\n\n            /* Store.  */\n\n            tmp = load_reg(s, rs);\n\n            switch (op) {\n\n            case 0: gen_st8(tmp, addr, user); break;\n\n            case 1: gen_st16(tmp, addr, user); break;\n\n            case 2: gen_st32(tmp, addr, user); break;\n\n            default:\n\n                tcg_temp_free_i32(addr);\n\n                goto illegal_op;\n\n            }\n\n        }\n\n        if (postinc)\n\n            tcg_gen_addi_i32(addr, addr, imm);\n\n        if (writeback) {\n\n            store_reg(s, rn, addr);\n\n        } else {\n\n            tcg_temp_free_i32(addr);\n\n        }\n\n        }\n\n        break;\n\n    default:\n\n        goto illegal_op;\n\n    }\n\n    return 0;\n\nillegal_op:\n\n    return 1;\n\n}\n", "idx": 26208}
{"project": "qemu", "commit_id": "a01672d3968cf91208666d371784110bfde9d4f8", "target": 1, "func": "static void kvm_set_phys_mem(target_phys_addr_t start_addr, ram_addr_t size,\n\n                             ram_addr_t phys_offset, bool log_dirty)\n\n{\n\n    KVMState *s = kvm_state;\n\n    ram_addr_t flags = phys_offset & ~TARGET_PAGE_MASK;\n\n    KVMSlot *mem, old;\n\n    int err;\n\n    void *ram = NULL;\n\n\n\n    /* kvm works in page size chunks, but the function may be called\n\n       with sub-page size and unaligned start address. */\n\n    size = TARGET_PAGE_ALIGN(size);\n\n    start_addr = TARGET_PAGE_ALIGN(start_addr);\n\n\n\n    /* KVM does not support read-only slots */\n\n    phys_offset &= ~IO_MEM_ROM;\n\n\n\n    if ((phys_offset & ~TARGET_PAGE_MASK) == IO_MEM_RAM) {\n\n        ram = qemu_safe_ram_ptr(phys_offset);\n\n    }\n\n\n\n    while (1) {\n\n        mem = kvm_lookup_overlapping_slot(s, start_addr, start_addr + size);\n\n        if (!mem) {\n\n            break;\n\n        }\n\n\n\n        if (flags < IO_MEM_UNASSIGNED && start_addr >= mem->start_addr &&\n\n            (start_addr + size <= mem->start_addr + mem->memory_size) &&\n\n            (ram - start_addr == mem->ram - mem->start_addr)) {\n\n            /* The new slot fits into the existing one and comes with\n\n             * identical parameters - update flags and done. */\n\n            kvm_slot_dirty_pages_log_change(mem, log_dirty);\n\n            return;\n\n        }\n\n\n\n        old = *mem;\n\n\n\n        /* unregister the overlapping slot */\n\n        mem->memory_size = 0;\n\n        err = kvm_set_user_memory_region(s, mem);\n\n        if (err) {\n\n            fprintf(stderr, \"%s: error unregistering overlapping slot: %s\\n\",\n\n                    __func__, strerror(-err));\n\n            abort();\n\n        }\n\n\n\n        /* Workaround for older KVM versions: we can't join slots, even not by\n\n         * unregistering the previous ones and then registering the larger\n\n         * slot. We have to maintain the existing fragmentation. Sigh.\n\n         *\n\n         * This workaround assumes that the new slot starts at the same\n\n         * address as the first existing one. If not or if some overlapping\n\n         * slot comes around later, we will fail (not seen in practice so far)\n\n         * - and actually require a recent KVM version. */\n\n        if (s->broken_set_mem_region &&\n\n            old.start_addr == start_addr && old.memory_size < size &&\n\n            flags < IO_MEM_UNASSIGNED) {\n\n            mem = kvm_alloc_slot(s);\n\n            mem->memory_size = old.memory_size;\n\n            mem->start_addr = old.start_addr;\n\n            mem->ram = old.ram;\n\n            mem->flags = kvm_mem_flags(s, log_dirty);\n\n\n\n            err = kvm_set_user_memory_region(s, mem);\n\n            if (err) {\n\n                fprintf(stderr, \"%s: error updating slot: %s\\n\", __func__,\n\n                        strerror(-err));\n\n                abort();\n\n            }\n\n\n\n            start_addr += old.memory_size;\n\n            phys_offset += old.memory_size;\n\n            ram += old.memory_size;\n\n            size -= old.memory_size;\n\n            continue;\n\n        }\n\n\n\n        /* register prefix slot */\n\n        if (old.start_addr < start_addr) {\n\n            mem = kvm_alloc_slot(s);\n\n            mem->memory_size = start_addr - old.start_addr;\n\n            mem->start_addr = old.start_addr;\n\n            mem->ram = old.ram;\n\n            mem->flags =  kvm_mem_flags(s, log_dirty);\n\n\n\n            err = kvm_set_user_memory_region(s, mem);\n\n            if (err) {\n\n                fprintf(stderr, \"%s: error registering prefix slot: %s\\n\",\n\n                        __func__, strerror(-err));\n\n#ifdef TARGET_PPC\n\n                fprintf(stderr, \"%s: This is probably because your kernel's \" \\\n\n                                \"PAGE_SIZE is too big. Please try to use 4k \" \\\n\n                                \"PAGE_SIZE!\\n\", __func__);\n\n#endif\n\n                abort();\n\n            }\n\n        }\n\n\n\n        /* register suffix slot */\n\n        if (old.start_addr + old.memory_size > start_addr + size) {\n\n            ram_addr_t size_delta;\n\n\n\n            mem = kvm_alloc_slot(s);\n\n            mem->start_addr = start_addr + size;\n\n            size_delta = mem->start_addr - old.start_addr;\n\n            mem->memory_size = old.memory_size - size_delta;\n\n            mem->ram = old.ram + size_delta;\n\n            mem->flags = kvm_mem_flags(s, log_dirty);\n\n\n\n            err = kvm_set_user_memory_region(s, mem);\n\n            if (err) {\n\n                fprintf(stderr, \"%s: error registering suffix slot: %s\\n\",\n\n                        __func__, strerror(-err));\n\n                abort();\n\n            }\n\n        }\n\n    }\n\n\n\n    /* in case the KVM bug workaround already \"consumed\" the new slot */\n\n    if (!size) {\n\n        return;\n\n    }\n\n    /* KVM does not need to know about this memory */\n\n    if (flags >= IO_MEM_UNASSIGNED) {\n\n        return;\n\n    }\n\n    mem = kvm_alloc_slot(s);\n\n    mem->memory_size = size;\n\n    mem->start_addr = start_addr;\n\n    mem->ram = ram;\n\n    mem->flags = kvm_mem_flags(s, log_dirty);\n\n\n\n    err = kvm_set_user_memory_region(s, mem);\n\n    if (err) {\n\n        fprintf(stderr, \"%s: error registering slot: %s\\n\", __func__,\n\n                strerror(-err));\n\n        abort();\n\n    }\n\n}\n", "idx": 26209}
{"project": "qemu", "commit_id": "c572f23a3e7180dbeab5e86583e43ea2afed6271", "target": 1, "func": "static void v9fs_xattrwalk(void *opaque)\n{\n    int64_t size;\n    V9fsString name;\n    ssize_t err = 0;\n    size_t offset = 7;\n    int32_t fid, newfid;\n    V9fsFidState *file_fidp;\n    V9fsFidState *xattr_fidp = NULL;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    pdu_unmarshal(pdu, offset, \"dds\", &fid, &newfid, &name);\n    file_fidp = get_fid(pdu, fid);\n    if (file_fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    xattr_fidp = alloc_fid(s, newfid);\n    if (xattr_fidp == NULL) {\n        err = -EINVAL;\n        goto out;\n    }\n    v9fs_path_copy(&xattr_fidp->path, &file_fidp->path);\n    if (name.data[0] == 0) {\n        /*\n         * listxattr request. Get the size first\n         */\n        size = v9fs_co_llistxattr(pdu, &xattr_fidp->path, NULL, 0);\n        if (size < 0) {\n            err = size;\n            clunk_fid(s, xattr_fidp->fid);\n            goto out;\n        }\n        /*\n         * Read the xattr value\n         */\n        xattr_fidp->fs.xattr.len = size;\n        xattr_fidp->fid_type = P9_FID_XATTR;\n        xattr_fidp->fs.xattr.copied_len = -1;\n        if (size) {\n            xattr_fidp->fs.xattr.value = g_malloc(size);\n            err = v9fs_co_llistxattr(pdu, &xattr_fidp->path,\n                                     xattr_fidp->fs.xattr.value,\n                                     xattr_fidp->fs.xattr.len);\n            if (err < 0) {\n                clunk_fid(s, xattr_fidp->fid);\n                goto out;\n            }\n        }\n        offset += pdu_marshal(pdu, offset, \"q\", size);\n        err = offset;\n    } else {\n        /*\n         * specific xattr fid. We check for xattr\n         * presence also collect the xattr size\n         */\n        size = v9fs_co_lgetxattr(pdu, &xattr_fidp->path,\n                                 &name, NULL, 0);\n        if (size < 0) {\n            err = size;\n            clunk_fid(s, xattr_fidp->fid);\n            goto out;\n        }\n        /*\n         * Read the xattr value\n         */\n        xattr_fidp->fs.xattr.len = size;\n        xattr_fidp->fid_type = P9_FID_XATTR;\n        xattr_fidp->fs.xattr.copied_len = -1;\n        if (size) {\n            xattr_fidp->fs.xattr.value = g_malloc(size);\n            err = v9fs_co_lgetxattr(pdu, &xattr_fidp->path,\n                                    &name, xattr_fidp->fs.xattr.value,\n                                    xattr_fidp->fs.xattr.len);\n            if (err < 0) {\n                clunk_fid(s, xattr_fidp->fid);\n                goto out;\n            }\n        }\n        offset += pdu_marshal(pdu, offset, \"q\", size);\n        err = offset;\n    }\nout:\n    put_fid(pdu, file_fidp);\n    if (xattr_fidp) {\n        put_fid(pdu, xattr_fidp);\n    }\nout_nofid:\n    trace_v9fs_xattrwalk_return(pdu->tag, pdu->id, size);\n    complete_pdu(s, pdu, err);\n    v9fs_string_free(&name);\n}", "idx": 26210}
{"project": "qemu", "commit_id": "1d5bf692e55ae22b59083741d521e27db704846d", "target": 1, "func": "static void vfio_listener_region_del(MemoryListener *listener,\n\n                                     MemoryRegionSection *section)\n\n{\n\n    VFIOContainer *container = container_of(listener, VFIOContainer,\n\n                                            iommu_data.listener);\n\n    hwaddr iova, end;\n\n    int ret;\n\n\n\n    if (vfio_listener_skipped_section(section)) {\n\n        DPRINTF(\"SKIPPING region_del %\"HWADDR_PRIx\" - %\"PRIx64\"\\n\",\n\n                section->offset_within_address_space,\n\n                section->offset_within_address_space + section->size - 1);\n\n        return;\n\n    }\n\n\n\n    if (unlikely((section->offset_within_address_space & ~TARGET_PAGE_MASK) !=\n\n                 (section->offset_within_region & ~TARGET_PAGE_MASK))) {\n\n        error_report(\"%s received unaligned region\", __func__);\n\n        return;\n\n    }\n\n\n\n    iova = TARGET_PAGE_ALIGN(section->offset_within_address_space);\n\n    end = (section->offset_within_address_space + int128_get64(section->size)) &\n\n          TARGET_PAGE_MASK;\n\n\n\n    if (iova >= end) {\n\n        return;\n\n    }\n\n\n\n    DPRINTF(\"region_del %\"HWADDR_PRIx\" - %\"HWADDR_PRIx\"\\n\",\n\n            iova, end - 1);\n\n\n\n    ret = vfio_dma_unmap(container, iova, end - iova);\n\n    memory_region_unref(section->mr);\n\n    if (ret) {\n\n        error_report(\"vfio_dma_unmap(%p, 0x%\"HWADDR_PRIx\", \"\n\n                     \"0x%\"HWADDR_PRIx\") = %d (%m)\",\n\n                     container, iova, end - iova, ret);\n\n    }\n\n}\n", "idx": 26213}
{"project": "qemu", "commit_id": "384acbf46b70edf0d2c1648aa1a92a90bcf7057d", "target": 0, "func": "static int qemu_laio_process_requests(void *opaque)\n\n{\n\n    struct qemu_laio_state *s = opaque;\n\n    struct qemu_laiocb *laiocb, *next;\n\n    int res = 0;\n\n\n\n    QLIST_FOREACH_SAFE (laiocb, &s->completed_reqs, node, next) {\n\n        if (laiocb->async_context_id == get_async_context_id()) {\n\n            qemu_laio_process_completion(s, laiocb);\n\n            QLIST_REMOVE(laiocb, node);\n\n            res = 1;\n\n        }\n\n    }\n\n\n\n    return res;\n\n}\n", "idx": 26216}
{"project": "qemu", "commit_id": "bff3063837a76b37a4bbbfe614324ca38e859f2b", "target": 0, "func": "static void event_scan(PowerPCCPU *cpu, sPAPRMachineState *spapr,\n\n                       uint32_t token, uint32_t nargs,\n\n                       target_ulong args,\n\n                       uint32_t nret, target_ulong rets)\n\n{\n\n    uint32_t mask, buf, len, event_len;\n\n    sPAPREventLogEntry *event;\n\n    struct rtas_error_log *hdr;\n\n\n\n    if (nargs != 4 || nret != 1) {\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    mask = rtas_ld(args, 0);\n\n    buf = rtas_ld(args, 2);\n\n    len = rtas_ld(args, 3);\n\n\n\n    event = rtas_event_log_dequeue(mask, false);\n\n    if (!event) {\n\n        goto out_no_events;\n\n    }\n\n\n\n    hdr = event->data;\n\n    event_len = be32_to_cpu(hdr->extended_length) + sizeof(*hdr);\n\n\n\n    if (event_len < len) {\n\n        len = event_len;\n\n    }\n\n\n\n    cpu_physical_memory_write(buf, event->data, len);\n\n    rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n    g_free(event->data);\n\n    g_free(event);\n\n    return;\n\n\n\nout_no_events:\n\n    rtas_st(rets, 0, RTAS_OUT_NO_ERRORS_FOUND);\n\n}\n", "idx": 26217}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void sysbus_esp_mem_write(void *opaque, target_phys_addr_t addr,\n\n                                 uint64_t val, unsigned int size)\n\n{\n\n    SysBusESPState *sysbus = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = addr >> sysbus->it_shift;\n\n    esp_reg_write(&sysbus->esp, saddr, val);\n\n}\n", "idx": 26218}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static int wm8750_tx(I2CSlave *i2c, uint8_t data)\n\n{\n\n    WM8750State *s = WM8750(i2c);\n\n    uint8_t cmd;\n\n    uint16_t value;\n\n\n\n    if (s->i2c_len >= 2) {\n\n#ifdef VERBOSE\n\n        printf(\"%s: long message (%i bytes)\\n\", __func__, s->i2c_len);\n\n#endif\n\n        return 1;\n\n    }\n\n    s->i2c_data[s->i2c_len ++] = data;\n\n    if (s->i2c_len != 2)\n\n        return 0;\n\n\n\n    cmd = s->i2c_data[0] >> 1;\n\n    value = ((s->i2c_data[0] << 8) | s->i2c_data[1]) & 0x1ff;\n\n\n\n    switch (cmd) {\n\n    case WM8750_LADCIN:\t/* ADC Signal Path Control (Left) */\n\n        s->diff[0] = (((value >> 6) & 3) == 3);\t/* LINSEL */\n\n        if (s->diff[0])\n\n            s->in[0] = &s->adc_voice[0 + s->ds * 1];\n\n        else\n\n            s->in[0] = &s->adc_voice[((value >> 6) & 3) * 1 + 0];\n\n        break;\n\n\n\n    case WM8750_RADCIN:\t/* ADC Signal Path Control (Right) */\n\n        s->diff[1] = (((value >> 6) & 3) == 3);\t/* RINSEL */\n\n        if (s->diff[1])\n\n            s->in[1] = &s->adc_voice[0 + s->ds * 1];\n\n        else\n\n            s->in[1] = &s->adc_voice[((value >> 6) & 3) * 1 + 0];\n\n        break;\n\n\n\n    case WM8750_ADCIN:\t/* ADC Input Mode */\n\n        s->ds = (value >> 8) & 1;\t/* DS */\n\n        if (s->diff[0])\n\n            s->in[0] = &s->adc_voice[0 + s->ds * 1];\n\n        if (s->diff[1])\n\n            s->in[1] = &s->adc_voice[0 + s->ds * 1];\n\n        s->monomix[0] = (value >> 6) & 3;\t/* MONOMIX */\n\n        break;\n\n\n\n    case WM8750_ADCTL1:\t/* Additional Control (1) */\n\n        s->monomix[1] = (value >> 1) & 1;\t/* DMONOMIX */\n\n        break;\n\n\n\n    case WM8750_PWR1:\t/* Power Management (1) */\n\n        s->enable = ((value >> 6) & 7) == 3;\t/* VMIDSEL, VREF */\n\n        wm8750_set_format(s);\n\n        break;\n\n\n\n    case WM8750_LINVOL:\t/* Left Channel PGA */\n\n        s->invol[0] = value & 0x3f;\t\t/* LINVOL */\n\n        s->inmute[0] = (value >> 7) & 1;\t/* LINMUTE */\n\n        wm8750_vol_update(s);\n\n        break;\n\n\n\n    case WM8750_RINVOL:\t/* Right Channel PGA */\n\n        s->invol[1] = value & 0x3f;\t\t/* RINVOL */\n\n        s->inmute[1] = (value >> 7) & 1;\t/* RINMUTE */\n\n        wm8750_vol_update(s);\n\n        break;\n\n\n\n    case WM8750_ADCDAC:\t/* ADC and DAC Control */\n\n        s->pol = (value >> 5) & 3;\t\t/* ADCPOL */\n\n        s->mute = (value >> 3) & 1;\t\t/* DACMU */\n\n        wm8750_vol_update(s);\n\n        break;\n\n\n\n    case WM8750_ADCTL3:\t/* Additional Control (3) */\n\n        break;\n\n\n\n    case WM8750_LADC:\t/* Left ADC Digital Volume */\n\n        s->invol[2] = value & 0xff;\t\t/* LADCVOL */\n\n        wm8750_vol_update(s);\n\n        break;\n\n\n\n    case WM8750_RADC:\t/* Right ADC Digital Volume */\n\n        s->invol[3] = value & 0xff;\t\t/* RADCVOL */\n\n        wm8750_vol_update(s);\n\n        break;\n\n\n\n    case WM8750_ALC1:\t/* ALC Control (1) */\n\n        s->alc = (value >> 7) & 3;\t\t/* ALCSEL */\n\n        break;\n\n\n\n    case WM8750_NGATE:\t/* Noise Gate Control */\n\n    case WM8750_3D:\t/* 3D enhance */\n\n        break;\n\n\n\n    case WM8750_LDAC:\t/* Left Channel Digital Volume */\n\n        s->outvol[0] = value & 0xff;\t\t/* LDACVOL */\n\n        wm8750_vol_update(s);\n\n        break;\n\n\n\n    case WM8750_RDAC:\t/* Right Channel Digital Volume */\n\n        s->outvol[1] = value & 0xff;\t\t/* RDACVOL */\n\n        wm8750_vol_update(s);\n\n        break;\n\n\n\n    case WM8750_BASS:\t/* Bass Control */\n\n        break;\n\n\n\n    case WM8750_LOUTM1:\t/* Left Mixer Control (1) */\n\n        s->path[0] = (value >> 8) & 1;\t\t/* LD2LO */\n\n        /* TODO: mute/unmute respective paths */\n\n        wm8750_vol_update(s);\n\n        break;\n\n\n\n    case WM8750_LOUTM2:\t/* Left Mixer Control (2) */\n\n        s->path[1] = (value >> 8) & 1;\t\t/* RD2LO */\n\n        /* TODO: mute/unmute respective paths */\n\n        wm8750_vol_update(s);\n\n        break;\n\n\n\n    case WM8750_ROUTM1:\t/* Right Mixer Control (1) */\n\n        s->path[2] = (value >> 8) & 1;\t\t/* LD2RO */\n\n        /* TODO: mute/unmute respective paths */\n\n        wm8750_vol_update(s);\n\n        break;\n\n\n\n    case WM8750_ROUTM2:\t/* Right Mixer Control (2) */\n\n        s->path[3] = (value >> 8) & 1;\t\t/* RD2RO */\n\n        /* TODO: mute/unmute respective paths */\n\n        wm8750_vol_update(s);\n\n        break;\n\n\n\n    case WM8750_MOUTM1:\t/* Mono Mixer Control (1) */\n\n        s->mpath[0] = (value >> 8) & 1;\t\t/* LD2MO */\n\n        /* TODO: mute/unmute respective paths */\n\n        wm8750_vol_update(s);\n\n        break;\n\n\n\n    case WM8750_MOUTM2:\t/* Mono Mixer Control (2) */\n\n        s->mpath[1] = (value >> 8) & 1;\t\t/* RD2MO */\n\n        /* TODO: mute/unmute respective paths */\n\n        wm8750_vol_update(s);\n\n        break;\n\n\n\n    case WM8750_LOUT1V:\t/* LOUT1 Volume */\n\n        s->outvol[2] = value & 0x7f;\t\t/* LOUT1VOL */\n\n        wm8750_vol_update(s);\n\n        break;\n\n\n\n    case WM8750_LOUT2V:\t/* LOUT2 Volume */\n\n        s->outvol[4] = value & 0x7f;\t\t/* LOUT2VOL */\n\n        wm8750_vol_update(s);\n\n        break;\n\n\n\n    case WM8750_ROUT1V:\t/* ROUT1 Volume */\n\n        s->outvol[3] = value & 0x7f;\t\t/* ROUT1VOL */\n\n        wm8750_vol_update(s);\n\n        break;\n\n\n\n    case WM8750_ROUT2V:\t/* ROUT2 Volume */\n\n        s->outvol[5] = value & 0x7f;\t\t/* ROUT2VOL */\n\n        wm8750_vol_update(s);\n\n        break;\n\n\n\n    case WM8750_MOUTV:\t/* MONOOUT Volume */\n\n        s->outvol[6] = value & 0x7f;\t\t/* MONOOUTVOL */\n\n        wm8750_vol_update(s);\n\n        break;\n\n\n\n    case WM8750_ADCTL2:\t/* Additional Control (2) */\n\n        break;\n\n\n\n    case WM8750_PWR2:\t/* Power Management (2) */\n\n        s->power = value & 0x7e;\n\n        /* TODO: mute/unmute respective paths */\n\n        wm8750_vol_update(s);\n\n        break;\n\n\n\n    case WM8750_IFACE:\t/* Digital Audio Interface Format */\n\n        s->format = value;\n\n        s->master = (value >> 6) & 1;\t\t\t/* MS */\n\n        wm8750_clk_update(s, s->master);\n\n        break;\n\n\n\n    case WM8750_SRATE:\t/* Clocking and Sample Rate Control */\n\n        s->rate = &wm_rate_table[(value >> 1) & 0x1f];\n\n        wm8750_clk_update(s, 0);\n\n        break;\n\n\n\n    case WM8750_RESET:\t/* Reset */\n\n        wm8750_reset(I2C_SLAVE(s));\n\n        break;\n\n\n\n#ifdef VERBOSE\n\n    default:\n\n        printf(\"%s: unknown register %02x\\n\", __FUNCTION__, cmd);\n\n#endif\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 26220}
{"project": "qemu", "commit_id": "7bd427d801e1e3293a634d3c83beadaa90ffb911", "target": 0, "func": "static int protocol_client_msg(VncState *vs, uint8_t *data, size_t len)\n\n{\n\n    int i;\n\n    uint16_t limit;\n\n    VncDisplay *vd = vs->vd;\n\n\n\n    if (data[0] > 3) {\n\n        vd->timer_interval = VNC_REFRESH_INTERVAL_BASE;\n\n        if (!qemu_timer_expired(vd->timer, qemu_get_clock(rt_clock) + vd->timer_interval))\n\n            qemu_mod_timer(vd->timer, qemu_get_clock(rt_clock) + vd->timer_interval);\n\n    }\n\n\n\n    switch (data[0]) {\n\n    case VNC_MSG_CLIENT_SET_PIXEL_FORMAT:\n\n        if (len == 1)\n\n            return 20;\n\n\n\n        set_pixel_format(vs, read_u8(data, 4), read_u8(data, 5),\n\n                         read_u8(data, 6), read_u8(data, 7),\n\n                         read_u16(data, 8), read_u16(data, 10),\n\n                         read_u16(data, 12), read_u8(data, 14),\n\n                         read_u8(data, 15), read_u8(data, 16));\n\n        break;\n\n    case VNC_MSG_CLIENT_SET_ENCODINGS:\n\n        if (len == 1)\n\n            return 4;\n\n\n\n        if (len == 4) {\n\n            limit = read_u16(data, 2);\n\n            if (limit > 0)\n\n                return 4 + (limit * 4);\n\n        } else\n\n            limit = read_u16(data, 2);\n\n\n\n        for (i = 0; i < limit; i++) {\n\n            int32_t val = read_s32(data, 4 + (i * 4));\n\n            memcpy(data + 4 + (i * 4), &val, sizeof(val));\n\n        }\n\n\n\n        set_encodings(vs, (int32_t *)(data + 4), limit);\n\n        break;\n\n    case VNC_MSG_CLIENT_FRAMEBUFFER_UPDATE_REQUEST:\n\n        if (len == 1)\n\n            return 10;\n\n\n\n        framebuffer_update_request(vs,\n\n                                   read_u8(data, 1), read_u16(data, 2), read_u16(data, 4),\n\n                                   read_u16(data, 6), read_u16(data, 8));\n\n        break;\n\n    case VNC_MSG_CLIENT_KEY_EVENT:\n\n        if (len == 1)\n\n            return 8;\n\n\n\n        key_event(vs, read_u8(data, 1), read_u32(data, 4));\n\n        break;\n\n    case VNC_MSG_CLIENT_POINTER_EVENT:\n\n        if (len == 1)\n\n            return 6;\n\n\n\n        pointer_event(vs, read_u8(data, 1), read_u16(data, 2), read_u16(data, 4));\n\n        break;\n\n    case VNC_MSG_CLIENT_CUT_TEXT:\n\n        if (len == 1)\n\n            return 8;\n\n\n\n        if (len == 8) {\n\n            uint32_t dlen = read_u32(data, 4);\n\n            if (dlen > 0)\n\n                return 8 + dlen;\n\n        }\n\n\n\n        client_cut_text(vs, read_u32(data, 4), data + 8);\n\n        break;\n\n    case VNC_MSG_CLIENT_QEMU:\n\n        if (len == 1)\n\n            return 2;\n\n\n\n        switch (read_u8(data, 1)) {\n\n        case VNC_MSG_CLIENT_QEMU_EXT_KEY_EVENT:\n\n            if (len == 2)\n\n                return 12;\n\n\n\n            ext_key_event(vs, read_u16(data, 2),\n\n                          read_u32(data, 4), read_u32(data, 8));\n\n            break;\n\n        case VNC_MSG_CLIENT_QEMU_AUDIO:\n\n            if (len == 2)\n\n                return 4;\n\n\n\n            switch (read_u16 (data, 2)) {\n\n            case VNC_MSG_CLIENT_QEMU_AUDIO_ENABLE:\n\n                audio_add(vs);\n\n                break;\n\n            case VNC_MSG_CLIENT_QEMU_AUDIO_DISABLE:\n\n                audio_del(vs);\n\n                break;\n\n            case VNC_MSG_CLIENT_QEMU_AUDIO_SET_FORMAT:\n\n                if (len == 4)\n\n                    return 10;\n\n                switch (read_u8(data, 4)) {\n\n                case 0: vs->as.fmt = AUD_FMT_U8; break;\n\n                case 1: vs->as.fmt = AUD_FMT_S8; break;\n\n                case 2: vs->as.fmt = AUD_FMT_U16; break;\n\n                case 3: vs->as.fmt = AUD_FMT_S16; break;\n\n                case 4: vs->as.fmt = AUD_FMT_U32; break;\n\n                case 5: vs->as.fmt = AUD_FMT_S32; break;\n\n                default:\n\n                    printf(\"Invalid audio format %d\\n\", read_u8(data, 4));\n\n                    vnc_client_error(vs);\n\n                    break;\n\n                }\n\n                vs->as.nchannels = read_u8(data, 5);\n\n                if (vs->as.nchannels != 1 && vs->as.nchannels != 2) {\n\n                    printf(\"Invalid audio channel coount %d\\n\",\n\n                           read_u8(data, 5));\n\n                    vnc_client_error(vs);\n\n                    break;\n\n                }\n\n                vs->as.freq = read_u32(data, 6);\n\n                break;\n\n            default:\n\n                printf (\"Invalid audio message %d\\n\", read_u8(data, 4));\n\n                vnc_client_error(vs);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            printf(\"Msg: %d\\n\", read_u16(data, 0));\n\n            vnc_client_error(vs);\n\n            break;\n\n        }\n\n        break;\n\n    default:\n\n        printf(\"Msg: %d\\n\", data[0]);\n\n        vnc_client_error(vs);\n\n        break;\n\n    }\n\n\n\n    vnc_read_when(vs, protocol_client_msg, 1);\n\n    return 0;\n\n}\n", "idx": 26221}
{"project": "qemu", "commit_id": "9a78eead0c74333a394c0f7bbfc4423ac746fcd5", "target": 0, "func": "void ppc_cpu_list (FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))\n\n{\n\n    int i, max;\n\n\n\n    max = ARRAY_SIZE(ppc_defs);\n\n    for (i = 0; i < max; i++) {\n\n        (*cpu_fprintf)(f, \"PowerPC %-16s PVR %08x\\n\",\n\n                       ppc_defs[i].name, ppc_defs[i].pvr);\n\n    }\n\n}\n", "idx": 26222}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "func": "static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)\n\n{\n\n    char buffer[PATH_MAX];\n\n    char *path = fs_path->data;\n\n\n\n    return truncate(rpath(ctx, path, buffer), size);\n\n}\n", "idx": 26223}
{"project": "qemu", "commit_id": "41bf234d8e35e9273290df278e2aeb88c0c50a4f", "target": 0, "func": "static void gic_update(gic_state *s)\n\n{\n\n    int best_irq;\n\n    int best_prio;\n\n    int irq;\n\n    int level;\n\n    int cpu;\n\n    int cm;\n\n\n\n    for (cpu = 0; cpu < NUM_CPU(s); cpu++) {\n\n        cm = 1 << cpu;\n\n        s->current_pending[cpu] = 1023;\n\n        if (!s->enabled || !s->cpu_enabled[cpu]) {\n\n\t    qemu_irq_lower(s->parent_irq[cpu]);\n\n            return;\n\n        }\n\n        best_prio = 0x100;\n\n        best_irq = 1023;\n\n        for (irq = 0; irq < GIC_NIRQ; irq++) {\n\n            if (GIC_TEST_ENABLED(irq) && GIC_TEST_PENDING(irq, cm)) {\n\n                if (GIC_GET_PRIORITY(irq, cpu) < best_prio) {\n\n                    best_prio = GIC_GET_PRIORITY(irq, cpu);\n\n                    best_irq = irq;\n\n                }\n\n            }\n\n        }\n\n        level = 0;\n\n        if (best_prio <= s->priority_mask[cpu]) {\n\n            s->current_pending[cpu] = best_irq;\n\n            if (best_prio < s->running_priority[cpu]) {\n\n                DPRINTF(\"Raised pending IRQ %d\\n\", best_irq);\n\n                level = 1;\n\n            }\n\n        }\n\n        qemu_set_irq(s->parent_irq[cpu], level);\n\n    }\n\n}\n", "idx": 26224}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void *rom_ptr(target_phys_addr_t addr)\n\n{\n\n    Rom *rom;\n\n\n\n    rom = find_rom(addr);\n\n    if (!rom || !rom->data)\n\n        return NULL;\n\n    return rom->data + (addr - rom->addr);\n\n}\n", "idx": 26225}
{"project": "qemu", "commit_id": "90e56fb46d0a7add88ed463efa4e723a6238f692", "target": 0, "func": "static void *do_data_decompress(void *opaque)\n\n{\n\n    DecompressParam *param = opaque;\n\n    unsigned long pagesize;\n\n\n\n    while (!quit_decomp_thread) {\n\n        qemu_mutex_lock(&param->mutex);\n\n        while (!param->start && !quit_decomp_thread) {\n\n            qemu_cond_wait(&param->cond, &param->mutex);\n\n        }\n\n        if (!quit_decomp_thread) {\n\n            pagesize = TARGET_PAGE_SIZE;\n\n            /* uncompress() will return failed in some case, especially\n\n             * when the page is dirted when doing the compression, it's\n\n             * not a problem because the dirty page will be retransferred\n\n             * and uncompress() won't break the data in other pages.\n\n             */\n\n            uncompress((Bytef *)param->des, &pagesize,\n\n                       (const Bytef *)param->compbuf, param->len);\n\n        }\n\n        param->start = false;\n\n        qemu_mutex_unlock(&param->mutex);\n\n\n\n        qemu_mutex_lock(&decomp_done_lock);\n\n        param->done = true;\n\n        qemu_cond_signal(&decomp_done_cond);\n\n        qemu_mutex_unlock(&decomp_done_lock);\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 26226}
{"project": "qemu", "commit_id": "298a1665a2800f7264e483c2dd1f551574243a2f", "target": 0, "func": "static bool is_zero_sectors(BlockDriverState *bs, int64_t start,\n\n                            uint32_t count)\n\n{\n\n    int nr;\n\n    BlockDriverState *file;\n\n    int64_t res;\n\n\n\n    if (start + count > bs->total_sectors) {\n\n        count = bs->total_sectors - start;\n\n    }\n\n\n\n    if (!count) {\n\n        return true;\n\n    }\n\n    res = bdrv_get_block_status_above(bs, NULL, start, count,\n\n                                      &nr, &file);\n\n    return res >= 0 && (res & BDRV_BLOCK_ZERO) && nr == count;\n\n}\n", "idx": 26227}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "static void *kqemu_vmalloc(size_t size)\n\n{\n\n    static int phys_ram_fd = -1;\n\n    static int phys_ram_size = 0;\n\n    void *ptr;\n\n\n\n/* no need (?) for a dummy file on OpenBSD/FreeBSD */\n\n#if defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__DragonFly__)\n\n    int map_anon = MAP_ANON;\n\n#else\n\n    int map_anon = 0;\n\n    const char *tmpdir;\n\n    char phys_ram_file[1024];\n\n#ifdef CONFIG_SOLARIS\n\n    struct statvfs stfs;\n\n#else\n\n    struct statfs stfs;\n\n#endif\n\n\n\n    if (!size) {\n\n        abort ();\n\n    }\n\n\n\n    if (phys_ram_fd < 0) {\n\n        tmpdir = getenv(\"QEMU_TMPDIR\");\n\n        if (!tmpdir)\n\n#ifdef CONFIG_SOLARIS\n\n            tmpdir = \"/tmp\";\n\n        if (statvfs(tmpdir, &stfs) == 0) {\n\n#else\n\n            tmpdir = \"/dev/shm\";\n\n        if (statfs(tmpdir, &stfs) == 0) {\n\n#endif\n\n            int64_t free_space;\n\n            int ram_mb;\n\n\n\n            free_space = (int64_t)stfs.f_bavail * stfs.f_bsize;\n\n            if ((ram_size + 8192 * 1024) >= free_space) {\n\n                ram_mb = (ram_size / (1024 * 1024));\n\n                fprintf(stderr,\n\n                        \"You do not have enough space in '%s' for the %d MB of QEMU virtual RAM.\\n\",\n\n                        tmpdir, ram_mb);\n\n                if (strcmp(tmpdir, \"/dev/shm\") == 0) {\n\n                    fprintf(stderr, \"To have more space available provided you have enough RAM and swap, do as root:\\n\"\n\n                            \"mount -o remount,size=%dm /dev/shm\\n\",\n\n                            ram_mb + 16);\n\n                } else {\n\n                    fprintf(stderr,\n\n                            \"Use the '-m' option of QEMU to diminish the amount of virtual RAM or use the\\n\"\n\n                            \"QEMU_TMPDIR environment variable to set another directory where the QEMU\\n\"\n\n                            \"temporary RAM file will be opened.\\n\");\n\n                }\n\n                fprintf(stderr, \"Or disable the accelerator module with -no-kqemu\\n\");\n\n                exit(1);\n\n            }\n\n        }\n\n        snprintf(phys_ram_file, sizeof(phys_ram_file), \"%s/qemuXXXXXX\",\n\n                 tmpdir);\n\n        phys_ram_fd = mkstemp(phys_ram_file);\n\n        if (phys_ram_fd < 0) {\n\n            fprintf(stderr,\n\n                    \"warning: could not create temporary file in '%s'.\\n\"\n\n                    \"Use QEMU_TMPDIR to select a directory in a tmpfs filesystem.\\n\"\n\n                    \"Using '/tmp' as fallback.\\n\",\n\n                    tmpdir);\n\n            snprintf(phys_ram_file, sizeof(phys_ram_file), \"%s/qemuXXXXXX\",\n\n                     \"/tmp\");\n\n            phys_ram_fd = mkstemp(phys_ram_file);\n\n            if (phys_ram_fd < 0) {\n\n                fprintf(stderr, \"Could not create temporary memory file '%s'\\n\",\n\n                        phys_ram_file);\n\n                exit(1);\n\n            }\n\n        }\n\n        unlink(phys_ram_file);\n\n    }\n\n    size = (size + 4095) & ~4095;\n\n    ftruncate(phys_ram_fd, phys_ram_size + size);\n\n#endif /* !(__OpenBSD__ || __FreeBSD__ || __DragonFly__) */\n\n    ptr = mmap(NULL,\n\n               size,\n\n               PROT_WRITE | PROT_READ, map_anon | MAP_SHARED,\n\n               phys_ram_fd, phys_ram_size);\n\n    if (ptr == MAP_FAILED) {\n\n        fprintf(stderr, \"Could not map physical memory\\n\");\n\n        exit(1);\n\n    }\n\n    phys_ram_size += size;\n\n    return ptr;\n\n}\n", "idx": 26228}
{"project": "qemu", "commit_id": "8172539d21a03e982aa7f139ddc1607dc1422045", "target": 0, "func": "static uint32_t virtio_console_get_features(VirtIODevice *vdev)\n\n{\n\n    return 0;\n\n}\n", "idx": 26229}
{"project": "qemu", "commit_id": "e69a17f65e9f12f33c48b04a789e49d40a8993f5", "target": 0, "func": "static inline void IRQ_setbit(IRQQueue *q, int n_IRQ)\n\n{\n\n    set_bit(q->queue, n_IRQ);\n\n}\n", "idx": 26232}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static void sdl_callback (void *opaque, Uint8 *buf, int len)\n\n{\n\n    SDLVoiceOut *sdl = opaque;\n\n    SDLAudioState *s = &glob_sdl;\n\n    HWVoiceOut *hw = &sdl->hw;\n\n    int samples = len >> hw->info.shift;\n\n\n\n    if (s->exit) {\n\n        return;\n\n    }\n\n\n\n    while (samples) {\n\n        int to_mix, decr;\n\n\n\n        /* dolog (\"in callback samples=%d\\n\", samples); */\n\n        sdl_wait (s, \"sdl_callback\");\n\n        if (s->exit) {\n\n            return;\n\n        }\n\n\n\n        if (sdl_lock (s, \"sdl_callback\")) {\n\n            return;\n\n        }\n\n\n\n        if (audio_bug (AUDIO_FUNC, sdl->live < 0 || sdl->live > hw->samples)) {\n\n            dolog (\"sdl->live=%d hw->samples=%d\\n\",\n\n                   sdl->live, hw->samples);\n\n            return;\n\n        }\n\n\n\n        if (!sdl->live) {\n\n            goto again;\n\n        }\n\n\n\n        /* dolog (\"in callback live=%d\\n\", live); */\n\n        to_mix = audio_MIN (samples, sdl->live);\n\n        decr = to_mix;\n\n        while (to_mix) {\n\n            int chunk = audio_MIN (to_mix, hw->samples - hw->rpos);\n\n            st_sample_t *src = hw->mix_buf + hw->rpos;\n\n\n\n            /* dolog (\"in callback to_mix %d, chunk %d\\n\", to_mix, chunk); */\n\n            hw->clip (buf, src, chunk);\n\n            sdl->rpos = (sdl->rpos + chunk) % hw->samples;\n\n            to_mix -= chunk;\n\n            buf += chunk << hw->info.shift;\n\n        }\n\n        samples -= decr;\n\n        sdl->live -= decr;\n\n        sdl->decr += decr;\n\n\n\n    again:\n\n        if (sdl_unlock (s, \"sdl_callback\")) {\n\n            return;\n\n        }\n\n    }\n\n    /* dolog (\"done len=%d\\n\", len); */\n\n}\n", "idx": 26233}
{"project": "qemu", "commit_id": "016d2e1dfa21b64a524d3629fdd317d4c25bc3b8", "target": 1, "func": "long do_sigreturn(CPUSH4State *regs)\n\n{\n\n    struct target_sigframe *frame;\n\n    abi_ulong frame_addr;\n\n    sigset_t blocked;\n\n    target_sigset_t target_set;\n\n    target_ulong r0;\n\n    int i;\n\n    int err = 0;\n\n\n\n#if defined(DEBUG_SIGNAL)\n\n    fprintf(stderr, \"do_sigreturn\\n\");\n\n#endif\n\n    frame_addr = regs->gregs[15];\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))\n\n   \tgoto badframe;\n\n\n\n    __get_user(target_set.sig[0], &frame->sc.oldmask);\n\n    for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n        __get_user(target_set.sig[i], &frame->extramask[i - 1]);\n\n    }\n\n\n\n    if (err)\n\n        goto badframe;\n\n\n\n    target_to_host_sigset_internal(&blocked, &target_set);\n\n    do_sigprocmask(SIG_SETMASK, &blocked, NULL);\n\n\n\n    if (restore_sigcontext(regs, &frame->sc, &r0))\n\n        goto badframe;\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return r0;\n\n\n\nbadframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n", "idx": 26234}
{"project": "qemu", "commit_id": "5dd7a535b71a0f2f8e7af75c5d694174359ce323", "target": 1, "func": "static void iscsi_nop_timed_event(void *opaque)\n\n{\n\n    IscsiLun *iscsilun = opaque;\n\n\n\n    if (iscsi_get_nops_in_flight(iscsilun->iscsi) > MAX_NOP_FAILURES) {\n\n        error_report(\"iSCSI: NOP timeout. Reconnecting...\");\n\n        iscsi_reconnect(iscsilun->iscsi);\n\n    }\n\n\n\n    if (iscsi_nop_out_async(iscsilun->iscsi, NULL, NULL, 0, NULL) != 0) {\n\n        error_report(\"iSCSI: failed to sent NOP-Out. Disabling NOP messages.\");\n\n        return;\n\n    }\n\n\n\n    timer_mod(iscsilun->nop_timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + NOP_INTERVAL);\n\n    iscsi_set_events(iscsilun);\n\n}\n", "idx": 26237}
{"project": "qemu", "commit_id": "403e633126b7a781ecd48a29e3355770d46bbf1a", "target": 1, "func": "void qemu_thread_get_self(QemuThread *thread)\n\n{\n\n    if (!thread->thread) {\n\n        /* In the main thread of the process.  Initialize the QemuThread\n\n           pointer in TLS, and use the dummy GetCurrentThread handle as\n\n           the identifier for qemu_thread_is_self.  */\n\n        qemu_thread_init();\n\n        TlsSetValue(qemu_thread_tls_index, thread);\n\n        thread->thread = GetCurrentThread();\n\n    }\n\n}\n", "idx": 26238}
{"project": "qemu", "commit_id": "480cff632221dc4d4889bf72dd0f09cd35096bc1", "target": 1, "func": "static void coroutine_fn qemu_co_mutex_lock_slowpath(CoMutex *mutex)\n\n{\n\n    Coroutine *self = qemu_coroutine_self();\n\n    CoWaitRecord w;\n\n    unsigned old_handoff;\n\n\n\n    trace_qemu_co_mutex_lock_entry(mutex, self);\n\n    w.co = self;\n\n    push_waiter(mutex, &w);\n\n\n\n    /* This is the \"Responsibility Hand-Off\" protocol; a lock() picks from\n\n     * a concurrent unlock() the responsibility of waking somebody up.\n\n     */\n\n    old_handoff = atomic_mb_read(&mutex->handoff);\n\n    if (old_handoff &&\n\n        has_waiters(mutex) &&\n\n        atomic_cmpxchg(&mutex->handoff, old_handoff, 0) == old_handoff) {\n\n        /* There can be no concurrent pops, because there can be only\n\n         * one active handoff at a time.\n\n         */\n\n        CoWaitRecord *to_wake = pop_waiter(mutex);\n\n        Coroutine *co = to_wake->co;\n\n        if (co == self) {\n\n            /* We got the lock ourselves!  */\n\n            assert(to_wake == &w);\n\n            return;\n\n        }\n\n\n\n        aio_co_wake(co);\n\n    }\n\n\n\n    qemu_coroutine_yield();\n\n    trace_qemu_co_mutex_lock_return(mutex, self);\n\n}\n", "idx": 26239}
{"project": "qemu", "commit_id": "e4a3507e86a1ef1453d603031bca27d5ac4cff3c", "target": 0, "func": "static ssize_t block_crypto_write_func(QCryptoBlock *block,\n\n                                       void *opaque,\n\n                                       size_t offset,\n\n                                       const uint8_t *buf,\n\n                                       size_t buflen,\n\n                                       Error **errp)\n\n{\n\n    struct BlockCryptoCreateData *data = opaque;\n\n    ssize_t ret;\n\n\n\n    ret = blk_pwrite(data->blk, offset, buf, buflen, 0);\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"Could not write encryption header\");\n\n        return ret;\n\n    }\n\n    return ret;\n\n}\n", "idx": 26241}
{"project": "qemu", "commit_id": "b8eb5512fd8a115f164edbbe897cdf8884920ccb", "target": 0, "func": "static void apic_reset_common(DeviceState *dev)\n\n{\n\n    APICCommonState *s = APIC_COMMON(dev);\n\n    APICCommonClass *info = APIC_COMMON_GET_CLASS(s);\n\n    bool bsp;\n\n\n\n    bsp = cpu_is_bsp(s->cpu);\n\n    s->apicbase = APIC_DEFAULT_ADDRESS |\n\n        (bsp ? MSR_IA32_APICBASE_BSP : 0) | MSR_IA32_APICBASE_ENABLE;\n\n\n\n    s->vapic_paddr = 0;\n\n    info->vapic_base_update(s);\n\n\n\n    apic_init_reset(dev);\n\n\n\n    if (bsp) {\n\n        /*\n\n         * LINT0 delivery mode on CPU #0 is set to ExtInt at initialization\n\n         * time typically by BIOS, so PIC interrupt can be delivered to the\n\n         * processor when local APIC is enabled.\n\n         */\n\n        s->lvt[APIC_LVT_LINT0] = 0x700;\n\n    }\n\n}\n", "idx": 26242}
{"project": "qemu", "commit_id": "b854bc196f5c4b4e3299c0b0ee63cf828ece9e77", "target": 0, "func": "static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,\n\n                omap_clk clk)\n\n{\n\n    int iomemtype;\n\n\n\n    s->pwt.base = base;\n\n    s->pwt.clk = clk;\n\n    omap_pwt_reset(s);\n\n\n\n    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,\n\n                    omap_pwt_writefn, s);\n\n    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);\n\n}\n", "idx": 26243}
{"project": "qemu", "commit_id": "d6f4ade214a9f74dca9495b83a24ff9c113e4f9a", "target": 0, "func": "static int qemu_calculate_timeout(void)\n\n{\n\n#ifndef CONFIG_IOTHREAD\n\n    int timeout;\n\n\n\n    if (!vm_running)\n\n        timeout = 5000;\n\n    else if (tcg_has_work())\n\n        timeout = 0;\n\n    else {\n\n     /* XXX: use timeout computed from timers */\n\n        int64_t add;\n\n        int64_t delta;\n\n        /* Advance virtual time to the next event.  */\n\n\tdelta = qemu_icount_delta();\n\n        if (delta > 0) {\n\n            /* If virtual time is ahead of real time then just\n\n               wait for IO.  */\n\n            timeout = (delta + 999999) / 1000000;\n\n        } else {\n\n            /* Wait for either IO to occur or the next\n\n               timer event.  */\n\n            add = qemu_next_deadline();\n\n            /* We advance the timer before checking for IO.\n\n               Limit the amount we advance so that early IO\n\n               activity won't get the guest too far ahead.  */\n\n            if (add > 10000000)\n\n                add = 10000000;\n\n            delta += add;\n\n            qemu_icount += qemu_icount_round (add);\n\n            timeout = delta / 1000000;\n\n            if (timeout < 0)\n\n                timeout = 0;\n\n        }\n\n    }\n\n\n\n    return timeout;\n\n#else /* CONFIG_IOTHREAD */\n\n    return 1000;\n\n#endif\n\n}\n", "idx": 26244}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "int vnc_hextile_send_framebuffer_update(VncState *vs, int x,\n\n                                        int y, int w, int h)\n\n{\n\n    int i, j;\n\n    int has_fg, has_bg;\n\n    uint8_t *last_fg, *last_bg;\n\n    VncDisplay *vd = vs->vd;\n\n\n\n    last_fg = (uint8_t *) qemu_malloc(vd->server->pf.bytes_per_pixel);\n\n    last_bg = (uint8_t *) qemu_malloc(vd->server->pf.bytes_per_pixel);\n\n    has_fg = has_bg = 0;\n\n    for (j = y; j < (y + h); j += 16) {\n\n        for (i = x; i < (x + w); i += 16) {\n\n            vs->send_hextile_tile(vs, i, j,\n\n                                  MIN(16, x + w - i), MIN(16, y + h - j),\n\n                                  last_bg, last_fg, &has_bg, &has_fg);\n\n        }\n\n    }\n\n    free(last_fg);\n\n    free(last_bg);\n\n\n\n    return 1;\n\n}\n", "idx": 26245}
{"project": "qemu", "commit_id": "e280ff5e9159ed227a117339c1157143627cab96", "target": 0, "func": "static int spice_chr_write(CharDriverState *chr, const uint8_t *buf, int len)\n\n{\n\n    SpiceCharDriver *s = chr->opaque;\n\n\n\n    vmc_register_interface(s);\n\n    assert(s->datalen == 0);\n\n    if (s->bufsize < len) {\n\n        s->bufsize = len;\n\n        s->buffer = g_realloc(s->buffer, s->bufsize);\n\n    }\n\n    memcpy(s->buffer, buf, len);\n\n    s->datapos = s->buffer;\n\n    s->datalen = len;\n\n    spice_server_char_device_wakeup(&s->sin);\n\n    return len;\n\n}\n", "idx": 26246}
{"project": "qemu", "commit_id": "68756ba8be2127b6ea30a466af9f78a5c97bc15f", "target": 0, "func": "static int net_slirp_init(NetClientState *peer, const char *model,\n\n                          const char *name, int restricted,\n\n                          const char *vnetwork, const char *vhost,\n\n                          const char *vhostname, const char *tftp_export,\n\n                          const char *bootfile, const char *vdhcp_start,\n\n                          const char *vnameserver, const char *smb_export,\n\n                          const char *vsmbserver, const char **dnssearch)\n\n{\n\n    /* default settings according to historic slirp */\n\n    struct in_addr net  = { .s_addr = htonl(0x0a000200) }; /* 10.0.2.0 */\n\n    struct in_addr mask = { .s_addr = htonl(0xffffff00) }; /* 255.255.255.0 */\n\n    struct in_addr host = { .s_addr = htonl(0x0a000202) }; /* 10.0.2.2 */\n\n    struct in_addr dhcp = { .s_addr = htonl(0x0a00020f) }; /* 10.0.2.15 */\n\n    struct in_addr dns  = { .s_addr = htonl(0x0a000203) }; /* 10.0.2.3 */\n\n#ifndef _WIN32\n\n    struct in_addr smbsrv = { .s_addr = 0 };\n\n#endif\n\n    NetClientState *nc;\n\n    SlirpState *s;\n\n    char buf[20];\n\n    uint32_t addr;\n\n    int shift;\n\n    char *end;\n\n    struct slirp_config_str *config;\n\n\n\n    if (!tftp_export) {\n\n        tftp_export = legacy_tftp_prefix;\n\n    }\n\n    if (!bootfile) {\n\n        bootfile = legacy_bootp_filename;\n\n    }\n\n\n\n    if (vnetwork) {\n\n        if (get_str_sep(buf, sizeof(buf), &vnetwork, '/') < 0) {\n\n            if (!inet_aton(vnetwork, &net)) {\n\n                return -1;\n\n            }\n\n            addr = ntohl(net.s_addr);\n\n            if (!(addr & 0x80000000)) {\n\n                mask.s_addr = htonl(0xff000000); /* class A */\n\n            } else if ((addr & 0xfff00000) == 0xac100000) {\n\n                mask.s_addr = htonl(0xfff00000); /* priv. 172.16.0.0/12 */\n\n            } else if ((addr & 0xc0000000) == 0x80000000) {\n\n                mask.s_addr = htonl(0xffff0000); /* class B */\n\n            } else if ((addr & 0xffff0000) == 0xc0a80000) {\n\n                mask.s_addr = htonl(0xffff0000); /* priv. 192.168.0.0/16 */\n\n            } else if ((addr & 0xffff0000) == 0xc6120000) {\n\n                mask.s_addr = htonl(0xfffe0000); /* tests 198.18.0.0/15 */\n\n            } else if ((addr & 0xe0000000) == 0xe0000000) {\n\n                mask.s_addr = htonl(0xffffff00); /* class C */\n\n            } else {\n\n                mask.s_addr = htonl(0xfffffff0); /* multicast/reserved */\n\n            }\n\n        } else {\n\n            if (!inet_aton(buf, &net)) {\n\n                return -1;\n\n            }\n\n            shift = strtol(vnetwork, &end, 10);\n\n            if (*end != '\\0') {\n\n                if (!inet_aton(vnetwork, &mask)) {\n\n                    return -1;\n\n                }\n\n            } else if (shift < 4 || shift > 32) {\n\n                return -1;\n\n            } else {\n\n                mask.s_addr = htonl(0xffffffff << (32 - shift));\n\n            }\n\n        }\n\n        net.s_addr &= mask.s_addr;\n\n        host.s_addr = net.s_addr | (htonl(0x0202) & ~mask.s_addr);\n\n        dhcp.s_addr = net.s_addr | (htonl(0x020f) & ~mask.s_addr);\n\n        dns.s_addr  = net.s_addr | (htonl(0x0203) & ~mask.s_addr);\n\n    }\n\n\n\n    if (vhost && !inet_aton(vhost, &host)) {\n\n        return -1;\n\n    }\n\n    if ((host.s_addr & mask.s_addr) != net.s_addr) {\n\n        return -1;\n\n    }\n\n\n\n    if (vdhcp_start && !inet_aton(vdhcp_start, &dhcp)) {\n\n        return -1;\n\n    }\n\n    if ((dhcp.s_addr & mask.s_addr) != net.s_addr ||\n\n        dhcp.s_addr == host.s_addr || dhcp.s_addr == dns.s_addr) {\n\n        return -1;\n\n    }\n\n\n\n    if (vnameserver && !inet_aton(vnameserver, &dns)) {\n\n        return -1;\n\n    }\n\n    if ((dns.s_addr & mask.s_addr) != net.s_addr ||\n\n        dns.s_addr == host.s_addr) {\n\n        return -1;\n\n    }\n\n\n\n#ifndef _WIN32\n\n    if (vsmbserver && !inet_aton(vsmbserver, &smbsrv)) {\n\n        return -1;\n\n    }\n\n#endif\n\n\n\n    nc = qemu_new_net_client(&net_slirp_info, peer, model, name);\n\n\n\n    snprintf(nc->info_str, sizeof(nc->info_str),\n\n             \"net=%s,restrict=%s\", inet_ntoa(net),\n\n             restricted ? \"on\" : \"off\");\n\n\n\n    s = DO_UPCAST(SlirpState, nc, nc);\n\n\n\n    s->slirp = slirp_init(restricted, net, mask, host, vhostname,\n\n                          tftp_export, bootfile, dhcp, dns, dnssearch, s);\n\n    QTAILQ_INSERT_TAIL(&slirp_stacks, s, entry);\n\n\n\n    for (config = slirp_configs; config; config = config->next) {\n\n        if (config->flags & SLIRP_CFG_HOSTFWD) {\n\n            if (slirp_hostfwd(s, config->str,\n\n                              config->flags & SLIRP_CFG_LEGACY) < 0)\n\n                goto error;\n\n        } else {\n\n            if (slirp_guestfwd(s, config->str,\n\n                               config->flags & SLIRP_CFG_LEGACY) < 0)\n\n                goto error;\n\n        }\n\n    }\n\n#ifndef _WIN32\n\n    if (!smb_export) {\n\n        smb_export = legacy_smb_export;\n\n    }\n\n    if (smb_export) {\n\n        if (slirp_smb(s, smb_export, smbsrv) < 0)\n\n            goto error;\n\n    }\n\n#endif\n\n\n\n    return 0;\n\n\n\nerror:\n\n    qemu_del_net_client(nc);\n\n    return -1;\n\n}\n", "idx": 26247}
{"project": "qemu", "commit_id": "492ec48dc2d99ca13b24d554e1970af7e2581e23", "target": 0, "func": "static int ppce500_load_device_tree(CPUPPCState *env,\n\n                                    PPCE500Params *params,\n\n                                    hwaddr addr,\n\n                                    hwaddr initrd_base,\n\n                                    hwaddr initrd_size)\n\n{\n\n    int ret = -1;\n\n    uint64_t mem_reg_property[] = { 0, cpu_to_be64(params->ram_size) };\n\n    int fdt_size;\n\n    void *fdt;\n\n    uint8_t hypercall[16];\n\n    uint32_t clock_freq = 400000000;\n\n    uint32_t tb_freq = 400000000;\n\n    int i;\n\n    const char *toplevel_compat = NULL; /* user override */\n\n    char compatible_sb[] = \"fsl,mpc8544-immr\\0simple-bus\";\n\n    char soc[128];\n\n    char mpic[128];\n\n    uint32_t mpic_ph;\n\n    uint32_t msi_ph;\n\n    char gutil[128];\n\n    char pci[128];\n\n    char msi[128];\n\n    uint32_t *pci_map = NULL;\n\n    int len;\n\n    uint32_t pci_ranges[14] =\n\n        {\n\n            0x2000000, 0x0, 0xc0000000,\n\n            0x0, 0xc0000000,\n\n            0x0, 0x20000000,\n\n\n\n            0x1000000, 0x0, 0x0,\n\n            0x0, 0xe1000000,\n\n            0x0, 0x10000,\n\n        };\n\n    QemuOpts *machine_opts;\n\n    const char *dtb_file = NULL;\n\n\n\n    machine_opts = qemu_opts_find(qemu_find_opts(\"machine\"), 0);\n\n    if (machine_opts) {\n\n        dtb_file = qemu_opt_get(machine_opts, \"dtb\");\n\n        toplevel_compat = qemu_opt_get(machine_opts, \"dt_compatible\");\n\n    }\n\n\n\n    if (dtb_file) {\n\n        char *filename;\n\n        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, dtb_file);\n\n        if (!filename) {\n\n            goto out;\n\n        }\n\n\n\n        fdt = load_device_tree(filename, &fdt_size);\n\n        if (!fdt) {\n\n            goto out;\n\n        }\n\n        goto done;\n\n    }\n\n\n\n    fdt = create_device_tree(&fdt_size);\n\n    if (fdt == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    /* Manipulate device tree in memory. */\n\n    qemu_devtree_setprop_cell(fdt, \"/\", \"#address-cells\", 2);\n\n    qemu_devtree_setprop_cell(fdt, \"/\", \"#size-cells\", 2);\n\n\n\n    qemu_devtree_add_subnode(fdt, \"/memory\");\n\n    qemu_devtree_setprop_string(fdt, \"/memory\", \"device_type\", \"memory\");\n\n    qemu_devtree_setprop(fdt, \"/memory\", \"reg\", mem_reg_property,\n\n                         sizeof(mem_reg_property));\n\n\n\n    qemu_devtree_add_subnode(fdt, \"/chosen\");\n\n    if (initrd_size) {\n\n        ret = qemu_devtree_setprop_cell(fdt, \"/chosen\", \"linux,initrd-start\",\n\n                                        initrd_base);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"couldn't set /chosen/linux,initrd-start\\n\");\n\n        }\n\n\n\n        ret = qemu_devtree_setprop_cell(fdt, \"/chosen\", \"linux,initrd-end\",\n\n                                        (initrd_base + initrd_size));\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"couldn't set /chosen/linux,initrd-end\\n\");\n\n        }\n\n    }\n\n\n\n    ret = qemu_devtree_setprop_string(fdt, \"/chosen\", \"bootargs\",\n\n                                      params->kernel_cmdline);\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /chosen/bootargs\\n\");\n\n\n\n    if (kvm_enabled()) {\n\n        /* Read out host's frequencies */\n\n        clock_freq = kvmppc_get_clockfreq();\n\n        tb_freq = kvmppc_get_tbfreq();\n\n\n\n        /* indicate KVM hypercall interface */\n\n        qemu_devtree_add_subnode(fdt, \"/hypervisor\");\n\n        qemu_devtree_setprop_string(fdt, \"/hypervisor\", \"compatible\",\n\n                                    \"linux,kvm\");\n\n        kvmppc_get_hypercall(env, hypercall, sizeof(hypercall));\n\n        qemu_devtree_setprop(fdt, \"/hypervisor\", \"hcall-instructions\",\n\n                             hypercall, sizeof(hypercall));\n\n    }\n\n\n\n    /* Create CPU nodes */\n\n    qemu_devtree_add_subnode(fdt, \"/cpus\");\n\n    qemu_devtree_setprop_cell(fdt, \"/cpus\", \"#address-cells\", 1);\n\n    qemu_devtree_setprop_cell(fdt, \"/cpus\", \"#size-cells\", 0);\n\n\n\n    /* We need to generate the cpu nodes in reverse order, so Linux can pick\n\n       the first node as boot node and be happy */\n\n    for (i = smp_cpus - 1; i >= 0; i--) {\n\n        char cpu_name[128];\n\n        uint64_t cpu_release_addr = MPC8544_SPIN_BASE + (i * 0x20);\n\n\n\n        for (env = first_cpu; env != NULL; env = env->next_cpu) {\n\n            if (env->cpu_index == i) {\n\n                break;\n\n            }\n\n        }\n\n\n\n        if (!env) {\n\n            continue;\n\n        }\n\n\n\n        snprintf(cpu_name, sizeof(cpu_name), \"/cpus/PowerPC,8544@%x\", env->cpu_index);\n\n        qemu_devtree_add_subnode(fdt, cpu_name);\n\n        qemu_devtree_setprop_cell(fdt, cpu_name, \"clock-frequency\", clock_freq);\n\n        qemu_devtree_setprop_cell(fdt, cpu_name, \"timebase-frequency\", tb_freq);\n\n        qemu_devtree_setprop_string(fdt, cpu_name, \"device_type\", \"cpu\");\n\n        qemu_devtree_setprop_cell(fdt, cpu_name, \"reg\", env->cpu_index);\n\n        qemu_devtree_setprop_cell(fdt, cpu_name, \"d-cache-line-size\",\n\n                                  env->dcache_line_size);\n\n        qemu_devtree_setprop_cell(fdt, cpu_name, \"i-cache-line-size\",\n\n                                  env->icache_line_size);\n\n        qemu_devtree_setprop_cell(fdt, cpu_name, \"d-cache-size\", 0x8000);\n\n        qemu_devtree_setprop_cell(fdt, cpu_name, \"i-cache-size\", 0x8000);\n\n        qemu_devtree_setprop_cell(fdt, cpu_name, \"bus-frequency\", 0);\n\n        if (env->cpu_index) {\n\n            qemu_devtree_setprop_string(fdt, cpu_name, \"status\", \"disabled\");\n\n            qemu_devtree_setprop_string(fdt, cpu_name, \"enable-method\", \"spin-table\");\n\n            qemu_devtree_setprop_u64(fdt, cpu_name, \"cpu-release-addr\",\n\n                                     cpu_release_addr);\n\n        } else {\n\n            qemu_devtree_setprop_string(fdt, cpu_name, \"status\", \"okay\");\n\n        }\n\n    }\n\n\n\n    qemu_devtree_add_subnode(fdt, \"/aliases\");\n\n    /* XXX These should go into their respective devices' code */\n\n    snprintf(soc, sizeof(soc), \"/soc@%llx\", MPC8544_CCSRBAR_BASE);\n\n    qemu_devtree_add_subnode(fdt, soc);\n\n    qemu_devtree_setprop_string(fdt, soc, \"device_type\", \"soc\");\n\n    qemu_devtree_setprop(fdt, soc, \"compatible\", compatible_sb,\n\n                         sizeof(compatible_sb));\n\n    qemu_devtree_setprop_cell(fdt, soc, \"#address-cells\", 1);\n\n    qemu_devtree_setprop_cell(fdt, soc, \"#size-cells\", 1);\n\n    qemu_devtree_setprop_cells(fdt, soc, \"ranges\", 0x0,\n\n                               MPC8544_CCSRBAR_BASE >> 32, MPC8544_CCSRBAR_BASE,\n\n                               MPC8544_CCSRBAR_SIZE);\n\n    /* XXX should contain a reasonable value */\n\n    qemu_devtree_setprop_cell(fdt, soc, \"bus-frequency\", 0);\n\n\n\n    snprintf(mpic, sizeof(mpic), \"%s/pic@%llx\", soc, MPC8544_MPIC_REGS_OFFSET);\n\n    qemu_devtree_add_subnode(fdt, mpic);\n\n    qemu_devtree_setprop_string(fdt, mpic, \"device_type\", \"open-pic\");\n\n    qemu_devtree_setprop_string(fdt, mpic, \"compatible\", \"chrp,open-pic\");\n\n    qemu_devtree_setprop_cells(fdt, mpic, \"reg\", MPC8544_MPIC_REGS_OFFSET,\n\n                               0x40000);\n\n    qemu_devtree_setprop_cell(fdt, mpic, \"#address-cells\", 0);\n\n    qemu_devtree_setprop_cell(fdt, mpic, \"#interrupt-cells\", 2);\n\n    mpic_ph = qemu_devtree_alloc_phandle(fdt);\n\n    qemu_devtree_setprop_cell(fdt, mpic, \"phandle\", mpic_ph);\n\n    qemu_devtree_setprop_cell(fdt, mpic, \"linux,phandle\", mpic_ph);\n\n    qemu_devtree_setprop(fdt, mpic, \"interrupt-controller\", NULL, 0);\n\n\n\n    /*\n\n     * We have to generate ser1 first, because Linux takes the first\n\n     * device it finds in the dt as serial output device. And we generate\n\n     * devices in reverse order to the dt.\n\n     */\n\n    dt_serial_create(fdt, MPC8544_SERIAL1_REGS_OFFSET,\n\n                     soc, mpic, \"serial1\", 1, false);\n\n    dt_serial_create(fdt, MPC8544_SERIAL0_REGS_OFFSET,\n\n                     soc, mpic, \"serial0\", 0, true);\n\n\n\n    snprintf(gutil, sizeof(gutil), \"%s/global-utilities@%llx\", soc,\n\n             MPC8544_UTIL_OFFSET);\n\n    qemu_devtree_add_subnode(fdt, gutil);\n\n    qemu_devtree_setprop_string(fdt, gutil, \"compatible\", \"fsl,mpc8544-guts\");\n\n    qemu_devtree_setprop_cells(fdt, gutil, \"reg\", MPC8544_UTIL_OFFSET, 0x1000);\n\n    qemu_devtree_setprop(fdt, gutil, \"fsl,has-rstcr\", NULL, 0);\n\n\n\n    snprintf(msi, sizeof(msi), \"/%s/msi@%llx\", soc, MPC8544_MSI_REGS_OFFSET);\n\n    qemu_devtree_add_subnode(fdt, msi);\n\n    qemu_devtree_setprop_string(fdt, msi, \"compatible\", \"fsl,mpic-msi\");\n\n    qemu_devtree_setprop_cells(fdt, msi, \"reg\", MPC8544_MSI_REGS_OFFSET, 0x200);\n\n    msi_ph = qemu_devtree_alloc_phandle(fdt);\n\n    qemu_devtree_setprop_cells(fdt, msi, \"msi-available-ranges\", 0x0, 0x100);\n\n    qemu_devtree_setprop_phandle(fdt, msi, \"interrupt-parent\", mpic);\n\n    qemu_devtree_setprop_cells(fdt, msi, \"interrupts\",\n\n        0xe0, 0x0,\n\n        0xe1, 0x0,\n\n        0xe2, 0x0,\n\n        0xe3, 0x0,\n\n        0xe4, 0x0,\n\n        0xe5, 0x0,\n\n        0xe6, 0x0,\n\n        0xe7, 0x0);\n\n    qemu_devtree_setprop_cell(fdt, msi, \"phandle\", msi_ph);\n\n    qemu_devtree_setprop_cell(fdt, msi, \"linux,phandle\", msi_ph);\n\n\n\n    snprintf(pci, sizeof(pci), \"/pci@%llx\", MPC8544_PCI_REGS_BASE);\n\n    qemu_devtree_add_subnode(fdt, pci);\n\n    qemu_devtree_setprop_cell(fdt, pci, \"cell-index\", 0);\n\n    qemu_devtree_setprop_string(fdt, pci, \"compatible\", \"fsl,mpc8540-pci\");\n\n    qemu_devtree_setprop_string(fdt, pci, \"device_type\", \"pci\");\n\n    qemu_devtree_setprop_cells(fdt, pci, \"interrupt-map-mask\", 0xf800, 0x0,\n\n                               0x0, 0x7);\n\n    pci_map = pci_map_create(fdt, qemu_devtree_get_phandle(fdt, mpic),\n\n                             0x11, 2, &len);\n\n    qemu_devtree_setprop(fdt, pci, \"interrupt-map\", pci_map, len);\n\n    qemu_devtree_setprop_phandle(fdt, pci, \"interrupt-parent\", mpic);\n\n    qemu_devtree_setprop_cells(fdt, pci, \"interrupts\", 24, 2);\n\n    qemu_devtree_setprop_cells(fdt, pci, \"bus-range\", 0, 255);\n\n    for (i = 0; i < 14; i++) {\n\n        pci_ranges[i] = cpu_to_be32(pci_ranges[i]);\n\n    }\n\n    qemu_devtree_setprop_cell(fdt, pci, \"fsl,msi\", msi_ph);\n\n    qemu_devtree_setprop(fdt, pci, \"ranges\", pci_ranges, sizeof(pci_ranges));\n\n    qemu_devtree_setprop_cells(fdt, pci, \"reg\", MPC8544_PCI_REGS_BASE >> 32,\n\n                               MPC8544_PCI_REGS_BASE, 0, 0x1000);\n\n    qemu_devtree_setprop_cell(fdt, pci, \"clock-frequency\", 66666666);\n\n    qemu_devtree_setprop_cell(fdt, pci, \"#interrupt-cells\", 1);\n\n    qemu_devtree_setprop_cell(fdt, pci, \"#size-cells\", 2);\n\n    qemu_devtree_setprop_cell(fdt, pci, \"#address-cells\", 3);\n\n    qemu_devtree_setprop_string(fdt, \"/aliases\", \"pci0\", pci);\n\n\n\n    params->fixup_devtree(params, fdt);\n\n\n\n    if (toplevel_compat) {\n\n        qemu_devtree_setprop(fdt, \"/\", \"compatible\", toplevel_compat,\n\n                             strlen(toplevel_compat) + 1);\n\n    }\n\n\n\ndone:\n\n    qemu_devtree_dumpdtb(fdt, fdt_size);\n\n    ret = rom_add_blob_fixed(BINARY_DEVICE_TREE_FILE, fdt, fdt_size, addr);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n    g_free(fdt);\n\n    ret = fdt_size;\n\n\n\nout:\n\n    g_free(pci_map);\n\n\n\n    return ret;\n\n}\n", "idx": 26248}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "DriveInfo *drive_get_by_blockdev(BlockDriverState *bs)\n\n{\n\n    return bs->blk ? blk_legacy_dinfo(bs->blk) : NULL;\n\n}\n", "idx": 26250}
{"project": "qemu", "commit_id": "f8c35c1d59c9fecf79f6d5a02cd09f472a6f411d", "target": 0, "func": "static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,\n\n                        uint8_t *buf, int nb_sectors)\n\n{\n\n    int async_ret;\n\n    BlockDriverAIOCB *acb;\n\n    struct iovec iov;\n\n    QEMUIOVector qiov;\n\n\n\n    async_ret = NOT_DONE;\n\n    iov.iov_base = (void *)buf;\n\n    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;\n\n    qemu_iovec_init_external(&qiov, &iov, 1);\n\n\n\n    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,\n\n                                  bdrv_rw_em_cb, &async_ret);\n\n    if (acb == NULL) {\n\n        async_ret = -1;\n\n        goto fail;\n\n    }\n\n\n\n    while (async_ret == NOT_DONE) {\n\n        qemu_aio_wait();\n\n    }\n\n\n\n\n\nfail:\n\n    return async_ret;\n\n}\n", "idx": 26251}
{"project": "qemu", "commit_id": "b7680cb6078bd7294a3dd86473d3f2fdee991dd0", "target": 0, "func": "int kvm_arch_put_registers(CPUState *env, int level)\n\n{\n\n    int ret;\n\n\n\n    assert(cpu_is_stopped(env) || qemu_cpu_self(env));\n\n\n\n    ret = kvm_getput_regs(env, 1);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    ret = kvm_put_xsave(env);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    ret = kvm_put_xcrs(env);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    ret = kvm_put_sregs(env);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    ret = kvm_put_msrs(env, level);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    if (level >= KVM_PUT_RESET_STATE) {\n\n        ret = kvm_put_mp_state(env);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    ret = kvm_put_vcpu_events(env, level);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    ret = kvm_put_debugregs(env);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    /* must be last */\n\n    ret = kvm_guest_debug_workarounds(env);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    return 0;\n\n}\n", "idx": 26252}
{"project": "qemu", "commit_id": "338c858c946017cd3ec8c2be06d817e001d94bc3", "target": 0, "func": "long do_sigreturn(CPUAlphaState *env)\n\n{\n\n    struct target_sigcontext *sc;\n\n    abi_ulong sc_addr = env->ir[IR_A0];\n\n    target_sigset_t target_set;\n\n    sigset_t set;\n\n\n\n    if (!lock_user_struct(VERIFY_READ, sc, sc_addr, 1)) {\n\n        goto badframe;\n\n    }\n\n\n\n    target_sigemptyset(&target_set);\n\n    __get_user(target_set.sig[0], &sc->sc_mask);\n\n\n\n    target_to_host_sigset_internal(&set, &target_set);\n\n    do_sigprocmask(SIG_SETMASK, &set, NULL);\n\n\n\n    restore_sigcontext(env, sc);\n\n    unlock_user_struct(sc, sc_addr, 0);\n\n    return env->ir[IR_V0];\n\n\n\nbadframe:\n\n    force_sig(TARGET_SIGSEGV);\n\n}\n", "idx": 26253}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static bool ide_sect_range_ok(IDEState *s,\n\n                              uint64_t sector, uint64_t nb_sectors)\n\n{\n\n    uint64_t total_sectors;\n\n\n\n    bdrv_get_geometry(s->bs, &total_sectors);\n\n    if (sector > total_sectors || nb_sectors > total_sectors - sector) {\n\n        return false;\n\n    }\n\n    return true;\n\n}\n", "idx": 26254}
{"project": "qemu", "commit_id": "384acbf46b70edf0d2c1648aa1a92a90bcf7057d", "target": 0, "func": "int qed_write_l1_table_sync(BDRVQEDState *s, unsigned int index,\n\n                            unsigned int n)\n\n{\n\n    int ret = -EINPROGRESS;\n\n\n\n    async_context_push();\n\n\n\n    qed_write_l1_table(s, index, n, qed_sync_cb, &ret);\n\n    while (ret == -EINPROGRESS) {\n\n        qemu_aio_wait();\n\n    }\n\n\n\n    async_context_pop();\n\n\n\n    return ret;\n\n}\n", "idx": 26255}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "bool memory_region_get_dirty(MemoryRegion *mr, hwaddr addr,\n\n                             hwaddr size, unsigned client)\n\n{\n\n    assert(mr->terminates);\n\n    return cpu_physical_memory_get_dirty(mr->ram_addr + addr, size, client);\n\n}\n", "idx": 26256}
{"project": "qemu", "commit_id": "e57ca75ce3b2bd33102573a8c0555d62e1bcfceb", "target": 0, "func": "static int kvmppc_get_books_sregs(PowerPCCPU *cpu)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    struct kvm_sregs sregs;\n\n    int ret;\n\n    int i;\n\n\n\n    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_SREGS, &sregs);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    if (!env->external_htab) {\n\n        ppc_store_sdr1(env, sregs.u.s.sdr1);\n\n    }\n\n\n\n    /* Sync SLB */\n\n#ifdef TARGET_PPC64\n\n    /*\n\n     * The packed SLB array we get from KVM_GET_SREGS only contains\n\n     * information about valid entries. So we flush our internal copy\n\n     * to get rid of stale ones, then put all valid SLB entries back\n\n     * in.\n\n     */\n\n    memset(env->slb, 0, sizeof(env->slb));\n\n    for (i = 0; i < ARRAY_SIZE(env->slb); i++) {\n\n        target_ulong rb = sregs.u.s.ppc64.slb[i].slbe;\n\n        target_ulong rs = sregs.u.s.ppc64.slb[i].slbv;\n\n        /*\n\n         * Only restore valid entries\n\n         */\n\n        if (rb & SLB_ESID_V) {\n\n            ppc_store_slb(cpu, rb & 0xfff, rb & ~0xfffULL, rs);\n\n        }\n\n    }\n\n#endif\n\n\n\n    /* Sync SRs */\n\n    for (i = 0; i < 16; i++) {\n\n        env->sr[i] = sregs.u.s.ppc32.sr[i];\n\n    }\n\n\n\n    /* Sync BATs */\n\n    for (i = 0; i < 8; i++) {\n\n        env->DBAT[0][i] = sregs.u.s.ppc32.dbat[i] & 0xffffffff;\n\n        env->DBAT[1][i] = sregs.u.s.ppc32.dbat[i] >> 32;\n\n        env->IBAT[0][i] = sregs.u.s.ppc32.ibat[i] & 0xffffffff;\n\n        env->IBAT[1][i] = sregs.u.s.ppc32.ibat[i] >> 32;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 26257}
{"project": "qemu", "commit_id": "52cfcb464255b4da5115408e2a6ce3327bbcb9df", "target": 0, "func": "static void filter_mirror_setup(NetFilterState *nf, Error **errp)\n\n{\n\n    MirrorState *s = FILTER_MIRROR(nf);\n\n\n\n    if (!s->outdev) {\n\n        error_setg(errp, \"filter filter mirror needs 'outdev' \"\n\n                   \"property set\");\n\n        return;\n\n    }\n\n\n\n    s->chr_out = qemu_chr_find(s->outdev);\n\n    if (s->chr_out == NULL) {\n\n        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n\n                  \"Device '%s' not found\", s->outdev);\n\n        return;\n\n    }\n\n\n\n    if (qemu_chr_fe_claim(s->chr_out) != 0) {\n\n        error_setg(errp, QERR_DEVICE_IN_USE, s->outdev);\n\n        return;\n\n    }\n\n}\n", "idx": 26258}
{"project": "qemu", "commit_id": "0ae18ceeaaa2c1749e742c4b112f6c3bf0896408", "target": 0, "func": "static void integratorcp_init(ram_addr_t ram_size, int vga_ram_size,\n\n                     const char *boot_device, DisplayState *ds,\n\n                     const char *kernel_filename, const char *kernel_cmdline,\n\n                     const char *initrd_filename, const char *cpu_model)\n\n{\n\n    CPUState *env;\n\n    uint32_t ram_offset;\n\n    qemu_irq *pic;\n\n    qemu_irq *cpu_pic;\n\n    int sd;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"arm926\";\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    ram_offset = qemu_ram_alloc(ram_size);\n\n    /* ??? On a real system the first 1Mb is mapped as SSRAM or boot flash.  */\n\n    /* ??? RAM should repeat to fill physical memory space.  */\n\n    /* SDRAM at address zero*/\n\n    cpu_register_physical_memory(0, ram_size, ram_offset | IO_MEM_RAM);\n\n    /* And again at address 0x80000000 */\n\n    cpu_register_physical_memory(0x80000000, ram_size, ram_offset | IO_MEM_RAM);\n\n\n\n    integratorcm_init(ram_size >> 20);\n\n    cpu_pic = arm_pic_init_cpu(env);\n\n    pic = icp_pic_init(0x14000000, cpu_pic[ARM_PIC_CPU_IRQ],\n\n                       cpu_pic[ARM_PIC_CPU_FIQ]);\n\n    icp_pic_init(0xca000000, pic[26], NULL);\n\n    icp_pit_init(0x13000000, pic, 5);\n\n    pl031_init(0x15000000, pic[8]);\n\n    pl011_init(0x16000000, pic[1], serial_hds[0], PL011_ARM);\n\n    pl011_init(0x17000000, pic[2], serial_hds[1], PL011_ARM);\n\n    icp_control_init(0xcb000000);\n\n    pl050_init(0x18000000, pic[3], 0);\n\n    pl050_init(0x19000000, pic[4], 1);\n\n    sd = drive_get_index(IF_SD, 0, 0);\n\n    if (sd == -1) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital card\\n\");\n\n        exit(1);\n\n    }\n\n    pl181_init(0x1c000000, drives_table[sd].bdrv, pic[23], pic[24]);\n\n    if (nd_table[0].vlan) {\n\n        if (nd_table[0].model == NULL\n\n            || strcmp(nd_table[0].model, \"smc91c111\") == 0) {\n\n            smc91c111_init(&nd_table[0], 0xc8000000, pic[27]);\n\n        } else if (strcmp(nd_table[0].model, \"?\") == 0) {\n\n            fprintf(stderr, \"qemu: Supported NICs: smc91c111\\n\");\n\n            exit (1);\n\n        } else {\n\n            fprintf(stderr, \"qemu: Unsupported NIC: %s\\n\", nd_table[0].model);\n\n            exit (1);\n\n        }\n\n    }\n\n    pl110_init(ds, 0xc0000000, pic[22], 0);\n\n\n\n    integrator_binfo.ram_size = ram_size;\n\n    integrator_binfo.kernel_filename = kernel_filename;\n\n    integrator_binfo.kernel_cmdline = kernel_cmdline;\n\n    integrator_binfo.initrd_filename = initrd_filename;\n\n    arm_load_kernel(env, &integrator_binfo);\n\n}\n", "idx": 26259}
{"project": "qemu", "commit_id": "8297be80f7cf71e09617669a8bd8b2836dcfd4c3", "target": 0, "func": "static void generate_eeprom_spd(uint8_t *eeprom, ram_addr_t ram_size)\n\n{\n\n    enum { SDR = 0x4, DDR2 = 0x8 } type;\n\n    uint8_t *spd = spd_eeprom.contents;\n\n    uint8_t nbanks = 0;\n\n    uint16_t density = 0;\n\n    int i;\n\n\n\n    /* work in terms of MB */\n\n    ram_size >>= 20;\n\n\n\n    while ((ram_size >= 4) && (nbanks <= 2)) {\n\n        int sz_log2 = MIN(31 - clz32(ram_size), 14);\n\n        nbanks++;\n\n        density |= 1 << (sz_log2 - 2);\n\n        ram_size -= 1 << sz_log2;\n\n    }\n\n\n\n    /* split to 2 banks if possible */\n\n    if ((nbanks == 1) && (density > 1)) {\n\n        nbanks++;\n\n        density >>= 1;\n\n    }\n\n\n\n    if (density & 0xff00) {\n\n        density = (density & 0xe0) | ((density >> 8) & 0x1f);\n\n        type = DDR2;\n\n    } else if (!(density & 0x1f)) {\n\n        type = DDR2;\n\n    } else {\n\n        type = SDR;\n\n    }\n\n\n\n    if (ram_size) {\n\n        fprintf(stderr, \"Warning: SPD cannot represent final %dMB\"\n\n                \" of SDRAM\\n\", (int)ram_size);\n\n    }\n\n\n\n    /* fill in SPD memory information */\n\n    spd[2] = type;\n\n    spd[5] = nbanks;\n\n    spd[31] = density;\n\n\n\n    /* checksum */\n\n    spd[63] = 0;\n\n    for (i = 0; i < 63; i++) {\n\n        spd[63] += spd[i];\n\n    }\n\n\n\n    /* copy for SMBUS */\n\n    memcpy(eeprom, spd, sizeof(spd_eeprom.contents));\n\n}\n", "idx": 26260}
{"project": "qemu", "commit_id": "a0efbf16604770b9d805bcf210ec29942321134f", "target": 0, "func": "static GenericList *next_list(Visitor *v, GenericList *tail, size_t size)\n\n{\n\n    StringInputVisitor *siv = to_siv(v);\n\n    Range *r;\n\n\n\n    if (!siv->ranges || !siv->cur_range) {\n\n        return NULL;\n\n    }\n\n\n\n    r = siv->cur_range->data;\n\n    if (!r) {\n\n        return NULL;\n\n    }\n\n\n\n    if (siv->cur < r->begin || siv->cur >= r->end) {\n\n        siv->cur_range = g_list_next(siv->cur_range);\n\n        if (!siv->cur_range) {\n\n            return NULL;\n\n        }\n\n        r = siv->cur_range->data;\n\n        if (!r) {\n\n            return NULL;\n\n        }\n\n        siv->cur = r->begin;\n\n    }\n\n\n\n    tail->next = g_malloc0(size);\n\n    return tail->next;\n\n}\n", "idx": 26261}
{"project": "qemu", "commit_id": "49dfcec40349245ad365964468b67e132c3cedc7", "target": 0, "func": "static void invalidate_and_set_dirty(hwaddr addr,\n\n                                     hwaddr length)\n\n{\n\n    if (cpu_physical_memory_range_includes_clean(addr, length)) {\n\n        tb_invalidate_phys_range(addr, addr + length, 0);\n\n        cpu_physical_memory_set_dirty_range_nocode(addr, length);\n\n    }\n\n    xen_modified_memory(addr, length);\n\n}\n", "idx": 26263}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int proxy_unlinkat(FsContext *ctx, V9fsPath *dir,\n\n                          const char *name, int flags)\n\n{\n\n    int ret;\n\n    V9fsString fullname;\n\n    v9fs_string_init(&fullname);\n\n\n\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir->data, name);\n\n    ret = proxy_remove(ctx, fullname.data);\n\n    v9fs_string_free(&fullname);\n\n\n\n    return ret;\n\n}\n", "idx": 26264}
{"project": "qemu", "commit_id": "ad07cd69ecaffbaa015459a46975ab32e50df805", "target": 0, "func": "void virtio_scsi_common_realize(DeviceState *dev, Error **errp,\n\n                                VirtIOHandleOutput ctrl,\n\n                                VirtIOHandleOutput evt,\n\n                                VirtIOHandleOutput cmd)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n    VirtIOSCSICommon *s = VIRTIO_SCSI_COMMON(dev);\n\n    int i;\n\n\n\n    virtio_init(vdev, \"virtio-scsi\", VIRTIO_ID_SCSI,\n\n                sizeof(VirtIOSCSIConfig));\n\n\n\n    if (s->conf.num_queues == 0 ||\n\n            s->conf.num_queues > VIRTIO_QUEUE_MAX - 2) {\n\n        error_setg(errp, \"Invalid number of queues (= %\" PRIu32 \"), \"\n\n                         \"must be a positive integer less than %d.\",\n\n                   s->conf.num_queues, VIRTIO_QUEUE_MAX - 2);\n\n        virtio_cleanup(vdev);\n\n        return;\n\n    }\n\n    s->cmd_vqs = g_new0(VirtQueue *, s->conf.num_queues);\n\n    s->sense_size = VIRTIO_SCSI_SENSE_DEFAULT_SIZE;\n\n    s->cdb_size = VIRTIO_SCSI_CDB_DEFAULT_SIZE;\n\n\n\n    s->ctrl_vq = virtio_add_queue_aio(vdev, VIRTIO_SCSI_VQ_SIZE, ctrl);\n\n    s->event_vq = virtio_add_queue_aio(vdev, VIRTIO_SCSI_VQ_SIZE, evt);\n\n    for (i = 0; i < s->conf.num_queues; i++) {\n\n        s->cmd_vqs[i] = virtio_add_queue_aio(vdev, VIRTIO_SCSI_VQ_SIZE, cmd);\n\n    }\n\n\n\n    if (s->conf.iothread) {\n\n        virtio_scsi_set_iothread(VIRTIO_SCSI(s), s->conf.iothread);\n\n    }\n\n}\n", "idx": 26265}
{"project": "qemu", "commit_id": "cd42d5b23691ad73edfd6dbcfc935a960a9c5a65", "target": 0, "func": "static inline void gen_intermediate_code_internal(SPARCCPU *cpu,\n\n                                                  TranslationBlock *tb,\n\n                                                  bool spc)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUSPARCState *env = &cpu->env;\n\n    target_ulong pc_start, last_pc;\n\n    uint16_t *gen_opc_end;\n\n    DisasContext dc1, *dc = &dc1;\n\n    CPUBreakpoint *bp;\n\n    int j, lj = -1;\n\n    int num_insns;\n\n    int max_insns;\n\n    unsigned int insn;\n\n\n\n    memset(dc, 0, sizeof(DisasContext));\n\n    dc->tb = tb;\n\n    pc_start = tb->pc;\n\n    dc->pc = pc_start;\n\n    last_pc = dc->pc;\n\n    dc->npc = (target_ulong) tb->cs_base;\n\n    dc->cc_op = CC_OP_DYNAMIC;\n\n    dc->mem_idx = cpu_mmu_index(env);\n\n    dc->def = env->def;\n\n    dc->fpu_enabled = tb_fpu_enabled(tb->flags);\n\n    dc->address_mask_32bit = tb_am_enabled(tb->flags);\n\n    dc->singlestep = (cs->singlestep_enabled || singlestep);\n\n    gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE;\n\n\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0)\n\n        max_insns = CF_COUNT_MASK;\n\n    gen_tb_start();\n\n    do {\n\n        if (unlikely(!QTAILQ_EMPTY(&cs->breakpoints))) {\n\n            QTAILQ_FOREACH(bp, &cs->breakpoints, entry) {\n\n                if (bp->pc == dc->pc) {\n\n                    if (dc->pc != pc_start)\n\n                        save_state(dc);\n\n                    gen_helper_debug(cpu_env);\n\n                    tcg_gen_exit_tb(0);\n\n                    dc->is_br = 1;\n\n                    goto exit_gen_loop;\n\n                }\n\n            }\n\n        }\n\n        if (spc) {\n\n            qemu_log(\"Search PC...\\n\");\n\n            j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    tcg_ctx.gen_opc_instr_start[lj++] = 0;\n\n                tcg_ctx.gen_opc_pc[lj] = dc->pc;\n\n                gen_opc_npc[lj] = dc->npc;\n\n                tcg_ctx.gen_opc_instr_start[lj] = 1;\n\n                tcg_ctx.gen_opc_icount[lj] = num_insns;\n\n            }\n\n        }\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))\n\n            gen_io_start();\n\n        last_pc = dc->pc;\n\n        insn = cpu_ldl_code(env, dc->pc);\n\n\n\n        disas_sparc_insn(dc, insn);\n\n        num_insns++;\n\n\n\n        if (dc->is_br)\n\n            break;\n\n        /* if the next PC is different, we abort now */\n\n        if (dc->pc != (last_pc + 4))\n\n            break;\n\n        /* if we reach a page boundary, we stop generation so that the\n\n           PC of a TT_TFAULT exception is always in the right page */\n\n        if ((dc->pc & (TARGET_PAGE_SIZE - 1)) == 0)\n\n            break;\n\n        /* if single step mode, we generate only one instruction and\n\n           generate an exception */\n\n        if (dc->singlestep) {\n\n            break;\n\n        }\n\n    } while ((tcg_ctx.gen_opc_ptr < gen_opc_end) &&\n\n             (dc->pc - pc_start) < (TARGET_PAGE_SIZE - 32) &&\n\n             num_insns < max_insns);\n\n\n\n exit_gen_loop:\n\n    if (tb->cflags & CF_LAST_IO) {\n\n        gen_io_end();\n\n    }\n\n    if (!dc->is_br) {\n\n        if (dc->pc != DYNAMIC_PC &&\n\n            (dc->npc != DYNAMIC_PC && dc->npc != JUMP_PC)) {\n\n            /* static PC and NPC: we can use direct chaining */\n\n            gen_goto_tb(dc, 0, dc->pc, dc->npc);\n\n        } else {\n\n            if (dc->pc != DYNAMIC_PC) {\n\n                tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n            }\n\n            save_npc(dc);\n\n            tcg_gen_exit_tb(0);\n\n        }\n\n    }\n\n    gen_tb_end(tb, num_insns);\n\n    *tcg_ctx.gen_opc_ptr = INDEX_op_end;\n\n    if (spc) {\n\n        j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            tcg_ctx.gen_opc_instr_start[lj++] = 0;\n\n#if 0\n\n        log_page_dump();\n\n#endif\n\n        gen_opc_jump_pc[0] = dc->jump_pc[0];\n\n        gen_opc_jump_pc[1] = dc->jump_pc[1];\n\n    } else {\n\n        tb->size = last_pc + 4 - pc_start;\n\n        tb->icount = num_insns;\n\n    }\n\n#ifdef DEBUG_DISAS\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"--------------\\n\");\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n        log_target_disas(env, pc_start, last_pc + 4 - pc_start, 0);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n}\n", "idx": 26266}
{"project": "qemu", "commit_id": "ef1e1e0782e99c9dcf2b35e5310cdd8ca9211374", "target": 0, "func": "static int load_uboot_image(const char *filename, hwaddr *ep, hwaddr *loadaddr,\n\n                            int *is_linux, uint8_t image_type,\n\n                            uint64_t (*translate_fn)(void *, uint64_t),\n\n                            void *translate_opaque)\n\n{\n\n    int fd;\n\n    int size;\n\n    hwaddr address;\n\n    uboot_image_header_t h;\n\n    uboot_image_header_t *hdr = &h;\n\n    uint8_t *data = NULL;\n\n    int ret = -1;\n\n    int do_uncompress = 0;\n\n\n\n    fd = open(filename, O_RDONLY | O_BINARY);\n\n    if (fd < 0)\n\n        return -1;\n\n\n\n    size = read(fd, hdr, sizeof(uboot_image_header_t));\n\n    if (size < 0)\n\n        goto out;\n\n\n\n    bswap_uboot_header(hdr);\n\n\n\n    if (hdr->ih_magic != IH_MAGIC)\n\n        goto out;\n\n\n\n    if (hdr->ih_type != image_type) {\n\n        fprintf(stderr, \"Wrong image type %d, expected %d\\n\", hdr->ih_type,\n\n                image_type);\n\n        goto out;\n\n    }\n\n\n\n    /* TODO: Implement other image types.  */\n\n    switch (hdr->ih_type) {\n\n    case IH_TYPE_KERNEL:\n\n        address = hdr->ih_load;\n\n        if (translate_fn) {\n\n            address = translate_fn(translate_opaque, address);\n\n        }\n\n        if (loadaddr) {\n\n            *loadaddr = hdr->ih_load;\n\n        }\n\n\n\n        switch (hdr->ih_comp) {\n\n        case IH_COMP_NONE:\n\n            break;\n\n        case IH_COMP_GZIP:\n\n            do_uncompress = 1;\n\n            break;\n\n        default:\n\n            fprintf(stderr,\n\n                    \"Unable to load u-boot images with compression type %d\\n\",\n\n                    hdr->ih_comp);\n\n            goto out;\n\n        }\n\n\n\n        if (ep) {\n\n            *ep = hdr->ih_ep;\n\n        }\n\n\n\n        /* TODO: Check CPU type.  */\n\n        if (is_linux) {\n\n            if (hdr->ih_os == IH_OS_LINUX) {\n\n                *is_linux = 1;\n\n            } else {\n\n                *is_linux = 0;\n\n            }\n\n        }\n\n\n\n        break;\n\n    case IH_TYPE_RAMDISK:\n\n        address = *loadaddr;\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"Unsupported u-boot image type %d\\n\", hdr->ih_type);\n\n        goto out;\n\n    }\n\n\n\n    data = g_malloc(hdr->ih_size);\n\n\n\n    if (read(fd, data, hdr->ih_size) != hdr->ih_size) {\n\n        fprintf(stderr, \"Error reading file\\n\");\n\n        goto out;\n\n    }\n\n\n\n    if (do_uncompress) {\n\n        uint8_t *compressed_data;\n\n        size_t max_bytes;\n\n        ssize_t bytes;\n\n\n\n        compressed_data = data;\n\n        max_bytes = UBOOT_MAX_GUNZIP_BYTES;\n\n        data = g_malloc(max_bytes);\n\n\n\n        bytes = gunzip(data, max_bytes, compressed_data, hdr->ih_size);\n\n        g_free(compressed_data);\n\n        if (bytes < 0) {\n\n            fprintf(stderr, \"Unable to decompress gzipped image!\\n\");\n\n            goto out;\n\n        }\n\n        hdr->ih_size = bytes;\n\n    }\n\n\n\n    rom_add_blob_fixed(filename, data, hdr->ih_size, address);\n\n\n\n    ret = hdr->ih_size;\n\n\n\nout:\n\n    if (data)\n\n        g_free(data);\n\n    close(fd);\n\n    return ret;\n\n}\n", "idx": 26267}
{"project": "qemu", "commit_id": "0ae18ceeaaa2c1749e742c4b112f6c3bf0896408", "target": 0, "func": "static void stellaris_init(const char *kernel_filename, const char *cpu_model,\n\n                           DisplayState *ds, stellaris_board_info *board)\n\n{\n\n    static const int uart_irq[] = {5, 6, 33, 34};\n\n    static const int timer_irq[] = {19, 21, 23, 35};\n\n    static const uint32_t gpio_addr[7] =\n\n      { 0x40004000, 0x40005000, 0x40006000, 0x40007000,\n\n        0x40024000, 0x40025000, 0x40026000};\n\n    static const int gpio_irq[7] = {0, 1, 2, 3, 4, 30, 31};\n\n\n\n    qemu_irq *pic;\n\n    qemu_irq *gpio_in[7];\n\n    qemu_irq *gpio_out[7];\n\n    qemu_irq adc;\n\n    int sram_size;\n\n    int flash_size;\n\n    i2c_bus *i2c;\n\n    int i;\n\n\n\n    flash_size = ((board->dc0 & 0xffff) + 1) << 1;\n\n    sram_size = (board->dc0 >> 18) + 1;\n\n    pic = armv7m_init(flash_size, sram_size, kernel_filename, cpu_model);\n\n\n\n    if (board->dc1 & (1 << 16)) {\n\n        adc = stellaris_adc_init(0x40038000, pic[14]);\n\n    } else {\n\n        adc = NULL;\n\n    }\n\n    for (i = 0; i < 4; i++) {\n\n        if (board->dc2 & (0x10000 << i)) {\n\n            stellaris_gptm_init(0x40030000 + i * 0x1000,\n\n                                pic[timer_irq[i]], adc);\n\n        }\n\n    }\n\n\n\n    stellaris_sys_init(0x400fe000, pic[28], board, nd_table[0].macaddr);\n\n\n\n    for (i = 0; i < 7; i++) {\n\n        if (board->dc4 & (1 << i)) {\n\n            gpio_in[i] = pl061_init(gpio_addr[i], pic[gpio_irq[i]],\n\n                                    &gpio_out[i]);\n\n        }\n\n    }\n\n\n\n    if (board->dc2 & (1 << 12)) {\n\n        i2c = i2c_init_bus();\n\n        stellaris_i2c_init(0x40020000, pic[8], i2c);\n\n        if (board->peripherals & BP_OLED_I2C) {\n\n            ssd0303_init(ds, i2c, 0x3d);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        if (board->dc2 & (1 << i)) {\n\n            pl011_init(0x4000c000 + i * 0x1000, pic[uart_irq[i]],\n\n                       serial_hds[i], PL011_LUMINARY);\n\n        }\n\n    }\n\n    if (board->dc2 & (1 << 4)) {\n\n        if (board->peripherals & BP_OLED_SSI) {\n\n            void * oled;\n\n            void * sd;\n\n            void *ssi_bus;\n\n            int index;\n\n\n\n            oled = ssd0323_init(ds, &gpio_out[GPIO_C][7]);\n\n            index = drive_get_index(IF_SD, 0, 0);\n\n            sd = ssi_sd_init(drives_table[index].bdrv);\n\n\n\n            ssi_bus = stellaris_ssi_bus_init(&gpio_out[GPIO_D][0],\n\n                                             ssi_sd_xfer, sd,\n\n                                             ssd0323_xfer_ssi, oled);\n\n\n\n            pl022_init(0x40008000, pic[7], stellaris_ssi_bus_xfer, ssi_bus);\n\n            /* Make sure the select pin is high.  */\n\n            qemu_irq_raise(gpio_out[GPIO_D][0]);\n\n        } else {\n\n            pl022_init(0x40008000, pic[7], NULL, NULL);\n\n        }\n\n    }\n\n    if (board->dc4 & (1 << 28)) {\n\n        /* FIXME: Obey network model.  */\n\n        stellaris_enet_init(&nd_table[0], 0x40048000, pic[42]);\n\n    }\n\n    if (board->peripherals & BP_GAMEPAD) {\n\n        qemu_irq gpad_irq[5];\n\n        static const int gpad_keycode[5] = { 0xc8, 0xd0, 0xcb, 0xcd, 0x1d };\n\n\n\n        gpad_irq[0] = qemu_irq_invert(gpio_in[GPIO_E][0]); /* up */\n\n        gpad_irq[1] = qemu_irq_invert(gpio_in[GPIO_E][1]); /* down */\n\n        gpad_irq[2] = qemu_irq_invert(gpio_in[GPIO_E][2]); /* left */\n\n        gpad_irq[3] = qemu_irq_invert(gpio_in[GPIO_E][3]); /* right */\n\n        gpad_irq[4] = qemu_irq_invert(gpio_in[GPIO_F][1]); /* select */\n\n\n\n        stellaris_gamepad_init(5, gpad_irq, gpad_keycode);\n\n    }\n\n}\n", "idx": 26268}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static int pcnet_can_receive(void *opaque)\n\n{\n\n    PCNetState *s = opaque;\n\n    if (CSR_STOP(s) || CSR_SPND(s))\n\n        return 0;\n\n\n\n    if (s->recv_pos > 0)\n\n        return 0;\n\n\n\n    return sizeof(s->buffer)-16;\n\n}\n", "idx": 26269}
{"project": "qemu", "commit_id": "0e7106d8b5f7ef4f9df10baf1dfb3db482bcd046", "target": 0, "func": "static int write_object(int fd, char *buf, uint64_t oid, int copies,\n\n                        unsigned int datalen, uint64_t offset, bool create,\n\n                        bool cache)\n\n{\n\n    return read_write_object(fd, buf, oid, copies, datalen, offset, true,\n\n                             create, cache);\n\n}\n", "idx": 26270}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t cuda_readw (void *opaque, target_phys_addr_t addr)\n\n{\n\n    return 0;\n\n}\n", "idx": 26271}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "void helper_iret_protected(int shift, int next_eip)\n\n{\n\n    int tss_selector, type;\n\n    uint32_t e1, e2;\n\n\n\n    /* specific case for TSS */\n\n    if (env->eflags & NT_MASK) {\n\n#ifdef TARGET_X86_64\n\n        if (env->hflags & HF_LMA_MASK)\n\n            raise_exception_err(EXCP0D_GPF, 0);\n\n#endif\n\n        tss_selector = lduw_kernel(env->tr.base + 0);\n\n        if (tss_selector & 4)\n\n            raise_exception_err(EXCP0A_TSS, tss_selector & 0xfffc);\n\n        if (load_segment(&e1, &e2, tss_selector) != 0)\n\n            raise_exception_err(EXCP0A_TSS, tss_selector & 0xfffc);\n\n        type = (e2 >> DESC_TYPE_SHIFT) & 0x17;\n\n        /* NOTE: we check both segment and busy TSS */\n\n        if (type != 3)\n\n            raise_exception_err(EXCP0A_TSS, tss_selector & 0xfffc);\n\n        switch_tss(tss_selector, e1, e2, SWITCH_TSS_IRET, next_eip);\n\n    } else {\n\n        helper_ret_protected(shift, 1, 0);\n\n    }\n\n    env->hflags2 &= ~HF2_NMI_MASK;\n\n#ifdef CONFIG_KQEMU\n\n    if (kqemu_is_ok(env)) {\n\n        CC_OP = CC_OP_EFLAGS;\n\n        env->exception_index = -1;\n\n        cpu_loop_exit();\n\n    }\n\n#endif\n\n}\n", "idx": 26272}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void bonito_spciconf_writeb(void *opaque, target_phys_addr_t addr,\n\n                                   uint32_t val)\n\n{\n\n    PCIBonitoState *s = opaque;\n\n    PCIDevice *d = PCI_DEVICE(s);\n\n    PCIHostState *phb = PCI_HOST_BRIDGE(s->pcihost);\n\n    uint32_t pciaddr;\n\n    uint16_t status;\n\n\n\n    DPRINTF(\"bonito_spciconf_writeb \"TARGET_FMT_plx\" val %x\\n\", addr, val);\n\n    pciaddr = bonito_sbridge_pciaddr(s, addr);\n\n\n\n    if (pciaddr == 0xffffffff) {\n\n        return;\n\n    }\n\n\n\n    /* set the pci address in s->config_reg */\n\n    phb->config_reg = (pciaddr) | (1u << 31);\n\n    pci_data_write(phb->bus, phb->config_reg, val & 0xff, 1);\n\n\n\n    /* clear PCI_STATUS_REC_MASTER_ABORT and PCI_STATUS_REC_TARGET_ABORT */\n\n    status = pci_get_word(d->config + PCI_STATUS);\n\n    status &= ~(PCI_STATUS_REC_MASTER_ABORT | PCI_STATUS_REC_TARGET_ABORT);\n\n    pci_set_word(d->config + PCI_STATUS, status);\n\n}\n", "idx": 26274}
{"project": "qemu", "commit_id": "1a28cac3161f8a85ee0256776068eaed2da025e5", "target": 0, "func": "void qemu_mutex_lock_iothread(void)\n\n{\n\n    if (kvm_enabled()) {\n\n        qemu_mutex_lock(&qemu_fair_mutex);\n\n        qemu_mutex_lock(&qemu_global_mutex);\n\n        qemu_mutex_unlock(&qemu_fair_mutex);\n\n    } else\n\n        qemu_signal_lock(100);\n\n}\n", "idx": 26275}
{"project": "qemu", "commit_id": "b0f49d138777fb6609aa2ea96d2c59fb872d2c2d", "target": 0, "func": "pvscsi_command_complete(SCSIRequest *req, uint32_t status, size_t resid)\n\n{\n\n    PVSCSIRequest *pvscsi_req = req->hba_private;\n\n    PVSCSIState *s = pvscsi_req->dev;\n\n\n\n    if (!pvscsi_req) {\n\n        trace_pvscsi_command_complete_not_found(req->tag);\n\n        return;\n\n    }\n\n\n\n    if (resid) {\n\n        /* Short transfer.  */\n\n        trace_pvscsi_command_complete_data_run();\n\n        pvscsi_req->cmp.hostStatus = BTSTAT_DATARUN;\n\n    }\n\n\n\n    pvscsi_req->cmp.scsiStatus = status;\n\n    if (pvscsi_req->cmp.scsiStatus == CHECK_CONDITION) {\n\n        uint8_t sense[SCSI_SENSE_BUF_SIZE];\n\n        int sense_len =\n\n            scsi_req_get_sense(pvscsi_req->sreq, sense, sizeof(sense));\n\n\n\n        trace_pvscsi_command_complete_sense_len(sense_len);\n\n        pvscsi_write_sense(pvscsi_req, sense, sense_len);\n\n    }\n\n    qemu_sglist_destroy(&pvscsi_req->sgl);\n\n    pvscsi_complete_request(s, pvscsi_req);\n\n}\n", "idx": 26276}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int proxy_open(FsContext *ctx, V9fsPath *fs_path,\n\n                      int flags, V9fsFidOpenState *fs)\n\n{\n\n    fs->fd = v9fs_request(ctx->private, T_OPEN, NULL, \"sd\", fs_path, flags);\n\n    if (fs->fd < 0) {\n\n        errno = -fs->fd;\n\n        fs->fd = -1;\n\n    }\n\n    return fs->fd;\n\n}\n", "idx": 26277}
{"project": "qemu", "commit_id": "0ae18ceeaaa2c1749e742c4b112f6c3bf0896408", "target": 0, "func": "void mips_r4k_init (ram_addr_t ram_size, int vga_ram_size,\n\n                    const char *boot_device, DisplayState *ds,\n\n                    const char *kernel_filename, const char *kernel_cmdline,\n\n                    const char *initrd_filename, const char *cpu_model)\n\n{\n\n    char buf[1024];\n\n    unsigned long bios_offset;\n\n    int bios_size;\n\n    CPUState *env;\n\n    RTCState *rtc_state;\n\n    int i;\n\n    qemu_irq *i8259;\n\n    int index;\n\n    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n#ifdef TARGET_MIPS64\n\n        cpu_model = \"R4000\";\n\n#else\n\n        cpu_model = \"24Kf\";\n\n#endif\n\n    }\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    qemu_register_reset(main_cpu_reset, env);\n\n\n\n    /* allocate RAM */\n\n    cpu_register_physical_memory(0, ram_size, IO_MEM_RAM);\n\n\n\n    if (!mips_qemu_iomemtype) {\n\n        mips_qemu_iomemtype = cpu_register_io_memory(0, mips_qemu_read,\n\n                                                     mips_qemu_write, NULL);\n\n    }\n\n    cpu_register_physical_memory(0x1fbf0000, 0x10000, mips_qemu_iomemtype);\n\n\n\n    /* Try to load a BIOS image. If this fails, we continue regardless,\n\n       but initialize the hardware ourselves. When a kernel gets\n\n       preloaded we also initialize the hardware, since the BIOS wasn't\n\n       run. */\n\n    bios_offset = ram_size + vga_ram_size;\n\n    if (bios_name == NULL)\n\n        bios_name = BIOS_FILENAME;\n\n    snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, bios_name);\n\n    bios_size = load_image(buf, phys_ram_base + bios_offset);\n\n    if ((bios_size > 0) && (bios_size <= BIOS_SIZE)) {\n\n\tcpu_register_physical_memory(0x1fc00000,\n\n\t\t\t\t     BIOS_SIZE, bios_offset | IO_MEM_ROM);\n\n    } else if ((index = drive_get_index(IF_PFLASH, 0, 0)) > -1) {\n\n        uint32_t mips_rom = 0x00400000;\n\n        cpu_register_physical_memory(0x1fc00000, mips_rom,\n\n\t                     qemu_ram_alloc(mips_rom) | IO_MEM_ROM);\n\n        if (!pflash_cfi01_register(0x1fc00000, qemu_ram_alloc(mips_rom),\n\n            drives_table[index].bdrv, sector_len, mips_rom / sector_len,\n\n            4, 0, 0, 0, 0)) {\n\n            fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n\t}\n\n    }\n\n    else {\n\n\t/* not fatal */\n\n        fprintf(stderr, \"qemu: Warning, could not load MIPS bios '%s'\\n\",\n\n\t\tbuf);\n\n    }\n\n\n\n    if (kernel_filename) {\n\n        loaderparams.ram_size = ram_size;\n\n        loaderparams.kernel_filename = kernel_filename;\n\n        loaderparams.kernel_cmdline = kernel_cmdline;\n\n        loaderparams.initrd_filename = initrd_filename;\n\n        load_kernel (env);\n\n    }\n\n\n\n    /* Init CPU internal devices */\n\n    cpu_mips_irq_init_cpu(env);\n\n    cpu_mips_clock_init(env);\n\n\n\n    /* The PIC is attached to the MIPS CPU INT0 pin */\n\n    i8259 = i8259_init(env->irq[2]);\n\n\n\n    rtc_state = rtc_init(0x70, i8259[8]);\n\n\n\n    /* Register 64 KB of ISA IO space at 0x14000000 */\n\n    isa_mmio_init(0x14000000, 0x00010000);\n\n    isa_mem_base = 0x10000000;\n\n\n\n    pit = pit_init(0x40, i8259[0]);\n\n\n\n    for(i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            serial_init(serial_io[i], i8259[serial_irq[i]], 115200,\n\n                        serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    isa_vga_init(ds, phys_ram_base + ram_size, ram_size,\n\n                 vga_ram_size);\n\n\n\n    if (nd_table[0].vlan) {\n\n        if (nd_table[i].model == NULL) {\n\n\t    nd_table[i].model = \"ne2k_isa\";\n\n        }\n\n        if (strcmp(nd_table[0].model, \"ne2k_isa\") == 0) {\n\n            isa_ne2000_init(0x300, i8259[9], &nd_table[0]);\n\n        } else if (strcmp(nd_table[0].model, \"?\") == 0) {\n\n            fprintf(stderr, \"qemu: Supported NICs: ne2k_isa\\n\");\n\n            exit (1);\n\n        } else {\n\n            fprintf(stderr, \"qemu: Unsupported NIC: %s\\n\", nd_table[0].model);\n\n            exit (1);\n\n        }\n\n    }\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);\n\n        if (index != -1)\n\n            hd[i] = drives_table[index].bdrv;\n\n        else\n\n            hd[i] = NULL;\n\n    }\n\n\n\n    for(i = 0; i < MAX_IDE_BUS; i++)\n\n        isa_ide_init(ide_iobase[i], ide_iobase2[i], i8259[ide_irq[i]],\n\n                     hd[MAX_IDE_DEVS * i],\n\n\t\t     hd[MAX_IDE_DEVS * i + 1]);\n\n\n\n    i8042_init(i8259[1], i8259[12], 0x60);\n\n}\n", "idx": 26278}
{"project": "qemu", "commit_id": "f1c52354e5bdab6983d13a4c174759c585e834b3", "target": 0, "func": "static bool spapr_drc_needed(void *opaque)\n\n{\n\n    sPAPRDRConnector *drc = (sPAPRDRConnector *)opaque;\n\n    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n    bool rc = false;\n\n    sPAPRDREntitySense value = drck->dr_entity_sense(drc);\n\n\n\n    /* If no dev is plugged in there is no need to migrate the DRC state */\n\n    if (value != SPAPR_DR_ENTITY_SENSE_PRESENT) {\n\n        return false;\n\n    }\n\n\n\n    /*\n\n     * If there is dev plugged in, we need to migrate the DRC state when\n\n     * it is different from cold-plugged state\n\n     */\n\n    switch (spapr_drc_type(drc)) {\n\n    case SPAPR_DR_CONNECTOR_TYPE_PCI:\n\n    case SPAPR_DR_CONNECTOR_TYPE_CPU:\n\n    case SPAPR_DR_CONNECTOR_TYPE_LMB:\n\n        rc = !((drc->isolation_state == SPAPR_DR_ISOLATION_STATE_UNISOLATED) &&\n\n               (drc->allocation_state == SPAPR_DR_ALLOCATION_STATE_USABLE) &&\n\n               drc->configured && !drc->awaiting_release);\n\n        break;\n\n    case SPAPR_DR_CONNECTOR_TYPE_PHB:\n\n    case SPAPR_DR_CONNECTOR_TYPE_VIO:\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n    return rc;\n\n}\n", "idx": 26279}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "PowerPCCPU *ppc4xx_init(const char *cpu_model,\n\n                        clk_setup_t *cpu_clk, clk_setup_t *tb_clk,\n\n                        uint32_t sysclk)\n\n{\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n\n\n    /* init CPUs */\n\n    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"Unable to find PowerPC %s CPU definition\\n\",\n\n                cpu_model);\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    cpu_clk->cb = NULL; /* We don't care about CPU clock frequency changes */\n\n    cpu_clk->opaque = env;\n\n    /* Set time-base frequency to sysclk */\n\n    tb_clk->cb = ppc_40x_timers_init(env, sysclk, PPC_INTERRUPT_PIT);\n\n    tb_clk->opaque = env;\n\n    ppc_dcr_init(env, NULL, NULL);\n\n    /* Register qemu callbacks */\n\n    qemu_register_reset(ppc4xx_reset, cpu);\n\n\n\n    return cpu;\n\n}\n", "idx": 26282}
{"project": "qemu", "commit_id": "b46578555c4bce64e3daba4591334aba2d12c156", "target": 1, "func": "static int close_f(int argc, char **argv)\n\n{\n\n    bdrv_close(bs);\n\n    bs = NULL;\n\n    return 0;\n\n}\n", "idx": 26285}
{"project": "qemu", "commit_id": "3a3567d337d3ee6fb2e2fcc1d27cd045ed97ae9b", "target": 1, "func": "static void pty_chr_state(CharDriverState *chr, int connected)\n\n{\n\n    PtyCharDriver *s = chr->opaque;\n\n\n\n    if (!connected) {\n\n        if (s->fd_tag) {\n\n            io_remove_watch_poll(s->fd_tag);\n\n            s->fd_tag = 0;\n\n        }\n\n        s->connected = 0;\n\n        /* (re-)connect poll interval for idle guests: once per second.\n\n         * We check more frequently in case the guests sends data to\n\n         * the virtual device linked to our pty. */\n\n        pty_chr_rearm_timer(chr, 1000);\n\n    } else {\n\n        if (s->timer_tag) {\n\n            g_source_remove(s->timer_tag);\n\n            s->timer_tag = 0;\n\n        }\n\n        if (!s->connected) {\n\n            qemu_chr_be_generic_open(chr);\n\n            s->connected = 1;\n\n            s->fd_tag = io_add_watch_poll(s->fd, pty_chr_read_poll, pty_chr_read, chr);\n\n        }\n\n    }\n\n}\n", "idx": 26286}
{"project": "qemu", "commit_id": "4a94fc9bf2dac5965acb8e264d55a356737a2aa6", "target": 1, "func": "static void zynq_xadc_write(void *opaque, hwaddr offset, uint64_t val,\n\n                            unsigned size)\n\n{\n\n    ZynqXADCState *s = (ZynqXADCState *)opaque;\n\n    int reg = offset / 4;\n\n    int xadc_reg;\n\n    int xadc_cmd;\n\n    int xadc_data;\n\n\n\n    if (!zynq_xadc_check_offset(reg, false)) {\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"zynq_xadc: Invalid write access \"\n\n                      \"to addr %\" HWADDR_PRIx \"\\n\", offset);\n\n        return;\n\n    }\n\n\n\n    switch (reg) {\n\n    case CFG:\n\n        s->regs[CFG] = val;\n\n        break;\n\n    case INT_STS:\n\n        s->regs[INT_STS] &= ~val;\n\n        break;\n\n    case INT_MASK:\n\n        s->regs[INT_MASK] = val & INT_ALL;\n\n        break;\n\n    case CMDFIFO:\n\n        xadc_cmd  = extract32(val, 26,  4);\n\n        xadc_reg  = extract32(val, 16, 10);\n\n        xadc_data = extract32(val,  0, 16);\n\n\n\n        if (s->regs[MCTL] & MCTL_RESET) {\n\n            qemu_log_mask(LOG_GUEST_ERROR, \"zynq_xadc: Sending command \"\n\n                          \"while comm channel held in reset: %\" PRIx32 \"\\n\",\n\n                          (uint32_t) val);\n\n            break;\n\n        }\n\n\n\n        if (xadc_reg > ZYNQ_XADC_NUM_ADC_REGS && xadc_cmd != CMD_NOP) {\n\n            qemu_log_mask(LOG_GUEST_ERROR, \"read/write op to invalid xadc \"\n\n                          \"reg 0x%x\\n\", xadc_reg);\n\n            break;\n\n        }\n\n\n\n        switch (xadc_cmd) {\n\n        case CMD_READ:\n\n            xadc_push_dfifo(s, s->xadc_regs[xadc_reg]);\n\n            break;\n\n        case CMD_WRITE:\n\n            s->xadc_regs[xadc_reg] = xadc_data;\n\n            /* fallthrough */\n\n        case CMD_NOP:\n\n            xadc_push_dfifo(s, 0);\n\n            break;\n\n        }\n\n        break;\n\n    case MCTL:\n\n        s->regs[MCTL] = val & 0x00fffeff;\n\n        break;\n\n    }\n\n    zynq_xadc_update_ints(s);\n\n}\n", "idx": 26287}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "static inline void gen_set_Rc0 (DisasContext *ctx)\n\n{\n\n    gen_op_cmpi(0);\n\n    gen_op_set_Rc0();\n\n}\n", "idx": 26288}
{"project": "qemu", "commit_id": "a01672d3968cf91208666d371784110bfde9d4f8", "target": 1, "func": "static int kvm_log_start(CPUPhysMemoryClient *client,\n\n                         target_phys_addr_t phys_addr, ram_addr_t size)\n\n{\n\n    return kvm_dirty_pages_log_change(phys_addr, size, true);\n\n}\n", "idx": 26289}
{"project": "qemu", "commit_id": "fa617181839741727d0067ea68807133f498f29b", "target": 1, "func": "static int megasas_scsi_init(PCIDevice *dev)\n\n{\n\n    DeviceState *d = DEVICE(dev);\n\n    MegasasState *s = MEGASAS(dev);\n\n    MegasasBaseClass *b = MEGASAS_DEVICE_GET_CLASS(s);\n\n    uint8_t *pci_conf;\n\n    int i, bar_type;\n\n    Error *err = NULL;\n\n\n\n    pci_conf = dev->config;\n\n\n\n    /* PCI latency timer = 0 */\n\n    pci_conf[PCI_LATENCY_TIMER] = 0;\n\n    /* Interrupt pin 1 */\n\n    pci_conf[PCI_INTERRUPT_PIN] = 0x01;\n\n\n\n    memory_region_init_io(&s->mmio_io, OBJECT(s), &megasas_mmio_ops, s,\n\n                          \"megasas-mmio\", 0x4000);\n\n    memory_region_init_io(&s->port_io, OBJECT(s), &megasas_port_ops, s,\n\n                          \"megasas-io\", 256);\n\n    memory_region_init_io(&s->queue_io, OBJECT(s), &megasas_queue_ops, s,\n\n                          \"megasas-queue\", 0x40000);\n\n\n\n    if (megasas_use_msi(s) &&\n\n        msi_init(dev, 0x50, 1, true, false)) {\n\n        s->flags &= ~MEGASAS_MASK_USE_MSI;\n\n    }\n\n    if (megasas_use_msix(s) &&\n\n        msix_init(dev, 15, &s->mmio_io, b->mmio_bar, 0x2000,\n\n                  &s->mmio_io, b->mmio_bar, 0x3800, 0x68)) {\n\n        s->flags &= ~MEGASAS_MASK_USE_MSIX;\n\n    }\n\n    if (pci_is_express(dev)) {\n\n        pcie_endpoint_cap_init(dev, 0xa0);\n\n    }\n\n\n\n    bar_type = PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_TYPE_64;\n\n    pci_register_bar(dev, b->ioport_bar,\n\n                     PCI_BASE_ADDRESS_SPACE_IO, &s->port_io);\n\n    pci_register_bar(dev, b->mmio_bar, bar_type, &s->mmio_io);\n\n    pci_register_bar(dev, 3, bar_type, &s->queue_io);\n\n\n\n    if (megasas_use_msix(s)) {\n\n        msix_vector_use(dev, 0);\n\n    }\n\n\n\n    s->fw_state = MFI_FWSTATE_READY;\n\n    if (!s->sas_addr) {\n\n        s->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) |\n\n                       IEEE_COMPANY_LOCALLY_ASSIGNED) << 36;\n\n        s->sas_addr |= (pci_bus_num(dev->bus) << 16);\n\n        s->sas_addr |= (PCI_SLOT(dev->devfn) << 8);\n\n        s->sas_addr |= PCI_FUNC(dev->devfn);\n\n    }\n\n    if (!s->hba_serial) {\n\n        s->hba_serial = g_strdup(MEGASAS_HBA_SERIAL);\n\n    }\n\n    if (s->fw_sge >= MEGASAS_MAX_SGE - MFI_PASS_FRAME_SIZE) {\n\n        s->fw_sge = MEGASAS_MAX_SGE - MFI_PASS_FRAME_SIZE;\n\n    } else if (s->fw_sge >= 128 - MFI_PASS_FRAME_SIZE) {\n\n        s->fw_sge = 128 - MFI_PASS_FRAME_SIZE;\n\n    } else {\n\n        s->fw_sge = 64 - MFI_PASS_FRAME_SIZE;\n\n    }\n\n    if (s->fw_cmds > MEGASAS_MAX_FRAMES) {\n\n        s->fw_cmds = MEGASAS_MAX_FRAMES;\n\n    }\n\n    trace_megasas_init(s->fw_sge, s->fw_cmds,\n\n                       megasas_is_jbod(s) ? \"jbod\" : \"raid\");\n\n\n\n    if (megasas_is_jbod(s)) {\n\n        s->fw_luns = MFI_MAX_SYS_PDS;\n\n    } else {\n\n        s->fw_luns = MFI_MAX_LD;\n\n    }\n\n    s->producer_pa = 0;\n\n    s->consumer_pa = 0;\n\n    for (i = 0; i < s->fw_cmds; i++) {\n\n        s->frames[i].index = i;\n\n        s->frames[i].context = -1;\n\n        s->frames[i].pa = 0;\n\n        s->frames[i].state = s;\n\n    }\n\n\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),\n\n                 &megasas_scsi_info, NULL);\n\n    if (!d->hotplugged) {\n\n        scsi_bus_legacy_handle_cmdline(&s->bus, &err);\n\n        if (err != NULL) {\n\n\n            error_free(err);\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}", "idx": 26290}
{"project": "qemu", "commit_id": "788cf9f8c8cbda53843e060540f3e91a060eb744", "target": 1, "func": "void hmp_cont(Monitor *mon, const QDict *qdict)\n\n{\n\n    BlockInfoList *bdev_list, *bdev;\n\n    Error *err = NULL;\n\n\n\n    bdev_list = qmp_query_block(NULL);\n\n    for (bdev = bdev_list; bdev; bdev = bdev->next) {\n\n        if (key_is_missing(bdev->value)) {\n\n            monitor_read_block_device_key(mon, bdev->value->device,\n\n                                          hmp_cont_cb, NULL);\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    qmp_cont(&err);\n\n    hmp_handle_error(mon, &err);\n\n\n\nout:\n\n    qapi_free_BlockInfoList(bdev_list);\n\n}\n", "idx": 26291}
{"project": "qemu", "commit_id": "98f28ad7a7d26e5e77c5cb37b262d76d6ccd963d", "target": 1, "func": "VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *conf)\n\n{\n\n    VirtIOBlock *s;\n\n    int cylinders, heads, secs;\n\n    static int virtio_blk_id;\n\n    DriveInfo *dinfo;\n\n\n\n    if (!conf->bs) {\n\n        error_report(\"virtio-blk-pci: drive property not set\");\n\n\n\n\n\n\n\n\n\n    s = (VirtIOBlock *)virtio_common_init(\"virtio-blk\", VIRTIO_ID_BLOCK,\n\n                                          sizeof(struct virtio_blk_config),\n\n                                          sizeof(VirtIOBlock));\n\n\n\n    s->vdev.get_config = virtio_blk_update_config;\n\n    s->vdev.get_features = virtio_blk_get_features;\n\n    s->vdev.reset = virtio_blk_reset;\n\n    s->bs = conf->bs;\n\n    s->conf = conf;\n\n    s->rq = NULL;\n\n    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;\n\n    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);\n\n\n\n    /* NB: per existing s/n string convention the string is terminated\n\n     * by '\\0' only when less than sizeof (s->sn)\n\n     */\n\n    dinfo = drive_get_by_blockdev(s->bs);\n\n    strncpy(s->sn, dinfo->serial, sizeof (s->sn));\n\n\n\n    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);\n\n\n\n    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);\n\n    register_savevm(dev, \"virtio-blk\", virtio_blk_id++, 2,\n\n                    virtio_blk_save, virtio_blk_load, s);\n\n    bdrv_set_removable(s->bs, 0);\n\n\n\n    return &s->vdev;\n", "idx": 26292}
{"project": "qemu", "commit_id": "5839e53bbc0fec56021d758aab7610df421ed8c8", "target": 1, "func": "int qcow2_snapshot_list(BlockDriverState *bs, QEMUSnapshotInfo **psn_tab)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    QEMUSnapshotInfo *sn_tab, *sn_info;\n\n    QCowSnapshot *sn;\n\n    int i;\n\n\n\n    if (!s->nb_snapshots) {\n\n        *psn_tab = NULL;\n\n        return s->nb_snapshots;\n\n    }\n\n\n\n    sn_tab = g_malloc0(s->nb_snapshots * sizeof(QEMUSnapshotInfo));\n\n    for(i = 0; i < s->nb_snapshots; i++) {\n\n        sn_info = sn_tab + i;\n\n        sn = s->snapshots + i;\n\n        pstrcpy(sn_info->id_str, sizeof(sn_info->id_str),\n\n                sn->id_str);\n\n        pstrcpy(sn_info->name, sizeof(sn_info->name),\n\n                sn->name);\n\n        sn_info->vm_state_size = sn->vm_state_size;\n\n        sn_info->date_sec = sn->date_sec;\n\n        sn_info->date_nsec = sn->date_nsec;\n\n        sn_info->vm_clock_nsec = sn->vm_clock_nsec;\n\n    }\n\n    *psn_tab = sn_tab;\n\n    return s->nb_snapshots;\n\n}\n", "idx": 26293}
{"project": "qemu", "commit_id": "83f7f32901c630f4fc01acd0d9082da466b17102", "target": 1, "func": "static bool is_special_wait_psw(CPUState *cs)\n\n{\n\n    /* signal quiesce */\n\n    return cs->kvm_run->psw_addr == 0xfffUL;\n\n}\n", "idx": 26296}
{"project": "qemu", "commit_id": "367790cce8e14131426f5190dfd7d1bdbf656e4d", "target": 1, "func": "DISAS_INSN(shift_reg)\n\n{\n\n    TCGv reg;\n\n    TCGv shift;\n\n\n\n    reg = DREG(insn, 0);\n\n    shift = DREG(insn, 9);\n\n    if (insn & 0x100) {\n\n        gen_helper_shl_cc(reg, cpu_env, reg, shift);\n\n    } else {\n\n        if (insn & 8) {\n\n            gen_helper_shr_cc(reg, cpu_env, reg, shift);\n\n        } else {\n\n            gen_helper_sar_cc(reg, cpu_env, reg, shift);\n\n        }\n\n    }\n\n    set_cc_op(s, CC_OP_FLAGS);\n\n}\n", "idx": 26297}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static uint16_t qvirtio_pci_get_queue_size(QVirtioDevice *d)\n\n{\n\n    QVirtioPCIDevice *dev = (QVirtioPCIDevice *)d;\n\n    return qpci_io_readw(dev->pdev, dev->addr + VIRTIO_PCI_QUEUE_NUM);\n\n}\n", "idx": 26299}
{"project": "qemu", "commit_id": "92196b2f5664d5defa778b1b24df56e2239b5e93", "target": 1, "func": "int bdrv_pwrite_sync(BlockDriverState *bs, int64_t offset,\n\n    const void *buf, int count)\n\n{\n\n    int ret;\n\n\n\n    ret = bdrv_pwrite(bs, offset, buf, count);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* No flush needed for cache=writethrough, it uses O_DSYNC */\n\n    if ((bs->open_flags & BDRV_O_CACHE_MASK) != 0) {\n\n        bdrv_flush(bs);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 26301}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "static pxa2xx_timer_info *pxa2xx_timer_init(target_phys_addr_t base,\n\n                qemu_irq *irqs)\n\n{\n\n    int i;\n\n    int iomemtype;\n\n    pxa2xx_timer_info *s;\n\n\n\n    s = (pxa2xx_timer_info *) qemu_mallocz(sizeof(pxa2xx_timer_info));\n\n    s->base = base;\n\n    s->irq_enabled = 0;\n\n    s->oldclock = 0;\n\n    s->clock = 0;\n\n    s->lastload = qemu_get_clock(vm_clock);\n\n    s->reset3 = 0;\n\n\n\n    for (i = 0; i < 4; i ++) {\n\n        s->timer[i].value = 0;\n\n        s->timer[i].irq = irqs[i];\n\n        s->timer[i].info = s;\n\n        s->timer[i].num = i;\n\n        s->timer[i].level = 0;\n\n        s->timer[i].qtimer = qemu_new_timer(vm_clock,\n\n                        pxa2xx_timer_tick, &s->timer[i]);\n\n    }\n\n\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_timer_readfn,\n\n                    pxa2xx_timer_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n\n\n    register_savevm(\"pxa2xx_timer\", 0, 0,\n\n                    pxa2xx_timer_save, pxa2xx_timer_load, s);\n\n\n\n    return s;\n\n}\n", "idx": 26305}
{"project": "qemu", "commit_id": "e0dadc1e9ef1f35208e5d2af9c7740c18a0b769f", "target": 1, "func": "static void aux_bridge_init(Object *obj)\n\n{\n\n    AUXTOI2CState *s = AUXTOI2C(obj);\n\n\n\n    s->i2c_bus = i2c_init_bus(DEVICE(obj), \"aux-i2c\");\n\n}\n", "idx": 26306}
{"project": "qemu", "commit_id": "df8bf7a7fe75eb5d5caffa55f5cd4292b757aea6", "target": 1, "func": "void net_rx_pkt_attach_iovec_ex(struct NetRxPkt *pkt,\n\n                                const struct iovec *iov, int iovcnt,\n\n                                size_t iovoff, bool strip_vlan,\n\n                                uint16_t vet)\n\n{\n\n    uint16_t tci = 0;\n\n    uint16_t ploff = iovoff;\n\n    assert(pkt);\n\n    pkt->vlan_stripped = false;\n\n\n\n    if (strip_vlan) {\n\n        pkt->vlan_stripped = eth_strip_vlan_ex(iov, iovcnt, iovoff, vet,\n\n                                               pkt->ehdr_buf,\n\n                                               &ploff, &tci);\n\n    }\n\n\n\n    pkt->tci = tci;\n\n\n\n    net_rx_pkt_pull_data(pkt, iov, iovcnt, ploff);\n\n}\n", "idx": 26308}
{"project": "qemu", "commit_id": "d83c951cce14dd3c7600c386d3791c4993744622", "target": 1, "func": "static int ata_passthrough_12_xfer_size(SCSIDevice *dev, uint8_t *buf)\n\n{\n\n    int length = buf[2] & 0x3;\n\n    int xfer;\n\n    int unit = ata_passthrough_xfer_unit(dev, buf);\n\n\n\n    switch (length) {\n\n    case 0:\n\n    case 3: /* USB-specific.  */\n\n\n        xfer = 0;\n\n        break;\n\n    case 1:\n\n        xfer = buf[3];\n\n        break;\n\n    case 2:\n\n        xfer = buf[4];\n\n        break;\n\n    }\n\n\n\n    return xfer * unit;\n\n}", "idx": 26311}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void bdrv_co_drain_bh_cb(void *opaque)\n\n{\n\n    BdrvCoDrainData *data = opaque;\n\n    Coroutine *co = data->co;\n\n\n\n    qemu_bh_delete(data->bh);\n\n    bdrv_drain_poll(data->bs);\n\n    data->done = true;\n\n    qemu_coroutine_enter(co, NULL);\n\n}\n", "idx": 26315}
{"project": "qemu", "commit_id": "2466119c9551d606a0f92f9832e0c865bc04b488", "target": 1, "func": "static inline int host_to_target_errno(int err)\n\n{\n\n    if(host_to_target_errno_table[err])\n\n        return host_to_target_errno_table[err];\n\n    return err;\n\n}\n", "idx": 26316}
{"project": "qemu", "commit_id": "e8a40bf71d606f9f87866fb2461eaed52814b38e", "target": 1, "func": "void backup_start(const char *job_id, BlockDriverState *bs,\n\n                  BlockDriverState *target, int64_t speed,\n\n                  MirrorSyncMode sync_mode, BdrvDirtyBitmap *sync_bitmap,\n\n                  bool compress,\n\n                  BlockdevOnError on_source_error,\n\n                  BlockdevOnError on_target_error,\n\n                  int creation_flags,\n\n                  BlockCompletionFunc *cb, void *opaque,\n\n                  BlockJobTxn *txn, Error **errp)\n\n{\n\n    int64_t len;\n\n    BlockDriverInfo bdi;\n\n    BackupBlockJob *job = NULL;\n\n    int ret;\n\n\n\n    assert(bs);\n\n    assert(target);\n\n\n\n    if (bs == target) {\n\n        error_setg(errp, \"Source and target cannot be the same\");\n\n        return;\n\n    }\n\n\n\n    if (!bdrv_is_inserted(bs)) {\n\n        error_setg(errp, \"Device is not inserted: %s\",\n\n                   bdrv_get_device_name(bs));\n\n        return;\n\n    }\n\n\n\n    if (!bdrv_is_inserted(target)) {\n\n        error_setg(errp, \"Device is not inserted: %s\",\n\n                   bdrv_get_device_name(target));\n\n        return;\n\n    }\n\n\n\n    if (compress && target->drv->bdrv_co_pwritev_compressed == NULL) {\n\n        error_setg(errp, \"Compression is not supported for this drive %s\",\n\n                   bdrv_get_device_name(target));\n\n        return;\n\n    }\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_BACKUP_SOURCE, errp)) {\n\n        return;\n\n    }\n\n\n\n    if (bdrv_op_is_blocked(target, BLOCK_OP_TYPE_BACKUP_TARGET, errp)) {\n\n        return;\n\n    }\n\n\n\n    if (sync_mode == MIRROR_SYNC_MODE_INCREMENTAL) {\n\n        if (!sync_bitmap) {\n\n            error_setg(errp, \"must provide a valid bitmap name for \"\n\n                             \"\\\"incremental\\\" sync mode\");\n\n            return;\n\n        }\n\n\n\n        /* Create a new bitmap, and freeze/disable this one. */\n\n        if (bdrv_dirty_bitmap_create_successor(bs, sync_bitmap, errp) < 0) {\n\n            return;\n\n        }\n\n    } else if (sync_bitmap) {\n\n        error_setg(errp,\n\n                   \"a sync_bitmap was provided to backup_run, \"\n\n                   \"but received an incompatible sync_mode (%s)\",\n\n                   MirrorSyncMode_lookup[sync_mode]);\n\n        return;\n\n    }\n\n\n\n    len = bdrv_getlength(bs);\n\n    if (len < 0) {\n\n        error_setg_errno(errp, -len, \"unable to get length for '%s'\",\n\n                         bdrv_get_device_name(bs));\n\n        goto error;\n\n    }\n\n\n\n    job = block_job_create(job_id, &backup_job_driver, bs, speed,\n\n                           creation_flags, cb, opaque, errp);\n\n    if (!job) {\n\n        goto error;\n\n    }\n\n\n\n    job->target = blk_new();\n\n    blk_insert_bs(job->target, target);\n\n\n\n    job->on_source_error = on_source_error;\n\n    job->on_target_error = on_target_error;\n\n    job->sync_mode = sync_mode;\n\n    job->sync_bitmap = sync_mode == MIRROR_SYNC_MODE_INCREMENTAL ?\n\n                       sync_bitmap : NULL;\n\n    job->compress = compress;\n\n\n\n    /* If there is no backing file on the target, we cannot rely on COW if our\n\n     * backup cluster size is smaller than the target cluster size. Even for\n\n     * targets with a backing file, try to avoid COW if possible. */\n\n    ret = bdrv_get_info(target, &bdi);\n\n    if (ret < 0 && !target->backing) {\n\n        error_setg_errno(errp, -ret,\n\n            \"Couldn't determine the cluster size of the target image, \"\n\n            \"which has no backing file\");\n\n        error_append_hint(errp,\n\n            \"Aborting, since this may create an unusable destination image\\n\");\n\n        goto error;\n\n    } else if (ret < 0 && target->backing) {\n\n        /* Not fatal; just trudge on ahead. */\n\n        job->cluster_size = BACKUP_CLUSTER_SIZE_DEFAULT;\n\n    } else {\n\n        job->cluster_size = MAX(BACKUP_CLUSTER_SIZE_DEFAULT, bdi.cluster_size);\n\n    }\n\n\n\n    block_job_add_bdrv(&job->common, target);\n\n    job->common.len = len;\n\n    job->common.co = qemu_coroutine_create(backup_run, job);\n\n    block_job_txn_add_job(txn, &job->common);\n\n    qemu_coroutine_enter(job->common.co);\n\n    return;\n\n\n\n error:\n\n    if (sync_bitmap) {\n\n        bdrv_reclaim_dirty_bitmap(bs, sync_bitmap, NULL);\n\n    }\n\n    if (job) {\n\n        blk_unref(job->target);\n\n        block_job_unref(&job->common);\n\n    }\n\n}\n", "idx": 26317}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void restart_co_req(void *opaque)\n\n{\n\n    Coroutine *co = opaque;\n\n\n\n    qemu_coroutine_enter(co, NULL);\n\n}\n", "idx": 26318}
{"project": "qemu", "commit_id": "6bdcc018a6ed760b9dfe43539124e420aed83092", "target": 1, "func": "static void nbd_coroutine_start(NBDClientSession *s,\n\n                                NBDRequest *request)\n\n{\n\n    /* Poor man semaphore.  The free_sema is locked when no other request\n\n     * can be accepted, and unlocked after receiving one reply.  */\n\n    if (s->in_flight == MAX_NBD_REQUESTS) {\n\n        qemu_co_queue_wait(&s->free_sema, NULL);\n\n        assert(s->in_flight < MAX_NBD_REQUESTS);\n\n    }\n\n    s->in_flight++;\n\n\n\n    /* s->recv_coroutine[i] is set as soon as we get the send_lock.  */\n\n}\n", "idx": 26319}
{"project": "qemu", "commit_id": "b224e5e2162a767dd56dbc366f796fbe45ca5baa", "target": 1, "func": "static int add_graphics_client(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    const char *protocol  = qdict_get_str(qdict, \"protocol\");\n\n    const char *fdname = qdict_get_str(qdict, \"fdname\");\n\n    CharDriverState *s;\n\n\n\n    if (strcmp(protocol, \"spice\") == 0) {\n\n        int fd = monitor_get_fd(mon, fdname, NULL);\n\n        int skipauth = qdict_get_try_bool(qdict, \"skipauth\", 0);\n\n        int tls = qdict_get_try_bool(qdict, \"tls\", 0);\n\n        if (!using_spice) {\n\n            /* correct one? spice isn't a device ,,, */\n\n            qerror_report(QERR_DEVICE_NOT_ACTIVE, \"spice\");\n\n            return -1;\n\n        }\n\n        if (qemu_spice_display_add_client(fd, skipauth, tls) < 0) {\n\n            close(fd);\n\n        }\n\n        return 0;\n\n#ifdef CONFIG_VNC\n\n    } else if (strcmp(protocol, \"vnc\") == 0) {\n\n\tint fd = monitor_get_fd(mon, fdname, NULL);\n\n        int skipauth = qdict_get_try_bool(qdict, \"skipauth\", 0);\n\n\tvnc_display_add_client(NULL, fd, skipauth);\n\n\treturn 0;\n\n#endif\n\n    } else if ((s = qemu_chr_find(protocol)) != NULL) {\n\n\tint fd = monitor_get_fd(mon, fdname, NULL);\n\n\tif (qemu_chr_add_client(s, fd) < 0) {\n\n\t    qerror_report(QERR_ADD_CLIENT_FAILED);\n\n\t    return -1;\n\n\t}\n\n\treturn 0;\n\n    }\n\n\n\n    qerror_report(QERR_INVALID_PARAMETER, \"protocol\");\n\n    return -1;\n\n}\n", "idx": 26320}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "int inet_connect_opts(QemuOpts *opts)\n\n{\n\n    struct addrinfo ai,*res,*e;\n\n    const char *addr;\n\n    const char *port;\n\n    char uaddr[INET6_ADDRSTRLEN+1];\n\n    char uport[33];\n\n    int sock,rc;\n\n\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_CANONNAME | AI_ADDRCONFIG;\n\n    ai.ai_family = PF_UNSPEC;\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    addr = qemu_opt_get(opts, \"host\");\n\n    port = qemu_opt_get(opts, \"port\");\n\n    if (addr == NULL || port == NULL) {\n\n        fprintf(stderr, \"inet_connect: host and/or port not specified\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (qemu_opt_get_bool(opts, \"ipv4\", 0))\n\n        ai.ai_family = PF_INET;\n\n    if (qemu_opt_get_bool(opts, \"ipv6\", 0))\n\n        ai.ai_family = PF_INET6;\n\n\n\n    /* lookup */\n\n    if (0 != (rc = getaddrinfo(addr, port, &ai, &res))) {\n\n        fprintf(stderr,\"getaddrinfo(%s,%s): %s\\n\", addr, port,\n\n                gai_strerror(rc));\n\n\treturn -1;\n\n    }\n\n    if (sockets_debug)\n\n        inet_print_addrinfo(__FUNCTION__, res);\n\n\n\n    for (e = res; e != NULL; e = e->ai_next) {\n\n        if (getnameinfo((struct sockaddr*)e->ai_addr,e->ai_addrlen,\n\n                            uaddr,INET6_ADDRSTRLEN,uport,32,\n\n                            NI_NUMERICHOST | NI_NUMERICSERV) != 0) {\n\n            fprintf(stderr,\"%s: getnameinfo: oops\\n\", __FUNCTION__);\n\n            continue;\n\n        }\n\n        sock = socket(e->ai_family, e->ai_socktype, e->ai_protocol);\n\n        if (sock < 0) {\n\n            fprintf(stderr,\"%s: socket(%s): %s\\n\", __FUNCTION__,\n\n            inet_strfamily(e->ai_family), strerror(errno));\n\n            continue;\n\n        }\n\n        setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(void*)&on,sizeof(on));\n\n\n\n        /* connect to peer */\n\n        if (connect(sock,e->ai_addr,e->ai_addrlen) < 0) {\n\n            if (sockets_debug || NULL == e->ai_next)\n\n                fprintf(stderr, \"%s: connect(%s,%s,%s,%s): %s\\n\", __FUNCTION__,\n\n                        inet_strfamily(e->ai_family),\n\n                        e->ai_canonname, uaddr, uport, strerror(errno));\n\n            closesocket(sock);\n\n            continue;\n\n        }\n\n        if (sockets_debug)\n\n            fprintf(stderr, \"%s: connect(%s,%s,%s,%s): OK\\n\", __FUNCTION__,\n\n                    inet_strfamily(e->ai_family),\n\n                    e->ai_canonname, uaddr, uport);\n\n        freeaddrinfo(res);\n\n        return sock;\n\n    }\n\n    freeaddrinfo(res);\n\n    return -1;\n\n}\n", "idx": 26321}
{"project": "qemu", "commit_id": "456736710df19c2275192269fe67a3f0b2583835", "target": 1, "func": "static int bdrv_open_common(BlockDriverState *bs, BlockDriverState *file,\n\n    QDict *options, int flags, BlockDriver *drv)\n\n{\n\n    int ret, open_flags;\n\n    const char *filename;\n\n\n\n    assert(drv != NULL);\n\n    assert(bs->file == NULL);\n\n    assert(options != NULL && bs->options != options);\n\n\n\n    trace_bdrv_open_common(bs, filename, flags, drv->format_name);\n\n\n\n    if (use_bdrv_whitelist && !bdrv_is_whitelisted(drv)) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    /* bdrv_open() with directly using a protocol as drv. This layer is already\n\n     * opened, so assign it to bs (while file becomes a closed BlockDriverState)\n\n     * and return immediately. */\n\n    if (file != NULL && drv->bdrv_file_open) {\n\n        bdrv_swap(file, bs);\n\n        return 0;\n\n    }\n\n\n\n    bs->open_flags = flags;\n\n    bs->buffer_alignment = 512;\n\n\n\n    assert(bs->copy_on_read == 0); /* bdrv_new() and bdrv_close() make it so */\n\n    if ((flags & BDRV_O_RDWR) && (flags & BDRV_O_COPY_ON_READ)) {\n\n        bdrv_enable_copy_on_read(bs);\n\n    }\n\n\n\n    if (file != NULL) {\n\n        filename = file->filename;\n\n    } else {\n\n        filename = qdict_get_try_str(options, \"filename\");\n\n    }\n\n\n\n    if (filename != NULL) {\n\n        pstrcpy(bs->filename, sizeof(bs->filename), filename);\n\n    } else {\n\n        bs->filename[0] = '\\0';\n\n    }\n\n\n\n    bs->drv = drv;\n\n    bs->opaque = g_malloc0(drv->instance_size);\n\n\n\n    bs->enable_write_cache = !!(flags & BDRV_O_CACHE_WB);\n\n    open_flags = bdrv_open_flags(bs, flags);\n\n\n\n    bs->read_only = !(open_flags & BDRV_O_RDWR);\n\n\n\n    /* Open the image, either directly or using a protocol */\n\n    if (drv->bdrv_file_open) {\n\n        assert(file == NULL);\n\n        assert(drv->bdrv_parse_filename || filename != NULL);\n\n        ret = drv->bdrv_file_open(bs, options, open_flags);\n\n    } else {\n\n        if (file == NULL) {\n\n            qerror_report(ERROR_CLASS_GENERIC_ERROR, \"Can't use '%s' as a \"\n\n                          \"block driver for the protocol level\",\n\n                          drv->format_name);\n\n            ret = -EINVAL;\n\n            goto free_and_fail;\n\n        }\n\n        assert(file != NULL);\n\n        bs->file = file;\n\n        ret = drv->bdrv_open(bs, options, open_flags);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        goto free_and_fail;\n\n    }\n\n\n\n    ret = refresh_total_sectors(bs, bs->total_sectors);\n\n    if (ret < 0) {\n\n        goto free_and_fail;\n\n    }\n\n\n\n#ifndef _WIN32\n\n    if (bs->is_temporary) {\n\n        assert(filename != NULL);\n\n        unlink(filename);\n\n    }\n\n#endif\n\n    return 0;\n\n\n\nfree_and_fail:\n\n    bs->file = NULL;\n\n    g_free(bs->opaque);\n\n    bs->opaque = NULL;\n\n    bs->drv = NULL;\n\n    return ret;\n\n}\n", "idx": 26323}
{"project": "qemu", "commit_id": "b35278f75450e57c134a153e6da9744c1db8382f", "target": 1, "func": "static int qcow2_open(BlockDriverState *bs, int flags)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int len, i, ret = 0;\n\n    QCowHeader header;\n\n    uint64_t ext_end;\n\n\n\n    ret = bdrv_pread(bs->file, 0, &header, sizeof(header));\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n    be32_to_cpus(&header.magic);\n\n    be32_to_cpus(&header.version);\n\n    be64_to_cpus(&header.backing_file_offset);\n\n    be32_to_cpus(&header.backing_file_size);\n\n    be64_to_cpus(&header.size);\n\n    be32_to_cpus(&header.cluster_bits);\n\n    be32_to_cpus(&header.crypt_method);\n\n    be64_to_cpus(&header.l1_table_offset);\n\n    be32_to_cpus(&header.l1_size);\n\n    be64_to_cpus(&header.refcount_table_offset);\n\n    be32_to_cpus(&header.refcount_table_clusters);\n\n    be64_to_cpus(&header.snapshots_offset);\n\n    be32_to_cpus(&header.nb_snapshots);\n\n\n\n    if (header.magic != QCOW_MAGIC) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    if (header.version < 2 || header.version > 3) {\n\n        report_unsupported(bs, \"QCOW version %d\", header.version);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    }\n\n\n\n    s->qcow_version = header.version;\n\n\n\n    /* Initialise version 3 header fields */\n\n    if (header.version == 2) {\n\n        header.incompatible_features    = 0;\n\n        header.compatible_features      = 0;\n\n        header.autoclear_features       = 0;\n\n        header.refcount_order           = 4;\n\n        header.header_length            = 72;\n\n    } else {\n\n        be64_to_cpus(&header.incompatible_features);\n\n        be64_to_cpus(&header.compatible_features);\n\n        be64_to_cpus(&header.autoclear_features);\n\n        be32_to_cpus(&header.refcount_order);\n\n        be32_to_cpus(&header.header_length);\n\n    }\n\n\n\n    if (header.header_length > sizeof(header)) {\n\n        s->unknown_header_fields_size = header.header_length - sizeof(header);\n\n        s->unknown_header_fields = g_malloc(s->unknown_header_fields_size);\n\n        ret = bdrv_pread(bs->file, sizeof(header), s->unknown_header_fields,\n\n                         s->unknown_header_fields_size);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    if (header.backing_file_offset) {\n\n        ext_end = header.backing_file_offset;\n\n    } else {\n\n        ext_end = 1 << header.cluster_bits;\n\n    }\n\n\n\n    /* Handle feature bits */\n\n    s->incompatible_features    = header.incompatible_features;\n\n    s->compatible_features      = header.compatible_features;\n\n    s->autoclear_features       = header.autoclear_features;\n\n\n\n    if (s->incompatible_features != 0) {\n\n        void *feature_table = NULL;\n\n        qcow2_read_extensions(bs, header.header_length, ext_end,\n\n                              &feature_table);\n\n        report_unsupported_feature(bs, feature_table,\n\n                                   s->incompatible_features);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    }\n\n\n\n    /* Check support for various header values */\n\n    if (header.refcount_order != 4) {\n\n        report_unsupported(bs, \"%d bit reference counts\",\n\n                           1 << header.refcount_order);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    }\n\n\n\n    if (header.cluster_bits < MIN_CLUSTER_BITS ||\n\n        header.cluster_bits > MAX_CLUSTER_BITS) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    if (header.crypt_method > QCOW_CRYPT_AES) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    s->crypt_method_header = header.crypt_method;\n\n    if (s->crypt_method_header) {\n\n        bs->encrypted = 1;\n\n    }\n\n    s->cluster_bits = header.cluster_bits;\n\n    s->cluster_size = 1 << s->cluster_bits;\n\n    s->cluster_sectors = 1 << (s->cluster_bits - 9);\n\n    s->l2_bits = s->cluster_bits - 3; /* L2 is always one cluster */\n\n    s->l2_size = 1 << s->l2_bits;\n\n    bs->total_sectors = header.size / 512;\n\n    s->csize_shift = (62 - (s->cluster_bits - 8));\n\n    s->csize_mask = (1 << (s->cluster_bits - 8)) - 1;\n\n    s->cluster_offset_mask = (1LL << s->csize_shift) - 1;\n\n    s->refcount_table_offset = header.refcount_table_offset;\n\n    s->refcount_table_size =\n\n        header.refcount_table_clusters << (s->cluster_bits - 3);\n\n\n\n    s->snapshots_offset = header.snapshots_offset;\n\n    s->nb_snapshots = header.nb_snapshots;\n\n\n\n    /* read the level 1 table */\n\n    s->l1_size = header.l1_size;\n\n    s->l1_vm_state_index = size_to_l1(s, header.size);\n\n    /* the L1 table must contain at least enough entries to put\n\n       header.size bytes */\n\n    if (s->l1_size < s->l1_vm_state_index) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    s->l1_table_offset = header.l1_table_offset;\n\n    if (s->l1_size > 0) {\n\n        s->l1_table = g_malloc0(\n\n            align_offset(s->l1_size * sizeof(uint64_t), 512));\n\n        ret = bdrv_pread(bs->file, s->l1_table_offset, s->l1_table,\n\n                         s->l1_size * sizeof(uint64_t));\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        for(i = 0;i < s->l1_size; i++) {\n\n            be64_to_cpus(&s->l1_table[i]);\n\n        }\n\n    }\n\n\n\n    /* alloc L2 table/refcount block cache */\n\n    s->l2_table_cache = qcow2_cache_create(bs, L2_CACHE_SIZE);\n\n    s->refcount_block_cache = qcow2_cache_create(bs, REFCOUNT_CACHE_SIZE);\n\n\n\n    s->cluster_cache = g_malloc(s->cluster_size);\n\n    /* one more sector for decompressed data alignment */\n\n    s->cluster_data = qemu_blockalign(bs, QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size\n\n                                  + 512);\n\n    s->cluster_cache_offset = -1;\n\n    s->flags = flags;\n\n\n\n    ret = qcow2_refcount_init(bs);\n\n    if (ret != 0) {\n\n        goto fail;\n\n    }\n\n\n\n    QLIST_INIT(&s->cluster_allocs);\n\n\n\n    /* read qcow2 extensions */\n\n    if (qcow2_read_extensions(bs, header.header_length, ext_end, NULL)) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    /* read the backing file name */\n\n    if (header.backing_file_offset != 0) {\n\n        len = header.backing_file_size;\n\n        if (len > 1023) {\n\n            len = 1023;\n\n        }\n\n        ret = bdrv_pread(bs->file, header.backing_file_offset,\n\n                         bs->backing_file, len);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        bs->backing_file[len] = '\\0';\n\n    }\n\n\n\n    ret = qcow2_read_snapshots(bs);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Clear unknown autoclear feature bits */\n\n    if (!bs->read_only && s->autoclear_features != 0) {\n\n        s->autoclear_features = 0;\n\n        ret = qcow2_update_header(bs);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    /* Initialise locks */\n\n    qemu_co_mutex_init(&s->lock);\n\n\n\n#ifdef DEBUG_ALLOC\n\n    {\n\n        BdrvCheckResult result = {0};\n\n        qcow2_check_refcounts(bs, &result);\n\n    }\n\n#endif\n\n    return ret;\n\n\n\n fail:\n\n    g_free(s->unknown_header_fields);\n\n    cleanup_unknown_header_ext(bs);\n\n    qcow2_free_snapshots(bs);\n\n    qcow2_refcount_close(bs);\n\n    g_free(s->l1_table);\n\n    if (s->l2_table_cache) {\n\n        qcow2_cache_destroy(bs, s->l2_table_cache);\n\n    }\n\n    g_free(s->cluster_cache);\n\n    qemu_vfree(s->cluster_data);\n\n    return ret;\n\n}\n", "idx": 26324}
{"project": "qemu", "commit_id": "962b289ef35087fcd8764e4e29808d8ac90157f7", "target": 1, "func": "char *target_strerror(int err)\n\n{\n\n\n\n\n    return strerror(target_to_host_errno(err));\n", "idx": 26326}
{"project": "qemu", "commit_id": "f61d82c2dfe02a60642a76e8f0034a0244eef2bf", "target": 1, "func": "static int pci_cirrus_vga_initfn(PCIDevice *dev)\n\n{\n\n     PCICirrusVGAState *d = DO_UPCAST(PCICirrusVGAState, dev, dev);\n\n     CirrusVGAState *s = &d->cirrus_vga;\n\n     PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(dev);\n\n     int16_t device_id = pc->device_id;\n\n\n\n\n\n\n\n\n\n\n\n     /* setup VGA */\n\n     vga_common_init(&s->vga, OBJECT(dev), true);\n\n     cirrus_init_common(s, OBJECT(dev), device_id, 1, pci_address_space(dev),\n\n                        pci_address_space_io(dev));\n\n     s->vga.con = graphic_console_init(DEVICE(dev), 0, s->vga.hw_ops, &s->vga);\n\n\n\n     /* setup PCI */\n\n\n\n    memory_region_init(&s->pci_bar, OBJECT(dev), \"cirrus-pci-bar0\", 0x2000000);\n\n\n\n    /* XXX: add byte swapping apertures */\n\n    memory_region_add_subregion(&s->pci_bar, 0, &s->cirrus_linear_io);\n\n    memory_region_add_subregion(&s->pci_bar, 0x1000000,\n\n                                &s->cirrus_linear_bitblt_io);\n\n\n\n     /* setup memory space */\n\n     /* memory #0 LFB */\n\n     /* memory #1 memory-mapped I/O */\n\n     /* XXX: s->vga.vram_size must be a power of two */\n\n     pci_register_bar(&d->dev, 0, PCI_BASE_ADDRESS_MEM_PREFETCH, &s->pci_bar);\n\n     if (device_id == CIRRUS_ID_CLGD5446) {\n\n         pci_register_bar(&d->dev, 1, 0, &s->cirrus_mmio_io);\n\n\n     return 0;\n", "idx": 26328}
{"project": "qemu", "commit_id": "937470bb5470825e781ae50e92ff973a6b54d80f", "target": 1, "func": "static gboolean qio_channel_tls_handshake_io(QIOChannel *ioc,\n\n                                             GIOCondition condition,\n\n                                             gpointer user_data)\n\n{\n\n    QIOTask *task = user_data;\n\n    QIOChannelTLS *tioc = QIO_CHANNEL_TLS(\n\n        qio_task_get_source(task));\n\n\n\n    qio_channel_tls_handshake_task(\n\n       tioc, task);\n\n\n\n    object_unref(OBJECT(tioc));\n\n\n\n    return FALSE;\n\n}\n", "idx": 26330}
{"project": "qemu", "commit_id": "af60314291af3cabda18d27f928b0e0ff899cc76", "target": 1, "func": "static void vhost_commit(MemoryListener *listener)\n\n{\n\n}\n", "idx": 26331}
{"project": "qemu", "commit_id": "2886be1b01c274570fa139748a402207482405bd", "target": 1, "func": "static void pm_update_sci(VT686PMState *s)\n\n{\n\n    int sci_level, pmsts;\n\n\n\n    pmsts = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time);\n\n    sci_level = (((pmsts & s->ar.pm1.evt.en) &\n\n                  (ACPI_BITMASK_RT_CLOCK_ENABLE |\n\n                   ACPI_BITMASK_POWER_BUTTON_ENABLE |\n\n                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |\n\n                   ACPI_BITMASK_TIMER_ENABLE)) != 0);\n\n    qemu_set_irq(s->dev.irq[0], sci_level);\n\n    /* schedule a timer interruption if needed */\n\n    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&\n\n                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));\n\n}\n", "idx": 26333}
{"project": "qemu", "commit_id": "02b33596d09bafed5d58366403a2d369f0d1047e", "target": 1, "func": "static void dec_null(DisasContext *dc)\n\n{\n\n\n\n\n\n\n\n    qemu_log (\"unknown insn pc=%x opc=%x\\n\", dc->pc, dc->opcode);\n\n    dc->abort_at_next_insn = 1;\n", "idx": 26335}
{"project": "qemu", "commit_id": "3453f9a0dfa58578e6dadf0905ff4528b428ec73", "target": 1, "func": "static void usb_uas_task(UASDevice *uas, uas_ui *ui)\n\n{\n\n    uint16_t tag = be16_to_cpu(ui->hdr.tag);\n\n    uint64_t lun64 = be64_to_cpu(ui->task.lun);\n\n    SCSIDevice *dev = usb_uas_get_dev(uas, lun64);\n\n    int lun = usb_uas_get_lun(lun64);\n\n    UASRequest *req;\n\n    uint16_t task_tag;\n\n\n\n\n\n\n    req = usb_uas_find_request(uas, be16_to_cpu(ui->hdr.tag));\n\n    if (req) {\n\n        goto overlapped_tag;\n\n\n    if (dev == NULL) {\n\n        goto incorrect_lun;\n\n\n\n\n    switch (ui->task.function) {\n\n    case UAS_TMF_ABORT_TASK:\n\n        task_tag = be16_to_cpu(ui->task.task_tag);\n\n        trace_usb_uas_tmf_abort_task(uas->dev.addr, tag, task_tag);\n\n        req = usb_uas_find_request(uas, task_tag);\n\n        if (req && req->dev == dev) {\n\n            scsi_req_cancel(req->req);\n\n\n        usb_uas_queue_response(uas, tag, UAS_RC_TMF_COMPLETE, 0);\n\n        break;\n\n\n\n    case UAS_TMF_LOGICAL_UNIT_RESET:\n\n        trace_usb_uas_tmf_logical_unit_reset(uas->dev.addr, tag, lun);\n\n        qdev_reset_all(&dev->qdev);\n\n        usb_uas_queue_response(uas, tag, UAS_RC_TMF_COMPLETE, 0);\n\n        break;\n\n\n\n    default:\n\n        trace_usb_uas_tmf_unsupported(uas->dev.addr, tag, ui->task.function);\n\n        usb_uas_queue_response(uas, tag, UAS_RC_TMF_NOT_SUPPORTED, 0);\n\n        break;\n\n\n    return;\n\n\n\ninvalid_tag:\n\n    usb_uas_queue_response(uas, tag, UAS_RC_INVALID_INFO_UNIT, 0);\n\n    return;\n\n\n\noverlapped_tag:\n\n    usb_uas_queue_response(uas, req->tag, UAS_RC_OVERLAPPED_TAG, 0);\n\n    return;\n\n\n\nincorrect_lun:\n\n    usb_uas_queue_response(uas, tag, UAS_RC_INCORRECT_LUN, 0);\n", "idx": 26339}
{"project": "qemu", "commit_id": "66dc50f7057b9a0191f54e55764412202306858d", "target": 1, "func": "static int sch_handle_start_func_passthrough(SubchDev *sch)\n\n{\n\n\n\n    PMCW *p = &sch->curr_status.pmcw;\n\n    SCSW *s = &sch->curr_status.scsw;\n\n    int ret;\n\n\n\n    ORB *orb = &sch->orb;\n\n    if (!(s->ctrl & SCSW_ACTL_SUSP)) {\n\n        assert(orb != NULL);\n\n        p->intparm = orb->intparm;\n\n    }\n\n\n\n    /*\n\n     * Only support prefetch enable mode.\n\n     * Only support 64bit addressing idal.\n\n     */\n\n    if (!(orb->ctrl0 & ORB_CTRL0_MASK_PFCH) ||\n\n        !(orb->ctrl0 & ORB_CTRL0_MASK_C64)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    ret = s390_ccw_cmd_request(orb, s, sch->driver_data);\n\n    switch (ret) {\n\n    /* Currently we don't update control block and just return the cc code. */\n\n    case 0:\n\n        break;\n\n    case -EBUSY:\n\n        break;\n\n    case -ENODEV:\n\n        break;\n\n    case -EACCES:\n\n        /* Let's reflect an inaccessible host device by cc 3. */\n\n        ret = -ENODEV;\n\n        break;\n\n    default:\n\n       /*\n\n        * All other return codes will trigger a program check,\n\n        * or set cc to 1.\n\n        */\n\n       break;\n\n    };\n\n\n\n    return ret;\n\n}\n", "idx": 26340}
{"project": "qemu", "commit_id": "1d06cb7ab93f879ac25c9f5ef1d1ac8d97a42dfc", "target": 1, "func": "static int cmd_valid_while_locked(SDState *sd, SDRequest *req)\n\n{\n\n    /* Valid commands in locked state:\n\n     * basic class (0)\n\n     * lock card class (7)\n\n     * CMD16\n\n     * implicitly, the ACMD prefix CMD55\n\n     * ACMD41 and ACMD42\n\n     * Anything else provokes an \"illegal command\" response.\n\n     */\n\n    if (sd->card_status & APP_CMD) {\n\n        return req->cmd == 41 || req->cmd == 42;\n\n    }\n\n    if (req->cmd == 16 || req->cmd == 55) {\n\n        return 1;\n\n    }\n\n    return sd_cmd_class[req->cmd] == 0 || sd_cmd_class[req->cmd] == 7;\n\n}\n", "idx": 26341}
{"project": "qemu", "commit_id": "7a95434e0ca8a037fd8aa1a2e2461f92585eb77b", "target": 1, "func": "static struct dirent *local_readdir(FsContext *ctx, V9fsFidOpenState *fs)\n\n{\n\n    struct dirent *entry;\n\n\n\nagain:\n\n    entry = readdir(fs->dir.stream);\n\n    if (!entry) {\n\n        return NULL;\n\n    }\n\n\n\n    if (ctx->export_flags & V9FS_SM_MAPPED) {\n\n        entry->d_type = DT_UNKNOWN;\n\n    } else if (ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n\n        if (!strcmp(entry->d_name, VIRTFS_META_DIR)) {\n\n            /* skp the meta data directory */\n\n            goto again;\n\n        }\n\n        entry->d_type = DT_UNKNOWN;\n\n    }\n\n\n\n    return entry;\n\n}\n", "idx": 26346}
{"project": "qemu", "commit_id": "111049a4ecefc9cf1ac75c773f4c5c165f27fe63", "target": 1, "func": "void qmp_blockdev_backup(BlockdevBackup *arg, Error **errp)\n\n{\n\n    do_blockdev_backup(arg, NULL, errp);\n\n}\n", "idx": 26347}
{"project": "qemu", "commit_id": "70fbd3c4bf9850fce733eea2c910c397905fb9a3", "target": 1, "func": "static void fsl_imx6_class_init(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n    dc->realize = fsl_imx6_realize;\n\n\n\n    dc->desc = \"i.MX6 SOC\";\n\n}\n", "idx": 26349}
{"project": "qemu", "commit_id": "2ad645d2854746b55ddfd1d8e951f689cca5d78f", "target": 1, "func": "static void test_endianness_split(gconstpointer data)\n\n{\n\n    const TestCase *test = data;\n\n    char *args;\n\n\n\n    args = g_strdup_printf(\"-display none -M %s%s%s -device pc-testdev\",\n\n                           test->machine,\n\n                           test->superio ? \" -device \" : \"\",\n\n                           test->superio ?: \"\");\n\n    qtest_start(args);\n\n    isa_outl(test, 0xe8, 0x87654321);\n\n    g_assert_cmphex(isa_inl(test, 0xe0), ==, 0x87654321);\n\n    g_assert_cmphex(isa_inw(test, 0xe2), ==, 0x8765);\n\n    g_assert_cmphex(isa_inw(test, 0xe0), ==, 0x4321);\n\n\n\n    isa_outw(test, 0xea, 0x8866);\n\n    g_assert_cmphex(isa_inl(test, 0xe0), ==, 0x88664321);\n\n    g_assert_cmphex(isa_inw(test, 0xe2), ==, 0x8866);\n\n    g_assert_cmphex(isa_inw(test, 0xe0), ==, 0x4321);\n\n\n\n    isa_outw(test, 0xe8, 0x4422);\n\n    g_assert_cmphex(isa_inl(test, 0xe0), ==, 0x88664422);\n\n    g_assert_cmphex(isa_inw(test, 0xe2), ==, 0x8866);\n\n    g_assert_cmphex(isa_inw(test, 0xe0), ==, 0x4422);\n\n\n\n    isa_outb(test, 0xeb, 0x87);\n\n    g_assert_cmphex(isa_inl(test, 0xe0), ==, 0x87664422);\n\n    g_assert_cmphex(isa_inw(test, 0xe2), ==, 0x8766);\n\n\n\n    isa_outb(test, 0xea, 0x65);\n\n    g_assert_cmphex(isa_inl(test, 0xe0), ==, 0x87654422);\n\n    g_assert_cmphex(isa_inw(test, 0xe2), ==, 0x8765);\n\n    g_assert_cmphex(isa_inw(test, 0xe0), ==, 0x4422);\n\n\n\n    isa_outb(test, 0xe9, 0x43);\n\n    g_assert_cmphex(isa_inl(test, 0xe0), ==, 0x87654322);\n\n    g_assert_cmphex(isa_inw(test, 0xe2), ==, 0x8765);\n\n    g_assert_cmphex(isa_inw(test, 0xe0), ==, 0x4322);\n\n\n\n    isa_outb(test, 0xe8, 0x21);\n\n    g_assert_cmphex(isa_inl(test, 0xe0), ==, 0x87654321);\n\n    g_assert_cmphex(isa_inw(test, 0xe2), ==, 0x8765);\n\n    g_assert_cmphex(isa_inw(test, 0xe0), ==, 0x4321);\n\n    qtest_quit(global_qtest);\n\n    g_free(args);\n\n}\n", "idx": 26350}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtoull_whitespace(void)\n\n{\n\n    const char *str = \"  \\t  \";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    uint64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoull(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n", "idx": 26351}
{"project": "qemu", "commit_id": "9a93b61730e3b46ef1c01ca522c6abe80ec13832", "target": 1, "func": "static void msix_mmio_write(void *opaque, target_phys_addr_t addr,\n                            uint64_t val, unsigned size)\n{\n    PCIDevice *dev = opaque;\n    unsigned int offset = addr & (MSIX_PAGE_SIZE - 1) & ~0x3;\n    int vector = offset / PCI_MSIX_ENTRY_SIZE;\n    pci_set_long(dev->msix_table_page + offset, val);\n    msix_handle_mask_update(dev, vector);", "idx": 26355}
{"project": "qemu", "commit_id": "bdd81addf4033ce26e6cd180b060f63095f3ded9", "target": 1, "func": "static void vfio_msix_enable(VFIOPCIDevice *vdev)\n\n{\n\n    vfio_disable_interrupts(vdev);\n\n\n\n    vdev->msi_vectors = g_malloc0(vdev->msix->entries * sizeof(VFIOMSIVector));\n\n\n\n    vdev->interrupt = VFIO_INT_MSIX;\n\n\n\n    /*\n\n     * Some communication channels between VF & PF or PF & fw rely on the\n\n     * physical state of the device and expect that enabling MSI-X from the\n\n     * guest enables the same on the host.  When our guest is Linux, the\n\n     * guest driver call to pci_enable_msix() sets the enabling bit in the\n\n     * MSI-X capability, but leaves the vector table masked.  We therefore\n\n     * can't rely on a vector_use callback (from request_irq() in the guest)\n\n     * to switch the physical device into MSI-X mode because that may come a\n\n     * long time after pci_enable_msix().  This code enables vector 0 with\n\n     * triggering to userspace, then immediately release the vector, leaving\n\n     * the physical device with no vectors enabled, but MSI-X enabled, just\n\n     * like the guest view.\n\n     */\n\n    vfio_msix_vector_do_use(&vdev->pdev, 0, NULL, NULL);\n\n    vfio_msix_vector_release(&vdev->pdev, 0);\n\n\n\n    if (msix_set_vector_notifiers(&vdev->pdev, vfio_msix_vector_use,\n\n                                  vfio_msix_vector_release, NULL)) {\n\n        error_report(\"vfio: msix_set_vector_notifiers failed\");\n\n    }\n\n\n\n    trace_vfio_msix_enable(vdev->vbasedev.name);\n\n}\n", "idx": 26356}
{"project": "qemu", "commit_id": "cfd47a71df51047833d182e9e97244e7816b57da", "target": 1, "func": "static int check_bind(struct sockaddr *sa, socklen_t salen, bool *has_proto)\n\n{\n\n    int fd;\n\n\n\n    fd = socket(sa->sa_family, SOCK_STREAM, 0);\n\n    if (fd < 0) {\n\n        return -1;\n\n    }\n\n\n\n    if (bind(fd, sa, salen) < 0) {\n\n        close(fd);\n\n        if (errno == EADDRNOTAVAIL) {\n\n            *has_proto = false;\n\n            return 0;\n\n        }\n\n        return -1;\n\n    }\n\n\n\n    close(fd);\n\n    *has_proto = true;\n\n    return 0;\n\n}\n", "idx": 26357}
{"project": "qemu", "commit_id": "a1f7f97b950a46393b0e55a9a0082e70f540cbbd", "target": 1, "func": "static void mmubooke_create_initial_mapping(CPUPPCState *env,\n\n                                     target_ulong va,\n\n                                     hwaddr pa)\n\n{\n\n    ppcemb_tlb_t *tlb = &env->tlb.tlbe[0];\n\n\n\n    tlb->attr = 0;\n\n    tlb->prot = PAGE_VALID | ((PAGE_READ | PAGE_WRITE | PAGE_EXEC) << 4);\n\n    tlb->size = 1 << 31; /* up to 0x80000000  */\n\n    tlb->EPN = va & TARGET_PAGE_MASK;\n\n    tlb->RPN = pa & TARGET_PAGE_MASK;\n\n    tlb->PID = 0;\n\n\n\n    tlb = &env->tlb.tlbe[1];\n\n    tlb->attr = 0;\n\n    tlb->prot = PAGE_VALID | ((PAGE_READ | PAGE_WRITE | PAGE_EXEC) << 4);\n\n    tlb->size = 1 << 31; /* up to 0xffffffff  */\n\n    tlb->EPN = 0x80000000 & TARGET_PAGE_MASK;\n\n    tlb->RPN = 0x80000000 & TARGET_PAGE_MASK;\n\n    tlb->PID = 0;\n\n}\n", "idx": 26361}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "struct pxa2xx_pcmcia_s *pxa2xx_pcmcia_init(target_phys_addr_t base)\n\n{\n\n    int iomemtype;\n\n    struct pxa2xx_pcmcia_s *s;\n\n\n\n    s = (struct pxa2xx_pcmcia_s *)\n\n            qemu_mallocz(sizeof(struct pxa2xx_pcmcia_s));\n\n\n\n    /* Socket I/O Memory Space */\n\n    s->io_base = base | 0x00000000;\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_pcmcia_io_readfn,\n\n                    pxa2xx_pcmcia_io_writefn, s);\n\n    cpu_register_physical_memory(s->io_base, 0x03ffffff, iomemtype);\n\n\n\n    /* Then next 64 MB is reserved */\n\n\n\n    /* Socket Attribute Memory Space */\n\n    s->attr_base = base | 0x08000000;\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_pcmcia_attr_readfn,\n\n                    pxa2xx_pcmcia_attr_writefn, s);\n\n    cpu_register_physical_memory(s->attr_base, 0x03ffffff, iomemtype);\n\n\n\n    /* Socket Common Memory Space */\n\n    s->common_base = base | 0x0c000000;\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_pcmcia_common_readfn,\n\n                    pxa2xx_pcmcia_common_writefn, s);\n\n    cpu_register_physical_memory(s->common_base, 0x03ffffff, iomemtype);\n\n\n\n    if (base == 0x30000000)\n\n        s->slot.slot_string = \"PXA PC Card Socket 1\";\n\n    else\n\n        s->slot.slot_string = \"PXA PC Card Socket 0\";\n\n    s->slot.irq = qemu_allocate_irqs(pxa2xx_pcmcia_set_irq, s, 1)[0];\n\n    pcmcia_socket_register(&s->slot);\n\n\n\n    return s;\n\n}\n", "idx": 26362}
{"project": "qemu", "commit_id": "5dd7a535b71a0f2f8e7af75c5d694174359ce323", "target": 1, "func": "static void iscsi_timed_set_events(void *opaque)\n\n{\n\n    IscsiLun *iscsilun = opaque;\n\n    iscsi_set_events(iscsilun);\n\n}\n", "idx": 26365}
{"project": "qemu", "commit_id": "b307446e04232b3a87e9da04886895a8e5a4a407", "target": 1, "func": "void mips_cpu_dump_state(CPUState *cs, FILE *f, fprintf_function cpu_fprintf,\n\n                         int flags)\n\n{\n\n    MIPSCPU *cpu = MIPS_CPU(cs);\n\n    CPUMIPSState *env = &cpu->env;\n\n    int i;\n\n\n\n    cpu_fprintf(f, \"pc=0x\" TARGET_FMT_lx \" HI=0x\" TARGET_FMT_lx\n\n                \" LO=0x\" TARGET_FMT_lx \" ds %04x \"\n\n                TARGET_FMT_lx \" \" TARGET_FMT_ld \"\\n\",\n\n                env->active_tc.PC, env->active_tc.HI[0], env->active_tc.LO[0],\n\n                env->hflags, env->btarget, env->bcond);\n\n    for (i = 0; i < 32; i++) {\n\n        if ((i & 3) == 0)\n\n            cpu_fprintf(f, \"GPR%02d:\", i);\n\n        cpu_fprintf(f, \" %s \" TARGET_FMT_lx, regnames[i], env->active_tc.gpr[i]);\n\n        if ((i & 3) == 3)\n\n            cpu_fprintf(f, \"\\n\");\n\n    }\n\n\n\n    cpu_fprintf(f, \"CP0 Status  0x%08x Cause   0x%08x EPC    0x\" TARGET_FMT_lx \"\\n\",\n\n                env->CP0_Status, env->CP0_Cause, env->CP0_EPC);\n\n    cpu_fprintf(f, \"    Config0 0x%08x Config1 0x%08x LLAddr 0x%016\"\n\n                PRIx64 \"\\n\",\n\n                env->CP0_Config0, env->CP0_Config1, env->lladdr);\n\n    cpu_fprintf(f, \"    Config2 0x%08x Config3 0x%08x\\n\",\n\n                env->CP0_Config2, env->CP0_Config3);\n\n    cpu_fprintf(f, \"    Config4 0x%08x Config5 0x%08x\\n\",\n\n                env->CP0_Config4, env->CP0_Config5);\n\n    if (env->hflags & MIPS_HFLAG_FPU)\n\n        fpu_dump_state(env, f, cpu_fprintf, flags);\n\n#if defined(TARGET_MIPS64) && defined(MIPS_DEBUG_SIGN_EXTENSIONS)\n\n    cpu_mips_check_sign_extensions(env, f, cpu_fprintf, flags);\n\n#endif\n\n}\n", "idx": 26366}
{"project": "qemu", "commit_id": "49cffbc6079c27432b4635d5d03ce14a249d86e2", "target": 1, "func": "void virtio_blk_submit_multireq(BlockBackend *blk, MultiReqBuffer *mrb)\n\n{\n\n    int i = 0, start = 0, num_reqs = 0, niov = 0, nb_sectors = 0;\n\n    int max_xfer_len = 0;\n\n    int64_t sector_num = 0;\n\n\n\n    if (mrb->num_reqs == 1) {\n\n        submit_requests(blk, mrb, 0, 1, -1);\n\n        mrb->num_reqs = 0;\n\n        return;\n\n    }\n\n\n\n    max_xfer_len = blk_get_max_transfer_length(mrb->reqs[0]->dev->blk);\n\n    max_xfer_len = MIN_NON_ZERO(max_xfer_len, BDRV_REQUEST_MAX_SECTORS);\n\n\n\n    qsort(mrb->reqs, mrb->num_reqs, sizeof(*mrb->reqs),\n\n          &multireq_compare);\n\n\n\n    for (i = 0; i < mrb->num_reqs; i++) {\n\n        VirtIOBlockReq *req = mrb->reqs[i];\n\n        if (num_reqs > 0) {\n\n            bool merge = true;\n\n\n\n            /* merge would exceed maximum number of IOVs */\n\n            if (niov + req->qiov.niov > IOV_MAX) {\n\n                merge = false;\n\n            }\n\n\n\n            /* merge would exceed maximum transfer length of backend device */\n\n            if (req->qiov.size / BDRV_SECTOR_SIZE + nb_sectors > max_xfer_len) {\n\n                merge = false;\n\n            }\n\n\n\n            /* requests are not sequential */\n\n            if (sector_num + nb_sectors != req->sector_num) {\n\n                merge = false;\n\n            }\n\n\n\n            if (!merge) {\n\n                submit_requests(blk, mrb, start, num_reqs, niov);\n\n                num_reqs = 0;\n\n            }\n\n        }\n\n\n\n        if (num_reqs == 0) {\n\n            sector_num = req->sector_num;\n\n            nb_sectors = niov = 0;\n\n            start = i;\n\n        }\n\n\n\n        nb_sectors += req->qiov.size / BDRV_SECTOR_SIZE;\n\n        niov += req->qiov.niov;\n\n        num_reqs++;\n\n    }\n\n\n\n    submit_requests(blk, mrb, start, num_reqs, niov);\n\n    mrb->num_reqs = 0;\n\n}\n", "idx": 26368}
{"project": "qemu", "commit_id": "0d931d706266d6ada3bf22d3afca1afdc8d12fa9", "target": 1, "func": "static gboolean serial_xmit(GIOChannel *chan, GIOCondition cond, void *opaque)\n\n{\n\n    SerialState *s = opaque;\n\n\n\n    do {\n\n        if (s->tsr_retry <= 0) {\n\n            if (s->fcr & UART_FCR_FE) {\n\n                if (fifo8_is_empty(&s->xmit_fifo)) {\n\n                    return FALSE;\n\n                }\n\n                s->tsr = fifo8_pop(&s->xmit_fifo);\n\n                if (!s->xmit_fifo.num) {\n\n                    s->lsr |= UART_LSR_THRE;\n\n                }\n\n            } else if ((s->lsr & UART_LSR_THRE)) {\n\n                return FALSE;\n\n            } else {\n\n                s->tsr = s->thr;\n\n                s->lsr |= UART_LSR_THRE;\n\n                s->lsr &= ~UART_LSR_TEMT;\n\n            }\n\n        }\n\n\n\n        if (s->mcr & UART_MCR_LOOP) {\n\n            /* in loopback mode, say that we just received a char */\n\n            serial_receive1(s, &s->tsr, 1);\n\n        } else if (qemu_chr_fe_write(s->chr, &s->tsr, 1) != 1) {\n\n            if (s->tsr_retry >= 0 && s->tsr_retry < MAX_XMIT_RETRY &&\n\n                qemu_chr_fe_add_watch(s->chr, G_IO_OUT|G_IO_HUP,\n\n                                      serial_xmit, s) > 0) {\n\n                s->tsr_retry++;\n\n                return FALSE;\n\n            }\n\n            s->tsr_retry = 0;\n\n        } else {\n\n            s->tsr_retry = 0;\n\n        }\n\n        /* Transmit another byte if it is already available. It is only\n\n           possible when FIFO is enabled and not empty. */\n\n    } while ((s->fcr & UART_FCR_FE) && !fifo8_is_empty(&s->xmit_fifo));\n\n\n\n    s->last_xmit_ts = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n\n\n\n    if (s->lsr & UART_LSR_THRE) {\n\n        s->lsr |= UART_LSR_TEMT;\n\n        s->thr_ipending = 1;\n\n        serial_update_irq(s);\n\n    }\n\n\n\n    return FALSE;\n\n}\n", "idx": 26369}
{"project": "qemu", "commit_id": "56faeb9bb6872b3f926b3b3e0452a70beea10af2", "target": 1, "func": "static int qemu_gluster_parse_json(BlockdevOptionsGluster *gconf,\n\n                                  QDict *options, Error **errp)\n\n{\n\n    QemuOpts *opts;\n\n    SocketAddress *gsconf = NULL;\n\n    SocketAddressList *curr = NULL;\n\n    QDict *backing_options = NULL;\n\n    Error *local_err = NULL;\n\n    char *str = NULL;\n\n    const char *ptr;\n\n    size_t num_servers;\n\n    int i, type;\n\n\n\n    /* create opts info from runtime_json_opts list */\n\n    opts = qemu_opts_create(&runtime_json_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n\n\n    num_servers = qdict_array_entries(options, GLUSTER_OPT_SERVER_PATTERN);\n\n    if (num_servers < 1) {\n\n        error_setg(&local_err, QERR_MISSING_PARAMETER, \"server\");\n\n        goto out;\n\n    }\n\n\n\n    ptr = qemu_opt_get(opts, GLUSTER_OPT_VOLUME);\n\n    if (!ptr) {\n\n        error_setg(&local_err, QERR_MISSING_PARAMETER, GLUSTER_OPT_VOLUME);\n\n        goto out;\n\n    }\n\n    gconf->volume = g_strdup(ptr);\n\n\n\n    ptr = qemu_opt_get(opts, GLUSTER_OPT_PATH);\n\n    if (!ptr) {\n\n        error_setg(&local_err, QERR_MISSING_PARAMETER, GLUSTER_OPT_PATH);\n\n        goto out;\n\n    }\n\n    gconf->path = g_strdup(ptr);\n\n    qemu_opts_del(opts);\n\n\n\n    for (i = 0; i < num_servers; i++) {\n\n        str = g_strdup_printf(GLUSTER_OPT_SERVER_PATTERN\"%d.\", i);\n\n        qdict_extract_subqdict(options, &backing_options, str);\n\n\n\n        /* create opts info from runtime_type_opts list */\n\n        opts = qemu_opts_create(&runtime_type_opts, NULL, 0, &error_abort);\n\n        qemu_opts_absorb_qdict(opts, backing_options, &local_err);\n\n        if (local_err) {\n\n            goto out;\n\n        }\n\n\n\n        ptr = qemu_opt_get(opts, GLUSTER_OPT_TYPE);\n\n        if (!ptr) {\n\n            error_setg(&local_err, QERR_MISSING_PARAMETER, GLUSTER_OPT_TYPE);\n\n            error_append_hint(&local_err, GERR_INDEX_HINT, i);\n\n            goto out;\n\n\n\n        }\n\n        gsconf = g_new0(SocketAddress, 1);\n\n        if (!strcmp(ptr, \"tcp\")) {\n\n            ptr = \"inet\";       /* accept legacy \"tcp\" */\n\n        }\n\n        type = qapi_enum_parse(SocketAddressType_lookup, ptr,\n\n                               SOCKET_ADDRESS_TYPE__MAX, -1, NULL);\n\n        if (type != SOCKET_ADDRESS_TYPE_INET\n\n            && type != SOCKET_ADDRESS_TYPE_UNIX) {\n\n            error_setg(&local_err,\n\n                       \"Parameter '%s' may be 'inet' or 'unix'\",\n\n                       GLUSTER_OPT_TYPE);\n\n            error_append_hint(&local_err, GERR_INDEX_HINT, i);\n\n            goto out;\n\n        }\n\n        gsconf->type = type;\n\n        qemu_opts_del(opts);\n\n\n\n        if (gsconf->type == SOCKET_ADDRESS_TYPE_INET) {\n\n            /* create opts info from runtime_inet_opts list */\n\n            opts = qemu_opts_create(&runtime_inet_opts, NULL, 0, &error_abort);\n\n            qemu_opts_absorb_qdict(opts, backing_options, &local_err);\n\n            if (local_err) {\n\n                goto out;\n\n            }\n\n\n\n            ptr = qemu_opt_get(opts, GLUSTER_OPT_HOST);\n\n            if (!ptr) {\n\n                error_setg(&local_err, QERR_MISSING_PARAMETER,\n\n                           GLUSTER_OPT_HOST);\n\n                error_append_hint(&local_err, GERR_INDEX_HINT, i);\n\n                goto out;\n\n            }\n\n            gsconf->u.inet.host = g_strdup(ptr);\n\n            ptr = qemu_opt_get(opts, GLUSTER_OPT_PORT);\n\n            if (!ptr) {\n\n                error_setg(&local_err, QERR_MISSING_PARAMETER,\n\n                           GLUSTER_OPT_PORT);\n\n                error_append_hint(&local_err, GERR_INDEX_HINT, i);\n\n                goto out;\n\n            }\n\n            gsconf->u.inet.port = g_strdup(ptr);\n\n\n\n            /* defend for unsupported fields in InetSocketAddress,\n\n             * i.e. @ipv4, @ipv6  and @to\n\n             */\n\n            ptr = qemu_opt_get(opts, GLUSTER_OPT_TO);\n\n            if (ptr) {\n\n                gsconf->u.inet.has_to = true;\n\n            }\n\n            ptr = qemu_opt_get(opts, GLUSTER_OPT_IPV4);\n\n            if (ptr) {\n\n                gsconf->u.inet.has_ipv4 = true;\n\n            }\n\n            ptr = qemu_opt_get(opts, GLUSTER_OPT_IPV6);\n\n            if (ptr) {\n\n                gsconf->u.inet.has_ipv6 = true;\n\n            }\n\n            if (gsconf->u.inet.has_to) {\n\n                error_setg(&local_err, \"Parameter 'to' not supported\");\n\n                goto out;\n\n            }\n\n            if (gsconf->u.inet.has_ipv4 || gsconf->u.inet.has_ipv6) {\n\n                error_setg(&local_err, \"Parameters 'ipv4/ipv6' not supported\");\n\n                goto out;\n\n            }\n\n            qemu_opts_del(opts);\n\n        } else {\n\n            /* create opts info from runtime_unix_opts list */\n\n            opts = qemu_opts_create(&runtime_unix_opts, NULL, 0, &error_abort);\n\n            qemu_opts_absorb_qdict(opts, backing_options, &local_err);\n\n            if (local_err) {\n\n                goto out;\n\n            }\n\n\n\n            ptr = qemu_opt_get(opts, GLUSTER_OPT_SOCKET);\n\n            if (!ptr) {\n\n                error_setg(&local_err, QERR_MISSING_PARAMETER,\n\n                           GLUSTER_OPT_SOCKET);\n\n                error_append_hint(&local_err, GERR_INDEX_HINT, i);\n\n                goto out;\n\n            }\n\n            gsconf->u.q_unix.path = g_strdup(ptr);\n\n            qemu_opts_del(opts);\n\n        }\n\n\n\n        if (gconf->server == NULL) {\n\n            gconf->server = g_new0(SocketAddressList, 1);\n\n            gconf->server->value = gsconf;\n\n            curr = gconf->server;\n\n        } else {\n\n            curr->next = g_new0(SocketAddressList, 1);\n\n            curr->next->value = gsconf;\n\n            curr = curr->next;\n\n        }\n\n        gsconf = NULL;\n\n\n\n        QDECREF(backing_options);\n\n        backing_options = NULL;\n\n        g_free(str);\n\n        str = NULL;\n\n    }\n\n\n\n    return 0;\n\n\n\nout:\n\n    error_propagate(errp, local_err);\n\n    qapi_free_SocketAddress(gsconf);\n\n    qemu_opts_del(opts);\n\n    g_free(str);\n\n    QDECREF(backing_options);\n\n    errno = EINVAL;\n\n    return -errno;\n\n}\n", "idx": 26371}
{"project": "qemu", "commit_id": "14cec170ea4724e6881ba2febb20e88a942e52d3", "target": 1, "func": "static int xen_pt_bar_reg_read(XenPCIPassthroughState *s, XenPTReg *cfg_entry,\n\n                               uint32_t *value, uint32_t valid_mask)\n\n{\n\n    XenPTRegInfo *reg = cfg_entry->reg;\n\n    uint32_t valid_emu_mask = 0;\n\n    uint32_t bar_emu_mask = 0;\n\n    int index;\n\n\n\n    /* get BAR index */\n\n    index = xen_pt_bar_offset_to_index(reg->offset);\n\n    if (index < 0 || index >= PCI_NUM_REGIONS) {\n\n        XEN_PT_ERR(&s->dev, \"Internal error: Invalid BAR index [%d].\\n\", index);\n\n        return -1;\n\n    }\n\n\n\n    /* use fixed-up value from kernel sysfs */\n\n    *value = base_address_with_flags(&s->real_device.io_regions[index]);\n\n\n\n    /* set emulate mask depend on BAR flag */\n\n    switch (s->bases[index].bar_flag) {\n\n    case XEN_PT_BAR_FLAG_MEM:\n\n        bar_emu_mask = XEN_PT_BAR_MEM_EMU_MASK;\n\n        break;\n\n    case XEN_PT_BAR_FLAG_IO:\n\n        bar_emu_mask = XEN_PT_BAR_IO_EMU_MASK;\n\n        break;\n\n    case XEN_PT_BAR_FLAG_UPPER:\n\n        bar_emu_mask = XEN_PT_BAR_ALLF;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* emulate BAR */\n\n    valid_emu_mask = bar_emu_mask & valid_mask;\n\n    *value = XEN_PT_MERGE_VALUE(*value, cfg_entry->data, ~valid_emu_mask);\n\n\n\n    return 0;\n\n}\n", "idx": 26372}
{"project": "qemu", "commit_id": "d1f06fe665acdd7aa7a46a5ef88172c3d7d3028e", "target": 1, "func": "static int try_seek_hole(BlockDriverState *bs, off_t start, off_t *data,\n\n                         off_t *hole)\n\n{\n\n#if defined SEEK_HOLE && defined SEEK_DATA\n\n    BDRVRawState *s = bs->opaque;\n\n\n\n    *hole = lseek(s->fd, start, SEEK_HOLE);\n\n    if (*hole == -1) {\n\n        return -errno;\n\n    }\n\n\n\n    if (*hole > start) {\n\n        *data = start;\n\n    } else {\n\n        /* On a hole.  We need another syscall to find its end.  */\n\n        *data = lseek(s->fd, start, SEEK_DATA);\n\n        if (*data == -1) {\n\n            *data = lseek(s->fd, 0, SEEK_END);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n#else\n\n    return -ENOTSUP;\n\n#endif\n\n}\n", "idx": 26373}
{"project": "qemu", "commit_id": "833c7174ce5145397d2b3405f6857ca607fed1f1", "target": 1, "func": "static int net_client_init(const char *str)\n\n{\n\n    const char *p;\n\n    char *q;\n\n    char device[64];\n\n    char buf[1024];\n\n    int vlan_id, ret;\n\n    VLANState *vlan;\n\n\n\n    p = str;\n\n    q = device;\n\n    while (*p != '\\0' && *p != ',') {\n\n        if ((q - device) < sizeof(device) - 1)\n\n            *q++ = *p;\n\n        p++;\n\n    }\n\n    *q = '\\0';\n\n    if (*p == ',')\n\n        p++;\n\n    vlan_id = 0;\n\n    if (get_param_value(buf, sizeof(buf), \"vlan\", p)) {\n\n        vlan_id = strtol(buf, NULL, 0);\n\n    }\n\n    vlan = qemu_find_vlan(vlan_id);\n\n    if (!vlan) {\n\n        fprintf(stderr, \"Could not create vlan %d\\n\", vlan_id);\n\n        return -1;\n\n    }\n\n    if (!strcmp(device, \"nic\")) {\n\n        NICInfo *nd;\n\n        uint8_t *macaddr;\n\n\n\n        if (nb_nics >= MAX_NICS) {\n\n            fprintf(stderr, \"Too Many NICs\\n\");\n\n            return -1;\n\n        }\n\n        nd = &nd_table[nb_nics];\n\n        macaddr = nd->macaddr;\n\n        macaddr[0] = 0x52;\n\n        macaddr[1] = 0x54;\n\n        macaddr[2] = 0x00;\n\n        macaddr[3] = 0x12;\n\n        macaddr[4] = 0x34;\n\n        macaddr[5] = 0x56 + nb_nics;\n\n\n\n        if (get_param_value(buf, sizeof(buf), \"macaddr\", p)) {\n\n            if (parse_macaddr(macaddr, buf) < 0) {\n\n                fprintf(stderr, \"invalid syntax for ethernet address\\n\");\n\n                return -1;\n\n            }\n\n        }\n\n        if (get_param_value(buf, sizeof(buf), \"model\", p)) {\n\n            nd->model = strdup(buf);\n\n        }\n\n        nd->vlan = vlan;\n\n        nb_nics++;\n\n        vlan->nb_guest_devs++;\n\n        ret = 0;\n\n    } else\n\n    if (!strcmp(device, \"none\")) {\n\n        /* does nothing. It is needed to signal that no network cards\n\n           are wanted */\n\n        ret = 0;\n\n    } else\n\n#ifdef CONFIG_SLIRP\n\n    if (!strcmp(device, \"user\")) {\n\n        if (get_param_value(buf, sizeof(buf), \"hostname\", p)) {\n\n            pstrcpy(slirp_hostname, sizeof(slirp_hostname), buf);\n\n        }\n\n\n        ret = net_slirp_init(vlan);\n\n    } else\n\n#endif\n\n#ifdef _WIN32\n\n    if (!strcmp(device, \"tap\")) {\n\n        char ifname[64];\n\n        if (get_param_value(ifname, sizeof(ifname), \"ifname\", p) <= 0) {\n\n            fprintf(stderr, \"tap: no interface name\\n\");\n\n            return -1;\n\n        }\n\n\n        ret = tap_win32_init(vlan, ifname);\n\n    } else\n\n#else\n\n    if (!strcmp(device, \"tap\")) {\n\n        char ifname[64];\n\n        char setup_script[1024];\n\n        int fd;\n\n        if (get_param_value(buf, sizeof(buf), \"fd\", p) > 0) {\n\n            fd = strtol(buf, NULL, 0);\n\n            ret = -1;\n\n            if (net_tap_fd_init(vlan, fd))\n\n                ret = 0;\n\n        } else {\n\n            if (get_param_value(ifname, sizeof(ifname), \"ifname\", p) <= 0) {\n\n                ifname[0] = '\\0';\n\n            }\n\n            if (get_param_value(setup_script, sizeof(setup_script), \"script\", p) == 0) {\n\n                pstrcpy(setup_script, sizeof(setup_script), DEFAULT_NETWORK_SCRIPT);\n\n            }\n\n\n            ret = net_tap_init(vlan, ifname, setup_script);\n\n        }\n\n    } else\n\n#endif\n\n    if (!strcmp(device, \"socket\")) {\n\n        if (get_param_value(buf, sizeof(buf), \"fd\", p) > 0) {\n\n            int fd;\n\n            fd = strtol(buf, NULL, 0);\n\n            ret = -1;\n\n            if (net_socket_fd_init(vlan, fd, 1))\n\n                ret = 0;\n\n        } else if (get_param_value(buf, sizeof(buf), \"listen\", p) > 0) {\n\n            ret = net_socket_listen_init(vlan, buf);\n\n        } else if (get_param_value(buf, sizeof(buf), \"connect\", p) > 0) {\n\n            ret = net_socket_connect_init(vlan, buf);\n\n        } else if (get_param_value(buf, sizeof(buf), \"mcast\", p) > 0) {\n\n            ret = net_socket_mcast_init(vlan, buf);\n\n        } else {\n\n            fprintf(stderr, \"Unknown socket options: %s\\n\", p);\n\n            return -1;\n\n        }\n\n\n    } else\n\n    {\n\n        fprintf(stderr, \"Unknown network device: %s\\n\", device);\n\n        return -1;\n\n    }\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"Could not initialize device '%s'\\n\", device);\n\n    }\n\n    \n\n    return ret;\n\n}", "idx": 26374}
{"project": "qemu", "commit_id": "fa4ba923bd539647ace9d70d226a848bd6a89dac", "target": 1, "func": "static void kvm_io_ioeventfd_add(MemoryListener *listener,\n\n                                 MemoryRegionSection *section,\n\n                                 bool match_data, uint64_t data,\n\n                                 EventNotifier *e)\n\n{\n\n    int fd = event_notifier_get_fd(e);\n\n    int r;\n\n\n\n    r = kvm_set_ioeventfd_pio(fd, section->offset_within_address_space,\n\n                              data, true, int128_get64(section->size),\n\n                              match_data);\n\n    if (r < 0) {\n\n\n\n        abort();\n\n    }\n\n}", "idx": 26375}
{"project": "qemu", "commit_id": "e7b921c2d9efc249f99b9feb0e7dca82c96aa5c4", "target": 1, "func": "static inline bool regime_is_secure(CPUARMState *env, ARMMMUIdx mmu_idx)\n\n{\n\n    switch (mmu_idx) {\n\n    case ARMMMUIdx_S12NSE0:\n\n    case ARMMMUIdx_S12NSE1:\n\n    case ARMMMUIdx_S1NSE0:\n\n    case ARMMMUIdx_S1NSE1:\n\n    case ARMMMUIdx_S1E2:\n\n    case ARMMMUIdx_S2NS:\n\n\n\n        return false;\n\n    case ARMMMUIdx_S1E3:\n\n    case ARMMMUIdx_S1SE0:\n\n    case ARMMMUIdx_S1SE1:\n\n        return true;\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n}", "idx": 26377}
{"project": "qemu", "commit_id": "7faa8075d898ae56d2c533c530569bb25ab86eaf", "target": 1, "func": "static uint32_t pci_up_read(void *opaque, uint32_t addr)\n\n{\n\n    PIIX4PMState *s = opaque;\n\n    uint32_t val = s->pci0_status.up;\n\n\n\n    PIIX4_DPRINTF(\"pci_up_read %x\\n\", val);\n\n    return val;\n\n}\n", "idx": 26380}
{"project": "qemu", "commit_id": "10f5a72f70862d299ddbdf226d6dc71fa4ae34dd", "target": 1, "func": "static void virtio_blk_rw_complete(void *opaque, int ret)\n\n{\n\n    VirtIOBlockReq *next = opaque;\n\n\n\n    while (next) {\n\n        VirtIOBlockReq *req = next;\n\n        next = req->mr_next;\n\n        trace_virtio_blk_rw_complete(req, ret);\n\n\n\n        if (req->qiov.nalloc != -1) {\n\n            /* If nalloc is != 1 req->qiov is a local copy of the original\n\n             * external iovec. It was allocated in submit_merged_requests\n\n             * to be able to merge requests. */\n\n            qemu_iovec_destroy(&req->qiov);\n\n        }\n\n\n\n        if (ret) {\n\n            int p = virtio_ldl_p(VIRTIO_DEVICE(req->dev), &req->out.type);\n\n            bool is_read = !(p & VIRTIO_BLK_T_OUT);\n\n            /* Note that memory may be dirtied on read failure.  If the\n\n             * virtio request is not completed here, as is the case for\n\n             * BLOCK_ERROR_ACTION_STOP, the memory may not be copied\n\n             * correctly during live migration.  While this is ugly,\n\n             * it is acceptable because the device is free to write to\n\n             * the memory until the request is completed (which will\n\n             * happen on the other side of the migration).\n\n\n            if (virtio_blk_handle_rw_error(req, -ret, is_read)) {\n\n\n\n\n\n                continue;\n\n            }\n\n        }\n\n\n\n        virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);\n\n        block_acct_done(blk_get_stats(req->dev->blk), &req->acct);\n\n        virtio_blk_free_request(req);\n\n    }\n\n}", "idx": 26384}
{"project": "qemu", "commit_id": "e58d695e6c3a5cfa0aa2fc91b87ade017ef28b05", "target": 1, "func": "static void qmp_input_type_str(Visitor *v, const char *name, char **obj,\n\n                               Error **errp)\n\n{\n\n    QmpInputVisitor *qiv = to_qiv(v);\n\n    QString *qstr = qobject_to_qstring(qmp_input_get_object(qiv, name, true));\n\n\n\n    if (!qstr) {\n\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"string\");\n\n        return;\n\n    }\n\n\n\n    *obj = g_strdup(qstring_get_str(qstr));\n\n}", "idx": 26385}
{"project": "qemu", "commit_id": "ba2ab2f2ca4150a7e314fbb19fa158bd8ddc36eb", "target": 1, "func": "static int qcow2_create2(const char *filename, int64_t total_size,\n                         const char *backing_file, const char *backing_format,\n                         int flags, size_t cluster_size, int prealloc,\n                         QEMUOptionParameter *options, int version,\n                         Error **errp)\n{\n    /* Calculate cluster_bits */\n    int cluster_bits;\n    cluster_bits = ffs(cluster_size) - 1;\n    if (cluster_bits < MIN_CLUSTER_BITS || cluster_bits > MAX_CLUSTER_BITS ||\n        (1 << cluster_bits) != cluster_size)\n    {\n        error_setg(errp, \"Cluster size must be a power of two between %d and \"\n                   \"%dk\", 1 << MIN_CLUSTER_BITS, 1 << (MAX_CLUSTER_BITS - 10));\n        return -EINVAL;\n    /*\n     * Open the image file and write a minimal qcow2 header.\n     *\n     * We keep things simple and start with a zero-sized image. We also\n     * do without refcount blocks or a L1 table for now. We'll fix the\n     * inconsistency later.\n     *\n     * We do need a refcount table because growing the refcount table means\n     * allocating two new refcount blocks - the seconds of which would be at\n     * 2 GB for 64k clusters, and we don't want to have a 2 GB initial file\n     * size for any qcow2 image.\n     */\n    BlockDriverState* bs;\n    QCowHeader header;\n    uint8_t* refcount_table;\n    Error *local_err = NULL;\n    int ret;\n    ret = bdrv_create_file(filename, options, &local_err);\n    if (ret < 0) {\n        return ret;\n    ret = bdrv_file_open(&bs, filename, NULL, BDRV_O_RDWR, &local_err);\n    if (ret < 0) {\n        return ret;\n    /* Write the header */\n    memset(&header, 0, sizeof(header));\n    header.magic = cpu_to_be32(QCOW_MAGIC);\n    header.version = cpu_to_be32(version);\n    header.cluster_bits = cpu_to_be32(cluster_bits);\n    header.size = cpu_to_be64(0);\n    header.l1_table_offset = cpu_to_be64(0);\n    header.l1_size = cpu_to_be32(0);\n    header.refcount_table_offset = cpu_to_be64(cluster_size);\n    header.refcount_table_clusters = cpu_to_be32(1);\n    header.refcount_order = cpu_to_be32(3 + REFCOUNT_SHIFT);\n    header.header_length = cpu_to_be32(sizeof(header));\n    if (flags & BLOCK_FLAG_ENCRYPT) {\n        header.crypt_method = cpu_to_be32(QCOW_CRYPT_AES);\n    } else {\n        header.crypt_method = cpu_to_be32(QCOW_CRYPT_NONE);\n    if (flags & BLOCK_FLAG_LAZY_REFCOUNTS) {\n        header.compatible_features |=\n            cpu_to_be64(QCOW2_COMPAT_LAZY_REFCOUNTS);\n    ret = bdrv_pwrite(bs, 0, &header, sizeof(header));\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not write qcow2 header\");\n    /* Write an empty refcount table */\n    refcount_table = g_malloc0(cluster_size);\n    ret = bdrv_pwrite(bs, cluster_size, refcount_table, cluster_size);\n    g_free(refcount_table);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not write refcount table\");\n    /*\n     * And now open the image and make it consistent first (i.e. increase the\n     * refcount of the cluster that is occupied by the header and the refcount\n     * table)\n     */\n    BlockDriver* drv = bdrv_find_format(\"qcow2\");\n    assert(drv != NULL);\n        BDRV_O_RDWR | BDRV_O_CACHE_WB | BDRV_O_NO_FLUSH, drv, &local_err);\n    if (ret < 0) {\n    ret = qcow2_alloc_clusters(bs, 2 * cluster_size);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not allocate clusters for qcow2 \"\n                         \"header and refcount table\");\n    } else if (ret != 0) {\n        error_report(\"Huh, first cluster in empty image is already in use?\");\n        abort();\n    /* Okay, now that we have a valid image, let's give it the right size */\n    ret = bdrv_truncate(bs, total_size * BDRV_SECTOR_SIZE);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not resize image\");\n    /* Want a backing file? There you go.*/\n    if (backing_file) {\n        ret = bdrv_change_backing_file(bs, backing_file, backing_format);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not assign backing file '%s' \"\n                             \"with format '%s'\", backing_file, backing_format);\n    /* And if we're supposed to preallocate metadata, do that now */\n    if (prealloc) {\n        BDRVQcowState *s = bs->opaque;\n        qemu_co_mutex_lock(&s->lock);\n        ret = preallocate(bs);\n        qemu_co_mutex_unlock(&s->lock);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not preallocate metadata\");\n    ret = 0;\nout:\n    bdrv_unref(bs);\n    return ret;", "idx": 26388}
{"project": "qemu", "commit_id": "fd198f9002a9e1f070c82b04d3229c18d9a49471", "target": 0, "func": "MigrationCapabilityStatusList *qmp_query_migrate_capabilities(Error **errp)\n\n{\n\n    MigrationCapabilityStatusList *head = NULL;\n\n    MigrationCapabilityStatusList *caps;\n\n    MigrationState *s = migrate_get_current();\n\n    int i;\n\n\n\n    caps = NULL; /* silence compiler warning */\n\n    for (i = 0; i < MIGRATION_CAPABILITY__MAX; i++) {\n\n#ifndef CONFIG_LIVE_BLOCK_MIGRATION\n\n        if (i == MIGRATION_CAPABILITY_BLOCK) {\n\n            continue;\n\n        }\n\n#endif\n\n        if (i == MIGRATION_CAPABILITY_X_COLO && !colo_supported()) {\n\n            continue;\n\n        }\n\n        if (head == NULL) {\n\n            head = g_malloc0(sizeof(*caps));\n\n            caps = head;\n\n        } else {\n\n            caps->next = g_malloc0(sizeof(*caps));\n\n            caps = caps->next;\n\n        }\n\n        caps->value =\n\n            g_malloc(sizeof(*caps->value));\n\n        caps->value->capability = i;\n\n        caps->value->state = s->enabled_capabilities[i];\n\n    }\n\n\n\n    return head;\n\n}\n", "idx": 26391}
{"project": "qemu", "commit_id": "b062ad86dcd33ab39be5060b0655d8e13834b167", "target": 0, "func": "static int read_f(BlockBackend *blk, int argc, char **argv)\n\n{\n\n    struct timeval t1, t2;\n\n    int Cflag = 0, pflag = 0, qflag = 0, vflag = 0;\n\n    int Pflag = 0, sflag = 0, lflag = 0, bflag = 0;\n\n    int c, cnt;\n\n    char *buf;\n\n    int64_t offset;\n\n    int count;\n\n    /* Some compilers get confused and warn if this is not initialized.  */\n\n    int total = 0;\n\n    int pattern = 0, pattern_offset = 0, pattern_count = 0;\n\n\n\n    while ((c = getopt(argc, argv, \"bCl:pP:qs:v\")) != EOF) {\n\n        switch (c) {\n\n        case 'b':\n\n            bflag = 1;\n\n            break;\n\n        case 'C':\n\n            Cflag = 1;\n\n            break;\n\n        case 'l':\n\n            lflag = 1;\n\n            pattern_count = cvtnum(optarg);\n\n            if (pattern_count < 0) {\n\n                printf(\"non-numeric length argument -- %s\\n\", optarg);\n\n                return 0;\n\n            }\n\n            break;\n\n        case 'p':\n\n            pflag = 1;\n\n            break;\n\n        case 'P':\n\n            Pflag = 1;\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n                return 0;\n\n            }\n\n            break;\n\n        case 'q':\n\n            qflag = 1;\n\n            break;\n\n        case 's':\n\n            sflag = 1;\n\n            pattern_offset = cvtnum(optarg);\n\n            if (pattern_offset < 0) {\n\n                printf(\"non-numeric length argument -- %s\\n\", optarg);\n\n                return 0;\n\n            }\n\n            break;\n\n        case 'v':\n\n            vflag = 1;\n\n            break;\n\n        default:\n\n            return qemuio_command_usage(&read_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind != argc - 2) {\n\n        return qemuio_command_usage(&read_cmd);\n\n    }\n\n\n\n    if (bflag && pflag) {\n\n        printf(\"-b and -p cannot be specified at the same time\\n\");\n\n        return 0;\n\n    }\n\n\n\n    offset = cvtnum(argv[optind]);\n\n    if (offset < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    optind++;\n\n    count = cvtnum(argv[optind]);\n\n    if (count < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    if (!Pflag && (lflag || sflag)) {\n\n        return qemuio_command_usage(&read_cmd);\n\n    }\n\n\n\n    if (!lflag) {\n\n        pattern_count = count - pattern_offset;\n\n    }\n\n\n\n    if ((pattern_count < 0) || (pattern_count + pattern_offset > count))  {\n\n        printf(\"pattern verification range exceeds end of read data\\n\");\n\n        return 0;\n\n    }\n\n\n\n    if (!pflag) {\n\n        if (offset & 0x1ff) {\n\n            printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n                   offset);\n\n            return 0;\n\n        }\n\n        if (count & 0x1ff) {\n\n            printf(\"count %d is not sector aligned\\n\",\n\n                   count);\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    buf = qemu_io_alloc(blk, count, 0xab);\n\n\n\n    gettimeofday(&t1, NULL);\n\n    if (pflag) {\n\n        cnt = do_pread(blk, buf, offset, count, &total);\n\n    } else if (bflag) {\n\n        cnt = do_load_vmstate(blk, buf, offset, count, &total);\n\n    } else {\n\n        cnt = do_read(blk, buf, offset, count, &total);\n\n    }\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (cnt < 0) {\n\n        printf(\"read failed: %s\\n\", strerror(-cnt));\n\n        goto out;\n\n    }\n\n\n\n    if (Pflag) {\n\n        void *cmp_buf = g_malloc(pattern_count);\n\n        memset(cmp_buf, pattern, pattern_count);\n\n        if (memcmp(buf + pattern_offset, cmp_buf, pattern_count)) {\n\n            printf(\"Pattern verification failed at offset %\"\n\n                   PRId64 \", %d bytes\\n\",\n\n                   offset + pattern_offset, pattern_count);\n\n        }\n\n        g_free(cmp_buf);\n\n    }\n\n\n\n    if (qflag) {\n\n        goto out;\n\n    }\n\n\n\n    if (vflag) {\n\n        dump_buffer(buf, offset, count);\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, t1);\n\n    print_report(\"read\", &t2, offset, count, total, cnt, Cflag);\n\n\n\nout:\n\n    qemu_io_free(buf);\n\n\n\n    return 0;\n\n}\n", "idx": 26392}
{"project": "qemu", "commit_id": "94b037f2a451b3dc855f9f2c346e5049a361bd55", "target": 0, "func": "static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,\n\n                               unsigned int epid)\n\n{\n\n    XHCISlot *slot;\n\n    XHCIEPContext *epctx;\n\n    int i;\n\n\n\n    trace_usb_xhci_ep_disable(slotid, epid);\n\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n\n    assert(epid >= 1 && epid <= 31);\n\n\n\n    slot = &xhci->slots[slotid-1];\n\n\n\n    if (!slot->eps[epid-1]) {\n\n        DPRINTF(\"xhci: slot %d ep %d already disabled\\n\", slotid, epid);\n\n        return CC_SUCCESS;\n\n    }\n\n\n\n    xhci_ep_nuke_xfers(xhci, slotid, epid, 0);\n\n\n\n    epctx = slot->eps[epid-1];\n\n\n\n    if (epctx->nr_pstreams) {\n\n        xhci_free_streams(epctx);\n\n    }\n\n\n\n    for (i = 0; i < ARRAY_SIZE(epctx->transfers); i++) {\n\n        usb_packet_cleanup(&epctx->transfers[i].packet);\n\n    }\n\n\n\n    /* only touch guest RAM if we're not resetting the HC */\n\n    if (xhci->dcbaap_low || xhci->dcbaap_high) {\n\n        xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);\n\n    }\n\n\n\n    timer_free(epctx->kick_timer);\n\n    g_free(epctx);\n\n    slot->eps[epid-1] = NULL;\n\n\n\n    return CC_SUCCESS;\n\n}\n", "idx": 26393}
{"project": "qemu", "commit_id": "cdd5cc12ba8cf0c068da319370bdd3ba45eaf7ac", "target": 0, "func": "static int virtio_net_can_receive(VLANClientState *vc)\n\n{\n\n    VirtIONet *n = vc->opaque;\n\n\n\n    return do_virtio_net_can_receive(n, VIRTIO_NET_MAX_BUFSIZE);\n\n}\n", "idx": 26394}
{"project": "qemu", "commit_id": "1048c88f03545fa42bdebb077871a743a614d2ab", "target": 0, "func": "static void monitor_find_completion(const char *cmdline)\n\n{\n\n    const char *cmdname;\n\n    char *args[MAX_ARGS];\n\n    int nb_args, i, len;\n\n    const char *ptype, *str;\n\n    const mon_cmd_t *cmd;\n\n    const KeyDef *key;\n\n\n\n    parse_cmdline(cmdline, &nb_args, args);\n\n#ifdef DEBUG_COMPLETION\n\n    for(i = 0; i < nb_args; i++) {\n\n        monitor_printf(cur_mon, \"arg%d = '%s'\\n\", i, (char *)args[i]);\n\n    }\n\n#endif\n\n\n\n    /* if the line ends with a space, it means we want to complete the\n\n       next arg */\n\n    len = strlen(cmdline);\n\n    if (len > 0 && qemu_isspace(cmdline[len - 1])) {\n\n        if (nb_args >= MAX_ARGS) {\n\n            goto cleanup;\n\n        }\n\n        args[nb_args++] = g_strdup(\"\");\n\n    }\n\n    if (nb_args <= 1) {\n\n        /* command completion */\n\n        if (nb_args == 0)\n\n            cmdname = \"\";\n\n        else\n\n            cmdname = args[0];\n\n        readline_set_completion_index(cur_mon->rs, strlen(cmdname));\n\n        for(cmd = mon_cmds; cmd->name != NULL; cmd++) {\n\n            cmd_completion(cmdname, cmd->name);\n\n        }\n\n    } else {\n\n        /* find the command */\n\n        for (cmd = mon_cmds; cmd->name != NULL; cmd++) {\n\n            if (compare_cmd(args[0], cmd->name)) {\n\n                break;\n\n            }\n\n        }\n\n        if (!cmd->name) {\n\n            goto cleanup;\n\n        }\n\n\n\n        ptype = next_arg_type(cmd->args_type);\n\n        for(i = 0; i < nb_args - 2; i++) {\n\n            if (*ptype != '\\0') {\n\n                ptype = next_arg_type(ptype);\n\n                while (*ptype == '?')\n\n                    ptype = next_arg_type(ptype);\n\n            }\n\n        }\n\n        str = args[nb_args - 1];\n\n        if (*ptype == '-' && ptype[1] != '\\0') {\n\n            ptype = next_arg_type(ptype);\n\n        }\n\n        switch(*ptype) {\n\n        case 'F':\n\n            /* file completion */\n\n            readline_set_completion_index(cur_mon->rs, strlen(str));\n\n            file_completion(str);\n\n            break;\n\n        case 'B':\n\n            /* block device name completion */\n\n            readline_set_completion_index(cur_mon->rs, strlen(str));\n\n            bdrv_iterate(block_completion_it, (void *)str);\n\n            break;\n\n        case 's':\n\n            /* XXX: more generic ? */\n\n            if (!strcmp(cmd->name, \"info\")) {\n\n                readline_set_completion_index(cur_mon->rs, strlen(str));\n\n                for(cmd = info_cmds; cmd->name != NULL; cmd++) {\n\n                    cmd_completion(str, cmd->name);\n\n                }\n\n            } else if (!strcmp(cmd->name, \"sendkey\")) {\n\n                char *sep = strrchr(str, '-');\n\n                if (sep)\n\n                    str = sep + 1;\n\n                readline_set_completion_index(cur_mon->rs, strlen(str));\n\n                for(key = key_defs; key->name != NULL; key++) {\n\n                    cmd_completion(str, key->name);\n\n                }\n\n            } else if (!strcmp(cmd->name, \"help|?\")) {\n\n                readline_set_completion_index(cur_mon->rs, strlen(str));\n\n                for (cmd = mon_cmds; cmd->name != NULL; cmd++) {\n\n                    cmd_completion(str, cmd->name);\n\n                }\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n\n\ncleanup:\n\n    for (i = 0; i < nb_args; i++) {\n\n        g_free(args[i]);\n\n    }\n\n}\n", "idx": 26395}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void intel_hda_mmio_writel(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    IntelHDAState *d = opaque;\n\n    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);\n\n\n\n    intel_hda_reg_write(d, reg, val, 0xffffffff);\n\n}\n", "idx": 26396}
{"project": "qemu", "commit_id": "90449c388711c3defdc76da490926d1eca177b06", "target": 0, "func": "CPUSPARCState *cpu_sparc_init(const char *cpu_model)\n\n{\n\n    SPARCCPU *cpu;\n\n    CPUSPARCState *env;\n\n\n\n    cpu = SPARC_CPU(object_new(TYPE_SPARC_CPU));\n\n    env = &cpu->env;\n\n\n\n    gen_intermediate_code_init(env);\n\n\n\n    if (cpu_sparc_register(env, cpu_model) < 0) {\n\n        object_delete(OBJECT(cpu));\n\n        return NULL;\n\n    }\n\n    qemu_init_vcpu(env);\n\n\n\n    return env;\n\n}\n", "idx": 26397}
{"project": "qemu", "commit_id": "d732dcb442ce810709f48d7a105b573efda118a2", "target": 0, "func": "static abi_long unlock_iovec(struct iovec *vec, abi_ulong target_addr,\n\n                             int count, int copy)\n\n{\n\n    struct target_iovec *target_vec;\n\n    abi_ulong base;\n\n    int i;\n\n\n\n    target_vec = lock_user(VERIFY_READ, target_addr, count * sizeof(struct target_iovec), 1);\n\n    if (!target_vec)\n\n        return -TARGET_EFAULT;\n\n    for(i = 0;i < count; i++) {\n\n        base = tswapl(target_vec[i].iov_base);\n\n        unlock_user(vec[i].iov_base, base, copy ? vec[i].iov_len : 0);\n\n    }\n\n    unlock_user (target_vec, target_addr, 0);\n\n\n\n    return 0;\n\n}\n", "idx": 26398}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static int v9fs_synth_chmod(FsContext *fs_ctx, V9fsPath *path, FsCred *credp)\n\n{\n\n    errno = EPERM;\n\n    return -1;\n\n}\n", "idx": 26399}
{"project": "qemu", "commit_id": "53cb28cbfea038f8ad50132dc8a684e638c7d48b", "target": 0, "func": "static void mem_commit(MemoryListener *listener)\n\n{\n\n    AddressSpace *as = container_of(listener, AddressSpace, dispatch_listener);\n\n    AddressSpaceDispatch *cur = as->dispatch;\n\n    AddressSpaceDispatch *next = as->next_dispatch;\n\n\n\n    next->nodes = next_map.nodes;\n\n    next->sections = next_map.sections;\n\n\n\n    phys_page_compact_all(next, next_map.nodes_nb);\n\n\n\n    as->dispatch = next;\n\n    g_free(cur);\n\n}\n", "idx": 26400}
{"project": "qemu", "commit_id": "e3807054e20fb3b94d18cb751c437ee2f43b6fac", "target": 0, "func": "static void qemu_rdma_init_one_block(void *host_addr,\n\n    ram_addr_t block_offset, ram_addr_t length, void *opaque)\n\n{\n\n    rdma_add_block(opaque, host_addr, block_offset, length);\n\n}\n", "idx": 26402}
{"project": "qemu", "commit_id": "ac531cb6e542b1e61d668604adf9dc5306a948c0", "target": 0, "func": "START_TEST(qdict_iterapi_test)\n\n{\n\n    int count;\n\n    const QDictEntry *ent;\n\n\n\n    fail_unless(qdict_first(tests_dict) == NULL);\n\n\n\n    qdict_put(tests_dict, \"key1\", qint_from_int(1));\n\n    qdict_put(tests_dict, \"key2\", qint_from_int(2));\n\n    qdict_put(tests_dict, \"key3\", qint_from_int(3));\n\n\n\n    count = 0;\n\n    for (ent = qdict_first(tests_dict); ent; ent = qdict_next(tests_dict, ent)){\n\n        fail_unless(qdict_haskey(tests_dict, qdict_entry_key(ent)) == 1);\n\n        count++;\n\n    }\n\n\n\n    fail_unless(count == qdict_size(tests_dict));\n\n\n\n    /* Do it again to test restarting */\n\n    count = 0;\n\n    for (ent = qdict_first(tests_dict); ent; ent = qdict_next(tests_dict, ent)){\n\n        fail_unless(qdict_haskey(tests_dict, qdict_entry_key(ent)) == 1);\n\n        count++;\n\n    }\n\n\n\n    fail_unless(count == qdict_size(tests_dict));\n\n}\n", "idx": 26403}
{"project": "qemu", "commit_id": "85c97ca7a10b93216bc95052e9dabe3a4bb8736a", "target": 0, "func": "static int coroutine_fn bdrv_co_do_zero_pwritev(BlockDriverState *bs,\n\n                                                int64_t offset,\n\n                                                unsigned int bytes,\n\n                                                BdrvRequestFlags flags,\n\n                                                BdrvTrackedRequest *req)\n\n{\n\n    uint8_t *buf = NULL;\n\n    QEMUIOVector local_qiov;\n\n    struct iovec iov;\n\n    uint64_t align = bs->bl.request_alignment;\n\n    unsigned int head_padding_bytes, tail_padding_bytes;\n\n    int ret = 0;\n\n\n\n    head_padding_bytes = offset & (align - 1);\n\n    tail_padding_bytes = align - ((offset + bytes) & (align - 1));\n\n\n\n\n\n    assert(flags & BDRV_REQ_ZERO_WRITE);\n\n    if (head_padding_bytes || tail_padding_bytes) {\n\n        buf = qemu_blockalign(bs, align);\n\n        iov = (struct iovec) {\n\n            .iov_base   = buf,\n\n            .iov_len    = align,\n\n        };\n\n        qemu_iovec_init_external(&local_qiov, &iov, 1);\n\n    }\n\n    if (head_padding_bytes) {\n\n        uint64_t zero_bytes = MIN(bytes, align - head_padding_bytes);\n\n\n\n        /* RMW the unaligned part before head. */\n\n        mark_request_serialising(req, align);\n\n        wait_serialising_requests(req);\n\n        bdrv_debug_event(bs, BLKDBG_PWRITEV_RMW_HEAD);\n\n        ret = bdrv_aligned_preadv(bs, req, offset & ~(align - 1), align,\n\n                                  align, &local_qiov, 0);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        bdrv_debug_event(bs, BLKDBG_PWRITEV_RMW_AFTER_HEAD);\n\n\n\n        memset(buf + head_padding_bytes, 0, zero_bytes);\n\n        ret = bdrv_aligned_pwritev(bs, req, offset & ~(align - 1), align,\n\n                                   align, &local_qiov,\n\n                                   flags & ~BDRV_REQ_ZERO_WRITE);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        offset += zero_bytes;\n\n        bytes -= zero_bytes;\n\n    }\n\n\n\n    assert(!bytes || (offset & (align - 1)) == 0);\n\n    if (bytes >= align) {\n\n        /* Write the aligned part in the middle. */\n\n        uint64_t aligned_bytes = bytes & ~(align - 1);\n\n        ret = bdrv_aligned_pwritev(bs, req, offset, aligned_bytes, align,\n\n                                   NULL, flags);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        bytes -= aligned_bytes;\n\n        offset += aligned_bytes;\n\n    }\n\n\n\n    assert(!bytes || (offset & (align - 1)) == 0);\n\n    if (bytes) {\n\n        assert(align == tail_padding_bytes + bytes);\n\n        /* RMW the unaligned part after tail. */\n\n        mark_request_serialising(req, align);\n\n        wait_serialising_requests(req);\n\n        bdrv_debug_event(bs, BLKDBG_PWRITEV_RMW_TAIL);\n\n        ret = bdrv_aligned_preadv(bs, req, offset, align,\n\n                                  align, &local_qiov, 0);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        bdrv_debug_event(bs, BLKDBG_PWRITEV_RMW_AFTER_TAIL);\n\n\n\n        memset(buf, 0, bytes);\n\n        ret = bdrv_aligned_pwritev(bs, req, offset, align, align,\n\n                                   &local_qiov, flags & ~BDRV_REQ_ZERO_WRITE);\n\n    }\n\nfail:\n\n    qemu_vfree(buf);\n\n    return ret;\n\n\n\n}\n", "idx": 26404}
{"project": "qemu", "commit_id": "6cabe1f303b9d76458c00f00df7f477449a13b2f", "target": 0, "func": "static void qemu_wait_io_event(CPUState *env)\n\n{\n\n    while (!tcg_has_work())\n\n        qemu_cond_timedwait(env->halt_cond, &qemu_global_mutex, 1000);\n\n\n\n    qemu_mutex_unlock(&qemu_global_mutex);\n\n\n\n    /*\n\n     * Users of qemu_global_mutex can be starved, having no chance\n\n     * to acquire it since this path will get to it first.\n\n     * So use another lock to provide fairness.\n\n     */\n\n    qemu_mutex_lock(&qemu_fair_mutex);\n\n    qemu_mutex_unlock(&qemu_fair_mutex);\n\n\n\n    qemu_mutex_lock(&qemu_global_mutex);\n\n    qemu_wait_io_event_common(env);\n\n}\n", "idx": 26405}
{"project": "qemu", "commit_id": "02ffb504485f0920cfc75a0982a602f824a9a4f4", "target": 0, "func": "void qemu_co_queue_init(CoQueue *queue)\n\n{\n\n    QTAILQ_INIT(&queue->entries);\n\n\n\n    /* This will be exposed to callers once there are multiple AioContexts */\n\n    queue->ctx = qemu_get_aio_context();\n\n}\n", "idx": 26406}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "int64_t timerlistgroup_deadline_ns(QEMUTimerListGroup *tlg)\n\n{\n\n    int64_t deadline = -1;\n\n    QEMUClockType type;\n\n    bool play = replay_mode == REPLAY_MODE_PLAY;\n\n    for (type = 0; type < QEMU_CLOCK_MAX; type++) {\n\n        if (qemu_clock_use_for_deadline(type)) {\n\n            if (!play || type == QEMU_CLOCK_REALTIME) {\n\n                deadline = qemu_soonest_timeout(deadline,\n\n                                                timerlist_deadline_ns(tlg->tl[type]));\n\n            } else {\n\n                /* Read clock from the replay file and\n\n                   do not calculate the deadline, based on virtual clock. */\n\n                qemu_clock_get_ns(type);\n\n            }\n\n        }\n\n    }\n\n    return deadline;\n\n}\n", "idx": 26407}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static void socket_connect_data_free(socket_connect_data *c)\n\n{\n\n    qapi_free_SocketAddressLegacy(c->saddr);\n\n    g_free(c->model);\n\n    g_free(c->name);\n\n    g_free(c);\n\n}\n", "idx": 26408}
{"project": "qemu", "commit_id": "98522f63f40adaebc412481e1d2e9170160d4539", "target": 0, "func": "static int blk_connect(struct XenDevice *xendev)\n\n{\n\n    struct XenBlkDev *blkdev = container_of(xendev, struct XenBlkDev, xendev);\n\n    int pers, index, qflags;\n\n    bool readonly = true;\n\n\n\n    /* read-only ? */\n\n    if (blkdev->directiosafe) {\n\n        qflags = BDRV_O_NOCACHE | BDRV_O_NATIVE_AIO;\n\n    } else {\n\n        qflags = BDRV_O_CACHE_WB;\n\n    }\n\n    if (strcmp(blkdev->mode, \"w\") == 0) {\n\n        qflags |= BDRV_O_RDWR;\n\n        readonly = false;\n\n    }\n\n\n\n    /* init qemu block driver */\n\n    index = (blkdev->xendev.dev - 202 * 256) / 16;\n\n    blkdev->dinfo = drive_get(IF_XEN, 0, index);\n\n    if (!blkdev->dinfo) {\n\n        /* setup via xenbus -> create new block driver instance */\n\n        xen_be_printf(&blkdev->xendev, 2, \"create new bdrv (xenbus setup)\\n\");\n\n        blkdev->bs = bdrv_new(blkdev->dev);\n\n        if (blkdev->bs) {\n\n            Error *local_err = NULL;\n\n            BlockDriver *drv = bdrv_find_whitelisted_format(blkdev->fileproto,\n\n                                                           readonly);\n\n            if (bdrv_open(&blkdev->bs, blkdev->filename, NULL, NULL, qflags,\n\n                          drv, &local_err) != 0)\n\n            {\n\n                xen_be_printf(&blkdev->xendev, 0, \"error: %s\\n\",\n\n                              error_get_pretty(local_err));\n\n                error_free(local_err);\n\n                bdrv_unref(blkdev->bs);\n\n                blkdev->bs = NULL;\n\n            }\n\n        }\n\n        if (!blkdev->bs) {\n\n            return -1;\n\n        }\n\n    } else {\n\n        /* setup via qemu cmdline -> already setup for us */\n\n        xen_be_printf(&blkdev->xendev, 2, \"get configured bdrv (cmdline setup)\\n\");\n\n        blkdev->bs = blkdev->dinfo->bdrv;\n\n        if (bdrv_is_read_only(blkdev->bs) && !readonly) {\n\n            xen_be_printf(&blkdev->xendev, 0, \"Unexpected read-only drive\");\n\n            blkdev->bs = NULL;\n\n            return -1;\n\n        }\n\n        /* blkdev->bs is not create by us, we get a reference\n\n         * so we can bdrv_unref() unconditionally */\n\n        bdrv_ref(blkdev->bs);\n\n    }\n\n    bdrv_attach_dev_nofail(blkdev->bs, blkdev);\n\n    blkdev->file_size = bdrv_getlength(blkdev->bs);\n\n    if (blkdev->file_size < 0) {\n\n        xen_be_printf(&blkdev->xendev, 1, \"bdrv_getlength: %d (%s) | drv %s\\n\",\n\n                      (int)blkdev->file_size, strerror(-blkdev->file_size),\n\n                      bdrv_get_format_name(blkdev->bs) ?: \"-\");\n\n        blkdev->file_size = 0;\n\n    }\n\n\n\n    xen_be_printf(xendev, 1, \"type \\\"%s\\\", fileproto \\\"%s\\\", filename \\\"%s\\\",\"\n\n                  \" size %\" PRId64 \" (%\" PRId64 \" MB)\\n\",\n\n                  blkdev->type, blkdev->fileproto, blkdev->filename,\n\n                  blkdev->file_size, blkdev->file_size >> 20);\n\n\n\n    /* Fill in number of sector size and number of sectors */\n\n    xenstore_write_be_int(&blkdev->xendev, \"sector-size\", blkdev->file_blk);\n\n    xenstore_write_be_int64(&blkdev->xendev, \"sectors\",\n\n                            blkdev->file_size / blkdev->file_blk);\n\n\n\n    if (xenstore_read_fe_int(&blkdev->xendev, \"ring-ref\", &blkdev->ring_ref) == -1) {\n\n        return -1;\n\n    }\n\n    if (xenstore_read_fe_int(&blkdev->xendev, \"event-channel\",\n\n                             &blkdev->xendev.remote_port) == -1) {\n\n        return -1;\n\n    }\n\n    if (xenstore_read_fe_int(&blkdev->xendev, \"feature-persistent\", &pers)) {\n\n        blkdev->feature_persistent = FALSE;\n\n    } else {\n\n        blkdev->feature_persistent = !!pers;\n\n    }\n\n\n\n    blkdev->protocol = BLKIF_PROTOCOL_NATIVE;\n\n    if (blkdev->xendev.protocol) {\n\n        if (strcmp(blkdev->xendev.protocol, XEN_IO_PROTO_ABI_X86_32) == 0) {\n\n            blkdev->protocol = BLKIF_PROTOCOL_X86_32;\n\n        }\n\n        if (strcmp(blkdev->xendev.protocol, XEN_IO_PROTO_ABI_X86_64) == 0) {\n\n            blkdev->protocol = BLKIF_PROTOCOL_X86_64;\n\n        }\n\n    }\n\n\n\n    blkdev->sring = xc_gnttab_map_grant_ref(blkdev->xendev.gnttabdev,\n\n                                            blkdev->xendev.dom,\n\n                                            blkdev->ring_ref,\n\n                                            PROT_READ | PROT_WRITE);\n\n    if (!blkdev->sring) {\n\n        return -1;\n\n    }\n\n    blkdev->cnt_map++;\n\n\n\n    switch (blkdev->protocol) {\n\n    case BLKIF_PROTOCOL_NATIVE:\n\n    {\n\n        blkif_sring_t *sring_native = blkdev->sring;\n\n        BACK_RING_INIT(&blkdev->rings.native, sring_native, XC_PAGE_SIZE);\n\n        break;\n\n    }\n\n    case BLKIF_PROTOCOL_X86_32:\n\n    {\n\n        blkif_x86_32_sring_t *sring_x86_32 = blkdev->sring;\n\n\n\n        BACK_RING_INIT(&blkdev->rings.x86_32_part, sring_x86_32, XC_PAGE_SIZE);\n\n        break;\n\n    }\n\n    case BLKIF_PROTOCOL_X86_64:\n\n    {\n\n        blkif_x86_64_sring_t *sring_x86_64 = blkdev->sring;\n\n\n\n        BACK_RING_INIT(&blkdev->rings.x86_64_part, sring_x86_64, XC_PAGE_SIZE);\n\n        break;\n\n    }\n\n    }\n\n\n\n    if (blkdev->feature_persistent) {\n\n        /* Init persistent grants */\n\n        blkdev->max_grants = max_requests * BLKIF_MAX_SEGMENTS_PER_REQUEST;\n\n        blkdev->persistent_gnts = g_tree_new_full((GCompareDataFunc)int_cmp,\n\n                                             NULL, NULL,\n\n                                             (GDestroyNotify)destroy_grant);\n\n        blkdev->persistent_gnt_count = 0;\n\n    }\n\n\n\n    xen_be_bind_evtchn(&blkdev->xendev);\n\n\n\n    xen_be_printf(&blkdev->xendev, 1, \"ok: proto %s, ring-ref %d, \"\n\n                  \"remote port %d, local port %d\\n\",\n\n                  blkdev->xendev.protocol, blkdev->ring_ref,\n\n                  blkdev->xendev.remote_port, blkdev->xendev.local_port);\n\n    return 0;\n\n}\n", "idx": 26409}
{"project": "qemu", "commit_id": "88571882516a7cb4291a329c537eb79fd126e1f2", "target": 0, "func": "static uint64_t qemu_rdma_poll(RDMAContext *rdma, uint64_t *wr_id_out)\n\n{\n\n    int ret;\n\n    struct ibv_wc wc;\n\n    uint64_t wr_id;\n\n\n\n    ret = ibv_poll_cq(rdma->cq, 1, &wc);\n\n\n\n    if (!ret) {\n\n        *wr_id_out = RDMA_WRID_NONE;\n\n        return 0;\n\n    }\n\n\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ibv_poll_cq return %d!\\n\", ret);\n\n        return ret;\n\n    }\n\n\n\n    wr_id = wc.wr_id & RDMA_WRID_TYPE_MASK;\n\n\n\n    if (wc.status != IBV_WC_SUCCESS) {\n\n        fprintf(stderr, \"ibv_poll_cq wc.status=%d %s!\\n\",\n\n                        wc.status, ibv_wc_status_str(wc.status));\n\n        fprintf(stderr, \"ibv_poll_cq wrid=%s!\\n\", wrid_desc[wr_id]);\n\n\n\n        return -1;\n\n    }\n\n\n\n    if (rdma->control_ready_expected &&\n\n        (wr_id >= RDMA_WRID_RECV_CONTROL)) {\n\n        DDDPRINTF(\"completion %s #%\" PRId64 \" received (%\" PRId64 \")\"\n\n                  \" left %d\\n\", wrid_desc[RDMA_WRID_RECV_CONTROL],\n\n                  wr_id - RDMA_WRID_RECV_CONTROL, wr_id, rdma->nb_sent);\n\n        rdma->control_ready_expected = 0;\n\n    }\n\n\n\n    if (wr_id == RDMA_WRID_RDMA_WRITE) {\n\n        uint64_t chunk =\n\n            (wc.wr_id & RDMA_WRID_CHUNK_MASK) >> RDMA_WRID_CHUNK_SHIFT;\n\n        uint64_t index =\n\n            (wc.wr_id & RDMA_WRID_BLOCK_MASK) >> RDMA_WRID_BLOCK_SHIFT;\n\n        RDMALocalBlock *block = &(rdma->local_ram_blocks.block[index]);\n\n\n\n        DDDPRINTF(\"completions %s (%\" PRId64 \") left %d, \"\n\n                 \"block %\" PRIu64 \", chunk: %\" PRIu64 \" %p %p\\n\",\n\n                 print_wrid(wr_id), wr_id, rdma->nb_sent, index, chunk,\n\n                 block->local_host_addr, (void *)block->remote_host_addr);\n\n\n\n        clear_bit(chunk, block->transit_bitmap);\n\n\n\n        if (rdma->nb_sent > 0) {\n\n            rdma->nb_sent--;\n\n        }\n\n\n\n        if (!rdma->pin_all) {\n\n            /*\n\n             * FYI: If one wanted to signal a specific chunk to be unregistered\n\n             * using LRU or workload-specific information, this is the function\n\n             * you would call to do so. That chunk would then get asynchronously\n\n             * unregistered later.\n\n             */\n\n#ifdef RDMA_UNREGISTRATION_EXAMPLE\n\n            qemu_rdma_signal_unregister(rdma, index, chunk, wc.wr_id);\n\n#endif\n\n        }\n\n    } else {\n\n        DDDPRINTF(\"other completion %s (%\" PRId64 \") received left %d\\n\",\n\n            print_wrid(wr_id), wr_id, rdma->nb_sent);\n\n    }\n\n\n\n    *wr_id_out = wc.wr_id;\n\n\n\n    return  0;\n\n}\n", "idx": 26410}
{"project": "qemu", "commit_id": "4678124bb9bfb49e93b83f95c4d2feeb443ea38b", "target": 0, "func": "build_rsdt(GArray *table_data, BIOSLinker *linker, GArray *table_offsets,\n\n           const char *oem_id, const char *oem_table_id)\n\n{\n\n    AcpiRsdtDescriptorRev1 *rsdt;\n\n    size_t rsdt_len;\n\n    int i;\n\n    const int table_data_len = (sizeof(uint32_t) * table_offsets->len);\n\n\n\n    rsdt_len = sizeof(*rsdt) + table_data_len;\n\n    rsdt = acpi_data_push(table_data, rsdt_len);\n\n    memcpy(rsdt->table_offset_entry, table_offsets->data, table_data_len);\n\n    for (i = 0; i < table_offsets->len; ++i) {\n\n        /* rsdt->table_offset_entry to be filled by Guest linker */\n\n        bios_linker_loader_add_pointer(linker,\n\n                                       ACPI_BUILD_TABLE_FILE,\n\n                                       ACPI_BUILD_TABLE_FILE,\n\n                                       &rsdt->table_offset_entry[i],\n\n                                       sizeof(uint32_t));\n\n    }\n\n    build_header(linker, table_data,\n\n                 (void *)rsdt, \"RSDT\", rsdt_len, 1, oem_id, oem_table_id);\n\n}\n", "idx": 26411}
{"project": "qemu", "commit_id": "28ec2598ff7d74bd9556a1786f45fc5df2aacfe1", "target": 1, "func": "static int object_create(QemuOpts *opts, void *opaque)\n\n{\n\n    const char *type = qemu_opt_get(opts, \"qom-type\");\n\n    const char *id = qemu_opts_id(opts);\n\n    Object *obj;\n\n\n\n    g_assert(type != NULL);\n\n\n\n    if (id == NULL) {\n\n        qerror_report(QERR_MISSING_PARAMETER, \"id\");\n\n        return -1;\n\n    }\n\n\n\n    obj = object_new(type);\n\n    if (qemu_opt_foreach(opts, object_set_property, obj, 1) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    object_property_add_child(container_get(object_get_root(), \"/objects\"),\n\n                              id, obj, NULL);\n\n\n\n    return 0;\n\n}\n", "idx": 26413}
{"project": "qemu", "commit_id": "ebca2df783a5a742bb93784524336d8cbb9e662b", "target": 1, "func": "void tpm_backend_cancel_cmd(TPMBackend *s)\n\n{\n\n    TPMBackendClass *k = TPM_BACKEND_GET_CLASS(s);\n\n\n\n    assert(k->cancel_cmd);\n\n\n\n    k->cancel_cmd(s);\n\n}\n", "idx": 26415}
{"project": "qemu", "commit_id": "fa66b909f382619da15f8c7e323145adfa94fdac", "target": 1, "func": "void scsi_bus_legacy_handle_cmdline(SCSIBus *bus)\n\n{\n\n    DriveInfo *dinfo;\n\n    int unit;\n\n\n\n    for (unit = 0; unit < MAX_SCSI_DEVS; unit++) {\n\n        dinfo = drive_get(IF_SCSI, bus->busnr, unit);\n\n        if (dinfo == NULL) {\n\n            continue;\n\n        }\n\n        scsi_bus_legacy_add_drive(bus, dinfo, unit);\n\n    }\n\n}\n", "idx": 26416}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static TCGv_i32 new_tmp(void)\n\n{\n\n    num_temps++;\n\n    return tcg_temp_new_i32();\n\n}\n", "idx": 26418}
{"project": "qemu", "commit_id": "66dc50f7057b9a0191f54e55764412202306858d", "target": 1, "func": "void ioinst_handle_ssch(S390CPU *cpu, uint64_t reg1, uint32_t ipb)\n\n{\n\n    int cssid, ssid, schid, m;\n\n    SubchDev *sch;\n\n    ORB orig_orb, orb;\n\n    uint64_t addr;\n\n    int ret = -ENODEV;\n\n    int cc;\n\n    CPUS390XState *env = &cpu->env;\n\n    uint8_t ar;\n\n\n\n    addr = decode_basedisp_s(env, ipb, &ar);\n\n    if (addr & 3) {\n\n        program_interrupt(env, PGM_SPECIFICATION, 4);\n\n        return;\n\n    }\n\n    if (s390_cpu_virt_mem_read(cpu, addr, ar, &orig_orb, sizeof(orb))) {\n\n        return;\n\n    }\n\n    copy_orb_from_guest(&orb, &orig_orb);\n\n    if (ioinst_disassemble_sch_ident(reg1, &m, &cssid, &ssid, &schid) ||\n\n        !ioinst_orb_valid(&orb)) {\n\n        program_interrupt(env, PGM_OPERAND, 4);\n\n        return;\n\n    }\n\n    trace_ioinst_sch_id(\"ssch\", cssid, ssid, schid);\n\n    sch = css_find_subch(m, cssid, ssid, schid);\n\n    if (sch && css_subch_visible(sch)) {\n\n        ret = css_do_ssch(sch, &orb);\n\n    }\n\n    switch (ret) {\n\n    case -ENODEV:\n\n        cc = 3;\n\n        break;\n\n    case -EBUSY:\n\n        cc = 2;\n\n        break;\n\n    case -EFAULT:\n\n        /*\n\n         * TODO:\n\n         * I'm wondering whether there is something better\n\n         * to do for us here (like setting some device or\n\n         * subchannel status).\n\n         */\n\n        program_interrupt(env, PGM_ADDRESSING, 4);\n\n        return;\n\n    case 0:\n\n        cc = 0;\n\n        break;\n\n    default:\n\n        cc = 1;\n\n        break;\n\n    }\n\n    setcc(cpu, cc);\n\n}\n", "idx": 26420}
{"project": "qemu", "commit_id": "a8e5cc0c076a6e3a62f0e9aad88b007dccf3dd17", "target": 1, "func": "static int virtio_blk_device_init(VirtIODevice *vdev)\n\n{\n\n    DeviceState *qdev = DEVICE(vdev);\n\n    VirtIOBlock *s = VIRTIO_BLK(vdev);\n\n    VirtIOBlkConf *blk = &(s->blk);\n\n    static int virtio_blk_id;\n\n\n\n    if (!blk->conf.bs) {\n\n        error_report(\"drive property not set\");\n\n        return -1;\n\n    }\n\n    if (!bdrv_is_inserted(blk->conf.bs)) {\n\n        error_report(\"Device needs media, but drive is empty\");\n\n        return -1;\n\n    }\n\n\n\n    blkconf_serial(&blk->conf, &blk->serial);\n\n    if (blkconf_geometry(&blk->conf, NULL, 65535, 255, 255) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    virtio_init(vdev, \"virtio-blk\", VIRTIO_ID_BLOCK,\n\n                sizeof(struct virtio_blk_config));\n\n\n\n    vdev->get_config = virtio_blk_update_config;\n\n    vdev->set_config = virtio_blk_set_config;\n\n    vdev->get_features = virtio_blk_get_features;\n\n    vdev->set_status = virtio_blk_set_status;\n\n    vdev->reset = virtio_blk_reset;\n\n    s->bs = blk->conf.bs;\n\n    s->conf = &blk->conf;\n\n    memcpy(&(s->blk), blk, sizeof(struct VirtIOBlkConf));\n\n    s->rq = NULL;\n\n    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;\n\n\n\n    s->vq = virtio_add_queue(vdev, 128, virtio_blk_handle_output);\n\n#ifdef CONFIG_VIRTIO_BLK_DATA_PLANE\n\n    if (!virtio_blk_data_plane_create(vdev, blk, &s->dataplane)) {\n\n        virtio_cleanup(vdev);\n\n        return -1;\n\n    }\n\n#endif\n\n\n\n    s->change = qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);\n\n    register_savevm(qdev, \"virtio-blk\", virtio_blk_id++, 2,\n\n                    virtio_blk_save, virtio_blk_load, s);\n\n    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);\n\n    bdrv_set_buffer_alignment(s->bs, s->conf->logical_block_size);\n\n\n\n    bdrv_iostatus_enable(s->bs);\n\n\n\n    add_boot_device_path(s->conf->bootindex, qdev, \"/disk@0,0\");\n\n    return 0;\n\n}\n", "idx": 26421}
{"project": "qemu", "commit_id": "ed78cda3de92056737364ab3cb748b16f5f17dea", "target": 1, "func": "int bdrv_flush_all(void)\n\n{\n\n    BlockDriverState *bs;\n\n    int result = 0;\n\n\n\n    QTAILQ_FOREACH(bs, &bdrv_states, device_list) {\n\n        int ret = bdrv_flush(bs);\n\n        if (ret < 0 && !result) {\n\n            result = ret;\n\n        }\n\n    }\n\n\n\n    return result;\n\n}\n", "idx": 26425}
{"project": "qemu", "commit_id": "544a3731591f5d53e15f22de00ce5ac758d490b3", "target": 1, "func": "bool visit_start_union(Visitor *v, bool data_present, Error **errp)\n\n{\n\n    if (v->start_union) {\n\n        return v->start_union(v, data_present, errp);\n\n    }\n\n    return true;\n\n}\n", "idx": 26426}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void neon_store_scratch(int scratch, TCGv var)\n\n{\n\n    tcg_gen_st_i32(var, cpu_env, offsetof(CPUARMState, vfp.scratch[scratch]));\n\n    dead_tmp(var);\n\n}\n", "idx": 26432}
{"project": "qemu", "commit_id": "14a10fc39923b3af07c8c46d22cb20843bee3a72", "target": 1, "func": "static void sparc_cpu_realizefn(DeviceState *dev, Error **errp)\n{\n    SPARCCPUClass *scc = SPARC_CPU_GET_CLASS(dev);\n    scc->parent_realize(dev, errp);\n}", "idx": 26434}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void block_migration_cancel(void *opaque)\n\n{\n\n    blk_mig_cleanup();\n\n}\n", "idx": 26436}
{"project": "qemu", "commit_id": "43849424cff82803011fad21074531a1101e514e", "target": 1, "func": "static void tap_cleanup(VLANClientState *nc)\n\n{\n\n    TAPState *s = DO_UPCAST(TAPState, nc, nc);\n\n\n\n    if (s->vhost_net) {\n\n        vhost_net_cleanup(s->vhost_net);\n\n\n    }\n\n\n\n    qemu_purge_queued_packets(nc);\n\n\n\n    if (s->down_script[0])\n\n        launch_script(s->down_script, s->down_script_arg, s->fd);\n\n\n\n    tap_read_poll(s, 0);\n\n    tap_write_poll(s, 0);\n\n    close(s->fd);\n\n}", "idx": 26438}
{"project": "qemu", "commit_id": "167351020420c285b67cdf0603501b3d3b15e3f7", "target": 1, "func": "static int jazz_led_init(SysBusDevice *dev)\n\n{\n\n    LedState *s = FROM_SYSBUS(LedState, dev);\n\n\n\n    memory_region_init_io(&s->iomem, &led_ops, s, \"led\", 1);\n\n    sysbus_init_mmio(dev, &s->iomem);\n\n\n\n    s->ds = graphic_console_init(jazz_led_update_display,\n\n                                 jazz_led_invalidate_display,\n\n                                 jazz_led_screen_dump,\n\n                                 jazz_led_text_update, s);\n\n\n\n    return 0;\n\n}\n", "idx": 26443}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int blk_mig_save_bulked_block(QEMUFile *f)\n\n{\n\n    int64_t completed_sector_sum = 0;\n\n    BlkMigDevState *bmds;\n\n    int progress;\n\n    int ret = 0;\n\n\n\n    QSIMPLEQ_FOREACH(bmds, &block_mig_state.bmds_list, entry) {\n\n        if (bmds->bulk_completed == 0) {\n\n            if (mig_save_device_bulk(f, bmds) == 1) {\n\n                /* completed bulk section for this device */\n\n                bmds->bulk_completed = 1;\n\n            }\n\n            completed_sector_sum += bmds->completed_sectors;\n\n            ret = 1;\n\n            break;\n\n        } else {\n\n            completed_sector_sum += bmds->completed_sectors;\n\n        }\n\n    }\n\n\n\n    if (block_mig_state.total_sector_sum != 0) {\n\n        progress = completed_sector_sum * 100 /\n\n                   block_mig_state.total_sector_sum;\n\n    } else {\n\n        progress = 100;\n\n    }\n\n    if (progress != block_mig_state.prev_progress) {\n\n        block_mig_state.prev_progress = progress;\n\n        qemu_put_be64(f, (progress << BDRV_SECTOR_BITS)\n\n                         | BLK_MIG_FLAG_PROGRESS);\n\n        DPRINTF(\"Completed %d %%\\r\", progress);\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 26444}
{"project": "qemu", "commit_id": "062ba099e01ff1474be98c0a4f3da351efab5d9d", "target": 1, "func": "static bool arm_cpu_has_work(CPUState *cs)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(cs);\n\n\n\n    return !cpu->powered_off\n\n        && cs->interrupt_request &\n\n        (CPU_INTERRUPT_FIQ | CPU_INTERRUPT_HARD\n\n         | CPU_INTERRUPT_VFIQ | CPU_INTERRUPT_VIRQ\n\n         | CPU_INTERRUPT_EXITTB);\n\n}\n", "idx": 26445}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static bool cmd_data_set_management(IDEState *s, uint8_t cmd)\n\n{\n\n    switch (s->feature) {\n\n    case DSM_TRIM:\n\n        if (s->bs) {\n\n            ide_sector_start_dma(s, IDE_DMA_TRIM);\n\n            return false;\n\n        }\n\n        break;\n\n    }\n\n\n\n    ide_abort_command(s);\n\n    return true;\n\n}\n", "idx": 26450}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "dma_read(void *opaque, target_phys_addr_t addr, unsigned int size)\n\n{\n\n        struct fs_dma_ctrl *ctrl = opaque;\n\n\tint c;\n\n\tuint32_t r = 0;\n\n\n\n\tif (size != 4) {\n\n\t\tdma_rinvalid(opaque, addr);\n\n\t}\n\n\n\n\t/* Make addr relative to this channel and bounded to nr regs.  */\n\n\tc = fs_channel(addr);\n\n\taddr &= 0xff;\n\n\taddr >>= 2;\n\n\tswitch (addr)\n\n\t{\n\n\t\tcase RW_STAT:\n\n\t\t\tr = ctrl->channels[c].state & 7;\n\n\t\t\tr |= ctrl->channels[c].eol << 5;\n\n\t\t\tr |= ctrl->channels[c].stream_cmd_src << 8;\n\n\t\t\tbreak;\n\n\n\n\t\tdefault:\n\n\t\t\tr = ctrl->channels[c].regs[addr];\n\n\t\t\tD(printf (\"%s c=%d addr=\" TARGET_FMT_plx \"\\n\",\n\n\t\t\t\t  __func__, c, addr));\n\n\t\t\tbreak;\n\n\t}\n\n\treturn r;\n\n}\n", "idx": 26451}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "exynos4210_combiner_read(void *opaque, target_phys_addr_t offset, unsigned size)\n\n{\n\n    struct Exynos4210CombinerState *s =\n\n            (struct Exynos4210CombinerState *)opaque;\n\n    uint32_t req_quad_base_n;    /* Base of registers quad. Multiply it by 4 and\n\n                                   get a start of corresponding group quad */\n\n    uint32_t grp_quad_base_n;    /* Base of group quad */\n\n    uint32_t reg_n;              /* Register number inside the quad */\n\n    uint32_t val;\n\n\n\n    req_quad_base_n = offset >> 4;\n\n    grp_quad_base_n = req_quad_base_n << 2;\n\n    reg_n = (offset - (req_quad_base_n << 4)) >> 2;\n\n\n\n    if (req_quad_base_n >= IIC_NGRP) {\n\n        /* Read of ICIPSR register */\n\n        return s->icipsr[reg_n];\n\n    }\n\n\n\n    val = 0;\n\n\n\n    switch (reg_n) {\n\n    /* IISTR */\n\n    case 2:\n\n        val |= s->group[grp_quad_base_n].src_pending;\n\n        val |= s->group[grp_quad_base_n + 1].src_pending << 8;\n\n        val |= s->group[grp_quad_base_n + 2].src_pending << 16;\n\n        val |= s->group[grp_quad_base_n + 3].src_pending << 24;\n\n        break;\n\n    /* IIMSR */\n\n    case 3:\n\n        val |= s->group[grp_quad_base_n].src_mask &\n\n        s->group[grp_quad_base_n].src_pending;\n\n        val |= (s->group[grp_quad_base_n + 1].src_mask &\n\n                s->group[grp_quad_base_n + 1].src_pending) << 8;\n\n        val |= (s->group[grp_quad_base_n + 2].src_mask &\n\n                s->group[grp_quad_base_n + 2].src_pending) << 16;\n\n        val |= (s->group[grp_quad_base_n + 3].src_mask &\n\n                s->group[grp_quad_base_n + 3].src_pending) << 24;\n\n        break;\n\n    default:\n\n        if (offset >> 2 >= IIC_REGSET_SIZE) {\n\n            hw_error(\"exynos4210.combiner: overflow of reg_set by 0x\"\n\n                    TARGET_FMT_plx \"offset\\n\", offset);\n\n        }\n\n        val = s->reg_set[offset >> 2];\n\n        return 0;\n\n    }\n\n    return val;\n\n}\n", "idx": 26452}
{"project": "qemu", "commit_id": "6f789be56d3f38e9214dafcfab3bf9be7191f370", "target": 0, "func": "TranslationBlock *tb_gen_code(CPUState *cpu,\n\n                              target_ulong pc, target_ulong cs_base,\n\n                              uint32_t flags, int cflags)\n\n{\n\n    CPUArchState *env = cpu->env_ptr;\n\n    TranslationBlock *tb;\n\n    tb_page_addr_t phys_pc, phys_page2;\n\n    target_ulong virt_page2;\n\n    tcg_insn_unit *gen_code_buf;\n\n    int gen_code_size, search_size;\n\n#ifdef CONFIG_PROFILER\n\n    int64_t ti;\n\n#endif\n\n\n\n    phys_pc = get_page_addr_code(env, pc);\n\n    if (use_icount && !(cflags & CF_IGNORE_ICOUNT)) {\n\n        cflags |= CF_USE_ICOUNT;\n\n    }\n\n\n\n    tb = tb_alloc(pc);\n\n    if (unlikely(!tb)) {\n\n buffer_overflow:\n\n        /* flush must be done */\n\n        tb_flush(cpu);\n\n        /* cannot fail at this point */\n\n        tb = tb_alloc(pc);\n\n        assert(tb != NULL);\n\n        /* Don't forget to invalidate previous TB info.  */\n\n        tcg_ctx.tb_ctx.tb_invalidated_flag = 1;\n\n    }\n\n\n\n    gen_code_buf = tcg_ctx.code_gen_ptr;\n\n    tb->tc_ptr = gen_code_buf;\n\n    tb->cs_base = cs_base;\n\n    tb->flags = flags;\n\n    tb->cflags = cflags;\n\n\n\n#ifdef CONFIG_PROFILER\n\n    tcg_ctx.tb_count1++; /* includes aborted translations because of\n\n                       exceptions */\n\n    ti = profile_getclock();\n\n#endif\n\n\n\n    tcg_func_start(&tcg_ctx);\n\n\n\n    gen_intermediate_code(env, tb);\n\n\n\n    trace_translate_block(tb, tb->pc, tb->tc_ptr);\n\n\n\n    /* generate machine code */\n\n    tb->jmp_reset_offset[0] = TB_JMP_RESET_OFFSET_INVALID;\n\n    tb->jmp_reset_offset[1] = TB_JMP_RESET_OFFSET_INVALID;\n\n    tcg_ctx.tb_jmp_reset_offset = tb->jmp_reset_offset;\n\n#ifdef USE_DIRECT_JUMP\n\n    tcg_ctx.tb_jmp_insn_offset = tb->jmp_insn_offset;\n\n    tcg_ctx.tb_jmp_target_addr = NULL;\n\n#else\n\n    tcg_ctx.tb_jmp_insn_offset = NULL;\n\n    tcg_ctx.tb_jmp_target_addr = tb->jmp_target_addr;\n\n#endif\n\n\n\n#ifdef CONFIG_PROFILER\n\n    tcg_ctx.tb_count++;\n\n    tcg_ctx.interm_time += profile_getclock() - ti;\n\n    tcg_ctx.code_time -= profile_getclock();\n\n#endif\n\n\n\n    /* ??? Overflow could be handled better here.  In particular, we\n\n       don't need to re-do gen_intermediate_code, nor should we re-do\n\n       the tcg optimization currently hidden inside tcg_gen_code.  All\n\n       that should be required is to flush the TBs, allocate a new TB,\n\n       re-initialize it per above, and re-do the actual code generation.  */\n\n    gen_code_size = tcg_gen_code(&tcg_ctx, tb);\n\n    if (unlikely(gen_code_size < 0)) {\n\n        goto buffer_overflow;\n\n    }\n\n    search_size = encode_search(tb, (void *)gen_code_buf + gen_code_size);\n\n    if (unlikely(search_size < 0)) {\n\n        goto buffer_overflow;\n\n    }\n\n\n\n#ifdef CONFIG_PROFILER\n\n    tcg_ctx.code_time += profile_getclock();\n\n    tcg_ctx.code_in_len += tb->size;\n\n    tcg_ctx.code_out_len += gen_code_size;\n\n    tcg_ctx.search_out_len += search_size;\n\n#endif\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_OUT_ASM) &&\n\n        qemu_log_in_addr_range(tb->pc)) {\n\n        qemu_log(\"OUT: [size=%d]\\n\", gen_code_size);\n\n        log_disas(tb->tc_ptr, gen_code_size);\n\n        qemu_log(\"\\n\");\n\n        qemu_log_flush();\n\n    }\n\n#endif\n\n\n\n    tcg_ctx.code_gen_ptr = (void *)\n\n        ROUND_UP((uintptr_t)gen_code_buf + gen_code_size + search_size,\n\n                 CODE_GEN_ALIGN);\n\n\n\n    /* init jump list */\n\n    assert(((uintptr_t)tb & 3) == 0);\n\n    tb->jmp_list_first = (uintptr_t)tb | 2;\n\n    tb->jmp_list_next[0] = (uintptr_t)NULL;\n\n    tb->jmp_list_next[1] = (uintptr_t)NULL;\n\n\n\n    /* init original jump addresses wich has been set during tcg_gen_code() */\n\n    if (tb->jmp_reset_offset[0] != TB_JMP_RESET_OFFSET_INVALID) {\n\n        tb_reset_jump(tb, 0);\n\n    }\n\n    if (tb->jmp_reset_offset[1] != TB_JMP_RESET_OFFSET_INVALID) {\n\n        tb_reset_jump(tb, 1);\n\n    }\n\n\n\n    /* check next page if needed */\n\n    virt_page2 = (pc + tb->size - 1) & TARGET_PAGE_MASK;\n\n    phys_page2 = -1;\n\n    if ((pc & TARGET_PAGE_MASK) != virt_page2) {\n\n        phys_page2 = get_page_addr_code(env, virt_page2);\n\n    }\n\n    /* As long as consistency of the TB stuff is provided by tb_lock in user\n\n     * mode and is implicit in single-threaded softmmu emulation, no explicit\n\n     * memory barrier is required before tb_link_page() makes the TB visible\n\n     * through the physical hash table and physical page list.\n\n     */\n\n    tb_link_page(tb, phys_pc, phys_page2);\n\n    return tb;\n\n}\n", "idx": 26453}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "void scsi_bus_legacy_handle_cmdline(SCSIBus *bus, bool deprecated)\n\n{\n\n    Location loc;\n\n    DriveInfo *dinfo;\n\n    int unit;\n\n\n\n    loc_push_none(&loc);\n\n    for (unit = 0; unit <= bus->info->max_target; unit++) {\n\n        dinfo = drive_get(IF_SCSI, bus->busnr, unit);\n\n        if (dinfo == NULL) {\n\n            continue;\n\n        }\n\n        qemu_opts_loc_restore(dinfo->opts);\n\n        if (deprecated) {\n\n            /* Handling -drive not claimed by machine initialization */\n\n            if (blk_get_attached_dev(blk_by_legacy_dinfo(dinfo))) {\n\n                continue;       /* claimed */\n\n            }\n\n            if (!dinfo->is_default) {\n\n                error_report(\"warning: bus=%d,unit=%d is deprecated with this\"\n\n                             \" machine type\",\n\n                             bus->busnr, unit);\n\n            }\n\n        }\n\n        scsi_bus_legacy_add_drive(bus, blk_by_legacy_dinfo(dinfo),\n\n                                  unit, false, -1, NULL, &error_fatal);\n\n    }\n\n    loc_pop(&loc);\n\n}\n", "idx": 26454}
{"project": "qemu", "commit_id": "42bb9c9178ae7ac4c439172b1ae99cc29188a5c6", "target": 0, "func": "static void axienet_eth_rx_notify(void *opaque)\n\n{\n\n    XilinxAXIEnet *s = XILINX_AXI_ENET(opaque);\n\n\n\n    while (s->rxsize && stream_can_push(s->tx_dev, axienet_eth_rx_notify, s)) {\n\n        size_t ret = stream_push(s->tx_dev, (void *)s->rxmem + s->rxpos,\n\n                                 s->rxsize, s->rxapp);\n\n        s->rxsize -= ret;\n\n        s->rxpos += ret;\n\n        if (!s->rxsize) {\n\n            s->regs[R_IS] |= IS_RX_COMPLETE;\n\n            g_free(s->rxapp);\n\n        }\n\n    }\n\n    enet_update_irq(s);\n\n}\n", "idx": 26455}
{"project": "qemu", "commit_id": "65cdadd2e2de76f7db3bf6b7d8dd8c67abff9659", "target": 0, "func": "START_TEST(qint_from_int64_test)\n\n{\n\n    QInt *qi;\n\n    const int64_t value = 0x1234567890abcdefLL;\n\n\n\n    qi = qint_from_int(value);\n\n    fail_unless((int64_t) qi->value == value);\n\n\n\n    QDECREF(qi);\n\n}\n", "idx": 26456}
{"project": "qemu", "commit_id": "2c62f08ddbf3fa80dc7202eb9a2ea60ae44e2cc5", "target": 0, "func": "static int exynos4210_fimd_init(SysBusDevice *dev)\n\n{\n\n    Exynos4210fimdState *s = FROM_SYSBUS(Exynos4210fimdState, dev);\n\n\n\n    s->ifb = NULL;\n\n\n\n    sysbus_init_irq(dev, &s->irq[0]);\n\n    sysbus_init_irq(dev, &s->irq[1]);\n\n    sysbus_init_irq(dev, &s->irq[2]);\n\n\n\n    memory_region_init_io(&s->iomem, &exynos4210_fimd_mmio_ops, s,\n\n            \"exynos4210.fimd\", FIMD_REGS_SIZE);\n\n    sysbus_init_mmio(dev, &s->iomem);\n\n    s->console = graphic_console_init(exynos4210_fimd_update,\n\n                                  exynos4210_fimd_invalidate, NULL, NULL, s);\n\n\n\n    return 0;\n\n}\n", "idx": 26457}
{"project": "qemu", "commit_id": "b0457b69209fca3fb40a85bd54d7f27eb4bad7e7", "target": 0, "func": "static void pxa2xx_descriptor_load(struct pxa2xx_lcdc_s *s)\n\n{\n\n    struct pxa_frame_descriptor_s desc;\n\n    target_phys_addr_t descptr;\n\n    int i;\n\n\n\n    for (i = 0; i < PXA_LCDDMA_CHANS; i ++) {\n\n        s->dma_ch[i].source = 0;\n\n\n\n        if (!s->dma_ch[i].up)\n\n            continue;\n\n\n\n        if (s->dma_ch[i].branch & FBR_BRA) {\n\n            descptr = s->dma_ch[i].branch & FBR_SRCADDR;\n\n            if (s->dma_ch[i].branch & FBR_BINT)\n\n                pxa2xx_dma_bs_set(s, i);\n\n            s->dma_ch[i].branch &= ~FBR_BRA;\n\n        } else\n\n            descptr = s->dma_ch[i].descriptor;\n\n\n\n        if (!(descptr >= PXA2XX_SDRAM_BASE && descptr +\n\n                    sizeof(desc) <= PXA2XX_SDRAM_BASE + phys_ram_size))\n\n            continue;\n\n\n\n        cpu_physical_memory_read(descptr, (void *)&desc, sizeof(desc));\n\n        s->dma_ch[i].descriptor = tswap32(desc.fdaddr);\n\n        s->dma_ch[i].source = tswap32(desc.fsaddr);\n\n        s->dma_ch[i].id = tswap32(desc.fidr);\n\n        s->dma_ch[i].command = tswap32(desc.ldcmd);\n\n    }\n\n}\n", "idx": 26458}
{"project": "qemu", "commit_id": "7385aed20db5d83979f683b9d0048674411e963c", "target": 0, "func": "void helper_fsqrtq(CPUSPARCState *env)\n\n{\n\n    clear_float_exceptions(env);\n\n    QT0 = float128_sqrt(QT1, &env->fp_status);\n\n    check_ieee_exceptions(env);\n\n}\n", "idx": 26460}
{"project": "qemu", "commit_id": "fd859081453f94c3cbd6527289e41b7fddbf645f", "target": 0, "func": "static void tpm_tis_abort(TPMState *s, uint8_t locty)\n\n{\n\n    TPMTISEmuState *tis = &s->s.tis;\n\n\n\n    tis->loc[locty].r_offset = 0;\n\n    tis->loc[locty].w_offset = 0;\n\n\n\n    DPRINTF(\"tpm_tis: tis_abort: new active locality is %d\\n\", tis->next_locty);\n\n\n\n    /*\n\n     * Need to react differently depending on who's aborting now and\n\n     * which locality will become active afterwards.\n\n     */\n\n    if (tis->aborting_locty == tis->next_locty) {\n\n        tis->loc[tis->aborting_locty].state = TPM_TIS_STATE_READY;\n\n        tis->loc[tis->aborting_locty].sts = TPM_TIS_STS_COMMAND_READY;\n\n        tpm_tis_raise_irq(s, tis->aborting_locty, TPM_TIS_INT_COMMAND_READY);\n\n    }\n\n\n\n    /* locality after abort is another one than the current one */\n\n    tpm_tis_new_active_locality(s, tis->next_locty);\n\n\n\n    tis->next_locty = TPM_TIS_NO_LOCALITY;\n\n    /* nobody's aborting a command anymore */\n\n    tis->aborting_locty = TPM_TIS_NO_LOCALITY;\n\n}\n", "idx": 26461}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static TPMInfo *qmp_query_tpm_inst(TPMBackend *drv)\n\n{\n\n    TPMInfo *res = g_new0(TPMInfo, 1);\n\n    TPMPassthroughOptions *tpo;\n\n\n\n    res->id = g_strdup(drv->id);\n\n    res->model = drv->fe_model;\n\n    res->options = g_new0(TpmTypeOptions, 1);\n\n\n\n    switch (drv->ops->type) {\n\n    case TPM_TYPE_PASSTHROUGH:\n\n        res->options->type = TPM_TYPE_OPTIONS_KIND_PASSTHROUGH;\n\n        tpo = g_new0(TPMPassthroughOptions, 1);\n\n        res->options->u.passthrough = tpo;\n\n        if (drv->path) {\n\n            tpo->path = g_strdup(drv->path);\n\n            tpo->has_path = true;\n\n        }\n\n        if (drv->cancel_path) {\n\n            tpo->cancel_path = g_strdup(drv->cancel_path);\n\n            tpo->has_cancel_path = true;\n\n        }\n\n        break;\n\n    case TPM_TYPE__MAX:\n\n        break;\n\n    }\n\n\n\n    return res;\n\n}\n", "idx": 26462}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static inline void gen_movcf_d (DisasContext *ctx, int fs, int fd, int cc, int tf)\n\n{\n\n    int cond;\n\n    TCGv_i32 t0 = tcg_temp_new_i32();\n\n    TCGv_i64 fp0;\n\n    int l1 = gen_new_label();\n\n\n\n    if (tf)\n\n        cond = TCG_COND_EQ;\n\n    else\n\n        cond = TCG_COND_NE;\n\n\n\n    tcg_gen_andi_i32(t0, fpu_fcr31, 1 << get_fp_bit(cc));\n\n    tcg_gen_brcondi_i32(cond, t0, 0, l1);\n\n    tcg_temp_free_i32(t0);\n\n    fp0 = tcg_temp_new_i64();\n\n    gen_load_fpr64(ctx, fp0, fs);\n\n    gen_store_fpr64(ctx, fp0, fd);\n\n    tcg_temp_free_i64(fp0);\n\n    gen_set_label(l1);\n\n}\n", "idx": 26463}
{"project": "qemu", "commit_id": "b131c74a0e485b084ddaffc8214c8a19af492be7", "target": 0, "func": "int kvm_irqchip_remove_irqfd(KVMState *s, int fd, int virq)\n\n{\n\n    return -ENOSYS;\n\n}\n", "idx": 26464}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static void noop_conv (st_sample_t *dst, const void *src,\n\n                       int samples, volume_t *vol)\n\n{\n\n    (void) src;\n\n    (void) dst;\n\n    (void) samples;\n\n    (void) vol;\n\n}\n", "idx": 26465}
{"project": "qemu", "commit_id": "c10682cb031525a8bdf3999ef6a033777929d304", "target": 0, "func": "static void qemu_file_set_if_error(QEMUFile *f, int ret)\n\n{\n\n    if (ret < 0 && !f->last_error) {\n\n        qemu_file_set_error(f, ret);\n\n    }\n\n}\n", "idx": 26466}
{"project": "qemu", "commit_id": "cdbf6e165988ab9d7c01da03b9e27bb8ac0c76aa", "target": 0, "func": "static gboolean pty_chr_read(GIOChannel *chan, GIOCondition cond, void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    PtyCharDriver *s = chr->opaque;\n\n    gsize size, len;\n\n    uint8_t buf[READ_BUF_LEN];\n\n    GIOStatus status;\n\n\n\n    len = sizeof(buf);\n\n    if (len > s->read_bytes)\n\n        len = s->read_bytes;\n\n    if (len == 0)\n\n        return FALSE;\n\n    status = g_io_channel_read_chars(s->fd, (gchar *)buf, len, &size, NULL);\n\n    if (status != G_IO_STATUS_NORMAL) {\n\n        pty_chr_state(chr, 0);\n\n        return FALSE;\n\n    } else {\n\n        pty_chr_state(chr, 1);\n\n        qemu_chr_be_write(chr, buf, size);\n\n    }\n\n    return TRUE;\n\n}\n", "idx": 26467}
{"project": "qemu", "commit_id": "5f1d1fc5928a6f8f63089b3d0768e0dc42c05fbb", "target": 0, "func": "int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)\n\n{\n\n    DeviceState *qdev, **qdevs;\n\n    BusChild *kid;\n\n    int i, num, ret = 0;\n\n\n\n    /* Count qdevs on the bus list */\n\n    num = 0;\n\n    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {\n\n        num++;\n\n    }\n\n\n\n    /* Copy out into an array of pointers */\n\n    qdevs = g_malloc(sizeof(qdev) * num);\n\n    num = 0;\n\n    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {\n\n        qdevs[num++] = kid->child;\n\n    }\n\n\n\n    /* Sort the array */\n\n    qsort(qdevs, num, sizeof(qdev), compare_reg);\n\n\n\n    /* Hack alert. Give the devices to libfdt in reverse order, we happen\n\n     * to know that will mean they are in forward order in the tree. */\n\n    for (i = num - 1; i >= 0; i--) {\n\n        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);\n\n\n\n        ret = vio_make_devnode(dev, fdt);\n\n\n\n        if (ret < 0) {\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    free(qdevs);\n\n\n\n    return ret;\n\n}\n", "idx": 26468}
{"project": "qemu", "commit_id": "679aa175e84f5f80b32b307fce5a6b92729e0e61", "target": 0, "func": "void gic_update(GICState *s)\n\n{\n\n    int best_irq;\n\n    int best_prio;\n\n    int irq;\n\n    int level;\n\n    int cpu;\n\n    int cm;\n\n\n\n    for (cpu = 0; cpu < NUM_CPU(s); cpu++) {\n\n        cm = 1 << cpu;\n\n        s->current_pending[cpu] = 1023;\n\n        if (!s->enabled || !s->cpu_enabled[cpu]) {\n\n            qemu_irq_lower(s->parent_irq[cpu]);\n\n            return;\n\n        }\n\n        best_prio = 0x100;\n\n        best_irq = 1023;\n\n        for (irq = 0; irq < s->num_irq; irq++) {\n\n            if (GIC_TEST_ENABLED(irq, cm) && gic_test_pending(s, irq, cm) &&\n\n                (irq < GIC_INTERNAL || GIC_TARGET(irq) & cm)) {\n\n                if (GIC_GET_PRIORITY(irq, cpu) < best_prio) {\n\n                    best_prio = GIC_GET_PRIORITY(irq, cpu);\n\n                    best_irq = irq;\n\n                }\n\n            }\n\n        }\n\n        level = 0;\n\n        if (best_prio < s->priority_mask[cpu]) {\n\n            s->current_pending[cpu] = best_irq;\n\n            if (best_prio < s->running_priority[cpu]) {\n\n                DPRINTF(\"Raised pending IRQ %d (cpu %d)\\n\", best_irq, cpu);\n\n                level = 1;\n\n            }\n\n        }\n\n        qemu_set_irq(s->parent_irq[cpu], level);\n\n    }\n\n}\n", "idx": 26469}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void put_int64(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    int64_t *v = pv;\n\n    qemu_put_sbe64s(f, v);\n\n}\n", "idx": 26471}
{"project": "qemu", "commit_id": "4656e1f01289cc3aa20986deb6a407165826abe5", "target": 1, "func": "void ppc_tlb_invalidate_all(CPUPPCState *env)\n\n{\n\n    switch (env->mmu_model) {\n\n    case POWERPC_MMU_SOFT_6xx:\n\n    case POWERPC_MMU_SOFT_74xx:\n\n        ppc6xx_tlb_invalidate_all(env);\n\n        break;\n\n    case POWERPC_MMU_SOFT_4xx:\n\n    case POWERPC_MMU_SOFT_4xx_Z:\n\n        ppc4xx_tlb_invalidate_all(env);\n\n        break;\n\n    case POWERPC_MMU_REAL:\n\n        cpu_abort(env, \"No TLB for PowerPC 4xx in real mode\\n\");\n\n        break;\n\n    case POWERPC_MMU_MPC8xx:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_BOOKE:\n\n        tlb_flush(env, 1);\n\n        break;\n\n    case POWERPC_MMU_BOOKE206:\n\n        booke206_flush_tlb(env, -1, 0);\n\n        break;\n\n    case POWERPC_MMU_32B:\n\n    case POWERPC_MMU_601:\n\n#if defined(TARGET_PPC64)\n\n    case POWERPC_MMU_620:\n\n    case POWERPC_MMU_64B:\n\n    case POWERPC_MMU_2_06:\n\n\n#endif /* defined(TARGET_PPC64) */\n\n        tlb_flush(env, 1);\n\n        break;\n\n    default:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Unknown MMU model\\n\");\n\n        break;\n\n    }\n\n}", "idx": 26472}
{"project": "qemu", "commit_id": "9bb34eac8b89f624776ce6604c22d7c3097a1e24", "target": 0, "func": "static void vga_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    CirrusVGAState *s = opaque;\n\n    int index;\n\n\n\n    /* check port range access depending on color/monochrome mode */\n\n    if ((addr >= 0x3b0 && addr <= 0x3bf && (s->msr & MSR_COLOR_EMULATION))\n\n\t|| (addr >= 0x3d0 && addr <= 0x3df\n\n\t    && !(s->msr & MSR_COLOR_EMULATION)))\n\n\treturn;\n\n\n\n#ifdef DEBUG_VGA\n\n    printf(\"VGA: write addr=0x%04x data=0x%02x\\n\", addr, val);\n\n#endif\n\n\n\n    switch (addr) {\n\n    case 0x3c0:\n\n\tif (s->ar_flip_flop == 0) {\n\n\t    val &= 0x3f;\n\n\t    s->ar_index = val;\n\n\t} else {\n\n\t    index = s->ar_index & 0x1f;\n\n\t    switch (index) {\n\n\t    case 0x00 ... 0x0f:\n\n\t\ts->ar[index] = val & 0x3f;\n\n\t\tbreak;\n\n\t    case 0x10:\n\n\t\ts->ar[index] = val & ~0x10;\n\n\t\tbreak;\n\n\t    case 0x11:\n\n\t\ts->ar[index] = val;\n\n\t\tbreak;\n\n\t    case 0x12:\n\n\t\ts->ar[index] = val & ~0xc0;\n\n\t\tbreak;\n\n\t    case 0x13:\n\n\t\ts->ar[index] = val & ~0xf0;\n\n\t\tbreak;\n\n\t    case 0x14:\n\n\t\ts->ar[index] = val & ~0xf0;\n\n\t\tbreak;\n\n\t    default:\n\n\t\tbreak;\n\n\t    }\n\n\t}\n\n\ts->ar_flip_flop ^= 1;\n\n\tbreak;\n\n    case 0x3c2:\n\n\ts->msr = val & ~0x10;\n\n\tbreak;\n\n    case 0x3c4:\n\n\ts->sr_index = val;\n\n\tbreak;\n\n    case 0x3c5:\n\n\tif (cirrus_hook_write_sr(s, s->sr_index, val))\n\n\t    break;\n\n#ifdef DEBUG_VGA_REG\n\n\tprintf(\"vga: write SR%x = 0x%02x\\n\", s->sr_index, val);\n\n#endif\n\n\ts->sr[s->sr_index] = val & sr_mask[s->sr_index];\n\n\tbreak;\n\n    case 0x3c6:\n\n\tcirrus_write_hidden_dac(s, val);\n\n\tbreak;\n\n    case 0x3c7:\n\n\ts->dac_read_index = val;\n\n\ts->dac_sub_index = 0;\n\n\ts->dac_state = 3;\n\n\tbreak;\n\n    case 0x3c8:\n\n\ts->dac_write_index = val;\n\n\ts->dac_sub_index = 0;\n\n\ts->dac_state = 0;\n\n\tbreak;\n\n    case 0x3c9:\n\n\tif (cirrus_hook_write_palette(s, val))\n\n\t    break;\n\n\ts->dac_cache[s->dac_sub_index] = val;\n\n\tif (++s->dac_sub_index == 3) {\n\n\t    memcpy(&s->palette[s->dac_write_index * 3], s->dac_cache, 3);\n\n\t    s->dac_sub_index = 0;\n\n\t    s->dac_write_index++;\n\n\t}\n\n\tbreak;\n\n    case 0x3ce:\n\n\ts->gr_index = val;\n\n\tbreak;\n\n    case 0x3cf:\n\n\tif (cirrus_hook_write_gr(s, s->gr_index, val))\n\n\t    break;\n\n#ifdef DEBUG_VGA_REG\n\n\tprintf(\"vga: write GR%x = 0x%02x\\n\", s->gr_index, val);\n\n#endif\n\n\ts->gr[s->gr_index] = val & gr_mask[s->gr_index];\n\n\tbreak;\n\n    case 0x3b4:\n\n    case 0x3d4:\n\n\ts->cr_index = val;\n\n\tbreak;\n\n    case 0x3b5:\n\n    case 0x3d5:\n\n\tif (cirrus_hook_write_cr(s, s->cr_index, val))\n\n\t    break;\n\n#ifdef DEBUG_VGA_REG\n\n\tprintf(\"vga: write CR%x = 0x%02x\\n\", s->cr_index, val);\n\n#endif\n\n\t/* handle CR0-7 protection */\n\n\tif ((s->cr[11] & 0x80) && s->cr_index <= 7) {\n\n\t    /* can always write bit 4 of CR7 */\n\n\t    if (s->cr_index == 7)\n\n\t\ts->cr[7] = (s->cr[7] & ~0x10) | (val & 0x10);\n\n\t    return;\n\n\t}\n\n\tswitch (s->cr_index) {\n\n\tcase 0x01:\t\t/* horizontal display end */\n\n\tcase 0x07:\n\n\tcase 0x09:\n\n\tcase 0x0c:\n\n\tcase 0x0d:\n\n\tcase 0x12:\t\t/* veritcal display end */\n\n\t    s->cr[s->cr_index] = val;\n\n\t    break;\n\n\n\n\tdefault:\n\n\t    s->cr[s->cr_index] = val;\n\n\t    break;\n\n\t}\n\n\tbreak;\n\n    case 0x3ba:\n\n    case 0x3da:\n\n\ts->fcr = val & 0x10;\n\n\tbreak;\n\n    }\n\n}\n", "idx": 26479}
{"project": "qemu", "commit_id": "5d7fd045cafeac1831c1999cb9e1251b7906c6b2", "target": 0, "func": "uint32_t HELPER(lcebr)(CPUS390XState *env, uint32_t f1, uint32_t f2)\n\n{\n\n    env->fregs[f1].l.upper = float32_chs(env->fregs[f2].l.upper);\n\n\n\n    return set_cc_nz_f32(env->fregs[f1].l.upper);\n\n}\n", "idx": 26480}
{"project": "qemu", "commit_id": "7c81e4e9db5f63635fbf11d66bf08e73d325ae97", "target": 0, "func": "static void nfs_refresh_filename(BlockDriverState *bs, QDict *options)\n\n{\n\n    NFSClient *client = bs->opaque;\n\n    QDict *opts = qdict_new();\n\n    QObject *server_qdict;\n\n    Visitor *ov;\n\n\n\n    qdict_put(opts, \"driver\", qstring_from_str(\"nfs\"));\n\n\n\n    if (client->uid && !client->gid) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nfs://%s%s?uid=%\" PRId64, client->server->host, client->path,\n\n                 client->uid);\n\n    } else if (!client->uid && client->gid) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nfs://%s%s?gid=%\" PRId64, client->server->host, client->path,\n\n                 client->gid);\n\n    } else if (client->uid && client->gid) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nfs://%s%s?uid=%\" PRId64 \"&gid=%\" PRId64,\n\n                 client->server->host, client->path, client->uid, client->gid);\n\n    } else {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nfs://%s%s\", client->server->host, client->path);\n\n    }\n\n\n\n    ov = qobject_output_visitor_new(&server_qdict);\n\n    visit_type_NFSServer(ov, NULL, &client->server, &error_abort);\n\n    visit_complete(ov, &server_qdict);\n\n    assert(qobject_type(server_qdict) == QTYPE_QDICT);\n\n\n\n    qdict_put_obj(opts, \"server\", server_qdict);\n\n    qdict_put(opts, \"path\", qstring_from_str(client->path));\n\n\n\n    if (client->uid) {\n\n        qdict_put(opts, \"user\", qint_from_int(client->uid));\n\n    }\n\n    if (client->gid) {\n\n        qdict_put(opts, \"group\", qint_from_int(client->gid));\n\n    }\n\n    if (client->tcp_syncnt) {\n\n        qdict_put(opts, \"tcp-syn-cnt\",\n\n                  qint_from_int(client->tcp_syncnt));\n\n    }\n\n    if (client->readahead) {\n\n        qdict_put(opts, \"readahead-size\",\n\n                  qint_from_int(client->readahead));\n\n    }\n\n    if (client->pagecache) {\n\n        qdict_put(opts, \"page-cache-size\",\n\n                  qint_from_int(client->pagecache));\n\n    }\n\n    if (client->debug) {\n\n        qdict_put(opts, \"debug\", qint_from_int(client->debug));\n\n    }\n\n\n\n    visit_free(ov);\n\n    qdict_flatten(opts);\n\n    bs->full_open_options = opts;\n\n}\n", "idx": 26482}
{"project": "qemu", "commit_id": "a980f7f2c2f4d7e9a1eba4f804cd66dbd458b6d4", "target": 0, "func": "static void pci_basic(gconstpointer data)\n\n{\n\n    QVirtioPCIDevice *dev;\n\n    QPCIBus *bus;\n\n    QVirtQueuePCI *tx, *rx;\n\n    QGuestAllocator *alloc;\n\n    void (*func) (QVirtioDevice *dev,\n\n                  QGuestAllocator *alloc,\n\n                  QVirtQueue *rvq,\n\n                  QVirtQueue *tvq,\n\n                  int socket) = data;\n\n    int sv[2], ret;\n\n\n\n    ret = socketpair(PF_UNIX, SOCK_STREAM, 0, sv);\n\n    g_assert_cmpint(ret, !=, -1);\n\n\n\n    bus = pci_test_start(sv[1]);\n\n    dev = virtio_net_pci_init(bus, PCI_SLOT);\n\n\n\n    alloc = pc_alloc_init();\n\n    rx = (QVirtQueuePCI *)qvirtqueue_setup(&dev->vdev, alloc, 0);\n\n    tx = (QVirtQueuePCI *)qvirtqueue_setup(&dev->vdev, alloc, 1);\n\n\n\n    driver_init(&dev->vdev);\n\n    func(&dev->vdev, alloc, &rx->vq, &tx->vq, sv[0]);\n\n\n\n    /* End test */\n\n    close(sv[0]);\n\n    qvirtqueue_cleanup(dev->vdev.bus, &tx->vq, alloc);\n\n    qvirtqueue_cleanup(dev->vdev.bus, &rx->vq, alloc);\n\n    pc_alloc_uninit(alloc);\n\n    qvirtio_pci_device_disable(dev);\n\n    g_free(dev->pdev);\n\n    g_free(dev);\n\n    qpci_free_pc(bus);\n\n    test_end();\n\n}\n", "idx": 26483}
{"project": "qemu", "commit_id": "09e68369a88d7de0f988972bf28eec1b80cc47f9", "target": 0, "func": "static void qmp_input_type_bool(Visitor *v, const char *name, bool *obj,\n\n                                Error **errp)\n\n{\n\n    QmpInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qmp_input_get_object(qiv, name, true, errp);\n\n    QBool *qbool;\n\n\n\n    if (!qobj) {\n\n        return;\n\n    }\n\n    qbool = qobject_to_qbool(qobj);\n\n    if (!qbool) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"boolean\");\n\n        return;\n\n    }\n\n\n\n    *obj = qbool_get_bool(qbool);\n\n}\n", "idx": 26484}
{"project": "qemu", "commit_id": "1dbd2fd9cbf29c74131e439ce80fb2efde56ee32", "target": 0, "func": "static int qemu_rdma_dest_init(RDMAContext *rdma, Error **errp)\n\n{\n\n    int ret = -EINVAL, idx;\n\n    struct rdma_cm_id *listen_id;\n\n    char ip[40] = \"unknown\";\n\n    struct rdma_addrinfo *res;\n\n    char port_str[16];\n\n\n\n    for (idx = 0; idx < RDMA_WRID_MAX; idx++) {\n\n        rdma->wr_data[idx].control_len = 0;\n\n        rdma->wr_data[idx].control_curr = NULL;\n\n    }\n\n\n\n    if (rdma->host == NULL) {\n\n        ERROR(errp, \"RDMA host is not set!\");\n\n        rdma->error_state = -EINVAL;\n\n        return -1;\n\n    }\n\n    /* create CM channel */\n\n    rdma->channel = rdma_create_event_channel();\n\n    if (!rdma->channel) {\n\n        ERROR(errp, \"could not create rdma event channel\");\n\n        rdma->error_state = -EINVAL;\n\n        return -1;\n\n    }\n\n\n\n    /* create CM id */\n\n    ret = rdma_create_id(rdma->channel, &listen_id, NULL, RDMA_PS_TCP);\n\n    if (ret) {\n\n        ERROR(errp, \"could not create cm_id!\");\n\n        goto err_dest_init_create_listen_id;\n\n    }\n\n\n\n    snprintf(port_str, 16, \"%d\", rdma->port);\n\n    port_str[15] = '\\0';\n\n\n\n    if (rdma->host && strcmp(\"\", rdma->host)) {\n\n        struct rdma_addrinfo *e;\n\n\n\n        ret = rdma_getaddrinfo(rdma->host, port_str, NULL, &res);\n\n        if (ret < 0) {\n\n            ERROR(errp, \"could not rdma_getaddrinfo address %s\", rdma->host);\n\n            goto err_dest_init_bind_addr;\n\n        }\n\n\n\n        for (e = res; e != NULL; e = e->ai_next) {\n\n            inet_ntop(e->ai_family,\n\n                &((struct sockaddr_in *) e->ai_dst_addr)->sin_addr, ip, sizeof ip);\n\n            trace_qemu_rdma_dest_init_trying(rdma->host, ip);\n\n            ret = rdma_bind_addr(listen_id, e->ai_dst_addr);\n\n            if (!ret) {\n\n                if (e->ai_family == AF_INET6) {\n\n                    ret = qemu_rdma_broken_ipv6_kernel(errp, listen_id->verbs);\n\n                    if (ret) {\n\n                        continue;\n\n                    }\n\n                }\n\n                    \n\n                goto listen;\n\n            }\n\n        }\n\n\n\n        ERROR(errp, \"Error: could not rdma_bind_addr!\");\n\n        goto err_dest_init_bind_addr;\n\n    } else {\n\n        ERROR(errp, \"migration host and port not specified!\");\n\n        ret = -EINVAL;\n\n        goto err_dest_init_bind_addr;\n\n    }\n\nlisten:\n\n\n\n    rdma->listen_id = listen_id;\n\n    qemu_rdma_dump_gid(\"dest_init\", listen_id);\n\n    return 0;\n\n\n\nerr_dest_init_bind_addr:\n\n    rdma_destroy_id(listen_id);\n\nerr_dest_init_create_listen_id:\n\n    rdma_destroy_event_channel(rdma->channel);\n\n    rdma->channel = NULL;\n\n    rdma->error_state = ret;\n\n    return ret;\n\n\n\n}\n", "idx": 26485}
{"project": "qemu", "commit_id": "3954d33ab7f82f5a5fa0ced231849920265a5fec", "target": 0, "func": "static int spapr_vio_busdev_init(DeviceState *qdev, DeviceInfo *qinfo)\n\n{\n\n    VIOsPAPRDeviceInfo *info = (VIOsPAPRDeviceInfo *)qinfo;\n\n    VIOsPAPRDevice *dev = (VIOsPAPRDevice *)qdev;\n\n    char *id;\n\n    int ret;\n\n\n\n    ret = spapr_vio_check_reg(dev, info);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    /* Don't overwrite ids assigned on the command line */\n\n    if (!dev->qdev.id) {\n\n        id = vio_format_dev_name(dev);\n\n        if (!id) {\n\n            return -1;\n\n        }\n\n        dev->qdev.id = id;\n\n    }\n\n\n\n    dev->qirq = spapr_allocate_irq(dev->vio_irq_num, &dev->vio_irq_num);\n\n    if (!dev->qirq) {\n\n        return -1;\n\n    }\n\n\n\n    rtce_init(dev);\n\n\n\n    return info->init(dev);\n\n}\n", "idx": 26486}
{"project": "qemu", "commit_id": "4f8a066b5fc254eeaabbbde56ba4f5b29cc68fdf", "target": 0, "func": "static DriveInfo *blockdev_init(QDict *bs_opts,\n\n                                BlockInterfaceType type,\n\n                                DriveMediaType media)\n\n{\n\n    const char *buf;\n\n    const char *file = NULL;\n\n    const char *serial;\n\n    int ro = 0;\n\n    int bdrv_flags = 0;\n\n    int on_read_error, on_write_error;\n\n    DriveInfo *dinfo;\n\n    ThrottleConfig cfg;\n\n    int snapshot = 0;\n\n    bool copy_on_read;\n\n    int ret;\n\n    Error *error = NULL;\n\n    QemuOpts *opts;\n\n    const char *id;\n\n    bool has_driver_specific_opts;\n\n    BlockDriver *drv = NULL;\n\n\n\n    /* Check common options by copying from bs_opts to opts, all other options\n\n     * stay in bs_opts for processing by bdrv_open(). */\n\n    id = qdict_get_try_str(bs_opts, \"id\");\n\n    opts = qemu_opts_create(&qemu_common_drive_opts, id, 1, &error);\n\n    if (error_is_set(&error)) {\n\n        qerror_report_err(error);\n\n        error_free(error);\n\n        return NULL;\n\n    }\n\n\n\n    qemu_opts_absorb_qdict(opts, bs_opts, &error);\n\n    if (error_is_set(&error)) {\n\n        qerror_report_err(error);\n\n        error_free(error);\n\n        return NULL;\n\n    }\n\n\n\n    if (id) {\n\n        qdict_del(bs_opts, \"id\");\n\n    }\n\n\n\n    has_driver_specific_opts = !!qdict_size(bs_opts);\n\n\n\n    /* extract parameters */\n\n    snapshot = qemu_opt_get_bool(opts, \"snapshot\", 0);\n\n    ro = qemu_opt_get_bool(opts, \"read-only\", 0);\n\n    copy_on_read = qemu_opt_get_bool(opts, \"copy-on-read\", false);\n\n\n\n    file = qemu_opt_get(opts, \"file\");\n\n    serial = qemu_opt_get(opts, \"serial\");\n\n\n\n    if ((buf = qemu_opt_get(opts, \"discard\")) != NULL) {\n\n        if (bdrv_parse_discard_flags(buf, &bdrv_flags) != 0) {\n\n            error_report(\"invalid discard option\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if (qemu_opt_get_bool(opts, \"cache.writeback\", true)) {\n\n        bdrv_flags |= BDRV_O_CACHE_WB;\n\n    }\n\n    if (qemu_opt_get_bool(opts, \"cache.direct\", false)) {\n\n        bdrv_flags |= BDRV_O_NOCACHE;\n\n    }\n\n    if (qemu_opt_get_bool(opts, \"cache.no-flush\", false)) {\n\n        bdrv_flags |= BDRV_O_NO_FLUSH;\n\n    }\n\n\n\n#ifdef CONFIG_LINUX_AIO\n\n    if ((buf = qemu_opt_get(opts, \"aio\")) != NULL) {\n\n        if (!strcmp(buf, \"native\")) {\n\n            bdrv_flags |= BDRV_O_NATIVE_AIO;\n\n        } else if (!strcmp(buf, \"threads\")) {\n\n            /* this is the default */\n\n        } else {\n\n           error_report(\"invalid aio option\");\n\n           return NULL;\n\n        }\n\n    }\n\n#endif\n\n\n\n    if ((buf = qemu_opt_get(opts, \"format\")) != NULL) {\n\n        if (is_help_option(buf)) {\n\n            error_printf(\"Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            error_printf(\"\\n\");\n\n            return NULL;\n\n        }\n\n\n\n        drv = bdrv_find_format(buf);\n\n        if (!drv) {\n\n            error_report(\"'%s' invalid format\", buf);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* disk I/O throttling */\n\n    memset(&cfg, 0, sizeof(cfg));\n\n    cfg.buckets[THROTTLE_BPS_TOTAL].avg =\n\n        qemu_opt_get_number(opts, \"throttling.bps-total\", 0);\n\n    cfg.buckets[THROTTLE_BPS_READ].avg  =\n\n        qemu_opt_get_number(opts, \"throttling.bps-read\", 0);\n\n    cfg.buckets[THROTTLE_BPS_WRITE].avg =\n\n        qemu_opt_get_number(opts, \"throttling.bps-write\", 0);\n\n    cfg.buckets[THROTTLE_OPS_TOTAL].avg =\n\n        qemu_opt_get_number(opts, \"throttling.iops-total\", 0);\n\n    cfg.buckets[THROTTLE_OPS_READ].avg =\n\n        qemu_opt_get_number(opts, \"throttling.iops-read\", 0);\n\n    cfg.buckets[THROTTLE_OPS_WRITE].avg =\n\n        qemu_opt_get_number(opts, \"throttling.iops-write\", 0);\n\n\n\n    cfg.buckets[THROTTLE_BPS_TOTAL].max =\n\n        qemu_opt_get_number(opts, \"throttling.bps-total-max\", 0);\n\n    cfg.buckets[THROTTLE_BPS_READ].max  =\n\n        qemu_opt_get_number(opts, \"throttling.bps-read-max\", 0);\n\n    cfg.buckets[THROTTLE_BPS_WRITE].max =\n\n        qemu_opt_get_number(opts, \"throttling.bps-write-max\", 0);\n\n    cfg.buckets[THROTTLE_OPS_TOTAL].max =\n\n        qemu_opt_get_number(opts, \"throttling.iops-total-max\", 0);\n\n    cfg.buckets[THROTTLE_OPS_READ].max =\n\n        qemu_opt_get_number(opts, \"throttling.iops-read-max\", 0);\n\n    cfg.buckets[THROTTLE_OPS_WRITE].max =\n\n        qemu_opt_get_number(opts, \"throttling.iops-write-max\", 0);\n\n\n\n    cfg.op_size = qemu_opt_get_number(opts, \"throttling.iops-size\", 0);\n\n\n\n    if (!check_throttle_config(&cfg, &error)) {\n\n        error_report(\"%s\", error_get_pretty(error));\n\n        error_free(error);\n\n        return NULL;\n\n    }\n\n\n\n    on_write_error = BLOCKDEV_ON_ERROR_ENOSPC;\n\n    if ((buf = qemu_opt_get(opts, \"werror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO && type != IF_NONE) {\n\n            error_report(\"werror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_write_error = parse_block_error_action(buf, 0);\n\n        if (on_write_error < 0) {\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    on_read_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    if ((buf = qemu_opt_get(opts, \"rerror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_VIRTIO && type != IF_SCSI && type != IF_NONE) {\n\n            error_report(\"rerror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_read_error = parse_block_error_action(buf, 1);\n\n        if (on_read_error < 0) {\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* init */\n\n    dinfo = g_malloc0(sizeof(*dinfo));\n\n    dinfo->id = g_strdup(qemu_opts_id(opts));\n\n    dinfo->bdrv = bdrv_new(dinfo->id);\n\n    dinfo->bdrv->open_flags = snapshot ? BDRV_O_SNAPSHOT : 0;\n\n    dinfo->bdrv->read_only = ro;\n\n    dinfo->type = type;\n\n    dinfo->refcount = 1;\n\n    if (serial != NULL) {\n\n        dinfo->serial = g_strdup(serial);\n\n    }\n\n    QTAILQ_INSERT_TAIL(&drives, dinfo, next);\n\n\n\n    bdrv_set_on_error(dinfo->bdrv, on_read_error, on_write_error);\n\n\n\n    /* disk I/O throttling */\n\n    if (throttle_enabled(&cfg)) {\n\n        bdrv_io_limits_enable(dinfo->bdrv);\n\n        bdrv_set_io_limits(dinfo->bdrv, &cfg);\n\n    }\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n    case IF_NONE:\n\n        dinfo->media_cd = media == MEDIA_CDROM;\n\n        break;\n\n    case IF_SD:\n\n    case IF_FLOPPY:\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n    case IF_VIRTIO:\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    if (!file || !*file) {\n\n        if (has_driver_specific_opts) {\n\n            file = NULL;\n\n        } else {\n\n            return dinfo;\n\n        }\n\n    }\n\n    if (snapshot) {\n\n        /* always use cache=unsafe with snapshot */\n\n        bdrv_flags &= ~BDRV_O_CACHE_MASK;\n\n        bdrv_flags |= (BDRV_O_SNAPSHOT|BDRV_O_CACHE_WB|BDRV_O_NO_FLUSH);\n\n    }\n\n\n\n    if (copy_on_read) {\n\n        bdrv_flags |= BDRV_O_COPY_ON_READ;\n\n    }\n\n\n\n    if (runstate_check(RUN_STATE_INMIGRATE)) {\n\n        bdrv_flags |= BDRV_O_INCOMING;\n\n    }\n\n\n\n    if (media == MEDIA_CDROM) {\n\n        /* CDROM is fine for any interface, don't check.  */\n\n        ro = 1;\n\n    } else if (ro == 1) {\n\n        if (type != IF_SCSI && type != IF_VIRTIO && type != IF_FLOPPY &&\n\n            type != IF_NONE && type != IF_PFLASH) {\n\n            error_report(\"read-only not supported by this bus type\");\n\n            goto err;\n\n        }\n\n    }\n\n\n\n    bdrv_flags |= ro ? 0 : BDRV_O_RDWR;\n\n\n\n    if (ro && copy_on_read) {\n\n        error_report(\"warning: disabling copy_on_read on read-only drive\");\n\n    }\n\n\n\n    QINCREF(bs_opts);\n\n    ret = bdrv_open(dinfo->bdrv, file, bs_opts, bdrv_flags, drv, &error);\n\n\n\n    if (ret < 0) {\n\n        error_report(\"could not open disk image %s: %s\",\n\n                     file ?: dinfo->id, error_get_pretty(error));\n\n        goto err;\n\n    }\n\n\n\n    if (bdrv_key_required(dinfo->bdrv))\n\n        autostart = 0;\n\n\n\n    QDECREF(bs_opts);\n\n    qemu_opts_del(opts);\n\n\n\n    return dinfo;\n\n\n\nerr:\n\n    qemu_opts_del(opts);\n\n    QDECREF(bs_opts);\n\n    bdrv_unref(dinfo->bdrv);\n\n    g_free(dinfo->id);\n\n    QTAILQ_REMOVE(&drives, dinfo, next);\n\n    g_free(dinfo);\n\n    return NULL;\n\n}\n", "idx": 26487}
{"project": "qemu", "commit_id": "5e1b34a3fa0a0fbf46628aab10cc49f6f855520e", "target": 0, "func": "static void ioq_init(LaioQueue *io_q)\n\n{\n\n    QSIMPLEQ_INIT(&io_q->pending);\n\n    io_q->plugged = 0;\n\n    io_q->n = 0;\n\n    io_q->blocked = false;\n\n}\n", "idx": 26488}
{"project": "qemu", "commit_id": "2d26512b45b5236fa521c4492608fe9fb5bedf46", "target": 0, "func": "int cksum(struct mbuf *m, int len)\n\n{\n\n\tregister uint16_t *w;\n\n\tregister int sum = 0;\n\n\tregister int mlen = 0;\n\n\tint byte_swapped = 0;\n\n\n\n\tunion {\n\n\t\tuint8_t  c[2];\n\n\t\tuint16_t s;\n\n\t} s_util;\n\n\tunion {\n\n\t\tuint16_t s[2];\n\n\t\tuint32_t l;\n\n\t} l_util;\n\n\n\n\tif (m->m_len == 0)\n\n\t   goto cont;\n\n\tw = mtod(m, uint16_t *);\n\n\n\n\tmlen = m->m_len;\n\n\n\n\tif (len < mlen)\n\n\t   mlen = len;\n\n#ifdef DEBUG\n\n\tlen -= mlen;\n\n#endif\n\n\t/*\n\n\t * Force to even boundary.\n\n\t */\n\n\tif ((1 & (long) w) && (mlen > 0)) {\n\n\t\tREDUCE;\n\n\t\tsum <<= 8;\n\n\t\ts_util.c[0] = *(uint8_t *)w;\n\n\t\tw = (uint16_t *)((int8_t *)w + 1);\n\n\t\tmlen--;\n\n\t\tbyte_swapped = 1;\n\n\t}\n\n\t/*\n\n\t * Unroll the loop to make overhead from\n\n\t * branches &c small.\n\n\t */\n\n\twhile ((mlen -= 32) >= 0) {\n\n\t\tsum += w[0]; sum += w[1]; sum += w[2]; sum += w[3];\n\n\t\tsum += w[4]; sum += w[5]; sum += w[6]; sum += w[7];\n\n\t\tsum += w[8]; sum += w[9]; sum += w[10]; sum += w[11];\n\n\t\tsum += w[12]; sum += w[13]; sum += w[14]; sum += w[15];\n\n\t\tw += 16;\n\n\t}\n\n\tmlen += 32;\n\n\twhile ((mlen -= 8) >= 0) {\n\n\t\tsum += w[0]; sum += w[1]; sum += w[2]; sum += w[3];\n\n\t\tw += 4;\n\n\t}\n\n\tmlen += 8;\n\n\tif (mlen == 0 && byte_swapped == 0)\n\n\t   goto cont;\n\n\tREDUCE;\n\n\twhile ((mlen -= 2) >= 0) {\n\n\t\tsum += *w++;\n\n\t}\n\n\n\n\tif (byte_swapped) {\n\n\t\tREDUCE;\n\n\t\tsum <<= 8;\n\n\t\tif (mlen == -1) {\n\n\t\t\ts_util.c[1] = *(uint8_t *)w;\n\n\t\t\tsum += s_util.s;\n\n\t\t\tmlen = 0;\n\n\t\t} else\n\n\n\n\t\t   mlen = -1;\n\n\t} else if (mlen == -1)\n\n\t   s_util.c[0] = *(uint8_t *)w;\n\n\n\ncont:\n\n#ifdef DEBUG\n\n\tif (len) {\n\n\t\tDEBUG_ERROR((dfd, \"cksum: out of data\\n\"));\n\n\t\tDEBUG_ERROR((dfd, \" len = %d\\n\", len));\n\n\t}\n\n#endif\n\n\tif (mlen == -1) {\n\n\t\t/* The last mbuf has odd # of bytes. Follow the\n\n\t\t standard (the odd byte may be shifted left by 8 bits\n\n\t\t\t   or not as determined by endian-ness of the machine) */\n\n\t\ts_util.c[1] = 0;\n\n\t\tsum += s_util.s;\n\n\t}\n\n\tREDUCE;\n\n\treturn (~sum & 0xffff);\n\n}\n", "idx": 26489}
{"project": "qemu", "commit_id": "ebc996f3b13004e7272c462254522ba0102f09fe", "target": 0, "func": "static int sys_utimensat(int dirfd, const char *pathname,\n\n    const struct timespec times[2], int flags)\n\n{\n\n  return (utimensat(dirfd, pathname, times, flags));\n\n}\n", "idx": 26490}
{"project": "qemu", "commit_id": "c6258b04f19bc690b576b089f621cb5333c533d7", "target": 0, "func": "void hmp_delvm(Monitor *mon, const QDict *qdict)\n\n{\n\n    BlockDriverState *bs;\n\n    Error *err;\n\n    const char *name = qdict_get_str(qdict, \"name\");\n\n\n\n    if (!find_vmstate_bs()) {\n\n        monitor_printf(mon, \"No block device supports snapshots\\n\");\n\n        return;\n\n    }\n\n\n\n    if (bdrv_all_delete_snapshot(name, &bs, &err) < 0) {\n\n        monitor_printf(mon,\n\n                       \"Error while deleting snapshot on device '%s': %s\\n\",\n\n                       bdrv_get_device_name(bs), error_get_pretty(err));\n\n        error_free(err);\n\n    }\n\n}\n", "idx": 26491}
{"project": "qemu", "commit_id": "b2c98d9d392c87c9b9e975d30f79924719d9cbbe", "target": 0, "func": "static void tcg_out_movi(TCGContext *s, TCGType type,\n\n                         TCGReg ret, tcg_target_long sval)\n\n{\n\n    static const S390Opcode lli_insns[4] = {\n\n        RI_LLILL, RI_LLILH, RI_LLIHL, RI_LLIHH\n\n    };\n\n\n\n    tcg_target_ulong uval = sval;\n\n    int i;\n\n\n\n    if (type == TCG_TYPE_I32) {\n\n        uval = (uint32_t)sval;\n\n        sval = (int32_t)sval;\n\n    }\n\n\n\n    /* Try all 32-bit insns that can load it in one go.  */\n\n    if (sval >= -0x8000 && sval < 0x8000) {\n\n        tcg_out_insn(s, RI, LGHI, ret, sval);\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        tcg_target_long mask = 0xffffull << i*16;\n\n        if ((uval & mask) == uval) {\n\n            tcg_out_insn_RI(s, lli_insns[i], ret, uval >> i*16);\n\n            return;\n\n        }\n\n    }\n\n\n\n    /* Try all 48-bit insns that can load it in one go.  */\n\n    if (facilities & FACILITY_EXT_IMM) {\n\n        if (sval == (int32_t)sval) {\n\n            tcg_out_insn(s, RIL, LGFI, ret, sval);\n\n            return;\n\n        }\n\n        if (uval <= 0xffffffff) {\n\n            tcg_out_insn(s, RIL, LLILF, ret, uval);\n\n            return;\n\n        }\n\n        if ((uval & 0xffffffff) == 0) {\n\n            tcg_out_insn(s, RIL, LLIHF, ret, uval >> 31 >> 1);\n\n            return;\n\n        }\n\n    }\n\n\n\n    /* Try for PC-relative address load.  */\n\n    if ((sval & 1) == 0) {\n\n        ptrdiff_t off = tcg_pcrel_diff(s, (void *)sval) >> 1;\n\n        if (off == (int32_t)off) {\n\n            tcg_out_insn(s, RIL, LARL, ret, off);\n\n            return;\n\n        }\n\n    }\n\n\n\n    /* If extended immediates are not present, then we may have to issue\n\n       several instructions to load the low 32 bits.  */\n\n    if (!(facilities & FACILITY_EXT_IMM)) {\n\n        /* A 32-bit unsigned value can be loaded in 2 insns.  And given\n\n           that the lli_insns loop above did not succeed, we know that\n\n           both insns are required.  */\n\n        if (uval <= 0xffffffff) {\n\n            tcg_out_insn(s, RI, LLILL, ret, uval);\n\n            tcg_out_insn(s, RI, IILH, ret, uval >> 16);\n\n            return;\n\n        }\n\n\n\n        /* If all high bits are set, the value can be loaded in 2 or 3 insns.\n\n           We first want to make sure that all the high bits get set.  With\n\n           luck the low 16-bits can be considered negative to perform that for\n\n           free, otherwise we load an explicit -1.  */\n\n        if (sval >> 31 >> 1 == -1) {\n\n            if (uval & 0x8000) {\n\n                tcg_out_insn(s, RI, LGHI, ret, uval);\n\n            } else {\n\n                tcg_out_insn(s, RI, LGHI, ret, -1);\n\n                tcg_out_insn(s, RI, IILL, ret, uval);\n\n            }\n\n            tcg_out_insn(s, RI, IILH, ret, uval >> 16);\n\n            return;\n\n        }\n\n    }\n\n\n\n    /* If we get here, both the high and low parts have non-zero bits.  */\n\n\n\n    /* Recurse to load the lower 32-bits.  */\n\n    tcg_out_movi(s, TCG_TYPE_I64, ret, uval & 0xffffffff);\n\n\n\n    /* Insert data into the high 32-bits.  */\n\n    uval = uval >> 31 >> 1;\n\n    if (facilities & FACILITY_EXT_IMM) {\n\n        if (uval < 0x10000) {\n\n            tcg_out_insn(s, RI, IIHL, ret, uval);\n\n        } else if ((uval & 0xffff) == 0) {\n\n            tcg_out_insn(s, RI, IIHH, ret, uval >> 16);\n\n        } else {\n\n            tcg_out_insn(s, RIL, IIHF, ret, uval);\n\n        }\n\n    } else {\n\n        if (uval & 0xffff) {\n\n            tcg_out_insn(s, RI, IIHL, ret, uval);\n\n        }\n\n        if (uval & 0xffff0000) {\n\n            tcg_out_insn(s, RI, IIHH, ret, uval >> 16);\n\n        }\n\n    }\n\n}\n", "idx": 26493}
{"project": "qemu", "commit_id": "cf3dc71eb5141761c3aed0d936e390aeaa73a88b", "target": 0, "func": "milkymist_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    LM32CPU *cpu;\n\n    CPULM32State *env;\n\n    int kernel_size;\n\n    DriveInfo *dinfo;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *phys_sdram = g_new(MemoryRegion, 1);\n\n    qemu_irq irq[32];\n\n    int i;\n\n    char *bios_filename;\n\n    ResetInfo *reset_info;\n\n\n\n    /* memory map */\n\n    hwaddr flash_base   = 0x00000000;\n\n    size_t flash_sector_size        = 128 * 1024;\n\n    size_t flash_size               = 32 * 1024 * 1024;\n\n    hwaddr sdram_base   = 0x40000000;\n\n    size_t sdram_size               = 128 * 1024 * 1024;\n\n\n\n    hwaddr initrd_base  = sdram_base + 0x1002000;\n\n    hwaddr cmdline_base = sdram_base + 0x1000000;\n\n    size_t initrd_max = sdram_size - 0x1002000;\n\n\n\n    reset_info = g_malloc0(sizeof(ResetInfo));\n\n\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"lm32-full\";\n\n    }\n\n    cpu = cpu_lm32_init(cpu_model);\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"qemu: unable to find CPU '%s'\\n\", cpu_model);\n\n        exit(1);\n\n    }\n\n\n\n    env = &cpu->env;\n\n    reset_info->cpu = cpu;\n\n\n\n    cpu_lm32_set_phys_msb_ignore(env, 1);\n\n\n\n    memory_region_allocate_system_memory(phys_sdram, NULL, \"milkymist.sdram\",\n\n                                         sdram_size);\n\n    memory_region_add_subregion(address_space_mem, sdram_base, phys_sdram);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    /* Numonyx JS28F256J3F105 */\n\n    pflash_cfi01_register(flash_base, NULL, \"milkymist.flash\", flash_size,\n\n                          dinfo ? blk_by_legacy_dinfo(dinfo) : NULL,\n\n                          flash_sector_size, flash_size / flash_sector_size,\n\n                          2, 0x00, 0x89, 0x00, 0x1d, 1);\n\n\n\n    /* create irq lines */\n\n    env->pic_state = lm32_pic_init(qemu_allocate_irq(cpu_irq_handler, cpu, 0));\n\n    for (i = 0; i < 32; i++) {\n\n        irq[i] = qdev_get_gpio_in(env->pic_state, i);\n\n    }\n\n\n\n    /* load bios rom */\n\n    if (bios_name == NULL) {\n\n        bios_name = BIOS_FILENAME;\n\n    }\n\n    bios_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n\n\n    if (bios_filename) {\n\n        load_image_targphys(bios_filename, BIOS_OFFSET, BIOS_SIZE);\n\n    }\n\n\n\n    reset_info->bootstrap_pc = BIOS_OFFSET;\n\n\n\n    /* if no kernel is given no valid bios rom is a fatal error */\n\n    if (!kernel_filename && !dinfo && !bios_filename && !qtest_enabled()) {\n\n        fprintf(stderr, \"qemu: could not load Milkymist One bios '%s'\\n\",\n\n                bios_name);\n\n        exit(1);\n\n    }\n\n    g_free(bios_filename);\n\n\n\n    milkymist_uart_create(0x60000000, irq[0]);\n\n    milkymist_sysctl_create(0x60001000, irq[1], irq[2], irq[3],\n\n            80000000, 0x10014d31, 0x0000041f, 0x00000001);\n\n    milkymist_hpdmc_create(0x60002000);\n\n    milkymist_vgafb_create(0x60003000, 0x40000000, 0x0fffffff);\n\n    milkymist_memcard_create(0x60004000);\n\n    milkymist_ac97_create(0x60005000, irq[4], irq[5], irq[6], irq[7]);\n\n    milkymist_pfpu_create(0x60006000, irq[8]);\n\n    milkymist_tmu2_create(0x60007000, irq[9]);\n\n    milkymist_minimac2_create(0x60008000, 0x30000000, irq[10], irq[11]);\n\n    milkymist_softusb_create(0x6000f000, irq[15],\n\n            0x20000000, 0x1000, 0x20020000, 0x2000);\n\n\n\n    /* make sure juart isn't the first chardev */\n\n    env->juart_state = lm32_juart_init();\n\n\n\n    if (kernel_filename) {\n\n        uint64_t entry;\n\n\n\n        /* Boots a kernel elf binary.  */\n\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n\n                               1, EM_LATTICEMICO32, 0, 0);\n\n        reset_info->bootstrap_pc = entry;\n\n\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename, sdram_base,\n\n                                              sdram_size);\n\n            reset_info->bootstrap_pc = sdram_base;\n\n        }\n\n\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    if (kernel_cmdline && strlen(kernel_cmdline)) {\n\n        pstrcpy_targphys(\"cmdline\", cmdline_base, TARGET_PAGE_SIZE,\n\n                kernel_cmdline);\n\n        reset_info->cmdline_base = (uint32_t)cmdline_base;\n\n    }\n\n\n\n    if (initrd_filename) {\n\n        size_t initrd_size;\n\n        initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                initrd_max);\n\n        reset_info->initrd_base = (uint32_t)initrd_base;\n\n        reset_info->initrd_size = (uint32_t)initrd_size;\n\n    }\n\n\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n}\n", "idx": 26494}
{"project": "qemu", "commit_id": "a03ef88f77af045a2eb9629b5ce774a3fb973c5e", "target": 0, "func": "static int vmdk_write_extent(VmdkExtent *extent, int64_t cluster_offset,\n\n                            int64_t offset_in_cluster, QEMUIOVector *qiov,\n\n                            uint64_t qiov_offset, uint64_t n_bytes,\n\n                            uint64_t offset)\n\n{\n\n    int ret;\n\n    VmdkGrainMarker *data = NULL;\n\n    uLongf buf_len;\n\n    QEMUIOVector local_qiov;\n\n    struct iovec iov;\n\n    int64_t write_offset;\n\n    int64_t write_end_sector;\n\n\n\n    if (extent->compressed) {\n\n        void *compressed_data;\n\n\n\n        if (!extent->has_marker) {\n\n            ret = -EINVAL;\n\n            goto out;\n\n        }\n\n        buf_len = (extent->cluster_sectors << 9) * 2;\n\n        data = g_malloc(buf_len + sizeof(VmdkGrainMarker));\n\n\n\n        compressed_data = g_malloc(n_bytes);\n\n        qemu_iovec_to_buf(qiov, qiov_offset, compressed_data, n_bytes);\n\n        ret = compress(data->data, &buf_len, compressed_data, n_bytes);\n\n        g_free(compressed_data);\n\n\n\n        if (ret != Z_OK || buf_len == 0) {\n\n            ret = -EINVAL;\n\n            goto out;\n\n        }\n\n\n\n        data->lba = offset >> BDRV_SECTOR_BITS;\n\n        data->size = buf_len;\n\n\n\n        n_bytes = buf_len + sizeof(VmdkGrainMarker);\n\n        iov = (struct iovec) {\n\n            .iov_base   = data,\n\n            .iov_len    = n_bytes,\n\n        };\n\n        qemu_iovec_init_external(&local_qiov, &iov, 1);\n\n    } else {\n\n        qemu_iovec_init(&local_qiov, qiov->niov);\n\n        qemu_iovec_concat(&local_qiov, qiov, qiov_offset, n_bytes);\n\n    }\n\n\n\n    write_offset = cluster_offset + offset_in_cluster,\n\n    ret = bdrv_co_pwritev(extent->file->bs, write_offset, n_bytes,\n\n                          &local_qiov, 0);\n\n\n\n    write_end_sector = DIV_ROUND_UP(write_offset + n_bytes, BDRV_SECTOR_SIZE);\n\n\n\n    if (extent->compressed) {\n\n        extent->next_cluster_sector = write_end_sector;\n\n    } else {\n\n        extent->next_cluster_sector = MAX(extent->next_cluster_sector,\n\n                                          write_end_sector);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n    ret = 0;\n\n out:\n\n    g_free(data);\n\n    if (!extent->compressed) {\n\n        qemu_iovec_destroy(&local_qiov);\n\n    }\n\n    return ret;\n\n}\n", "idx": 26495}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void address_space_unmap(AddressSpace *as, void *buffer, target_phys_addr_t len,\n\n                         int is_write, target_phys_addr_t access_len)\n\n{\n\n    if (buffer != bounce.buffer) {\n\n        if (is_write) {\n\n            ram_addr_t addr1 = qemu_ram_addr_from_host_nofail(buffer);\n\n            while (access_len) {\n\n                unsigned l;\n\n                l = TARGET_PAGE_SIZE;\n\n                if (l > access_len)\n\n                    l = access_len;\n\n                invalidate_and_set_dirty(addr1, l);\n\n                addr1 += l;\n\n                access_len -= l;\n\n            }\n\n        }\n\n        if (xen_enabled()) {\n\n            xen_invalidate_map_cache_entry(buffer);\n\n        }\n\n        return;\n\n    }\n\n    if (is_write) {\n\n        address_space_write(as, bounce.addr, bounce.buffer, access_len);\n\n    }\n\n    qemu_vfree(bounce.buffer);\n\n    bounce.buffer = NULL;\n\n    cpu_notify_map_clients();\n\n}\n", "idx": 26496}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static int vnc_continue_handshake(struct VncState *vs) {\n\n    int ret;\n\n\n\n    if ((ret = gnutls_handshake(vs->tls_session)) < 0) {\n\n       if (!gnutls_error_is_fatal(ret)) {\n\n           VNC_DEBUG(\"Handshake interrupted (blocking)\\n\");\n\n           if (!gnutls_record_get_direction(vs->tls_session))\n\n               qemu_set_fd_handler(vs->csock, vnc_handshake_io, NULL, vs);\n\n           else\n\n               qemu_set_fd_handler(vs->csock, NULL, vnc_handshake_io, vs);\n\n           return 0;\n\n       }\n\n       VNC_DEBUG(\"Handshake failed %s\\n\", gnutls_strerror(ret));\n\n       vnc_client_error(vs);\n\n       return -1;\n\n    }\n\n\n\n    if (vs->vd->x509verify) {\n\n\tif (vnc_validate_certificate(vs) < 0) {\n\n\t    VNC_DEBUG(\"Client verification failed\\n\");\n\n\t    vnc_client_error(vs);\n\n\t    return -1;\n\n\t} else {\n\n\t    VNC_DEBUG(\"Client verification passed\\n\");\n\n\t}\n\n    }\n\n\n\n    VNC_DEBUG(\"Handshake done, switching to TLS data mode\\n\");\n\n    vs->wiremode = VNC_WIREMODE_TLS;\n\n    qemu_set_fd_handler2(vs->csock, NULL, vnc_client_read, vnc_client_write, vs);\n\n\n\n    return start_auth_vencrypt_subauth(vs);\n\n}\n", "idx": 26497}
{"project": "qemu", "commit_id": "eca1bdf415c454093dfc7eb983cd49287c043967", "target": 1, "func": "void cpu_reset (CPUMIPSState *env)\n{\n    memset(env, 0, offsetof(CPUMIPSState, breakpoints));\n    tlb_flush(env, 1);\n    /* Minimal init */\n#if defined(CONFIG_USER_ONLY)\n    env->hflags = MIPS_HFLAG_UM;\n#else\n    if (env->hflags & MIPS_HFLAG_BMASK) {\n        /* If the exception was raised from a delay slot,\n           come back to the jump.  */\n        env->CP0_ErrorEPC = env->active_tc.PC - 4;\n    } else {\n        env->CP0_ErrorEPC = env->active_tc.PC;\n    env->active_tc.PC = (int32_t)0xBFC00000;\n    env->CP0_Wired = 0;\n    /* SMP not implemented */\n    env->CP0_EBase = 0x80000000;\n    env->CP0_Status = (1 << CP0St_BEV) | (1 << CP0St_ERL);\n    /* vectored interrupts not implemented, timer on int 7,\n       no performance counters. */\n    env->CP0_IntCtl = 0xe0000000;\n    {\n        int i;\n        for (i = 0; i < 7; i++) {\n            env->CP0_WatchLo[i] = 0;\n            env->CP0_WatchHi[i] = 0x80000000;\n        env->CP0_WatchLo[7] = 0;\n        env->CP0_WatchHi[7] = 0;\n    /* Count register increments in debug mode, EJTAG version 1 */\n    env->CP0_Debug = (1 << CP0DB_CNT) | (0x1 << CP0DB_VER);\n    env->hflags = MIPS_HFLAG_CP0;\n#endif\n    env->exception_index = EXCP_NONE;\n    cpu_mips_register(env, env->cpu_model);", "idx": 26498}
{"project": "qemu", "commit_id": "9877860e7bd1e26ee70ab9bb5ebc34c92bf23bf5", "target": 1, "func": "static int vmdk_open(BlockDriverState *bs, QDict *options, int flags,\n\n                     Error **errp)\n\n{\n\n    char *buf;\n\n    int ret;\n\n    BDRVVmdkState *s = bs->opaque;\n\n    uint32_t magic;\n\n    Error *local_err = NULL;\n\n\n\n    bs->file = bdrv_open_child(NULL, options, \"file\", bs, &child_file,\n\n                               false, errp);\n\n    if (!bs->file) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    buf = vmdk_read_desc(bs->file, 0, errp);\n\n    if (!buf) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    magic = ldl_be_p(buf);\n\n    switch (magic) {\n\n        case VMDK3_MAGIC:\n\n        case VMDK4_MAGIC:\n\n            ret = vmdk_open_sparse(bs, bs->file, flags, buf, options,\n\n                                   errp);\n\n            s->desc_offset = 0x200;\n\n            break;\n\n        default:\n\n            ret = vmdk_open_desc_file(bs, flags, buf, options, errp);\n\n            break;\n\n    }\n\n    if (ret) {\n\n        goto fail;\n\n    }\n\n\n\n    /* try to open parent images, if exist */\n\n    ret = vmdk_parent_open(bs);\n\n    if (ret) {\n\n        goto fail;\n\n    }\n\n    s->cid = vmdk_read_cid(bs, 0);\n\n    s->parent_cid = vmdk_read_cid(bs, 1);\n\n    qemu_co_mutex_init(&s->lock);\n\n\n\n    /* Disable migration when VMDK images are used */\n\n    error_setg(&s->migration_blocker, \"The vmdk format used by node '%s' \"\n\n               \"does not support live migration\",\n\n               bdrv_get_device_or_node_name(bs));\n\n    ret = migrate_add_blocker(s->migration_blocker, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        error_free(s->migration_blocker);\n\n        goto fail;\n\n    }\n\n\n\n    g_free(buf);\n\n    return 0;\n\n\n\nfail:\n\n    g_free(buf);\n\n    g_free(s->create_type);\n\n    s->create_type = NULL;\n\n    vmdk_free_extents(bs);\n\n    return ret;\n\n}\n", "idx": 26499}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline void gen_neon_widen(TCGv_i64 dest, TCGv src, int size, int u)\n\n{\n\n    if (u) {\n\n        switch (size) {\n\n        case 0: gen_helper_neon_widen_u8(dest, src); break;\n\n        case 1: gen_helper_neon_widen_u16(dest, src); break;\n\n        case 2: tcg_gen_extu_i32_i64(dest, src); break;\n\n        default: abort();\n\n        }\n\n    } else {\n\n        switch (size) {\n\n        case 0: gen_helper_neon_widen_s8(dest, src); break;\n\n        case 1: gen_helper_neon_widen_s16(dest, src); break;\n\n        case 2: tcg_gen_ext_i32_i64(dest, src); break;\n\n        default: abort();\n\n        }\n\n    }\n\n    dead_tmp(src);\n\n}\n", "idx": 26500}
{"project": "qemu", "commit_id": "593831de5dce5f5b9ce1226e0d8353eecb1176e4", "target": 1, "func": "int qdev_unplug(DeviceState *dev)\n{\n    if (!dev->parent_bus->allow_hotplug) {\n        qemu_error(\"Bus %s does not support hotplugging\\n\",\n                   dev->parent_bus->name);\n        return -1;\n    }\n    return dev->info->unplug(dev);\n}", "idx": 26503}
{"project": "qemu", "commit_id": "3a03bfa5a219fe06779706315f2555622b51193c", "target": 1, "func": "int qemu_pipe(int pipefd[2])\n\n{\n\n    int ret;\n\n\n\n#ifdef CONFIG_PIPE2\n\n    ret = pipe2(pipefd, O_CLOEXEC);\n\n#else\n\n    ret = pipe(pipefd);\n\n    if (ret == 0) {\n\n        qemu_set_cloexec(pipefd[0]);\n\n        qemu_set_cloexec(pipefd[1]);\n\n    }\n\n#endif\n\n\n\n    return ret;\n\n}\n", "idx": 26508}
{"project": "qemu", "commit_id": "81b23ef82cd1be29ca3d69ab7e98b5b5e55926ce", "target": 1, "func": "static int xen_pt_cmd_reg_read(XenPCIPassthroughState *s, XenPTReg *cfg_entry,\n\n                               uint16_t *value, uint16_t valid_mask)\n\n{\n\n    XenPTRegInfo *reg = cfg_entry->reg;\n\n    uint16_t valid_emu_mask = 0;\n\n    uint16_t emu_mask = reg->emu_mask;\n\n\n\n    if (s->is_virtfn) {\n\n        emu_mask |= PCI_COMMAND_MEMORY;\n\n    }\n\n\n\n    /* emulate word register */\n\n    valid_emu_mask = emu_mask & valid_mask;\n\n    *value = XEN_PT_MERGE_VALUE(*value, cfg_entry->data, ~valid_emu_mask);\n\n\n\n    return 0;\n\n}\n", "idx": 26509}
{"project": "qemu", "commit_id": "bbc5842211cdd90103cfe52f2ca24afac880694f", "target": 1, "func": "static inline void write_IRQreg (openpic_t *opp, int n_IRQ,\n\n                                 uint32_t reg, uint32_t val)\n\n{\n\n    uint32_t tmp;\n\n\n\n    switch (reg) {\n\n    case IRQ_IPVP:\n\n        /* NOTE: not fully accurate for special IRQs, but simple and\n\n           sufficient */\n\n        /* ACTIVITY bit is read-only */\n\n        opp->src[n_IRQ].ipvp =\n\n            (opp->src[n_IRQ].ipvp & 0x40000000) |\n\n            (val & 0x800F00FF);\n\n        openpic_update_irq(opp, n_IRQ);\n\n        DPRINTF(\"Set IPVP %d to 0x%08x -> 0x%08x\\n\",\n\n                n_IRQ, val, opp->src[n_IRQ].ipvp);\n\n        break;\n\n    case IRQ_IDE:\n\n        tmp = val & 0xC0000000;\n\n        tmp |= val & ((1 << MAX_CPU) - 1);\n\n        opp->src[n_IRQ].ide = tmp;\n\n        DPRINTF(\"Set IDE %d to 0x%08x\\n\", n_IRQ, opp->src[n_IRQ].ide);\n\n        break;\n\n    }\n\n}\n", "idx": 26511}
{"project": "qemu", "commit_id": "f45cb2f43f5bb0a4122a64e61c746048b59a84ed", "target": 1, "func": "static void sync_c0_tcstatus(CPUMIPSState *cpu, int tc,\n\n                             target_ulong v)\n\n{\n\n    uint32_t status;\n\n    uint32_t tcu, tmx, tasid, tksu;\n\n    uint32_t mask = ((1 << CP0St_CU3)\n\n                       | (1 << CP0St_CU2)\n\n                       | (1 << CP0St_CU1)\n\n                       | (1 << CP0St_CU0)\n\n                       | (1 << CP0St_MX)\n\n                       | (3 << CP0St_KSU));\n\n\n\n    tcu = (v >> CP0TCSt_TCU0) & 0xf;\n\n    tmx = (v >> CP0TCSt_TMX) & 0x1;\n\n    tasid = v & 0xff;\n\n    tksu = (v >> CP0TCSt_TKSU) & 0x3;\n\n\n\n    status = tcu << CP0St_CU0;\n\n    status |= tmx << CP0St_MX;\n\n    status |= tksu << CP0St_KSU;\n\n\n\n    cpu->CP0_Status &= ~mask;\n\n    cpu->CP0_Status |= status;\n\n\n\n    /* Sync the TASID with EntryHi.  */\n\n    cpu->CP0_EntryHi &= ~0xff;\n\n    cpu->CP0_EntryHi = tasid;\n\n\n\n    compute_hflags(cpu);\n\n}\n", "idx": 26514}
{"project": "qemu", "commit_id": "06b1297017415ae6a07a0e97ad7d8e90b2d95823", "target": 1, "func": "static int virtio_net_has_buffers(VirtIONet *n, int bufsize)\n\n{\n\n    if (virtio_queue_empty(n->rx_vq) ||\n\n        (n->mergeable_rx_bufs &&\n\n         !virtqueue_avail_bytes(n->rx_vq, bufsize, 0))) {\n\n        virtio_queue_set_notification(n->rx_vq, 1);\n\n        return 0;\n\n    }\n\n\n\n    virtio_queue_set_notification(n->rx_vq, 0);\n\n    return 1;\n\n}\n", "idx": 26516}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_add16(TCGv t0, TCGv t1)\n\n{\n\n    TCGv tmp = new_tmp();\n\n    tcg_gen_xor_i32(tmp, t0, t1);\n\n    tcg_gen_andi_i32(tmp, tmp, 0x8000);\n\n    tcg_gen_andi_i32(t0, t0, ~0x8000);\n\n    tcg_gen_andi_i32(t1, t1, ~0x8000);\n\n    tcg_gen_add_i32(t0, t0, t1);\n\n    tcg_gen_xor_i32(t0, t0, tmp);\n\n    dead_tmp(tmp);\n\n    dead_tmp(t1);\n\n}\n", "idx": 26517}
{"project": "qemu", "commit_id": "d3392718e1fcf0859fb7c0774a8e946bacb8419c", "target": 1, "func": "static void do_v7m_exception_exit(ARMCPU *cpu)\n\n{\n\n    CPUARMState *env = &cpu->env;\n\n    CPUState *cs = CPU(cpu);\n\n    uint32_t excret;\n\n    uint32_t xpsr;\n\n    bool ufault = false;\n\n    bool sfault = false;\n\n    bool return_to_sp_process;\n\n    bool return_to_handler;\n\n    bool rettobase = false;\n\n    bool exc_secure = false;\n\n    bool return_to_secure;\n\n\n\n    /* We can only get here from an EXCP_EXCEPTION_EXIT, and\n\n     * gen_bx_excret() enforces the architectural rule\n\n     * that jumps to magic addresses don't have magic behaviour unless\n\n     * we're in Handler mode (compare pseudocode BXWritePC()).\n\n     */\n\n    assert(arm_v7m_is_handler_mode(env));\n\n\n\n    /* In the spec pseudocode ExceptionReturn() is called directly\n\n     * from BXWritePC() and gets the full target PC value including\n\n     * bit zero. In QEMU's implementation we treat it as a normal\n\n     * jump-to-register (which is then caught later on), and so split\n\n     * the target value up between env->regs[15] and env->thumb in\n\n     * gen_bx(). Reconstitute it.\n\n     */\n\n    excret = env->regs[15];\n\n    if (env->thumb) {\n\n        excret |= 1;\n\n    }\n\n\n\n    qemu_log_mask(CPU_LOG_INT, \"Exception return: magic PC %\" PRIx32\n\n                  \" previous exception %d\\n\",\n\n                  excret, env->v7m.exception);\n\n\n\n    if ((excret & R_V7M_EXCRET_RES1_MASK) != R_V7M_EXCRET_RES1_MASK) {\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"M profile: zero high bits in exception \"\n\n                      \"exit PC value 0x%\" PRIx32 \" are UNPREDICTABLE\\n\",\n\n                      excret);\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_M_SECURITY)) {\n\n        /* EXC_RETURN.ES validation check (R_SMFL). We must do this before\n\n         * we pick which FAULTMASK to clear.\n\n         */\n\n        if (!env->v7m.secure &&\n\n            ((excret & R_V7M_EXCRET_ES_MASK) ||\n\n             !(excret & R_V7M_EXCRET_DCRS_MASK))) {\n\n            sfault = 1;\n\n            /* For all other purposes, treat ES as 0 (R_HXSR) */\n\n            excret &= ~R_V7M_EXCRET_ES_MASK;\n\n        }\n\n    }\n\n\n\n    if (env->v7m.exception != ARMV7M_EXCP_NMI) {\n\n        /* Auto-clear FAULTMASK on return from other than NMI.\n\n         * If the security extension is implemented then this only\n\n         * happens if the raw execution priority is >= 0; the\n\n         * value of the ES bit in the exception return value indicates\n\n         * which security state's faultmask to clear. (v8M ARM ARM R_KBNF.)\n\n         */\n\n        if (arm_feature(env, ARM_FEATURE_M_SECURITY)) {\n\n            exc_secure = excret & R_V7M_EXCRET_ES_MASK;\n\n            if (armv7m_nvic_raw_execution_priority(env->nvic) >= 0) {\n\n                env->v7m.faultmask[exc_secure] = 0;\n\n            }\n\n        } else {\n\n            env->v7m.faultmask[M_REG_NS] = 0;\n\n        }\n\n    }\n\n\n\n    switch (armv7m_nvic_complete_irq(env->nvic, env->v7m.exception,\n\n                                     exc_secure)) {\n\n    case -1:\n\n        /* attempt to exit an exception that isn't active */\n\n        ufault = true;\n\n        break;\n\n    case 0:\n\n        /* still an irq active now */\n\n        break;\n\n    case 1:\n\n        /* we returned to base exception level, no nesting.\n\n         * (In the pseudocode this is written using \"NestedActivation != 1\"\n\n         * where we have 'rettobase == false'.)\n\n         */\n\n        rettobase = true;\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n\n\n    return_to_handler = !(excret & R_V7M_EXCRET_MODE_MASK);\n\n    return_to_sp_process = excret & R_V7M_EXCRET_SPSEL_MASK;\n\n    return_to_secure = arm_feature(env, ARM_FEATURE_M_SECURITY) &&\n\n        (excret & R_V7M_EXCRET_S_MASK);\n\n\n\n    if (arm_feature(env, ARM_FEATURE_V8)) {\n\n        if (!arm_feature(env, ARM_FEATURE_M_SECURITY)) {\n\n            /* UNPREDICTABLE if S == 1 or DCRS == 0 or ES == 1 (R_XLCP);\n\n             * we choose to take the UsageFault.\n\n             */\n\n            if ((excret & R_V7M_EXCRET_S_MASK) ||\n\n                (excret & R_V7M_EXCRET_ES_MASK) ||\n\n                !(excret & R_V7M_EXCRET_DCRS_MASK)) {\n\n                ufault = true;\n\n            }\n\n        }\n\n        if (excret & R_V7M_EXCRET_RES0_MASK) {\n\n            ufault = true;\n\n        }\n\n    } else {\n\n        /* For v7M we only recognize certain combinations of the low bits */\n\n        switch (excret & 0xf) {\n\n        case 1: /* Return to Handler */\n\n            break;\n\n        case 13: /* Return to Thread using Process stack */\n\n        case 9: /* Return to Thread using Main stack */\n\n            /* We only need to check NONBASETHRDENA for v7M, because in\n\n             * v8M this bit does not exist (it is RES1).\n\n             */\n\n            if (!rettobase &&\n\n                !(env->v7m.ccr[env->v7m.secure] &\n\n                  R_V7M_CCR_NONBASETHRDENA_MASK)) {\n\n                ufault = true;\n\n            }\n\n            break;\n\n        default:\n\n            ufault = true;\n\n        }\n\n    }\n\n\n\n    if (sfault) {\n\n        env->v7m.sfsr |= R_V7M_SFSR_INVER_MASK;\n\n        armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_SECURE, false);\n\n        v7m_exception_taken(cpu, excret);\n\n        qemu_log_mask(CPU_LOG_INT, \"...taking SecureFault on existing \"\n\n                      \"stackframe: failed EXC_RETURN.ES validity check\\n\");\n\n        return;\n\n    }\n\n\n\n    if (ufault) {\n\n        /* Bad exception return: instead of popping the exception\n\n         * stack, directly take a usage fault on the current stack.\n\n         */\n\n        env->v7m.cfsr[env->v7m.secure] |= R_V7M_CFSR_INVPC_MASK;\n\n        armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_USAGE, env->v7m.secure);\n\n        v7m_exception_taken(cpu, excret);\n\n        qemu_log_mask(CPU_LOG_INT, \"...taking UsageFault on existing \"\n\n                      \"stackframe: failed exception return integrity check\\n\");\n\n        return;\n\n    }\n\n\n\n    /* Set CONTROL.SPSEL from excret.SPSEL. Since we're still in\n\n     * Handler mode (and will be until we write the new XPSR.Interrupt\n\n     * field) this does not switch around the current stack pointer.\n\n     */\n\n    write_v7m_control_spsel_for_secstate(env, return_to_sp_process, exc_secure);\n\n\n\n    switch_v7m_security_state(env, return_to_secure);\n\n\n\n    {\n\n        /* The stack pointer we should be reading the exception frame from\n\n         * depends on bits in the magic exception return type value (and\n\n         * for v8M isn't necessarily the stack pointer we will eventually\n\n         * end up resuming execution with). Get a pointer to the location\n\n         * in the CPU state struct where the SP we need is currently being\n\n         * stored; we will use and modify it in place.\n\n         * We use this limited C variable scope so we don't accidentally\n\n         * use 'frame_sp_p' after we do something that makes it invalid.\n\n         */\n\n        uint32_t *frame_sp_p = get_v7m_sp_ptr(env,\n\n                                              return_to_secure,\n\n                                              !return_to_handler,\n\n                                              return_to_sp_process);\n\n        uint32_t frameptr = *frame_sp_p;\n\n\n\n        if (!QEMU_IS_ALIGNED(frameptr, 8) &&\n\n            arm_feature(env, ARM_FEATURE_V8)) {\n\n            qemu_log_mask(LOG_GUEST_ERROR,\n\n                          \"M profile exception return with non-8-aligned SP \"\n\n                          \"for destination state is UNPREDICTABLE\\n\");\n\n        }\n\n\n\n        /* Do we need to pop callee-saved registers? */\n\n        if (return_to_secure &&\n\n            ((excret & R_V7M_EXCRET_ES_MASK) == 0 ||\n\n             (excret & R_V7M_EXCRET_DCRS_MASK) == 0)) {\n\n            uint32_t expected_sig = 0xfefa125b;\n\n            uint32_t actual_sig = ldl_phys(cs->as, frameptr);\n\n\n\n            if (expected_sig != actual_sig) {\n\n                /* Take a SecureFault on the current stack */\n\n                env->v7m.sfsr |= R_V7M_SFSR_INVIS_MASK;\n\n                armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_SECURE, false);\n\n                v7m_exception_taken(cpu, excret);\n\n                qemu_log_mask(CPU_LOG_INT, \"...taking SecureFault on existing \"\n\n                              \"stackframe: failed exception return integrity \"\n\n                              \"signature check\\n\");\n\n                return;\n\n            }\n\n\n\n            env->regs[4] = ldl_phys(cs->as, frameptr + 0x8);\n\n            env->regs[5] = ldl_phys(cs->as, frameptr + 0xc);\n\n            env->regs[6] = ldl_phys(cs->as, frameptr + 0x10);\n\n            env->regs[7] = ldl_phys(cs->as, frameptr + 0x14);\n\n            env->regs[8] = ldl_phys(cs->as, frameptr + 0x18);\n\n            env->regs[9] = ldl_phys(cs->as, frameptr + 0x1c);\n\n            env->regs[10] = ldl_phys(cs->as, frameptr + 0x20);\n\n            env->regs[11] = ldl_phys(cs->as, frameptr + 0x24);\n\n\n\n            frameptr += 0x28;\n\n        }\n\n\n\n        /* Pop registers. TODO: make these accesses use the correct\n\n         * attributes and address space (S/NS, priv/unpriv) and handle\n\n         * memory transaction failures.\n\n         */\n\n        env->regs[0] = ldl_phys(cs->as, frameptr);\n\n        env->regs[1] = ldl_phys(cs->as, frameptr + 0x4);\n\n        env->regs[2] = ldl_phys(cs->as, frameptr + 0x8);\n\n        env->regs[3] = ldl_phys(cs->as, frameptr + 0xc);\n\n        env->regs[12] = ldl_phys(cs->as, frameptr + 0x10);\n\n        env->regs[14] = ldl_phys(cs->as, frameptr + 0x14);\n\n        env->regs[15] = ldl_phys(cs->as, frameptr + 0x18);\n\n\n\n        /* Returning from an exception with a PC with bit 0 set is defined\n\n         * behaviour on v8M (bit 0 is ignored), but for v7M it was specified\n\n         * to be UNPREDICTABLE. In practice actual v7M hardware seems to ignore\n\n         * the lsbit, and there are several RTOSes out there which incorrectly\n\n         * assume the r15 in the stack frame should be a Thumb-style \"lsbit\n\n         * indicates ARM/Thumb\" value, so ignore the bit on v7M as well, but\n\n         * complain about the badly behaved guest.\n\n         */\n\n        if (env->regs[15] & 1) {\n\n            env->regs[15] &= ~1U;\n\n            if (!arm_feature(env, ARM_FEATURE_V8)) {\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"M profile return from interrupt with misaligned \"\n\n                              \"PC is UNPREDICTABLE on v7M\\n\");\n\n            }\n\n        }\n\n\n\n        xpsr = ldl_phys(cs->as, frameptr + 0x1c);\n\n\n\n        if (arm_feature(env, ARM_FEATURE_V8)) {\n\n            /* For v8M we have to check whether the xPSR exception field\n\n             * matches the EXCRET value for return to handler/thread\n\n             * before we commit to changing the SP and xPSR.\n\n             */\n\n            bool will_be_handler = (xpsr & XPSR_EXCP) != 0;\n\n            if (return_to_handler != will_be_handler) {\n\n                /* Take an INVPC UsageFault on the current stack.\n\n                 * By this point we will have switched to the security state\n\n                 * for the background state, so this UsageFault will target\n\n                 * that state.\n\n                 */\n\n                armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_USAGE,\n\n                                        env->v7m.secure);\n\n                env->v7m.cfsr[env->v7m.secure] |= R_V7M_CFSR_INVPC_MASK;\n\n                v7m_exception_taken(cpu, excret);\n\n                qemu_log_mask(CPU_LOG_INT, \"...taking UsageFault on existing \"\n\n                              \"stackframe: failed exception return integrity \"\n\n                              \"check\\n\");\n\n                return;\n\n            }\n\n        }\n\n\n\n        /* Commit to consuming the stack frame */\n\n        frameptr += 0x20;\n\n        /* Undo stack alignment (the SPREALIGN bit indicates that the original\n\n         * pre-exception SP was not 8-aligned and we added a padding word to\n\n         * align it, so we undo this by ORing in the bit that increases it\n\n         * from the current 8-aligned value to the 8-unaligned value. (Adding 4\n\n         * would work too but a logical OR is how the pseudocode specifies it.)\n\n         */\n\n        if (xpsr & XPSR_SPREALIGN) {\n\n            frameptr |= 4;\n\n        }\n\n        *frame_sp_p = frameptr;\n\n    }\n\n    /* This xpsr_write() will invalidate frame_sp_p as it may switch stack */\n\n    xpsr_write(env, xpsr, ~XPSR_SPREALIGN);\n\n\n\n    /* The restored xPSR exception field will be zero if we're\n\n     * resuming in Thread mode. If that doesn't match what the\n\n     * exception return excret specified then this is a UsageFault.\n\n     * v7M requires we make this check here; v8M did it earlier.\n\n     */\n\n    if (return_to_handler != arm_v7m_is_handler_mode(env)) {\n\n        /* Take an INVPC UsageFault by pushing the stack again;\n\n         * we know we're v7M so this is never a Secure UsageFault.\n\n         */\n\n        assert(!arm_feature(env, ARM_FEATURE_V8));\n\n        armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_USAGE, false);\n\n        env->v7m.cfsr[env->v7m.secure] |= R_V7M_CFSR_INVPC_MASK;\n\n        v7m_push_stack(cpu);\n\n        v7m_exception_taken(cpu, excret);\n\n        qemu_log_mask(CPU_LOG_INT, \"...taking UsageFault on new stackframe: \"\n\n                      \"failed exception return integrity check\\n\");\n\n        return;\n\n    }\n\n\n\n    /* Otherwise, we have a successful exception exit. */\n\n    arm_clear_exclusive(env);\n\n    qemu_log_mask(CPU_LOG_INT, \"...successful exception return\\n\");\n\n}\n", "idx": 26518}
{"project": "qemu", "commit_id": "9561fda8d90e176bef598ba87c42a1bd6ad03ef7", "target": 1, "func": "static void qbus_initfn(Object *obj)\n\n{\n\n    BusState *bus = BUS(obj);\n\n\n\n    QTAILQ_INIT(&bus->children);\n\n    object_property_add_link(obj, QDEV_HOTPLUG_HANDLER_PROPERTY,\n\n                             TYPE_HOTPLUG_HANDLER,\n\n                             (Object **)&bus->hotplug_handler, NULL);\n\n    object_property_add_bool(obj, \"realized\",\n\n                             bus_get_realized, bus_set_realized, NULL);\n\n}\n", "idx": 26522}
{"project": "qemu", "commit_id": "3af9187fc6caaf415ab9c0c6d92c9678f65cb17f", "target": 1, "func": "static ssize_t mipsnet_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n\n{\n\n    MIPSnetState *s = qemu_get_nic_opaque(nc);\n\n\n\n    trace_mipsnet_receive(size);\n\n    if (!mipsnet_can_receive(nc))\n\n\n\n\n\n\n\n    s->busy = 1;\n\n\n\n    /* Just accept everything. */\n\n\n\n    /* Write packet data. */\n\n    memcpy(s->rx_buffer, buf, size);\n\n\n\n    s->rx_count = size;\n\n    s->rx_read = 0;\n\n\n\n    /* Now we can signal we have received something. */\n\n    s->intctl |= MIPSNET_INTCTL_RXDONE;\n\n    mipsnet_update_irq(s);\n\n\n\n    return size;\n", "idx": 26527}
{"project": "qemu", "commit_id": "6f321e93abb27b4e7ceb228b4204aa304e95daad", "target": 1, "func": "static void qed_aio_write_alloc(QEDAIOCB *acb, size_t len)\n\n{\n\n    BDRVQEDState *s = acb_to_s(acb);\n\n\n\n    /* Freeze this request if another allocating write is in progress */\n\n    if (acb != QSIMPLEQ_FIRST(&s->allocating_write_reqs)) {\n\n        QSIMPLEQ_INSERT_TAIL(&s->allocating_write_reqs, acb, next);\n\n    }\n\n    if (acb != QSIMPLEQ_FIRST(&s->allocating_write_reqs)) {\n\n        return; /* wait for existing request to finish */\n\n    }\n\n\n\n    acb->cur_nclusters = qed_bytes_to_clusters(s,\n\n            qed_offset_into_cluster(s, acb->cur_pos) + len);\n\n    acb->cur_cluster = qed_alloc_clusters(s, acb->cur_nclusters);\n\n    qemu_iovec_copy(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);\n\n\n\n    if (qed_should_set_need_check(s)) {\n\n        s->header.features |= QED_F_NEED_CHECK;\n\n        qed_write_header(s, qed_aio_write_prefill, acb);\n\n    } else {\n\n        qed_aio_write_prefill(acb, 0);\n\n    }\n\n}\n", "idx": 26528}
{"project": "qemu", "commit_id": "157e94e8a2f7d3e14060d833bd1519a83099eaa9", "target": 1, "func": "static int parse_numa(void *opaque, QemuOpts *opts, Error **errp)\n\n{\n\n    NumaOptions *object = NULL;\n\n    Error *err = NULL;\n\n\n\n    {\n\n        Visitor *v = opts_visitor_new(opts);\n\n        visit_type_NumaOptions(v, NULL, &object, &err);\n\n        visit_free(v);\n\n    }\n\n\n\n    if (err) {\n\n        goto error;\n\n    }\n\n\n\n    switch (object->type) {\n\n    case NUMA_OPTIONS_KIND_NODE:\n\n        numa_node_parse(object->u.node.data, opts, &err);\n\n        if (err) {\n\n            goto error;\n\n        }\n\n        nb_numa_nodes++;\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n\n\n    return 0;\n\n\n\nerror:\n\n    error_report_err(err);\n\n    qapi_free_NumaOptions(object);\n\n\n\n    return -1;\n\n}\n", "idx": 26529}
{"project": "qemu", "commit_id": "b14ef7c9ab41ea824c3ccadb070ad95567cca84e", "target": 1, "func": "static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n#ifdef DEBUG_UNASSIGNED\n\n    printf(\"Unassigned mem read \" TARGET_FMT_plx \"\\n\", addr);\n\n#endif\n\n#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)\n\n    do_unassigned_access(addr, 0, 0, 0, 4);\n\n#endif\n\n    return 0;\n\n}\n", "idx": 26530}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static TCGv_i64 gen_addq_msw(TCGv_i64 a, TCGv b)\n\n{\n\n    TCGv_i64 tmp64 = tcg_temp_new_i64();\n\n\n\n    tcg_gen_extu_i32_i64(tmp64, b);\n\n    dead_tmp(b);\n\n    tcg_gen_shli_i64(tmp64, tmp64, 32);\n\n    tcg_gen_add_i64(a, tmp64, a);\n\n\n\n    tcg_temp_free_i64(tmp64);\n\n    return a;\n\n}\n", "idx": 26531}
{"project": "qemu", "commit_id": "6f442fe83821a06c5408056c7879e83a74f2ff32", "target": 1, "func": "static uint8_t send_read_command(void)\n\n{\n\n    uint8_t drive = 0;\n\n    uint8_t head = 0;\n\n    uint8_t cyl = 0;\n\n    uint8_t sect_addr = 1;\n\n    uint8_t sect_size = 2;\n\n    uint8_t eot = 1;\n\n    uint8_t gap = 0x1b;\n\n    uint8_t gpl = 0xff;\n\n\n\n    uint8_t msr = 0;\n\n    uint8_t st0;\n\n\n\n    uint8_t ret = 0;\n\n\n\n    floppy_send(CMD_READ);\n\n    floppy_send(head << 2 | drive);\n\n    g_assert(!get_irq(FLOPPY_IRQ));\n\n    floppy_send(cyl);\n\n    floppy_send(head);\n\n    floppy_send(sect_addr);\n\n    floppy_send(sect_size);\n\n    floppy_send(eot);\n\n    floppy_send(gap);\n\n    floppy_send(gpl);\n\n\n\n    uint8_t i = 0;\n\n    uint8_t n = 2;\n\n    for (; i < n; i++) {\n\n        msr = inb(FLOPPY_BASE + reg_msr);\n\n        if (msr == 0xd0) {\n\n            break;\n\n        }\n\n        sleep(1);\n\n    }\n\n\n\n    if (i >= n) {\n\n        return 1;\n\n    }\n\n\n\n    st0 = floppy_recv();\n\n    if (st0 != 0x40) {\n\n        ret = 1;\n\n    }\n\n\n\n    floppy_recv();\n\n    floppy_recv();\n\n    floppy_recv();\n\n    floppy_recv();\n\n    floppy_recv();\n\n    floppy_recv();\n\n\n\n    return ret;\n\n}\n", "idx": 26532}
{"project": "qemu", "commit_id": "b074e6220542107afb9fad480a184775be591d2a", "target": 1, "func": "static void trigger_ascii_console_data(void *opaque, int n, int level)\n\n{\n\n    sclp_service_interrupt(0);\n\n}\n", "idx": 26533}
{"project": "qemu", "commit_id": "0ca4f94195cce77b624edc6d9abcf14a3bf01f06", "target": 1, "func": "static uint64_t bonito_readl(void *opaque, hwaddr addr,\n\n                             unsigned size)\n\n{\n\n    PCIBonitoState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = (addr - BONITO_REGBASE) >> 2;\n\n\n\n    DPRINTF(\"bonito_readl \"TARGET_FMT_plx\"\\n\", addr);\n\n    switch (saddr) {\n\n    case BONITO_INTISR:\n\n        return s->regs[saddr];\n\n    default:\n\n        return s->regs[saddr];\n\n    }\n\n}\n", "idx": 26534}
{"project": "qemu", "commit_id": "a980f7f2c2f4d7e9a1eba4f804cd66dbd458b6d4", "target": 0, "func": "static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < vs->num_queues + 2; i++) {\n\n        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);\n\n    }\n\n    pc_alloc_uninit(vs->alloc);\n\n    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));\n\n    g_free(vs->dev);\n\n    qpci_free_pc(vs->bus);\n\n    g_free(vs);\n\n}\n", "idx": 26535}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static int virtio_net_can_receive(void *opaque)\n\n{\n\n    VirtIONet *n = opaque;\n\n\n\n    return do_virtio_net_can_receive(n, VIRTIO_NET_MAX_BUFSIZE);\n\n}\n", "idx": 26536}
{"project": "qemu", "commit_id": "d492a75cfefd9a09125ba2b007c817c1417c3820", "target": 0, "func": "void spapr_clear_pending_events(sPAPRMachineState *spapr)\n\n{\n\n    sPAPREventLogEntry *entry = NULL;\n\n\n\n    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {\n\n        QTAILQ_REMOVE(&spapr->pending_events, entry, next);\n\n        g_free(entry->extended_log);\n\n        g_free(entry);\n\n    }\n\n}\n", "idx": 26538}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static void bt_hci_inquiry_result(struct bt_hci_s *hci,\n\n                struct bt_device_s *slave)\n\n{\n\n    if (!slave->inquiry_scan || !hci->lm.responses_left)\n\n        return;\n\n\n\n    hci->lm.responses_left --;\n\n    hci->lm.responses ++;\n\n\n\n    switch (hci->lm.inquiry_mode) {\n\n    case 0x00:\n\n        bt_hci_inquiry_result_standard(hci, slave);\n\n        return;\n\n    case 0x01:\n\n        bt_hci_inquiry_result_with_rssi(hci, slave);\n\n        return;\n\n    default:\n\n        fprintf(stderr, \"%s: bad inquiry mode %02x\\n\", __FUNCTION__,\n\n                        hci->lm.inquiry_mode);\n\n        exit(-1);\n\n    }\n\n}\n", "idx": 26539}
{"project": "qemu", "commit_id": "abd696e4f74a9d30801c6ae2693efe4e5979c2f2", "target": 0, "func": "static void sclp_set_write_mask(void)\n\n{\n\n    WriteEventMask *sccb = (void*)_sccb;\n\n\n\n    sccb->h.length = sizeof(WriteEventMask);\n\n    sccb->mask_length = sizeof(unsigned int);\n\n    sccb->receive_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n    sccb->cp_receive_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n    sccb->send_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n    sccb->cp_send_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n\n\n    sclp_service_call(SCLP_CMD_WRITE_EVENT_MASK, sccb);\n\n}\n", "idx": 26540}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t hpet_ram_readw(void *opaque, target_phys_addr_t addr)\n\n{\n\n    printf(\"qemu: hpet_read w at %\" PRIx64 \"\\n\", addr);\n\n    return 0;\n\n}\n", "idx": 26541}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "gen_intermediate_code_internal(MicroBlazeCPU *cpu, TranslationBlock *tb,\n\n                               bool search_pc)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUMBState *env = &cpu->env;\n\n    uint32_t pc_start;\n\n    int j, lj;\n\n    struct DisasContext ctx;\n\n    struct DisasContext *dc = &ctx;\n\n    uint32_t next_page_start, org_flags;\n\n    target_ulong npc;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    pc_start = tb->pc;\n\n    dc->cpu = cpu;\n\n    dc->tb = tb;\n\n    org_flags = dc->synced_flags = dc->tb_flags = tb->flags;\n\n\n\n    dc->is_jmp = DISAS_NEXT;\n\n    dc->jmp = 0;\n\n    dc->delayed_branch = !!(dc->tb_flags & D_FLAG);\n\n    if (dc->delayed_branch) {\n\n        dc->jmp = JMP_INDIRECT;\n\n    }\n\n    dc->pc = pc_start;\n\n    dc->singlestep_enabled = cs->singlestep_enabled;\n\n    dc->cpustate_changed = 0;\n\n    dc->abort_at_next_insn = 0;\n\n    dc->nr_nops = 0;\n\n\n\n    if (pc_start & 3) {\n\n        cpu_abort(cs, \"Microblaze: unaligned PC=%x\\n\", pc_start);\n\n    }\n\n\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n#if !SIM_COMPAT\n\n        qemu_log(\"--------------\\n\");\n\n        log_cpu_state(CPU(cpu), 0);\n\n#endif\n\n    }\n\n\n\n    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n\n    lj = -1;\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0)\n\n        max_insns = CF_COUNT_MASK;\n\n\n\n    gen_tb_start(tb);\n\n    do\n\n    {\n\n#if SIM_COMPAT\n\n        if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n            tcg_gen_movi_tl(cpu_SR[SR_PC], dc->pc);\n\n            gen_helper_debug();\n\n        }\n\n#endif\n\n        check_breakpoint(env, dc);\n\n\n\n        if (search_pc) {\n\n            j = tcg_op_buf_count();\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    tcg_ctx.gen_opc_instr_start[lj++] = 0;\n\n            }\n\n            tcg_ctx.gen_opc_pc[lj] = dc->pc;\n\n            tcg_ctx.gen_opc_instr_start[lj] = 1;\n\n                        tcg_ctx.gen_opc_icount[lj] = num_insns;\n\n        }\n\n\n\n        /* Pretty disas.  */\n\n        LOG_DIS(\"%8.8x:\\t\", dc->pc);\n\n\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))\n\n            gen_io_start();\n\n\n\n        dc->clear_imm = 1;\n\n        decode(dc, cpu_ldl_code(env, dc->pc));\n\n        if (dc->clear_imm)\n\n            dc->tb_flags &= ~IMM_FLAG;\n\n        dc->pc += 4;\n\n        num_insns++;\n\n\n\n        if (dc->delayed_branch) {\n\n            dc->delayed_branch--;\n\n            if (!dc->delayed_branch) {\n\n                if (dc->tb_flags & DRTI_FLAG)\n\n                    do_rti(dc);\n\n                 if (dc->tb_flags & DRTB_FLAG)\n\n                    do_rtb(dc);\n\n                if (dc->tb_flags & DRTE_FLAG)\n\n                    do_rte(dc);\n\n                /* Clear the delay slot flag.  */\n\n                dc->tb_flags &= ~D_FLAG;\n\n                /* If it is a direct jump, try direct chaining.  */\n\n                if (dc->jmp == JMP_INDIRECT) {\n\n                    eval_cond_jmp(dc, env_btarget, tcg_const_tl(dc->pc));\n\n                    dc->is_jmp = DISAS_JUMP;\n\n                } else if (dc->jmp == JMP_DIRECT) {\n\n                    t_sync_flags(dc);\n\n                    gen_goto_tb(dc, 0, dc->jmp_pc);\n\n                    dc->is_jmp = DISAS_TB_JUMP;\n\n                } else if (dc->jmp == JMP_DIRECT_CC) {\n\n                    int l1;\n\n\n\n                    t_sync_flags(dc);\n\n                    l1 = gen_new_label();\n\n                    /* Conditional jmp.  */\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, env_btaken, 0, l1);\n\n                    gen_goto_tb(dc, 1, dc->pc);\n\n                    gen_set_label(l1);\n\n                    gen_goto_tb(dc, 0, dc->jmp_pc);\n\n\n\n                    dc->is_jmp = DISAS_TB_JUMP;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n        if (cs->singlestep_enabled) {\n\n            break;\n\n        }\n\n    } while (!dc->is_jmp && !dc->cpustate_changed\n\n             && !tcg_op_buf_full()\n\n             && !singlestep\n\n             && (dc->pc < next_page_start)\n\n             && num_insns < max_insns);\n\n\n\n    npc = dc->pc;\n\n    if (dc->jmp == JMP_DIRECT || dc->jmp == JMP_DIRECT_CC) {\n\n        if (dc->tb_flags & D_FLAG) {\n\n            dc->is_jmp = DISAS_UPDATE;\n\n            tcg_gen_movi_tl(cpu_SR[SR_PC], npc);\n\n            sync_jmpstate(dc);\n\n        } else\n\n            npc = dc->jmp_pc;\n\n    }\n\n\n\n    if (tb->cflags & CF_LAST_IO)\n\n        gen_io_end();\n\n    /* Force an update if the per-tb cpu state has changed.  */\n\n    if (dc->is_jmp == DISAS_NEXT\n\n        && (dc->cpustate_changed || org_flags != dc->tb_flags)) {\n\n        dc->is_jmp = DISAS_UPDATE;\n\n        tcg_gen_movi_tl(cpu_SR[SR_PC], npc);\n\n    }\n\n    t_sync_flags(dc);\n\n\n\n    if (unlikely(cs->singlestep_enabled)) {\n\n        TCGv_i32 tmp = tcg_const_i32(EXCP_DEBUG);\n\n\n\n        if (dc->is_jmp != DISAS_JUMP) {\n\n            tcg_gen_movi_tl(cpu_SR[SR_PC], npc);\n\n        }\n\n        gen_helper_raise_exception(cpu_env, tmp);\n\n        tcg_temp_free_i32(tmp);\n\n    } else {\n\n        switch(dc->is_jmp) {\n\n            case DISAS_NEXT:\n\n                gen_goto_tb(dc, 1, npc);\n\n                break;\n\n            default:\n\n            case DISAS_JUMP:\n\n            case DISAS_UPDATE:\n\n                /* indicate that the hash table must be used\n\n                   to find the next TB */\n\n                tcg_gen_exit_tb(0);\n\n                break;\n\n            case DISAS_TB_JUMP:\n\n                /* nothing more to generate */\n\n                break;\n\n        }\n\n    }\n\n    gen_tb_end(tb, num_insns);\n\n\n\n    if (search_pc) {\n\n        j = tcg_op_buf_count();\n\n        lj++;\n\n        while (lj <= j)\n\n            tcg_ctx.gen_opc_instr_start[lj++] = 0;\n\n    } else {\n\n        tb->size = dc->pc - pc_start;\n\n                tb->icount = num_insns;\n\n    }\n\n\n\n#ifdef DEBUG_DISAS\n\n#if !SIM_COMPAT\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"\\n\");\n\n#if DISAS_GNU\n\n        log_target_disas(env, pc_start, dc->pc - pc_start, 0);\n\n#endif\n\n        qemu_log(\"\\nisize=%d osize=%d\\n\",\n\n                 dc->pc - pc_start, tcg_op_buf_count());\n\n    }\n\n#endif\n\n#endif\n\n    assert(!dc->abort_at_next_insn);\n\n}\n", "idx": 26542}
{"project": "qemu", "commit_id": "17b74b98676aee5bc470b173b1e528d2fce2cf18", "target": 0, "func": "void json_prop_int(QJSON *json, const char *name, int64_t val)\n\n{\n\n    json_emit_element(json, name);\n\n    qstring_append_int(json->str, val);\n\n}\n", "idx": 26543}
{"project": "qemu", "commit_id": "acfb23ad3dd8d0ab385a10e483776ba7dcf927ad", "target": 0, "func": "static void test_bh_delete_from_cb_many(void)\n\n{\n\n    BHTestData data1 = { .n = 0, .max = 1 };\n\n    BHTestData data2 = { .n = 0, .max = 3 };\n\n    BHTestData data3 = { .n = 0, .max = 2 };\n\n    BHTestData data4 = { .n = 0, .max = 4 };\n\n\n\n    data1.bh = aio_bh_new(ctx, bh_delete_cb, &data1);\n\n    data2.bh = aio_bh_new(ctx, bh_delete_cb, &data2);\n\n    data3.bh = aio_bh_new(ctx, bh_delete_cb, &data3);\n\n    data4.bh = aio_bh_new(ctx, bh_delete_cb, &data4);\n\n\n\n    qemu_bh_schedule(data1.bh);\n\n    qemu_bh_schedule(data2.bh);\n\n    qemu_bh_schedule(data3.bh);\n\n    qemu_bh_schedule(data4.bh);\n\n    g_assert_cmpint(data1.n, ==, 0);\n\n    g_assert_cmpint(data2.n, ==, 0);\n\n    g_assert_cmpint(data3.n, ==, 0);\n\n    g_assert_cmpint(data4.n, ==, 0);\n\n\n\n    g_assert(aio_poll(ctx, false));\n\n    g_assert_cmpint(data1.n, ==, 1);\n\n    g_assert_cmpint(data2.n, ==, 1);\n\n    g_assert_cmpint(data3.n, ==, 1);\n\n    g_assert_cmpint(data4.n, ==, 1);\n\n    g_assert(data1.bh == NULL);\n\n\n\n    wait_for_aio();\n\n    g_assert_cmpint(data1.n, ==, data1.max);\n\n    g_assert_cmpint(data2.n, ==, data2.max);\n\n    g_assert_cmpint(data3.n, ==, data3.max);\n\n    g_assert_cmpint(data4.n, ==, data4.max);\n\n    g_assert(data1.bh == NULL);\n\n    g_assert(data2.bh == NULL);\n\n    g_assert(data3.bh == NULL);\n\n    g_assert(data4.bh == NULL);\n\n}\n", "idx": 26544}
{"project": "qemu", "commit_id": "2e6fc7eb1a4af1b127df5f07b8bb28af891946fa", "target": 0, "func": "static int raw_has_zero_init(BlockDriverState *bs)\n\n{\n\n    return bdrv_has_zero_init(bs->file->bs);\n\n}\n", "idx": 26545}
{"project": "qemu", "commit_id": "fd8f5e37557596e14a859d8edf3dc24523bd4400", "target": 0, "func": "void bios_linker_loader_add_pointer(GArray *linker,\n\n                                    const char *dest_file,\n\n                                    const char *src_file,\n\n                                    GArray *table, void *pointer,\n\n                                    uint8_t pointer_size)\n\n{\n\n    BiosLinkerLoaderEntry entry;\n\n\n\n    memset(&entry, 0, sizeof entry);\n\n    strncpy(entry.pointer.dest_file, dest_file,\n\n            sizeof entry.pointer.dest_file - 1);\n\n    strncpy(entry.pointer.src_file, src_file,\n\n            sizeof entry.pointer.src_file - 1);\n\n    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_POINTER);\n\n    entry.pointer.offset = cpu_to_le32((gchar *)pointer - table->data);\n\n    entry.pointer.size = pointer_size;\n\n    assert(pointer_size == 1 || pointer_size == 2 ||\n\n           pointer_size == 4 || pointer_size == 8);\n\n\n\n    g_array_append_val(linker, entry);\n\n}\n", "idx": 26546}
{"project": "qemu", "commit_id": "b1424e0381a7f1c9969079eca4458d5f20bf1859", "target": 0, "func": "static void vga_draw_graphic(VGACommonState *s, int full_update)\n\n{\n\n    int y1, y, update, linesize, y_start, double_scan, mask, depth;\n\n    int width, height, shift_control, line_offset, bwidth, bits;\n\n    ram_addr_t page0, page1, page_min, page_max;\n\n    int disp_width, multi_scan, multi_run;\n\n    uint8_t *d;\n\n    uint32_t v, addr1, addr;\n\n    vga_draw_line_func *vga_draw_line;\n\n\n\n    full_update |= update_basic_params(s);\n\n\n\n    if (!full_update)\n\n        vga_sync_dirty_bitmap(s);\n\n\n\n    s->get_resolution(s, &width, &height);\n\n    disp_width = width;\n\n\n\n    shift_control = (s->gr[VGA_GFX_MODE] >> 5) & 3;\n\n    double_scan = (s->cr[VGA_CRTC_MAX_SCAN] >> 7);\n\n    if (shift_control != 1) {\n\n        multi_scan = (((s->cr[VGA_CRTC_MAX_SCAN] & 0x1f) + 1) << double_scan)\n\n            - 1;\n\n    } else {\n\n        /* in CGA modes, multi_scan is ignored */\n\n        /* XXX: is it correct ? */\n\n        multi_scan = double_scan;\n\n    }\n\n    multi_run = multi_scan;\n\n    if (shift_control != s->shift_control ||\n\n        double_scan != s->double_scan) {\n\n        full_update = 1;\n\n        s->shift_control = shift_control;\n\n        s->double_scan = double_scan;\n\n    }\n\n\n\n    if (shift_control == 0) {\n\n        if (s->sr[VGA_SEQ_CLOCK_MODE] & 8) {\n\n            disp_width <<= 1;\n\n        }\n\n    } else if (shift_control == 1) {\n\n        if (s->sr[VGA_SEQ_CLOCK_MODE] & 8) {\n\n            disp_width <<= 1;\n\n        }\n\n    }\n\n\n\n    depth = s->get_bpp(s);\n\n    if (s->line_offset != s->last_line_offset ||\n\n        disp_width != s->last_width ||\n\n        height != s->last_height ||\n\n        s->last_depth != depth) {\n\n#if defined(HOST_WORDS_BIGENDIAN) == defined(TARGET_WORDS_BIGENDIAN)\n\n        if (depth == 16 || depth == 32) {\n\n#else\n\n        if (depth == 32) {\n\n#endif\n\n            qemu_free_displaysurface(s->ds);\n\n            s->ds->surface = qemu_create_displaysurface_from(disp_width, height, depth,\n\n                    s->line_offset,\n\n                    s->vram_ptr + (s->start_addr * 4));\n\n#if defined(HOST_WORDS_BIGENDIAN) != defined(TARGET_WORDS_BIGENDIAN)\n\n            s->ds->surface->pf = qemu_different_endianness_pixelformat(depth);\n\n#endif\n\n            dpy_gfx_resize(s->ds);\n\n        } else {\n\n            qemu_console_resize(s->ds, disp_width, height);\n\n        }\n\n        s->last_scr_width = disp_width;\n\n        s->last_scr_height = height;\n\n        s->last_width = disp_width;\n\n        s->last_height = height;\n\n        s->last_line_offset = s->line_offset;\n\n        s->last_depth = depth;\n\n        full_update = 1;\n\n    } else if (is_buffer_shared(s->ds->surface) &&\n\n               (full_update || ds_get_data(s->ds) != s->vram_ptr\n\n                + (s->start_addr * 4))) {\n\n        qemu_free_displaysurface(s->ds);\n\n        s->ds->surface = qemu_create_displaysurface_from(disp_width,\n\n                height, depth,\n\n                s->line_offset,\n\n                s->vram_ptr + (s->start_addr * 4));\n\n        dpy_gfx_setdata(s->ds);\n\n    }\n\n\n\n    s->rgb_to_pixel =\n\n        rgb_to_pixel_dup_table[get_depth_index(s->ds)];\n\n\n\n    if (shift_control == 0) {\n\n        full_update |= update_palette16(s);\n\n        if (s->sr[VGA_SEQ_CLOCK_MODE] & 8) {\n\n            v = VGA_DRAW_LINE4D2;\n\n        } else {\n\n            v = VGA_DRAW_LINE4;\n\n        }\n\n        bits = 4;\n\n    } else if (shift_control == 1) {\n\n        full_update |= update_palette16(s);\n\n        if (s->sr[VGA_SEQ_CLOCK_MODE] & 8) {\n\n            v = VGA_DRAW_LINE2D2;\n\n        } else {\n\n            v = VGA_DRAW_LINE2;\n\n        }\n\n        bits = 4;\n\n    } else {\n\n        switch(s->get_bpp(s)) {\n\n        default:\n\n        case 0:\n\n            full_update |= update_palette256(s);\n\n            v = VGA_DRAW_LINE8D2;\n\n            bits = 4;\n\n            break;\n\n        case 8:\n\n            full_update |= update_palette256(s);\n\n            v = VGA_DRAW_LINE8;\n\n            bits = 8;\n\n            break;\n\n        case 15:\n\n            v = VGA_DRAW_LINE15;\n\n            bits = 16;\n\n            break;\n\n        case 16:\n\n            v = VGA_DRAW_LINE16;\n\n            bits = 16;\n\n            break;\n\n        case 24:\n\n            v = VGA_DRAW_LINE24;\n\n            bits = 24;\n\n            break;\n\n        case 32:\n\n            v = VGA_DRAW_LINE32;\n\n            bits = 32;\n\n            break;\n\n        }\n\n    }\n\n    vga_draw_line = vga_draw_line_table[v * NB_DEPTHS + get_depth_index(s->ds)];\n\n\n\n    if (!is_buffer_shared(s->ds->surface) && s->cursor_invalidate)\n\n        s->cursor_invalidate(s);\n\n\n\n    line_offset = s->line_offset;\n\n#if 0\n\n    printf(\"w=%d h=%d v=%d line_offset=%d cr[0x09]=0x%02x cr[0x17]=0x%02x linecmp=%d sr[0x01]=0x%02x\\n\",\n\n           width, height, v, line_offset, s->cr[9], s->cr[VGA_CRTC_MODE],\n\n           s->line_compare, s->sr[VGA_SEQ_CLOCK_MODE]);\n\n#endif\n\n    addr1 = (s->start_addr * 4);\n\n    bwidth = (width * bits + 7) / 8;\n\n    y_start = -1;\n\n    page_min = -1;\n\n    page_max = 0;\n\n    d = ds_get_data(s->ds);\n\n    linesize = ds_get_linesize(s->ds);\n\n    y1 = 0;\n\n    for(y = 0; y < height; y++) {\n\n        addr = addr1;\n\n        if (!(s->cr[VGA_CRTC_MODE] & 1)) {\n\n            int shift;\n\n            /* CGA compatibility handling */\n\n            shift = 14 + ((s->cr[VGA_CRTC_MODE] >> 6) & 1);\n\n            addr = (addr & ~(1 << shift)) | ((y1 & 1) << shift);\n\n        }\n\n        if (!(s->cr[VGA_CRTC_MODE] & 2)) {\n\n            addr = (addr & ~0x8000) | ((y1 & 2) << 14);\n\n        }\n\n        update = full_update;\n\n        page0 = addr;\n\n        page1 = addr + bwidth - 1;\n\n        update |= memory_region_get_dirty(&s->vram, page0, page1 - page0,\n\n                                          DIRTY_MEMORY_VGA);\n\n        /* explicit invalidation for the hardware cursor */\n\n        update |= (s->invalidated_y_table[y >> 5] >> (y & 0x1f)) & 1;\n\n        if (update) {\n\n            if (y_start < 0)\n\n                y_start = y;\n\n            if (page0 < page_min)\n\n                page_min = page0;\n\n            if (page1 > page_max)\n\n                page_max = page1;\n\n            if (!(is_buffer_shared(s->ds->surface))) {\n\n                vga_draw_line(s, d, s->vram_ptr + addr, width);\n\n                if (s->cursor_draw_line)\n\n                    s->cursor_draw_line(s, d, y);\n\n            }\n\n        } else {\n\n            if (y_start >= 0) {\n\n                /* flush to display */\n\n                dpy_gfx_update(s->ds, 0, y_start,\n\n                               disp_width, y - y_start);\n\n                y_start = -1;\n\n            }\n\n        }\n\n        if (!multi_run) {\n\n            mask = (s->cr[VGA_CRTC_MODE] & 3) ^ 3;\n\n            if ((y1 & mask) == mask)\n\n                addr1 += line_offset;\n\n            y1++;\n\n            multi_run = multi_scan;\n\n        } else {\n\n            multi_run--;\n\n        }\n\n        /* line compare acts on the displayed lines */\n\n        if (y == s->line_compare)\n\n            addr1 = 0;\n\n        d += linesize;\n\n    }\n\n    if (y_start >= 0) {\n\n        /* flush to display */\n\n        dpy_gfx_update(s->ds, 0, y_start,\n\n                       disp_width, y - y_start);\n\n    }\n\n    /* reset modified pages */\n\n    if (page_max >= page_min) {\n\n        memory_region_reset_dirty(&s->vram,\n\n                                  page_min,\n\n                                  page_max - page_min,\n\n                                  DIRTY_MEMORY_VGA);\n\n    }\n\n    memset(s->invalidated_y_table, 0, ((height + 31) >> 5) * 4);\n\n}\n", "idx": 26547}
{"project": "qemu", "commit_id": "190563f9a90c9df8ad32fc7f3e4b166deda949a6", "target": 0, "func": "static int usb_net_handle_datain(USBNetState *s, USBPacket *p)\n\n{\n\n    int ret = USB_RET_NAK;\n\n\n\n    if (s->in_ptr > s->in_len) {\n\n        s->in_ptr = s->in_len = 0;\n\n        ret = USB_RET_NAK;\n\n        return ret;\n\n    }\n\n    if (!s->in_len) {\n\n        ret = USB_RET_NAK;\n\n        return ret;\n\n    }\n\n    ret = s->in_len - s->in_ptr;\n\n    if (ret > p->iov.size) {\n\n        ret = p->iov.size;\n\n    }\n\n    usb_packet_copy(p, &s->in_buf[s->in_ptr], ret);\n\n    s->in_ptr += ret;\n\n    if (s->in_ptr >= s->in_len &&\n\n                    (is_rndis(s) || (s->in_len & (64 - 1)) || !ret)) {\n\n        /* no short packet necessary */\n\n        s->in_ptr = s->in_len = 0;\n\n    }\n\n\n\n#ifdef TRAFFIC_DEBUG\n\n    fprintf(stderr, \"usbnet: data in len %zu return %d\", p->iov.size, ret);\n\n    iov_hexdump(p->iov.iov, p->iov.niov, stderr, \"usbnet\", ret);\n\n#endif\n\n\n\n    return ret;\n\n}\n", "idx": 26549}
{"project": "qemu", "commit_id": "7d3467d903c0fa663fbe3f1002e7c624a210b634", "target": 0, "func": "static void usb_msd_realize_storage(USBDevice *dev, Error **errp)\n\n{\n\n    MSDState *s = USB_STORAGE_DEV(dev);\n\n    BlockBackend *blk = s->conf.blk;\n\n    SCSIDevice *scsi_dev;\n\n    Error *err = NULL;\n\n\n\n    if (!blk) {\n\n        error_setg(errp, \"drive property not set\");\n\n        return;\n\n    }\n\n\n\n    bdrv_add_key(blk_bs(blk), NULL, &err);\n\n    if (err) {\n\n        if (monitor_cur_is_qmp()) {\n\n            error_propagate(errp, err);\n\n            return;\n\n        }\n\n        error_free(err);\n\n        err = NULL;\n\n        if (cur_mon) {\n\n            monitor_read_bdrv_key_start(cur_mon, blk_bs(blk),\n\n                                        usb_msd_password_cb, s);\n\n            s->dev.auto_attach = 0;\n\n        } else {\n\n            autostart = 0;\n\n        }\n\n    }\n\n\n\n    blkconf_serial(&s->conf, &dev->serial);\n\n    blkconf_blocksizes(&s->conf);\n\n\n\n    /*\n\n     * Hack alert: this pretends to be a block device, but it's really\n\n     * a SCSI bus that can serve only a single device, which it\n\n     * creates automatically.  But first it needs to detach from its\n\n     * blockdev, or else scsi_bus_legacy_add_drive() dies when it\n\n     * attaches again.\n\n     *\n\n     * The hack is probably a bad idea.\n\n     */\n\n    blk_detach_dev(blk, &s->dev.qdev);\n\n    s->conf.blk = NULL;\n\n\n\n    usb_desc_create_serial(dev);\n\n    usb_desc_init(dev);\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),\n\n                 &usb_msd_scsi_info_storage, NULL);\n\n    scsi_dev = scsi_bus_legacy_add_drive(&s->bus, blk, 0, !!s->removable,\n\n                                         s->conf.bootindex, dev->serial,\n\n                                         &err);\n\n    if (!scsi_dev) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n    usb_msd_handle_reset(dev);\n\n    s->scsi_dev = scsi_dev;\n\n}\n", "idx": 26550}
{"project": "qemu", "commit_id": "6214e73cc5b75a4f8d89a70d71727edfa47a81b3", "target": 0, "func": "static int usb_xhci_initfn(struct PCIDevice *dev)\n\n{\n\n    int i, ret;\n\n\n\n    XHCIState *xhci = DO_UPCAST(XHCIState, pci_dev, dev);\n\n\n\n    xhci->pci_dev.config[PCI_CLASS_PROG] = 0x30;    /* xHCI */\n\n    xhci->pci_dev.config[PCI_INTERRUPT_PIN] = 0x01; /* interrupt pin 1 */\n\n    xhci->pci_dev.config[PCI_CACHE_LINE_SIZE] = 0x10;\n\n    xhci->pci_dev.config[0x60] = 0x30; /* release number */\n\n\n\n    usb_xhci_init(xhci, &dev->qdev);\n\n\n\n    if (xhci->numintrs > MAXINTRS) {\n\n        xhci->numintrs = MAXINTRS;\n\n    }\n\n    if (xhci->numintrs < 1) {\n\n        xhci->numintrs = 1;\n\n    }\n\n    if (xhci->numslots > MAXSLOTS) {\n\n        xhci->numslots = MAXSLOTS;\n\n    }\n\n    if (xhci->numslots < 1) {\n\n        xhci->numslots = 1;\n\n    }\n\n\n\n    xhci->mfwrap_timer = qemu_new_timer_ns(vm_clock, xhci_mfwrap_timer, xhci);\n\n\n\n    xhci->irq = xhci->pci_dev.irq[0];\n\n\n\n    memory_region_init(&xhci->mem, \"xhci\", LEN_REGS);\n\n    memory_region_init_io(&xhci->mem_cap, &xhci_cap_ops, xhci,\n\n                          \"capabilities\", LEN_CAP);\n\n    memory_region_init_io(&xhci->mem_oper, &xhci_oper_ops, xhci,\n\n                          \"operational\", 0x400);\n\n    memory_region_init_io(&xhci->mem_runtime, &xhci_runtime_ops, xhci,\n\n                          \"runtime\", LEN_RUNTIME);\n\n    memory_region_init_io(&xhci->mem_doorbell, &xhci_doorbell_ops, xhci,\n\n                          \"doorbell\", LEN_DOORBELL);\n\n\n\n    memory_region_add_subregion(&xhci->mem, 0,            &xhci->mem_cap);\n\n    memory_region_add_subregion(&xhci->mem, OFF_OPER,     &xhci->mem_oper);\n\n    memory_region_add_subregion(&xhci->mem, OFF_RUNTIME,  &xhci->mem_runtime);\n\n    memory_region_add_subregion(&xhci->mem, OFF_DOORBELL, &xhci->mem_doorbell);\n\n\n\n    for (i = 0; i < xhci->numports; i++) {\n\n        XHCIPort *port = &xhci->ports[i];\n\n        uint32_t offset = OFF_OPER + 0x400 + 0x10 * i;\n\n        port->xhci = xhci;\n\n        memory_region_init_io(&port->mem, &xhci_port_ops, port,\n\n                              port->name, 0x10);\n\n        memory_region_add_subregion(&xhci->mem, offset, &port->mem);\n\n    }\n\n\n\n    pci_register_bar(&xhci->pci_dev, 0,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY|PCI_BASE_ADDRESS_MEM_TYPE_64,\n\n                     &xhci->mem);\n\n\n\n    ret = pcie_cap_init(&xhci->pci_dev, 0xa0, PCI_EXP_TYPE_ENDPOINT, 0);\n\n    assert(ret >= 0);\n\n\n\n    if (xhci->flags & (1 << XHCI_FLAG_USE_MSI)) {\n\n        msi_init(&xhci->pci_dev, 0x70, xhci->numintrs, true, false);\n\n    }\n\n    if (xhci->flags & (1 << XHCI_FLAG_USE_MSI_X)) {\n\n        msix_init(&xhci->pci_dev, xhci->numintrs,\n\n                  &xhci->mem, 0, OFF_MSIX_TABLE,\n\n                  &xhci->mem, 0, OFF_MSIX_PBA,\n\n                  0x90);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 26551}
{"project": "qemu", "commit_id": "e4f308bbf9f360ee2af5b94b87aef170d8f20dc4", "target": 0, "func": "static void pm_update_sci(PIIX4PMState *s)\n\n{\n\n    int sci_level, pmsts;\n\n\n\n    pmsts = acpi_pm1_evt_get_sts(&s->ar);\n\n    sci_level = (((pmsts & s->ar.pm1.evt.en) &\n\n                  (ACPI_BITMASK_RT_CLOCK_ENABLE |\n\n                   ACPI_BITMASK_POWER_BUTTON_ENABLE |\n\n                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |\n\n                   ACPI_BITMASK_TIMER_ENABLE)) != 0) ||\n\n        (((s->ar.gpe.sts[0] & s->ar.gpe.en[0]) &\n\n          (PIIX4_PCI_HOTPLUG_STATUS | PIIX4_CPU_HOTPLUG_STATUS)) != 0);\n\n\n\n    qemu_set_irq(s->irq, sci_level);\n\n    /* schedule a timer interruption if needed */\n\n    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&\n\n                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));\n\n}\n", "idx": 26552}
{"project": "qemu", "commit_id": "ad523590f62cf5d44e97388de370d27b95b25aff", "target": 0, "func": "void memory_region_iommu_replay(MemoryRegion *mr, IOMMUNotifier *n,\n\n                                bool is_write)\n\n{\n\n    hwaddr addr, granularity;\n\n    IOMMUTLBEntry iotlb;\n\n    IOMMUAccessFlags flag = is_write ? IOMMU_WO : IOMMU_RO;\n\n\n\n    /* If the IOMMU has its own replay callback, override */\n\n    if (mr->iommu_ops->replay) {\n\n        mr->iommu_ops->replay(mr, n);\n\n        return;\n\n    }\n\n\n\n    granularity = memory_region_iommu_get_min_page_size(mr);\n\n\n\n    for (addr = 0; addr < memory_region_size(mr); addr += granularity) {\n\n        iotlb = mr->iommu_ops->translate(mr, addr, flag);\n\n        if (iotlb.perm != IOMMU_NONE) {\n\n            n->notify(n, &iotlb);\n\n        }\n\n\n\n        /* if (2^64 - MR size) < granularity, it's possible to get an\n\n         * infinite loop here.  This should catch such a wraparound */\n\n        if ((addr + granularity) < addr) {\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 26553}
{"project": "qemu", "commit_id": "56a6f02b8ce1fe41a2a9077593e46eca7d98267d", "target": 0, "func": "static void qmp_output_end_list(Visitor *v)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    qmp_output_pop(qov);\n\n}\n", "idx": 26554}
{"project": "qemu", "commit_id": "2ba82852894c762299b7d05e9a2be184116b80f0", "target": 1, "func": "static void *file_ram_alloc(RAMBlock *block,\n\n                            ram_addr_t memory,\n\n                            const char *path)\n\n{\n\n    char *filename;\n\n    char *sanitized_name;\n\n    char *c;\n\n    void *area;\n\n    int fd;\n\n    unsigned long hpagesize;\n\n\n\n    hpagesize = gethugepagesize(path);\n\n    if (!hpagesize) {\n\n        return NULL;\n\n    }\n\n\n\n    if (memory < hpagesize) {\n\n        return NULL;\n\n    }\n\n\n\n    if (kvm_enabled() && !kvm_has_sync_mmu()) {\n\n        fprintf(stderr, \"host lacks kvm mmu notifiers, -mem-path unsupported\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    /* Make name safe to use with mkstemp by replacing '/' with '_'. */\n\n    sanitized_name = g_strdup(block->mr->name);\n\n    for (c = sanitized_name; *c != '\\0'; c++) {\n\n        if (*c == '/')\n\n            *c = '_';\n\n    }\n\n\n\n    filename = g_strdup_printf(\"%s/qemu_back_mem.%s.XXXXXX\", path,\n\n                               sanitized_name);\n\n    g_free(sanitized_name);\n\n\n\n    fd = mkstemp(filename);\n\n    if (fd < 0) {\n\n        perror(\"unable to create backing store for hugepages\");\n\n        g_free(filename);\n\n        return NULL;\n\n    }\n\n    unlink(filename);\n\n    g_free(filename);\n\n\n\n    memory = (memory+hpagesize-1) & ~(hpagesize-1);\n\n\n\n    /*\n\n     * ftruncate is not supported by hugetlbfs in older\n\n     * hosts, so don't bother bailing out on errors.\n\n     * If anything goes wrong with it under other filesystems,\n\n     * mmap will fail.\n\n     */\n\n    if (ftruncate(fd, memory))\n\n        perror(\"ftruncate\");\n\n\n\n    area = mmap(0, memory, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\n\n    if (area == MAP_FAILED) {\n\n        perror(\"file_ram_alloc: can't mmap RAM pages\");\n\n        close(fd);\n\n        return (NULL);\n\n    }\n\n\n\n    if (mem_prealloc) {\n\n        int ret, i;\n\n        struct sigaction act, oldact;\n\n        sigset_t set, oldset;\n\n\n\n        memset(&act, 0, sizeof(act));\n\n        act.sa_handler = &sigbus_handler;\n\n        act.sa_flags = 0;\n\n\n\n        ret = sigaction(SIGBUS, &act, &oldact);\n\n        if (ret) {\n\n            perror(\"file_ram_alloc: failed to install signal handler\");\n\n            exit(1);\n\n        }\n\n\n\n        /* unblock SIGBUS */\n\n        sigemptyset(&set);\n\n        sigaddset(&set, SIGBUS);\n\n        pthread_sigmask(SIG_UNBLOCK, &set, &oldset);\n\n\n\n        if (sigsetjmp(sigjump, 1)) {\n\n            fprintf(stderr, \"file_ram_alloc: failed to preallocate pages\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        /* MAP_POPULATE silently ignores failures */\n\n        for (i = 0; i < (memory/hpagesize)-1; i++) {\n\n            memset(area + (hpagesize*i), 0, 1);\n\n        }\n\n\n\n        ret = sigaction(SIGBUS, &oldact, NULL);\n\n        if (ret) {\n\n            perror(\"file_ram_alloc: failed to reinstall signal handler\");\n\n            exit(1);\n\n        }\n\n\n\n        pthread_sigmask(SIG_SETMASK, &oldset, NULL);\n\n    }\n\n\n\n    block->fd = fd;\n\n    return area;\n\n}\n", "idx": 26557}
{"project": "qemu", "commit_id": "2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3", "target": 1, "func": "static void boston_register_types(void)\n\n{\n\n    type_register_static(&boston_device);\n\n}\n", "idx": 26558}
{"project": "qemu", "commit_id": "0c9390d978cbf61e8f16c9f580fa96b305c43568", "target": 1, "func": "static gboolean nbd_accept(QIOChannel *ioc, GIOCondition condition,\n\n                           gpointer opaque)\n\n{\n\n    QIOChannelSocket *cioc;\n\n\n\n    if (!nbd_server) {\n\n        return FALSE;\n\n    }\n\n\n\n    cioc = qio_channel_socket_accept(QIO_CHANNEL_SOCKET(ioc),\n\n                                     NULL);\n\n    if (!cioc) {\n\n        return TRUE;\n\n    }\n\n\n\n    qio_channel_set_name(QIO_CHANNEL(cioc), \"nbd-server\");\n\n    nbd_client_new(NULL, cioc,\n\n                   nbd_server->tlscreds, NULL,\n\n                   nbd_client_put);\n\n    object_unref(OBJECT(cioc));\n\n    return TRUE;\n\n}\n", "idx": 26560}
{"project": "qemu", "commit_id": "6573d9c63885aaf533366ab5c68318d1cf1a0fcc", "target": 0, "func": "bool block_job_user_paused(BlockJob *job)\n\n{\n\n    return job ? job->user_paused : 0;\n\n}\n", "idx": 26562}
{"project": "qemu", "commit_id": "0dfe952dc5c2921488a1172407857d5bb81d17a4", "target": 0, "func": "static void booke_decr_cb(void *opaque)\n\n{\n\n    PowerPCCPU *cpu = opaque;\n\n    CPUPPCState *env = &cpu->env;\n\n\n\n    env->spr[SPR_BOOKE_TSR] |= TSR_DIS;\n\n    booke_update_irq(cpu);\n\n\n\n    if (env->spr[SPR_BOOKE_TCR] & TCR_ARE) {\n\n        /* Auto Reload */\n\n        cpu_ppc_store_decr(env, env->spr[SPR_BOOKE_DECAR]);\n\n    }\n\n}\n", "idx": 26563}
{"project": "qemu", "commit_id": "9f8863ebd7f584762a906881a62a04ac05ce4898", "target": 0, "func": "static char *read_splashfile(char *filename, size_t *file_sizep,\n\n                             int *file_typep)\n\n{\n\n    GError *err = NULL;\n\n    gboolean res;\n\n    gchar *content;\n\n    int file_type = -1;\n\n    unsigned int filehead = 0;\n\n    int bmp_bpp;\n\n\n\n    res = g_file_get_contents(filename, &content, file_sizep, &err);\n\n    if (res == FALSE) {\n\n        error_report(\"failed to read splash file '%s'\", filename);\n\n        g_error_free(err);\n\n        return NULL;\n\n    }\n\n\n\n    /* check file size */\n\n    if (*file_sizep < 30) {\n\n        goto error;\n\n    }\n\n\n\n    /* check magic ID */\n\n    filehead = ((content[0] & 0xff) + (content[1] << 8)) & 0xffff;\n\n    if (filehead == 0xd8ff) {\n\n        file_type = JPG_FILE;\n\n    } else if (filehead == 0x4d42) {\n\n        file_type = BMP_FILE;\n\n    } else {\n\n        goto error;\n\n    }\n\n\n\n    /* check BMP bpp */\n\n    if (file_type == BMP_FILE) {\n\n        bmp_bpp = (content[28] + (content[29] << 8)) & 0xffff;\n\n        if (bmp_bpp != 24) {\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    /* return values */\n\n    *file_typep = file_type;\n\n\n\n    return content;\n\n\n\nerror:\n\n    error_report(\"splash file '%s' format not recognized; must be JPEG \"\n\n                 \"or 24 bit BMP\", filename);\n\n    g_free(content);\n\n    return NULL;\n\n}\n", "idx": 26564}
{"project": "qemu", "commit_id": "d3b12f5dec4b27ebab58fb5797cb67bacced773b", "target": 0, "func": "static void qemu_event_read(void *opaque)\n\n{\n\n    int fd = (intptr_t)opaque;\n\n    ssize_t len;\n\n    char buffer[512];\n\n\n\n    /* Drain the notify pipe.  For eventfd, only 8 bytes will be read.  */\n\n    do {\n\n        len = read(fd, buffer, sizeof(buffer));\n\n    } while ((len == -1 && errno == EINTR) || len == sizeof(buffer));\n\n}\n", "idx": 26565}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static struct omap_tipb_bridge_s *omap_tipb_bridge_init(\n\n    MemoryRegion *memory, target_phys_addr_t base,\n\n    qemu_irq abort_irq, omap_clk clk)\n\n{\n\n    struct omap_tipb_bridge_s *s = (struct omap_tipb_bridge_s *)\n\n            g_malloc0(sizeof(struct omap_tipb_bridge_s));\n\n\n\n    s->abort = abort_irq;\n\n    omap_tipb_bridge_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_tipb_bridge_ops, s,\n\n                          \"omap-tipb-bridge\", 0x100);\n\n    memory_region_add_subregion(memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 26566}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static int coreaudio_init_out (HWVoiceOut *hw, audsettings_t *as)\n\n{\n\n    OSStatus status;\n\n    coreaudioVoiceOut *core = (coreaudioVoiceOut *) hw;\n\n    UInt32 propertySize;\n\n    int err;\n\n    const char *typ = \"playback\";\n\n    AudioValueRange frameRange;\n\n\n\n    /* create mutex */\n\n    err = pthread_mutex_init(&core->mutex, NULL);\n\n    if (err) {\n\n        dolog(\"Could not create mutex\\nReason: %s\\n\", strerror (err));\n\n        return -1;\n\n    }\n\n\n\n    audio_pcm_init_info (&hw->info, as);\n\n\n\n    /* open default output device */\n\n    propertySize = sizeof(core->outputDeviceID);\n\n    status = AudioHardwareGetProperty(\n\n        kAudioHardwarePropertyDefaultOutputDevice,\n\n        &propertySize,\n\n        &core->outputDeviceID);\n\n    if (status != kAudioHardwareNoError) {\n\n        coreaudio_logerr2 (status, typ,\n\n                           \"Could not get default output Device\\n\");\n\n        return -1;\n\n    }\n\n    if (core->outputDeviceID == kAudioDeviceUnknown) {\n\n        dolog (\"Could not initialize %s - Unknown Audiodevice\\n\", typ);\n\n        return -1;\n\n    }\n\n\n\n    /* get minimum and maximum buffer frame sizes */\n\n    propertySize = sizeof(frameRange);\n\n    status = AudioDeviceGetProperty(\n\n        core->outputDeviceID,\n\n        0,\n\n        0,\n\n        kAudioDevicePropertyBufferFrameSizeRange,\n\n        &propertySize,\n\n        &frameRange);\n\n    if (status != kAudioHardwareNoError) {\n\n        coreaudio_logerr2 (status, typ,\n\n                           \"Could not get device buffer frame range\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (frameRange.mMinimum > conf.buffer_frames) {\n\n        core->audioDevicePropertyBufferFrameSize = (UInt32) frameRange.mMinimum;\n\n        dolog (\"warning: Upsizing Buffer Frames to %f\\n\", frameRange.mMinimum);\n\n    }\n\n    else if (frameRange.mMaximum < conf.buffer_frames) {\n\n        core->audioDevicePropertyBufferFrameSize = (UInt32) frameRange.mMaximum;\n\n        dolog (\"warning: Downsizing Buffer Frames to %f\\n\", frameRange.mMaximum);\n\n    }\n\n    else {\n\n        core->audioDevicePropertyBufferFrameSize = conf.buffer_frames;\n\n    }\n\n\n\n    /* set Buffer Frame Size */\n\n    propertySize = sizeof(core->audioDevicePropertyBufferFrameSize);\n\n    status = AudioDeviceSetProperty(\n\n        core->outputDeviceID,\n\n        NULL,\n\n        0,\n\n        false,\n\n        kAudioDevicePropertyBufferFrameSize,\n\n        propertySize,\n\n        &core->audioDevicePropertyBufferFrameSize);\n\n    if (status != kAudioHardwareNoError) {\n\n        coreaudio_logerr2 (status, typ,\n\n                           \"Could not set device buffer frame size %ld\\n\",\n\n                           core->audioDevicePropertyBufferFrameSize);\n\n        return -1;\n\n    }\n\n\n\n    /* get Buffer Frame Size */\n\n    propertySize = sizeof(core->audioDevicePropertyBufferFrameSize);\n\n    status = AudioDeviceGetProperty(\n\n        core->outputDeviceID,\n\n        0,\n\n        false,\n\n        kAudioDevicePropertyBufferFrameSize,\n\n        &propertySize,\n\n        &core->audioDevicePropertyBufferFrameSize);\n\n    if (status != kAudioHardwareNoError) {\n\n        coreaudio_logerr2 (status, typ,\n\n                           \"Could not get device buffer frame size\\n\");\n\n        return -1;\n\n    }\n\n    hw->samples = conf.nbuffers * core->audioDevicePropertyBufferFrameSize;\n\n\n\n    /* get StreamFormat */\n\n    propertySize = sizeof(core->outputStreamBasicDescription);\n\n    status = AudioDeviceGetProperty(\n\n        core->outputDeviceID,\n\n        0,\n\n        false,\n\n        kAudioDevicePropertyStreamFormat,\n\n        &propertySize,\n\n        &core->outputStreamBasicDescription);\n\n    if (status != kAudioHardwareNoError) {\n\n        coreaudio_logerr2 (status, typ,\n\n                           \"Could not get Device Stream properties\\n\");\n\n        core->outputDeviceID = kAudioDeviceUnknown;\n\n        return -1;\n\n    }\n\n\n\n    /* set Samplerate */\n\n    core->outputStreamBasicDescription.mSampleRate = (Float64) as->freq;\n\n    propertySize = sizeof(core->outputStreamBasicDescription);\n\n    status = AudioDeviceSetProperty(\n\n        core->outputDeviceID,\n\n        0,\n\n        0,\n\n        0,\n\n        kAudioDevicePropertyStreamFormat,\n\n        propertySize,\n\n        &core->outputStreamBasicDescription);\n\n    if (status != kAudioHardwareNoError) {\n\n        coreaudio_logerr2 (status, typ, \"Could not set samplerate %d\\n\",\n\n                           as->freq);\n\n        core->outputDeviceID = kAudioDeviceUnknown;\n\n        return -1;\n\n    }\n\n\n\n    /* set Callback */\n\n    status = AudioDeviceAddIOProc(core->outputDeviceID, audioDeviceIOProc, hw);\n\n    if (status != kAudioHardwareNoError) {\n\n        coreaudio_logerr2 (status, typ, \"Could not set IOProc\\n\");\n\n        core->outputDeviceID = kAudioDeviceUnknown;\n\n        return -1;\n\n    }\n\n\n\n    /* start Playback */\n\n    if (!isPlaying(core->outputDeviceID)) {\n\n        status = AudioDeviceStart(core->outputDeviceID, audioDeviceIOProc);\n\n        if (status != kAudioHardwareNoError) {\n\n            coreaudio_logerr2 (status, typ, \"Could not start playback\\n\");\n\n            AudioDeviceRemoveIOProc(core->outputDeviceID, audioDeviceIOProc);\n\n            core->outputDeviceID = kAudioDeviceUnknown;\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 26567}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void thread_pool_submit(ThreadPool *pool, ThreadPoolFunc *func, void *arg)\n\n{\n\n    thread_pool_submit_aio(pool, func, arg, NULL, NULL);\n\n}\n", "idx": 26569}
{"project": "qemu", "commit_id": "3468b59e18b179bc63c7ce934de912dfa9596122", "target": 0, "func": "void tcg_region_init(void)\n\n{\n\n    void *buf = tcg_init_ctx.code_gen_buffer;\n\n    void *aligned;\n\n    size_t size = tcg_init_ctx.code_gen_buffer_size;\n\n    size_t page_size = qemu_real_host_page_size;\n\n    size_t region_size;\n\n    size_t n_regions;\n\n    size_t i;\n\n\n\n    /* We do not yet support multiple TCG contexts, so use one region for now */\n\n    n_regions = 1;\n\n\n\n    /* The first region will be 'aligned - buf' bytes larger than the others */\n\n    aligned = QEMU_ALIGN_PTR_UP(buf, page_size);\n\n    g_assert(aligned < tcg_init_ctx.code_gen_buffer + size);\n\n    /*\n\n     * Make region_size a multiple of page_size, using aligned as the start.\n\n     * As a result of this we might end up with a few extra pages at the end of\n\n     * the buffer; we will assign those to the last region.\n\n     */\n\n    region_size = (size - (aligned - buf)) / n_regions;\n\n    region_size = QEMU_ALIGN_DOWN(region_size, page_size);\n\n\n\n    /* A region must have at least 2 pages; one code, one guard */\n\n    g_assert(region_size >= 2 * page_size);\n\n\n\n    /* init the region struct */\n\n    qemu_mutex_init(&region.lock);\n\n    region.n = n_regions;\n\n    region.size = region_size - page_size;\n\n    region.stride = region_size;\n\n    region.start = buf;\n\n    region.start_aligned = aligned;\n\n    /* page-align the end, since its last page will be a guard page */\n\n    region.end = QEMU_ALIGN_PTR_DOWN(buf + size, page_size);\n\n    /* account for that last guard page */\n\n    region.end -= page_size;\n\n\n\n    /* set guard pages */\n\n    for (i = 0; i < region.n; i++) {\n\n        void *start, *end;\n\n        int rc;\n\n\n\n        tcg_region_bounds(i, &start, &end);\n\n        rc = qemu_mprotect_none(end, page_size);\n\n        g_assert(!rc);\n\n    }\n\n\n\n    /* We do not yet support multiple TCG contexts so allocate the region now */\n\n    {\n\n        bool err = tcg_region_initial_alloc__locked(tcg_ctx);\n\n\n\n        g_assert(!err);\n\n    }\n\n}\n", "idx": 26570}
{"project": "qemu", "commit_id": "1cf0d2b8352a2df35919030b84dbfc713ee9b9be", "target": 0, "func": "static int vt82c686b_ac97_initfn(PCIDevice *dev)\n\n{\n\n    VT686AC97State *s = DO_UPCAST(VT686AC97State, dev, dev);\n\n    uint8_t *pci_conf = s->dev.config;\n\n\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_VIA);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_VIA_AC97);\n\n    pci_config_set_class(pci_conf, PCI_CLASS_MULTIMEDIA_AUDIO);\n\n    pci_config_set_revision(pci_conf, 0x50);\n\n\n\n    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_INVALIDATE |\n\n                 PCI_COMMAND_PARITY);\n\n    pci_set_word(pci_conf + PCI_STATUS, PCI_STATUS_CAP_LIST |\n\n                 PCI_STATUS_DEVSEL_MEDIUM);\n\n    pci_set_long(pci_conf + PCI_INTERRUPT_PIN, 0x03);\n\n\n\n    return 0;\n\n}\n", "idx": 26571}
{"project": "qemu", "commit_id": "10c4c98ab7dc18169b37b76f6ea5e60ebe65222b", "target": 0, "func": "void sysbus_dev_print(Monitor *mon, DeviceState *dev, int indent)\n\n{\n\n    SysBusDevice *s = sysbus_from_qdev(dev);\n\n    int i;\n\n\n\n    for (i = 0; i < s->num_mmio; i++) {\n\n        monitor_printf(mon, \"%*smmio \" TARGET_FMT_plx \"/\" TARGET_FMT_plx \"\\n\",\n\n                       indent, \"\", s->mmio[i].addr, s->mmio[i].size);\n\n    }\n\n}\n", "idx": 26572}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_writev_vmstate(BlockDriverState *bs, QEMUIOVector *qiov, int64_t pos)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    if (!drv) {\n\n        return -ENOMEDIUM;\n\n    } else if (drv->bdrv_save_vmstate) {\n\n        return drv->bdrv_save_vmstate(bs, qiov, pos);\n\n    } else if (bs->file) {\n\n        return bdrv_writev_vmstate(bs->file, qiov, pos);\n\n    }\n\n\n\n    return -ENOTSUP;\n\n}\n", "idx": 26573}
{"project": "qemu", "commit_id": "18e80c55bb6ec17c05ec0ba717ec83933c2bfc07", "target": 0, "func": "static void handle_arg_reserved_va(const char *arg)\n\n{\n\n    char *p;\n\n    int shift = 0;\n\n    reserved_va = strtoul(arg, &p, 0);\n\n    switch (*p) {\n\n    case 'k':\n\n    case 'K':\n\n        shift = 10;\n\n        break;\n\n    case 'M':\n\n        shift = 20;\n\n        break;\n\n    case 'G':\n\n        shift = 30;\n\n        break;\n\n    }\n\n    if (shift) {\n\n        unsigned long unshifted = reserved_va;\n\n        p++;\n\n        reserved_va <<= shift;\n\n        if (((reserved_va >> shift) != unshifted)\n\n#if HOST_LONG_BITS > TARGET_VIRT_ADDR_SPACE_BITS\n\n            || (reserved_va > (1ul << TARGET_VIRT_ADDR_SPACE_BITS))\n\n#endif\n\n            ) {\n\n            fprintf(stderr, \"Reserved virtual address too big\\n\");\n\n            exit(EXIT_FAILURE);\n\n        }\n\n    }\n\n    if (*p) {\n\n        fprintf(stderr, \"Unrecognised -R size suffix '%s'\\n\", p);\n\n        exit(EXIT_FAILURE);\n\n    }\n\n}\n", "idx": 26574}
{"project": "qemu", "commit_id": "ffbb1705a33df8e2fb12b24d96663d63b22eaf8b", "target": 0, "func": "void spapr_events_init(sPAPRMachineState *spapr)\n\n{\n\n    QTAILQ_INIT(&spapr->pending_events);\n\n    spapr->check_exception_irq = xics_spapr_alloc(spapr->xics, 0, false,\n\n                                            &error_fatal);\n\n    spapr->epow_notifier.notify = spapr_powerdown_req;\n\n    qemu_register_powerdown_notifier(&spapr->epow_notifier);\n\n    spapr_rtas_register(RTAS_CHECK_EXCEPTION, \"check-exception\",\n\n                        check_exception);\n\n    spapr_rtas_register(RTAS_EVENT_SCAN, \"event-scan\", event_scan);\n\n}\n", "idx": 26575}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "func": "static int local_statfs(FsContext *s, V9fsPath *fs_path, struct statfs *stbuf)\n\n{\n\n    char buffer[PATH_MAX];\n\n    char *path = fs_path->data;\n\n\n\n    return statfs(rpath(s, path, buffer), stbuf);\n\n}\n", "idx": 26576}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static void bdrv_co_maybe_schedule_bh(BlockAIOCBCoroutine *acb)\n\n{\n\n    acb->need_bh = false;\n\n    if (acb->req.error != -EINPROGRESS) {\n\n        BlockDriverState *bs = acb->common.bs;\n\n\n\n        acb->bh = aio_bh_new(bdrv_get_aio_context(bs), bdrv_co_em_bh, acb);\n\n        qemu_bh_schedule(acb->bh);\n\n    }\n\n}\n", "idx": 26577}
{"project": "qemu", "commit_id": "6ed92b14f610c78aea52b087d6bdc59a3f2de72a", "target": 0, "func": "static void xlnx_zynqmp_init(Object *obj)\n\n{\n\n    XlnxZynqMPState *s = XLNX_ZYNQMP(obj);\n\n    int i;\n\n\n\n    for (i = 0; i < XLNX_ZYNQMP_NUM_APU_CPUS; i++) {\n\n        object_initialize(&s->apu_cpu[i], sizeof(s->apu_cpu[i]),\n\n                          \"cortex-a53-\" TYPE_ARM_CPU);\n\n        object_property_add_child(obj, \"apu-cpu[*]\", OBJECT(&s->apu_cpu[i]),\n\n                                  &error_abort);\n\n    }\n\n\n\n    for (i = 0; i < XLNX_ZYNQMP_NUM_RPU_CPUS; i++) {\n\n        object_initialize(&s->rpu_cpu[i], sizeof(s->rpu_cpu[i]),\n\n                          \"cortex-r5-\" TYPE_ARM_CPU);\n\n        object_property_add_child(obj, \"rpu-cpu[*]\", OBJECT(&s->rpu_cpu[i]),\n\n                                  &error_abort);\n\n    }\n\n\n\n    object_property_add_link(obj, \"ddr-ram\", TYPE_MEMORY_REGION,\n\n                             (Object **)&s->ddr_ram,\n\n                             qdev_prop_allow_set_link_before_realize,\n\n                             OBJ_PROP_LINK_UNREF_ON_RELEASE, &error_abort);\n\n\n\n    object_initialize(&s->gic, sizeof(s->gic), TYPE_ARM_GIC);\n\n    qdev_set_parent_bus(DEVICE(&s->gic), sysbus_get_default());\n\n\n\n    for (i = 0; i < XLNX_ZYNQMP_NUM_GEMS; i++) {\n\n        object_initialize(&s->gem[i], sizeof(s->gem[i]), TYPE_CADENCE_GEM);\n\n        qdev_set_parent_bus(DEVICE(&s->gem[i]), sysbus_get_default());\n\n    }\n\n\n\n    for (i = 0; i < XLNX_ZYNQMP_NUM_UARTS; i++) {\n\n        object_initialize(&s->uart[i], sizeof(s->uart[i]), TYPE_CADENCE_UART);\n\n        qdev_set_parent_bus(DEVICE(&s->uart[i]), sysbus_get_default());\n\n    }\n\n\n\n    object_initialize(&s->sata, sizeof(s->sata), TYPE_SYSBUS_AHCI);\n\n    qdev_set_parent_bus(DEVICE(&s->sata), sysbus_get_default());\n\n\n\n    for (i = 0; i < XLNX_ZYNQMP_NUM_SDHCI; i++) {\n\n        object_initialize(&s->sdhci[i], sizeof(s->sdhci[i]),\n\n                          TYPE_SYSBUS_SDHCI);\n\n        qdev_set_parent_bus(DEVICE(&s->sdhci[i]),\n\n                            sysbus_get_default());\n\n    }\n\n\n\n    for (i = 0; i < XLNX_ZYNQMP_NUM_SPIS; i++) {\n\n        object_initialize(&s->spi[i], sizeof(s->spi[i]),\n\n                          TYPE_XILINX_SPIPS);\n\n        qdev_set_parent_bus(DEVICE(&s->spi[i]), sysbus_get_default());\n\n    }\n\n}\n", "idx": 26578}
{"project": "qemu", "commit_id": "5b4dd0f55ed3027557ed9a6fd89d5aa379122feb", "target": 0, "func": "static int xen_pt_config_reg_init(XenPCIPassthroughState *s,\n\n                                  XenPTRegGroup *reg_grp, XenPTRegInfo *reg)\n\n{\n\n    XenPTReg *reg_entry;\n\n    uint32_t data = 0;\n\n    int rc = 0;\n\n\n\n    reg_entry = g_new0(XenPTReg, 1);\n\n    reg_entry->reg = reg;\n\n\n\n    if (reg->init) {\n\n        uint32_t host_mask, size_mask;\n\n        unsigned int offset;\n\n        uint32_t val;\n\n\n\n        /* initialize emulate register */\n\n        rc = reg->init(s, reg_entry->reg,\n\n                       reg_grp->base_offset + reg->offset, &data);\n\n        if (rc < 0) {\n\n            g_free(reg_entry);\n\n            return rc;\n\n        }\n\n        if (data == XEN_PT_INVALID_REG) {\n\n            /* free unused BAR register entry */\n\n            g_free(reg_entry);\n\n            return 0;\n\n        }\n\n        /* Sync up the data to dev.config */\n\n        offset = reg_grp->base_offset + reg->offset;\n\n        size_mask = 0xFFFFFFFF >> ((4 - reg->size) << 3);\n\n\n\n        switch (reg->size) {\n\n        case 1: rc = xen_host_pci_get_byte(&s->real_device, offset, (uint8_t *)&val);\n\n                break;\n\n        case 2: rc = xen_host_pci_get_word(&s->real_device, offset, (uint16_t *)&val);\n\n                break;\n\n        case 4: rc = xen_host_pci_get_long(&s->real_device, offset, &val);\n\n                break;\n\n        default: assert(1);\n\n        }\n\n        if (rc) {\n\n            /* Serious issues when we cannot read the host values! */\n\n            g_free(reg_entry);\n\n            return rc;\n\n        }\n\n        /* Set bits in emu_mask are the ones we emulate. The dev.config shall\n\n         * contain the emulated view of the guest - therefore we flip the mask\n\n         * to mask out the host values (which dev.config initially has) . */\n\n        host_mask = size_mask & ~reg->emu_mask;\n\n\n\n        if ((data & host_mask) != (val & host_mask)) {\n\n            uint32_t new_val;\n\n\n\n            /* Mask out host (including past size). */\n\n            new_val = val & host_mask;\n\n            /* Merge emulated ones (excluding the non-emulated ones). */\n\n            new_val |= data & host_mask;\n\n            /* Leave intact host and emulated values past the size - even though\n\n             * we do not care as we write per reg->size granularity, but for the\n\n             * logging below lets have the proper value. */\n\n            new_val |= ((val | data)) & ~size_mask;\n\n            XEN_PT_LOG(&s->dev,\"Offset 0x%04x mismatch! Emulated=0x%04x, host=0x%04x, syncing to 0x%04x.\\n\",\n\n                       offset, data, val, new_val);\n\n            val = new_val;\n\n        } else\n\n            val = data;\n\n\n\n        /* This could be just pci_set_long as we don't modify the bits\n\n         * past reg->size, but in case this routine is run in parallel\n\n         * we do not want to over-write other registers. */\n\n        switch (reg->size) {\n\n        case 1: pci_set_byte(s->dev.config + offset, (uint8_t)val);\n\n                break;\n\n        case 2: pci_set_word(s->dev.config + offset, (uint16_t)val);\n\n                break;\n\n        case 4: pci_set_long(s->dev.config + offset, val);\n\n                break;\n\n        default: assert(1);\n\n        }\n\n        /* set register value */\n\n        reg_entry->data = val;\n\n\n\n    }\n\n    /* list add register entry */\n\n    QLIST_INSERT_HEAD(&reg_grp->reg_tbl_list, reg_entry, entries);\n\n\n\n    return 0;\n\n}\n", "idx": 26580}
{"project": "qemu", "commit_id": "b544c1aba8681c2fe5d6715fbd37cf6caf1bc7bb", "target": 1, "func": "static void coroutine_fn send_pending_req(BDRVSheepdogState *s, uint64_t oid)\n\n{\n\n    AIOReq *aio_req;\n\n    SheepdogAIOCB *acb;\n\n\n\n    while ((aio_req = find_pending_req(s, oid)) != NULL) {\n\n        acb = aio_req->aiocb;\n\n        /* move aio_req from pending list to inflight one */\n\n        QLIST_REMOVE(aio_req, aio_siblings);\n\n        QLIST_INSERT_HEAD(&s->inflight_aio_head, aio_req, aio_siblings);\n\n        add_aio_request(s, aio_req, acb->qiov->iov, acb->qiov->niov, false,\n\n                        acb->aiocb_type);\n\n    }\n\n}\n", "idx": 26582}
{"project": "qemu", "commit_id": "b248ede2ef2792d364bd305e5e92e24921c924a8", "target": 1, "func": "if_start(Slirp *slirp)\n\n{\n\n    uint64_t now = qemu_get_clock_ns(rt_clock);\n\n    int requeued = 0;\n\n\tstruct mbuf *ifm, *ifqt;\n\n\n\n\tDEBUG_CALL(\"if_start\");\n\n\n\n\tif (slirp->if_queued == 0)\n\n\t   return; /* Nothing to do */\n\n\n\n again:\n\n        /* check if we can really output */\n\n        if (!slirp_can_output(slirp->opaque))\n\n            return;\n\n\n\n\t/*\n\n\t * See which queue to get next packet from\n\n\t * If there's something in the fastq, select it immediately\n\n\t */\n\n\tif (slirp->if_fastq.ifq_next != &slirp->if_fastq) {\n\n\t\tifm = slirp->if_fastq.ifq_next;\n\n\t} else {\n\n\t\t/* Nothing on fastq, see if next_m is valid */\n\n\t\tif (slirp->next_m != &slirp->if_batchq)\n\n\t\t   ifm = slirp->next_m;\n\n\t\telse\n\n\t\t   ifm = slirp->if_batchq.ifq_next;\n\n\n\n\t\t/* Set which packet to send on next iteration */\n\n\t\tslirp->next_m = ifm->ifq_next;\n\n\t}\n\n\t/* Remove it from the queue */\n\n\tifqt = ifm->ifq_prev;\n\n\tremque(ifm);\n\n\tslirp->if_queued--;\n\n\n\n\t/* If there are more packets for this session, re-queue them */\n\n\tif (ifm->ifs_next != /* ifm->ifs_prev != */ ifm) {\n\n\t\tinsque(ifm->ifs_next, ifqt);\n\n\t\tifs_remque(ifm);\n\n\t}\n\n\n\n\t/* Update so_queued */\n\n\tif (ifm->ifq_so) {\n\n\t\tif (--ifm->ifq_so->so_queued == 0)\n\n\t\t   /* If there's no more queued, reset nqueued */\n\n\t\t   ifm->ifq_so->so_nqueued = 0;\n\n\t}\n\n\n\n        if (ifm->expiration_date < now) {\n\n            /* Expired */\n\n            m_free(ifm);\n\n        } else {\n\n            /* Encapsulate the packet for sending */\n\n            if (if_encap(slirp, ifm)) {\n\n                m_free(ifm);\n\n            } else {\n\n                /* re-queue */\n\n                insque(ifm, ifqt);\n\n                requeued++;\n\n            }\n\n        }\n\n\n\n\tif (slirp->if_queued)\n\n\t   goto again;\n\n\n\n        slirp->if_queued = requeued;\n\n}\n", "idx": 26587}
{"project": "qemu", "commit_id": "f0267ef7115656119bf00ed77857789adc036bda", "target": 0, "func": "void cpu_loop(CPUARMState *env)\n\n{\n\n    CPUState *cs = CPU(arm_env_get_cpu(env));\n\n    int trapnr;\n\n    unsigned int n, insn;\n\n    target_siginfo_t info;\n\n    uint32_t addr;\n\n\n\n    for(;;) {\n\n        cpu_exec_start(cs);\n\n        trapnr = cpu_arm_exec(cs);\n\n        cpu_exec_end(cs);\n\n        switch(trapnr) {\n\n        case EXCP_UDEF:\n\n            {\n\n                TaskState *ts = cs->opaque;\n\n                uint32_t opcode;\n\n                int rc;\n\n\n\n                /* we handle the FPU emulation here, as Linux */\n\n                /* we get the opcode */\n\n                /* FIXME - what to do if get_user() fails? */\n\n                get_user_code_u32(opcode, env->regs[15], env);\n\n\n\n                rc = EmulateAll(opcode, &ts->fpa, env);\n\n                if (rc == 0) { /* illegal instruction */\n\n                    info.si_signo = TARGET_SIGILL;\n\n                    info.si_errno = 0;\n\n                    info.si_code = TARGET_ILL_ILLOPN;\n\n                    info._sifields._sigfault._addr = env->regs[15];\n\n                    queue_signal(env, info.si_signo, &info);\n\n                } else if (rc < 0) { /* FP exception */\n\n                    int arm_fpe=0;\n\n\n\n                    /* translate softfloat flags to FPSR flags */\n\n                    if (-rc & float_flag_invalid)\n\n                      arm_fpe |= BIT_IOC;\n\n                    if (-rc & float_flag_divbyzero)\n\n                      arm_fpe |= BIT_DZC;\n\n                    if (-rc & float_flag_overflow)\n\n                      arm_fpe |= BIT_OFC;\n\n                    if (-rc & float_flag_underflow)\n\n                      arm_fpe |= BIT_UFC;\n\n                    if (-rc & float_flag_inexact)\n\n                      arm_fpe |= BIT_IXC;\n\n\n\n                    FPSR fpsr = ts->fpa.fpsr;\n\n                    //printf(\"fpsr 0x%x, arm_fpe 0x%x\\n\",fpsr,arm_fpe);\n\n\n\n                    if (fpsr & (arm_fpe << 16)) { /* exception enabled? */\n\n                      info.si_signo = TARGET_SIGFPE;\n\n                      info.si_errno = 0;\n\n\n\n                      /* ordered by priority, least first */\n\n                      if (arm_fpe & BIT_IXC) info.si_code = TARGET_FPE_FLTRES;\n\n                      if (arm_fpe & BIT_UFC) info.si_code = TARGET_FPE_FLTUND;\n\n                      if (arm_fpe & BIT_OFC) info.si_code = TARGET_FPE_FLTOVF;\n\n                      if (arm_fpe & BIT_DZC) info.si_code = TARGET_FPE_FLTDIV;\n\n                      if (arm_fpe & BIT_IOC) info.si_code = TARGET_FPE_FLTINV;\n\n\n\n                      info._sifields._sigfault._addr = env->regs[15];\n\n                      queue_signal(env, info.si_signo, &info);\n\n                    } else {\n\n                      env->regs[15] += 4;\n\n                    }\n\n\n\n                    /* accumulate unenabled exceptions */\n\n                    if ((!(fpsr & BIT_IXE)) && (arm_fpe & BIT_IXC))\n\n                      fpsr |= BIT_IXC;\n\n                    if ((!(fpsr & BIT_UFE)) && (arm_fpe & BIT_UFC))\n\n                      fpsr |= BIT_UFC;\n\n                    if ((!(fpsr & BIT_OFE)) && (arm_fpe & BIT_OFC))\n\n                      fpsr |= BIT_OFC;\n\n                    if ((!(fpsr & BIT_DZE)) && (arm_fpe & BIT_DZC))\n\n                      fpsr |= BIT_DZC;\n\n                    if ((!(fpsr & BIT_IOE)) && (arm_fpe & BIT_IOC))\n\n                      fpsr |= BIT_IOC;\n\n                    ts->fpa.fpsr=fpsr;\n\n                } else { /* everything OK */\n\n                    /* increment PC */\n\n                    env->regs[15] += 4;\n\n                }\n\n            }\n\n            break;\n\n        case EXCP_SWI:\n\n        case EXCP_BKPT:\n\n            {\n\n                env->eabi = 1;\n\n                /* system call */\n\n                if (trapnr == EXCP_BKPT) {\n\n                    if (env->thumb) {\n\n                        /* FIXME - what to do if get_user() fails? */\n\n                        get_user_code_u16(insn, env->regs[15], env);\n\n                        n = insn & 0xff;\n\n                        env->regs[15] += 2;\n\n                    } else {\n\n                        /* FIXME - what to do if get_user() fails? */\n\n                        get_user_code_u32(insn, env->regs[15], env);\n\n                        n = (insn & 0xf) | ((insn >> 4) & 0xff0);\n\n                        env->regs[15] += 4;\n\n                    }\n\n                } else {\n\n                    if (env->thumb) {\n\n                        /* FIXME - what to do if get_user() fails? */\n\n                        get_user_code_u16(insn, env->regs[15] - 2, env);\n\n                        n = insn & 0xff;\n\n                    } else {\n\n                        /* FIXME - what to do if get_user() fails? */\n\n                        get_user_code_u32(insn, env->regs[15] - 4, env);\n\n                        n = insn & 0xffffff;\n\n                    }\n\n                }\n\n\n\n                if (n == ARM_NR_cacheflush) {\n\n                    /* nop */\n\n                } else if (n == ARM_NR_semihosting\n\n                           || n == ARM_NR_thumb_semihosting) {\n\n                    env->regs[0] = do_arm_semihosting (env);\n\n                } else if (n == 0 || n >= ARM_SYSCALL_BASE || env->thumb) {\n\n                    /* linux syscall */\n\n                    if (env->thumb || n == 0) {\n\n                        n = env->regs[7];\n\n                    } else {\n\n                        n -= ARM_SYSCALL_BASE;\n\n                        env->eabi = 0;\n\n                    }\n\n                    if ( n > ARM_NR_BASE) {\n\n                        switch (n) {\n\n                        case ARM_NR_cacheflush:\n\n                            /* nop */\n\n                            break;\n\n                        case ARM_NR_set_tls:\n\n                            cpu_set_tls(env, env->regs[0]);\n\n                            env->regs[0] = 0;\n\n                            break;\n\n                        case ARM_NR_breakpoint:\n\n                            env->regs[15] -= env->thumb ? 2 : 4;\n\n                            goto excp_debug;\n\n                        default:\n\n                            gemu_log(\"qemu: Unsupported ARM syscall: 0x%x\\n\",\n\n                                     n);\n\n                            env->regs[0] = -TARGET_ENOSYS;\n\n                            break;\n\n                        }\n\n                    } else {\n\n                        env->regs[0] = do_syscall(env,\n\n                                                  n,\n\n                                                  env->regs[0],\n\n                                                  env->regs[1],\n\n                                                  env->regs[2],\n\n                                                  env->regs[3],\n\n                                                  env->regs[4],\n\n                                                  env->regs[5],\n\n                                                  0, 0);\n\n                    }\n\n                } else {\n\n                    goto error;\n\n                }\n\n            }\n\n            break;\n\n        case EXCP_INTERRUPT:\n\n            /* just indicate that signals should be handled asap */\n\n            break;\n\n        case EXCP_STREX:\n\n            if (!do_strex(env)) {\n\n                break;\n\n            }\n\n            /* fall through for segv */\n\n        case EXCP_PREFETCH_ABORT:\n\n        case EXCP_DATA_ABORT:\n\n            addr = env->exception.vaddress;\n\n            {\n\n                info.si_signo = TARGET_SIGSEGV;\n\n                info.si_errno = 0;\n\n                /* XXX: check env->error_code */\n\n                info.si_code = TARGET_SEGV_MAPERR;\n\n                info._sifields._sigfault._addr = addr;\n\n                queue_signal(env, info.si_signo, &info);\n\n            }\n\n            break;\n\n        case EXCP_DEBUG:\n\n        excp_debug:\n\n            {\n\n                int sig;\n\n\n\n                sig = gdb_handlesig(cs, TARGET_SIGTRAP);\n\n                if (sig)\n\n                  {\n\n                    info.si_signo = sig;\n\n                    info.si_errno = 0;\n\n                    info.si_code = TARGET_TRAP_BRKPT;\n\n                    queue_signal(env, info.si_signo, &info);\n\n                  }\n\n            }\n\n            break;\n\n        case EXCP_KERNEL_TRAP:\n\n            if (do_kernel_trap(env))\n\n              goto error;\n\n            break;\n\n        case EXCP_YIELD:\n\n            /* nothing to do here for user-mode, just resume guest code */\n\n            break;\n\n        default:\n\n        error:\n\n            EXCP_DUMP(env, \"qemu: unhandled CPU exception 0x%x - aborting\\n\", trapnr);\n\n            abort();\n\n        }\n\n        process_pending_signals(env);\n\n    }\n\n}\n", "idx": 26592}
{"project": "qemu", "commit_id": "65e7545ea3c65a6468fb59418a6dbe66ef71d6d1", "target": 0, "func": "static void sunkbd_event(void *opaque, int ch)\n\n{\n\n    ChannelState *s = opaque;\n\n    int release = ch & 0x80;\n\n\n\n    trace_escc_sunkbd_event_in(ch);\n\n    switch (ch) {\n\n    case 58: // Caps lock press\n\n        s->caps_lock_mode ^= 1;\n\n        if (s->caps_lock_mode == 2)\n\n            return; // Drop second press\n\n        break;\n\n    case 69: // Num lock press\n\n        s->num_lock_mode ^= 1;\n\n        if (s->num_lock_mode == 2)\n\n            return; // Drop second press\n\n        break;\n\n    case 186: // Caps lock release\n\n        s->caps_lock_mode ^= 2;\n\n        if (s->caps_lock_mode == 3)\n\n            return; // Drop first release\n\n        break;\n\n    case 197: // Num lock release\n\n        s->num_lock_mode ^= 2;\n\n        if (s->num_lock_mode == 3)\n\n            return; // Drop first release\n\n        break;\n\n    case 0xe0:\n\n        s->e0_mode = 1;\n\n        return;\n\n    default:\n\n        break;\n\n    }\n\n    if (s->e0_mode) {\n\n        s->e0_mode = 0;\n\n        ch = e0_keycodes[ch & 0x7f];\n\n    } else {\n\n        ch = keycodes[ch & 0x7f];\n\n    }\n\n    trace_escc_sunkbd_event_out(ch);\n\n    put_queue(s, ch | release);\n\n}\n", "idx": 26593}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static void omap_pwl_update(struct omap_pwl_s *s)\n\n{\n\n    int output = (s->clk && s->enable) ? s->level : 0;\n\n\n\n    if (output != s->output) {\n\n        s->output = output;\n\n        printf(\"%s: Backlight now at %i/256\\n\", __FUNCTION__, output);\n\n    }\n\n}\n", "idx": 26594}
{"project": "qemu", "commit_id": "c9fc50839863f05545caca92bb9fbead8b1c91bd", "target": 0, "func": "static void dump_human_image_check(ImageCheck *check)\n\n{\n\n    if (!(check->corruptions || check->leaks || check->check_errors)) {\n\n        printf(\"No errors were found on the image.\\n\");\n\n    } else {\n\n        if (check->corruptions) {\n\n            printf(\"\\n%\" PRId64 \" errors were found on the image.\\n\"\n\n                \"Data may be corrupted, or further writes to the image \"\n\n                \"may corrupt it.\\n\",\n\n                check->corruptions);\n\n        }\n\n\n\n        if (check->leaks) {\n\n            printf(\"\\n%\" PRId64 \" leaked clusters were found on the image.\\n\"\n\n                \"This means waste of disk space, but no harm to data.\\n\",\n\n                check->leaks);\n\n        }\n\n\n\n        if (check->check_errors) {\n\n            printf(\"\\n%\" PRId64 \" internal errors have occurred during the check.\\n\",\n\n                check->check_errors);\n\n        }\n\n    }\n\n\n\n    if (check->total_clusters != 0 && check->allocated_clusters != 0) {\n\n        printf(\"%\" PRId64 \"/%\" PRId64 \"= %0.2f%% allocated, %0.2f%% fragmented\\n\",\n\n        check->allocated_clusters, check->total_clusters,\n\n        check->allocated_clusters * 100.0 / check->total_clusters,\n\n        check->fragmented_clusters * 100.0 / check->allocated_clusters);\n\n    }\n\n\n\n    if (check->image_end_offset) {\n\n        printf(\"Image end offset: %\" PRId64 \"\\n\", check->image_end_offset);\n\n    }\n\n}\n", "idx": 26595}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void free_note_info(struct elf_note_info *info)\n\n{\n\n    struct elf_thread_status *ets;\n\n\n\n    while (!TAILQ_EMPTY(&info->thread_list)) {\n\n        ets = TAILQ_FIRST(&info->thread_list);\n\n        TAILQ_REMOVE(&info->thread_list, ets, ets_link);\n\n        qemu_free(ets);\n\n    }\n\n\n\n    qemu_free(info->prstatus);\n\n    qemu_free(info->psinfo);\n\n    qemu_free(info->notes);\n\n}\n", "idx": 26596}
{"project": "qemu", "commit_id": "17e2377abf16c3951d7d34521ceade4d7dc31d01", "target": 0, "func": "void *get_mmap_addr(unsigned long size)\n\n{\n\n    return NULL;\n\n}\n", "idx": 26597}
{"project": "qemu", "commit_id": "cc2212c2f851291929becc3f4fd153d05ca4c54a", "target": 0, "func": "uint32_t HELPER(neon_narrow_sat_s32)(CPUState *env, uint64_t x)\n\n{\n\n    if ((int64_t)x != (int32_t)x) {\n\n        SET_QC();\n\n        return (x >> 63) ^ 0x7fffffff;\n\n    }\n\n    return x;\n\n}\n", "idx": 26598}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "float32 int32_to_float32( int32 a STATUS_PARAM )\n\n{\n\n    flag zSign;\n\n\n\n    if ( a == 0 ) return 0;\n\n    if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );\n\n    zSign = ( a < 0 );\n\n    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );\n\n\n\n}\n", "idx": 26599}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "static int kvm_get_msr(CPUState *env, struct kvm_msr_entry *msrs, int n)\n\n{\n\n    struct kvm_msrs *kmsrs = qemu_malloc(sizeof *kmsrs + n * sizeof *msrs);\n\n    int r;\n\n\n\n    kmsrs->nmsrs = n;\n\n    memcpy(kmsrs->entries, msrs, n * sizeof *msrs);\n\n    r = kvm_vcpu_ioctl(env, KVM_GET_MSRS, kmsrs);\n\n    memcpy(msrs, kmsrs->entries, n * sizeof *msrs);\n\n    free(kmsrs);\n\n    return r;\n\n}\n", "idx": 26600}
{"project": "qemu", "commit_id": "29396ed9acfaee9936377ddece4b05452b417861", "target": 0, "func": "static void amdvi_realize(DeviceState *dev, Error **err)\n\n{\n\n    int ret = 0;\n\n    AMDVIState *s = AMD_IOMMU_DEVICE(dev);\n\n    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(dev);\n\n    MachineState *ms = MACHINE(qdev_get_machine());\n\n    MachineClass *mc = MACHINE_GET_CLASS(ms);\n\n    PCMachineState *pcms =\n\n        PC_MACHINE(object_dynamic_cast(OBJECT(ms), TYPE_PC_MACHINE));\n\n    PCIBus *bus;\n\n\n\n    if (!pcms) {\n\n        error_setg(err, \"Machine-type '%s' not supported by amd-iommu\",\n\n                   mc->name);\n\n        return;\n\n    }\n\n\n\n    bus = pcms->bus;\n\n    s->iotlb = g_hash_table_new_full(amdvi_uint64_hash,\n\n                                     amdvi_uint64_equal, g_free, g_free);\n\n\n\n    /* This device should take care of IOMMU PCI properties */\n\n    x86_iommu->type = TYPE_AMD;\n\n    qdev_set_parent_bus(DEVICE(&s->pci), &bus->qbus);\n\n    object_property_set_bool(OBJECT(&s->pci), true, \"realized\", err);\n\n    ret = pci_add_capability(&s->pci.dev, AMDVI_CAPAB_ID_SEC, 0,\n\n                                         AMDVI_CAPAB_SIZE, err);\n\n    if (ret < 0) {\n\n        return;\n\n    }\n\n    s->capab_offset = ret;\n\n\n\n    ret = pci_add_capability(&s->pci.dev, PCI_CAP_ID_MSI, 0,\n\n                             AMDVI_CAPAB_REG_SIZE, err);\n\n    if (ret < 0) {\n\n        return;\n\n    }\n\n    ret = pci_add_capability(&s->pci.dev, PCI_CAP_ID_HT, 0,\n\n                             AMDVI_CAPAB_REG_SIZE, err);\n\n    if (ret < 0) {\n\n        return;\n\n    }\n\n\n\n    /* set up MMIO */\n\n    memory_region_init_io(&s->mmio, OBJECT(s), &mmio_mem_ops, s, \"amdvi-mmio\",\n\n                          AMDVI_MMIO_SIZE);\n\n\n\n    sysbus_init_mmio(SYS_BUS_DEVICE(s), &s->mmio);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(s), 0, AMDVI_BASE_ADDR);\n\n    pci_setup_iommu(bus, amdvi_host_dma_iommu, s);\n\n    s->devid = object_property_get_int(OBJECT(&s->pci), \"addr\", err);\n\n    msi_init(&s->pci.dev, 0, 1, true, false, err);\n\n    amdvi_init(s);\n\n}\n", "idx": 26601}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "void helper_rdmsr(void)\n\n{\n\n    uint64_t val;\n\n\n\n    helper_svm_check_intercept_param(SVM_EXIT_MSR, 0);\n\n\n\n    switch((uint32_t)ECX) {\n\n    case MSR_IA32_SYSENTER_CS:\n\n        val = env->sysenter_cs;\n\n        break;\n\n    case MSR_IA32_SYSENTER_ESP:\n\n        val = env->sysenter_esp;\n\n        break;\n\n    case MSR_IA32_SYSENTER_EIP:\n\n        val = env->sysenter_eip;\n\n        break;\n\n    case MSR_IA32_APICBASE:\n\n        val = cpu_get_apic_base(env);\n\n        break;\n\n    case MSR_EFER:\n\n        val = env->efer;\n\n        break;\n\n    case MSR_STAR:\n\n        val = env->star;\n\n        break;\n\n    case MSR_PAT:\n\n        val = env->pat;\n\n        break;\n\n    case MSR_VM_HSAVE_PA:\n\n        val = env->vm_hsave;\n\n        break;\n\n    case MSR_IA32_PERF_STATUS:\n\n        /* tsc_increment_by_tick */\n\n        val = 1000ULL;\n\n        /* CPU multiplier */\n\n        val |= (((uint64_t)4ULL) << 40);\n\n        break;\n\n#ifdef TARGET_X86_64\n\n    case MSR_LSTAR:\n\n        val = env->lstar;\n\n        break;\n\n    case MSR_CSTAR:\n\n        val = env->cstar;\n\n        break;\n\n    case MSR_FMASK:\n\n        val = env->fmask;\n\n        break;\n\n    case MSR_FSBASE:\n\n        val = env->segs[R_FS].base;\n\n        break;\n\n    case MSR_GSBASE:\n\n        val = env->segs[R_GS].base;\n\n        break;\n\n    case MSR_KERNELGSBASE:\n\n        val = env->kernelgsbase;\n\n        break;\n\n#endif\n\n#ifdef CONFIG_KQEMU\n\n    case MSR_QPI_COMMBASE:\n\n        if (env->kqemu_enabled) {\n\n            val = kqemu_comm_base;\n\n        } else {\n\n            val = 0;\n\n        }\n\n        break;\n\n#endif\n\n    case MSR_MTRRphysBase(0):\n\n    case MSR_MTRRphysBase(1):\n\n    case MSR_MTRRphysBase(2):\n\n    case MSR_MTRRphysBase(3):\n\n    case MSR_MTRRphysBase(4):\n\n    case MSR_MTRRphysBase(5):\n\n    case MSR_MTRRphysBase(6):\n\n    case MSR_MTRRphysBase(7):\n\n        val = env->mtrr_var[((uint32_t)ECX - MSR_MTRRphysBase(0)) / 2].base;\n\n        break;\n\n    case MSR_MTRRphysMask(0):\n\n    case MSR_MTRRphysMask(1):\n\n    case MSR_MTRRphysMask(2):\n\n    case MSR_MTRRphysMask(3):\n\n    case MSR_MTRRphysMask(4):\n\n    case MSR_MTRRphysMask(5):\n\n    case MSR_MTRRphysMask(6):\n\n    case MSR_MTRRphysMask(7):\n\n        val = env->mtrr_var[((uint32_t)ECX - MSR_MTRRphysMask(0)) / 2].mask;\n\n        break;\n\n    case MSR_MTRRfix64K_00000:\n\n        val = env->mtrr_fixed[0];\n\n        break;\n\n    case MSR_MTRRfix16K_80000:\n\n    case MSR_MTRRfix16K_A0000:\n\n        val = env->mtrr_fixed[(uint32_t)ECX - MSR_MTRRfix16K_80000 + 1];\n\n        break;\n\n    case MSR_MTRRfix4K_C0000:\n\n    case MSR_MTRRfix4K_C8000:\n\n    case MSR_MTRRfix4K_D0000:\n\n    case MSR_MTRRfix4K_D8000:\n\n    case MSR_MTRRfix4K_E0000:\n\n    case MSR_MTRRfix4K_E8000:\n\n    case MSR_MTRRfix4K_F0000:\n\n    case MSR_MTRRfix4K_F8000:\n\n        val = env->mtrr_fixed[(uint32_t)ECX - MSR_MTRRfix4K_C0000 + 3];\n\n        break;\n\n    case MSR_MTRRdefType:\n\n        val = env->mtrr_deftype;\n\n        break;\n\n    case MSR_MTRRcap:\n\n        if (env->cpuid_features & CPUID_MTRR)\n\n            val = MSR_MTRRcap_VCNT | MSR_MTRRcap_FIXRANGE_SUPPORT | MSR_MTRRcap_WC_SUPPORTED;\n\n        else\n\n            /* XXX: exception ? */\n\n            val = 0;\n\n        break;\n\n    case MSR_MCG_CAP:\n\n        val = env->mcg_cap;\n\n        break;\n\n    case MSR_MCG_CTL:\n\n        if (env->mcg_cap & MCG_CTL_P)\n\n            val = env->mcg_ctl;\n\n        else\n\n            val = 0;\n\n        break;\n\n    case MSR_MCG_STATUS:\n\n        val = env->mcg_status;\n\n        break;\n\n    default:\n\n        if ((uint32_t)ECX >= MSR_MC0_CTL\n\n            && (uint32_t)ECX < MSR_MC0_CTL + (4 * env->mcg_cap & 0xff)) {\n\n            uint32_t offset = (uint32_t)ECX - MSR_MC0_CTL;\n\n            val = env->mce_banks[offset];\n\n            break;\n\n        }\n\n        /* XXX: exception ? */\n\n        val = 0;\n\n        break;\n\n    }\n\n    EAX = (uint32_t)(val);\n\n    EDX = (uint32_t)(val >> 32);\n\n}\n", "idx": 26603}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void AUD_del_capture (CaptureVoiceOut *cap, void *cb_opaque)\n\n{\n\n    struct capture_callback *cb;\n\n\n\n    for (cb = cap->cb_head.lh_first; cb; cb = cb->entries.le_next) {\n\n        if (cb->opaque == cb_opaque) {\n\n            cb->ops.destroy (cb_opaque);\n\n            LIST_REMOVE (cb, entries);\n\n            qemu_free (cb);\n\n\n\n            if (!cap->cb_head.lh_first) {\n\n                SWVoiceOut *sw = cap->hw.sw_head.lh_first, *sw1;\n\n\n\n                while (sw) {\n\n                    SWVoiceCap *sc = (SWVoiceCap *) sw;\n\n#ifdef DEBUG_CAPTURE\n\n                    dolog (\"freeing %s\\n\", sw->name);\n\n#endif\n\n\n\n                    sw1 = sw->entries.le_next;\n\n                    if (sw->rate) {\n\n                        st_rate_stop (sw->rate);\n\n                        sw->rate = NULL;\n\n                    }\n\n                    LIST_REMOVE (sw, entries);\n\n                    LIST_REMOVE (sc, entries);\n\n                    qemu_free (sc);\n\n                    sw = sw1;\n\n                }\n\n                LIST_REMOVE (cap, entries);\n\n                qemu_free (cap);\n\n            }\n\n            return;\n\n        }\n\n    }\n\n}\n", "idx": 26604}
{"project": "qemu", "commit_id": "ef76dc59fa5203d146a2acf85a0ad5a5971a4824", "target": 0, "func": "START_TEST(unterminated_dict)\n\n{\n\n    QObject *obj = qobject_from_json(\"{'abc':32\");\n\n    fail_unless(obj == NULL);\n\n}\n", "idx": 26605}
{"project": "qemu", "commit_id": "cfdf2c40577ed99bb19cdc05d0537e2808d77a78", "target": 0, "func": "static void do_balloon(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    int value = qdict_get_int(qdict, \"value\");\n\n    ram_addr_t target = value;\n\n    qemu_balloon(target << 20);\n\n}\n", "idx": 26606}
{"project": "qemu", "commit_id": "e57ca75ce3b2bd33102573a8c0555d62e1bcfceb", "target": 0, "func": "static void spapr_cpu_reset(void *opaque)\n\n{\n\n    sPAPRMachineState *spapr = SPAPR_MACHINE(qdev_get_machine());\n\n    PowerPCCPU *cpu = opaque;\n\n    CPUState *cs = CPU(cpu);\n\n    CPUPPCState *env = &cpu->env;\n\n\n\n    cpu_reset(cs);\n\n\n\n    /* All CPUs start halted.  CPU0 is unhalted from the machine level\n\n     * reset code and the rest are explicitly started up by the guest\n\n     * using an RTAS call */\n\n    cs->halted = 1;\n\n\n\n    env->spr[SPR_HIOR] = 0;\n\n\n\n    ppc_hash64_set_external_hpt(cpu, spapr->htab, spapr->htab_shift,\n\n                                &error_fatal);\n\n}\n", "idx": 26607}
{"project": "qemu", "commit_id": "efb9ee024845982a210bfe48a73298846adfe9da", "target": 0, "func": "static int scsi_handle_rw_error(SCSIDiskReq *r, int error, int type)\n\n{\n\n    int is_read = (type == SCSI_REQ_STATUS_RETRY_READ);\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    BlockErrorAction action = bdrv_get_on_error(s->bs, is_read);\n\n\n\n    if (action == BLOCK_ERR_IGNORE) {\n\n        bdrv_mon_event(s->bs, BDRV_ACTION_IGNORE, is_read);\n\n        return 0;\n\n    }\n\n\n\n    if ((error == ENOSPC && action == BLOCK_ERR_STOP_ENOSPC)\n\n            || action == BLOCK_ERR_STOP_ANY) {\n\n\n\n        type &= SCSI_REQ_STATUS_RETRY_TYPE_MASK;\n\n        r->status |= SCSI_REQ_STATUS_RETRY | type;\n\n\n\n        bdrv_mon_event(s->bs, BDRV_ACTION_STOP, is_read);\n\n        vm_stop(VMSTOP_DISKFULL);\n\n    } else {\n\n        if (type == SCSI_REQ_STATUS_RETRY_READ) {\n\n            scsi_req_data(&r->req, 0);\n\n        }\n\n        if (error == ENOMEM) {\n\n            scsi_command_complete(r, CHECK_CONDITION,\n\n                                  SENSE_CODE(TARGET_FAILURE));\n\n        } else {\n\n            scsi_command_complete(r, CHECK_CONDITION,\n\n                                  SENSE_CODE(IO_ERROR));\n\n        }\n\n        bdrv_mon_event(s->bs, BDRV_ACTION_REPORT, is_read);\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 26608}
{"project": "qemu", "commit_id": "8297be80f7cf71e09617669a8bd8b2836dcfd4c3", "target": 0, "func": "void xen_map_cache_init(phys_offset_to_gaddr_t f, void *opaque)\n\n{\n\n    unsigned long size;\n\n    struct rlimit rlimit_as;\n\n\n\n    mapcache = g_malloc0(sizeof (MapCache));\n\n\n\n    mapcache->phys_offset_to_gaddr = f;\n\n    mapcache->opaque = opaque;\n\n    qemu_mutex_init(&mapcache->lock);\n\n\n\n    QTAILQ_INIT(&mapcache->locked_entries);\n\n\n\n    if (geteuid() == 0) {\n\n        rlimit_as.rlim_cur = RLIM_INFINITY;\n\n        rlimit_as.rlim_max = RLIM_INFINITY;\n\n        mapcache->max_mcache_size = MCACHE_MAX_SIZE;\n\n    } else {\n\n        getrlimit(RLIMIT_AS, &rlimit_as);\n\n        rlimit_as.rlim_cur = rlimit_as.rlim_max;\n\n\n\n        if (rlimit_as.rlim_max != RLIM_INFINITY) {\n\n            fprintf(stderr, \"Warning: QEMU's maximum size of virtual\"\n\n                    \" memory is not infinity.\\n\");\n\n        }\n\n        if (rlimit_as.rlim_max < MCACHE_MAX_SIZE + NON_MCACHE_MEMORY_SIZE) {\n\n            mapcache->max_mcache_size = rlimit_as.rlim_max -\n\n                NON_MCACHE_MEMORY_SIZE;\n\n        } else {\n\n            mapcache->max_mcache_size = MCACHE_MAX_SIZE;\n\n        }\n\n    }\n\n\n\n    setrlimit(RLIMIT_AS, &rlimit_as);\n\n\n\n    mapcache->nr_buckets =\n\n        (((mapcache->max_mcache_size >> XC_PAGE_SHIFT) +\n\n          (1UL << (MCACHE_BUCKET_SHIFT - XC_PAGE_SHIFT)) - 1) >>\n\n         (MCACHE_BUCKET_SHIFT - XC_PAGE_SHIFT));\n\n\n\n    size = mapcache->nr_buckets * sizeof (MapCacheEntry);\n\n    size = (size + XC_PAGE_SIZE - 1) & ~(XC_PAGE_SIZE - 1);\n\n    DPRINTF(\"%s, nr_buckets = %lx size %lu\\n\", __func__,\n\n            mapcache->nr_buckets, size);\n\n    mapcache->entry = g_malloc0(size);\n\n}\n", "idx": 26609}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "FWCfgState *pc_memory_init(PCMachineState *pcms,\n\n                           MemoryRegion *system_memory,\n\n                           MemoryRegion *rom_memory,\n\n                           MemoryRegion **ram_memory,\n\n                           PcGuestInfo *guest_info)\n\n{\n\n    int linux_boot, i;\n\n    MemoryRegion *ram, *option_rom_mr;\n\n    MemoryRegion *ram_below_4g, *ram_above_4g;\n\n    FWCfgState *fw_cfg;\n\n    MachineState *machine = MACHINE(pcms);\n\n\n\n    assert(machine->ram_size == pcms->below_4g_mem_size +\n\n                                pcms->above_4g_mem_size);\n\n\n\n    linux_boot = (machine->kernel_filename != NULL);\n\n\n\n    /* Allocate RAM.  We allocate it as a single memory region and use\n\n     * aliases to address portions of it, mostly for backwards compatibility\n\n     * with older qemus that used qemu_ram_alloc().\n\n     */\n\n    ram = g_malloc(sizeof(*ram));\n\n    memory_region_allocate_system_memory(ram, NULL, \"pc.ram\",\n\n                                         machine->ram_size);\n\n    *ram_memory = ram;\n\n    ram_below_4g = g_malloc(sizeof(*ram_below_4g));\n\n    memory_region_init_alias(ram_below_4g, NULL, \"ram-below-4g\", ram,\n\n                             0, pcms->below_4g_mem_size);\n\n    memory_region_add_subregion(system_memory, 0, ram_below_4g);\n\n    e820_add_entry(0, pcms->below_4g_mem_size, E820_RAM);\n\n    if (pcms->above_4g_mem_size > 0) {\n\n        ram_above_4g = g_malloc(sizeof(*ram_above_4g));\n\n        memory_region_init_alias(ram_above_4g, NULL, \"ram-above-4g\", ram,\n\n                                 pcms->below_4g_mem_size,\n\n                                 pcms->above_4g_mem_size);\n\n        memory_region_add_subregion(system_memory, 0x100000000ULL,\n\n                                    ram_above_4g);\n\n        e820_add_entry(0x100000000ULL, pcms->above_4g_mem_size, E820_RAM);\n\n    }\n\n\n\n    if (!guest_info->has_reserved_memory &&\n\n        (machine->ram_slots ||\n\n         (machine->maxram_size > machine->ram_size))) {\n\n        MachineClass *mc = MACHINE_GET_CLASS(machine);\n\n\n\n        error_report(\"\\\"-memory 'slots|maxmem'\\\" is not supported by: %s\",\n\n                     mc->name);\n\n        exit(EXIT_FAILURE);\n\n    }\n\n\n\n    /* initialize hotplug memory address space */\n\n    if (guest_info->has_reserved_memory &&\n\n        (machine->ram_size < machine->maxram_size)) {\n\n        ram_addr_t hotplug_mem_size =\n\n            machine->maxram_size - machine->ram_size;\n\n\n\n        if (machine->ram_slots > ACPI_MAX_RAM_SLOTS) {\n\n            error_report(\"unsupported amount of memory slots: %\"PRIu64,\n\n                         machine->ram_slots);\n\n            exit(EXIT_FAILURE);\n\n        }\n\n\n\n        if (QEMU_ALIGN_UP(machine->maxram_size,\n\n                          TARGET_PAGE_SIZE) != machine->maxram_size) {\n\n            error_report(\"maximum memory size must by aligned to multiple of \"\n\n                         \"%d bytes\", TARGET_PAGE_SIZE);\n\n            exit(EXIT_FAILURE);\n\n        }\n\n\n\n        pcms->hotplug_memory.base =\n\n            ROUND_UP(0x100000000ULL + pcms->above_4g_mem_size, 1ULL << 30);\n\n\n\n        if (pcms->enforce_aligned_dimm) {\n\n            /* size hotplug region assuming 1G page max alignment per slot */\n\n            hotplug_mem_size += (1ULL << 30) * machine->ram_slots;\n\n        }\n\n\n\n        if ((pcms->hotplug_memory.base + hotplug_mem_size) <\n\n            hotplug_mem_size) {\n\n            error_report(\"unsupported amount of maximum memory: \" RAM_ADDR_FMT,\n\n                         machine->maxram_size);\n\n            exit(EXIT_FAILURE);\n\n        }\n\n\n\n        memory_region_init(&pcms->hotplug_memory.mr, OBJECT(pcms),\n\n                           \"hotplug-memory\", hotplug_mem_size);\n\n        memory_region_add_subregion(system_memory, pcms->hotplug_memory.base,\n\n                                    &pcms->hotplug_memory.mr);\n\n    }\n\n\n\n    /* Initialize PC system firmware */\n\n    pc_system_firmware_init(rom_memory, guest_info->isapc_ram_fw);\n\n\n\n    option_rom_mr = g_malloc(sizeof(*option_rom_mr));\n\n    memory_region_init_ram(option_rom_mr, NULL, \"pc.rom\", PC_ROM_SIZE,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(option_rom_mr);\n\n    memory_region_add_subregion_overlap(rom_memory,\n\n                                        PC_ROM_MIN_VGA,\n\n                                        option_rom_mr,\n\n                                        1);\n\n\n\n    fw_cfg = bochs_bios_init();\n\n    rom_set_fw(fw_cfg);\n\n\n\n    if (guest_info->has_reserved_memory && pcms->hotplug_memory.base) {\n\n        uint64_t *val = g_malloc(sizeof(*val));\n\n        PCMachineClass *pcmc = PC_MACHINE_GET_CLASS(pcms);\n\n        uint64_t res_mem_end = pcms->hotplug_memory.base;\n\n\n\n        if (!pcmc->broken_reserved_end) {\n\n            res_mem_end += memory_region_size(&pcms->hotplug_memory.mr);\n\n        }\n\n        *val = cpu_to_le64(ROUND_UP(res_mem_end, 0x1ULL << 30));\n\n        fw_cfg_add_file(fw_cfg, \"etc/reserved-memory-end\", val, sizeof(*val));\n\n    }\n\n\n\n    if (linux_boot) {\n\n        load_linux(pcms, fw_cfg);\n\n    }\n\n\n\n    for (i = 0; i < nb_option_roms; i++) {\n\n        rom_add_option(option_rom[i].name, option_rom[i].bootindex);\n\n    }\n\n    guest_info->fw_cfg = fw_cfg;\n\n    return fw_cfg;\n\n}\n", "idx": 26616}
{"project": "qemu", "commit_id": "5e5a94b60518002e8ecc7afa78a9e7565b23e38f", "target": 1, "func": "static int coroutine_fn bdrv_aligned_pwritev(BlockDriverState *bs,\n\n    BdrvTrackedRequest *req, int64_t offset, unsigned int bytes,\n\n    QEMUIOVector *qiov, int flags)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    bool waited;\n\n    int ret;\n\n\n\n    int64_t sector_num = offset >> BDRV_SECTOR_BITS;\n\n    unsigned int nb_sectors = bytes >> BDRV_SECTOR_BITS;\n\n\n\n    assert((offset & (BDRV_SECTOR_SIZE - 1)) == 0);\n\n    assert((bytes & (BDRV_SECTOR_SIZE - 1)) == 0);\n\n    assert(!qiov || bytes == qiov->size);\n\n\n\n    waited = wait_serialising_requests(req);\n\n    assert(!waited || !req->serialising);\n\n    assert(req->overlap_offset <= offset);\n\n    assert(offset + bytes <= req->overlap_offset + req->overlap_bytes);\n\n\n\n    ret = notifier_with_return_list_notify(&bs->before_write_notifiers, req);\n\n\n\n    if (!ret && bs->detect_zeroes != BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF &&\n\n        !(flags & BDRV_REQ_ZERO_WRITE) && drv->bdrv_co_write_zeroes &&\n\n        qemu_iovec_is_zero(qiov)) {\n\n        flags |= BDRV_REQ_ZERO_WRITE;\n\n        if (bs->detect_zeroes == BLOCKDEV_DETECT_ZEROES_OPTIONS_UNMAP) {\n\n            flags |= BDRV_REQ_MAY_UNMAP;\n\n        }\n\n    }\n\n\n\n    if (ret < 0) {\n\n        /* Do nothing, write notifier decided to fail this request */\n\n    } else if (flags & BDRV_REQ_ZERO_WRITE) {\n\n        BLKDBG_EVENT(bs, BLKDBG_PWRITEV_ZERO);\n\n        ret = bdrv_co_do_write_zeroes(bs, sector_num, nb_sectors, flags);\n\n    } else {\n\n        BLKDBG_EVENT(bs, BLKDBG_PWRITEV);\n\n        ret = drv->bdrv_co_writev(bs, sector_num, nb_sectors, qiov);\n\n    }\n\n    BLKDBG_EVENT(bs, BLKDBG_PWRITEV_DONE);\n\n\n\n    if (ret == 0 && !bs->enable_write_cache) {\n\n        ret = bdrv_co_flush(bs);\n\n    }\n\n\n\n    bdrv_set_dirty(bs, sector_num, nb_sectors);\n\n\n\n    if (bs->stats.wr_highest_sector < sector_num + nb_sectors - 1) {\n\n        bs->stats.wr_highest_sector = sector_num + nb_sectors - 1;\n\n    }\n\n    if (bs->growable && ret >= 0) {\n\n        bs->total_sectors = MAX(bs->total_sectors, sector_num + nb_sectors);\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 26617}
{"project": "qemu", "commit_id": "1d2acc3162d9c7772510c973f446353fbdd1f9a8", "target": 1, "func": "static void migrate_fd_cancel(MigrationState *s)\n{\n    int old_state ;\n    QEMUFile *f = migrate_get_current()->to_dst_file;\n    trace_migrate_fd_cancel();\n    if (s->rp_state.from_dst_file) {\n        /* shutdown the rp socket, so causing the rp thread to shutdown */\n        qemu_file_shutdown(s->rp_state.from_dst_file);\n    do {\n        old_state = s->state;\n        if (!migration_is_setup_or_active(old_state)) {\n            break;\n        migrate_set_state(&s->state, old_state, MIGRATION_STATUS_CANCELLING);\n    } while (s->state != MIGRATION_STATUS_CANCELLING);\n    /*\n     * If we're unlucky the migration code might be stuck somewhere in a\n     * send/write while the network has failed and is waiting to timeout;\n     * if we've got shutdown(2) available then we can force it to quit.\n     * The outgoing qemu file gets closed in migrate_fd_cleanup that is\n     * called in a bh, so there is no race against this cancel.\n     */\n    if (s->state == MIGRATION_STATUS_CANCELLING && f) {\n        qemu_file_shutdown(f);", "idx": 26619}
{"project": "qemu", "commit_id": "58892b447f0ffcd0967bc6f1bcb40df288ebeebc", "target": 1, "func": "static int vfio_start_eventfd_injection(VFIOINTp *intp)\n\n{\n\n    int ret;\n\n\n\n    ret = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt);\n\n    if (ret) {\n\n        error_report(\"vfio: Error: Failed to pass IRQ fd to the driver: %m\");\n\n    }\n\n    return ret;\n\n}\n", "idx": 26620}
{"project": "qemu", "commit_id": "a79b5f8b80890b402fdb0733b0a073695a7875b5", "target": 1, "func": "static V9fsSynthNode *v9fs_add_dir_node(V9fsSynthNode *parent, int mode,\n\n                                        const char *name,\n\n                                        V9fsSynthNodeAttr *attr, int inode)\n\n{\n\n    V9fsSynthNode *node;\n\n\n\n    /* Add directory type and remove write bits */\n\n    mode = ((mode & 0777) | S_IFDIR) & ~(S_IWUSR | S_IWGRP | S_IWOTH);\n\n    node = g_malloc0(sizeof(V9fsSynthNode));\n\n    if (attr) {\n\n        /* We are adding .. or . entries */\n\n        node->attr = attr;\n\n        node->attr->nlink++;\n\n    } else {\n\n        node->attr = &node->actual_attr;\n\n        node->attr->inode = inode;\n\n        node->attr->nlink = 1;\n\n        /* We don't allow write to directories */\n\n        node->attr->mode   = mode;\n\n        node->attr->write = NULL;\n\n        node->attr->read  = NULL;\n\n    }\n\n    node->private = node;\n\n    strncpy(node->name, name, sizeof(node->name));\n\n    QLIST_INSERT_HEAD_RCU(&parent->child, node, sibling);\n\n    return node;\n\n}\n", "idx": 26621}
{"project": "qemu", "commit_id": "7f64f8e2c3c5a02636c2a6b8d6e6c5f7a62b89f7", "target": 1, "func": "static int scsi_disk_emulate_command(SCSIDiskReq *r)\n\n{\n\n    SCSIRequest *req = &r->req;\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    uint64_t nb_sectors;\n\n    uint8_t *outbuf;\n\n    int buflen = 0;\n\n\n\n    if (!r->iov.iov_base) {\n\n        /*\n\n         * FIXME: we shouldn't return anything bigger than 4k, but the code\n\n         * requires the buffer to be as big as req->cmd.xfer in several\n\n         * places.  So, do not allow CDBs with a very large ALLOCATION\n\n         * LENGTH.  The real fix would be to modify scsi_read_data and\n\n         * dma_buf_read, so that they return data beyond the buflen\n\n         * as all zeros.\n\n         */\n\n        if (req->cmd.xfer > 65536) {\n\n            goto illegal_request;\n\n        }\n\n        r->buflen = MAX(4096, req->cmd.xfer);\n\n        r->iov.iov_base = qemu_blockalign(s->qdev.conf.bs, r->buflen);\n\n    }\n\n\n\n    outbuf = r->iov.iov_base;\n\n    switch (req->cmd.buf[0]) {\n\n    case TEST_UNIT_READY:\n\n        assert(!s->tray_open && bdrv_is_inserted(s->qdev.conf.bs));\n\n        break;\n\n    case INQUIRY:\n\n        buflen = scsi_disk_emulate_inquiry(req, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case MODE_SENSE:\n\n    case MODE_SENSE_10:\n\n        buflen = scsi_disk_emulate_mode_sense(r, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case READ_TOC:\n\n        buflen = scsi_disk_emulate_read_toc(req, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case RESERVE:\n\n        if (req->cmd.buf[1] & 1) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case RESERVE_10:\n\n        if (req->cmd.buf[1] & 3) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case RELEASE:\n\n        if (req->cmd.buf[1] & 1) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case RELEASE_10:\n\n        if (req->cmd.buf[1] & 3) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case START_STOP:\n\n        if (scsi_disk_emulate_start_stop(r) < 0) {\n\n            return -1;\n\n        }\n\n        break;\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n        s->tray_locked = req->cmd.buf[4] & 1;\n\n        bdrv_lock_medium(s->qdev.conf.bs, req->cmd.buf[4] & 1);\n\n        break;\n\n    case READ_CAPACITY_10:\n\n        /* The normal LEN field for this command is zero.  */\n\n        memset(outbuf, 0, 8);\n\n        bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n        if (!nb_sectors) {\n\n            scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n\n            return -1;\n\n        }\n\n        if ((req->cmd.buf[8] & 1) == 0 && req->cmd.lba) {\n\n            goto illegal_request;\n\n        }\n\n        nb_sectors /= s->qdev.blocksize / 512;\n\n        /* Returned value is the address of the last sector.  */\n\n        nb_sectors--;\n\n        /* Remember the new size for read/write sanity checking. */\n\n        s->qdev.max_lba = nb_sectors;\n\n        /* Clip to 2TB, instead of returning capacity modulo 2TB. */\n\n        if (nb_sectors > UINT32_MAX) {\n\n            nb_sectors = UINT32_MAX;\n\n        }\n\n        outbuf[0] = (nb_sectors >> 24) & 0xff;\n\n        outbuf[1] = (nb_sectors >> 16) & 0xff;\n\n        outbuf[2] = (nb_sectors >> 8) & 0xff;\n\n        outbuf[3] = nb_sectors & 0xff;\n\n        outbuf[4] = 0;\n\n        outbuf[5] = 0;\n\n        outbuf[6] = s->qdev.blocksize >> 8;\n\n        outbuf[7] = 0;\n\n        buflen = 8;\n\n        break;\n\n    case REQUEST_SENSE:\n\n        /* Just return \"NO SENSE\".  */\n\n        buflen = scsi_build_sense(NULL, 0, outbuf, r->buflen,\n\n                                  (req->cmd.buf[1] & 1) == 0);\n\n        break;\n\n    case MECHANISM_STATUS:\n\n        buflen = scsi_emulate_mechanism_status(s, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case GET_CONFIGURATION:\n\n        buflen = scsi_get_configuration(s, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case GET_EVENT_STATUS_NOTIFICATION:\n\n        buflen = scsi_get_event_status_notification(s, r, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case READ_DVD_STRUCTURE:\n\n        buflen = scsi_read_dvd_structure(s, r, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case SERVICE_ACTION_IN_16:\n\n        /* Service Action In subcommands. */\n\n        if ((req->cmd.buf[1] & 31) == SAI_READ_CAPACITY_16) {\n\n            DPRINTF(\"SAI READ CAPACITY(16)\\n\");\n\n            memset(outbuf, 0, req->cmd.xfer);\n\n            bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n            if (!nb_sectors) {\n\n                scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n\n                return -1;\n\n            }\n\n            if ((req->cmd.buf[14] & 1) == 0 && req->cmd.lba) {\n\n                goto illegal_request;\n\n            }\n\n            nb_sectors /= s->qdev.blocksize / 512;\n\n            /* Returned value is the address of the last sector.  */\n\n            nb_sectors--;\n\n            /* Remember the new size for read/write sanity checking. */\n\n            s->qdev.max_lba = nb_sectors;\n\n            outbuf[0] = (nb_sectors >> 56) & 0xff;\n\n            outbuf[1] = (nb_sectors >> 48) & 0xff;\n\n            outbuf[2] = (nb_sectors >> 40) & 0xff;\n\n            outbuf[3] = (nb_sectors >> 32) & 0xff;\n\n            outbuf[4] = (nb_sectors >> 24) & 0xff;\n\n            outbuf[5] = (nb_sectors >> 16) & 0xff;\n\n            outbuf[6] = (nb_sectors >> 8) & 0xff;\n\n            outbuf[7] = nb_sectors & 0xff;\n\n            outbuf[8] = 0;\n\n            outbuf[9] = 0;\n\n            outbuf[10] = s->qdev.blocksize >> 8;\n\n            outbuf[11] = 0;\n\n            outbuf[12] = 0;\n\n            outbuf[13] = get_physical_block_exp(&s->qdev.conf);\n\n\n\n            /* set TPE bit if the format supports discard */\n\n            if (s->qdev.conf.discard_granularity) {\n\n                outbuf[14] = 0x80;\n\n            }\n\n\n\n            /* Protection, exponent and lowest lba field left blank. */\n\n            buflen = req->cmd.xfer;\n\n            break;\n\n        }\n\n        DPRINTF(\"Unsupported Service Action In\\n\");\n\n        goto illegal_request;\n\n    case VERIFY_10:\n\n        break;\n\n    default:\n\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n\n        return -1;\n\n    }\n\n    buflen = MIN(buflen, req->cmd.xfer);\n\n    return buflen;\n\n\n\nillegal_request:\n\n    if (r->req.status == -1) {\n\n        scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n\n    }\n\n    return -1;\n\n}\n", "idx": 26623}
{"project": "qemu", "commit_id": "3ae59580a0db469c1de72d5c58266b08fb096056", "target": 1, "func": "static void bdrv_delete(BlockDriverState *bs)\n\n{\n\n    assert(!bs->dev);\n\n    assert(!bs->job);\n\n    assert(bdrv_op_blocker_is_empty(bs));\n\n    assert(!bs->refcnt);\n\n    assert(QLIST_EMPTY(&bs->dirty_bitmaps));\n\n\n\n    bdrv_close(bs);\n\n\n\n    /* remove from list, if necessary */\n\n    bdrv_make_anon(bs);\n\n\n\n\n    g_free(bs);\n\n}", "idx": 26624}
{"project": "qemu", "commit_id": "302a0d3ed721e4c30c6a2a37f64c60b50ffd33b9", "target": 1, "func": "static void v9fs_write(void *opaque)\n\n{\n\n    int cnt;\n\n    ssize_t err;\n\n    int32_t fid;\n\n    int64_t off;\n\n    int32_t count;\n\n    int32_t len = 0;\n\n    int32_t total = 0;\n\n    size_t offset = 7;\n\n    V9fsFidState *fidp;\n\n    struct iovec iov[128]; /* FIXME: bad, bad, bad */\n\n    struct iovec *sg = iov;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    pdu_unmarshal(pdu, offset, \"dqdv\", &fid, &off, &count, sg, &cnt);\n\n    trace_v9fs_write(pdu->tag, pdu->id, fid, off, count, cnt);\n\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        err = -EINVAL;\n\n        goto out_nofid;\n\n    }\n\n    if (fidp->fid_type == P9_FID_FILE) {\n\n        if (fidp->fs.fd == -1) {\n\n            err = -EINVAL;\n\n            goto out;\n\n        }\n\n    } else if (fidp->fid_type == P9_FID_XATTR) {\n\n        /*\n\n         * setxattr operation\n\n         */\n\n        err = v9fs_xattr_write(s, pdu, fidp, off, count, sg, cnt);\n\n        goto out;\n\n    } else {\n\n        err = -EINVAL;\n\n        goto out;\n\n    }\n\n    sg = cap_sg(sg, count, &cnt);\n\n    do {\n\n        if (0) {\n\n            print_sg(sg, cnt);\n\n        }\n\n        /* Loop in case of EINTR */\n\n        do {\n\n            len = v9fs_co_pwritev(pdu, fidp, sg, cnt, off);\n\n            if (len >= 0) {\n\n                off   += len;\n\n                total += len;\n\n            }\n\n        } while (len == -EINTR && !pdu->cancelled);\n\n        if (len < 0) {\n\n            /* IO error return the error */\n\n            err = len;\n\n            goto out;\n\n        }\n\n        sg = adjust_sg(sg, len, &cnt);\n\n    } while (total < count && len > 0);\n\n    offset += pdu_marshal(pdu, offset, \"d\", total);\n\n    err = offset;\n\n    trace_v9fs_write_return(pdu->tag, pdu->id, total, err);\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    complete_pdu(s, pdu, err);\n\n}\n", "idx": 26625}
{"project": "qemu", "commit_id": "164a101f28a53cd3db60ed874e7c3630e7988ed8", "target": 1, "func": "void aio_set_fd_handler(AioContext *ctx,\n\n                        int fd,\n\n                        IOHandler *io_read,\n\n                        IOHandler *io_write,\n\n                        AioFlushHandler *io_flush,\n\n                        void *opaque)\n\n{\n\n    AioHandler *node;\n\n\n\n    node = find_aio_handler(ctx, fd);\n\n\n\n    /* Are we deleting the fd handler? */\n\n    if (!io_read && !io_write) {\n\n        if (node) {\n\n            g_source_remove_poll(&ctx->source, &node->pfd);\n\n\n\n            /* If the lock is held, just mark the node as deleted */\n\n            if (ctx->walking_handlers) {\n\n                node->deleted = 1;\n\n                node->pfd.revents = 0;\n\n            } else {\n\n                /* Otherwise, delete it for real.  We can't just mark it as\n\n                 * deleted because deleted nodes are only cleaned up after\n\n                 * releasing the walking_handlers lock.\n\n                 */\n\n                QLIST_REMOVE(node, node);\n\n                g_free(node);\n\n            }\n\n        }\n\n    } else {\n\n        if (node == NULL) {\n\n            /* Alloc and insert if it's not already there */\n\n            node = g_malloc0(sizeof(AioHandler));\n\n            node->pfd.fd = fd;\n\n            QLIST_INSERT_HEAD(&ctx->aio_handlers, node, node);\n\n\n\n            g_source_add_poll(&ctx->source, &node->pfd);\n\n        }\n\n        /* Update handler with latest information */\n\n        node->io_read = io_read;\n\n        node->io_write = io_write;\n\n        node->io_flush = io_flush;\n\n        node->opaque = opaque;\n\n        node->pollfds_idx = -1;\n\n\n\n        node->pfd.events = (io_read ? G_IO_IN | G_IO_HUP | G_IO_ERR : 0);\n\n        node->pfd.events |= (io_write ? G_IO_OUT | G_IO_ERR : 0);\n\n    }\n\n\n\n    aio_notify(ctx);\n\n}\n", "idx": 26628}
{"project": "qemu", "commit_id": "e9a07334fb6ee08ddd61787c102d36e7e781efef", "target": 1, "func": "static void g364fb_update_display(void *opaque)\n{\n    G364State *s = opaque;\n    if (s->width == 0 || s->height == 0)\n        return;\n    if (s->width != ds_get_width(s->ds) || s->height != ds_get_height(s->ds)) {\n        qemu_console_resize(s->ds, s->width, s->height);\n    }\n    if (s->ctla & CTLA_FORCE_BLANK) {\n        g364fb_draw_blank(s);\n    } else if (s->depth == 8) {\n        g364fb_draw_graphic8(s);\n    } else {\n        error_report(\"g364: unknown guest depth %d\", s->depth);\n    }\n    qemu_irq_raise(s->irq);\n}", "idx": 26632}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void bmds_set_aio_inflight(BlkMigDevState *bmds, int64_t sector_num,\n\n                             int nb_sectors, int set)\n\n{\n\n    int64_t start, end;\n\n    unsigned long val, idx, bit;\n\n\n\n    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;\n\n    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;\n\n\n\n    for (; start <= end; start++) {\n\n        idx = start / (sizeof(unsigned long) * 8);\n\n        bit = start % (sizeof(unsigned long) * 8);\n\n        val = bmds->aio_bitmap[idx];\n\n        if (set) {\n\n            val |= 1UL << bit;\n\n        } else {\n\n            val &= ~(1UL << bit);\n\n        }\n\n        bmds->aio_bitmap[idx] = val;\n\n    }\n\n}\n", "idx": 26634}
{"project": "qemu", "commit_id": "5ee5993001cf32addb86a92e2ae8cb090fbc1462", "target": 1, "func": "void helper_wrpil(CPUSPARCState *env, target_ulong new_pil)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n    trace_win_helper_wrpil(env->psrpil, (uint32_t)new_pil);\n\n\n\n    env->psrpil = new_pil;\n\n\n\n    if (cpu_interrupts_enabled(env)) {\n\n\n        cpu_check_irqs(env);\n\n\n    }\n\n#endif\n\n}", "idx": 26638}
{"project": "qemu", "commit_id": "7f0278435df1fa845b3bd9556942f89296d4246b", "target": 1, "func": "const char *qdict_get_try_str(const QDict *qdict, const char *key)\n\n{\n\n    QObject *obj;\n\n\n\n    obj = qdict_get(qdict, key);\n\n    if (!obj || qobject_type(obj) != QTYPE_QSTRING)\n\n        return NULL;\n\n\n\n    return qstring_get_str(qobject_to_qstring(obj));\n\n}\n", "idx": 26639}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void tricore_testboard_init(MachineState *machine, int board_id)\n\n{\n\n    TriCoreCPU *cpu;\n\n    CPUTriCoreState *env;\n\n\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *ext_cram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ext_dram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *int_cram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *int_dram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *pcp_data = g_new(MemoryRegion, 1);\n\n    MemoryRegion *pcp_text = g_new(MemoryRegion, 1);\n\n\n\n    if (!machine->cpu_model) {\n\n        machine->cpu_model = \"tc1796\";\n\n    }\n\n    cpu = cpu_tricore_init(machine->cpu_model);\n\n    if (!cpu) {\n\n        error_report(\"Unable to find CPU definition\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n    memory_region_init_ram(ext_cram, NULL, \"powerlink_ext_c.ram\", 2*1024*1024, &error_abort);\n\n    vmstate_register_ram_global(ext_cram);\n\n    memory_region_init_ram(ext_dram, NULL, \"powerlink_ext_d.ram\", 4*1024*1024, &error_abort);\n\n    vmstate_register_ram_global(ext_dram);\n\n    memory_region_init_ram(int_cram, NULL, \"powerlink_int_c.ram\", 48*1024, &error_abort);\n\n    vmstate_register_ram_global(int_cram);\n\n    memory_region_init_ram(int_dram, NULL, \"powerlink_int_d.ram\", 48*1024, &error_abort);\n\n    vmstate_register_ram_global(int_dram);\n\n    memory_region_init_ram(pcp_data, NULL, \"powerlink_pcp_data.ram\", 16*1024, &error_abort);\n\n    vmstate_register_ram_global(pcp_data);\n\n    memory_region_init_ram(pcp_text, NULL, \"powerlink_pcp_text.ram\", 32*1024, &error_abort);\n\n    vmstate_register_ram_global(pcp_text);\n\n\n\n    memory_region_add_subregion(sysmem, 0x80000000, ext_cram);\n\n    memory_region_add_subregion(sysmem, 0xa1000000, ext_dram);\n\n    memory_region_add_subregion(sysmem, 0xd4000000, int_cram);\n\n    memory_region_add_subregion(sysmem, 0xd0000000, int_dram);\n\n    memory_region_add_subregion(sysmem, 0xf0050000, pcp_data);\n\n    memory_region_add_subregion(sysmem, 0xf0060000, pcp_text);\n\n\n\n    tricoretb_binfo.ram_size = machine->ram_size;\n\n    tricoretb_binfo.kernel_filename = machine->kernel_filename;\n\n\n\n    if (machine->kernel_filename) {\n\n        tricore_load_kernel(env);\n\n    }\n\n}\n", "idx": 26640}
{"project": "qemu", "commit_id": "fac7aa7fc2ebc26803b0a7b44b010f47ce3e1dd8", "target": 1, "func": "static void ahci_write_fis_sdb(AHCIState *s, int port, uint32_t finished)\n\n{\n\n    AHCIPortRegs *pr = &s->dev[port].port_regs;\n\n    IDEState *ide_state;\n\n    uint8_t *sdb_fis;\n\n\n\n    if (!s->dev[port].res_fis ||\n\n        !(pr->cmd & PORT_CMD_FIS_RX)) {\n\n        return;\n\n    }\n\n\n\n    sdb_fis = &s->dev[port].res_fis[RES_FIS_SDBFIS];\n\n    ide_state = &s->dev[port].port.ifs[0];\n\n\n\n    /* clear memory */\n\n    *(uint32_t*)sdb_fis = 0;\n\n\n\n    /* write values */\n\n    sdb_fis[0] = ide_state->error;\n\n    sdb_fis[2] = ide_state->status & 0x77;\n\n    s->dev[port].finished |= finished;\n\n    *(uint32_t*)(sdb_fis + 4) = cpu_to_le32(s->dev[port].finished);\n\n\n\n    ahci_trigger_irq(s, &s->dev[port], PORT_IRQ_SDB_FIS);\n\n}\n", "idx": 26641}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int bt_hid_in(struct bt_hid_device_s *s)\n\n{\n\n    USBPacket p;\n\n\n\n    p.pid = USB_TOKEN_IN;\n\n    p.devep = 1;\n\n    p.data = s->datain.buffer;\n\n    p.len = sizeof(s->datain.buffer);\n\n    s->datain.len = s->usbdev->info->handle_data(s->usbdev, &p);\n\n\n\n    return s->datain.len;\n\n}\n", "idx": 26642}
{"project": "qemu", "commit_id": "8af00205445eb901f17ca5b632d976065187538e", "target": 1, "func": "int v9fs_set_xattr(FsContext *ctx, const char *path, const char *name,\n\n                   void *value, size_t size, int flags)\n\n{\n\n    XattrOperations *xops = get_xattr_operations(ctx->xops, name);\n\n    if (xops) {\n\n        return xops->setxattr(ctx, path, name, value, size, flags);\n\n    }\n\n    errno = -EOPNOTSUPP;\n\n    return -1;\n\n\n\n}\n", "idx": 26643}
{"project": "qemu", "commit_id": "0fbc20740342713f282b118b4a446c4c43df3f4a", "target": 1, "func": "void kvm_irqchip_add_irq_route(KVMState *s, int irq, int irqchip, int pin)\n\n{\n\n    struct kvm_irq_routing_entry e;\n\n\n\n    assert(pin < s->gsi_count);\n\n\n\n    e.gsi = irq;\n\n    e.type = KVM_IRQ_ROUTING_IRQCHIP;\n\n    e.flags = 0;\n\n    e.u.irqchip.irqchip = irqchip;\n\n    e.u.irqchip.pin = pin;\n\n    kvm_add_routing_entry(s, &e);\n\n}\n", "idx": 26644}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static inline void gen_op_evsrwu(TCGv_i32 ret, TCGv_i32 arg1, TCGv_i32 arg2)\n\n{\n\n    TCGv_i32 t0;\n\n    int l1, l2;\n\n\n\n    l1 = gen_new_label();\n\n    l2 = gen_new_label();\n\n    t0 = tcg_temp_local_new_i32();\n\n    /* No error here: 6 bits are used */\n\n    tcg_gen_andi_i32(t0, arg2, 0x3F);\n\n    tcg_gen_brcondi_i32(TCG_COND_GE, t0, 32, l1);\n\n    tcg_gen_shr_i32(ret, arg1, t0);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_movi_i32(ret, 0);\n\n    gen_set_label(l2);\n\n    tcg_temp_free_i32(t0);\n\n}\n", "idx": 26645}
{"project": "qemu", "commit_id": "bf55b7afce53718ef96f4e6616da62c0ccac37dd", "target": 0, "func": "static IOMMUTLBEntry vtd_iommu_translate(MemoryRegion *iommu, hwaddr addr,\n\n                                         bool is_write)\n\n{\n\n    VTDAddressSpace *vtd_as = container_of(iommu, VTDAddressSpace, iommu);\n\n    IntelIOMMUState *s = vtd_as->iommu_state;\n\n    IOMMUTLBEntry ret = {\n\n        .target_as = &address_space_memory,\n\n        .iova = addr,\n\n        .translated_addr = 0,\n\n        .addr_mask = ~(hwaddr)0,\n\n        .perm = IOMMU_NONE,\n\n    };\n\n\n\n    if (!s->dmar_enabled) {\n\n        /* DMAR disabled, passthrough, use 4k-page*/\n\n        ret.iova = addr & VTD_PAGE_MASK_4K;\n\n        ret.translated_addr = addr & VTD_PAGE_MASK_4K;\n\n        ret.addr_mask = ~VTD_PAGE_MASK_4K;\n\n        ret.perm = IOMMU_RW;\n\n        return ret;\n\n    }\n\n\n\n    vtd_do_iommu_translate(vtd_as, vtd_as->bus, vtd_as->devfn, addr,\n\n                           is_write, &ret);\n\n    VTD_DPRINTF(MMU,\n\n                \"bus %\"PRIu8 \" slot %\"PRIu8 \" func %\"PRIu8 \" devfn %\"PRIu8\n\n                \" iova 0x%\"PRIx64 \" hpa 0x%\"PRIx64, pci_bus_num(vtd_as->bus),\n\n                VTD_PCI_SLOT(vtd_as->devfn), VTD_PCI_FUNC(vtd_as->devfn),\n\n                vtd_as->devfn, addr, ret.translated_addr);\n\n    return ret;\n\n}\n", "idx": 26646}
{"project": "qemu", "commit_id": "d185c094b404b4ff392b77d1244c0233da7d53bd", "target": 0, "func": "static gboolean io_watch_poll_check(GSource *source)\n\n{\n\n    IOWatchPoll *iwp = io_watch_poll_from_source(source);\n\n\n\n    if (iwp->max_size == 0) {\n\n        return FALSE;\n\n    }\n\n\n\n    return g_io_watch_funcs.check(source);\n\n}\n", "idx": 26647}
{"project": "qemu", "commit_id": "91479dd0b5bd3b087b92ddd7bc3f2c54982cfe17", "target": 0, "func": "START_TEST(qlist_append_test)\n\n{\n\n    QInt *qi;\n\n    QList *qlist;\n\n    QListEntry *entry;\n\n\n\n    qi = qint_from_int(42);\n\n\n\n    qlist = qlist_new();\n\n    qlist_append(qlist, qi);\n\n\n\n    entry = QTAILQ_FIRST(&qlist->head);\n\n    fail_unless(entry != NULL);\n\n    fail_unless(entry->value == QOBJECT(qi));\n\n\n\n    // destroy doesn't exist yet\n\n    QDECREF(qi);\n\n    g_free(entry);\n\n    g_free(qlist);\n\n}\n", "idx": 26649}
{"project": "qemu", "commit_id": "2d6c1ef40f3678ab47a4d14fb5dadaa486bfcda6", "target": 0, "func": "static int parse_chr(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    CharDriverState **ptr = qdev_get_prop_ptr(dev, prop);\n\n\n\n    *ptr = qemu_chr_find(str);\n\n    if (*ptr == NULL)\n\n        return -ENOENT;\n\n    return 0;\n\n}\n", "idx": 26650}
{"project": "qemu", "commit_id": "8172539d21a03e982aa7f139ddc1607dc1422045", "target": 0, "func": "static unsigned virtio_pci_get_features(void *opaque)\n\n{\n\n    unsigned ret = 0;\n\n    ret |= (1 << VIRTIO_F_NOTIFY_ON_EMPTY);\n\n    ret |= (1 << VIRTIO_RING_F_INDIRECT_DESC);\n\n    ret |= (1 << VIRTIO_F_BAD_FEATURE);\n\n    return ret;\n\n}\n", "idx": 26651}
{"project": "qemu", "commit_id": "93147a180c10b97bf9575a87e01c9a1c93e6c9ce", "target": 0, "func": "target_ulong HELPER(mfspr)(CPUOpenRISCState *env,\n\n                           target_ulong rd, target_ulong ra, uint32_t offset)\n\n{\n\n#ifndef CONFIG_USER_ONLY\n\n    int spr = (ra | offset);\n\n    int idx;\n\n\n\n    OpenRISCCPU *cpu = openrisc_env_get_cpu(env);\n\n\n\n    switch (spr) {\n\n    case TO_SPR(0, 0): /* VR */\n\n        return env->vr & SPR_VR;\n\n\n\n    case TO_SPR(0, 1): /* UPR */\n\n        return env->upr;    /* TT, DM, IM, UP present */\n\n\n\n    case TO_SPR(0, 2): /* CPUCFGR */\n\n        return env->cpucfgr;\n\n\n\n    case TO_SPR(0, 3): /* DMMUCFGR */\n\n        return env->dmmucfgr;    /* 1Way, 64 entries */\n\n\n\n    case TO_SPR(0, 4): /* IMMUCFGR */\n\n        return env->immucfgr;\n\n\n\n    case TO_SPR(0, 16): /* NPC */\n\n        return env->npc;\n\n\n\n    case TO_SPR(0, 17): /* SR */\n\n        return env->sr;\n\n\n\n    case TO_SPR(0, 18): /* PPC */\n\n        return env->ppc;\n\n\n\n    case TO_SPR(0, 32): /* EPCR */\n\n        return env->epcr;\n\n\n\n    case TO_SPR(0, 48): /* EEAR */\n\n        return env->eear;\n\n\n\n    case TO_SPR(0, 64): /* ESR */\n\n        return env->esr;\n\n\n\n    case TO_SPR(1, 512) ... TO_SPR(1, 639): /* DTLBW0MR 0-127 */\n\n        idx = spr - TO_SPR(1, 512);\n\n        return env->tlb->dtlb[0][idx].mr;\n\n\n\n    case TO_SPR(1, 640) ... TO_SPR(1, 767): /* DTLBW0TR 0-127 */\n\n        idx = spr - TO_SPR(1, 640);\n\n        return env->tlb->dtlb[0][idx].tr;\n\n\n\n    case TO_SPR(1, 768) ... TO_SPR(1, 895):   /* DTLBW1MR 0-127 */\n\n    case TO_SPR(1, 896) ... TO_SPR(1, 1023):  /* DTLBW1TR 0-127 */\n\n    case TO_SPR(1, 1024) ... TO_SPR(1, 1151): /* DTLBW2MR 0-127 */\n\n    case TO_SPR(1, 1152) ... TO_SPR(1, 1279): /* DTLBW2TR 0-127 */\n\n    case TO_SPR(1, 1280) ... TO_SPR(1, 1407): /* DTLBW3MR 0-127 */\n\n    case TO_SPR(1, 1408) ... TO_SPR(1, 1535): /* DTLBW3TR 0-127 */\n\n        break;\n\n\n\n    case TO_SPR(2, 512) ... TO_SPR(2, 639): /* ITLBW0MR 0-127 */\n\n        idx = spr - TO_SPR(2, 512);\n\n        return env->tlb->itlb[0][idx].mr;\n\n\n\n    case TO_SPR(2, 640) ... TO_SPR(2, 767): /* ITLBW0TR 0-127 */\n\n        idx = spr - TO_SPR(2, 640);\n\n        return env->tlb->itlb[0][idx].tr;\n\n\n\n    case TO_SPR(2, 768) ... TO_SPR(2, 895):   /* ITLBW1MR 0-127 */\n\n    case TO_SPR(2, 896) ... TO_SPR(2, 1023):  /* ITLBW1TR 0-127 */\n\n    case TO_SPR(2, 1024) ... TO_SPR(2, 1151): /* ITLBW2MR 0-127 */\n\n    case TO_SPR(2, 1152) ... TO_SPR(2, 1279): /* ITLBW2TR 0-127 */\n\n    case TO_SPR(2, 1280) ... TO_SPR(2, 1407): /* ITLBW3MR 0-127 */\n\n    case TO_SPR(2, 1408) ... TO_SPR(2, 1535): /* ITLBW3TR 0-127 */\n\n        break;\n\n\n\n    case TO_SPR(9, 0):  /* PICMR */\n\n        return env->picmr;\n\n\n\n    case TO_SPR(9, 2):  /* PICSR */\n\n        return env->picsr;\n\n\n\n    case TO_SPR(10, 0): /* TTMR */\n\n        return env->ttmr;\n\n\n\n    case TO_SPR(10, 1): /* TTCR */\n\n        cpu_openrisc_count_update(cpu);\n\n        return env->ttcr;\n\n\n\n    default:\n\n        break;\n\n    }\n\n#endif\n\n\n\n/*If we later need to add tracepoints (or debug printfs) for the return\n\nvalue, it may be useful to structure the code like this:\n\n\n\ntarget_ulong ret = 0;\n\n\n\nswitch() {\n\ncase x:\n\n ret = y;\n\n break;\n\ncase z:\n\n ret = 42;\n\n break;\n\n...\n\n}\n\n\n\nlater something like trace_spr_read(ret);\n\n\n\nreturn ret;*/\n\n\n\n    /* for rd is passed in, if rd unchanged, just keep it back.  */\n\n    return rd;\n\n}\n", "idx": 26652}
{"project": "qemu", "commit_id": "1453e6627d19a8d6d54480c6980f5cef5dfc6833", "target": 0, "func": "void qmp_inject_nmi(Error **errp)\n\n{\n\n#if defined(TARGET_I386)\n\n    CPUState *cs;\n\n\n\n    CPU_FOREACH(cs) {\n\n        X86CPU *cpu = X86_CPU(cs);\n\n\n\n        if (!cpu->apic_state) {\n\n            cpu_interrupt(cs, CPU_INTERRUPT_NMI);\n\n        } else {\n\n            apic_deliver_nmi(cpu->apic_state);\n\n        }\n\n    }\n\n#else\n\n    nmi_monitor_handle(monitor_get_cpu_index(), errp);\n\n#endif\n\n}\n", "idx": 26653}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "ssize_t virtio_pdu_vunmarshal(V9fsPDU *pdu, size_t offset,\n\n                              const char *fmt, va_list ap)\n\n{\n\n    V9fsState *s = pdu->s;\n\n    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);\n\n    VirtQueueElement *elem = &v->elems[pdu->idx];\n\n\n\n    return v9fs_iov_vunmarshal(elem->out_sg, elem->out_num, offset, 1, fmt, ap);\n\n}\n", "idx": 26654}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "void do_td (int flags)\n\n{\n\n    if (!likely(!(((int64_t)T0 < (int64_t)T1 && (flags & 0x10)) ||\n\n                  ((int64_t)T0 > (int64_t)T1 && (flags & 0x08)) ||\n\n                  ((int64_t)T0 == (int64_t)T1 && (flags & 0x04)) ||\n\n                  ((uint64_t)T0 < (uint64_t)T1 && (flags & 0x02)) ||\n\n                  ((uint64_t)T0 > (uint64_t)T1 && (flags & 0x01)))))\n\n        do_raise_exception_err(EXCP_PROGRAM, EXCP_TRAP);\n\n}\n", "idx": 26655}
{"project": "qemu", "commit_id": "e4a3507e86a1ef1453d603031bca27d5ac4cff3c", "target": 0, "func": "static ssize_t block_crypto_read_func(QCryptoBlock *block,\n\n                                      void *opaque,\n\n                                      size_t offset,\n\n                                      uint8_t *buf,\n\n                                      size_t buflen,\n\n                                      Error **errp)\n\n{\n\n    BlockDriverState *bs = opaque;\n\n    ssize_t ret;\n\n\n\n    ret = bdrv_pread(bs->file, offset, buf, buflen);\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"Could not read encryption header\");\n\n        return ret;\n\n    }\n\n    return ret;\n\n}\n", "idx": 26656}
{"project": "qemu", "commit_id": "eda24e188637e2f86db31c3edb76d457212fdcb1", "target": 0, "func": "vnc_display_setup_auth(VncDisplay *vd,\n\n                       bool password,\n\n                       bool sasl,\n\n                       bool websocket,\n\n                       Error **errp)\n\n{\n\n    /*\n\n     * We have a choice of 3 authentication options\n\n     *\n\n     *   1. none\n\n     *   2. vnc\n\n     *   3. sasl\n\n     *\n\n     * The channel can be run in 2 modes\n\n     *\n\n     *   1. clear\n\n     *   2. tls\n\n     *\n\n     * And TLS can use 2 types of credentials\n\n     *\n\n     *   1. anon\n\n     *   2. x509\n\n     *\n\n     * We thus have 9 possible logical combinations\n\n     *\n\n     *   1. clear + none\n\n     *   2. clear + vnc\n\n     *   3. clear + sasl\n\n     *   4. tls + anon + none\n\n     *   5. tls + anon + vnc\n\n     *   6. tls + anon + sasl\n\n     *   7. tls + x509 + none\n\n     *   8. tls + x509 + vnc\n\n     *   9. tls + x509 + sasl\n\n     *\n\n     * These need to be mapped into the VNC auth schemes\n\n     * in an appropriate manner. In regular VNC, all the\n\n     * TLS options get mapped into VNC_AUTH_VENCRYPT\n\n     * sub-auth types.\n\n     *\n\n     * In websockets, the https:// protocol already provides\n\n     * TLS support, so there is no need to make use of the\n\n     * VeNCrypt extension. Furthermore, websockets browser\n\n     * clients could not use VeNCrypt even if they wanted to,\n\n     * as they cannot control when the TLS handshake takes\n\n     * place. Thus there is no option but to rely on https://,\n\n     * meaning combinations 4->6 and 7->9 will be mapped to\n\n     * VNC auth schemes in the same way as combos 1->3.\n\n     *\n\n     * Regardless of fact that we have a different mapping to\n\n     * VNC auth mechs for plain VNC vs websockets VNC, the end\n\n     * result has the same security characteristics.\n\n     */\n\n    if (password) {\n\n        if (vd->tlscreds) {\n\n            vd->auth = VNC_AUTH_VENCRYPT;\n\n            if (object_dynamic_cast(OBJECT(vd->tlscreds),\n\n                                    TYPE_QCRYPTO_TLS_CREDS_X509)) {\n\n                VNC_DEBUG(\"Initializing VNC server with x509 password auth\\n\");\n\n                vd->subauth = VNC_AUTH_VENCRYPT_X509VNC;\n\n            } else if (object_dynamic_cast(OBJECT(vd->tlscreds),\n\n                                           TYPE_QCRYPTO_TLS_CREDS_ANON)) {\n\n                VNC_DEBUG(\"Initializing VNC server with TLS password auth\\n\");\n\n                vd->subauth = VNC_AUTH_VENCRYPT_TLSVNC;\n\n            } else {\n\n                error_setg(errp,\n\n                           \"Unsupported TLS cred type %s\",\n\n                           object_get_typename(OBJECT(vd->tlscreds)));\n\n                return -1;\n\n            }\n\n        } else {\n\n            VNC_DEBUG(\"Initializing VNC server with password auth\\n\");\n\n            vd->auth = VNC_AUTH_VNC;\n\n            vd->subauth = VNC_AUTH_INVALID;\n\n        }\n\n        if (websocket) {\n\n            vd->ws_auth = VNC_AUTH_VNC;\n\n        } else {\n\n            vd->ws_auth = VNC_AUTH_INVALID;\n\n        }\n\n    } else if (sasl) {\n\n        if (vd->tlscreds) {\n\n            vd->auth = VNC_AUTH_VENCRYPT;\n\n            if (object_dynamic_cast(OBJECT(vd->tlscreds),\n\n                                    TYPE_QCRYPTO_TLS_CREDS_X509)) {\n\n                VNC_DEBUG(\"Initializing VNC server with x509 SASL auth\\n\");\n\n                vd->subauth = VNC_AUTH_VENCRYPT_X509SASL;\n\n            } else if (object_dynamic_cast(OBJECT(vd->tlscreds),\n\n                                           TYPE_QCRYPTO_TLS_CREDS_ANON)) {\n\n                VNC_DEBUG(\"Initializing VNC server with TLS SASL auth\\n\");\n\n                vd->subauth = VNC_AUTH_VENCRYPT_TLSSASL;\n\n            } else {\n\n                error_setg(errp,\n\n                           \"Unsupported TLS cred type %s\",\n\n                           object_get_typename(OBJECT(vd->tlscreds)));\n\n                return -1;\n\n            }\n\n        } else {\n\n            VNC_DEBUG(\"Initializing VNC server with SASL auth\\n\");\n\n            vd->auth = VNC_AUTH_SASL;\n\n            vd->subauth = VNC_AUTH_INVALID;\n\n        }\n\n        if (websocket) {\n\n            vd->ws_auth = VNC_AUTH_SASL;\n\n        } else {\n\n            vd->ws_auth = VNC_AUTH_INVALID;\n\n        }\n\n    } else {\n\n        if (vd->tlscreds) {\n\n            vd->auth = VNC_AUTH_VENCRYPT;\n\n            if (object_dynamic_cast(OBJECT(vd->tlscreds),\n\n                                    TYPE_QCRYPTO_TLS_CREDS_X509)) {\n\n                VNC_DEBUG(\"Initializing VNC server with x509 no auth\\n\");\n\n                vd->subauth = VNC_AUTH_VENCRYPT_X509NONE;\n\n            } else if (object_dynamic_cast(OBJECT(vd->tlscreds),\n\n                                           TYPE_QCRYPTO_TLS_CREDS_ANON)) {\n\n                VNC_DEBUG(\"Initializing VNC server with TLS no auth\\n\");\n\n                vd->subauth = VNC_AUTH_VENCRYPT_TLSNONE;\n\n            } else {\n\n                error_setg(errp,\n\n                           \"Unsupported TLS cred type %s\",\n\n                           object_get_typename(OBJECT(vd->tlscreds)));\n\n                return -1;\n\n            }\n\n        } else {\n\n            VNC_DEBUG(\"Initializing VNC server with no auth\\n\");\n\n            vd->auth = VNC_AUTH_NONE;\n\n            vd->subauth = VNC_AUTH_INVALID;\n\n        }\n\n        if (websocket) {\n\n            vd->ws_auth = VNC_AUTH_NONE;\n\n        } else {\n\n            vd->ws_auth = VNC_AUTH_INVALID;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 26657}
{"project": "qemu", "commit_id": "991f8f0c91d65cebf51fa931450e02b0d5209012", "target": 0, "func": "static void fill_elf_note_phdr(struct elf_phdr *phdr, int sz, off_t offset)\n\n{\n\n    phdr->p_type = PT_NOTE;\n\n    phdr->p_offset = offset;\n\n    phdr->p_vaddr = 0;\n\n    phdr->p_paddr = 0;\n\n    phdr->p_filesz = sz;\n\n    phdr->p_memsz = 0;\n\n    phdr->p_flags = 0;\n\n    phdr->p_align = 0;\n\n\n\n#ifdef BSWAP_NEEDED\n\n    bswap_phdr(phdr);\n\n#endif\n\n}\n", "idx": 26658}
{"project": "qemu", "commit_id": "812c1057f6175ac9a9829fa2920a2b5783814193", "target": 0, "func": "static gboolean tcp_chr_chan_close(GIOChannel *channel, GIOCondition cond,\n\n                                   void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n\n\n    if (cond != G_IO_HUP) {\n\n        return FALSE;\n\n    }\n\n\n\n    /* connection closed */\n\n    tcp_chr_disconnect(chr);\n\n    if (chr->fd_hup_tag) {\n\n        g_source_remove(chr->fd_hup_tag);\n\n        chr->fd_hup_tag = 0;\n\n    }\n\n\n\n    return TRUE;\n\n}\n", "idx": 26660}
{"project": "qemu", "commit_id": "46c5874e9cd752ed8ded31af03472edd8fc3efc1", "target": 0, "func": "static void rtas_ibm_configure_pe(PowerPCCPU *cpu,\n\n                                  sPAPREnvironment *spapr,\n\n                                  uint32_t token, uint32_t nargs,\n\n                                  target_ulong args, uint32_t nret,\n\n                                  target_ulong rets)\n\n{\n\n    sPAPRPHBState *sphb;\n\n    sPAPRPHBClass *spc;\n\n    uint64_t buid;\n\n    int ret;\n\n\n\n    if ((nargs != 3) || (nret != 1)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    buid = ((uint64_t)rtas_ld(args, 1) << 32) | rtas_ld(args, 2);\n\n    sphb = find_phb(spapr, buid);\n\n    if (!sphb) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb);\n\n    if (!spc->eeh_configure) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    ret = spc->eeh_configure(sphb);\n\n    rtas_st(rets, 0, ret);\n\n    return;\n\n\n\nparam_error_exit:\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n", "idx": 26661}
{"project": "qemu", "commit_id": "6eb8f212d2686ed9b17077d554465df7ae06f805", "target": 0, "func": "static void sigp_cpu_start(void *arg)\n\n{\n\n    CPUState *cs = arg;\n\n    S390CPU *cpu = S390_CPU(cs);\n\n\n\n    s390_cpu_set_state(CPU_STATE_OPERATING, cpu);\n\n    DPRINTF(\"DONE: KVM cpu start: %p\\n\", &cpu->env);\n\n}\n", "idx": 26662}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "eth_setup_ip4_fragmentation(const void *l2hdr, size_t l2hdr_len,\n\n                            void *l3hdr, size_t l3hdr_len,\n\n                            size_t l3payload_len,\n\n                            size_t frag_offset, bool more_frags)\n\n{\n\n    if (eth_get_l3_proto(l2hdr, l2hdr_len) == ETH_P_IP) {\n\n        uint16_t orig_flags;\n\n        struct ip_header *iphdr = (struct ip_header *) l3hdr;\n\n        uint16_t frag_off_units = frag_offset / IP_FRAG_UNIT_SIZE;\n\n        uint16_t new_ip_off;\n\n\n\n        assert(frag_offset % IP_FRAG_UNIT_SIZE == 0);\n\n        assert((frag_off_units & ~IP_OFFMASK) == 0);\n\n\n\n        orig_flags = be16_to_cpu(iphdr->ip_off) & ~(IP_OFFMASK|IP_MF);\n\n        new_ip_off = frag_off_units | orig_flags  | (more_frags ? IP_MF : 0);\n\n        iphdr->ip_off = cpu_to_be16(new_ip_off);\n\n        iphdr->ip_len = cpu_to_be16(l3payload_len + l3hdr_len);\n\n    }\n\n}\n", "idx": 26663}
{"project": "qemu", "commit_id": "3b8c1761f0e1523622e008836d01a6544b1c21ab", "target": 0, "func": "static void netfilter_finalize(Object *obj)\n\n{\n\n    NetFilterState *nf = NETFILTER(obj);\n\n    NetFilterClass *nfc = NETFILTER_GET_CLASS(obj);\n\n\n\n    if (nfc->cleanup) {\n\n        nfc->cleanup(nf);\n\n    }\n\n\n\n    if (nf->netdev && !QTAILQ_EMPTY(&nf->netdev->filters) &&\n\n        nf->next.tqe_prev) {\n\n        QTAILQ_REMOVE(&nf->netdev->filters, nf, next);\n\n    }\n\n    g_free(nf->netdev_id);\n\n}\n", "idx": 26669}
{"project": "qemu", "commit_id": "57407ea44cc0a3d630b9b89a2be011f1955ce5c1", "target": 0, "func": "static void ne2000_cleanup(NetClientState *nc)\n\n{\n\n    NE2000State *s = qemu_get_nic_opaque(nc);\n\n\n\n    s->nic = NULL;\n\n}\n", "idx": 26670}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float32 HELPER(ucf64_subs)(float32 a, float32 b, CPUUniCore32State *env)\n\n{\n\n    return float32_sub(a, b, &env->ucf64.fp_status);\n\n}\n", "idx": 26671}
{"project": "qemu", "commit_id": "e67b3ca53a891413a33c45495ff20c2728d69722", "target": 0, "func": "static void sys_write(void *opaque, hwaddr addr,\n\n                      uint64_t value, unsigned size)\n\n{\n\n    LM32SysState *s = opaque;\n\n    char *testname;\n\n\n\n    trace_lm32_sys_memory_write(addr, value);\n\n\n\n    addr >>= 2;\n\n    switch (addr) {\n\n    case R_CTRL:\n\n        qemu_system_shutdown_request();\n\n        break;\n\n    case R_PASSFAIL:\n\n        s->regs[addr] = value;\n\n        testname = (char *)s->testname;\n\n        qemu_log(\"TC  %-16s %s\\n\", testname, (value) ? \"FAILED\" : \"OK\");\n\n        break;\n\n    case R_TESTNAME:\n\n        s->regs[addr] = value;\n\n        copy_testname(s);\n\n        break;\n\n\n\n    default:\n\n        error_report(\"lm32_sys: write access to unknown register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    }\n\n}\n", "idx": 26672}
{"project": "qemu", "commit_id": "c6a6a5e3bb7120e1eb33eca6364a290229c1e72e", "target": 0, "func": "do_cksum(uint8_t *dp, uint8_t *de)\n\n{\n\n    unsigned int bsum[2] = {0, 0}, i, sum;\n\n\n\n    for (i = 1; dp < de; bsum[i^=1] += *dp++)\n\n        ;\n\n    sum = (bsum[0] << 8) + bsum[1];\n\n    sum = (sum >> 16) + (sum & 0xffff);\n\n    return ~(sum + (sum >> 16));\n\n}\n", "idx": 26673}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static DeviceState *qbus_find_dev(BusState *bus, char *elem)\n\n{\n\n    DeviceState *dev;\n\n\n\n    /*\n\n     * try to match in order:\n\n     *   (1) instance id, if present\n\n     *   (2) driver name\n\n     *   (3) driver alias, if present\n\n     */\n\n    LIST_FOREACH(dev, &bus->children, sibling) {\n\n        if (dev->id  &&  strcmp(dev->id, elem) == 0) {\n\n            return dev;\n\n        }\n\n    }\n\n    LIST_FOREACH(dev, &bus->children, sibling) {\n\n        if (strcmp(dev->info->name, elem) == 0) {\n\n            return dev;\n\n        }\n\n    }\n\n    LIST_FOREACH(dev, &bus->children, sibling) {\n\n        if (dev->info->alias && strcmp(dev->info->alias, elem) == 0) {\n\n            return dev;\n\n        }\n\n    }\n\n    return NULL;\n\n}\n", "idx": 26674}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "void scsi_req_cancel_async(SCSIRequest *req, Notifier *notifier)\n\n{\n\n    trace_scsi_req_cancel(req->dev->id, req->lun, req->tag);\n\n    if (notifier) {\n\n        notifier_list_add(&req->cancel_notifiers, notifier);\n\n    }\n\n    if (req->io_canceled) {\n\n        return;\n\n    }\n\n    scsi_req_ref(req);\n\n    scsi_req_dequeue(req);\n\n    req->io_canceled = true;\n\n    if (req->aiocb) {\n\n        bdrv_aio_cancel_async(req->aiocb);\n\n    }\n\n}\n", "idx": 26675}
{"project": "qemu", "commit_id": "240f64b6dc3346d044d7beb7cc3a53668ce47384", "target": 0, "func": "void qmp_object_add(const char *type, const char *id,\n\n                    bool has_props, QObject *props, Error **errp)\n\n{\n\n    const QDict *pdict = NULL;\n\n    QmpInputVisitor *qiv;\n\n    Object *obj;\n\n\n\n    if (props) {\n\n        pdict = qobject_to_qdict(props);\n\n        if (!pdict) {\n\n            error_setg(errp, QERR_INVALID_PARAMETER_TYPE, \"props\", \"dict\");\n\n            return;\n\n        }\n\n    }\n\n\n\n    qiv = qmp_input_visitor_new(props, false);\n\n    obj = user_creatable_add_type(type, id, pdict,\n\n                                  qmp_input_get_visitor(qiv), errp);\n\n    qmp_input_visitor_cleanup(qiv);\n\n    if (obj) {\n\n        object_unref(obj);\n\n    }\n\n}\n", "idx": 26676}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static inline void temp_save(TCGContext *s, TCGTemp *ts,\n\n                             TCGRegSet allocated_regs)\n\n{\n\n#ifdef USE_LIVENESS_ANALYSIS\n\n    /* ??? Liveness does not yet incorporate indirect bases.  */\n\n    if (!ts->indirect_base) {\n\n        /* The liveness analysis already ensures that globals are back\n\n           in memory. Keep an assert for safety. */\n\n        tcg_debug_assert(ts->val_type == TEMP_VAL_MEM || ts->fixed_reg);\n\n        return;\n\n    }\n\n#endif\n\n    temp_sync(s, ts, allocated_regs);\n\n    temp_dead(s, ts);\n\n}\n", "idx": 26677}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void register_multipage(AddressSpaceDispatch *d, MemoryRegionSection *section)\n\n{\n\n    target_phys_addr_t start_addr = section->offset_within_address_space;\n\n    ram_addr_t size = section->size;\n\n    target_phys_addr_t addr;\n\n    uint16_t section_index = phys_section_add(section);\n\n\n\n    assert(size);\n\n\n\n    addr = start_addr;\n\n    phys_page_set(d, addr >> TARGET_PAGE_BITS, size >> TARGET_PAGE_BITS,\n\n                  section_index);\n\n}\n", "idx": 26679}
{"project": "qemu", "commit_id": "100f738850639a108d6767316ce4dcc1d1ea4ae4", "target": 0, "func": "static void ics_simple_realize(DeviceState *dev, Error **errp)\n\n{\n\n    ICSState *ics = ICS_SIMPLE(dev);\n\n\n\n    if (!ics->nr_irqs) {\n\n        error_setg(errp, \"Number of interrupts needs to be greater 0\");\n\n        return;\n\n    }\n\n    ics->irqs = g_malloc0(ics->nr_irqs * sizeof(ICSIRQState));\n\n    ics->qirqs = qemu_allocate_irqs(ics_simple_set_irq, ics, ics->nr_irqs);\n\n\n\n    qemu_register_reset(ics_simple_reset, dev);\n\n}\n", "idx": 26680}
{"project": "qemu", "commit_id": "3c94378e2c500b6211e95d7457f4a9959955c3d1", "target": 0, "func": "static int IRQ_get_next(OpenPICState *opp, IRQQueue *q)\n\n{\n\n    if (q->next == -1) {\n\n        /* XXX: optimize */\n\n        IRQ_check(opp, q);\n\n    }\n\n\n\n    return q->next;\n\n}\n", "idx": 26681}
{"project": "qemu", "commit_id": "98522f63f40adaebc412481e1d2e9170160d4539", "target": 0, "func": "static int enable_write_target(BDRVVVFATState *s)\n\n{\n\n    BlockDriver *bdrv_qcow;\n\n    QEMUOptionParameter *options;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n    int size = sector2cluster(s, s->sector_count);\n\n    s->used_clusters = calloc(size, 1);\n\n\n\n    array_init(&(s->commits), sizeof(commit_t));\n\n\n\n    s->qcow_filename = g_malloc(1024);\n\n    ret = get_tmp_filename(s->qcow_filename, 1024);\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    bdrv_qcow = bdrv_find_format(\"qcow\");\n\n    options = parse_option_parameters(\"\", bdrv_qcow->create_options, NULL);\n\n    set_option_parameter_int(options, BLOCK_OPT_SIZE, s->sector_count * 512);\n\n    set_option_parameter(options, BLOCK_OPT_BACKING_FILE, \"fat:\");\n\n\n\n    ret = bdrv_create(bdrv_qcow, s->qcow_filename, options, &local_err);\n\n    if (ret < 0) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        goto err;\n\n    }\n\n\n\n    s->qcow = NULL;\n\n    ret = bdrv_open(&s->qcow, s->qcow_filename, NULL, NULL,\n\n            BDRV_O_RDWR | BDRV_O_CACHE_WB | BDRV_O_NO_FLUSH, bdrv_qcow,\n\n            &local_err);\n\n    if (ret < 0) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        goto err;\n\n    }\n\n\n\n#ifndef _WIN32\n\n    unlink(s->qcow_filename);\n\n#endif\n\n\n\n    s->bs->backing_hd = bdrv_new(\"\");\n\n    s->bs->backing_hd->drv = &vvfat_write_target;\n\n    s->bs->backing_hd->opaque = g_malloc(sizeof(void*));\n\n    *(void**)s->bs->backing_hd->opaque = s;\n\n\n\n    return 0;\n\n\n\nerr:\n\n    g_free(s->qcow_filename);\n\n    s->qcow_filename = NULL;\n\n    return ret;\n\n}\n", "idx": 26682}
{"project": "qemu", "commit_id": "1830f22a6777cedaccd67a08f675d30f7a85ebfd", "target": 0, "func": "static void dump_json_image_info_list(ImageInfoList *list)\n\n{\n\n    QString *str;\n\n    QmpOutputVisitor *ov = qmp_output_visitor_new();\n\n    QObject *obj;\n\n    visit_type_ImageInfoList(qmp_output_get_visitor(ov), NULL, &list,\n\n                             &error_abort);\n\n    obj = qmp_output_get_qobject(ov);\n\n    str = qobject_to_json_pretty(obj);\n\n    assert(str != NULL);\n\n    printf(\"%s\\n\", qstring_get_str(str));\n\n    qobject_decref(obj);\n\n    qmp_output_visitor_cleanup(ov);\n\n    QDECREF(str);\n\n}\n", "idx": 26683}
{"project": "qemu", "commit_id": "91cda45b69e45a089f9989979a65db3f710c9925", "target": 0, "func": "static int get_segment32(CPUPPCState *env, struct mmu_ctx_hash32 *ctx,\n\n                         target_ulong eaddr, int rw, int type)\n\n{\n\n    hwaddr hash;\n\n    target_ulong vsid;\n\n    int ds, pr, target_page_bits;\n\n    int ret, ret2;\n\n    target_ulong sr, pgidx;\n\n\n\n    pr = msr_pr;\n\n    ctx->eaddr = eaddr;\n\n\n\n    sr = env->sr[eaddr >> 28];\n\n    ctx->key = (((sr & SR32_KP) && (pr != 0)) ||\n\n                ((sr & SR32_KS) && (pr == 0))) ? 1 : 0;\n\n    ds = !!(sr & SR32_T);\n\n    ctx->nx = !!(sr & SR32_NX);\n\n    vsid = sr & SR32_VSID;\n\n    target_page_bits = TARGET_PAGE_BITS;\n\n    LOG_MMU(\"Check segment v=\" TARGET_FMT_lx \" %d \" TARGET_FMT_lx \" nip=\"\n\n            TARGET_FMT_lx \" lr=\" TARGET_FMT_lx\n\n            \" ir=%d dr=%d pr=%d %d t=%d\\n\",\n\n            eaddr, (int)(eaddr >> 28), sr, env->nip, env->lr, (int)msr_ir,\n\n            (int)msr_dr, pr != 0 ? 1 : 0, rw, type);\n\n    pgidx = (eaddr & ~SEGMENT_MASK_256M) >> target_page_bits;\n\n    hash = vsid ^ pgidx;\n\n    ctx->ptem = (vsid << 7) | (pgidx >> 10);\n\n\n\n    LOG_MMU(\"pte segment: key=%d ds %d nx %d vsid \" TARGET_FMT_lx \"\\n\",\n\n            ctx->key, ds, ctx->nx, vsid);\n\n    ret = -1;\n\n    if (!ds) {\n\n        /* Check if instruction fetch is allowed, if needed */\n\n        if (type != ACCESS_CODE || ctx->nx == 0) {\n\n            /* Page address translation */\n\n            LOG_MMU(\"htab_base \" TARGET_FMT_plx \" htab_mask \" TARGET_FMT_plx\n\n                    \" hash \" TARGET_FMT_plx \"\\n\",\n\n                    env->htab_base, env->htab_mask, hash);\n\n            ctx->hash[0] = hash;\n\n            ctx->hash[1] = ~hash;\n\n\n\n            /* Initialize real address with an invalid value */\n\n            ctx->raddr = (hwaddr)-1ULL;\n\n            LOG_MMU(\"0 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n                    \" vsid=\" TARGET_FMT_lx \" ptem=\" TARGET_FMT_lx\n\n                    \" hash=\" TARGET_FMT_plx \"\\n\",\n\n                    env->htab_base, env->htab_mask, vsid, ctx->ptem,\n\n                    ctx->hash[0]);\n\n            /* Primary table lookup */\n\n            ret = find_pte32(env, ctx, 0, rw, type, target_page_bits);\n\n            if (ret < 0) {\n\n                /* Secondary table lookup */\n\n                LOG_MMU(\"1 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n                        \" vsid=\" TARGET_FMT_lx \" api=\" TARGET_FMT_lx\n\n                        \" hash=\" TARGET_FMT_plx \"\\n\", env->htab_base,\n\n                        env->htab_mask, vsid, ctx->ptem, ctx->hash[1]);\n\n                ret2 = find_pte32(env, ctx, 1, rw, type,\n\n                                  target_page_bits);\n\n                if (ret2 != -1) {\n\n                    ret = ret2;\n\n                }\n\n            }\n\n#if defined(DUMP_PAGE_TABLES)\n\n            if (qemu_log_enabled()) {\n\n                hwaddr curaddr;\n\n                uint32_t a0, a1, a2, a3;\n\n\n\n                qemu_log(\"Page table: \" TARGET_FMT_plx \" len \" TARGET_FMT_plx\n\n                         \"\\n\", sdr, mask + 0x80);\n\n                for (curaddr = sdr; curaddr < (sdr + mask + 0x80);\n\n                     curaddr += 16) {\n\n                    a0 = ldl_phys(curaddr);\n\n                    a1 = ldl_phys(curaddr + 4);\n\n                    a2 = ldl_phys(curaddr + 8);\n\n                    a3 = ldl_phys(curaddr + 12);\n\n                    if (a0 != 0 || a1 != 0 || a2 != 0 || a3 != 0) {\n\n                        qemu_log(TARGET_FMT_plx \": %08x %08x %08x %08x\\n\",\n\n                                 curaddr, a0, a1, a2, a3);\n\n                    }\n\n                }\n\n            }\n\n#endif\n\n        } else {\n\n            LOG_MMU(\"No access allowed\\n\");\n\n            ret = -3;\n\n        }\n\n    } else {\n\n        target_ulong sr;\n\n\n\n        LOG_MMU(\"direct store...\\n\");\n\n        /* Direct-store segment : absolutely *BUGGY* for now */\n\n\n\n        /* Direct-store implies a 32-bit MMU.\n\n         * Check the Segment Register's bus unit ID (BUID).\n\n         */\n\n        sr = env->sr[eaddr >> 28];\n\n        if ((sr & 0x1FF00000) >> 20 == 0x07f) {\n\n            /* Memory-forced I/O controller interface access */\n\n            /* If T=1 and BUID=x'07F', the 601 performs a memory access\n\n             * to SR[28-31] LA[4-31], bypassing all protection mechanisms.\n\n             */\n\n            ctx->raddr = ((sr & 0xF) << 28) | (eaddr & 0x0FFFFFFF);\n\n            ctx->prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n            return 0;\n\n        }\n\n\n\n        switch (type) {\n\n        case ACCESS_INT:\n\n            /* Integer load/store : only access allowed */\n\n            break;\n\n        case ACCESS_CODE:\n\n            /* No code fetch is allowed in direct-store areas */\n\n            return -4;\n\n        case ACCESS_FLOAT:\n\n            /* Floating point load/store */\n\n            return -4;\n\n        case ACCESS_RES:\n\n            /* lwarx, ldarx or srwcx. */\n\n            return -4;\n\n        case ACCESS_CACHE:\n\n            /* dcba, dcbt, dcbtst, dcbf, dcbi, dcbst, dcbz, or icbi */\n\n            /* Should make the instruction do no-op.\n\n             * As it already do no-op, it's quite easy :-)\n\n             */\n\n            ctx->raddr = eaddr;\n\n            return 0;\n\n        case ACCESS_EXT:\n\n            /* eciwx or ecowx */\n\n            return -4;\n\n        default:\n\n            qemu_log(\"ERROR: instruction should not need \"\n\n                        \"address translation\\n\");\n\n            return -4;\n\n        }\n\n        if ((rw == 1 || ctx->key != 1) && (rw == 0 || ctx->key != 0)) {\n\n            ctx->raddr = eaddr;\n\n            ret = 2;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 26684}
{"project": "qemu", "commit_id": "a8b10c6ead7f62e8eadbdaf944f371889c3c4c29", "target": 0, "func": "static int dmg_read_mish_block(BDRVDMGState *s, DmgHeaderState *ds,\n\n                               uint8_t *buffer, uint32_t count)\n\n{\n\n    uint32_t type, i;\n\n    int ret;\n\n    size_t new_size;\n\n    uint32_t chunk_count;\n\n    int64_t offset = 0;\n\n    uint64_t data_offset;\n\n    uint64_t in_offset = ds->data_fork_offset;\n\n    uint64_t out_offset;\n\n\n\n    type = buff_read_uint32(buffer, offset);\n\n    /* skip data that is not a valid MISH block (invalid magic or too small) */\n\n    if (type != 0x6d697368 || count < 244) {\n\n        /* assume success for now */\n\n        return 0;\n\n    }\n\n\n\n    /* chunk offsets are relative to this sector number */\n\n    out_offset = buff_read_uint64(buffer, offset + 8);\n\n\n\n    /* location in data fork for (compressed) blob (in bytes) */\n\n    data_offset = buff_read_uint64(buffer, offset + 0x18);\n\n    in_offset += data_offset;\n\n\n\n    /* move to begin of chunk entries */\n\n    offset += 204;\n\n\n\n    chunk_count = (count - 204) / 40;\n\n    new_size = sizeof(uint64_t) * (s->n_chunks + chunk_count);\n\n    s->types = g_realloc(s->types, new_size / 2);\n\n    s->offsets = g_realloc(s->offsets, new_size);\n\n    s->lengths = g_realloc(s->lengths, new_size);\n\n    s->sectors = g_realloc(s->sectors, new_size);\n\n    s->sectorcounts = g_realloc(s->sectorcounts, new_size);\n\n\n\n    for (i = s->n_chunks; i < s->n_chunks + chunk_count; i++) {\n\n        s->types[i] = buff_read_uint32(buffer, offset);\n\n        offset += 4;\n\n        if (s->types[i] != 0x80000005 && s->types[i] != 1 &&\n\n            s->types[i] != 2) {\n\n            chunk_count--;\n\n            i--;\n\n            offset += 36;\n\n            continue;\n\n        }\n\n        offset += 4;\n\n\n\n        s->sectors[i] = buff_read_uint64(buffer, offset);\n\n        s->sectors[i] += out_offset;\n\n        offset += 8;\n\n\n\n        s->sectorcounts[i] = buff_read_uint64(buffer, offset);\n\n        offset += 8;\n\n\n\n        if (s->sectorcounts[i] > DMG_SECTORCOUNTS_MAX) {\n\n            error_report(\"sector count %\" PRIu64 \" for chunk %\" PRIu32\n\n                         \" is larger than max (%u)\",\n\n                         s->sectorcounts[i], i, DMG_SECTORCOUNTS_MAX);\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n\n\n        s->offsets[i] = buff_read_uint64(buffer, offset);\n\n        s->offsets[i] += in_offset;\n\n        offset += 8;\n\n\n\n        s->lengths[i] = buff_read_uint64(buffer, offset);\n\n        offset += 8;\n\n\n\n        if (s->lengths[i] > DMG_LENGTHS_MAX) {\n\n            error_report(\"length %\" PRIu64 \" for chunk %\" PRIu32\n\n                         \" is larger than max (%u)\",\n\n                         s->lengths[i], i, DMG_LENGTHS_MAX);\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n\n\n        update_max_chunk_size(s, i, &ds->max_compressed_size,\n\n                              &ds->max_sectors_per_chunk);\n\n    }\n\n    s->n_chunks += chunk_count;\n\n    return 0;\n\n\n\nfail:\n\n    return ret;\n\n}\n", "idx": 26685}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static always_inline void gen_qemu_ldf (TCGv t0, TCGv t1, int flags)\n\n{\n\n    TCGv tmp = tcg_temp_new(TCG_TYPE_I32);\n\n    tcg_gen_qemu_ld32u(tmp, t1, flags);\n\n    tcg_gen_helper_1_1(helper_memory_to_f, t0, tmp);\n\n    tcg_temp_free(tmp);\n\n}\n", "idx": 26686}
{"project": "qemu", "commit_id": "b97400caef60ccfb0bc81c59f8bd824c43a0d6c8", "target": 0, "func": "static int local_chmod(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)\n\n{\n\n    char buffer[PATH_MAX];\n\n    char *path = fs_path->data;\n\n\n\n    if (fs_ctx->fs_sm == SM_MAPPED) {\n\n        return local_set_xattr(rpath(fs_ctx, path, buffer), credp);\n\n    } else if ((fs_ctx->fs_sm == SM_PASSTHROUGH) ||\n\n               (fs_ctx->fs_sm == SM_NONE)) {\n\n        return chmod(rpath(fs_ctx, path, buffer), credp->fc_mode);\n\n    }\n\n    return -1;\n\n}\n", "idx": 26687}
{"project": "qemu", "commit_id": "434929bf11f0573d953c24287badbc2431a042ef", "target": 1, "func": "static inline PageDesc *page_find(target_ulong index)\n\n{\n\n    PageDesc *p;\n\n\n\n    p = l1_map[index >> L2_BITS];\n\n    if (!p)\n\n        return 0;\n\n    return p + (index & (L2_SIZE - 1));\n\n}\n", "idx": 26688}
{"project": "qemu", "commit_id": "7364dbdabb7824d5bde1e341bb6d928282f01c83", "target": 1, "func": "static int protocol_client_auth_sasl_mechname_len(VncState *vs, uint8_t *data, size_t len)\n\n{\n\n    uint32_t mechlen = read_u32(data, 0);\n\n    VNC_DEBUG(\"Got client mechname len %d\\n\", mechlen);\n\n    if (mechlen > 100) {\n\n        VNC_DEBUG(\"Too long SASL mechname data %d\\n\", mechlen);\n\n        vnc_client_error(vs);\n\n        return -1;\n\n    }\n\n    if (mechlen < 1) {\n\n        VNC_DEBUG(\"Too short SASL mechname %d\\n\", mechlen);\n\n        vnc_client_error(vs);\n\n        return -1;\n\n    }\n\n    vnc_read_when(vs, protocol_client_auth_sasl_mechname,mechlen);\n\n    return 0;\n\n}\n", "idx": 26690}
{"project": "qemu", "commit_id": "299b520cd4092be3c53f8380b81315c33927d9d3", "target": 1, "func": "static inline int ultrasparc_tag_match(SparcTLBEntry *tlb,\n\n                                       uint64_t address, uint64_t context,\n\n                                       target_phys_addr_t *physical,\n\n                                       int is_nucleus)\n\n{\n\n    uint64_t mask;\n\n\n\n    switch ((tlb->tte >> 61) & 3) {\n\n    default:\n\n    case 0x0: // 8k\n\n        mask = 0xffffffffffffe000ULL;\n\n        break;\n\n    case 0x1: // 64k\n\n        mask = 0xffffffffffff0000ULL;\n\n        break;\n\n    case 0x2: // 512k\n\n        mask = 0xfffffffffff80000ULL;\n\n        break;\n\n    case 0x3: // 4M\n\n        mask = 0xffffffffffc00000ULL;\n\n        break;\n\n    }\n\n\n\n    // valid, context match, virtual address match?\n\n    if (TTE_IS_VALID(tlb->tte) &&\n\n        ((is_nucleus && compare_masked(0, tlb->tag, 0x1fff))\n\n         || TTE_IS_GLOBAL(tlb->tte) || compare_masked(context, tlb->tag, 0x1fff))\n\n        && compare_masked(address, tlb->tag, mask))\n\n    {\n\n        // decode physical address\n\n        *physical = ((tlb->tte & mask) | (address & ~mask)) & 0x1ffffffe000ULL;\n\n        return 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 26691}
{"project": "qemu", "commit_id": "eff235eb2bcd7092901f4698a7907e742f3b7f2f", "target": 1, "func": "static ExitStatus trans_fop_wew_0e(DisasContext *ctx, uint32_t insn,\n\n                                   const DisasInsn *di)\n\n{\n\n    unsigned rt = assemble_rt64(insn);\n\n    unsigned ra = assemble_ra64(insn);\n\n    return do_fop_wew(ctx, rt, ra, di->f_wew);\n\n}\n", "idx": 26694}
{"project": "qemu", "commit_id": "39ea3d4eaf1ff300ee55946108394729bc053dfa", "target": 0, "func": "static int disas_thumb2_insn(CPUState *env, DisasContext *s, uint16_t insn_hw1)\n\n{\n\n    uint32_t insn, imm, shift, offset;\n\n    uint32_t rd, rn, rm, rs;\n\n    TCGv tmp;\n\n    TCGv tmp2;\n\n    TCGv tmp3;\n\n    TCGv addr;\n\n    TCGv_i64 tmp64;\n\n    int op;\n\n    int shiftop;\n\n    int conds;\n\n    int logic_cc;\n\n\n\n    if (!(arm_feature(env, ARM_FEATURE_THUMB2)\n\n          || arm_feature (env, ARM_FEATURE_M))) {\n\n        /* Thumb-1 cores may need to treat bl and blx as a pair of\n\n           16-bit instructions to get correct prefetch abort behavior.  */\n\n        insn = insn_hw1;\n\n        if ((insn & (1 << 12)) == 0) {\n\n            /* Second half of blx.  */\n\n            offset = ((insn & 0x7ff) << 1);\n\n            tmp = load_reg(s, 14);\n\n            tcg_gen_addi_i32(tmp, tmp, offset);\n\n            tcg_gen_andi_i32(tmp, tmp, 0xfffffffc);\n\n\n\n            tmp2 = new_tmp();\n\n            tcg_gen_movi_i32(tmp2, s->pc | 1);\n\n            store_reg(s, 14, tmp2);\n\n            gen_bx(s, tmp);\n\n            return 0;\n\n        }\n\n        if (insn & (1 << 11)) {\n\n            /* Second half of bl.  */\n\n            offset = ((insn & 0x7ff) << 1) | 1;\n\n            tmp = load_reg(s, 14);\n\n            tcg_gen_addi_i32(tmp, tmp, offset);\n\n\n\n            tmp2 = new_tmp();\n\n            tcg_gen_movi_i32(tmp2, s->pc | 1);\n\n            store_reg(s, 14, tmp2);\n\n            gen_bx(s, tmp);\n\n            return 0;\n\n        }\n\n        if ((s->pc & ~TARGET_PAGE_MASK) == 0) {\n\n            /* Instruction spans a page boundary.  Implement it as two\n\n               16-bit instructions in case the second half causes an\n\n               prefetch abort.  */\n\n            offset = ((int32_t)insn << 21) >> 9;\n\n            tcg_gen_movi_i32(cpu_R[14], s->pc + 2 + offset);\n\n            return 0;\n\n        }\n\n        /* Fall through to 32-bit decode.  */\n\n    }\n\n\n\n    insn = lduw_code(s->pc);\n\n    s->pc += 2;\n\n    insn |= (uint32_t)insn_hw1 << 16;\n\n\n\n    if ((insn & 0xf800e800) != 0xf000e800) {\n\n        ARCH(6T2);\n\n    }\n\n\n\n    rn = (insn >> 16) & 0xf;\n\n    rs = (insn >> 12) & 0xf;\n\n    rd = (insn >> 8) & 0xf;\n\n    rm = insn & 0xf;\n\n    switch ((insn >> 25) & 0xf) {\n\n    case 0: case 1: case 2: case 3:\n\n        /* 16-bit instructions.  Should never happen.  */\n\n        abort();\n\n    case 4:\n\n        if (insn & (1 << 22)) {\n\n            /* Other load/store, table branch.  */\n\n            if (insn & 0x01200000) {\n\n                /* Load/store doubleword.  */\n\n                if (rn == 15) {\n\n                    addr = new_tmp();\n\n                    tcg_gen_movi_i32(addr, s->pc & ~3);\n\n                } else {\n\n                    addr = load_reg(s, rn);\n\n                }\n\n                offset = (insn & 0xff) * 4;\n\n                if ((insn & (1 << 23)) == 0)\n\n                    offset = -offset;\n\n                if (insn & (1 << 24)) {\n\n                    tcg_gen_addi_i32(addr, addr, offset);\n\n                    offset = 0;\n\n                }\n\n                if (insn & (1 << 20)) {\n\n                    /* ldrd */\n\n                    tmp = gen_ld32(addr, IS_USER(s));\n\n                    store_reg(s, rs, tmp);\n\n                    tcg_gen_addi_i32(addr, addr, 4);\n\n                    tmp = gen_ld32(addr, IS_USER(s));\n\n                    store_reg(s, rd, tmp);\n\n                } else {\n\n                    /* strd */\n\n                    tmp = load_reg(s, rs);\n\n                    gen_st32(tmp, addr, IS_USER(s));\n\n                    tcg_gen_addi_i32(addr, addr, 4);\n\n                    tmp = load_reg(s, rd);\n\n                    gen_st32(tmp, addr, IS_USER(s));\n\n                }\n\n                if (insn & (1 << 21)) {\n\n                    /* Base writeback.  */\n\n                    if (rn == 15)\n\n                        goto illegal_op;\n\n                    tcg_gen_addi_i32(addr, addr, offset - 4);\n\n                    store_reg(s, rn, addr);\n\n                } else {\n\n                    dead_tmp(addr);\n\n                }\n\n            } else if ((insn & (1 << 23)) == 0) {\n\n                /* Load/store exclusive word.  */\n\n                addr = tcg_temp_local_new();\n\n                load_reg_var(s, addr, rn);\n\n                tcg_gen_addi_i32(addr, addr, (insn & 0xff) << 2);\n\n                if (insn & (1 << 20)) {\n\n                    gen_load_exclusive(s, rs, 15, addr, 2);\n\n                } else {\n\n                    gen_store_exclusive(s, rd, rs, 15, addr, 2);\n\n                }\n\n                tcg_temp_free(addr);\n\n            } else if ((insn & (1 << 6)) == 0) {\n\n                /* Table Branch.  */\n\n                if (rn == 15) {\n\n                    addr = new_tmp();\n\n                    tcg_gen_movi_i32(addr, s->pc);\n\n                } else {\n\n                    addr = load_reg(s, rn);\n\n                }\n\n                tmp = load_reg(s, rm);\n\n                tcg_gen_add_i32(addr, addr, tmp);\n\n                if (insn & (1 << 4)) {\n\n                    /* tbh */\n\n                    tcg_gen_add_i32(addr, addr, tmp);\n\n                    dead_tmp(tmp);\n\n                    tmp = gen_ld16u(addr, IS_USER(s));\n\n                } else { /* tbb */\n\n                    dead_tmp(tmp);\n\n                    tmp = gen_ld8u(addr, IS_USER(s));\n\n                }\n\n                dead_tmp(addr);\n\n                tcg_gen_shli_i32(tmp, tmp, 1);\n\n                tcg_gen_addi_i32(tmp, tmp, s->pc);\n\n                store_reg(s, 15, tmp);\n\n            } else {\n\n                /* Load/store exclusive byte/halfword/doubleword.  */\n\n                ARCH(7);\n\n                op = (insn >> 4) & 0x3;\n\n                if (op == 2) {\n\n                    goto illegal_op;\n\n                }\n\n                addr = tcg_temp_local_new();\n\n                load_reg_var(s, addr, rn);\n\n                if (insn & (1 << 20)) {\n\n                    gen_load_exclusive(s, rs, rd, addr, op);\n\n                } else {\n\n                    gen_store_exclusive(s, rm, rs, rd, addr, op);\n\n                }\n\n                tcg_temp_free(addr);\n\n            }\n\n        } else {\n\n            /* Load/store multiple, RFE, SRS.  */\n\n            if (((insn >> 23) & 1) == ((insn >> 24) & 1)) {\n\n                /* Not available in user mode.  */\n\n                if (IS_USER(s))\n\n                    goto illegal_op;\n\n                if (insn & (1 << 20)) {\n\n                    /* rfe */\n\n                    addr = load_reg(s, rn);\n\n                    if ((insn & (1 << 24)) == 0)\n\n                        tcg_gen_addi_i32(addr, addr, -8);\n\n                    /* Load PC into tmp and CPSR into tmp2.  */\n\n                    tmp = gen_ld32(addr, 0);\n\n                    tcg_gen_addi_i32(addr, addr, 4);\n\n                    tmp2 = gen_ld32(addr, 0);\n\n                    if (insn & (1 << 21)) {\n\n                        /* Base writeback.  */\n\n                        if (insn & (1 << 24)) {\n\n                            tcg_gen_addi_i32(addr, addr, 4);\n\n                        } else {\n\n                            tcg_gen_addi_i32(addr, addr, -4);\n\n                        }\n\n                        store_reg(s, rn, addr);\n\n                    } else {\n\n                        dead_tmp(addr);\n\n                    }\n\n                    gen_rfe(s, tmp, tmp2);\n\n                } else {\n\n                    /* srs */\n\n                    op = (insn & 0x1f);\n\n                    if (op == (env->uncached_cpsr & CPSR_M)) {\n\n                        addr = load_reg(s, 13);\n\n                    } else {\n\n                        addr = new_tmp();\n\n                        tmp = tcg_const_i32(op);\n\n                        gen_helper_get_r13_banked(addr, cpu_env, tmp);\n\n                        tcg_temp_free_i32(tmp);\n\n                    }\n\n                    if ((insn & (1 << 24)) == 0) {\n\n                        tcg_gen_addi_i32(addr, addr, -8);\n\n                    }\n\n                    tmp = load_reg(s, 14);\n\n                    gen_st32(tmp, addr, 0);\n\n                    tcg_gen_addi_i32(addr, addr, 4);\n\n                    tmp = new_tmp();\n\n                    gen_helper_cpsr_read(tmp);\n\n                    gen_st32(tmp, addr, 0);\n\n                    if (insn & (1 << 21)) {\n\n                        if ((insn & (1 << 24)) == 0) {\n\n                            tcg_gen_addi_i32(addr, addr, -4);\n\n                        } else {\n\n                            tcg_gen_addi_i32(addr, addr, 4);\n\n                        }\n\n                        if (op == (env->uncached_cpsr & CPSR_M)) {\n\n                            store_reg(s, 13, addr);\n\n                        } else {\n\n                            tmp = tcg_const_i32(op);\n\n                            gen_helper_set_r13_banked(cpu_env, tmp, addr);\n\n                            tcg_temp_free_i32(tmp);\n\n                        }\n\n                    } else {\n\n                        dead_tmp(addr);\n\n                    }\n\n                }\n\n            } else {\n\n                int i;\n\n                /* Load/store multiple.  */\n\n                addr = load_reg(s, rn);\n\n                offset = 0;\n\n                for (i = 0; i < 16; i++) {\n\n                    if (insn & (1 << i))\n\n                        offset += 4;\n\n                }\n\n                if (insn & (1 << 24)) {\n\n                    tcg_gen_addi_i32(addr, addr, -offset);\n\n                }\n\n\n\n                for (i = 0; i < 16; i++) {\n\n                    if ((insn & (1 << i)) == 0)\n\n                        continue;\n\n                    if (insn & (1 << 20)) {\n\n                        /* Load.  */\n\n                        tmp = gen_ld32(addr, IS_USER(s));\n\n                        if (i == 15) {\n\n                            gen_bx(s, tmp);\n\n                        } else {\n\n                            store_reg(s, i, tmp);\n\n                        }\n\n                    } else {\n\n                        /* Store.  */\n\n                        tmp = load_reg(s, i);\n\n                        gen_st32(tmp, addr, IS_USER(s));\n\n                    }\n\n                    tcg_gen_addi_i32(addr, addr, 4);\n\n                }\n\n                if (insn & (1 << 21)) {\n\n                    /* Base register writeback.  */\n\n                    if (insn & (1 << 24)) {\n\n                        tcg_gen_addi_i32(addr, addr, -offset);\n\n                    }\n\n                    /* Fault if writeback register is in register list.  */\n\n                    if (insn & (1 << rn))\n\n                        goto illegal_op;\n\n                    store_reg(s, rn, addr);\n\n                } else {\n\n                    dead_tmp(addr);\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    case 5:\n\n\n\n        op = (insn >> 21) & 0xf;\n\n        if (op == 6) {\n\n            /* Halfword pack.  */\n\n            tmp = load_reg(s, rn);\n\n            tmp2 = load_reg(s, rm);\n\n            shift = ((insn >> 10) & 0x1c) | ((insn >> 6) & 0x3);\n\n            if (insn & (1 << 5)) {\n\n                /* pkhtb */\n\n                if (shift == 0)\n\n                    shift = 31;\n\n                tcg_gen_sari_i32(tmp2, tmp2, shift);\n\n                tcg_gen_andi_i32(tmp, tmp, 0xffff0000);\n\n                tcg_gen_ext16u_i32(tmp2, tmp2);\n\n            } else {\n\n                /* pkhbt */\n\n                if (shift)\n\n                    tcg_gen_shli_i32(tmp2, tmp2, shift);\n\n                tcg_gen_ext16u_i32(tmp, tmp);\n\n                tcg_gen_andi_i32(tmp2, tmp2, 0xffff0000);\n\n            }\n\n            tcg_gen_or_i32(tmp, tmp, tmp2);\n\n            dead_tmp(tmp2);\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            /* Data processing register constant shift.  */\n\n            if (rn == 15) {\n\n                tmp = new_tmp();\n\n                tcg_gen_movi_i32(tmp, 0);\n\n            } else {\n\n                tmp = load_reg(s, rn);\n\n            }\n\n            tmp2 = load_reg(s, rm);\n\n\n\n            shiftop = (insn >> 4) & 3;\n\n            shift = ((insn >> 6) & 3) | ((insn >> 10) & 0x1c);\n\n            conds = (insn & (1 << 20)) != 0;\n\n            logic_cc = (conds && thumb2_logic_op(op));\n\n            gen_arm_shift_im(tmp2, shiftop, shift, logic_cc);\n\n            if (gen_thumb2_data_op(s, op, conds, 0, tmp, tmp2))\n\n                goto illegal_op;\n\n            dead_tmp(tmp2);\n\n            if (rd != 15) {\n\n                store_reg(s, rd, tmp);\n\n            } else {\n\n                dead_tmp(tmp);\n\n            }\n\n        }\n\n        break;\n\n    case 13: /* Misc data processing.  */\n\n        op = ((insn >> 22) & 6) | ((insn >> 7) & 1);\n\n        if (op < 4 && (insn & 0xf000) != 0xf000)\n\n            goto illegal_op;\n\n        switch (op) {\n\n        case 0: /* Register controlled shift.  */\n\n            tmp = load_reg(s, rn);\n\n            tmp2 = load_reg(s, rm);\n\n            if ((insn & 0x70) != 0)\n\n                goto illegal_op;\n\n            op = (insn >> 21) & 3;\n\n            logic_cc = (insn & (1 << 20)) != 0;\n\n            gen_arm_shift_reg(tmp, op, tmp2, logic_cc);\n\n            if (logic_cc)\n\n                gen_logic_CC(tmp);\n\n            store_reg_bx(env, s, rd, tmp);\n\n            break;\n\n        case 1: /* Sign/zero extend.  */\n\n            tmp = load_reg(s, rm);\n\n            shift = (insn >> 4) & 3;\n\n            /* ??? In many cases it's not neccessary to do a\n\n               rotate, a shift is sufficient.  */\n\n            if (shift != 0)\n\n                tcg_gen_rotri_i32(tmp, tmp, shift * 8);\n\n            op = (insn >> 20) & 7;\n\n            switch (op) {\n\n            case 0: gen_sxth(tmp);   break;\n\n            case 1: gen_uxth(tmp);   break;\n\n            case 2: gen_sxtb16(tmp); break;\n\n            case 3: gen_uxtb16(tmp); break;\n\n            case 4: gen_sxtb(tmp);   break;\n\n            case 5: gen_uxtb(tmp);   break;\n\n            default: goto illegal_op;\n\n            }\n\n            if (rn != 15) {\n\n                tmp2 = load_reg(s, rn);\n\n                if ((op >> 1) == 1) {\n\n                    gen_add16(tmp, tmp2);\n\n                } else {\n\n                    tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                    dead_tmp(tmp2);\n\n                }\n\n            }\n\n            store_reg(s, rd, tmp);\n\n            break;\n\n        case 2: /* SIMD add/subtract.  */\n\n            op = (insn >> 20) & 7;\n\n            shift = (insn >> 4) & 7;\n\n            if ((op & 3) == 3 || (shift & 3) == 3)\n\n                goto illegal_op;\n\n            tmp = load_reg(s, rn);\n\n            tmp2 = load_reg(s, rm);\n\n            gen_thumb2_parallel_addsub(op, shift, tmp, tmp2);\n\n            dead_tmp(tmp2);\n\n            store_reg(s, rd, tmp);\n\n            break;\n\n        case 3: /* Other data processing.  */\n\n            op = ((insn >> 17) & 0x38) | ((insn >> 4) & 7);\n\n            if (op < 4) {\n\n                /* Saturating add/subtract.  */\n\n                tmp = load_reg(s, rn);\n\n                tmp2 = load_reg(s, rm);\n\n                if (op & 1)\n\n                    gen_helper_double_saturate(tmp, tmp);\n\n                if (op & 2)\n\n                    gen_helper_sub_saturate(tmp, tmp2, tmp);\n\n                else\n\n                    gen_helper_add_saturate(tmp, tmp, tmp2);\n\n                dead_tmp(tmp2);\n\n            } else {\n\n                tmp = load_reg(s, rn);\n\n                switch (op) {\n\n                case 0x0a: /* rbit */\n\n                    gen_helper_rbit(tmp, tmp);\n\n                    break;\n\n                case 0x08: /* rev */\n\n                    tcg_gen_bswap32_i32(tmp, tmp);\n\n                    break;\n\n                case 0x09: /* rev16 */\n\n                    gen_rev16(tmp);\n\n                    break;\n\n                case 0x0b: /* revsh */\n\n                    gen_revsh(tmp);\n\n                    break;\n\n                case 0x10: /* sel */\n\n                    tmp2 = load_reg(s, rm);\n\n                    tmp3 = new_tmp();\n\n                    tcg_gen_ld_i32(tmp3, cpu_env, offsetof(CPUState, GE));\n\n                    gen_helper_sel_flags(tmp, tmp3, tmp, tmp2);\n\n                    dead_tmp(tmp3);\n\n                    dead_tmp(tmp2);\n\n                    break;\n\n                case 0x18: /* clz */\n\n                    gen_helper_clz(tmp, tmp);\n\n                    break;\n\n                default:\n\n                    goto illegal_op;\n\n                }\n\n            }\n\n            store_reg(s, rd, tmp);\n\n            break;\n\n        case 4: case 5: /* 32-bit multiply.  Sum of absolute differences.  */\n\n            op = (insn >> 4) & 0xf;\n\n            tmp = load_reg(s, rn);\n\n            tmp2 = load_reg(s, rm);\n\n            switch ((insn >> 20) & 7) {\n\n            case 0: /* 32 x 32 -> 32 */\n\n                tcg_gen_mul_i32(tmp, tmp, tmp2);\n\n                dead_tmp(tmp2);\n\n                if (rs != 15) {\n\n                    tmp2 = load_reg(s, rs);\n\n                    if (op)\n\n                        tcg_gen_sub_i32(tmp, tmp2, tmp);\n\n                    else\n\n                        tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                    dead_tmp(tmp2);\n\n                }\n\n                break;\n\n            case 1: /* 16 x 16 -> 32 */\n\n                gen_mulxy(tmp, tmp2, op & 2, op & 1);\n\n                dead_tmp(tmp2);\n\n                if (rs != 15) {\n\n                    tmp2 = load_reg(s, rs);\n\n                    gen_helper_add_setq(tmp, tmp, tmp2);\n\n                    dead_tmp(tmp2);\n\n                }\n\n                break;\n\n            case 2: /* Dual multiply add.  */\n\n            case 4: /* Dual multiply subtract.  */\n\n                if (op)\n\n                    gen_swap_half(tmp2);\n\n                gen_smul_dual(tmp, tmp2);\n\n                /* This addition cannot overflow.  */\n\n                if (insn & (1 << 22)) {\n\n                    tcg_gen_sub_i32(tmp, tmp, tmp2);\n\n                } else {\n\n                    tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                }\n\n                dead_tmp(tmp2);\n\n                if (rs != 15)\n\n                  {\n\n                    tmp2 = load_reg(s, rs);\n\n                    gen_helper_add_setq(tmp, tmp, tmp2);\n\n                    dead_tmp(tmp2);\n\n                  }\n\n                break;\n\n            case 3: /* 32 * 16 -> 32msb */\n\n                if (op)\n\n                    tcg_gen_sari_i32(tmp2, tmp2, 16);\n\n                else\n\n                    gen_sxth(tmp2);\n\n                tmp64 = gen_muls_i64_i32(tmp, tmp2);\n\n                tcg_gen_shri_i64(tmp64, tmp64, 16);\n\n                tmp = new_tmp();\n\n                tcg_gen_trunc_i64_i32(tmp, tmp64);\n\n                tcg_temp_free_i64(tmp64);\n\n                if (rs != 15)\n\n                  {\n\n                    tmp2 = load_reg(s, rs);\n\n                    gen_helper_add_setq(tmp, tmp, tmp2);\n\n                    dead_tmp(tmp2);\n\n                  }\n\n                break;\n\n            case 5: case 6: /* 32 * 32 -> 32msb (SMMUL, SMMLA, SMMLS) */\n\n                tmp64 = gen_muls_i64_i32(tmp, tmp2);\n\n                if (rs != 15) {\n\n                    tmp = load_reg(s, rs);\n\n                    if (insn & (1 << 20)) {\n\n                        tmp64 = gen_addq_msw(tmp64, tmp);\n\n                    } else {\n\n                        tmp64 = gen_subq_msw(tmp64, tmp);\n\n                    }\n\n                }\n\n                if (insn & (1 << 4)) {\n\n                    tcg_gen_addi_i64(tmp64, tmp64, 0x80000000u);\n\n                }\n\n                tcg_gen_shri_i64(tmp64, tmp64, 32);\n\n                tmp = new_tmp();\n\n                tcg_gen_trunc_i64_i32(tmp, tmp64);\n\n                tcg_temp_free_i64(tmp64);\n\n                break;\n\n            case 7: /* Unsigned sum of absolute differences.  */\n\n                gen_helper_usad8(tmp, tmp, tmp2);\n\n                dead_tmp(tmp2);\n\n                if (rs != 15) {\n\n                    tmp2 = load_reg(s, rs);\n\n                    tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                    dead_tmp(tmp2);\n\n                }\n\n                break;\n\n            }\n\n            store_reg(s, rd, tmp);\n\n            break;\n\n        case 6: case 7: /* 64-bit multiply, Divide.  */\n\n            op = ((insn >> 4) & 0xf) | ((insn >> 16) & 0x70);\n\n            tmp = load_reg(s, rn);\n\n            tmp2 = load_reg(s, rm);\n\n            if ((op & 0x50) == 0x10) {\n\n                /* sdiv, udiv */\n\n                if (!arm_feature(env, ARM_FEATURE_DIV))\n\n                    goto illegal_op;\n\n                if (op & 0x20)\n\n                    gen_helper_udiv(tmp, tmp, tmp2);\n\n                else\n\n                    gen_helper_sdiv(tmp, tmp, tmp2);\n\n                dead_tmp(tmp2);\n\n                store_reg(s, rd, tmp);\n\n            } else if ((op & 0xe) == 0xc) {\n\n                /* Dual multiply accumulate long.  */\n\n                if (op & 1)\n\n                    gen_swap_half(tmp2);\n\n                gen_smul_dual(tmp, tmp2);\n\n                if (op & 0x10) {\n\n                    tcg_gen_sub_i32(tmp, tmp, tmp2);\n\n                } else {\n\n                    tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                }\n\n                dead_tmp(tmp2);\n\n                /* BUGFIX */\n\n                tmp64 = tcg_temp_new_i64();\n\n                tcg_gen_ext_i32_i64(tmp64, tmp);\n\n                dead_tmp(tmp);\n\n                gen_addq(s, tmp64, rs, rd);\n\n                gen_storeq_reg(s, rs, rd, tmp64);\n\n                tcg_temp_free_i64(tmp64);\n\n            } else {\n\n                if (op & 0x20) {\n\n                    /* Unsigned 64-bit multiply  */\n\n                    tmp64 = gen_mulu_i64_i32(tmp, tmp2);\n\n                } else {\n\n                    if (op & 8) {\n\n                        /* smlalxy */\n\n                        gen_mulxy(tmp, tmp2, op & 2, op & 1);\n\n                        dead_tmp(tmp2);\n\n                        tmp64 = tcg_temp_new_i64();\n\n                        tcg_gen_ext_i32_i64(tmp64, tmp);\n\n                        dead_tmp(tmp);\n\n                    } else {\n\n                        /* Signed 64-bit multiply  */\n\n                        tmp64 = gen_muls_i64_i32(tmp, tmp2);\n\n                    }\n\n                }\n\n                if (op & 4) {\n\n                    /* umaal */\n\n                    gen_addq_lo(s, tmp64, rs);\n\n                    gen_addq_lo(s, tmp64, rd);\n\n                } else if (op & 0x40) {\n\n                    /* 64-bit accumulate.  */\n\n                    gen_addq(s, tmp64, rs, rd);\n\n                }\n\n                gen_storeq_reg(s, rs, rd, tmp64);\n\n                tcg_temp_free_i64(tmp64);\n\n            }\n\n            break;\n\n        }\n\n        break;\n\n    case 6: case 7: case 14: case 15:\n\n        /* Coprocessor.  */\n\n        if (((insn >> 24) & 3) == 3) {\n\n            /* Translate into the equivalent ARM encoding.  */\n\n            insn = (insn & 0xe2ffffff) | ((insn & (1 << 28)) >> 4);\n\n            if (disas_neon_data_insn(env, s, insn))\n\n                goto illegal_op;\n\n        } else {\n\n            if (insn & (1 << 28))\n\n                goto illegal_op;\n\n            if (disas_coproc_insn (env, s, insn))\n\n                goto illegal_op;\n\n        }\n\n        break;\n\n    case 8: case 9: case 10: case 11:\n\n        if (insn & (1 << 15)) {\n\n            /* Branches, misc control.  */\n\n            if (insn & 0x5000) {\n\n                /* Unconditional branch.  */\n\n                /* signextend(hw1[10:0]) -> offset[:12].  */\n\n                offset = ((int32_t)insn << 5) >> 9 & ~(int32_t)0xfff;\n\n                /* hw1[10:0] -> offset[11:1].  */\n\n                offset |= (insn & 0x7ff) << 1;\n\n                /* (~hw2[13, 11] ^ offset[24]) -> offset[23,22]\n\n                   offset[24:22] already have the same value because of the\n\n                   sign extension above.  */\n\n                offset ^= ((~insn) & (1 << 13)) << 10;\n\n                offset ^= ((~insn) & (1 << 11)) << 11;\n\n\n\n                if (insn & (1 << 14)) {\n\n                    /* Branch and link.  */\n\n                    tcg_gen_movi_i32(cpu_R[14], s->pc | 1);\n\n                }\n\n\n\n                offset += s->pc;\n\n                if (insn & (1 << 12)) {\n\n                    /* b/bl */\n\n                    gen_jmp(s, offset);\n\n                } else {\n\n                    /* blx */\n\n                    offset &= ~(uint32_t)2;\n\n                    gen_bx_im(s, offset);\n\n                }\n\n            } else if (((insn >> 23) & 7) == 7) {\n\n                /* Misc control */\n\n                if (insn & (1 << 13))\n\n                    goto illegal_op;\n\n\n\n                if (insn & (1 << 26)) {\n\n                    /* Secure monitor call (v6Z) */\n\n                    goto illegal_op; /* not implemented.  */\n\n                } else {\n\n                    op = (insn >> 20) & 7;\n\n                    switch (op) {\n\n                    case 0: /* msr cpsr.  */\n\n                        if (IS_M(env)) {\n\n                            tmp = load_reg(s, rn);\n\n                            addr = tcg_const_i32(insn & 0xff);\n\n                            gen_helper_v7m_msr(cpu_env, addr, tmp);\n\n                            tcg_temp_free_i32(addr);\n\n                            dead_tmp(tmp);\n\n                            gen_lookup_tb(s);\n\n                            break;\n\n                        }\n\n                        /* fall through */\n\n                    case 1: /* msr spsr.  */\n\n                        if (IS_M(env))\n\n                            goto illegal_op;\n\n                        tmp = load_reg(s, rn);\n\n                        if (gen_set_psr(s,\n\n                              msr_mask(env, s, (insn >> 8) & 0xf, op == 1),\n\n                              op == 1, tmp))\n\n                            goto illegal_op;\n\n                        break;\n\n                    case 2: /* cps, nop-hint.  */\n\n                        if (((insn >> 8) & 7) == 0) {\n\n                            gen_nop_hint(s, insn & 0xff);\n\n                        }\n\n                        /* Implemented as NOP in user mode.  */\n\n                        if (IS_USER(s))\n\n                            break;\n\n                        offset = 0;\n\n                        imm = 0;\n\n                        if (insn & (1 << 10)) {\n\n                            if (insn & (1 << 7))\n\n                                offset |= CPSR_A;\n\n                            if (insn & (1 << 6))\n\n                                offset |= CPSR_I;\n\n                            if (insn & (1 << 5))\n\n                                offset |= CPSR_F;\n\n                            if (insn & (1 << 9))\n\n                                imm = CPSR_A | CPSR_I | CPSR_F;\n\n                        }\n\n                        if (insn & (1 << 8)) {\n\n                            offset |= 0x1f;\n\n                            imm |= (insn & 0x1f);\n\n                        }\n\n                        if (offset) {\n\n                            gen_set_psr_im(s, offset, 0, imm);\n\n                        }\n\n                        break;\n\n                    case 3: /* Special control operations.  */\n\n                        ARCH(7);\n\n                        op = (insn >> 4) & 0xf;\n\n                        switch (op) {\n\n                        case 2: /* clrex */\n\n                            gen_clrex(s);\n\n                            break;\n\n                        case 4: /* dsb */\n\n                        case 5: /* dmb */\n\n                        case 6: /* isb */\n\n                            /* These execute as NOPs.  */\n\n                            break;\n\n                        default:\n\n                            goto illegal_op;\n\n                        }\n\n                        break;\n\n                    case 4: /* bxj */\n\n                        /* Trivial implementation equivalent to bx.  */\n\n                        tmp = load_reg(s, rn);\n\n                        gen_bx(s, tmp);\n\n                        break;\n\n                    case 5: /* Exception return.  */\n\n                        if (IS_USER(s)) {\n\n                            goto illegal_op;\n\n                        }\n\n                        if (rn != 14 || rd != 15) {\n\n                            goto illegal_op;\n\n                        }\n\n                        tmp = load_reg(s, rn);\n\n                        tcg_gen_subi_i32(tmp, tmp, insn & 0xff);\n\n                        gen_exception_return(s, tmp);\n\n                        break;\n\n                    case 6: /* mrs cpsr.  */\n\n                        tmp = new_tmp();\n\n                        if (IS_M(env)) {\n\n                            addr = tcg_const_i32(insn & 0xff);\n\n                            gen_helper_v7m_mrs(tmp, cpu_env, addr);\n\n                            tcg_temp_free_i32(addr);\n\n                        } else {\n\n                            gen_helper_cpsr_read(tmp);\n\n                        }\n\n                        store_reg(s, rd, tmp);\n\n                        break;\n\n                    case 7: /* mrs spsr.  */\n\n                        /* Not accessible in user mode.  */\n\n                        if (IS_USER(s) || IS_M(env))\n\n                            goto illegal_op;\n\n                        tmp = load_cpu_field(spsr);\n\n                        store_reg(s, rd, tmp);\n\n                        break;\n\n                    }\n\n                }\n\n            } else {\n\n                /* Conditional branch.  */\n\n                op = (insn >> 22) & 0xf;\n\n                /* Generate a conditional jump to next instruction.  */\n\n                s->condlabel = gen_new_label();\n\n                gen_test_cc(op ^ 1, s->condlabel);\n\n                s->condjmp = 1;\n\n\n\n                /* offset[11:1] = insn[10:0] */\n\n                offset = (insn & 0x7ff) << 1;\n\n                /* offset[17:12] = insn[21:16].  */\n\n                offset |= (insn & 0x003f0000) >> 4;\n\n                /* offset[31:20] = insn[26].  */\n\n                offset |= ((int32_t)((insn << 5) & 0x80000000)) >> 11;\n\n                /* offset[18] = insn[13].  */\n\n                offset |= (insn & (1 << 13)) << 5;\n\n                /* offset[19] = insn[11].  */\n\n                offset |= (insn & (1 << 11)) << 8;\n\n\n\n                /* jump to the offset */\n\n                gen_jmp(s, s->pc + offset);\n\n            }\n\n        } else {\n\n            /* Data processing immediate.  */\n\n            if (insn & (1 << 25)) {\n\n                if (insn & (1 << 24)) {\n\n                    if (insn & (1 << 20))\n\n                        goto illegal_op;\n\n                    /* Bitfield/Saturate.  */\n\n                    op = (insn >> 21) & 7;\n\n                    imm = insn & 0x1f;\n\n                    shift = ((insn >> 6) & 3) | ((insn >> 10) & 0x1c);\n\n                    if (rn == 15) {\n\n                        tmp = new_tmp();\n\n                        tcg_gen_movi_i32(tmp, 0);\n\n                    } else {\n\n                        tmp = load_reg(s, rn);\n\n                    }\n\n                    switch (op) {\n\n                    case 2: /* Signed bitfield extract.  */\n\n                        imm++;\n\n                        if (shift + imm > 32)\n\n                            goto illegal_op;\n\n                        if (imm < 32)\n\n                            gen_sbfx(tmp, shift, imm);\n\n                        break;\n\n                    case 6: /* Unsigned bitfield extract.  */\n\n                        imm++;\n\n                        if (shift + imm > 32)\n\n                            goto illegal_op;\n\n                        if (imm < 32)\n\n                            gen_ubfx(tmp, shift, (1u << imm) - 1);\n\n                        break;\n\n                    case 3: /* Bitfield insert/clear.  */\n\n                        if (imm < shift)\n\n                            goto illegal_op;\n\n                        imm = imm + 1 - shift;\n\n                        if (imm != 32) {\n\n                            tmp2 = load_reg(s, rd);\n\n                            gen_bfi(tmp, tmp2, tmp, shift, (1u << imm) - 1);\n\n                            dead_tmp(tmp2);\n\n                        }\n\n                        break;\n\n                    case 7:\n\n                        goto illegal_op;\n\n                    default: /* Saturate.  */\n\n                        if (shift) {\n\n                            if (op & 1)\n\n                                tcg_gen_sari_i32(tmp, tmp, shift);\n\n                            else\n\n                                tcg_gen_shli_i32(tmp, tmp, shift);\n\n                        }\n\n                        tmp2 = tcg_const_i32(imm);\n\n                        if (op & 4) {\n\n                            /* Unsigned.  */\n\n                            if ((op & 1) && shift == 0)\n\n                                gen_helper_usat16(tmp, tmp, tmp2);\n\n                            else\n\n                                gen_helper_usat(tmp, tmp, tmp2);\n\n                        } else {\n\n                            /* Signed.  */\n\n                            if ((op & 1) && shift == 0)\n\n                                gen_helper_ssat16(tmp, tmp, tmp2);\n\n                            else\n\n                                gen_helper_ssat(tmp, tmp, tmp2);\n\n                        }\n\n                        tcg_temp_free_i32(tmp2);\n\n                        break;\n\n                    }\n\n                    store_reg(s, rd, tmp);\n\n                } else {\n\n                    imm = ((insn & 0x04000000) >> 15)\n\n                          | ((insn & 0x7000) >> 4) | (insn & 0xff);\n\n                    if (insn & (1 << 22)) {\n\n                        /* 16-bit immediate.  */\n\n                        imm |= (insn >> 4) & 0xf000;\n\n                        if (insn & (1 << 23)) {\n\n                            /* movt */\n\n                            tmp = load_reg(s, rd);\n\n                            tcg_gen_ext16u_i32(tmp, tmp);\n\n                            tcg_gen_ori_i32(tmp, tmp, imm << 16);\n\n                        } else {\n\n                            /* movw */\n\n                            tmp = new_tmp();\n\n                            tcg_gen_movi_i32(tmp, imm);\n\n                        }\n\n                    } else {\n\n                        /* Add/sub 12-bit immediate.  */\n\n                        if (rn == 15) {\n\n                            offset = s->pc & ~(uint32_t)3;\n\n                            if (insn & (1 << 23))\n\n                                offset -= imm;\n\n                            else\n\n                                offset += imm;\n\n                            tmp = new_tmp();\n\n                            tcg_gen_movi_i32(tmp, offset);\n\n                        } else {\n\n                            tmp = load_reg(s, rn);\n\n                            if (insn & (1 << 23))\n\n                                tcg_gen_subi_i32(tmp, tmp, imm);\n\n                            else\n\n                                tcg_gen_addi_i32(tmp, tmp, imm);\n\n                        }\n\n                    }\n\n                    store_reg(s, rd, tmp);\n\n                }\n\n            } else {\n\n                int shifter_out = 0;\n\n                /* modified 12-bit immediate.  */\n\n                shift = ((insn & 0x04000000) >> 23) | ((insn & 0x7000) >> 12);\n\n                imm = (insn & 0xff);\n\n                switch (shift) {\n\n                case 0: /* XY */\n\n                    /* Nothing to do.  */\n\n                    break;\n\n                case 1: /* 00XY00XY */\n\n                    imm |= imm << 16;\n\n                    break;\n\n                case 2: /* XY00XY00 */\n\n                    imm |= imm << 16;\n\n                    imm <<= 8;\n\n                    break;\n\n                case 3: /* XYXYXYXY */\n\n                    imm |= imm << 16;\n\n                    imm |= imm << 8;\n\n                    break;\n\n                default: /* Rotated constant.  */\n\n                    shift = (shift << 1) | (imm >> 7);\n\n                    imm |= 0x80;\n\n                    imm = imm << (32 - shift);\n\n                    shifter_out = 1;\n\n                    break;\n\n                }\n\n                tmp2 = new_tmp();\n\n                tcg_gen_movi_i32(tmp2, imm);\n\n                rn = (insn >> 16) & 0xf;\n\n                if (rn == 15) {\n\n                    tmp = new_tmp();\n\n                    tcg_gen_movi_i32(tmp, 0);\n\n                } else {\n\n                    tmp = load_reg(s, rn);\n\n                }\n\n                op = (insn >> 21) & 0xf;\n\n                if (gen_thumb2_data_op(s, op, (insn & (1 << 20)) != 0,\n\n                                       shifter_out, tmp, tmp2))\n\n                    goto illegal_op;\n\n                dead_tmp(tmp2);\n\n                rd = (insn >> 8) & 0xf;\n\n                if (rd != 15) {\n\n                    store_reg(s, rd, tmp);\n\n                } else {\n\n                    dead_tmp(tmp);\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    case 12: /* Load/store single data item.  */\n\n        {\n\n        int postinc = 0;\n\n        int writeback = 0;\n\n        int user;\n\n        if ((insn & 0x01100000) == 0x01000000) {\n\n            if (disas_neon_ls_insn(env, s, insn))\n\n                goto illegal_op;\n\n            break;\n\n        }\n\n        user = IS_USER(s);\n\n        if (rn == 15) {\n\n            addr = new_tmp();\n\n            /* PC relative.  */\n\n            /* s->pc has already been incremented by 4.  */\n\n            imm = s->pc & 0xfffffffc;\n\n            if (insn & (1 << 23))\n\n                imm += insn & 0xfff;\n\n            else\n\n                imm -= insn & 0xfff;\n\n            tcg_gen_movi_i32(addr, imm);\n\n        } else {\n\n            addr = load_reg(s, rn);\n\n            if (insn & (1 << 23)) {\n\n                /* Positive offset.  */\n\n                imm = insn & 0xfff;\n\n                tcg_gen_addi_i32(addr, addr, imm);\n\n            } else {\n\n                op = (insn >> 8) & 7;\n\n                imm = insn & 0xff;\n\n                switch (op) {\n\n                case 0: case 8: /* Shifted Register.  */\n\n                    shift = (insn >> 4) & 0xf;\n\n                    if (shift > 3)\n\n                        goto illegal_op;\n\n                    tmp = load_reg(s, rm);\n\n                    if (shift)\n\n                        tcg_gen_shli_i32(tmp, tmp, shift);\n\n                    tcg_gen_add_i32(addr, addr, tmp);\n\n                    dead_tmp(tmp);\n\n                    break;\n\n                case 4: /* Negative offset.  */\n\n                    tcg_gen_addi_i32(addr, addr, -imm);\n\n                    break;\n\n                case 6: /* User privilege.  */\n\n                    tcg_gen_addi_i32(addr, addr, imm);\n\n                    user = 1;\n\n                    break;\n\n                case 1: /* Post-decrement.  */\n\n                    imm = -imm;\n\n                    /* Fall through.  */\n\n                case 3: /* Post-increment.  */\n\n                    postinc = 1;\n\n                    writeback = 1;\n\n                    break;\n\n                case 5: /* Pre-decrement.  */\n\n                    imm = -imm;\n\n                    /* Fall through.  */\n\n                case 7: /* Pre-increment.  */\n\n                    tcg_gen_addi_i32(addr, addr, imm);\n\n                    writeback = 1;\n\n                    break;\n\n                default:\n\n                    goto illegal_op;\n\n                }\n\n            }\n\n        }\n\n        op = ((insn >> 21) & 3) | ((insn >> 22) & 4);\n\n        if (insn & (1 << 20)) {\n\n            /* Load.  */\n\n            if (rs == 15 && op != 2) {\n\n                if (op & 2)\n\n                    goto illegal_op;\n\n                /* Memory hint.  Implemented as NOP.  */\n\n            } else {\n\n                switch (op) {\n\n                case 0: tmp = gen_ld8u(addr, user); break;\n\n                case 4: tmp = gen_ld8s(addr, user); break;\n\n                case 1: tmp = gen_ld16u(addr, user); break;\n\n                case 5: tmp = gen_ld16s(addr, user); break;\n\n                case 2: tmp = gen_ld32(addr, user); break;\n\n                default: goto illegal_op;\n\n                }\n\n                if (rs == 15) {\n\n                    gen_bx(s, tmp);\n\n                } else {\n\n                    store_reg(s, rs, tmp);\n\n                }\n\n            }\n\n        } else {\n\n            /* Store.  */\n\n            if (rs == 15)\n\n                goto illegal_op;\n\n            tmp = load_reg(s, rs);\n\n            switch (op) {\n\n            case 0: gen_st8(tmp, addr, user); break;\n\n            case 1: gen_st16(tmp, addr, user); break;\n\n            case 2: gen_st32(tmp, addr, user); break;\n\n            default: goto illegal_op;\n\n            }\n\n        }\n\n        if (postinc)\n\n            tcg_gen_addi_i32(addr, addr, imm);\n\n        if (writeback) {\n\n            store_reg(s, rn, addr);\n\n        } else {\n\n            dead_tmp(addr);\n\n        }\n\n        }\n\n        break;\n\n    default:\n\n        goto illegal_op;\n\n    }\n\n    return 0;\n\nillegal_op:\n\n    return 1;\n\n}\n", "idx": 26696}
{"project": "qemu", "commit_id": "2278a69e7020d86a8c73a28474e7709d3e7d5081", "target": 0, "func": "size_t iov_to_buf(const struct iovec *iov, const unsigned int iov_cnt, size_t iov_off,\n\n                  void *buf, size_t size)\n\n{\n\n    uint8_t *ptr;\n\n    size_t iovec_off, buf_off;\n\n    unsigned int i;\n\n\n\n    ptr = buf;\n\n    iovec_off = 0;\n\n    buf_off = 0;\n\n    for (i = 0; i < iov_cnt && size; i++) {\n\n        if (iov_off < (iovec_off + iov[i].iov_len)) {\n\n            size_t len = MIN((iovec_off + iov[i].iov_len) - iov_off , size);\n\n\n\n            memcpy(ptr + buf_off, iov[i].iov_base + (iov_off - iovec_off), len);\n\n\n\n            buf_off += len;\n\n            iov_off += len;\n\n            size -= len;\n\n        }\n\n        iovec_off += iov[i].iov_len;\n\n    }\n\n    return buf_off;\n\n}\n", "idx": 26697}
{"project": "qemu", "commit_id": "ac8c19ba742fcbc3d64a5390b32acc6479edd7e1", "target": 0, "func": "void hmp_savevm(Monitor *mon, const QDict *qdict)\n\n{\n\n    BlockDriverState *bs, *bs1;\n\n    QEMUSnapshotInfo sn1, *sn = &sn1, old_sn1, *old_sn = &old_sn1;\n\n    int ret;\n\n    QEMUFile *f;\n\n    int saved_vm_running;\n\n    uint64_t vm_state_size;\n\n    qemu_timeval tv;\n\n    struct tm tm;\n\n    const char *name = qdict_get_try_str(qdict, \"name\");\n\n    Error *local_err = NULL;\n\n    AioContext *aio_context;\n\n\n\n    if (!bdrv_all_can_snapshot(&bs)) {\n\n        monitor_printf(mon, \"Device '%s' is writable but does not \"\n\n                       \"support snapshots.\\n\", bdrv_get_device_name(bs));\n\n        return;\n\n    }\n\n\n\n    /* Delete old snapshots of the same name */\n\n    if (name && bdrv_all_delete_snapshot(name, &bs1, &local_err) < 0) {\n\n        error_reportf_err(local_err,\n\n                          \"Error while deleting snapshot on device '%s': \",\n\n                          bdrv_get_device_name(bs1));\n\n        return;\n\n    }\n\n\n\n    bs = bdrv_all_find_vmstate_bs();\n\n    if (bs == NULL) {\n\n        monitor_printf(mon, \"No block device can accept snapshots\\n\");\n\n        return;\n\n    }\n\n    aio_context = bdrv_get_aio_context(bs);\n\n\n\n    saved_vm_running = runstate_is_running();\n\n\n\n    ret = global_state_store();\n\n    if (ret) {\n\n        monitor_printf(mon, \"Error saving global state\\n\");\n\n        return;\n\n    }\n\n    vm_stop(RUN_STATE_SAVE_VM);\n\n\n\n    aio_context_acquire(aio_context);\n\n\n\n    memset(sn, 0, sizeof(*sn));\n\n\n\n    /* fill auxiliary fields */\n\n    qemu_gettimeofday(&tv);\n\n    sn->date_sec = tv.tv_sec;\n\n    sn->date_nsec = tv.tv_usec * 1000;\n\n    sn->vm_clock_nsec = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n\n\n\n    if (name) {\n\n        ret = bdrv_snapshot_find(bs, old_sn, name);\n\n        if (ret >= 0) {\n\n            pstrcpy(sn->name, sizeof(sn->name), old_sn->name);\n\n            pstrcpy(sn->id_str, sizeof(sn->id_str), old_sn->id_str);\n\n        } else {\n\n            pstrcpy(sn->name, sizeof(sn->name), name);\n\n        }\n\n    } else {\n\n        /* cast below needed for OpenBSD where tv_sec is still 'long' */\n\n        localtime_r((const time_t *)&tv.tv_sec, &tm);\n\n        strftime(sn->name, sizeof(sn->name), \"vm-%Y%m%d%H%M%S\", &tm);\n\n    }\n\n\n\n    /* save the VM state */\n\n    f = qemu_fopen_bdrv(bs, 1);\n\n    if (!f) {\n\n        monitor_printf(mon, \"Could not open VM state file\\n\");\n\n        goto the_end;\n\n    }\n\n    ret = qemu_savevm_state(f, &local_err);\n\n    vm_state_size = qemu_ftell(f);\n\n    qemu_fclose(f);\n\n    if (ret < 0) {\n\n        error_report_err(local_err);\n\n        goto the_end;\n\n    }\n\n\n\n    ret = bdrv_all_create_snapshot(sn, bs, vm_state_size, &bs);\n\n    if (ret < 0) {\n\n        monitor_printf(mon, \"Error while creating snapshot on '%s'\\n\",\n\n                       bdrv_get_device_name(bs));\n\n    }\n\n\n\n the_end:\n\n    aio_context_release(aio_context);\n\n    if (saved_vm_running) {\n\n        vm_start();\n\n    }\n\n}\n", "idx": 26698}
{"project": "qemu", "commit_id": "b25b387fa5928e516cb2c9e7fde68e958bd7e50a", "target": 0, "func": "static coroutine_fn int qcow2_co_pwritev(BlockDriverState *bs, uint64_t offset,\n\n                                         uint64_t bytes, QEMUIOVector *qiov,\n\n                                         int flags)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int offset_in_cluster;\n\n    int ret;\n\n    unsigned int cur_bytes; /* number of sectors in current iteration */\n\n    uint64_t cluster_offset;\n\n    QEMUIOVector hd_qiov;\n\n    uint64_t bytes_done = 0;\n\n    uint8_t *cluster_data = NULL;\n\n    QCowL2Meta *l2meta = NULL;\n\n\n\n    trace_qcow2_writev_start_req(qemu_coroutine_self(), offset, bytes);\n\n\n\n    qemu_iovec_init(&hd_qiov, qiov->niov);\n\n\n\n    s->cluster_cache_offset = -1; /* disable compressed cache */\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (bytes != 0) {\n\n\n\n        l2meta = NULL;\n\n\n\n        trace_qcow2_writev_start_part(qemu_coroutine_self());\n\n        offset_in_cluster = offset_into_cluster(s, offset);\n\n        cur_bytes = MIN(bytes, INT_MAX);\n\n        if (bs->encrypted) {\n\n            cur_bytes = MIN(cur_bytes,\n\n                            QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size\n\n                            - offset_in_cluster);\n\n        }\n\n\n\n        ret = qcow2_alloc_cluster_offset(bs, offset, &cur_bytes,\n\n                                         &cluster_offset, &l2meta);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        assert((cluster_offset & 511) == 0);\n\n\n\n        qemu_iovec_reset(&hd_qiov);\n\n        qemu_iovec_concat(&hd_qiov, qiov, bytes_done, cur_bytes);\n\n\n\n        if (bs->encrypted) {\n\n            Error *err = NULL;\n\n            assert(s->cipher);\n\n            if (!cluster_data) {\n\n                cluster_data = qemu_try_blockalign(bs->file->bs,\n\n                                                   QCOW_MAX_CRYPT_CLUSTERS\n\n                                                   * s->cluster_size);\n\n                if (cluster_data == NULL) {\n\n                    ret = -ENOMEM;\n\n                    goto fail;\n\n                }\n\n            }\n\n\n\n            assert(hd_qiov.size <=\n\n                   QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);\n\n            qemu_iovec_to_buf(&hd_qiov, 0, cluster_data, hd_qiov.size);\n\n\n\n            if (qcow2_encrypt_sectors(s, offset >> BDRV_SECTOR_BITS,\n\n                                      cluster_data,\n\n                                      cur_bytes >>BDRV_SECTOR_BITS,\n\n                                      true, &err) < 0) {\n\n                error_free(err);\n\n                ret = -EIO;\n\n                goto fail;\n\n            }\n\n\n\n            qemu_iovec_reset(&hd_qiov);\n\n            qemu_iovec_add(&hd_qiov, cluster_data, cur_bytes);\n\n        }\n\n\n\n        ret = qcow2_pre_write_overlap_check(bs, 0,\n\n                cluster_offset + offset_in_cluster, cur_bytes);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        /* If we need to do COW, check if it's possible to merge the\n\n         * writing of the guest data together with that of the COW regions.\n\n         * If it's not possible (or not necessary) then write the\n\n         * guest data now. */\n\n        if (!merge_cow(offset, cur_bytes, &hd_qiov, l2meta)) {\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO);\n\n            trace_qcow2_writev_data(qemu_coroutine_self(),\n\n                                    cluster_offset + offset_in_cluster);\n\n            ret = bdrv_co_pwritev(bs->file,\n\n                                  cluster_offset + offset_in_cluster,\n\n                                  cur_bytes, &hd_qiov, 0);\n\n            qemu_co_mutex_lock(&s->lock);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n        }\n\n\n\n        while (l2meta != NULL) {\n\n            QCowL2Meta *next;\n\n\n\n            ret = qcow2_alloc_cluster_link_l2(bs, l2meta);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            /* Take the request off the list of running requests */\n\n            if (l2meta->nb_clusters != 0) {\n\n                QLIST_REMOVE(l2meta, next_in_flight);\n\n            }\n\n\n\n            qemu_co_queue_restart_all(&l2meta->dependent_requests);\n\n\n\n            next = l2meta->next;\n\n            g_free(l2meta);\n\n            l2meta = next;\n\n        }\n\n\n\n        bytes -= cur_bytes;\n\n        offset += cur_bytes;\n\n        bytes_done += cur_bytes;\n\n        trace_qcow2_writev_done_part(qemu_coroutine_self(), cur_bytes);\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    while (l2meta != NULL) {\n\n        QCowL2Meta *next;\n\n\n\n        if (l2meta->nb_clusters != 0) {\n\n            QLIST_REMOVE(l2meta, next_in_flight);\n\n        }\n\n        qemu_co_queue_restart_all(&l2meta->dependent_requests);\n\n\n\n        next = l2meta->next;\n\n        g_free(l2meta);\n\n        l2meta = next;\n\n    }\n\n\n\n    qemu_iovec_destroy(&hd_qiov);\n\n    qemu_vfree(cluster_data);\n\n    trace_qcow2_writev_done_req(qemu_coroutine_self(), ret);\n\n\n\n    return ret;\n\n}\n", "idx": 26699}
{"project": "qemu", "commit_id": "d67f4aaae8379b44b3b51ff07df75f693012983c", "target": 0, "func": "static int open_self_maps(void *cpu_env, int fd)\n\n{\n\n#if defined(TARGET_ARM) || defined(TARGET_M68K) || defined(TARGET_UNICORE32)\n\n    CPUState *cpu = ENV_GET_CPU((CPUArchState *)cpu_env);\n\n    TaskState *ts = cpu->opaque;\n\n#endif\n\n    FILE *fp;\n\n    char *line = NULL;\n\n    size_t len = 0;\n\n    ssize_t read;\n\n\n\n    fp = fopen(\"/proc/self/maps\", \"r\");\n\n    if (fp == NULL) {\n\n        return -EACCES;\n\n    }\n\n\n\n    while ((read = getline(&line, &len, fp)) != -1) {\n\n        int fields, dev_maj, dev_min, inode;\n\n        uint64_t min, max, offset;\n\n        char flag_r, flag_w, flag_x, flag_p;\n\n        char path[512] = \"\";\n\n        fields = sscanf(line, \"%\"PRIx64\"-%\"PRIx64\" %c%c%c%c %\"PRIx64\" %x:%x %d\"\n\n                        \" %512s\", &min, &max, &flag_r, &flag_w, &flag_x,\n\n                        &flag_p, &offset, &dev_maj, &dev_min, &inode, path);\n\n\n\n        if ((fields < 10) || (fields > 11)) {\n\n            continue;\n\n        }\n\n        if (!strncmp(path, \"[stack]\", 7)) {\n\n            continue;\n\n        }\n\n        if (h2g_valid(min) && h2g_valid(max)) {\n\n            dprintf(fd, TARGET_ABI_FMT_lx \"-\" TARGET_ABI_FMT_lx\n\n                    \" %c%c%c%c %08\" PRIx64 \" %02x:%02x %d %s%s\\n\",\n\n                    h2g(min), h2g(max), flag_r, flag_w,\n\n                    flag_x, flag_p, offset, dev_maj, dev_min, inode,\n\n                    path[0] ? \"         \" : \"\", path);\n\n        }\n\n    }\n\n\n\n    free(line);\n\n    fclose(fp);\n\n\n\n#if defined(TARGET_ARM) || defined(TARGET_M68K) || defined(TARGET_UNICORE32)\n\n    dprintf(fd, \"%08llx-%08llx rw-p %08llx 00:00 0          [stack]\\n\",\n\n                (unsigned long long)ts->info->stack_limit,\n\n                (unsigned long long)(ts->info->start_stack +\n\n                                     (TARGET_PAGE_SIZE - 1)) & TARGET_PAGE_MASK,\n\n                (unsigned long long)0);\n\n#endif\n\n\n\n    return 0;\n\n}\n", "idx": 26700}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static void vnc_flush(VncState *vs)\n\n{\n\n    if (vs->output.offset)\n\n\tvnc_client_write(vs);\n\n}\n", "idx": 26701}
{"project": "qemu", "commit_id": "fae2afb10e3fdceab612c62a2b1e8b944ff578d9", "target": 0, "func": "static void qxl_log_cmd_draw(PCIQXLDevice *qxl, QXLDrawable *draw, int group_id)\n\n{\n\n    fprintf(stderr, \": surface_id %d type %s effect %s\",\n\n            draw->surface_id,\n\n            qxl_name(qxl_draw_type, draw->type),\n\n            qxl_name(qxl_draw_effect, draw->effect));\n\n    switch (draw->type) {\n\n    case QXL_DRAW_COPY:\n\n        qxl_log_cmd_draw_copy(qxl, &draw->u.copy, group_id);\n\n        break;\n\n    }\n\n}\n", "idx": 26702}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_enable_write_cache(BlockDriverState *bs)\n\n{\n\n    return bs->enable_write_cache;\n\n}\n", "idx": 26703}
{"project": "qemu", "commit_id": "67980031d234aa90524b83bb80bb5d1601d29076", "target": 0, "func": "static void device_set_realized(Object *obj, bool value, Error **errp)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    DeviceClass *dc = DEVICE_GET_CLASS(dev);\n\n    HotplugHandler *hotplug_ctrl;\n\n    BusState *bus;\n\n    Error *local_err = NULL;\n\n    bool unattached_parent = false;\n\n    static int unattached_count;\n\n\n\n    if (dev->hotplugged && !dc->hotpluggable) {\n\n        error_setg(errp, QERR_DEVICE_NO_HOTPLUG, object_get_typename(obj));\n\n        return;\n\n    }\n\n\n\n    if (value && !dev->realized) {\n\n        if (!obj->parent) {\n\n            gchar *name = g_strdup_printf(\"device[%d]\", unattached_count++);\n\n\n\n            object_property_add_child(container_get(qdev_get_machine(),\n\n                                                    \"/unattached\"),\n\n                                      name, obj, &error_abort);\n\n            unattached_parent = true;\n\n            g_free(name);\n\n        }\n\n\n\n        hotplug_ctrl = qdev_get_hotplug_handler(dev);\n\n        if (hotplug_ctrl) {\n\n            hotplug_handler_pre_plug(hotplug_ctrl, dev, &local_err);\n\n            if (local_err != NULL) {\n\n                goto fail;\n\n            }\n\n        }\n\n\n\n        if (dc->realize) {\n\n            dc->realize(dev, &local_err);\n\n        }\n\n\n\n        if (local_err != NULL) {\n\n            goto fail;\n\n        }\n\n\n\n        DEVICE_LISTENER_CALL(realize, Forward, dev);\n\n\n\n        if (hotplug_ctrl) {\n\n            hotplug_handler_plug(hotplug_ctrl, dev, &local_err);\n\n        }\n\n\n\n        if (local_err != NULL) {\n\n            goto post_realize_fail;\n\n        }\n\n\n\n        if (qdev_get_vmsd(dev)) {\n\n            vmstate_register_with_alias_id(dev, -1, qdev_get_vmsd(dev), dev,\n\n                                           dev->instance_id_alias,\n\n                                           dev->alias_required_for_version,\n\n                                           NULL);\n\n        }\n\n\n\n        QLIST_FOREACH(bus, &dev->child_bus, sibling) {\n\n            object_property_set_bool(OBJECT(bus), true, \"realized\",\n\n                                         &local_err);\n\n            if (local_err != NULL) {\n\n                goto child_realize_fail;\n\n            }\n\n        }\n\n        if (dev->hotplugged) {\n\n            device_reset(dev);\n\n        }\n\n        dev->pending_deleted_event = false;\n\n    } else if (!value && dev->realized) {\n\n        Error **local_errp = NULL;\n\n        QLIST_FOREACH(bus, &dev->child_bus, sibling) {\n\n            local_errp = local_err ? NULL : &local_err;\n\n            object_property_set_bool(OBJECT(bus), false, \"realized\",\n\n                                     local_errp);\n\n        }\n\n        if (qdev_get_vmsd(dev)) {\n\n            vmstate_unregister(dev, qdev_get_vmsd(dev), dev);\n\n        }\n\n        if (dc->unrealize) {\n\n            local_errp = local_err ? NULL : &local_err;\n\n            dc->unrealize(dev, local_errp);\n\n        }\n\n        dev->pending_deleted_event = true;\n\n        DEVICE_LISTENER_CALL(unrealize, Reverse, dev);\n\n    }\n\n\n\n    if (local_err != NULL) {\n\n        goto fail;\n\n    }\n\n\n\n    dev->realized = value;\n\n    return;\n\n\n\nchild_realize_fail:\n\n    QLIST_FOREACH(bus, &dev->child_bus, sibling) {\n\n        object_property_set_bool(OBJECT(bus), false, \"realized\",\n\n                                 NULL);\n\n    }\n\n\n\n    if (qdev_get_vmsd(dev)) {\n\n        vmstate_unregister(dev, qdev_get_vmsd(dev), dev);\n\n    }\n\n\n\npost_realize_fail:\n\n    if (dc->unrealize) {\n\n        dc->unrealize(dev, NULL);\n\n    }\n\n\n\nfail:\n\n    error_propagate(errp, local_err);\n\n    if (unattached_parent) {\n\n        object_unparent(OBJECT(dev));\n\n        unattached_count--;\n\n    }\n\n}\n", "idx": 26705}
{"project": "qemu", "commit_id": "2d6ee8e7e17227d5eb8c6e9a054dd88d5b37c5ae", "target": 0, "func": "static void serial_update_irq(SerialState *s)\n\n{\n\n    uint8_t tmp_iir = UART_IIR_NO_INT;\n\n\n\n    if ((s->ier & UART_IER_RLSI) && (s->lsr & UART_LSR_INT_ANY)) {\n\n        tmp_iir = UART_IIR_RLSI;\n\n    } else if ((s->ier & UART_IER_RDI) && s->timeout_ipending) {\n\n        /* Note that(s->ier & UART_IER_RDI) can mask this interrupt,\n\n         * this is not in the specification but is observed on existing\n\n         * hardware.  */\n\n        tmp_iir = UART_IIR_CTI;\n\n    } else if ((s->ier & UART_IER_RDI) && (s->lsr & UART_LSR_DR)) {\n\n        if (!(s->fcr & UART_FCR_FE)) {\n\n           tmp_iir = UART_IIR_RDI;\n\n        } else if (s->recv_fifo.count >= s->recv_fifo.itl) {\n\n           tmp_iir = UART_IIR_RDI;\n\n        }\n\n    } else if ((s->ier & UART_IER_THRI) && s->thr_ipending) {\n\n        tmp_iir = UART_IIR_THRI;\n\n    } else if ((s->ier & UART_IER_MSI) && (s->msr & UART_MSR_ANY_DELTA)) {\n\n        tmp_iir = UART_IIR_MSI;\n\n    }\n\n\n\n    s->iir = tmp_iir | (s->iir & 0xF0);\n\n\n\n    if (tmp_iir != UART_IIR_NO_INT) {\n\n        qemu_irq_raise(s->irq);\n\n    } else {\n\n        qemu_irq_lower(s->irq);\n\n    }\n\n}\n", "idx": 26706}
{"project": "qemu", "commit_id": "4f9242fc931ab5e5b1b753c8e5a76c50c0b0612e", "target": 0, "func": "static void spapr_add_lmbs(DeviceState *dev, uint64_t addr_start, uint64_t size,\n\n                           uint32_t node, bool dedicated_hp_event_source,\n\n                           Error **errp)\n\n{\n\n    sPAPRDRConnector *drc;\n\n    uint32_t nr_lmbs = size/SPAPR_MEMORY_BLOCK_SIZE;\n\n    int i, fdt_offset, fdt_size;\n\n    void *fdt;\n\n    uint64_t addr = addr_start;\n\n\n\n    for (i = 0; i < nr_lmbs; i++) {\n\n        drc = spapr_drc_by_id(TYPE_SPAPR_DRC_LMB,\n\n                              addr / SPAPR_MEMORY_BLOCK_SIZE);\n\n        g_assert(drc);\n\n\n\n        fdt = create_device_tree(&fdt_size);\n\n        fdt_offset = spapr_populate_memory_node(fdt, node, addr,\n\n                                                SPAPR_MEMORY_BLOCK_SIZE);\n\n\n\n        spapr_drc_attach(drc, dev, fdt, fdt_offset, !dev->hotplugged, errp);\n\n        addr += SPAPR_MEMORY_BLOCK_SIZE;\n\n        if (!dev->hotplugged) {\n\n            sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n            /* guests expect coldplugged LMBs to be pre-allocated */\n\n            drck->set_allocation_state(drc, SPAPR_DR_ALLOCATION_STATE_USABLE);\n\n            drck->set_isolation_state(drc, SPAPR_DR_ISOLATION_STATE_UNISOLATED);\n\n        }\n\n    }\n\n    /* send hotplug notification to the\n\n     * guest only in case of hotplugged memory\n\n     */\n\n    if (dev->hotplugged) {\n\n        if (dedicated_hp_event_source) {\n\n            drc = spapr_drc_by_id(TYPE_SPAPR_DRC_LMB,\n\n                                  addr_start / SPAPR_MEMORY_BLOCK_SIZE);\n\n            spapr_hotplug_req_add_by_count_indexed(SPAPR_DR_CONNECTOR_TYPE_LMB,\n\n                                                   nr_lmbs,\n\n                                                   spapr_drc_index(drc));\n\n        } else {\n\n            spapr_hotplug_req_add_by_count(SPAPR_DR_CONNECTOR_TYPE_LMB,\n\n                                           nr_lmbs);\n\n        }\n\n    }\n\n}\n", "idx": 26707}
{"project": "qemu", "commit_id": "0e87ba2ccbf900cc5a56b95e0671e5a5d2c2f6a0", "target": 0, "func": "static int vdi_open(BlockDriverState *bs, int flags)\n\n{\n\n    BDRVVdiState *s = bs->opaque;\n\n    VdiHeader header;\n\n    size_t bmap_size;\n\n    int ret;\n\n\n\n    logout(\"\\n\");\n\n\n\n    ret = bdrv_read(bs->file, 0, (uint8_t *)&header, 1);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    vdi_header_to_cpu(&header);\n\n#if defined(CONFIG_VDI_DEBUG)\n\n    vdi_header_print(&header);\n\n#endif\n\n\n\n    if (header.disk_size % SECTOR_SIZE != 0) {\n\n        /* 'VBoxManage convertfromraw' can create images with odd disk sizes.\n\n           We accept them but round the disk size to the next multiple of\n\n           SECTOR_SIZE. */\n\n        logout(\"odd disk size %\" PRIu64 \" B, round up\\n\", header.disk_size);\n\n        header.disk_size += SECTOR_SIZE - 1;\n\n        header.disk_size &= ~(SECTOR_SIZE - 1);\n\n    }\n\n\n\n    if (header.version != VDI_VERSION_1_1) {\n\n        logout(\"unsupported version %u.%u\\n\",\n\n               header.version >> 16, header.version & 0xffff);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.offset_bmap % SECTOR_SIZE != 0) {\n\n        /* We only support block maps which start on a sector boundary. */\n\n        logout(\"unsupported block map offset 0x%x B\\n\", header.offset_bmap);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.offset_data % SECTOR_SIZE != 0) {\n\n        /* We only support data blocks which start on a sector boundary. */\n\n        logout(\"unsupported data offset 0x%x B\\n\", header.offset_data);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.sector_size != SECTOR_SIZE) {\n\n        logout(\"unsupported sector size %u B\\n\", header.sector_size);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.block_size != 1 * MiB) {\n\n        logout(\"unsupported block size %u B\\n\", header.block_size);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.disk_size >\n\n               (uint64_t)header.blocks_in_image * header.block_size) {\n\n        logout(\"unsupported disk size %\" PRIu64 \" B\\n\", header.disk_size);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (!uuid_is_null(header.uuid_link)) {\n\n        logout(\"link uuid != 0, unsupported\\n\");\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (!uuid_is_null(header.uuid_parent)) {\n\n        logout(\"parent uuid != 0, unsupported\\n\");\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    }\n\n\n\n    bs->total_sectors = header.disk_size / SECTOR_SIZE;\n\n\n\n    s->block_size = header.block_size;\n\n    s->block_sectors = header.block_size / SECTOR_SIZE;\n\n    s->bmap_sector = header.offset_bmap / SECTOR_SIZE;\n\n    s->header = header;\n\n\n\n    bmap_size = header.blocks_in_image * sizeof(uint32_t);\n\n    bmap_size = (bmap_size + SECTOR_SIZE - 1) / SECTOR_SIZE;\n\n    if (bmap_size > 0) {\n\n        s->bmap = g_malloc(bmap_size * SECTOR_SIZE);\n\n    }\n\n    ret = bdrv_read(bs->file, s->bmap_sector, (uint8_t *)s->bmap, bmap_size);\n\n    if (ret < 0) {\n\n        goto fail_free_bmap;\n\n    }\n\n\n\n    /* Disable migration when vdi images are used */\n\n    error_set(&s->migration_blocker,\n\n              QERR_BLOCK_FORMAT_FEATURE_NOT_SUPPORTED,\n\n              \"vdi\", bs->device_name, \"live migration\");\n\n    migrate_add_blocker(s->migration_blocker);\n\n\n\n    return 0;\n\n\n\n fail_free_bmap:\n\n    g_free(s->bmap);\n\n\n\n fail:\n\n    return ret;\n\n}\n", "idx": 26708}
{"project": "qemu", "commit_id": "ee951a37d8873bff7aa58e23222dfd984111b6cb", "target": 0, "func": "qemu_irq isa_reserve_irq(int isairq)\n\n{\n\n    if (isairq < 0 || isairq > 15) {\n\n        hw_error(\"isa irq %d invalid\", isairq);\n\n    }\n\n    if (isabus->assigned & (1 << isairq)) {\n\n        hw_error(\"isa irq %d already assigned\", isairq);\n\n    }\n\n    isabus->assigned |= (1 << isairq);\n\n    return isabus->irqs[isairq];\n\n}\n", "idx": 26709}
{"project": "qemu", "commit_id": "524d18d8bd463431b120eeb5f9f3d1064a1c19e4", "target": 0, "func": "S390CPU *cpu_s390x_create(const char *cpu_model, Error **errp)\n\n{\n\n    static bool features_parsed;\n\n    char *name, *features;\n\n    const char *typename;\n\n    ObjectClass *oc;\n\n    CPUClass *cc;\n\n\n\n    name = g_strdup(cpu_model);\n\n    features = strchr(name, ',');\n\n    if (features) {\n\n        features[0] = 0;\n\n        features++;\n\n    }\n\n\n\n    oc = cpu_class_by_name(TYPE_S390_CPU, name);\n\n    if (!oc) {\n\n        error_setg(errp, \"Unknown CPU definition \\'%s\\'\", name);\n\n        g_free(name);\n\n        return NULL;\n\n    }\n\n    typename = object_class_get_name(oc);\n\n\n\n    if (!features_parsed) {\n\n        features_parsed = true;\n\n        cc = CPU_CLASS(oc);\n\n        cc->parse_features(typename, features, errp);\n\n    }\n\n    g_free(name);\n\n\n\n    if (*errp) {\n\n        return NULL;\n\n    }\n\n    return S390_CPU(CPU(object_new(typename)));\n\n}\n", "idx": 26710}
{"project": "qemu", "commit_id": "bab482d7405f9fe3cac9c213d60f9ca9442c047b", "target": 0, "func": "static void do_subchannel_work(SubchDev *sch, ORB *orb)\n\n{\n\n\n\n    SCSW *s = &sch->curr_status.scsw;\n\n\n\n    if (s->ctrl & SCSW_FCTL_CLEAR_FUNC) {\n\n        sch_handle_clear_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_HALT_FUNC) {\n\n        sch_handle_halt_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_START_FUNC) {\n\n        /* Triggered by both ssch and rsch. */\n\n        sch_handle_start_func(sch, orb);\n\n    } else {\n\n        /* Cannot happen. */\n\n        return;\n\n    }\n\n    css_inject_io_interrupt(sch);\n\n}\n", "idx": 26711}
{"project": "qemu", "commit_id": "bb551faa4ac8a798df9757c0ae26893041344bc3", "target": 0, "func": "static inline void pit_load_count(PITChannelState *s, int val)\n\n{\n\n    if (val == 0)\n\n        val = 0x10000;\n\n    s->count_load_time = cpu_get_ticks();\n\n    s->count_last_edge_check_time = s->count_load_time;\n\n    s->count = val;\n\n    if (s == &pit_channels[0] && val <= pit_min_timer_count) {\n\n        fprintf(stderr, \n\n                \"\\nWARNING: qemu: on your system, accurate timer emulation is impossible if its frequency is more than %d Hz. If using a 2.5.xx Linux kernel, you must patch asm/param.h to change HZ from 1000 to 100.\\n\\n\", \n\n                PIT_FREQ / pit_min_timer_count);\n\n    }\n\n}\n", "idx": 26712}
{"project": "qemu", "commit_id": "104981d52b63dc3d68f39d4442881c667f44bbb9", "target": 0, "func": "static int usbredir_handle_bulk_data(USBRedirDevice *dev, USBPacket *p,\n\n                                      uint8_t ep)\n\n{\n\n    AsyncURB *aurb = async_alloc(dev, p);\n\n    struct usb_redir_bulk_packet_header bulk_packet;\n\n\n\n    DPRINTF(\"bulk-out ep %02X len %zd id %u\\n\", ep,\n\n            p->iov.size, aurb->packet_id);\n\n\n\n    bulk_packet.endpoint  = ep;\n\n    bulk_packet.length    = p->iov.size;\n\n    bulk_packet.stream_id = 0;\n\n    aurb->bulk_packet = bulk_packet;\n\n\n\n    if (ep & USB_DIR_IN) {\n\n        usbredirparser_send_bulk_packet(dev->parser, aurb->packet_id,\n\n                                        &bulk_packet, NULL, 0);\n\n    } else {\n\n        uint8_t buf[p->iov.size];\n\n        usb_packet_copy(p, buf, p->iov.size);\n\n        usbredir_log_data(dev, \"bulk data out:\", buf, p->iov.size);\n\n        usbredirparser_send_bulk_packet(dev->parser, aurb->packet_id,\n\n                                        &bulk_packet, buf, p->iov.size);\n\n    }\n\n    usbredirparser_do_write(dev->parser);\n\n    return USB_RET_ASYNC;\n\n}\n", "idx": 26713}
{"project": "qemu", "commit_id": "f6bb84d53110398f4899c19dab4e0fe9908ec060", "target": 1, "func": "static inline TranslationBlock *tb_find(CPUState *cpu,\n\n                                        TranslationBlock *last_tb,\n\n                                        int tb_exit)\n\n{\n\n    CPUArchState *env = (CPUArchState *)cpu->env_ptr;\n\n    TranslationBlock *tb;\n\n    target_ulong cs_base, pc;\n\n    uint32_t flags;\n\n    bool acquired_tb_lock = false;\n\n\n\n    /* we record a subset of the CPU state. It will\n\n       always be the same before a given translated block\n\n       is executed. */\n\n    cpu_get_tb_cpu_state(env, &pc, &cs_base, &flags);\n\n    tb = atomic_rcu_read(&cpu->tb_jmp_cache[tb_jmp_cache_hash_func(pc)]);\n\n    if (unlikely(!tb || tb->pc != pc || tb->cs_base != cs_base ||\n\n                 tb->flags != flags ||\n\n                 tb->trace_vcpu_dstate != *cpu->trace_dstate)) {\n\n        tb = tb_htable_lookup(cpu, pc, cs_base, flags);\n\n        if (!tb) {\n\n\n\n            /* mmap_lock is needed by tb_gen_code, and mmap_lock must be\n\n             * taken outside tb_lock. As system emulation is currently\n\n             * single threaded the locks are NOPs.\n\n             */\n\n            mmap_lock();\n\n            tb_lock();\n\n            acquired_tb_lock = true;\n\n\n\n            /* There's a chance that our desired tb has been translated while\n\n             * taking the locks so we check again inside the lock.\n\n             */\n\n            tb = tb_htable_lookup(cpu, pc, cs_base, flags);\n\n            if (!tb) {\n\n                /* if no translated code available, then translate it now */\n\n                tb = tb_gen_code(cpu, pc, cs_base, flags, 0);\n\n            }\n\n\n\n            mmap_unlock();\n\n        }\n\n\n\n        /* We add the TB in the virtual pc hash table for the fast lookup */\n\n        atomic_set(&cpu->tb_jmp_cache[tb_jmp_cache_hash_func(pc)], tb);\n\n    }\n\n#ifndef CONFIG_USER_ONLY\n\n    /* We don't take care of direct jumps when address mapping changes in\n\n     * system emulation. So it's not safe to make a direct jump to a TB\n\n     * spanning two pages because the mapping for the second page can change.\n\n     */\n\n    if (tb->page_addr[1] != -1) {\n\n        last_tb = NULL;\n\n    }\n\n#endif\n\n    /* See if we can patch the calling TB. */\n\n    if (last_tb && !qemu_loglevel_mask(CPU_LOG_TB_NOCHAIN)) {\n\n        if (!acquired_tb_lock) {\n\n            tb_lock();\n\n            acquired_tb_lock = true;\n\n        }\n\n        if (!tb->invalid) {\n\n            tb_add_jump(last_tb, tb_exit, tb);\n\n        }\n\n    }\n\n    if (acquired_tb_lock) {\n\n        tb_unlock();\n\n    }\n\n    return tb;\n\n}\n", "idx": 26715}
{"project": "qemu", "commit_id": "339064d5063924e5176842abbf6c8089f3479c5b", "target": 1, "func": "void *qemu_blockalign(BlockDriverState *bs, size_t size)\n\n{\n\n    return qemu_memalign((bs && bs->buffer_alignment) ? bs->buffer_alignment : 512, size);\n\n}\n", "idx": 26717}
{"project": "qemu", "commit_id": "bbbc39ccacf66ef58261c155f9eed503947c3023", "target": 1, "func": "static int ehci_fill_queue(EHCIPacket *p)\n\n{\n\n    USBEndpoint *ep = p->packet.ep;\n\n    EHCIQueue *q = p->queue;\n\n    EHCIqtd qtd = p->qtd;\n\n    uint32_t qtdaddr;\n\n\n\n    for (;;) {\n\n        if (NLPTR_TBIT(qtd.next) != 0) {\n\n\n\n        qtdaddr = qtd.next;\n\n        /*\n\n         * Detect circular td lists, Windows creates these, counting on the\n\n         * active bit going low after execution to make the queue stop.\n\n         */\n\n        QTAILQ_FOREACH(p, &q->packets, next) {\n\n            if (p->qtdaddr == qtdaddr) {\n\n                goto leave;\n\n\n\n        if (get_dwords(q->ehci, NLPTR_GET(qtdaddr),\n\n                       (uint32_t *) &qtd, sizeof(EHCIqtd) >> 2) < 0) {\n\n            return -1;\n\n\n        ehci_trace_qtd(q, NLPTR_GET(qtdaddr), &qtd);\n\n        if (!(qtd.token & QTD_TOKEN_ACTIVE)) {\n\n\n\n\n\n\n\n        p = ehci_alloc_packet(q);\n\n        p->qtdaddr = qtdaddr;\n\n        p->qtd = qtd;\n\n        if (ehci_execute(p, \"queue\") == -1) {\n\n            return -1;\n\n\n        assert(p->packet.status == USB_RET_ASYNC);\n\n        p->async = EHCI_ASYNC_INFLIGHT;\n\n\nleave:\n\n    usb_device_flush_ep_queue(ep->dev, ep);\n\n    return 1;\n", "idx": 26718}
{"project": "qemu", "commit_id": "b5eff355460643d09e533024360fe0522f368c07", "target": 1, "func": "void bdrv_close(BlockDriverState *bs)\n\n{\n\n    if (bs->drv) {\n\n        if (bs->backing_hd)\n\n            bdrv_delete(bs->backing_hd);\n\n        bs->drv->bdrv_close(bs);\n\n        qemu_free(bs->opaque);\n\n#ifdef _WIN32\n\n        if (bs->is_temporary) {\n\n            unlink(bs->filename);\n\n        }\n\n#endif\n\n        bs->opaque = NULL;\n\n        bs->drv = NULL;\n\n\n\n        /* call the change callback */\n\n        bs->total_sectors = 0;\n\n        bs->media_changed = 1;\n\n        if (bs->change_cb)\n\n            bs->change_cb(bs->change_opaque);\n\n    }\n\n}\n", "idx": 26719}
{"project": "qemu", "commit_id": "e8a095dadb70e2ea6d5169d261920db3747bfa45", "target": 1, "func": "void bdrv_attach_aio_context(BlockDriverState *bs,\n\n                             AioContext *new_context)\n\n{\n\n    BdrvAioNotifier *ban;\n\n    BdrvChild *child;\n\n\n\n    if (!bs->drv) {\n\n        return;\n\n    }\n\n\n\n    bs->aio_context = new_context;\n\n\n\n    QLIST_FOREACH(child, &bs->children, next) {\n\n        bdrv_attach_aio_context(child->bs, new_context);\n\n    }\n\n    if (bs->drv->bdrv_attach_aio_context) {\n\n        bs->drv->bdrv_attach_aio_context(bs, new_context);\n\n    }\n\n\n\n    QLIST_FOREACH(ban, &bs->aio_notifiers, list) {\n\n        ban->attached_aio_context(new_context, ban->opaque);\n\n    }\n\n}\n", "idx": 26721}
{"project": "qemu", "commit_id": "e0e2d644096c79a71099b176d08f465f6803a8b1", "target": 1, "func": "static inline uint16_t vring_avail_flags(VirtQueue *vq)\n\n{\n\n    VRingMemoryRegionCaches *caches = atomic_rcu_read(&vq->vring.caches);\n\n    hwaddr pa = offsetof(VRingAvail, flags);\n\n    return virtio_lduw_phys_cached(vq->vdev, &caches->avail, pa);\n\n}\n", "idx": 26723}
{"project": "qemu", "commit_id": "b7d1f77adaab790d20232df261d4e2ff6a77f556", "target": 1, "func": "static void ppc_spapr_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    const char *boot_device = machine->boot_order;\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    PCIHostState *phb;\n\n    int i;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *rma_region;\n\n    void *rma = NULL;\n\n    hwaddr rma_alloc_size;\n\n    hwaddr node0_size = spapr_node0_size();\n\n    uint32_t initrd_base = 0;\n\n    long kernel_size = 0, initrd_size = 0;\n\n    long load_limit, rtas_limit, fw_size;\n\n    bool kernel_le = false;\n\n    char *filename;\n\n\n\n    msi_supported = true;\n\n\n\n    spapr = g_malloc0(sizeof(*spapr));\n\n    QLIST_INIT(&spapr->phbs);\n\n\n\n    cpu_ppc_hypercall = emulate_spapr_hypercall;\n\n\n\n    /* Allocate RMA if necessary */\n\n    rma_alloc_size = kvmppc_alloc_rma(&rma);\n\n\n\n    if (rma_alloc_size == -1) {\n\n        hw_error(\"qemu: Unable to create RMA\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    if (rma_alloc_size && (rma_alloc_size < node0_size)) {\n\n        spapr->rma_size = rma_alloc_size;\n\n    } else {\n\n        spapr->rma_size = node0_size;\n\n\n\n        /* With KVM, we don't actually know whether KVM supports an\n\n         * unbounded RMA (PR KVM) or is limited by the hash table size\n\n         * (HV KVM using VRMA), so we always assume the latter\n\n         *\n\n         * In that case, we also limit the initial allocations for RTAS\n\n         * etc... to 256M since we have no way to know what the VRMA size\n\n         * is going to be as it depends on the size of the hash table\n\n         * isn't determined yet.\n\n         */\n\n        if (kvm_enabled()) {\n\n            spapr->vrma_adjust = 1;\n\n            spapr->rma_size = MIN(spapr->rma_size, 0x10000000);\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size > node0_size) {\n\n        fprintf(stderr, \"Error: Numa node 0 has to span the RMA (%#08\"HWADDR_PRIx\")\\n\",\n\n                spapr->rma_size);\n\n        exit(1);\n\n    }\n\n\n\n    /* We place the device tree and RTAS just below either the top of the RMA,\n\n     * or just below 2GB, whichever is lowere, so that it can be\n\n     * processed with 32-bit real mode code if necessary */\n\n    rtas_limit = MIN(spapr->rma_size, 0x80000000);\n\n    spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;\n\n    spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE;\n\n    load_limit = spapr->fdt_addr - FW_OVERHEAD;\n\n\n\n    /* We aim for a hash table of size 1/128 the size of RAM.  The\n\n     * normal rule of thumb is 1/64 the size of RAM, but that's much\n\n     * more than needed for the Linux guests we support. */\n\n    spapr->htab_shift = 18; /* Minimum architected size */\n\n    while (spapr->htab_shift <= 46) {\n\n        if ((1ULL << (spapr->htab_shift + 7)) >= ram_size) {\n\n            break;\n\n        }\n\n        spapr->htab_shift++;\n\n    }\n\n\n\n    /* Set up Interrupt Controller before we create the VCPUs */\n\n    spapr->icp = xics_system_init(smp_cpus * kvmppc_smt_threads() / smp_threads,\n\n                                  XICS_IRQS);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n        cpu_model = kvm_enabled() ? \"host\" : \"POWER7\";\n\n    }\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        cpu = cpu_ppc_init(cpu_model);\n\n        if (cpu == NULL) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        env = &cpu->env;\n\n\n\n        /* Set time-base frequency to 512 MHz */\n\n        cpu_ppc_tb_init(env, TIMEBASE_FREQ);\n\n\n\n        /* PAPR always has exception vectors in RAM not ROM. To ensure this,\n\n         * MSR[IP] should never be set.\n\n         */\n\n        env->msr_mask &= ~(1 << 6);\n\n\n\n        /* Tell KVM that we're in PAPR mode */\n\n        if (kvm_enabled()) {\n\n            kvmppc_set_papr(cpu);\n\n        }\n\n\n\n        if (cpu->max_compat) {\n\n            if (ppc_set_compat(cpu, cpu->max_compat) < 0) {\n\n                exit(1);\n\n            }\n\n        }\n\n\n\n        xics_cpu_setup(spapr->icp, cpu);\n\n\n\n        qemu_register_reset(spapr_cpu_reset, cpu);\n\n    }\n\n\n\n    /* allocate RAM */\n\n    spapr->ram_limit = ram_size;\n\n    memory_region_allocate_system_memory(ram, NULL, \"ppc_spapr.ram\",\n\n                                         spapr->ram_limit);\n\n    memory_region_add_subregion(sysmem, 0, ram);\n\n\n\n    if (rma_alloc_size && rma) {\n\n        rma_region = g_new(MemoryRegion, 1);\n\n        memory_region_init_ram_ptr(rma_region, NULL, \"ppc_spapr.rma\",\n\n                                   rma_alloc_size, rma);\n\n        vmstate_register_ram_global(rma_region);\n\n        memory_region_add_subregion(sysmem, 0, rma_region);\n\n    }\n\n\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\n\n    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,\n\n                                           rtas_limit - spapr->rtas_addr);\n\n    if (spapr->rtas_size < 0) {\n\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n\n        exit(1);\n\n    }\n\n    if (spapr->rtas_size > RTAS_MAX_SIZE) {\n\n        hw_error(\"RTAS too big ! 0x%lx bytes (max is 0x%x)\\n\",\n\n                 spapr->rtas_size, RTAS_MAX_SIZE);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    /* Set up EPOW events infrastructure */\n\n    spapr_events_init(spapr);\n\n\n\n    /* Set up VIO bus */\n\n    spapr->vio_bus = spapr_vio_bus_init();\n\n\n\n    for (i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            spapr_vty_create(spapr->vio_bus, serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    /* We always have at least the nvram device on VIO */\n\n    spapr_create_nvram(spapr);\n\n\n\n    /* Set up PCI */\n\n    spapr_pci_msi_init(spapr, SPAPR_PCI_MSI_WINDOW);\n\n    spapr_pci_rtas_init();\n\n\n\n    phb = spapr_create_phb(spapr, 0);\n\n\n\n    for (i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!nd->model) {\n\n            nd->model = g_strdup(\"ibmveth\");\n\n        }\n\n\n\n        if (strcmp(nd->model, \"ibmveth\") == 0) {\n\n            spapr_vlan_create(spapr->vio_bus, nd);\n\n        } else {\n\n            pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {\n\n        spapr_vscsi_create(spapr->vio_bus);\n\n    }\n\n\n\n    /* Graphics */\n\n    if (spapr_vga_init(phb->bus)) {\n\n        spapr->has_graphics = true;\n\n    }\n\n\n\n    if (usb_enabled(spapr->has_graphics)) {\n\n        pci_create_simple(phb->bus, -1, \"pci-ohci\");\n\n        if (spapr->has_graphics) {\n\n            usbdevice_create(\"keyboard\");\n\n            usbdevice_create(\"mouse\");\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size < (MIN_RMA_SLOF << 20)) {\n\n        fprintf(stderr, \"qemu: pSeries SLOF firmware requires >= \"\n\n                \"%ldM guest RMA (Real Mode Area memory)\\n\", MIN_RMA_SLOF);\n\n        exit(1);\n\n    }\n\n\n\n    if (kernel_filename) {\n\n        uint64_t lowaddr = 0;\n\n\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n\n        if (kernel_size == ELF_LOAD_WRONG_ENDIAN) {\n\n            kernel_size = load_elf(kernel_filename,\n\n                                   translate_kernel_address, NULL,\n\n                                   NULL, &lowaddr, NULL, 0, ELF_MACHINE, 0);\n\n            kernel_le = kernel_size > 0;\n\n        }\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: error loading %s: %s\\n\",\n\n                    kernel_filename, load_elf_strerror(kernel_size));\n\n            exit(1);\n\n        }\n\n\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            /* Try to locate the initrd in the gap between the kernel\n\n             * and the firmware. Add a bit of space just in case\n\n             */\n\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              load_limit - initrd_base);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    }\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = FW_FILE_NAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n\n    if (fw_size < 0) {\n\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    spapr->entry_point = 0x100;\n\n\n\n    vmstate_register(NULL, 0, &vmstate_spapr, spapr);\n\n    register_savevm_live(NULL, \"spapr/htab\", -1, 1,\n\n                         &savevm_htab_handlers, spapr);\n\n\n\n    /* Prepare the device tree */\n\n    spapr->fdt_skel = spapr_create_fdt_skel(initrd_base, initrd_size,\n\n                                            kernel_size, kernel_le,\n\n                                            boot_device, kernel_cmdline,\n\n                                            spapr->epow_irq);\n\n    assert(spapr->fdt_skel != NULL);\n\n}\n", "idx": 26724}
{"project": "qemu", "commit_id": "e25cad6921ef78c8e2b7a4f59b03545bd675a9ad", "target": 1, "func": "static int sd_snapshot_delete(BlockDriverState *bs,\n\n                              const char *snapshot_id,\n\n                              const char *name,\n\n                              Error **errp)\n\n{\n\n    unsigned long snap_id = 0;\n\n    char snap_tag[SD_MAX_VDI_TAG_LEN];\n\n    Error *local_err = NULL;\n\n    int fd, ret;\n\n    char buf[SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN];\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    unsigned int wlen = SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN, rlen = 0;\n\n    uint32_t vid;\n\n    SheepdogVdiReq hdr = {\n\n        .opcode = SD_OP_DEL_VDI,\n\n        .data_length = wlen,\n\n        .flags = SD_FLAG_CMD_WRITE,\n\n    };\n\n    SheepdogVdiRsp *rsp = (SheepdogVdiRsp *)&hdr;\n\n\n\n    if (!remove_objects(s)) {\n\n        return -1;\n\n    }\n\n\n\n    memset(buf, 0, sizeof(buf));\n\n    memset(snap_tag, 0, sizeof(snap_tag));\n\n    pstrcpy(buf, SD_MAX_VDI_LEN, s->name);\n\n    ret = qemu_strtoul(snapshot_id, NULL, 10, &snap_id);\n\n    if (ret || snap_id > UINT32_MAX) {\n\n        error_setg(errp, \"Invalid snapshot ID: %s\",\n\n                         snapshot_id ? snapshot_id : \"<null>\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (snap_id) {\n\n        hdr.snapid = (uint32_t) snap_id;\n\n    } else {\n\n        pstrcpy(snap_tag, sizeof(snap_tag), snapshot_id);\n\n        pstrcpy(buf + SD_MAX_VDI_LEN, SD_MAX_VDI_TAG_LEN, snap_tag);\n\n    }\n\n\n\n    ret = find_vdi_name(s, s->name, snap_id, snap_tag, &vid, true,\n\n                        &local_err);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    fd = connect_to_sdog(s, &local_err);\n\n    if (fd < 0) {\n\n        error_report_err(local_err);\n\n        return -1;\n\n    }\n\n\n\n    ret = do_req(fd, s->bs, (SheepdogReq *)&hdr,\n\n                 buf, &wlen, &rlen);\n\n    closesocket(fd);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    switch (rsp->result) {\n\n    case SD_RES_NO_VDI:\n\n        error_report(\"%s was already deleted\", s->name);\n\n    case SD_RES_SUCCESS:\n\n        break;\n\n    default:\n\n        error_report(\"%s, %s\", sd_strerror(rsp->result), s->name);\n\n        return -1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 26725}
{"project": "qemu", "commit_id": "ebd9fbd7e102c533143c2c8372312b75c2b2678a", "target": 1, "func": "static int block_save_iterate(QEMUFile *f, void *opaque)\n\n{\n\n    int ret;\n\n    int64_t last_ftell = qemu_ftell(f);\n\n\n\n    DPRINTF(\"Enter save live iterate submitted %d transferred %d\\n\",\n\n            block_mig_state.submitted, block_mig_state.transferred);\n\n\n\n    ret = flush_blks(f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    blk_mig_reset_dirty_cursor();\n\n\n\n    /* control the rate of transfer */\n\n    blk_mig_lock();\n\n    while ((block_mig_state.submitted +\n\n            block_mig_state.read_done) * BLOCK_SIZE <\n\n           qemu_file_get_rate_limit(f)) {\n\n        blk_mig_unlock();\n\n        if (block_mig_state.bulk_completed == 0) {\n\n            /* first finish the bulk phase */\n\n            if (blk_mig_save_bulked_block(f) == 0) {\n\n                /* finished saving bulk on all devices */\n\n                block_mig_state.bulk_completed = 1;\n\n            }\n\n            ret = 0;\n\n        } else {\n\n            /* Always called with iothread lock taken for\n\n             * simplicity, block_save_complete also calls it.\n\n             */\n\n            qemu_mutex_lock_iothread();\n\n            ret = blk_mig_save_dirty_block(f, 1);\n\n            qemu_mutex_unlock_iothread();\n\n        }\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        blk_mig_lock();\n\n        if (ret != 0) {\n\n            /* no more dirty blocks */\n\n            break;\n\n        }\n\n    }\n\n    blk_mig_unlock();\n\n\n\n    ret = flush_blks(f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    qemu_put_be64(f, BLK_MIG_FLAG_EOS);\n\n    return qemu_ftell(f) - last_ftell;\n\n}\n", "idx": 26726}
{"project": "qemu", "commit_id": "94a8d39afd8ccfdbf578af04c3385fdb5f545af1", "target": 1, "func": "void kvm_flush_coalesced_mmio_buffer(void)\n\n{\n\n#ifdef KVM_CAP_COALESCED_MMIO\n\n    KVMState *s = kvm_state;\n\n    if (s->coalesced_mmio_ring) {\n\n        struct kvm_coalesced_mmio_ring *ring = s->coalesced_mmio_ring;\n\n        while (ring->first != ring->last) {\n\n            struct kvm_coalesced_mmio *ent;\n\n\n\n            ent = &ring->coalesced_mmio[ring->first];\n\n\n\n            cpu_physical_memory_write(ent->phys_addr, ent->data, ent->len);\n\n            smp_wmb();\n\n            ring->first = (ring->first + 1) % KVM_COALESCED_MMIO_MAX;\n\n        }\n\n    }\n\n#endif\n\n}\n", "idx": 26731}
{"project": "qemu", "commit_id": "ed1dda53d073acdb52889aa30f9d251061b053bd", "target": 1, "func": "static always_inline void gen_intermediate_code_internal (CPUState *env,\n\n                                                          TranslationBlock *tb,\n\n                                                          int search_pc)\n\n{\n\n#if defined ALPHA_DEBUG_DISAS\n\n    static int insn_count;\n\n#endif\n\n    DisasContext ctx, *ctxp = &ctx;\n\n    target_ulong pc_start;\n\n    uint32_t insn;\n\n    uint16_t *gen_opc_end;\n\n    CPUBreakpoint *bp;\n\n    int j, lj = -1;\n\n    int ret;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    pc_start = tb->pc;\n\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n    ctx.pc = pc_start;\n\n    ctx.amask = env->amask;\n\n#if defined (CONFIG_USER_ONLY)\n\n    ctx.mem_idx = 0;\n\n#else\n\n    ctx.mem_idx = ((env->ps >> 3) & 3);\n\n    ctx.pal_mode = env->ipr[IPR_EXC_ADDR] & 1;\n\n#endif\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0)\n\n        max_insns = CF_COUNT_MASK;\n\n\n\n    gen_icount_start();\n\n    for (ret = 0; ret == 0;) {\n\n        if (unlikely(!TAILQ_EMPTY(&env->breakpoints))) {\n\n            TAILQ_FOREACH(bp, &env->breakpoints, entry) {\n\n                if (bp->pc == ctx.pc) {\n\n                    gen_excp(&ctx, EXCP_DEBUG, 0);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (search_pc) {\n\n            j = gen_opc_ptr - gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    gen_opc_instr_start[lj++] = 0;\n\n                gen_opc_pc[lj] = ctx.pc;\n\n                gen_opc_instr_start[lj] = 1;\n\n                gen_opc_icount[lj] = num_insns;\n\n            }\n\n        }\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))\n\n            gen_io_start();\n\n#if defined ALPHA_DEBUG_DISAS\n\n        insn_count++;\n\n        LOG_DISAS(\"pc \" TARGET_FMT_lx \" mem_idx %d\\n\",\n\n                  ctx.pc, ctx.mem_idx);\n\n#endif\n\n        insn = ldl_code(ctx.pc);\n\n#if defined ALPHA_DEBUG_DISAS\n\n        insn_count++;\n\n        LOG_DISAS(\"opcode %08x %d\\n\", insn, insn_count);\n\n#endif\n\n        num_insns++;\n\n        ctx.pc += 4;\n\n        ret = translate_one(ctxp, insn);\n\n        if (ret != 0)\n\n            break;\n\n        /* if we reach a page boundary or are single stepping, stop\n\n         * generation\n\n         */\n\n        if (((ctx.pc & (TARGET_PAGE_SIZE - 1)) == 0) ||\n\n            num_insns >= max_insns) {\n\n            break;\n\n        }\n\n\n\n        if (env->singlestep_enabled) {\n\n            gen_excp(&ctx, EXCP_DEBUG, 0);\n\n            break;\n\n\t}\n\n\n\n#if defined (DO_SINGLE_STEP)\n\n        break;\n\n#endif\n\n    }\n\n    if (ret != 1 && ret != 3) {\n\n        tcg_gen_movi_i64(cpu_pc, ctx.pc);\n\n    }\n\n#if defined (DO_TB_FLUSH)\n\n    gen_helper_tb_flush();\n\n#endif\n\n    if (tb->cflags & CF_LAST_IO)\n\n        gen_io_end();\n\n    /* Generate the return instruction */\n\n    tcg_gen_exit_tb(0);\n\n    gen_icount_end(tb, num_insns);\n\n    *gen_opc_ptr = INDEX_op_end;\n\n    if (search_pc) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n    } else {\n\n        tb->size = ctx.pc - pc_start;\n\n        tb->icount = num_insns;\n\n    }\n\n#if defined ALPHA_DEBUG_DISAS\n\n    log_cpu_state_mask(CPU_LOG_TB_CPU, env, 0);\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n        log_target_disas(pc_start, ctx.pc - pc_start, 1);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n}\n", "idx": 26734}
{"project": "qemu", "commit_id": "e954ea2873fd6621d199d4a1a012fc0bc0292924", "target": 1, "func": "static void qxl_add_memslot(PCIQXLDevice *d, uint32_t slot_id, uint64_t delta,\n\n                            qxl_async_io async)\n\n{\n\n    static const int regions[] = {\n\n        QXL_RAM_RANGE_INDEX,\n\n        QXL_VRAM_RANGE_INDEX,\n\n        QXL_VRAM64_RANGE_INDEX,\n\n    };\n\n    uint64_t guest_start;\n\n    uint64_t guest_end;\n\n    int pci_region;\n\n    pcibus_t pci_start;\n\n    pcibus_t pci_end;\n\n    intptr_t virt_start;\n\n    QXLDevMemSlot memslot;\n\n    int i;\n\n\n\n    guest_start = le64_to_cpu(d->guest_slots[slot_id].slot.mem_start);\n\n    guest_end   = le64_to_cpu(d->guest_slots[slot_id].slot.mem_end);\n\n\n\n    trace_qxl_memslot_add_guest(d->id, slot_id, guest_start, guest_end);\n\n\n\n    PANIC_ON(slot_id >= NUM_MEMSLOTS);\n\n    PANIC_ON(guest_start > guest_end);\n\n\n\n    for (i = 0; i < ARRAY_SIZE(regions); i++) {\n\n        pci_region = regions[i];\n\n        pci_start = d->pci.io_regions[pci_region].addr;\n\n        pci_end = pci_start + d->pci.io_regions[pci_region].size;\n\n        /* mapped? */\n\n        if (pci_start == -1) {\n\n            continue;\n\n        }\n\n        /* start address in range ? */\n\n        if (guest_start < pci_start || guest_start > pci_end) {\n\n            continue;\n\n        }\n\n        /* end address in range ? */\n\n        if (guest_end > pci_end) {\n\n            continue;\n\n        }\n\n        /* passed */\n\n        break;\n\n    }\n\n    PANIC_ON(i == ARRAY_SIZE(regions)); /* finished loop without match */\n\n\n\n    switch (pci_region) {\n\n    case QXL_RAM_RANGE_INDEX:\n\n        virt_start = (intptr_t)memory_region_get_ram_ptr(&d->vga.vram);\n\n        break;\n\n    case QXL_VRAM_RANGE_INDEX:\n\n    case 4 /* vram 64bit */:\n\n        virt_start = (intptr_t)memory_region_get_ram_ptr(&d->vram_bar);\n\n        break;\n\n    default:\n\n        /* should not happen */\n\n        abort();\n\n    }\n\n\n\n    memslot.slot_id = slot_id;\n\n    memslot.slot_group_id = MEMSLOT_GROUP_GUEST; /* guest group */\n\n    memslot.virt_start = virt_start + (guest_start - pci_start);\n\n    memslot.virt_end   = virt_start + (guest_end   - pci_start);\n\n    memslot.addr_delta = memslot.virt_start - delta;\n\n    memslot.generation = d->rom->slot_generation = 0;\n\n    qxl_rom_set_dirty(d);\n\n\n\n    qemu_spice_add_memslot(&d->ssd, &memslot, async);\n\n    d->guest_slots[slot_id].ptr = (void*)memslot.virt_start;\n\n    d->guest_slots[slot_id].size = memslot.virt_end - memslot.virt_start;\n\n    d->guest_slots[slot_id].delta = delta;\n\n    d->guest_slots[slot_id].active = 1;\n\n}\n", "idx": 26735}
{"project": "qemu", "commit_id": "894e02804c862c6940b43a0a488164655d3fb3f0", "target": 1, "func": "static int nbd_negotiate_handle_info(NBDClient *client, uint16_t myflags,\n\n                                     Error **errp)\n\n{\n\n    int rc;\n\n    char name[NBD_MAX_NAME_SIZE + 1];\n\n    NBDExport *exp;\n\n    uint16_t requests;\n\n    uint16_t request;\n\n    uint32_t namelen;\n\n    bool sendname = false;\n\n    bool blocksize = false;\n\n    uint32_t sizes[3];\n\n    char buf[sizeof(uint64_t) + sizeof(uint16_t)];\n\n    const char *msg;\n\n\n\n    /* Client sends:\n\n        4 bytes: L, name length (can be 0)\n\n        L bytes: export name\n\n        2 bytes: N, number of requests (can be 0)\n\n        N * 2 bytes: N requests\n\n    */\n\n    if (client->optlen < sizeof(namelen) + sizeof(requests)) {\n\n        msg = \"overall request too short\";\n\n        goto invalid;\n\n    }\n\n    if (nbd_read(client->ioc, &namelen, sizeof(namelen), errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    be32_to_cpus(&namelen);\n\n    client->optlen -= sizeof(namelen);\n\n    if (namelen > client->optlen - sizeof(requests) ||\n\n        (client->optlen - namelen) % 2)\n\n    {\n\n        msg = \"name length is incorrect\";\n\n        goto invalid;\n\n    }\n\n    if (namelen >= sizeof(name)) {\n\n        msg = \"name too long for qemu\";\n\n        goto invalid;\n\n    }\n\n    if (nbd_read(client->ioc, name, namelen, errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    name[namelen] = '\\0';\n\n    client->optlen -= namelen;\n\n    trace_nbd_negotiate_handle_export_name_request(name);\n\n\n\n    if (nbd_read(client->ioc, &requests, sizeof(requests), errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    be16_to_cpus(&requests);\n\n    client->optlen -= sizeof(requests);\n\n    trace_nbd_negotiate_handle_info_requests(requests);\n\n    if (requests != client->optlen / sizeof(request)) {\n\n        msg = \"incorrect number of  requests for overall length\";\n\n        goto invalid;\n\n    }\n\n    while (requests--) {\n\n        if (nbd_read(client->ioc, &request, sizeof(request), errp) < 0) {\n\n            return -EIO;\n\n        }\n\n        be16_to_cpus(&request);\n\n        client->optlen -= sizeof(request);\n\n        trace_nbd_negotiate_handle_info_request(request,\n\n                                                nbd_info_lookup(request));\n\n        /* We care about NBD_INFO_NAME and NBD_INFO_BLOCK_SIZE;\n\n         * everything else is either a request we don't know or\n\n         * something we send regardless of request */\n\n        switch (request) {\n\n        case NBD_INFO_NAME:\n\n            sendname = true;\n\n            break;\n\n        case NBD_INFO_BLOCK_SIZE:\n\n            blocksize = true;\n\n            break;\n\n        }\n\n    }\n\n    assert(client->optlen == 0);\n\n\n\n    exp = nbd_export_find(name);\n\n    if (!exp) {\n\n        return nbd_negotiate_send_rep_err(client, NBD_REP_ERR_UNKNOWN,\n\n                                          errp, \"export '%s' not present\",\n\n                                          name);\n\n    }\n\n\n\n    /* Don't bother sending NBD_INFO_NAME unless client requested it */\n\n    if (sendname) {\n\n        rc = nbd_negotiate_send_info(client, NBD_INFO_NAME, namelen, name,\n\n                                     errp);\n\n        if (rc < 0) {\n\n            return rc;\n\n        }\n\n    }\n\n\n\n    /* Send NBD_INFO_DESCRIPTION only if available, regardless of\n\n     * client request */\n\n    if (exp->description) {\n\n        size_t len = strlen(exp->description);\n\n\n\n        rc = nbd_negotiate_send_info(client, NBD_INFO_DESCRIPTION,\n\n                                     len, exp->description, errp);\n\n        if (rc < 0) {\n\n            return rc;\n\n        }\n\n    }\n\n\n\n    /* Send NBD_INFO_BLOCK_SIZE always, but tweak the minimum size\n\n     * according to whether the client requested it, and according to\n\n     * whether this is OPT_INFO or OPT_GO. */\n\n    /* minimum - 1 for back-compat, or 512 if client is new enough.\n\n     * TODO: consult blk_bs(blk)->bl.request_alignment? */\n\n    sizes[0] =\n\n            (client->opt == NBD_OPT_INFO || blocksize) ? BDRV_SECTOR_SIZE : 1;\n\n    /* preferred - Hard-code to 4096 for now.\n\n     * TODO: is blk_bs(blk)->bl.opt_transfer appropriate? */\n\n    sizes[1] = 4096;\n\n    /* maximum - At most 32M, but smaller as appropriate. */\n\n    sizes[2] = MIN(blk_get_max_transfer(exp->blk), NBD_MAX_BUFFER_SIZE);\n\n    trace_nbd_negotiate_handle_info_block_size(sizes[0], sizes[1], sizes[2]);\n\n    cpu_to_be32s(&sizes[0]);\n\n    cpu_to_be32s(&sizes[1]);\n\n    cpu_to_be32s(&sizes[2]);\n\n    rc = nbd_negotiate_send_info(client, NBD_INFO_BLOCK_SIZE,\n\n                                 sizeof(sizes), sizes, errp);\n\n    if (rc < 0) {\n\n        return rc;\n\n    }\n\n\n\n    /* Send NBD_INFO_EXPORT always */\n\n    trace_nbd_negotiate_new_style_size_flags(exp->size,\n\n                                             exp->nbdflags | myflags);\n\n    stq_be_p(buf, exp->size);\n\n    stw_be_p(buf + 8, exp->nbdflags | myflags);\n\n    rc = nbd_negotiate_send_info(client, NBD_INFO_EXPORT,\n\n                                 sizeof(buf), buf, errp);\n\n    if (rc < 0) {\n\n        return rc;\n\n    }\n\n\n\n    /* If the client is just asking for NBD_OPT_INFO, but forgot to\n\n     * request block sizes, return an error.\n\n     * TODO: consult blk_bs(blk)->request_align, and only error if it\n\n     * is not 1? */\n\n    if (client->opt == NBD_OPT_INFO && !blocksize) {\n\n        return nbd_negotiate_send_rep_err(client,\n\n                                          NBD_REP_ERR_BLOCK_SIZE_REQD,\n\n                                          errp,\n\n                                          \"request NBD_INFO_BLOCK_SIZE to \"\n\n                                          \"use this export\");\n\n    }\n\n\n\n    /* Final reply */\n\n    rc = nbd_negotiate_send_rep(client, NBD_REP_ACK, errp);\n\n    if (rc < 0) {\n\n        return rc;\n\n    }\n\n\n\n    if (client->opt == NBD_OPT_GO) {\n\n        client->exp = exp;\n\n        QTAILQ_INSERT_TAIL(&client->exp->clients, client, next);\n\n        nbd_export_get(client->exp);\n\n        rc = 1;\n\n    }\n\n    return rc;\n\n\n\n invalid:\n\n    if (nbd_drop(client->ioc, client->optlen, errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    return nbd_negotiate_send_rep_err(client, NBD_REP_ERR_INVALID,\n\n                                      errp, \"%s\", msg);\n\n}\n", "idx": 26736}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void qemu_rdma_init_one_block(void *host_addr,\n\n    ram_addr_t block_offset, ram_addr_t length, void *opaque)\n\n{\n\n    __qemu_rdma_add_block(opaque, host_addr, block_offset, length);\n\n}\n", "idx": 26737}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "VncJob *vnc_job_new(VncState *vs)\n\n{\n\n    VncJob *job = g_malloc0(sizeof(VncJob));\n\n\n\n    job->vs = vs;\n\n    vnc_lock_queue(queue);\n\n    QLIST_INIT(&job->rectangles);\n\n    vnc_unlock_queue(queue);\n\n    return job;\n\n}\n", "idx": 26738}
{"project": "qemu", "commit_id": "73479c5c87bf431c6344a80ab01456ed979447f1", "target": 1, "func": "void superh_cpu_do_interrupt(CPUState *cs)\n\n{\n\n    SuperHCPU *cpu = SUPERH_CPU(cs);\n\n    CPUSH4State *env = &cpu->env;\n\n    int do_irq = cs->interrupt_request & CPU_INTERRUPT_HARD;\n\n    int do_exp, irq_vector = cs->exception_index;\n\n\n\n    /* prioritize exceptions over interrupts */\n\n\n\n    do_exp = cs->exception_index != -1;\n\n    do_irq = do_irq && (cs->exception_index == -1);\n\n\n\n    if (env->sr & (1u << SR_BL)) {\n\n        if (do_exp && cs->exception_index != 0x1e0) {\n\n            cs->exception_index = 0x000; /* masked exception -> reset */\n\n        }\n\n        if (do_irq && !env->in_sleep) {\n\n            return; /* masked */\n\n        }\n\n    }\n\n    env->in_sleep = 0;\n\n\n\n    if (do_irq) {\n\n        irq_vector = sh_intc_get_pending_vector(env->intc_handle,\n\n\t\t\t\t\t\t(env->sr >> 4) & 0xf);\n\n        if (irq_vector == -1) {\n\n            return; /* masked */\n\n\t}\n\n    }\n\n\n\n    if (qemu_loglevel_mask(CPU_LOG_INT)) {\n\n\tconst char *expname;\n\n        switch (cs->exception_index) {\n\n\tcase 0x0e0:\n\n\t    expname = \"addr_error\";\n\n\t    break;\n\n\tcase 0x040:\n\n\t    expname = \"tlb_miss\";\n\n\t    break;\n\n\tcase 0x0a0:\n\n\t    expname = \"tlb_violation\";\n\n\t    break;\n\n\tcase 0x180:\n\n\t    expname = \"illegal_instruction\";\n\n\t    break;\n\n\tcase 0x1a0:\n\n\t    expname = \"slot_illegal_instruction\";\n\n\t    break;\n\n\tcase 0x800:\n\n\t    expname = \"fpu_disable\";\n\n\t    break;\n\n\tcase 0x820:\n\n\t    expname = \"slot_fpu\";\n\n\t    break;\n\n\tcase 0x100:\n\n\t    expname = \"data_write\";\n\n\t    break;\n\n\tcase 0x060:\n\n\t    expname = \"dtlb_miss_write\";\n\n\t    break;\n\n\tcase 0x0c0:\n\n\t    expname = \"dtlb_violation_write\";\n\n\t    break;\n\n\tcase 0x120:\n\n\t    expname = \"fpu_exception\";\n\n\t    break;\n\n\tcase 0x080:\n\n\t    expname = \"initial_page_write\";\n\n\t    break;\n\n\tcase 0x160:\n\n\t    expname = \"trapa\";\n\n\t    break;\n\n\tdefault:\n\n            expname = do_irq ? \"interrupt\" : \"???\";\n\n            break;\n\n\t}\n\n\tqemu_log(\"exception 0x%03x [%s] raised\\n\",\n\n\t\t  irq_vector, expname);\n\n        log_cpu_state(cs, 0);\n\n    }\n\n\n\n    env->ssr = cpu_read_sr(env);\n\n    env->spc = env->pc;\n\n    env->sgr = env->gregs[15];\n\n    env->sr |= (1u << SR_BL) | (1u << SR_MD) | (1u << SR_RB);\n\n\n\n    if (env->flags & (DELAY_SLOT | DELAY_SLOT_CONDITIONAL)) {\n\n        /* Branch instruction should be executed again before delay slot. */\n\n\tenv->spc -= 2;\n\n\t/* Clear flags for exception/interrupt routine. */\n\n        env->flags &= ~(DELAY_SLOT | DELAY_SLOT_CONDITIONAL);\n\n    }\n\n\n\n    if (do_exp) {\n\n        env->expevt = cs->exception_index;\n\n        switch (cs->exception_index) {\n\n        case 0x000:\n\n        case 0x020:\n\n        case 0x140:\n\n            env->sr &= ~(1u << SR_FD);\n\n            env->sr |= 0xf << 4; /* IMASK */\n\n            env->pc = 0xa0000000;\n\n            break;\n\n        case 0x040:\n\n        case 0x060:\n\n            env->pc = env->vbr + 0x400;\n\n            break;\n\n        case 0x160:\n\n            env->spc += 2; /* special case for TRAPA */\n\n            /* fall through */\n\n        default:\n\n            env->pc = env->vbr + 0x100;\n\n            break;\n\n        }\n\n        return;\n\n    }\n\n\n\n    if (do_irq) {\n\n        env->intevt = irq_vector;\n\n        env->pc = env->vbr + 0x600;\n\n        return;\n\n    }\n\n}\n", "idx": 26739}
{"project": "qemu", "commit_id": "88dd1b8d0063ff16c54dc19c8b52508a00108f50", "target": 1, "func": "static void usb_ohci_init(OHCIState *ohci, DeviceState *dev,\n\n                          int num_ports, dma_addr_t localmem_base,\n\n                          char *masterbus, uint32_t firstport,\n\n                          AddressSpace *as, Error **errp)\n\n{\n\n    Error *err = NULL;\n\n    int i;\n\n\n\n    ohci->as = as;\n\n\n\n    if (usb_frame_time == 0) {\n\n#ifdef OHCI_TIME_WARP\n\n        usb_frame_time = get_ticks_per_sec();\n\n        usb_bit_time = muldiv64(1, get_ticks_per_sec(), USB_HZ/1000);\n\n#else\n\n        usb_frame_time = muldiv64(1, get_ticks_per_sec(), 1000);\n\n        if (get_ticks_per_sec() >= USB_HZ) {\n\n            usb_bit_time = muldiv64(1, get_ticks_per_sec(), USB_HZ);\n\n        } else {\n\n            usb_bit_time = 1;\n\n        }\n\n#endif\n\n        trace_usb_ohci_init_time(usb_frame_time, usb_bit_time);\n\n    }\n\n\n\n    ohci->num_ports = num_ports;\n\n    if (masterbus) {\n\n        USBPort *ports[OHCI_MAX_PORTS];\n\n        for(i = 0; i < num_ports; i++) {\n\n            ports[i] = &ohci->rhport[i].port;\n\n        }\n\n        usb_register_companion(masterbus, ports, num_ports,\n\n                               firstport, ohci, &ohci_port_ops,\n\n                               USB_SPEED_MASK_LOW | USB_SPEED_MASK_FULL,\n\n                               &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return;\n\n        }\n\n    } else {\n\n        usb_bus_new(&ohci->bus, sizeof(ohci->bus), &ohci_bus_ops, dev);\n\n        for (i = 0; i < num_ports; i++) {\n\n            usb_register_port(&ohci->bus, &ohci->rhport[i].port,\n\n                              ohci, i, &ohci_port_ops,\n\n                              USB_SPEED_MASK_LOW | USB_SPEED_MASK_FULL);\n\n        }\n\n    }\n\n\n\n    memory_region_init_io(&ohci->mem, OBJECT(dev), &ohci_mem_ops,\n\n                          ohci, \"ohci\", 256);\n\n    ohci->localmem_base = localmem_base;\n\n\n\n    ohci->name = object_get_typename(OBJECT(dev));\n\n    usb_packet_init(&ohci->usb_packet);\n\n\n\n    ohci->async_td = 0;\n\n    qemu_register_reset(ohci_reset, ohci);\n\n}\n", "idx": 26742}
{"project": "qemu", "commit_id": "0c9390d978cbf61e8f16c9f580fa96b305c43568", "target": 1, "func": "static void nbd_client_closed(NBDClient *client)\n\n{\n\n    nb_fds--;\n\n    if (nb_fds == 0 && !persistent && state == RUNNING) {\n\n        state = TERMINATE;\n\n    }\n\n    nbd_update_server_watch();\n\n    nbd_client_put(client);\n\n}\n", "idx": 26745}
{"project": "qemu", "commit_id": "1e9b65bb1bad51735cab6c861c29b592dccabf0e", "target": 1, "func": "void error_setg(Error **errp, const char *fmt, ...)\n\n{\n\n    va_list ap;\n\n\n\n    va_start(ap, fmt);\n\n    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);\n\n    va_end(ap);\n\n}\n", "idx": 26747}
{"project": "qemu", "commit_id": "b4e5a4bffda0d5dd79c87c66f28a5fac87182e30", "target": 1, "func": "static void patch_pci_windows(PcPciInfo *pci, uint8_t *start, unsigned size)\n\n{\n\n    *ACPI_BUILD_PTR(start, size, acpi_pci32_start[0], uint32_t) =\n\n        cpu_to_le32(pci->w32.begin);\n\n\n\n    *ACPI_BUILD_PTR(start, size, acpi_pci32_end[0], uint32_t) =\n\n        cpu_to_le32(pci->w32.end - 1);\n\n\n\n    if (pci->w64.end || pci->w64.begin) {\n\n        *ACPI_BUILD_PTR(start, size, acpi_pci64_valid[0], uint8_t) = 1;\n\n        *ACPI_BUILD_PTR(start, size, acpi_pci64_start[0], uint64_t) =\n\n            cpu_to_le64(pci->w64.begin);\n\n        *ACPI_BUILD_PTR(start, size, acpi_pci64_end[0], uint64_t) =\n\n            cpu_to_le64(pci->w64.end - 1);\n\n        *ACPI_BUILD_PTR(start, size, acpi_pci64_length[0], uint64_t) =\n\n            cpu_to_le64(pci->w64.end - pci->w64.begin);\n\n    } else {\n\n        *ACPI_BUILD_PTR(start, size, acpi_pci64_valid[0], uint8_t) = 0;\n\n    }\n\n}\n", "idx": 26748}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static uint16_t nvme_create_sq(NvmeCtrl *n, NvmeCmd *cmd)\n\n{\n\n    NvmeSQueue *sq;\n\n    NvmeCreateSq *c = (NvmeCreateSq *)cmd;\n\n\n\n    uint16_t cqid = le16_to_cpu(c->cqid);\n\n    uint16_t sqid = le16_to_cpu(c->sqid);\n\n    uint16_t qsize = le16_to_cpu(c->qsize);\n\n    uint16_t qflags = le16_to_cpu(c->sq_flags);\n\n    uint64_t prp1 = le64_to_cpu(c->prp1);\n\n\n\n    if (!cqid || nvme_check_cqid(n, cqid)) {\n\n        return NVME_INVALID_CQID | NVME_DNR;\n\n    }\n\n    if (!sqid || !nvme_check_sqid(n, sqid)) {\n\n        return NVME_INVALID_QID | NVME_DNR;\n\n    }\n\n    if (!qsize || qsize > NVME_CAP_MQES(n->bar.cap)) {\n\n        return NVME_MAX_QSIZE_EXCEEDED | NVME_DNR;\n\n    }\n\n    if (!prp1 || prp1 & (n->page_size - 1)) {\n\n        return NVME_INVALID_FIELD | NVME_DNR;\n\n    }\n\n    if (!(NVME_SQ_FLAGS_PC(qflags))) {\n\n        return NVME_INVALID_FIELD | NVME_DNR;\n\n    }\n\n    sq = g_malloc0(sizeof(*sq));\n\n    nvme_init_sq(sq, n, prp1, sqid, cqid, qsize + 1);\n\n    return NVME_SUCCESS;\n\n}\n", "idx": 26749}
{"project": "qemu", "commit_id": "0ac241bcf9f9d99a252a352a162f4b13b24732ab", "target": 1, "func": "hwaddr uc32_cpu_get_phys_page_debug(CPUState *cs, vaddr addr)\n\n{\n\n    UniCore32CPU *cpu = UNICORE32_CPU(cs);\n\n\n\n    cpu_abort(CPU(cpu), \"%s not supported yet\\n\", __func__);\n\n    return addr;\n\n}\n", "idx": 26752}
{"project": "qemu", "commit_id": "d2e49aad7259af943b72be761ee5c18e14acd71a", "target": 1, "func": "static char *SocketAddress_to_str(const char *prefix, SocketAddress *addr,\n\n                                  bool is_listen, bool is_telnet)\n\n{\n\n    switch (addr->type) {\n\n    case SOCKET_ADDRESS_KIND_INET:\n\n        return g_strdup_printf(\"%s%s:%s:%s%s\", prefix,\n\n                               is_telnet ? \"telnet\" : \"tcp\",\n\n                               addr->u.inet.data->host,\n\n                               addr->u.inet.data->port,\n\n                               is_listen ? \",server\" : \"\");\n\n        break;\n\n    case SOCKET_ADDRESS_KIND_UNIX:\n\n        return g_strdup_printf(\"%sunix:%s%s\", prefix,\n\n                               addr->u.q_unix.data->path,\n\n                               is_listen ? \",server\" : \"\");\n\n        break;\n\n    case SOCKET_ADDRESS_KIND_FD:\n\n        return g_strdup_printf(\"%sfd:%s%s\", prefix, addr->u.fd.data->str,\n\n                               is_listen ? \",server\" : \"\");\n\n        break;\n\n\n\n\n\n    default:\n\n        abort();\n\n    }\n\n}", "idx": 26753}
{"project": "qemu", "commit_id": "f332e830e38b3ff3953ef02ac04e409ae53769c5", "target": 1, "func": "static void parse_type_size(Visitor *v, const char *name, uint64_t *obj,\n\n                            Error **errp)\n\n{\n\n    StringInputVisitor *siv = to_siv(v);\n\n    Error *err = NULL;\n\n    uint64_t val;\n\n\n\n    if (siv->string) {\n\n        parse_option_size(name, siv->string, &val, &err);\n\n    } else {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"size\");\n\n        return;\n\n    }\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n\n\n    *obj = val;\n\n}\n", "idx": 26754}
{"project": "qemu", "commit_id": "010ec6293409f10b88631c36145944b9c3277ce1", "target": 1, "func": "static ssize_t nic_receive(VLANClientState *nc, const uint8_t * buf, size_t size)\n\n{\n\n    /* TODO:\n\n     * - Magic packets should set bit 30 in power management driver register.\n\n     * - Interesting packets should set bit 29 in power management driver register.\n\n     */\n\n    EEPRO100State *s = DO_UPCAST(NICState, nc, nc)->opaque;\n\n    uint16_t rfd_status = 0xa000;\n\n    static const uint8_t broadcast_macaddr[6] =\n\n        { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\n\n\n    /* TODO: check multiple IA bit. */\n\n    if (s->configuration[20] & BIT(6)) {\n\n        missing(\"Multiple IA bit\");\n\n        return -1;\n\n    }\n\n\n\n    if (s->configuration[8] & 0x80) {\n\n        /* CSMA is disabled. */\n\n        logout(\"%p received while CSMA is disabled\\n\", s);\n\n        return -1;\n\n    } else if (size < 64 && (s->configuration[7] & BIT(0))) {\n\n        /* Short frame and configuration byte 7/0 (discard short receive) set:\n\n         * Short frame is discarded */\n\n        logout(\"%p received short frame (%zu byte)\\n\", s, size);\n\n        s->statistics.rx_short_frame_errors++;\n\n#if 0\n\n        return -1;\n\n#endif\n\n    } else if ((size > MAX_ETH_FRAME_SIZE + 4) && !(s->configuration[18] & BIT(3))) {\n\n        /* Long frame and configuration byte 18/3 (long receive ok) not set:\n\n         * Long frames are discarded. */\n\n        logout(\"%p received long frame (%zu byte), ignored\\n\", s, size);\n\n        return -1;\n\n    } else if (memcmp(buf, s->conf.macaddr.a, 6) == 0) {       /* !!! */\n\n        /* Frame matches individual address. */\n\n        /* TODO: check configuration byte 15/4 (ignore U/L). */\n\n        TRACE(RXTX, logout(\"%p received frame for me, len=%zu\\n\", s, size));\n\n    } else if (memcmp(buf, broadcast_macaddr, 6) == 0) {\n\n        /* Broadcast frame. */\n\n        TRACE(RXTX, logout(\"%p received broadcast, len=%zu\\n\", s, size));\n\n        rfd_status |= 0x0002;\n\n    } else if (buf[0] & 0x01) {\n\n        /* Multicast frame. */\n\n        TRACE(RXTX, logout(\"%p received multicast, len=%zu,%s\\n\", s, size, nic_dump(buf, size)));\n\n        if (s->configuration[21] & BIT(3)) {\n\n          /* Multicast all bit is set, receive all multicast frames. */\n\n        } else {\n\n          unsigned mcast_idx = compute_mcast_idx(buf);\n\n          assert(mcast_idx < 64);\n\n          if (s->mult[mcast_idx >> 3] & (1 << (mcast_idx & 7))) {\n\n            /* Multicast frame is allowed in hash table. */\n\n          } else if (s->configuration[15] & BIT(0)) {\n\n              /* Promiscuous: receive all. */\n\n              rfd_status |= 0x0004;\n\n          } else {\n\n              TRACE(RXTX, logout(\"%p multicast ignored\\n\", s));\n\n              return -1;\n\n          }\n\n        }\n\n        /* TODO: Next not for promiscuous mode? */\n\n        rfd_status |= 0x0002;\n\n    } else if (s->configuration[15] & BIT(0)) {\n\n        /* Promiscuous: receive all. */\n\n        TRACE(RXTX, logout(\"%p received frame in promiscuous mode, len=%zu\\n\", s, size));\n\n        rfd_status |= 0x0004;\n\n    } else {\n\n        TRACE(RXTX, logout(\"%p received frame, ignored, len=%zu,%s\\n\", s, size,\n\n              nic_dump(buf, size)));\n\n        return size;\n\n    }\n\n\n\n    if (get_ru_state(s) != ru_ready) {\n\n        /* No resources available. */\n\n        logout(\"no resources, state=%u\\n\", get_ru_state(s));\n\n        /* TODO: RNR interrupt only at first failed frame? */\n\n        eepro100_rnr_interrupt(s);\n\n        s->statistics.rx_resource_errors++;\n\n#if 0\n\n        assert(!\"no resources\");\n\n#endif\n\n        return -1;\n\n    }\n\n    /* !!! */\n\n    eepro100_rx_t rx;\n\n    cpu_physical_memory_read(s->ru_base + s->ru_offset, (uint8_t *) & rx,\n\n                             offsetof(eepro100_rx_t, packet));\n\n    uint16_t rfd_command = le16_to_cpu(rx.command);\n\n    uint16_t rfd_size = le16_to_cpu(rx.size);\n\n\n\n    if (size > rfd_size) {\n\n        logout(\"Receive buffer (%\" PRId16 \" bytes) too small for data \"\n\n            \"(%zu bytes); data truncated\\n\", rfd_size, size);\n\n        size = rfd_size;\n\n    }\n\n    if (size < 64) {\n\n        rfd_status |= 0x0080;\n\n    }\n\n    TRACE(OTHER, logout(\"command 0x%04x, link 0x%08x, addr 0x%08x, size %u\\n\",\n\n          rfd_command, rx.link, rx.rx_buf_addr, rfd_size));\n\n    stw_phys(s->ru_base + s->ru_offset + offsetof(eepro100_rx_t, status),\n\n             rfd_status);\n\n    stw_phys(s->ru_base + s->ru_offset + offsetof(eepro100_rx_t, count), size);\n\n    /* Early receive interrupt not supported. */\n\n#if 0\n\n    eepro100_er_interrupt(s);\n\n#endif\n\n    /* Receive CRC Transfer not supported. */\n\n    if (s->configuration[18] & BIT(2)) {\n\n        missing(\"Receive CRC Transfer\");\n\n        return -1;\n\n    }\n\n    /* TODO: check stripping enable bit. */\n\n#if 0\n\n    assert(!(s->configuration[17] & BIT(0)));\n\n#endif\n\n    cpu_physical_memory_write(s->ru_base + s->ru_offset +\n\n                              offsetof(eepro100_rx_t, packet), buf, size);\n\n    s->statistics.rx_good_frames++;\n\n    eepro100_fr_interrupt(s);\n\n    s->ru_offset = le32_to_cpu(rx.link);\n\n    if (rfd_command & COMMAND_EL) {\n\n        /* EL bit is set, so this was the last frame. */\n\n        logout(\"receive: Running out of frames\\n\");\n\n        set_ru_state(s, ru_suspended);\n\n    }\n\n    if (rfd_command & COMMAND_S) {\n\n        /* S bit is set. */\n\n        set_ru_state(s, ru_suspended);\n\n    }\n\n    return size;\n\n}\n", "idx": 26759}
{"project": "qemu", "commit_id": "31ce5e0c49821d92fb30cce2f3055ef33613b287", "target": 1, "func": "void kvm_inject_x86_mce(CPUState *cenv, int bank, uint64_t status,\n\n                        uint64_t mcg_status, uint64_t addr, uint64_t misc,\n\n                        int abort_on_error)\n\n{\n\n#ifdef KVM_CAP_MCE\n\n    struct kvm_x86_mce mce = {\n\n        .bank = bank,\n\n        .status = status,\n\n        .mcg_status = mcg_status,\n\n        .addr = addr,\n\n        .misc = misc,\n\n    };\n\n    struct kvm_x86_mce_data data = {\n\n            .env = cenv,\n\n            .mce = &mce,\n\n    };\n\n\n\n    if (!cenv->mcg_cap) {\n\n        fprintf(stderr, \"MCE support is not enabled!\\n\");\n\n        return;\n\n    }\n\n\n\n    run_on_cpu(cenv, kvm_do_inject_x86_mce, &data);\n\n#else\n\n    if (abort_on_error)\n\n        abort();\n\n#endif\n\n}\n", "idx": 26765}
{"project": "qemu", "commit_id": "c94a7c6979cafa7a71f32b35e0ff71ed00c61a89", "target": 1, "func": "static int usb_xhci_initfn(struct PCIDevice *dev)\n\n{\n\n    int i, ret;\n\n\n\n    XHCIState *xhci = DO_UPCAST(XHCIState, pci_dev, dev);\n\n\n\n    xhci->pci_dev.config[PCI_CLASS_PROG] = 0x30;    /* xHCI */\n\n    xhci->pci_dev.config[PCI_INTERRUPT_PIN] = 0x01; /* interrupt pin 1 */\n\n    xhci->pci_dev.config[PCI_CACHE_LINE_SIZE] = 0x10;\n\n    xhci->pci_dev.config[0x60] = 0x30; /* release number */\n\n\n\n    usb_xhci_init(xhci, &dev->qdev);\n\n\n\n    if (xhci->numintrs > MAXINTRS) {\n\n        xhci->numintrs = MAXINTRS;\n\n\n\n\n\n    if (xhci->numintrs < 1) {\n\n        xhci->numintrs = 1;\n\n\n    if (xhci->numslots > MAXSLOTS) {\n\n        xhci->numslots = MAXSLOTS;\n\n\n    if (xhci->numslots < 1) {\n\n        xhci->numslots = 1;\n\n\n\n\n    xhci->mfwrap_timer = qemu_new_timer_ns(vm_clock, xhci_mfwrap_timer, xhci);\n\n\n\n    xhci->irq = xhci->pci_dev.irq[0];\n\n\n\n    memory_region_init(&xhci->mem, \"xhci\", LEN_REGS);\n\n    memory_region_init_io(&xhci->mem_cap, &xhci_cap_ops, xhci,\n\n                          \"capabilities\", LEN_CAP);\n\n    memory_region_init_io(&xhci->mem_oper, &xhci_oper_ops, xhci,\n\n                          \"operational\", 0x400);\n\n    memory_region_init_io(&xhci->mem_runtime, &xhci_runtime_ops, xhci,\n\n                          \"runtime\", LEN_RUNTIME);\n\n    memory_region_init_io(&xhci->mem_doorbell, &xhci_doorbell_ops, xhci,\n\n                          \"doorbell\", LEN_DOORBELL);\n\n\n\n    memory_region_add_subregion(&xhci->mem, 0,            &xhci->mem_cap);\n\n    memory_region_add_subregion(&xhci->mem, OFF_OPER,     &xhci->mem_oper);\n\n    memory_region_add_subregion(&xhci->mem, OFF_RUNTIME,  &xhci->mem_runtime);\n\n    memory_region_add_subregion(&xhci->mem, OFF_DOORBELL, &xhci->mem_doorbell);\n\n\n\n    for (i = 0; i < xhci->numports; i++) {\n\n        XHCIPort *port = &xhci->ports[i];\n\n        uint32_t offset = OFF_OPER + 0x400 + 0x10 * i;\n\n        port->xhci = xhci;\n\n        memory_region_init_io(&port->mem, &xhci_port_ops, port,\n\n                              port->name, 0x10);\n\n        memory_region_add_subregion(&xhci->mem, offset, &port->mem);\n\n\n\n\n    pci_register_bar(&xhci->pci_dev, 0,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY|PCI_BASE_ADDRESS_MEM_TYPE_64,\n\n                     &xhci->mem);\n\n\n\n    ret = pcie_endpoint_cap_init(&xhci->pci_dev, 0xa0);\n\n    assert(ret >= 0);\n\n\n\n    if (xhci->flags & (1 << XHCI_FLAG_USE_MSI)) {\n\n        msi_init(&xhci->pci_dev, 0x70, xhci->numintrs, true, false);\n\n\n    if (xhci->flags & (1 << XHCI_FLAG_USE_MSI_X)) {\n\n        msix_init(&xhci->pci_dev, xhci->numintrs,\n\n                  &xhci->mem, 0, OFF_MSIX_TABLE,\n\n                  &xhci->mem, 0, OFF_MSIX_PBA,\n\n                  0x90);\n\n\n\n\n    return 0;\n", "idx": 26767}
{"project": "qemu", "commit_id": "db486cc334aafd3dbdaf107388e37fc3d6d3e171", "target": 1, "func": "GList *range_list_insert(GList *list, Range *data)\n\n{\n\n    GList *l, *next = NULL;\n\n    Range *r, *nextr;\n\n\n\n    if (!list) {\n\n        list = g_list_insert_sorted(list, data, range_compare);\n\n        return list;\n\n    }\n\n\n\n    nextr = data;\n\n    l = list;\n\n    while (l && l != next && nextr) {\n\n        r = l->data;\n\n        if (ranges_can_merge(r, nextr)) {\n\n            range_merge(r, nextr);\n\n            l = g_list_remove_link(l, next);\n\n            next = g_list_next(l);\n\n            if (next) {\n\n                nextr = next->data;\n\n            } else {\n\n                nextr = NULL;\n\n            }\n\n        } else {\n\n            l = g_list_next(l);\n\n        }\n\n    }\n\n\n\n    if (!l) {\n\n        list = g_list_insert_sorted(list, data, range_compare);\n\n    }\n\n\n\n    return list;\n\n}\n", "idx": 26769}
{"project": "qemu", "commit_id": "363ba1c72fed4425e7917afc36722584aaeaad8a", "target": 1, "func": "static void close_guest_eventfds(IVShmemState *s, int posn)\n\n{\n\n    int i, guest_curr_max;\n\n\n\n    if (!ivshmem_has_feature(s, IVSHMEM_IOEVENTFD)) {\n\n\n\n\n\n\n\n\n    guest_curr_max = s->peers[posn].nb_eventfds;\n\n\n\n    memory_region_transaction_begin();\n\n    for (i = 0; i < guest_curr_max; i++) {\n\n        ivshmem_del_eventfd(s, posn, i);\n\n\n    memory_region_transaction_commit();\n\n    for (i = 0; i < guest_curr_max; i++) {\n\n        event_notifier_cleanup(&s->peers[posn].eventfds[i]);\n\n\n\n\n    g_free(s->peers[posn].eventfds);\n\n    s->peers[posn].nb_eventfds = 0;\n", "idx": 26771}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "func": "static int handle_name_to_path(FsContext *ctx, V9fsPath *dir_path,\n\n                              const char *name, V9fsPath *target)\n\n{\n\n    char buffer[PATH_MAX];\n\n    struct file_handle *fh;\n\n    int dirfd, ret, mnt_id;\n\n    struct handle_data *data = (struct handle_data *)ctx->private;\n\n\n\n    /* \".\" and \"..\" are not allowed */\n\n    if (!strcmp(name, \".\") || !strcmp(name, \"..\")) {\n\n        errno = EINVAL;\n\n        return -1;\n\n\n\n    }\n\n    if (dir_path) {\n\n        dirfd = open_by_handle(data->mountfd, dir_path->data, O_PATH);\n\n    } else {\n\n        /* relative to export root */\n\n        dirfd = open(rpath(ctx, \".\", buffer), O_DIRECTORY);\n\n    }\n\n    if (dirfd < 0) {\n\n        return dirfd;\n\n    }\n\n    fh = g_malloc(sizeof(struct file_handle) + data->handle_bytes);\n\n    fh->handle_bytes = data->handle_bytes;\n\n    /* add a \"./\" at the beginning of the path */\n\n    snprintf(buffer, PATH_MAX, \"./%s\", name);\n\n    /* flag = 0 imply don't follow symlink */\n\n    ret = name_to_handle(dirfd, buffer, fh, &mnt_id, 0);\n\n    if (!ret) {\n\n        target->data = (char *)fh;\n\n        target->size = sizeof(struct file_handle) + data->handle_bytes;\n\n    } else {\n\n        g_free(fh);\n\n    }\n\n    close(dirfd);\n\n    return ret;\n\n}\n", "idx": 26775}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static inline void vmsvga_update_rect_delayed(struct vmsvga_state_s *s,\n\n                int x, int y, int w, int h)\n\n{\n\n    struct vmsvga_rect_s *rect = &s->redraw_fifo[s->redraw_fifo_last ++];\n\n    s->redraw_fifo_last &= REDRAW_FIFO_LEN - 1;\n\n    rect->x = x;\n\n    rect->y = y;\n\n    rect->w = w;\n\n    rect->h = h;\n\n}\n", "idx": 26776}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static inline void t_gen_addx_carry(DisasContext *dc, TCGv d)\n\n{\n\n\tif (dc->flagx_known) {\n\n\t\tif (dc->flags_x) {\n\n\t\t\tTCGv c;\n\n            \n\n\t\t\tc = tcg_temp_new(TCG_TYPE_TL);\n\n\t\t\tt_gen_mov_TN_preg(c, PR_CCS);\n\n\t\t\t/* C flag is already at bit 0.  */\n\n\t\t\ttcg_gen_andi_tl(c, c, C_FLAG);\n\n\t\t\ttcg_gen_add_tl(d, d, c);\n\n\t\t\ttcg_temp_free(c);\n\n\t\t}\n\n\t} else {\n\n\t\tTCGv x, c;\n\n\n\n\t\tx = tcg_temp_new(TCG_TYPE_TL);\n\n\t\tc = tcg_temp_new(TCG_TYPE_TL);\n\n\t\tt_gen_mov_TN_preg(x, PR_CCS);\n\n\t\ttcg_gen_mov_tl(c, x);\n\n\n\n\t\t/* Propagate carry into d if X is set. Branch free.  */\n\n\t\ttcg_gen_andi_tl(c, c, C_FLAG);\n\n\t\ttcg_gen_andi_tl(x, x, X_FLAG);\n\n\t\ttcg_gen_shri_tl(x, x, 4);\n\n\n\n\t\ttcg_gen_and_tl(x, x, c);\n\n\t\ttcg_gen_add_tl(d, d, x);        \n\n\t\ttcg_temp_free(x);\n\n\t\ttcg_temp_free(c);\n\n\t}\n\n}\n", "idx": 26777}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static int qio_dns_resolver_lookup_sync_inet(QIODNSResolver *resolver,\n\n                                             SocketAddress *addr,\n\n                                             size_t *naddrs,\n\n                                             SocketAddress ***addrs,\n\n                                             Error **errp)\n\n{\n\n    struct addrinfo ai, *res, *e;\n\n    InetSocketAddress *iaddr = addr->u.inet.data;\n\n    char port[33];\n\n    char uaddr[INET6_ADDRSTRLEN + 1];\n\n    char uport[33];\n\n    int rc;\n\n    Error *err = NULL;\n\n    size_t i;\n\n\n\n    *naddrs = 0;\n\n    *addrs = NULL;\n\n\n\n    memset(&ai, 0, sizeof(ai));\n\n    ai.ai_flags = AI_PASSIVE;\n\n    if (iaddr->has_numeric && iaddr->numeric) {\n\n        ai.ai_flags |= AI_NUMERICHOST | AI_NUMERICSERV;\n\n    }\n\n    ai.ai_family = inet_ai_family_from_address(iaddr, &err);\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return -1;\n\n    }\n\n\n\n    if (iaddr->host == NULL) {\n\n        error_setg(errp, \"host not specified\");\n\n        return -1;\n\n    }\n\n    if (iaddr->port != NULL) {\n\n        pstrcpy(port, sizeof(port), iaddr->port);\n\n    } else {\n\n        port[0] = '\\0';\n\n    }\n\n\n\n    rc = getaddrinfo(strlen(iaddr->host) ? iaddr->host : NULL,\n\n                     strlen(port) ? port : NULL, &ai, &res);\n\n    if (rc != 0) {\n\n        error_setg(errp, \"address resolution failed for %s:%s: %s\",\n\n                   iaddr->host, port, gai_strerror(rc));\n\n        return -1;\n\n    }\n\n\n\n    for (e = res; e != NULL; e = e->ai_next) {\n\n        (*naddrs)++;\n\n    }\n\n\n\n    *addrs = g_new0(SocketAddress *, *naddrs);\n\n\n\n    /* create socket + bind */\n\n    for (i = 0, e = res; e != NULL; i++, e = e->ai_next) {\n\n        SocketAddress *newaddr = g_new0(SocketAddress, 1);\n\n        InetSocketAddress *newiaddr = g_new0(InetSocketAddress, 1);\n\n        newaddr->u.inet.data = newiaddr;\n\n        newaddr->type = SOCKET_ADDRESS_KIND_INET;\n\n\n\n        getnameinfo((struct sockaddr *)e->ai_addr, e->ai_addrlen,\n\n                    uaddr, INET6_ADDRSTRLEN, uport, 32,\n\n                    NI_NUMERICHOST | NI_NUMERICSERV);\n\n\n\n        *newiaddr = (InetSocketAddress){\n\n            .host = g_strdup(uaddr),\n\n            .port = g_strdup(uport),\n\n            .has_numeric = true,\n\n            .numeric = true,\n\n            .has_to = iaddr->has_to,\n\n            .to = iaddr->to,\n\n            .has_ipv4 = false,\n\n            .has_ipv6 = false,\n\n        };\n\n\n\n        (*addrs)[i] = newaddr;\n\n    }\n\n    freeaddrinfo(res);\n\n    return 0;\n\n}\n", "idx": 26778}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "void acpi_build(AcpiBuildTables *tables, MachineState *machine)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(machine);\n\n    PCMachineClass *pcmc = PC_MACHINE_GET_CLASS(pcms);\n\n    GArray *table_offsets;\n\n    unsigned facs, dsdt, rsdt, fadt;\n\n    AcpiPmInfo pm;\n\n    AcpiMiscInfo misc;\n\n    AcpiMcfgInfo mcfg;\n\n    Range pci_hole, pci_hole64;\n\n    uint8_t *u;\n\n    size_t aml_len = 0;\n\n    GArray *tables_blob = tables->table_data;\n\n    AcpiSlicOem slic_oem = { .id = NULL, .table_id = NULL };\n\n    Object *vmgenid_dev;\n\n\n\n    acpi_get_pm_info(&pm);\n\n    acpi_get_misc_info(&misc);\n\n    acpi_get_pci_holes(&pci_hole, &pci_hole64);\n\n    acpi_get_slic_oem(&slic_oem);\n\n\n\n    table_offsets = g_array_new(false, true /* clear */,\n\n                                        sizeof(uint32_t));\n\n    ACPI_BUILD_DPRINTF(\"init ACPI tables\\n\");\n\n\n\n    bios_linker_loader_alloc(tables->linker,\n\n                             ACPI_BUILD_TABLE_FILE, tables_blob,\n\n                             64 /* Ensure FACS is aligned */,\n\n                             false /* high memory */);\n\n\n\n    /*\n\n     * FACS is pointed to by FADT.\n\n     * We place it first since it's the only table that has alignment\n\n     * requirements.\n\n     */\n\n    facs = tables_blob->len;\n\n    build_facs(tables_blob, tables->linker);\n\n\n\n    /* DSDT is pointed to by FADT */\n\n    dsdt = tables_blob->len;\n\n    build_dsdt(tables_blob, tables->linker, &pm, &misc,\n\n               &pci_hole, &pci_hole64, machine);\n\n\n\n    /* Count the size of the DSDT and SSDT, we will need it for legacy\n\n     * sizing of ACPI tables.\n\n     */\n\n    aml_len += tables_blob->len - dsdt;\n\n\n\n    /* ACPI tables pointed to by RSDT */\n\n    fadt = tables_blob->len;\n\n    acpi_add_table(table_offsets, tables_blob);\n\n    build_fadt(tables_blob, tables->linker, &pm, facs, dsdt,\n\n               slic_oem.id, slic_oem.table_id);\n\n    aml_len += tables_blob->len - fadt;\n\n\n\n    acpi_add_table(table_offsets, tables_blob);\n\n    build_madt(tables_blob, tables->linker, pcms);\n\n\n\n    vmgenid_dev = find_vmgenid_dev();\n\n    if (vmgenid_dev) {\n\n        acpi_add_table(table_offsets, tables_blob);\n\n        vmgenid_build_acpi(VMGENID(vmgenid_dev), tables_blob,\n\n                           tables->vmgenid, tables->linker);\n\n    }\n\n\n\n    if (misc.has_hpet) {\n\n        acpi_add_table(table_offsets, tables_blob);\n\n        build_hpet(tables_blob, tables->linker);\n\n    }\n\n    if (misc.tpm_version != TPM_VERSION_UNSPEC) {\n\n        acpi_add_table(table_offsets, tables_blob);\n\n        build_tpm_tcpa(tables_blob, tables->linker, tables->tcpalog);\n\n\n\n        if (misc.tpm_version == TPM_VERSION_2_0) {\n\n            acpi_add_table(table_offsets, tables_blob);\n\n            build_tpm2(tables_blob, tables->linker);\n\n        }\n\n    }\n\n    if (pcms->numa_nodes) {\n\n        acpi_add_table(table_offsets, tables_blob);\n\n        build_srat(tables_blob, tables->linker, machine);\n\n        if (have_numa_distance) {\n\n            acpi_add_table(table_offsets, tables_blob);\n\n            build_slit(tables_blob, tables->linker);\n\n        }\n\n    }\n\n    if (acpi_get_mcfg(&mcfg)) {\n\n        acpi_add_table(table_offsets, tables_blob);\n\n        build_mcfg_q35(tables_blob, tables->linker, &mcfg);\n\n    }\n\n    if (x86_iommu_get_default()) {\n\n        IommuType IOMMUType = x86_iommu_get_type();\n\n        if (IOMMUType == TYPE_AMD) {\n\n            acpi_add_table(table_offsets, tables_blob);\n\n            build_amd_iommu(tables_blob, tables->linker);\n\n        } else if (IOMMUType == TYPE_INTEL) {\n\n            acpi_add_table(table_offsets, tables_blob);\n\n            build_dmar_q35(tables_blob, tables->linker);\n\n        }\n\n    }\n\n    if (pcms->acpi_nvdimm_state.is_enabled) {\n\n        nvdimm_build_acpi(table_offsets, tables_blob, tables->linker,\n\n                          &pcms->acpi_nvdimm_state, machine->ram_slots);\n\n    }\n\n\n\n    /* Add tables supplied by user (if any) */\n\n    for (u = acpi_table_first(); u; u = acpi_table_next(u)) {\n\n        unsigned len = acpi_table_len(u);\n\n\n\n        acpi_add_table(table_offsets, tables_blob);\n\n        g_array_append_vals(tables_blob, u, len);\n\n    }\n\n\n\n    /* RSDT is pointed to by RSDP */\n\n    rsdt = tables_blob->len;\n\n    build_rsdt(tables_blob, tables->linker, table_offsets,\n\n               slic_oem.id, slic_oem.table_id);\n\n\n\n    /* RSDP is in FSEG memory, so allocate it separately */\n\n    build_rsdp(tables->rsdp, tables->linker, rsdt);\n\n\n\n    /* We'll expose it all to Guest so we want to reduce\n\n     * chance of size changes.\n\n     *\n\n     * We used to align the tables to 4k, but of course this would\n\n     * too simple to be enough.  4k turned out to be too small an\n\n     * alignment very soon, and in fact it is almost impossible to\n\n     * keep the table size stable for all (max_cpus, max_memory_slots)\n\n     * combinations.  So the table size is always 64k for pc-i440fx-2.1\n\n     * and we give an error if the table grows beyond that limit.\n\n     *\n\n     * We still have the problem of migrating from \"-M pc-i440fx-2.0\".  For\n\n     * that, we exploit the fact that QEMU 2.1 generates _smaller_ tables\n\n     * than 2.0 and we can always pad the smaller tables with zeros.  We can\n\n     * then use the exact size of the 2.0 tables.\n\n     *\n\n     * All this is for PIIX4, since QEMU 2.0 didn't support Q35 migration.\n\n     */\n\n    if (pcmc->legacy_acpi_table_size) {\n\n        /* Subtracting aml_len gives the size of fixed tables.  Then add the\n\n         * size of the PIIX4 DSDT/SSDT in QEMU 2.0.\n\n         */\n\n        int legacy_aml_len =\n\n            pcmc->legacy_acpi_table_size +\n\n            ACPI_BUILD_LEGACY_CPU_AML_SIZE * pcms->apic_id_limit;\n\n        int legacy_table_size =\n\n            ROUND_UP(tables_blob->len - aml_len + legacy_aml_len,\n\n                     ACPI_BUILD_ALIGN_SIZE);\n\n        if (tables_blob->len > legacy_table_size) {\n\n            /* Should happen only with PCI bridges and -M pc-i440fx-2.0.  */\n\n            error_report(\"Warning: migration may not work.\");\n\n        }\n\n        g_array_set_size(tables_blob, legacy_table_size);\n\n    } else {\n\n        /* Make sure we have a buffer in case we need to resize the tables. */\n\n        if (tables_blob->len > ACPI_BUILD_TABLE_SIZE / 2) {\n\n            /* As of QEMU 2.1, this fires with 160 VCPUs and 255 memory slots.  */\n\n            error_report(\"Warning: ACPI tables are larger than 64k.\");\n\n            error_report(\"Warning: migration may not work.\");\n\n            error_report(\"Warning: please remove CPUs, NUMA nodes, \"\n\n                         \"memory slots or PCI bridges.\");\n\n        }\n\n        acpi_align_size(tables_blob, ACPI_BUILD_TABLE_SIZE);\n\n    }\n\n\n\n    acpi_align_size(tables->linker->cmd_blob, ACPI_BUILD_ALIGN_SIZE);\n\n\n\n    /* Cleanup memory that's no longer used. */\n\n    g_array_free(table_offsets, true);\n\n}\n", "idx": 26779}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "static void rtas_start_cpu(sPAPREnvironment *spapr,\n\n                           uint32_t token, uint32_t nargs,\n\n                           target_ulong args,\n\n                           uint32_t nret, target_ulong rets)\n\n{\n\n    target_ulong id, start, r3;\n\n    CPUState *cs;\n\n\n\n    if (nargs != 3 || nret != 1) {\n\n        rtas_st(rets, 0, -3);\n\n        return;\n\n    }\n\n\n\n    id = rtas_ld(args, 0);\n\n    start = rtas_ld(args, 1);\n\n    r3 = rtas_ld(args, 2);\n\n\n\n    cs = qemu_get_cpu(id);\n\n    if (cs != NULL) {\n\n        PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n        CPUPPCState *env = &cpu->env;\n\n\n\n        if (!cs->halted) {\n\n            rtas_st(rets, 0, -1);\n\n            return;\n\n        }\n\n\n\n        /* This will make sure qemu state is up to date with kvm, and\n\n         * mark it dirty so our changes get flushed back before the\n\n         * new cpu enters */\n\n        kvm_cpu_synchronize_state(cs);\n\n\n\n        env->msr = (1ULL << MSR_SF) | (1ULL << MSR_ME);\n\n        env->nip = start;\n\n        env->gpr[3] = r3;\n\n        cs->halted = 0;\n\n\n\n        qemu_cpu_kick(cs);\n\n\n\n        rtas_st(rets, 0, 0);\n\n        return;\n\n    }\n\n\n\n    /* Didn't find a matching cpu */\n\n    rtas_st(rets, 0, -3);\n\n}\n", "idx": 26780}
{"project": "qemu", "commit_id": "4ebc736e9938a7e88ecc785734b17145bf802a56", "target": 0, "func": "static Aml *build_crs(PCIHostState *host,\n\n                      GPtrArray *io_ranges, GPtrArray *mem_ranges)\n\n{\n\n    Aml *crs = aml_resource_template();\n\n    uint8_t max_bus = pci_bus_num(host->bus);\n\n    uint8_t type;\n\n    int devfn;\n\n\n\n    for (devfn = 0; devfn < ARRAY_SIZE(host->bus->devices); devfn++) {\n\n        int i;\n\n        uint64_t range_base, range_limit;\n\n        PCIDevice *dev = host->bus->devices[devfn];\n\n\n\n        if (!dev) {\n\n            continue;\n\n        }\n\n\n\n        for (i = 0; i < PCI_NUM_REGIONS; i++) {\n\n            PCIIORegion *r = &dev->io_regions[i];\n\n\n\n            range_base = r->addr;\n\n            range_limit = r->addr + r->size - 1;\n\n\n\n            /*\n\n             * Work-around for old bioses\n\n             * that do not support multiple root buses\n\n             */\n\n            if (!range_base || range_base > range_limit) {\n\n                continue;\n\n            }\n\n\n\n            if (r->type & PCI_BASE_ADDRESS_SPACE_IO) {\n\n                aml_append(crs,\n\n                    aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,\n\n                                AML_POS_DECODE, AML_ENTIRE_RANGE,\n\n                                0,\n\n                                range_base,\n\n                                range_limit,\n\n                                0,\n\n                                range_limit - range_base + 1));\n\n                crs_range_insert(io_ranges, range_base, range_limit);\n\n            } else { /* \"memory\" */\n\n                aml_append(crs,\n\n                    aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED,\n\n                                     AML_MAX_FIXED, AML_NON_CACHEABLE,\n\n                                     AML_READ_WRITE,\n\n                                     0,\n\n                                     range_base,\n\n                                     range_limit,\n\n                                     0,\n\n                                     range_limit - range_base + 1));\n\n                crs_range_insert(mem_ranges, range_base, range_limit);\n\n            }\n\n        }\n\n\n\n        type = dev->config[PCI_HEADER_TYPE] & ~PCI_HEADER_TYPE_MULTI_FUNCTION;\n\n        if (type == PCI_HEADER_TYPE_BRIDGE) {\n\n            uint8_t subordinate = dev->config[PCI_SUBORDINATE_BUS];\n\n            if (subordinate > max_bus) {\n\n                max_bus = subordinate;\n\n            }\n\n\n\n            range_base = pci_bridge_get_base(dev, PCI_BASE_ADDRESS_SPACE_IO);\n\n            range_limit = pci_bridge_get_limit(dev, PCI_BASE_ADDRESS_SPACE_IO);\n\n\n\n            /*\n\n             * Work-around for old bioses\n\n             * that do not support multiple root buses\n\n             */\n\n            if (range_base || range_base > range_limit) {\n\n                aml_append(crs,\n\n                           aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,\n\n                                       AML_POS_DECODE, AML_ENTIRE_RANGE,\n\n                                       0,\n\n                                       range_base,\n\n                                       range_limit,\n\n                                       0,\n\n                                       range_limit - range_base + 1));\n\n                crs_range_insert(io_ranges, range_base, range_limit);\n\n            }\n\n\n\n            range_base =\n\n                pci_bridge_get_base(dev, PCI_BASE_ADDRESS_SPACE_MEMORY);\n\n            range_limit =\n\n                pci_bridge_get_limit(dev, PCI_BASE_ADDRESS_SPACE_MEMORY);\n\n\n\n            /*\n\n             * Work-around for old bioses\n\n             * that do not support multiple root buses\n\n             */\n\n            if (range_base || range_base > range_limit) {\n\n                aml_append(crs,\n\n                           aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED,\n\n                                            AML_MAX_FIXED, AML_NON_CACHEABLE,\n\n                                            AML_READ_WRITE,\n\n                                            0,\n\n                                            range_base,\n\n                                            range_limit,\n\n                                            0,\n\n                                            range_limit - range_base + 1));\n\n                crs_range_insert(mem_ranges, range_base, range_limit);\n\n          }\n\n\n\n            range_base =\n\n                pci_bridge_get_base(dev, PCI_BASE_ADDRESS_MEM_PREFETCH);\n\n            range_limit =\n\n                pci_bridge_get_limit(dev, PCI_BASE_ADDRESS_MEM_PREFETCH);\n\n\n\n            /*\n\n             * Work-around for old bioses\n\n             * that do not support multiple root buses\n\n             */\n\n            if (range_base || range_base > range_limit) {\n\n                aml_append(crs,\n\n                           aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED,\n\n                                            AML_MAX_FIXED, AML_NON_CACHEABLE,\n\n                                            AML_READ_WRITE,\n\n                                            0,\n\n                                            range_base,\n\n                                            range_limit,\n\n                                            0,\n\n                                            range_limit - range_base + 1));\n\n                crs_range_insert(mem_ranges, range_base, range_limit);\n\n            }\n\n        }\n\n    }\n\n\n\n    aml_append(crs,\n\n        aml_word_bus_number(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE,\n\n                            0,\n\n                            pci_bus_num(host->bus),\n\n                            max_bus,\n\n                            0,\n\n                            max_bus - pci_bus_num(host->bus) + 1));\n\n\n\n    return crs;\n\n}\n", "idx": 26781}
{"project": "qemu", "commit_id": "65e7545ea3c65a6468fb59418a6dbe66ef71d6d1", "target": 0, "func": "static int escc_init1(SysBusDevice *dev)\n\n{\n\n    ESCCState *s = ESCC(dev);\n\n    unsigned int i;\n\n\n\n    s->chn[0].disabled = s->disabled;\n\n    s->chn[1].disabled = s->disabled;\n\n    for (i = 0; i < 2; i++) {\n\n        sysbus_init_irq(dev, &s->chn[i].irq);\n\n        s->chn[i].chn = 1 - i;\n\n        s->chn[i].clock = s->frequency / 2;\n\n        if (s->chn[i].chr) {\n\n            qemu_chr_add_handlers(s->chn[i].chr, serial_can_receive,\n\n                                  serial_receive1, serial_event, &s->chn[i]);\n\n        }\n\n    }\n\n    s->chn[0].otherchn = &s->chn[1];\n\n    s->chn[1].otherchn = &s->chn[0];\n\n\n\n    memory_region_init_io(&s->mmio, OBJECT(s), &escc_mem_ops, s, \"escc\",\n\n                          ESCC_SIZE << s->it_shift);\n\n    sysbus_init_mmio(dev, &s->mmio);\n\n\n\n    if (s->chn[0].type == mouse) {\n\n        qemu_add_mouse_event_handler(sunmouse_event, &s->chn[0], 0,\n\n                                     \"QEMU Sun Mouse\");\n\n    }\n\n    if (s->chn[1].type == kbd) {\n\n        qemu_add_kbd_event_handler(sunkbd_event, &s->chn[1]);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 26782}
{"project": "qemu", "commit_id": "22bfa75eafc21522afbb265091faa9cc0649e9fb", "target": 0, "func": "void aio_bh_update_timeout(AioContext *ctx, uint32_t *timeout)\n\n{\n\n    QEMUBH *bh;\n\n\n\n    for (bh = ctx->first_bh; bh; bh = bh->next) {\n\n        if (!bh->deleted && bh->scheduled) {\n\n            if (bh->idle) {\n\n                /* idle bottom halves will be polled at least\n\n                 * every 10ms */\n\n                *timeout = MIN(10, *timeout);\n\n            } else {\n\n                /* non-idle bottom halves will be executed\n\n                 * immediately */\n\n                *timeout = 0;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 26783}
{"project": "qemu", "commit_id": "7c81e4e9db5f63635fbf11d66bf08e73d325ae97", "target": 0, "func": "void bdrv_image_info_specific_dump(fprintf_function func_fprintf, void *f,\n\n                                   ImageInfoSpecific *info_spec)\n\n{\n\n    QObject *obj, *data;\n\n    Visitor *v = qobject_output_visitor_new(&obj);\n\n\n\n    visit_type_ImageInfoSpecific(v, NULL, &info_spec, &error_abort);\n\n    visit_complete(v, &obj);\n\n    assert(qobject_type(obj) == QTYPE_QDICT);\n\n    data = qdict_get(qobject_to_qdict(obj), \"data\");\n\n    dump_qobject(func_fprintf, f, 1, data);\n\n    qobject_decref(obj);\n\n    visit_free(v);\n\n}\n", "idx": 26784}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "SocketAddress *socket_address_crumple(SocketAddressFlat *addr_flat)\n\n{\n\n    SocketAddress *addr = g_new(SocketAddress, 1);\n\n\n\n    switch (addr_flat->type) {\n\n    case SOCKET_ADDRESS_FLAT_TYPE_INET:\n\n        addr->type = SOCKET_ADDRESS_KIND_INET;\n\n        addr->u.inet.data = QAPI_CLONE(InetSocketAddress,\n\n                                       &addr_flat->u.inet);\n\n        break;\n\n    case SOCKET_ADDRESS_FLAT_TYPE_UNIX:\n\n        addr->type = SOCKET_ADDRESS_KIND_UNIX;\n\n        addr->u.q_unix.data = QAPI_CLONE(UnixSocketAddress,\n\n                                         &addr_flat->u.q_unix);\n\n        break;\n\n    case SOCKET_ADDRESS_FLAT_TYPE_VSOCK:\n\n        addr->type = SOCKET_ADDRESS_KIND_VSOCK;\n\n        addr->u.vsock.data = QAPI_CLONE(VsockSocketAddress,\n\n                                        &addr_flat->u.vsock);\n\n        break;\n\n    case SOCKET_ADDRESS_FLAT_TYPE_FD:\n\n        addr->type = SOCKET_ADDRESS_KIND_FD;\n\n        addr->u.fd.data = QAPI_CLONE(String, &addr_flat->u.fd);\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n\n\n    return addr;\n\n}\n", "idx": 26786}
{"project": "qemu", "commit_id": "3ba235a02284c39b34a68a2a588508ffb52a7b55", "target": 0, "func": "void aio_set_event_notifier(AioContext *ctx,\n\n                            EventNotifier *e,\n\n                            EventNotifierHandler *io_notify)\n\n{\n\n    AioHandler *node;\n\n\n\n    QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n        if (node->e == e && !node->deleted) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* Are we deleting the fd handler? */\n\n    if (!io_notify) {\n\n        if (node) {\n\n            g_source_remove_poll(&ctx->source, &node->pfd);\n\n\n\n            /* If the lock is held, just mark the node as deleted */\n\n            if (ctx->walking_handlers) {\n\n                node->deleted = 1;\n\n                node->pfd.revents = 0;\n\n            } else {\n\n                /* Otherwise, delete it for real.  We can't just mark it as\n\n                 * deleted because deleted nodes are only cleaned up after\n\n                 * releasing the walking_handlers lock.\n\n                 */\n\n                QLIST_REMOVE(node, node);\n\n                g_free(node);\n\n            }\n\n        }\n\n    } else {\n\n        if (node == NULL) {\n\n            /* Alloc and insert if it's not already there */\n\n            node = g_malloc0(sizeof(AioHandler));\n\n            node->e = e;\n\n            node->pfd.fd = (uintptr_t)event_notifier_get_handle(e);\n\n            node->pfd.events = G_IO_IN;\n\n            QLIST_INSERT_HEAD(&ctx->aio_handlers, node, node);\n\n\n\n            g_source_add_poll(&ctx->source, &node->pfd);\n\n        }\n\n        /* Update handler with latest information */\n\n        node->io_notify = io_notify;\n\n    }\n\n\n\n    aio_notify(ctx);\n\n}\n", "idx": 26787}
{"project": "qemu", "commit_id": "7c2eaca4efa46e02caaec4ca7ddf05a6e461da94", "target": 0, "func": "static void uhci_fill_queue(UHCIState *s, UHCI_TD *td)\n\n{\n\n    uint32_t int_mask = 0;\n\n    uint32_t plink = td->link;\n\n    uint32_t token = uhci_queue_token(td);\n\n    UHCI_TD ptd;\n\n    int ret;\n\n\n\n    while (is_valid(plink)) {\n\n        pci_dma_read(&s->dev, plink & ~0xf, &ptd, sizeof(ptd));\n\n        le32_to_cpus(&ptd.link);\n\n        le32_to_cpus(&ptd.ctrl);\n\n        le32_to_cpus(&ptd.token);\n\n        le32_to_cpus(&ptd.buffer);\n\n        if (!(ptd.ctrl & TD_CTRL_ACTIVE)) {\n\n            break;\n\n        }\n\n        if (uhci_queue_token(&ptd) != token) {\n\n            break;\n\n        }\n\n        trace_usb_uhci_td_queue(plink & ~0xf, ptd.ctrl, ptd.token);\n\n        ret = uhci_handle_td(s, plink, &ptd, &int_mask, true);\n\n        if (ret == TD_RESULT_ASYNC_CONT) {\n\n            break;\n\n        }\n\n        assert(ret == TD_RESULT_ASYNC_START);\n\n        assert(int_mask == 0);\n\n        if (ptd.ctrl & TD_CTRL_SPD) {\n\n            break;\n\n        }\n\n        plink = ptd.link;\n\n    }\n\n}\n", "idx": 26788}
{"project": "qemu", "commit_id": "8152ceaf6eea6d63f6ee65eb419fff56bb3b987b", "target": 0, "func": "static inline int get_segment(CPUPPCState *env, mmu_ctx_t *ctx,\n\n                              target_ulong eaddr, int rw, int type)\n\n{\n\n    hwaddr hash;\n\n    target_ulong vsid;\n\n    int ds, pr, target_page_bits;\n\n    int ret, ret2;\n\n\n\n    pr = msr_pr;\n\n    ctx->eaddr = eaddr;\n\n#if defined(TARGET_PPC64)\n\n    if (env->mmu_model & POWERPC_MMU_64) {\n\n        ppc_slb_t *slb;\n\n        target_ulong pageaddr;\n\n        int segment_bits;\n\n\n\n        LOG_MMU(\"Check SLBs\\n\");\n\n        slb = slb_lookup(env, eaddr);\n\n        if (!slb) {\n\n            return -5;\n\n        }\n\n\n\n        if (slb->vsid & SLB_VSID_B) {\n\n            vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT_1T;\n\n            segment_bits = 40;\n\n        } else {\n\n            vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT;\n\n            segment_bits = 28;\n\n        }\n\n\n\n        target_page_bits = (slb->vsid & SLB_VSID_L)\n\n            ? TARGET_PAGE_BITS_16M : TARGET_PAGE_BITS;\n\n        ctx->key = !!(pr ? (slb->vsid & SLB_VSID_KP)\n\n                      : (slb->vsid & SLB_VSID_KS));\n\n        ds = 0;\n\n        ctx->nx = !!(slb->vsid & SLB_VSID_N);\n\n\n\n        pageaddr = eaddr & ((1ULL << segment_bits)\n\n                            - (1ULL << target_page_bits));\n\n        if (slb->vsid & SLB_VSID_B) {\n\n            hash = vsid ^ (vsid << 25) ^ (pageaddr >> target_page_bits);\n\n        } else {\n\n            hash = vsid ^ (pageaddr >> target_page_bits);\n\n        }\n\n        /* Only 5 bits of the page index are used in the AVPN */\n\n        ctx->ptem = (slb->vsid & SLB_VSID_PTEM) |\n\n            ((pageaddr >> 16) & ((1ULL << segment_bits) - 0x80));\n\n    } else\n\n#endif /* defined(TARGET_PPC64) */\n\n    {\n\n        target_ulong sr, pgidx;\n\n\n\n        sr = env->sr[eaddr >> 28];\n\n        ctx->key = (((sr & 0x20000000) && (pr != 0)) ||\n\n                    ((sr & 0x40000000) && (pr == 0))) ? 1 : 0;\n\n        ds = sr & 0x80000000 ? 1 : 0;\n\n        ctx->nx = sr & 0x10000000 ? 1 : 0;\n\n        vsid = sr & 0x00FFFFFF;\n\n        target_page_bits = TARGET_PAGE_BITS;\n\n        LOG_MMU(\"Check segment v=\" TARGET_FMT_lx \" %d \" TARGET_FMT_lx \" nip=\"\n\n                TARGET_FMT_lx \" lr=\" TARGET_FMT_lx\n\n                \" ir=%d dr=%d pr=%d %d t=%d\\n\",\n\n                eaddr, (int)(eaddr >> 28), sr, env->nip, env->lr, (int)msr_ir,\n\n                (int)msr_dr, pr != 0 ? 1 : 0, rw, type);\n\n        pgidx = (eaddr & ~SEGMENT_MASK_256M) >> target_page_bits;\n\n        hash = vsid ^ pgidx;\n\n        ctx->ptem = (vsid << 7) | (pgidx >> 10);\n\n    }\n\n    LOG_MMU(\"pte segment: key=%d ds %d nx %d vsid \" TARGET_FMT_lx \"\\n\",\n\n            ctx->key, ds, ctx->nx, vsid);\n\n    ret = -1;\n\n    if (!ds) {\n\n        /* Check if instruction fetch is allowed, if needed */\n\n        if (type != ACCESS_CODE || ctx->nx == 0) {\n\n            /* Page address translation */\n\n            LOG_MMU(\"htab_base \" TARGET_FMT_plx \" htab_mask \" TARGET_FMT_plx\n\n                    \" hash \" TARGET_FMT_plx \"\\n\",\n\n                    env->htab_base, env->htab_mask, hash);\n\n            ctx->hash[0] = hash;\n\n            ctx->hash[1] = ~hash;\n\n\n\n            /* Initialize real address with an invalid value */\n\n            ctx->raddr = (hwaddr)-1ULL;\n\n            if (unlikely(env->mmu_model == POWERPC_MMU_SOFT_6xx ||\n\n                         env->mmu_model == POWERPC_MMU_SOFT_74xx)) {\n\n                /* Software TLB search */\n\n                ret = ppc6xx_tlb_check(env, ctx, eaddr, rw, type);\n\n            } else {\n\n                LOG_MMU(\"0 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n                        \" vsid=\" TARGET_FMT_lx \" ptem=\" TARGET_FMT_lx\n\n                        \" hash=\" TARGET_FMT_plx \"\\n\",\n\n                        env->htab_base, env->htab_mask, vsid, ctx->ptem,\n\n                        ctx->hash[0]);\n\n                /* Primary table lookup */\n\n                ret = find_pte(env, ctx, 0, rw, type, target_page_bits);\n\n                if (ret < 0) {\n\n                    /* Secondary table lookup */\n\n                    if (eaddr != 0xEFFFFFFF) {\n\n                        LOG_MMU(\"1 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n                                \" vsid=\" TARGET_FMT_lx \" api=\" TARGET_FMT_lx\n\n                                \" hash=\" TARGET_FMT_plx \"\\n\", env->htab_base,\n\n                                env->htab_mask, vsid, ctx->ptem, ctx->hash[1]);\n\n                    }\n\n                    ret2 = find_pte(env, ctx, 1, rw, type,\n\n                                    target_page_bits);\n\n                    if (ret2 != -1) {\n\n                        ret = ret2;\n\n                    }\n\n                }\n\n            }\n\n#if defined(DUMP_PAGE_TABLES)\n\n            if (qemu_log_enabled()) {\n\n                hwaddr curaddr;\n\n                uint32_t a0, a1, a2, a3;\n\n\n\n                qemu_log(\"Page table: \" TARGET_FMT_plx \" len \" TARGET_FMT_plx\n\n                         \"\\n\", sdr, mask + 0x80);\n\n                for (curaddr = sdr; curaddr < (sdr + mask + 0x80);\n\n                     curaddr += 16) {\n\n                    a0 = ldl_phys(curaddr);\n\n                    a1 = ldl_phys(curaddr + 4);\n\n                    a2 = ldl_phys(curaddr + 8);\n\n                    a3 = ldl_phys(curaddr + 12);\n\n                    if (a0 != 0 || a1 != 0 || a2 != 0 || a3 != 0) {\n\n                        qemu_log(TARGET_FMT_plx \": %08x %08x %08x %08x\\n\",\n\n                                 curaddr, a0, a1, a2, a3);\n\n                    }\n\n                }\n\n            }\n\n#endif\n\n        } else {\n\n            LOG_MMU(\"No access allowed\\n\");\n\n            ret = -3;\n\n        }\n\n    } else {\n\n        target_ulong sr;\n\n\n\n        LOG_MMU(\"direct store...\\n\");\n\n        /* Direct-store segment : absolutely *BUGGY* for now */\n\n\n\n        /* Direct-store implies a 32-bit MMU.\n\n         * Check the Segment Register's bus unit ID (BUID).\n\n         */\n\n        sr = env->sr[eaddr >> 28];\n\n        if ((sr & 0x1FF00000) >> 20 == 0x07f) {\n\n            /* Memory-forced I/O controller interface access */\n\n            /* If T=1 and BUID=x'07F', the 601 performs a memory access\n\n             * to SR[28-31] LA[4-31], bypassing all protection mechanisms.\n\n             */\n\n            ctx->raddr = ((sr & 0xF) << 28) | (eaddr & 0x0FFFFFFF);\n\n            ctx->prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n            return 0;\n\n        }\n\n\n\n        switch (type) {\n\n        case ACCESS_INT:\n\n            /* Integer load/store : only access allowed */\n\n            break;\n\n        case ACCESS_CODE:\n\n            /* No code fetch is allowed in direct-store areas */\n\n            return -4;\n\n        case ACCESS_FLOAT:\n\n            /* Floating point load/store */\n\n            return -4;\n\n        case ACCESS_RES:\n\n            /* lwarx, ldarx or srwcx. */\n\n            return -4;\n\n        case ACCESS_CACHE:\n\n            /* dcba, dcbt, dcbtst, dcbf, dcbi, dcbst, dcbz, or icbi */\n\n            /* Should make the instruction do no-op.\n\n             * As it already do no-op, it's quite easy :-)\n\n             */\n\n            ctx->raddr = eaddr;\n\n            return 0;\n\n        case ACCESS_EXT:\n\n            /* eciwx or ecowx */\n\n            return -4;\n\n        default:\n\n            qemu_log(\"ERROR: instruction should not need \"\n\n                        \"address translation\\n\");\n\n            return -4;\n\n        }\n\n        if ((rw == 1 || ctx->key != 1) && (rw == 0 || ctx->key != 0)) {\n\n            ctx->raddr = eaddr;\n\n            ret = 2;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 26789}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static void char_socket_test(void)\n\n{\n\n    Chardev *chr = qemu_chr_new(\"server\", \"tcp:127.0.0.1:0,server,nowait\");\n\n    Chardev *chr_client;\n\n    QObject *addr;\n\n    QDict *qdict, *data;\n\n    const char *port;\n\n    SocketIdleData d = { .chr = chr };\n\n    CharBackend be;\n\n    CharBackend client_be;\n\n    char *tmp;\n\n\n\n    d.be = &be;\n\n    d.client_be = &be;\n\n\n\n    g_assert_nonnull(chr);\n\n    g_assert(!object_property_get_bool(OBJECT(chr), \"connected\", &error_abort));\n\n\n\n    addr = object_property_get_qobject(OBJECT(chr), \"addr\", &error_abort);\n\n    qdict = qobject_to_qdict(addr);\n\n    data = qdict_get_qdict(qdict, \"data\");\n\n    port = qdict_get_str(data, \"port\");\n\n    tmp = g_strdup_printf(\"tcp:127.0.0.1:%s\", port);\n\n    QDECREF(qdict);\n\n\n\n    qemu_chr_fe_init(&be, chr, &error_abort);\n\n    qemu_chr_fe_set_handlers(&be, socket_can_read, socket_read,\n\n                             NULL, &d, NULL, true);\n\n\n\n    chr_client = qemu_chr_new(\"client\", tmp);\n\n    qemu_chr_fe_init(&client_be, chr_client, &error_abort);\n\n    qemu_chr_fe_set_handlers(&client_be, socket_can_read_hello,\n\n                             socket_read_hello,\n\n                             NULL, &d, NULL, true);\n\n    g_free(tmp);\n\n\n\n    d.conn_expected = true;\n\n    guint id = g_idle_add(char_socket_test_idle, &d);\n\n    g_source_set_name_by_id(id, \"test-idle\");\n\n    g_assert_cmpint(id, >, 0);\n\n    main_loop();\n\n\n\n    g_assert(object_property_get_bool(OBJECT(chr), \"connected\", &error_abort));\n\n    g_assert(object_property_get_bool(OBJECT(chr_client),\n\n                                      \"connected\", &error_abort));\n\n\n\n    qemu_chr_write_all(chr_client, (const uint8_t *)\"Z\", 1);\n\n    main_loop();\n\n\n\n    object_unparent(OBJECT(chr_client));\n\n\n\n    d.conn_expected = false;\n\n    g_idle_add(char_socket_test_idle, &d);\n\n    main_loop();\n\n\n\n    object_unparent(OBJECT(chr));\n\n}\n", "idx": 26790}
{"project": "qemu", "commit_id": "da98c8eb4c35225049cad8cf767647eb39788b5d", "target": 0, "func": "void acpi_pm1_cnt_init(ACPIREGS *ar, qemu_irq cmos_s3)\n\n{\n\n    ar->pm1.cnt.cmos_s3 = cmos_s3;\n\n}\n", "idx": 26791}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int i2c_start_transfer(i2c_bus *bus, int address, int recv)\n\n{\n\n    DeviceState *qdev;\n\n    i2c_slave *slave = NULL;\n\n\n\n    LIST_FOREACH(qdev, &bus->qbus.children, sibling) {\n\n        slave = I2C_SLAVE_FROM_QDEV(qdev);\n\n        if (slave->address == address)\n\n            break;\n\n    }\n\n\n\n    if (!slave)\n\n        return 1;\n\n\n\n    /* If the bus is already busy, assume this is a repeated\n\n       start condition.  */\n\n    bus->current_dev = slave;\n\n    slave->info->event(slave, recv ? I2C_START_RECV : I2C_START_SEND);\n\n    return 0;\n\n}\n", "idx": 26792}
{"project": "qemu", "commit_id": "ad07cd69ecaffbaa015459a46975ab32e50df805", "target": 0, "func": "void virtio_scsi_dataplane_start(VirtIOSCSI *s)\n\n{\n\n    int i;\n\n    int rc;\n\n    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(s)));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(s);\n\n\n\n    if (s->dataplane_started ||\n\n        s->dataplane_starting ||\n\n        s->dataplane_fenced ||\n\n        s->ctx != iothread_get_aio_context(vs->conf.iothread)) {\n\n        return;\n\n    }\n\n\n\n    s->dataplane_starting = true;\n\n\n\n    /* Set up guest notifier (irq) */\n\n    rc = k->set_guest_notifiers(qbus->parent, vs->conf.num_queues + 2, true);\n\n    if (rc != 0) {\n\n        fprintf(stderr, \"virtio-scsi: Failed to set guest notifiers (%d), \"\n\n                \"ensure -enable-kvm is set\\n\", rc);\n\n        goto fail_guest_notifiers;\n\n    }\n\n\n\n    aio_context_acquire(s->ctx);\n\n    rc = virtio_scsi_vring_init(s, vs->ctrl_vq, 0,\n\n                                virtio_scsi_data_plane_handle_ctrl);\n\n    if (rc) {\n\n        goto fail_vrings;\n\n    }\n\n    rc = virtio_scsi_vring_init(s, vs->event_vq, 1,\n\n                                virtio_scsi_data_plane_handle_event);\n\n    if (rc) {\n\n        goto fail_vrings;\n\n    }\n\n    for (i = 0; i < vs->conf.num_queues; i++) {\n\n        rc = virtio_scsi_vring_init(s, vs->cmd_vqs[i], i + 2,\n\n                                    virtio_scsi_data_plane_handle_cmd);\n\n        if (rc) {\n\n            goto fail_vrings;\n\n        }\n\n    }\n\n\n\n    s->dataplane_starting = false;\n\n    s->dataplane_started = true;\n\n    aio_context_release(s->ctx);\n\n    return;\n\n\n\nfail_vrings:\n\n    virtio_scsi_clear_aio(s);\n\n    aio_context_release(s->ctx);\n\n    for (i = 0; i < vs->conf.num_queues + 2; i++) {\n\n        virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), i, false);\n\n    }\n\n    k->set_guest_notifiers(qbus->parent, vs->conf.num_queues + 2, false);\n\nfail_guest_notifiers:\n\n    s->dataplane_fenced = true;\n\n    s->dataplane_starting = false;\n\n    s->dataplane_started = true;\n\n}\n", "idx": 26793}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void disas_fp_csel(DisasContext *s, uint32_t insn)\n\n{\n\n    unsigned int mos, type, rm, cond, rn, rd;\n\n    int label_continue = -1;\n\n\n\n    mos = extract32(insn, 29, 3);\n\n    type = extract32(insn, 22, 2); /* 0 = single, 1 = double */\n\n    rm = extract32(insn, 16, 5);\n\n    cond = extract32(insn, 12, 4);\n\n    rn = extract32(insn, 5, 5);\n\n    rd = extract32(insn, 0, 5);\n\n\n\n    if (mos || type > 1) {\n\n        unallocated_encoding(s);\n\n        return;\n\n    }\n\n\n\n    if (!fp_access_check(s)) {\n\n        return;\n\n    }\n\n\n\n    if (cond < 0x0e) { /* not always */\n\n        int label_match = gen_new_label();\n\n        label_continue = gen_new_label();\n\n        arm_gen_test_cc(cond, label_match);\n\n        /* nomatch: */\n\n        gen_mov_fp2fp(s, type, rd, rm);\n\n        tcg_gen_br(label_continue);\n\n        gen_set_label(label_match);\n\n    }\n\n\n\n    gen_mov_fp2fp(s, type, rd, rn);\n\n\n\n    if (cond < 0x0e) { /* continue */\n\n        gen_set_label(label_continue);\n\n    }\n\n}\n", "idx": 26794}
{"project": "qemu", "commit_id": "53a295131274c87914c97053e2ca00f19a9c2efa", "target": 0, "func": "int bdrv_open(BlockDriverState **pbs, const char *filename,\n\n              const char *reference, QDict *options, int flags,\n\n              BlockDriver *drv, Error **errp)\n\n{\n\n    int ret;\n\n    BlockDriverState *file = NULL, *bs;\n\n    const char *drvname;\n\n    Error *local_err = NULL;\n\n    int snapshot_flags = 0;\n\n\n\n    assert(pbs);\n\n\n\n    if (reference) {\n\n        bool options_non_empty = options ? qdict_size(options) : false;\n\n        QDECREF(options);\n\n\n\n        if (*pbs) {\n\n            error_setg(errp, \"Cannot reuse an existing BDS when referencing \"\n\n                       \"another block device\");\n\n            return -EINVAL;\n\n        }\n\n\n\n        if (filename || options_non_empty) {\n\n            error_setg(errp, \"Cannot reference an existing block device with \"\n\n                       \"additional options or a new filename\");\n\n            return -EINVAL;\n\n        }\n\n\n\n        bs = bdrv_lookup_bs(reference, reference, errp);\n\n        if (!bs) {\n\n            return -ENODEV;\n\n        }\n\n        bdrv_ref(bs);\n\n        *pbs = bs;\n\n        return 0;\n\n    }\n\n\n\n    if (*pbs) {\n\n        bs = *pbs;\n\n    } else {\n\n        bs = bdrv_new();\n\n    }\n\n\n\n    /* NULL means an empty set of options */\n\n    if (options == NULL) {\n\n        options = qdict_new();\n\n    }\n\n\n\n    ret = bdrv_fill_options(&options, &filename, flags, drv, &local_err);\n\n    if (local_err) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Find the right image format driver */\n\n    drv = NULL;\n\n    drvname = qdict_get_try_str(options, \"driver\");\n\n    if (drvname) {\n\n        drv = bdrv_find_format(drvname);\n\n        qdict_del(options, \"driver\");\n\n        if (!drv) {\n\n            error_setg(errp, \"Unknown driver: '%s'\", drvname);\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    assert(drvname || !(flags & BDRV_O_PROTOCOL));\n\n    if (drv && !drv->bdrv_file_open) {\n\n        /* If the user explicitly wants a format driver here, we'll need to add\n\n         * another layer for the protocol in bs->file */\n\n        flags &= ~BDRV_O_PROTOCOL;\n\n    }\n\n\n\n    bs->options = options;\n\n    options = qdict_clone_shallow(options);\n\n\n\n    /* Open image file without format layer */\n\n    if ((flags & BDRV_O_PROTOCOL) == 0) {\n\n        if (flags & BDRV_O_RDWR) {\n\n            flags |= BDRV_O_ALLOW_RDWR;\n\n        }\n\n        if (flags & BDRV_O_SNAPSHOT) {\n\n            snapshot_flags = bdrv_temp_snapshot_flags(flags);\n\n            flags = bdrv_backing_flags(flags);\n\n        }\n\n\n\n        assert(file == NULL);\n\n        ret = bdrv_open_image(&file, filename, options, \"file\",\n\n                              bdrv_inherited_flags(flags),\n\n                              true, &local_err);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    /* Image format probing */\n\n    bs->probed = !drv;\n\n    if (!drv && file) {\n\n        ret = find_image_format(file, filename, &drv, &local_err);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n    } else if (!drv) {\n\n        error_setg(errp, \"Must specify either driver or file\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    /* Open the image */\n\n    ret = bdrv_open_common(bs, file, options, flags, drv, &local_err);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    if (file && (bs->file != file)) {\n\n        bdrv_unref(file);\n\n        file = NULL;\n\n    }\n\n\n\n    /* If there is a backing file, use it */\n\n    if ((flags & BDRV_O_NO_BACKING) == 0) {\n\n        QDict *backing_options;\n\n\n\n        qdict_extract_subqdict(options, &backing_options, \"backing.\");\n\n        ret = bdrv_open_backing_file(bs, backing_options, &local_err);\n\n        if (ret < 0) {\n\n            goto close_and_fail;\n\n        }\n\n    }\n\n\n\n    bdrv_refresh_filename(bs);\n\n\n\n    /* For snapshot=on, create a temporary qcow2 overlay. bs points to the\n\n     * temporary snapshot afterwards. */\n\n    if (snapshot_flags) {\n\n        ret = bdrv_append_temp_snapshot(bs, snapshot_flags, &local_err);\n\n        if (local_err) {\n\n            goto close_and_fail;\n\n        }\n\n    }\n\n\n\n    /* Check if any unknown options were used */\n\n    if (options && (qdict_size(options) != 0)) {\n\n        const QDictEntry *entry = qdict_first(options);\n\n        if (flags & BDRV_O_PROTOCOL) {\n\n            error_setg(errp, \"Block protocol '%s' doesn't support the option \"\n\n                       \"'%s'\", drv->format_name, entry->key);\n\n        } else {\n\n            error_setg(errp, \"Block format '%s' used by device '%s' doesn't \"\n\n                       \"support the option '%s'\", drv->format_name,\n\n                       bdrv_get_device_name(bs), entry->key);\n\n        }\n\n\n\n        ret = -EINVAL;\n\n        goto close_and_fail;\n\n    }\n\n\n\n    if (!bdrv_key_required(bs)) {\n\n        if (bs->blk) {\n\n            blk_dev_change_media_cb(bs->blk, true);\n\n        }\n\n    } else if (!runstate_check(RUN_STATE_PRELAUNCH)\n\n               && !runstate_check(RUN_STATE_INMIGRATE)\n\n               && !runstate_check(RUN_STATE_PAUSED)) { /* HACK */\n\n        error_setg(errp,\n\n                   \"Guest must be stopped for opening of encrypted image\");\n\n        ret = -EBUSY;\n\n        goto close_and_fail;\n\n    }\n\n\n\n    QDECREF(options);\n\n    *pbs = bs;\n\n    return 0;\n\n\n\nfail:\n\n    if (file != NULL) {\n\n        bdrv_unref(file);\n\n    }\n\n    QDECREF(bs->options);\n\n    QDECREF(options);\n\n    bs->options = NULL;\n\n    if (!*pbs) {\n\n        /* If *pbs is NULL, a new BDS has been created in this function and\n\n           needs to be freed now. Otherwise, it does not need to be closed,\n\n           since it has not really been opened yet. */\n\n        bdrv_unref(bs);\n\n    }\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n    }\n\n    return ret;\n\n\n\nclose_and_fail:\n\n    /* See fail path, but now the BDS has to be always closed */\n\n    if (*pbs) {\n\n        bdrv_close(bs);\n\n    } else {\n\n        bdrv_unref(bs);\n\n    }\n\n    QDECREF(options);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n    }\n\n    return ret;\n\n}\n", "idx": 26795}
{"project": "qemu", "commit_id": "ac531cb6e542b1e61d668604adf9dc5306a948c0", "target": 0, "func": "START_TEST(qdict_haskey_test)\n\n{\n\n    const char *key = \"test\";\n\n\n\n    qdict_put(tests_dict, key, qint_from_int(0));\n\n    fail_unless(qdict_haskey(tests_dict, key) == 1);\n\n}\n", "idx": 26796}
{"project": "qemu", "commit_id": "2de7e26891db3d5b7f214fa485a5e946b17a57b9", "target": 0, "func": "static void pc_dimm_check_memdev_is_busy(const Object *obj, const char *name,\n\n                                      Object *val, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n\n\n    if (host_memory_backend_is_mapped(MEMORY_BACKEND(val))) {\n\n        char *path = object_get_canonical_path_component(val);\n\n        error_setg(&local_err, \"can't use already busy memdev: %s\", path);\n\n        g_free(path);\n\n    } else {\n\n        qdev_prop_allow_set_link_before_realize(obj, name, val, &local_err);\n\n    }\n\n\n\n    error_propagate(errp, local_err);\n\n}\n", "idx": 26797}
{"project": "qemu", "commit_id": "fe52840c8760122257be7b7e4893dd951480a71f", "target": 0, "func": "void co_run_in_worker_bh(void *opaque)\n\n{\n\n    Coroutine *co = opaque;\n\n    thread_pool_submit_aio(aio_get_thread_pool(qemu_get_aio_context()),\n\n                           coroutine_enter_func, co, coroutine_enter_cb, co);\n\n}\n", "idx": 26798}
{"project": "qemu", "commit_id": "1237ad7607aae5859067831e36a59d3b017c5a54", "target": 0, "func": "static int local_fstat(FsContext *ctx, int fd, struct stat *stbuf)\n\n{\n\n    return fstat(fd, stbuf);\n\n}\n", "idx": 26799}
{"project": "qemu", "commit_id": "75af1f34cd5b07c3c7fcf86dfc99a42de48a600d", "target": 0, "func": "static bool virtio_blk_sect_range_ok(VirtIOBlock *dev,\n\n                                     uint64_t sector, size_t size)\n\n{\n\n    uint64_t nb_sectors = size >> BDRV_SECTOR_BITS;\n\n    uint64_t total_sectors;\n\n\n\n    if (nb_sectors > INT_MAX) {\n\n        return false;\n\n    }\n\n    if (sector & dev->sector_mask) {\n\n        return false;\n\n    }\n\n    if (size % dev->conf.conf.logical_block_size) {\n\n        return false;\n\n    }\n\n    blk_get_geometry(dev->blk, &total_sectors);\n\n    if (sector > total_sectors || nb_sectors > total_sectors - sector) {\n\n        return false;\n\n    }\n\n    return true;\n\n}\n", "idx": 26800}
{"project": "qemu", "commit_id": "ae67dc72e4f19238941894227d96b6201d71a70a", "target": 0, "func": "static void do_interrupt64(CPUX86State *env, int intno, int is_int,\n\n                           int error_code, target_ulong next_eip, int is_hw)\n\n{\n\n    SegmentCache *dt;\n\n    target_ulong ptr;\n\n    int type, dpl, selector, cpl, ist;\n\n    int has_error_code, new_stack;\n\n    uint32_t e1, e2, e3, ss;\n\n    target_ulong old_eip, esp, offset;\n\n\n\n    has_error_code = 0;\n\n    if (!is_int && !is_hw) {\n\n        has_error_code = exception_has_error_code(intno);\n\n    }\n\n    if (is_int) {\n\n        old_eip = next_eip;\n\n    } else {\n\n        old_eip = env->eip;\n\n    }\n\n\n\n    dt = &env->idt;\n\n    if (intno * 16 + 15 > dt->limit) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);\n\n    }\n\n    ptr = dt->base + intno * 16;\n\n    e1 = cpu_ldl_kernel(env, ptr);\n\n    e2 = cpu_ldl_kernel(env, ptr + 4);\n\n    e3 = cpu_ldl_kernel(env, ptr + 8);\n\n    /* check gate type */\n\n    type = (e2 >> DESC_TYPE_SHIFT) & 0x1f;\n\n    switch (type) {\n\n    case 14: /* 386 interrupt gate */\n\n    case 15: /* 386 trap gate */\n\n        break;\n\n    default:\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);\n\n        break;\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    cpl = env->hflags & HF_CPL_MASK;\n\n    /* check privilege if software int */\n\n    if (is_int && dpl < cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);\n\n    }\n\n    /* check valid bit */\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, intno * 16 + 2);\n\n    }\n\n    selector = e1 >> 16;\n\n    offset = ((target_ulong)e3 << 32) | (e2 & 0xffff0000) | (e1 & 0x0000ffff);\n\n    ist = e2 & 7;\n\n    if ((selector & 0xfffc) == 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, 0);\n\n    }\n\n\n\n    if (load_segment(env, &e1, &e2, selector) != 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    if (dpl > cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_L_MASK) || (e2 & DESC_B_MASK)) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if ((!(e2 & DESC_C_MASK) && dpl < cpl) || ist != 0) {\n\n        /* to inner privilege */\n\n        if (ist != 0) {\n\n            esp = get_rsp_from_tss(env, ist + 3);\n\n        } else {\n\n            esp = get_rsp_from_tss(env, dpl);\n\n        }\n\n        esp &= ~0xfLL; /* align stack */\n\n        ss = 0;\n\n        new_stack = 1;\n\n    } else if ((e2 & DESC_C_MASK) || dpl == cpl) {\n\n        /* to same privilege */\n\n        if (env->eflags & VM_MASK) {\n\n            raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        }\n\n        new_stack = 0;\n\n        if (ist != 0) {\n\n            esp = get_rsp_from_tss(env, ist + 3);\n\n        } else {\n\n            esp = env->regs[R_ESP];\n\n        }\n\n        esp &= ~0xfLL; /* align stack */\n\n        dpl = cpl;\n\n    } else {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        new_stack = 0; /* avoid warning */\n\n        esp = 0; /* avoid warning */\n\n    }\n\n\n\n    PUSHQ(esp, env->segs[R_SS].selector);\n\n    PUSHQ(esp, env->regs[R_ESP]);\n\n    PUSHQ(esp, cpu_compute_eflags(env));\n\n    PUSHQ(esp, env->segs[R_CS].selector);\n\n    PUSHQ(esp, old_eip);\n\n    if (has_error_code) {\n\n        PUSHQ(esp, error_code);\n\n    }\n\n\n\n    /* interrupt gate clear IF mask */\n\n    if ((type & 1) == 0) {\n\n        env->eflags &= ~IF_MASK;\n\n    }\n\n    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);\n\n\n\n    if (new_stack) {\n\n        ss = 0 | dpl;\n\n        cpu_x86_load_seg_cache(env, R_SS, ss, 0, 0, 0);\n\n    }\n\n    env->regs[R_ESP] = esp;\n\n\n\n    selector = (selector & ~3) | dpl;\n\n    cpu_x86_load_seg_cache(env, R_CS, selector,\n\n                   get_seg_base(e1, e2),\n\n                   get_seg_limit(e1, e2),\n\n                   e2);\n\n    env->eip = offset;\n\n}\n", "idx": 26802}
{"project": "qemu", "commit_id": "d368ba4376b2c1c24175c74b3733b8fe64dbe8a6", "target": 0, "func": "static void sdhci_generic_reset(DeviceState *ds)\n\n{\n\n    SDHCIState *s = SDHCI(ds);\n\n    SDHCI_GET_CLASS(s)->reset(s);\n\n}\n", "idx": 26803}
{"project": "qemu", "commit_id": "90e496386fe7fd32c189561f846b7913f95b8cf4", "target": 0, "func": "static void write_vec_element_i32(DisasContext *s, TCGv_i32 tcg_src,\n\n                                  int destidx, int element, TCGMemOp memop)\n\n{\n\n    int vect_off = vec_reg_offset(destidx, element, memop & MO_SIZE);\n\n    switch (memop) {\n\n    case MO_8:\n\n        tcg_gen_st8_i32(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    case MO_16:\n\n        tcg_gen_st16_i32(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    case MO_32:\n\n        tcg_gen_st_i32(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n}\n", "idx": 26804}
{"project": "qemu", "commit_id": "011de2b512a83aa5e9f8899ed5bbf2f31995b90e", "target": 0, "func": "static void net_socket_cleanup(NetClientState *nc)\n\n{\n\n    NetSocketState *s = DO_UPCAST(NetSocketState, nc, nc);\n\n    qemu_set_fd_handler(s->fd, NULL, NULL, NULL);\n\n    close(s->fd);\n\n}\n", "idx": 26805}
{"project": "qemu", "commit_id": "107684c05d80c457aa6e81d090b36a1a294110ec", "target": 0, "func": "void qtest_init(const char *qtest_chrdev, const char *qtest_log, Error **errp)\n\n{\n\n    CharDriverState *chr;\n\n\n\n    chr = qemu_chr_new(\"qtest\", qtest_chrdev, NULL);\n\n\n\n    if (chr == NULL) {\n\n        error_setg(errp, \"Failed to initialize device for qtest: \\\"%s\\\"\",\n\n                   qtest_chrdev);\n\n        return;\n\n    }\n\n\n\n    qemu_chr_add_handlers(chr, qtest_can_read, qtest_read, qtest_event, chr);\n\n    qemu_chr_fe_set_echo(chr, true);\n\n\n\n    inbuf = g_string_new(\"\");\n\n\n\n    if (qtest_log) {\n\n        if (strcmp(qtest_log, \"none\") != 0) {\n\n            qtest_log_fp = fopen(qtest_log, \"w+\");\n\n        }\n\n    } else {\n\n        qtest_log_fp = stderr;\n\n    }\n\n\n\n    qtest_chr = chr;\n\n}\n", "idx": 26806}
{"project": "qemu", "commit_id": "4083733db5e4120939acee57019ff52db1f45b9d", "target": 0, "func": "static void console_refresh(QemuConsole *s)\n\n{\n\n    DisplaySurface *surface = qemu_console_surface(s);\n\n    TextCell *c;\n\n    int x, y, y1;\n\n\n\n    if (s->ds->have_text) {\n\n        s->text_x[0] = 0;\n\n        s->text_y[0] = 0;\n\n        s->text_x[1] = s->width - 1;\n\n        s->text_y[1] = s->height - 1;\n\n        s->cursor_invalidate = 1;\n\n    }\n\n\n\n    vga_fill_rect(s, 0, 0, surface_width(surface), surface_height(surface),\n\n                  color_table_rgb[0][COLOR_BLACK]);\n\n    y1 = s->y_displayed;\n\n    for (y = 0; y < s->height; y++) {\n\n        c = s->cells + y1 * s->width;\n\n        for (x = 0; x < s->width; x++) {\n\n            vga_putcharxy(s, x, y, c->ch,\n\n                          &(c->t_attrib));\n\n            c++;\n\n        }\n\n        if (++y1 == s->total_height) {\n\n            y1 = 0;\n\n        }\n\n    }\n\n    console_show_cursor(s, 1);\n\n    dpy_gfx_update(s, 0, 0,\n\n                   surface_width(surface), surface_height(surface));\n\n}\n", "idx": 26807}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void qemu_init_child_watch(void)\n\n{\n\n    struct sigaction act;\n\n    sigchld_bh = qemu_bh_new(sigchld_bh_handler, NULL);\n\n\n\n    memset(&act, 0, sizeof(act));\n\n    act.sa_handler = sigchld_handler;\n\n    act.sa_flags = SA_NOCLDSTOP;\n\n    sigaction(SIGCHLD, &act, NULL);\n\n}\n", "idx": 26808}
{"project": "qemu", "commit_id": "e2a176dfda32f5cf80703c2921a19fe75850c38c", "target": 0, "func": "static uint32_t taihu_cpld_readl (void *opaque, hwaddr addr)\n\n{\n\n    uint32_t ret;\n\n\n\n    ret = taihu_cpld_readb(opaque, addr) << 24;\n\n    ret |= taihu_cpld_readb(opaque, addr + 1) << 16;\n\n    ret |= taihu_cpld_readb(opaque, addr + 2) << 8;\n\n    ret |= taihu_cpld_readb(opaque, addr + 3);\n\n\n\n    return ret;\n\n}\n", "idx": 26809}
{"project": "qemu", "commit_id": "715c54071a43ab978dc12b9da22a5016203ed284", "target": 0, "func": "static int htab_save_complete(QEMUFile *f, void *opaque)\n\n{\n\n    sPAPRMachineState *spapr = opaque;\n\n\n\n    /* Iteration header */\n\n    qemu_put_be32(f, 0);\n\n\n\n    if (!spapr->htab) {\n\n        int rc;\n\n\n\n        assert(kvm_enabled());\n\n\n\n        rc = spapr_check_htab_fd(spapr);\n\n        if (rc < 0) {\n\n            return rc;\n\n        }\n\n\n\n        rc = kvmppc_save_htab(f, spapr->htab_fd, MAX_KVM_BUF_SIZE, -1);\n\n        if (rc < 0) {\n\n            return rc;\n\n        }\n\n        close(spapr->htab_fd);\n\n        spapr->htab_fd = -1;\n\n    } else {\n\n        htab_save_later_pass(f, spapr, -1);\n\n    }\n\n\n\n    /* End marker */\n\n    qemu_put_be32(f, 0);\n\n    qemu_put_be16(f, 0);\n\n    qemu_put_be16(f, 0);\n\n\n\n    return 0;\n\n}\n", "idx": 26810}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static uint32_t  ahci_port_read(AHCIState *s, int port, int offset)\n\n{\n\n    uint32_t val;\n\n    AHCIPortRegs *pr;\n\n    pr = &s->dev[port].port_regs;\n\n\n\n    switch (offset) {\n\n    case PORT_LST_ADDR:\n\n        val = pr->lst_addr;\n\n        break;\n\n    case PORT_LST_ADDR_HI:\n\n        val = pr->lst_addr_hi;\n\n        break;\n\n    case PORT_FIS_ADDR:\n\n        val = pr->fis_addr;\n\n        break;\n\n    case PORT_FIS_ADDR_HI:\n\n        val = pr->fis_addr_hi;\n\n        break;\n\n    case PORT_IRQ_STAT:\n\n        val = pr->irq_stat;\n\n        break;\n\n    case PORT_IRQ_MASK:\n\n        val = pr->irq_mask;\n\n        break;\n\n    case PORT_CMD:\n\n        val = pr->cmd;\n\n        break;\n\n    case PORT_TFDATA:\n\n        val = pr->tfdata;\n\n        break;\n\n    case PORT_SIG:\n\n        val = pr->sig;\n\n        break;\n\n    case PORT_SCR_STAT:\n\n        if (s->dev[port].port.ifs[0].bs) {\n\n            val = SATA_SCR_SSTATUS_DET_DEV_PRESENT_PHY_UP |\n\n                  SATA_SCR_SSTATUS_SPD_GEN1 | SATA_SCR_SSTATUS_IPM_ACTIVE;\n\n        } else {\n\n            val = SATA_SCR_SSTATUS_DET_NODEV;\n\n        }\n\n        break;\n\n    case PORT_SCR_CTL:\n\n        val = pr->scr_ctl;\n\n        break;\n\n    case PORT_SCR_ERR:\n\n        val = pr->scr_err;\n\n        break;\n\n    case PORT_SCR_ACT:\n\n        pr->scr_act &= ~s->dev[port].finished;\n\n        s->dev[port].finished = 0;\n\n        val = pr->scr_act;\n\n        break;\n\n    case PORT_CMD_ISSUE:\n\n        val = pr->cmd_issue;\n\n        break;\n\n    case PORT_RESERVED:\n\n    default:\n\n        val = 0;\n\n    }\n\n    DPRINTF(port, \"offset: 0x%x val: 0x%x\\n\", offset, val);\n\n    return val;\n\n\n\n}\n", "idx": 26811}
{"project": "qemu", "commit_id": "0d82d0e8b98cf0ea03a45f8542d835ebd3a84cd3", "target": 0, "func": "static int64_t buffered_set_rate_limit(void *opaque, int64_t new_rate)\n\n{\n\n    QEMUFileBuffered *s = opaque;\n\n    if (qemu_file_get_error(s->file)) {\n\n        goto out;\n\n    }\n\n    if (new_rate > SIZE_MAX) {\n\n        new_rate = SIZE_MAX;\n\n    }\n\n\n\n    s->xfer_limit = new_rate / 10;\n\n    \n\nout:\n\n    return s->xfer_limit;\n\n}\n", "idx": 26813}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "func": "static int mp_dacl_setxattr(FsContext *ctx, const char *path, const char *name,\n\n                            void *value, size_t size, int flags)\n\n{\n\n    char buffer[PATH_MAX];\n\n    return lsetxattr(rpath(ctx, path, buffer), MAP_ACL_DEFAULT, value,\n\n            size, flags);\n\n}\n", "idx": 26814}
{"project": "qemu", "commit_id": "3954d33ab7f82f5a5fa0ced231849920265a5fec", "target": 0, "func": "static int spapr_vio_check_reg(VIOsPAPRDevice *sdev, VIOsPAPRDeviceInfo *info)\n\n{\n\n    VIOsPAPRDevice *other_sdev;\n\n    DeviceState *qdev;\n\n    VIOsPAPRBus *sbus;\n\n\n\n    sbus = DO_UPCAST(VIOsPAPRBus, bus, sdev->qdev.parent_bus);\n\n\n\n    /*\n\n     * Check two device aren't given clashing addresses by the user (or some\n\n     * other mechanism). We have to open code this because we have to check\n\n     * for matches with devices other than us.\n\n     */\n\n    QTAILQ_FOREACH(qdev, &sbus->bus.children, sibling) {\n\n        other_sdev = DO_UPCAST(VIOsPAPRDevice, qdev, qdev);\n\n\n\n        if (other_sdev != sdev && other_sdev->reg == sdev->reg) {\n\n            fprintf(stderr, \"vio: %s and %s devices conflict at address %#x\\n\",\n\n                    info->qdev.name, other_sdev->qdev.info->name, sdev->reg);\n\n            return -EEXIST;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 26815}
{"project": "qemu", "commit_id": "6a9c4ef452c98060e919aa49db49c09ed8c37745", "target": 1, "func": "void cpu_ppc_set_papr(PowerPCCPU *cpu)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n\n\n\n    /* PAPR always has exception vectors in RAM not ROM. To ensure this,\n\n     * MSR[IP] should never be set.\n\n     *\n\n     * We also disallow setting of MSR_HV\n\n     */\n\n    env->msr_mask &= ~((1ull << MSR_EP) | MSR_HVB);\n\n\n\n    /* Set a full AMOR so guest can use the AMR as it sees fit */\n\n    env->spr[SPR_AMOR] = amor->default_value = 0xffffffffffffffffull;\n\n\n\n    /* Tell KVM that we're in PAPR mode */\n\n    if (kvm_enabled()) {\n\n        kvmppc_set_papr(cpu);\n\n    }\n\n}", "idx": 26823}
{"project": "qemu", "commit_id": "4c4f0e4801ac79632d03867c88aafc90b4ce503c", "target": 1, "func": "static uint64_t openpic_src_read(void *opaque, uint64_t addr, unsigned len)\n\n{\n\n    OpenPICState *opp = opaque;\n\n    uint32_t retval;\n\n    int idx;\n\n\n\n    DPRINTF(\"%s: addr %08x\\n\", __func__, addr);\n\n    retval = 0xFFFFFFFF;\n\n    if (addr & 0xF) {\n\n        return retval;\n\n    }\n\n    addr = addr & 0xFFF0;\n\n    idx = addr >> 5;\n\n    if (addr & 0x10) {\n\n        /* EXDE / IFEDE / IEEDE */\n\n        retval = read_IRQreg_ide(opp, idx);\n\n    } else {\n\n        /* EXVP / IFEVP / IEEVP */\n\n        retval = read_IRQreg_ipvp(opp, idx);\n\n    }\n\n    DPRINTF(\"%s: => %08x\\n\", __func__, retval);\n\n\n\n    return retval;\n\n}\n", "idx": 26827}
{"project": "qemu", "commit_id": "14a10fc39923b3af07c8c46d22cb20843bee3a72", "target": 1, "func": "static void moxie_cpu_realizefn(DeviceState *dev, Error **errp)\n\n{\n\n    MoxieCPU *cpu = MOXIE_CPU(dev);\n\n    MoxieCPUClass *mcc = MOXIE_CPU_GET_CLASS(dev);\n\n\n\n    cpu_reset(CPU(cpu));\n\n\n\n    mcc->parent_realize(dev, errp);\n\n}\n", "idx": 26830}
{"project": "qemu", "commit_id": "a880845f3d92e508e43fcc38f0631b91c203e5d5", "target": 1, "func": "int ga_install_service(const char *path, const char *logfile)\n\n{\n\n    SC_HANDLE manager;\n\n    SC_HANDLE service;\n\n    TCHAR cmdline[MAX_PATH];\n\n\n\n    if (GetModuleFileName(NULL, cmdline, MAX_PATH) == 0) {\n\n        printf_win_error(\"No full path to service's executable\");\n\n        return EXIT_FAILURE;\n\n    }\n\n\n\n    _snprintf(cmdline, MAX_PATH - strlen(cmdline), \"%s -d\", cmdline);\n\n\n\n    if (path) {\n\n        _snprintf(cmdline, MAX_PATH - strlen(cmdline), \"%s -p %s\", cmdline, path);\n\n    }\n\n    if (logfile) {\n\n        _snprintf(cmdline, MAX_PATH - strlen(cmdline), \"%s -l %s -v\",\n\n            cmdline, logfile);\n\n    }\n\n\n\n    g_debug(\"service's cmdline: %s\", cmdline);\n\n\n\n    manager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);\n\n    if (manager == NULL) {\n\n        printf_win_error(\"No handle to service control manager\");\n\n        return EXIT_FAILURE;\n\n    }\n\n\n\n    service = CreateService(manager, QGA_SERVICE_NAME, QGA_SERVICE_DISPLAY_NAME,\n\n        SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS, SERVICE_AUTO_START,\n\n        SERVICE_ERROR_NORMAL, cmdline, NULL, NULL, NULL, NULL, NULL);\n\n\n\n    if (service) {\n\n        SERVICE_DESCRIPTION desc = { (char *)QGA_SERVICE_DESCRIPTION };\n\n        ChangeServiceConfig2(service, SERVICE_CONFIG_DESCRIPTION, &desc);\n\n\n\n        printf(\"Service was installed successfully.\\n\");\n\n    } else {\n\n        printf_win_error(\"Failed to install service\");\n\n    }\n\n\n\n    CloseServiceHandle(service);\n\n    CloseServiceHandle(manager);\n\n\n\n    return (service == NULL);\n\n}\n", "idx": 26831}
{"project": "qemu", "commit_id": "271c0f68b4eae72691721243a1c37f46a3232d61", "target": 1, "func": "static void thread_pool_cancel(BlockDriverAIOCB *acb)\n\n{\n\n    ThreadPoolElement *elem = (ThreadPoolElement *)acb;\n\n    ThreadPool *pool = elem->pool;\n\n\n\n    trace_thread_pool_cancel(elem, elem->common.opaque);\n\n\n\n    qemu_mutex_lock(&pool->lock);\n\n    if (elem->state == THREAD_QUEUED &&\n\n        /* No thread has yet started working on elem. we can try to \"steal\"\n\n         * the item from the worker if we can get a signal from the\n\n         * semaphore.  Because this is non-blocking, we can do it with\n\n         * the lock taken and ensure that elem will remain THREAD_QUEUED.\n\n         */\n\n        qemu_sem_timedwait(&pool->sem, 0) == 0) {\n\n        QTAILQ_REMOVE(&pool->request_list, elem, reqs);\n\n        elem->state = THREAD_CANCELED;\n\n        event_notifier_set(&pool->notifier);\n\n    } else {\n\n        pool->pending_cancellations++;\n\n        while (elem->state != THREAD_CANCELED && elem->state != THREAD_DONE) {\n\n            qemu_cond_wait(&pool->check_cancel, &pool->lock);\n\n        }\n\n        pool->pending_cancellations--;\n\n    }\n\n    qemu_mutex_unlock(&pool->lock);\n\n\n}", "idx": 26833}
{"project": "qemu", "commit_id": "cb4b4fde82b064472c13fb9d983ca36a70e560aa", "target": 1, "func": "static void vhost_dev_unassign_memory(struct vhost_dev *dev,\n\n                                      uint64_t start_addr,\n\n                                      uint64_t size)\n\n{\n\n    int from, to, n = dev->mem->nregions;\n\n    /* Track overlapping/split regions for sanity checking. */\n\n    int overlap_start = 0, overlap_end = 0, overlap_middle = 0, split = 0;\n\n\n\n    for (from = 0, to = 0; from < n; ++from, ++to) {\n\n        struct vhost_memory_region *reg = dev->mem->regions + to;\n\n        uint64_t reglast;\n\n        uint64_t memlast;\n\n        uint64_t change;\n\n\n\n        /* clone old region */\n\n        if (to != from) {\n\n            memcpy(reg, dev->mem->regions + from, sizeof *reg);\n\n        }\n\n\n\n        /* No overlap is simple */\n\n        if (!ranges_overlap(reg->guest_phys_addr, reg->memory_size,\n\n                            start_addr, size)) {\n\n            continue;\n\n        }\n\n\n\n        /* Split only happens if supplied region\n\n         * is in the middle of an existing one. Thus it can not\n\n         * overlap with any other existing region. */\n\n        assert(!split);\n\n\n\n        reglast = range_get_last(reg->guest_phys_addr, reg->memory_size);\n\n        memlast = range_get_last(start_addr, size);\n\n\n\n        /* Remove whole region */\n\n        if (start_addr <= reg->guest_phys_addr && memlast >= reglast) {\n\n            --dev->mem->nregions;\n\n            --to;\n\n            assert(to >= 0);\n\n            ++overlap_middle;\n\n            continue;\n\n        }\n\n\n\n        /* Shrink region */\n\n        if (memlast >= reglast) {\n\n            reg->memory_size = start_addr - reg->guest_phys_addr;\n\n            assert(reg->memory_size);\n\n            assert(!overlap_end);\n\n            ++overlap_end;\n\n            continue;\n\n        }\n\n\n\n        /* Shift region */\n\n        if (start_addr <= reg->guest_phys_addr) {\n\n            change = memlast + 1 - reg->guest_phys_addr;\n\n            reg->memory_size -= change;\n\n            reg->guest_phys_addr += change;\n\n            reg->userspace_addr += change;\n\n            assert(reg->memory_size);\n\n            assert(!overlap_start);\n\n            ++overlap_start;\n\n            continue;\n\n        }\n\n\n\n        /* This only happens if supplied region\n\n         * is in the middle of an existing one. Thus it can not\n\n         * overlap with any other existing region. */\n\n        assert(!overlap_start);\n\n        assert(!overlap_end);\n\n        assert(!overlap_middle);\n\n        /* Split region: shrink first part, shift second part. */\n\n        memcpy(dev->mem->regions + n, reg, sizeof *reg);\n\n        reg->memory_size = start_addr - reg->guest_phys_addr;\n\n        assert(reg->memory_size);\n\n        change = memlast + 1 - reg->guest_phys_addr;\n\n        reg = dev->mem->regions + n;\n\n        reg->memory_size -= change;\n\n        assert(reg->memory_size);\n\n        reg->guest_phys_addr += change;\n\n        reg->userspace_addr += change;\n\n        /* Never add more than 1 region */\n\n        assert(dev->mem->nregions == n);\n\n        ++dev->mem->nregions;\n\n        ++split;\n\n    }\n\n}\n", "idx": 26834}
{"project": "qemu", "commit_id": "7f7454ec296b3403b4accec55349a8f0232d3576", "target": 1, "func": "static int pfpu_decode_insn(MilkymistPFPUState *s)\n\n{\n\n    uint32_t pc = s->regs[R_PC];\n\n    uint32_t insn = s->microcode[pc];\n\n    uint32_t reg_a = (insn >> 18) & 0x7f;\n\n    uint32_t reg_b = (insn >> 11) & 0x7f;\n\n    uint32_t op = (insn >> 7) & 0xf;\n\n    uint32_t reg_d = insn & 0x7f;\n\n    uint32_t r;\n\n    int latency = 0;\n\n\n\n    switch (op) {\n\n    case OP_NOP:\n\n        break;\n\n    case OP_FADD:\n\n    {\n\n        float a = REINTERPRET_CAST(float, s->gp_regs[reg_a]);\n\n        float b = REINTERPRET_CAST(float, s->gp_regs[reg_b]);\n\n        float t = a + b;\n\n        r = REINTERPRET_CAST(uint32_t, t);\n\n        latency = LATENCY_FADD;\n\n        D_EXEC(qemu_log(\"ADD a=%f b=%f t=%f, r=%08x\\n\", a, b, t, r));\n\n    } break;\n\n    case OP_FSUB:\n\n    {\n\n        float a = REINTERPRET_CAST(float, s->gp_regs[reg_a]);\n\n        float b = REINTERPRET_CAST(float, s->gp_regs[reg_b]);\n\n        float t = a - b;\n\n        r = REINTERPRET_CAST(uint32_t, t);\n\n        latency = LATENCY_FSUB;\n\n        D_EXEC(qemu_log(\"SUB a=%f b=%f t=%f, r=%08x\\n\", a, b, t, r));\n\n    } break;\n\n    case OP_FMUL:\n\n    {\n\n        float a = REINTERPRET_CAST(float, s->gp_regs[reg_a]);\n\n        float b = REINTERPRET_CAST(float, s->gp_regs[reg_b]);\n\n        float t = a * b;\n\n        r = REINTERPRET_CAST(uint32_t, t);\n\n        latency = LATENCY_FMUL;\n\n        D_EXEC(qemu_log(\"MUL a=%f b=%f t=%f, r=%08x\\n\", a, b, t, r));\n\n    } break;\n\n    case OP_FABS:\n\n    {\n\n        float a = REINTERPRET_CAST(float, s->gp_regs[reg_a]);\n\n        float t = fabsf(a);\n\n        r = REINTERPRET_CAST(uint32_t, t);\n\n        latency = LATENCY_FABS;\n\n        D_EXEC(qemu_log(\"ABS a=%f t=%f, r=%08x\\n\", a, t, r));\n\n    } break;\n\n    case OP_F2I:\n\n    {\n\n        float a = REINTERPRET_CAST(float, s->gp_regs[reg_a]);\n\n        int32_t t = a;\n\n        r = REINTERPRET_CAST(uint32_t, t);\n\n        latency = LATENCY_F2I;\n\n        D_EXEC(qemu_log(\"F2I a=%f t=%d, r=%08x\\n\", a, t, r));\n\n    } break;\n\n    case OP_I2F:\n\n    {\n\n        int32_t a = REINTERPRET_CAST(int32_t, s->gp_regs[reg_a]);\n\n        float t = a;\n\n        r = REINTERPRET_CAST(uint32_t, t);\n\n        latency = LATENCY_I2F;\n\n        D_EXEC(qemu_log(\"I2F a=%08x t=%f, r=%08x\\n\", a, t, r));\n\n    } break;\n\n    case OP_VECTOUT:\n\n    {\n\n        uint32_t a = cpu_to_be32(s->gp_regs[reg_a]);\n\n        uint32_t b = cpu_to_be32(s->gp_regs[reg_b]);\n\n        target_phys_addr_t dma_ptr =\n\n            get_dma_address(s->regs[R_MESHBASE],\n\n                    s->gp_regs[GPR_X], s->gp_regs[GPR_Y]);\n\n        cpu_physical_memory_write(dma_ptr, (uint8_t *)&a, 4);\n\n        cpu_physical_memory_write(dma_ptr + 4, (uint8_t *)&b, 4);\n\n        s->regs[R_LASTDMA] = dma_ptr + 4;\n\n        D_EXEC(qemu_log(\"VECTOUT a=%08x b=%08x dma=%08x\\n\", a, b, dma_ptr));\n\n        trace_milkymist_pfpu_vectout(a, b, dma_ptr);\n\n    } break;\n\n    case OP_SIN:\n\n    {\n\n        int32_t a = REINTERPRET_CAST(int32_t, s->gp_regs[reg_a]);\n\n        float t = sinf(a * (1.0f / (M_PI * 4096.0f)));\n\n        r = REINTERPRET_CAST(uint32_t, t);\n\n        latency = LATENCY_SIN;\n\n        D_EXEC(qemu_log(\"SIN a=%d t=%f, r=%08x\\n\", a, t, r));\n\n    } break;\n\n    case OP_COS:\n\n    {\n\n        int32_t a = REINTERPRET_CAST(int32_t, s->gp_regs[reg_a]);\n\n        float t = cosf(a * (1.0f / (M_PI * 4096.0f)));\n\n        r = REINTERPRET_CAST(uint32_t, t);\n\n        latency = LATENCY_COS;\n\n        D_EXEC(qemu_log(\"COS a=%d t=%f, r=%08x\\n\", a, t, r));\n\n    } break;\n\n    case OP_ABOVE:\n\n    {\n\n        float a = REINTERPRET_CAST(float, s->gp_regs[reg_a]);\n\n        float b = REINTERPRET_CAST(float, s->gp_regs[reg_b]);\n\n        float t = (a > b) ? 1.0f : 0.0f;\n\n        r = REINTERPRET_CAST(uint32_t, t);\n\n        latency = LATENCY_ABOVE;\n\n        D_EXEC(qemu_log(\"ABOVE a=%f b=%f t=%f, r=%08x\\n\", a, b, t, r));\n\n    } break;\n\n    case OP_EQUAL:\n\n    {\n\n        float a = REINTERPRET_CAST(float, s->gp_regs[reg_a]);\n\n        float b = REINTERPRET_CAST(float, s->gp_regs[reg_b]);\n\n        float t = (a == b) ? 1.0f : 0.0f;\n\n        r = REINTERPRET_CAST(uint32_t, t);\n\n        latency = LATENCY_EQUAL;\n\n        D_EXEC(qemu_log(\"EQUAL a=%f b=%f t=%f, r=%08x\\n\", a, b, t, r));\n\n    } break;\n\n    case OP_COPY:\n\n    {\n\n        r = s->gp_regs[reg_a];\n\n        latency = LATENCY_COPY;\n\n        D_EXEC(qemu_log(\"COPY\"));\n\n    } break;\n\n    case OP_IF:\n\n    {\n\n        float a = REINTERPRET_CAST(float, s->gp_regs[reg_a]);\n\n        float b = REINTERPRET_CAST(float, s->gp_regs[reg_b]);\n\n        uint32_t f = s->gp_regs[GPR_FLAGS];\n\n        float t = (f != 0) ? a : b;\n\n        r = REINTERPRET_CAST(uint32_t, t);\n\n        latency = LATENCY_IF;\n\n        D_EXEC(qemu_log(\"IF f=%u a=%f b=%f t=%f, r=%08x\\n\", f, a, b, t, r));\n\n    } break;\n\n    case OP_TSIGN:\n\n    {\n\n        float a = REINTERPRET_CAST(float, s->gp_regs[reg_a]);\n\n        float b = REINTERPRET_CAST(float, s->gp_regs[reg_b]);\n\n        float t = (b < 0) ? -a : a;\n\n        r = REINTERPRET_CAST(uint32_t, t);\n\n        latency = LATENCY_TSIGN;\n\n        D_EXEC(qemu_log(\"TSIGN a=%f b=%f t=%f, r=%08x\\n\", a, b, t, r));\n\n    } break;\n\n    case OP_QUAKE:\n\n    {\n\n        uint32_t a = s->gp_regs[reg_a];\n\n        r = 0x5f3759df - (a >> 1);\n\n        latency = LATENCY_QUAKE;\n\n        D_EXEC(qemu_log(\"QUAKE a=%d r=%08x\\n\", a, r));\n\n    } break;\n\n\n\n    default:\n\n        error_report(\"milkymist_pfpu: unknown opcode %d\\n\", op);\n\n        break;\n\n    }\n\n\n\n    if (!reg_d) {\n\n        D_EXEC(qemu_log(\"%04d %8s R%03d, R%03d <L=%d, E=%04d>\\n\",\n\n                    s->regs[R_PC], opcode_to_str[op], reg_a, reg_b, latency,\n\n                    s->regs[R_PC] + latency));\n\n    } else {\n\n        D_EXEC(qemu_log(\"%04d %8s R%03d, R%03d <L=%d, E=%04d> -> R%03d\\n\",\n\n                    s->regs[R_PC], opcode_to_str[op], reg_a, reg_b, latency,\n\n                    s->regs[R_PC] + latency, reg_d));\n\n    }\n\n\n\n    if (op == OP_VECTOUT) {\n\n        return 0;\n\n    }\n\n\n\n    /* store output for this cycle */\n\n    if (reg_d) {\n\n        uint32_t val = output_queue_remove(s);\n\n        D_EXEC(qemu_log(\"R%03d <- 0x%08x\\n\", reg_d, val));\n\n        s->gp_regs[reg_d] = val;\n\n    }\n\n\n\n    output_queue_advance(s);\n\n\n\n    /* store op output */\n\n    if (op != OP_NOP) {\n\n        output_queue_insert(s, r, latency-1);\n\n    }\n\n\n\n    /* advance PC */\n\n    s->regs[R_PC]++;\n\n\n\n    return 1;\n\n};\n", "idx": 26835}
{"project": "qemu", "commit_id": "c6f10a5876a81f7a016714df06730c48210ee419", "target": 1, "func": "type_init(serial_register_types)\n\n\n\nstatic bool serial_isa_init(ISABus *bus, int index, CharDriverState *chr)\n\n{\n\n    DeviceState *dev;\n\n    ISADevice *isadev;\n\n\n\n    isadev = isa_try_create(bus, TYPE_ISA_SERIAL);\n\n    if (!isadev) {\n\n        return false;\n\n    }\n\n    dev = DEVICE(isadev);\n\n    qdev_prop_set_uint32(dev, \"index\", index);\n\n    qdev_prop_set_chr(dev, \"chardev\", chr);\n\n    if (qdev_init(dev) < 0) {\n\n        return false;\n\n    }\n\n    return true;\n\n}\n", "idx": 26840}
{"project": "qemu", "commit_id": "8be487d8f184f2f721cabeac559fb7a6cba18c95", "target": 1, "func": "static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)\n\n{\n\n    unsigned i;\n\n\n\n    /* Check that there is free space left in a buffer */\n\n    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {\n\n        ERRPRINT(\"Can't write to data buffer: buffer full\\n\");\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < size; i++) {\n\n        s->fifo_buffer[s->data_count] = value & 0xFF;\n\n        s->data_count++;\n\n        value >>= 8;\n\n        if (s->data_count >= (s->blksize & 0x0fff)) {\n\n            DPRINT_L2(\"write buffer filled with %u bytes of data\\n\",\n\n                    s->data_count);\n\n            s->data_count = 0;\n\n            s->prnsts &= ~SDHC_SPACE_AVAILABLE;\n\n            if (s->prnsts & SDHC_DOING_WRITE) {\n\n                sdhci_write_block_to_card(s);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 26841}
{"project": "qemu", "commit_id": "4871b51b9241b10f4fd8e04bbb21577886795e25", "target": 1, "func": "static uint32_t acpi_find_vgia(void)\n\n{\n\n    uint32_t rsdp_offset;\n\n    uint32_t guid_offset = 0;\n\n    AcpiRsdpDescriptor rsdp_table;\n\n    uint32_t rsdt;\n\n    AcpiRsdtDescriptorRev1 rsdt_table;\n\n    int tables_nr;\n\n    uint32_t *tables;\n\n    AcpiTableHeader ssdt_table;\n\n    VgidTable vgid_table;\n\n    int i;\n\n\n\n    /* Tables may take a short time to be set up by the guest */\n\n    for (i = 0; i < RSDP_TRIES_MAX; i++) {\n\n        rsdp_offset = acpi_find_rsdp_address();\n\n        if (rsdp_offset < RSDP_ADDR_INVALID) {\n\n            break;\n\n        }\n\n        g_usleep(RSDP_SLEEP_US);\n\n    }\n\n    g_assert_cmphex(rsdp_offset, <, RSDP_ADDR_INVALID);\n\n\n\n    acpi_parse_rsdp_table(rsdp_offset, &rsdp_table);\n\n\n\n    rsdt = rsdp_table.rsdt_physical_address;\n\n    /* read the header */\n\n    ACPI_READ_TABLE_HEADER(&rsdt_table, rsdt);\n\n    ACPI_ASSERT_CMP(rsdt_table.signature, \"RSDT\");\n\n\n\n    /* compute the table entries in rsdt */\n\n    tables_nr = (rsdt_table.length - sizeof(AcpiRsdtDescriptorRev1)) /\n\n                sizeof(uint32_t);\n\n    g_assert_cmpint(tables_nr, >, 0);\n\n\n\n    /* get the addresses of the tables pointed by rsdt */\n\n    tables = g_new0(uint32_t, tables_nr);\n\n    ACPI_READ_ARRAY_PTR(tables, tables_nr, rsdt);\n\n\n\n    for (i = 0; i < tables_nr; i++) {\n\n        ACPI_READ_TABLE_HEADER(&ssdt_table, tables[i]);\n\n        if (!strncmp((char *)ssdt_table.oem_table_id, \"VMGENID\", 7)) {\n\n            /* the first entry in the table should be VGIA\n\n             * That's all we need\n\n             */\n\n            ACPI_READ_FIELD(vgid_table.name_op, tables[i]);\n\n            g_assert(vgid_table.name_op == 0x08);  /* name */\n\n            ACPI_READ_ARRAY(vgid_table.vgia, tables[i]);\n\n            g_assert(memcmp(vgid_table.vgia, \"VGIA\", 4) == 0);\n\n            ACPI_READ_FIELD(vgid_table.val_op, tables[i]);\n\n            g_assert(vgid_table.val_op == 0x0C);  /* dword */\n\n            ACPI_READ_FIELD(vgid_table.vgia_val, tables[i]);\n\n            /* The GUID is written at a fixed offset into the fw_cfg file\n\n             * in order to implement the \"OVMF SDT Header probe suppressor\"\n\n             * see docs/specs/vmgenid.txt for more details\n\n             */\n\n            guid_offset = vgid_table.vgia_val + VMGENID_GUID_OFFSET;\n\n            break;\n\n        }\n\n    }\n\n    g_free(tables);\n\n    return guid_offset;\n\n}\n", "idx": 26847}
{"project": "qemu", "commit_id": "2d528d45ecf5ee3c1a566a9f3d664464925ef830", "target": 1, "func": "static CharDriverState *qemu_chr_open_pipe(ChardevHostdev *opts)\n\n{\n\n    const char *filename = opts->device;\n\n    CharDriverState *chr;\n\n    WinCharState *s;\n\n\n\n    chr = qemu_chr_alloc();\n\n    s = g_malloc0(sizeof(WinCharState));\n\n    chr->opaque = s;\n\n    chr->chr_write = win_chr_write;\n\n    chr->chr_close = win_chr_close;\n\n\n\n    if (win_chr_pipe_init(chr, filename) < 0) {\n\n        g_free(s);\n\n        g_free(chr);\n\n        return NULL;\n\n    }\n\n    return chr;\n\n}\n", "idx": 26848}
{"project": "qemu", "commit_id": "8194f35a0c71a3bf169459bf715bea53b7bbc904", "target": 1, "func": "int cpu_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    CPUState *env = opaque;\n\n    int i;\n\n    uint32_t tmp;\n\n\n\n    if (version_id != 5)\n\n        return -EINVAL;\n\n    for(i = 0; i < 8; i++)\n\n        qemu_get_betls(f, &env->gregs[i]);\n\n    qemu_get_be32s(f, &env->nwindows);\n\n    for(i = 0; i < env->nwindows * 16; i++)\n\n        qemu_get_betls(f, &env->regbase[i]);\n\n\n\n    /* FPU */\n\n    for(i = 0; i < TARGET_FPREGS; i++) {\n\n        union {\n\n            float32 f;\n\n            uint32_t i;\n\n        } u;\n\n        u.i = qemu_get_be32(f);\n\n        env->fpr[i] = u.f;\n\n    }\n\n\n\n    qemu_get_betls(f, &env->pc);\n\n    qemu_get_betls(f, &env->npc);\n\n    qemu_get_betls(f, &env->y);\n\n    tmp = qemu_get_be32(f);\n\n    env->cwp = 0; /* needed to ensure that the wrapping registers are\n\n                     correctly updated */\n\n    PUT_PSR(env, tmp);\n\n    qemu_get_betls(f, &env->fsr);\n\n    qemu_get_betls(f, &env->tbr);\n\n    tmp = qemu_get_be32(f);\n\n    env->interrupt_index = tmp;\n\n    qemu_get_be32s(f, &env->pil_in);\n\n#ifndef TARGET_SPARC64\n\n    qemu_get_be32s(f, &env->wim);\n\n    /* MMU */\n\n    for (i = 0; i < 32; i++)\n\n        qemu_get_be32s(f, &env->mmuregs[i]);\n\n#else\n\n    qemu_get_be64s(f, &env->lsu);\n\n    for (i = 0; i < 16; i++) {\n\n        qemu_get_be64s(f, &env->immuregs[i]);\n\n        qemu_get_be64s(f, &env->dmmuregs[i]);\n\n    }\n\n    for (i = 0; i < 64; i++) {\n\n        qemu_get_be64s(f, &env->itlb[i].tag);\n\n        qemu_get_be64s(f, &env->itlb[i].tte);\n\n        qemu_get_be64s(f, &env->dtlb[i].tag);\n\n        qemu_get_be64s(f, &env->dtlb[i].tte);\n\n    }\n\n    qemu_get_be32s(f, &env->mmu_version);\n\n    for (i = 0; i < MAXTL_MAX; i++) {\n\n        qemu_get_be64s(f, &env->ts[i].tpc);\n\n        qemu_get_be64s(f, &env->ts[i].tnpc);\n\n        qemu_get_be64s(f, &env->ts[i].tstate);\n\n        qemu_get_be32s(f, &env->ts[i].tt);\n\n    }\n\n    qemu_get_be32s(f, &env->xcc);\n\n    qemu_get_be32s(f, &env->asi);\n\n    qemu_get_be32s(f, &env->pstate);\n\n    qemu_get_be32s(f, &env->tl);\n\n    env->tsptr = &env->ts[env->tl & MAXTL_MASK];\n\n    qemu_get_be32s(f, &env->cansave);\n\n    qemu_get_be32s(f, &env->canrestore);\n\n    qemu_get_be32s(f, &env->otherwin);\n\n    qemu_get_be32s(f, &env->wstate);\n\n    qemu_get_be32s(f, &env->cleanwin);\n\n    for (i = 0; i < 8; i++)\n\n        qemu_get_be64s(f, &env->agregs[i]);\n\n    for (i = 0; i < 8; i++)\n\n        qemu_get_be64s(f, &env->bgregs[i]);\n\n    for (i = 0; i < 8; i++)\n\n        qemu_get_be64s(f, &env->igregs[i]);\n\n    for (i = 0; i < 8; i++)\n\n        qemu_get_be64s(f, &env->mgregs[i]);\n\n    qemu_get_be64s(f, &env->fprs);\n\n    qemu_get_be64s(f, &env->tick_cmpr);\n\n    qemu_get_be64s(f, &env->stick_cmpr);\n\n    qemu_get_ptimer(f, env->tick);\n\n    qemu_get_ptimer(f, env->stick);\n\n    qemu_get_be64s(f, &env->gsr);\n\n    qemu_get_be32s(f, &env->gl);\n\n    qemu_get_be64s(f, &env->hpstate);\n\n    for (i = 0; i < MAXTL_MAX; i++)\n\n        qemu_get_be64s(f, &env->htstate[i]);\n\n    qemu_get_be64s(f, &env->hintp);\n\n    qemu_get_be64s(f, &env->htba);\n\n    qemu_get_be64s(f, &env->hver);\n\n    qemu_get_be64s(f, &env->hstick_cmpr);\n\n    qemu_get_be64s(f, &env->ssr);\n\n    qemu_get_ptimer(f, env->hstick);\n\n#endif\n\n    tlb_flush(env, 1);\n\n    return 0;\n\n}\n", "idx": 26850}
{"project": "qemu", "commit_id": "88365e47dd19da8776252a94ed5fa0b7242ea9e9", "target": 1, "func": "static void mtree_print_mr(fprintf_function mon_printf, void *f,\n\n                           const MemoryRegion *mr, unsigned int level,\n\n                           target_phys_addr_t base,\n\n                           MemoryRegionListHead *alias_print_queue)\n\n{\n\n    MemoryRegionList *new_ml, *ml, *next_ml;\n\n    MemoryRegionListHead submr_print_queue;\n\n    const MemoryRegion *submr;\n\n    unsigned int i;\n\n\n\n    if (!mr) {\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < level; i++) {\n\n        mon_printf(f, \"  \");\n\n    }\n\n\n\n    if (mr->alias) {\n\n        MemoryRegionList *ml;\n\n        bool found = false;\n\n\n\n        /* check if the alias is already in the queue */\n\n        QTAILQ_FOREACH(ml, alias_print_queue, queue) {\n\n            if (ml->mr == mr->alias && !ml->printed) {\n\n                found = true;\n\n            }\n\n        }\n\n\n\n        if (!found) {\n\n            ml = g_new(MemoryRegionList, 1);\n\n            ml->mr = mr->alias;\n\n            ml->printed = false;\n\n            QTAILQ_INSERT_TAIL(alias_print_queue, ml, queue);\n\n        }\n\n        mon_printf(f, TARGET_FMT_plx \"-\" TARGET_FMT_plx \" (prio %d): alias %s @%s \"\n\n                   TARGET_FMT_plx \"-\" TARGET_FMT_plx \"\\n\",\n\n                   base + mr->addr,\n\n                   base + mr->addr\n\n                   + (target_phys_addr_t)int128_get64(mr->size) - 1,\n\n                   mr->priority,\n\n                   mr->name,\n\n                   mr->alias->name,\n\n                   mr->alias_offset,\n\n                   mr->alias_offset\n\n                   + (target_phys_addr_t)int128_get64(mr->size) - 1);\n\n    } else {\n\n        mon_printf(f, TARGET_FMT_plx \"-\" TARGET_FMT_plx \" (prio %d): %s\\n\",\n\n                   base + mr->addr,\n\n                   base + mr->addr\n\n                   + (target_phys_addr_t)int128_get64(mr->size) - 1,\n\n                   mr->priority,\n\n                   mr->name);\n\n    }\n\n\n\n    QTAILQ_INIT(&submr_print_queue);\n\n\n\n    QTAILQ_FOREACH(submr, &mr->subregions, subregions_link) {\n\n        new_ml = g_new(MemoryRegionList, 1);\n\n        new_ml->mr = submr;\n\n        QTAILQ_FOREACH(ml, &submr_print_queue, queue) {\n\n            if (new_ml->mr->addr < ml->mr->addr ||\n\n                (new_ml->mr->addr == ml->mr->addr &&\n\n                 new_ml->mr->priority > ml->mr->priority)) {\n\n                QTAILQ_INSERT_BEFORE(ml, new_ml, queue);\n\n                new_ml = NULL;\n\n                break;\n\n            }\n\n        }\n\n        if (new_ml) {\n\n            QTAILQ_INSERT_TAIL(&submr_print_queue, new_ml, queue);\n\n        }\n\n    }\n\n\n\n    QTAILQ_FOREACH(ml, &submr_print_queue, queue) {\n\n        mtree_print_mr(mon_printf, f, ml->mr, level + 1, base + mr->addr,\n\n                       alias_print_queue);\n\n    }\n\n\n\n    QTAILQ_FOREACH_SAFE(next_ml, &submr_print_queue, queue, ml) {\n\n        g_free(ml);\n\n    }\n\n}\n", "idx": 26854}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "int spapr_vio_check_tces(VIOsPAPRDevice *dev, target_ulong ioba,\n\n                         target_ulong len, enum VIOsPAPR_TCEAccess access)\n\n{\n\n    int start, end, i;\n\n\n\n    start = ioba >> SPAPR_VIO_TCE_PAGE_SHIFT;\n\n    end = (ioba + len - 1) >> SPAPR_VIO_TCE_PAGE_SHIFT;\n\n\n\n    for (i = start; i <= end; i++) {\n\n        if ((dev->rtce_table[i].tce & access) != access) {\n\n#ifdef DEBUG_TCE\n\n            fprintf(stderr, \"FAIL on %d\\n\", i);\n\n#endif\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 26855}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "int vnc_tls_client_setup(VncState *vs,\n\n                         int needX509Creds) {\n\n    VNC_DEBUG(\"Do TLS setup\\n\");\n\n    if (vnc_tls_initialize() < 0) {\n\n        VNC_DEBUG(\"Failed to init TLS\\n\");\n\n        vnc_client_error(vs);\n\n        return -1;\n\n    }\n\n    if (vs->tls.session == NULL) {\n\n        if (gnutls_init(&vs->tls.session, GNUTLS_SERVER) < 0) {\n\n            vnc_client_error(vs);\n\n            return -1;\n\n        }\n\n\n\n        if (gnutls_set_default_priority(vs->tls.session) < 0) {\n\n            gnutls_deinit(vs->tls.session);\n\n            vs->tls.session = NULL;\n\n            vnc_client_error(vs);\n\n            return -1;\n\n        }\n\n\n\n        if (vnc_set_gnutls_priority(vs->tls.session, needX509Creds) < 0) {\n\n            gnutls_deinit(vs->tls.session);\n\n            vs->tls.session = NULL;\n\n            vnc_client_error(vs);\n\n            return -1;\n\n        }\n\n\n\n        if (needX509Creds) {\n\n            gnutls_certificate_server_credentials x509_cred =\n\n                vnc_tls_initialize_x509_cred(vs->vd);\n\n            if (!x509_cred) {\n\n                gnutls_deinit(vs->tls.session);\n\n                vs->tls.session = NULL;\n\n                vnc_client_error(vs);\n\n                return -1;\n\n            }\n\n            if (gnutls_credentials_set(vs->tls.session,\n\n                                       GNUTLS_CRD_CERTIFICATE, x509_cred) < 0) {\n\n                gnutls_deinit(vs->tls.session);\n\n                vs->tls.session = NULL;\n\n                gnutls_certificate_free_credentials(x509_cred);\n\n                vnc_client_error(vs);\n\n                return -1;\n\n            }\n\n            if (vs->vd->tls.x509verify) {\n\n                VNC_DEBUG(\"Requesting a client certificate\\n\");\n\n                gnutls_certificate_server_set_request(vs->tls.session,\n\n                                                      GNUTLS_CERT_REQUEST);\n\n            }\n\n\n\n        } else {\n\n            gnutls_anon_server_credentials_t anon_cred =\n\n                vnc_tls_initialize_anon_cred();\n\n            if (!anon_cred) {\n\n                gnutls_deinit(vs->tls.session);\n\n                vs->tls.session = NULL;\n\n                vnc_client_error(vs);\n\n                return -1;\n\n            }\n\n            if (gnutls_credentials_set(vs->tls.session,\n\n                                       GNUTLS_CRD_ANON, anon_cred) < 0) {\n\n                gnutls_deinit(vs->tls.session);\n\n                vs->tls.session = NULL;\n\n                gnutls_anon_free_server_credentials(anon_cred);\n\n                vnc_client_error(vs);\n\n                return -1;\n\n            }\n\n        }\n\n\n\n        gnutls_transport_set_ptr(vs->tls.session, (gnutls_transport_ptr_t)vs);\n\n        gnutls_transport_set_push_function(vs->tls.session, vnc_tls_push);\n\n        gnutls_transport_set_pull_function(vs->tls.session, vnc_tls_pull);\n\n    }\n\n    return 0;\n\n}\n", "idx": 26856}
{"project": "qemu", "commit_id": "73a652a1b08445e8d91e50cdbb2da50e571c61b3", "target": 1, "func": "void qmp_guest_fstrim(bool has_minimum, int64_t minimum, Error **errp)\n\n{\n\n    int ret = 0;\n\n    FsMountList mounts;\n\n    struct FsMount *mount;\n\n    int fd;\n\n    Error *local_err = NULL;\n\n    struct fstrim_range r = {\n\n        .start = 0,\n\n        .len = -1,\n\n        .minlen = has_minimum ? minimum : 0,\n\n    };\n\n\n\n    slog(\"guest-fstrim called\");\n\n\n\n    QTAILQ_INIT(&mounts);\n\n    build_fs_mount_list(&mounts, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    QTAILQ_FOREACH(mount, &mounts, next) {\n\n        fd = qemu_open(mount->dirname, O_RDONLY);\n\n        if (fd == -1) {\n\n            error_setg_errno(errp, errno, \"failed to open %s\", mount->dirname);\n\n            goto error;\n\n        }\n\n\n\n        /* We try to cull filesytems we know won't work in advance, but other\n\n         * filesytems may not implement fstrim for less obvious reasons.  These\n\n         * will report EOPNOTSUPP; we simply ignore these errors.  Any other\n\n         * error means an unexpected error, so return it in those cases.  In\n\n         * some other cases ENOTTY will be reported (e.g. CD-ROMs).\n\n         */\n\n        ret = ioctl(fd, FITRIM, &r);\n\n        if (ret == -1) {\n\n            if (errno != ENOTTY && errno != EOPNOTSUPP) {\n\n                error_setg_errno(errp, errno, \"failed to trim %s\",\n\n                                 mount->dirname);\n\n                close(fd);\n\n                goto error;\n\n            }\n\n        }\n\n        close(fd);\n\n    }\n\n\n\nerror:\n\n    free_fs_mount_list(&mounts);\n\n}\n", "idx": 26857}
{"project": "qemu", "commit_id": "cfc87e00c22ab4ea0262c9771c803ed03d754001", "target": 1, "func": "vpc_co_pwritev(BlockDriverState *bs, uint64_t offset, uint64_t bytes,\n\n               QEMUIOVector *qiov, int flags)\n\n{\n\n    BDRVVPCState *s = bs->opaque;\n\n    int64_t image_offset;\n\n    int64_t n_bytes;\n\n    int64_t bytes_done = 0;\n\n    int ret;\n\n    VHDFooter *footer =  (VHDFooter *) s->footer_buf;\n\n    QEMUIOVector local_qiov;\n\n\n\n    if (be32_to_cpu(footer->type) == VHD_FIXED) {\n\n        return bdrv_co_pwritev(bs->file, offset, bytes, qiov, 0);\n\n    }\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    qemu_iovec_init(&local_qiov, qiov->niov);\n\n\n\n    while (bytes > 0) {\n\n        image_offset = get_image_offset(bs, offset, true);\n\n        n_bytes = MIN(bytes, s->block_size - (offset % s->block_size));\n\n\n\n        if (image_offset == -1) {\n\n            image_offset = alloc_block(bs, offset);\n\n            if (image_offset < 0) {\n\n                ret = image_offset;\n\n                goto fail;\n\n            }\n\n        }\n\n\n\n        qemu_iovec_reset(&local_qiov);\n\n        qemu_iovec_concat(&local_qiov, qiov, bytes_done, n_bytes);\n\n\n\n        ret = bdrv_co_pwritev(bs->file, image_offset, n_bytes,\n\n                              &local_qiov, 0);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        bytes -= n_bytes;\n\n        offset += n_bytes;\n\n        bytes_done += n_bytes;\n\n    }\n\n\n\n    ret = 0;\n\nfail:\n\n    qemu_iovec_destroy(&local_qiov);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    return ret;\n\n}\n", "idx": 26859}
{"project": "qemu", "commit_id": "c6742b14fe7352059cd4954a356a8105757af31b", "target": 1, "func": "bool memory_region_present(MemoryRegion *container, hwaddr addr)\n\n{\n\n    MemoryRegion *mr = memory_region_find(container, addr, 1).mr;\n\n    if (!mr || (mr == container)) {\n\n        return false;\n\n    }\n\n    memory_region_unref(mr);\n\n    return true;\n\n}\n", "idx": 26860}
{"project": "qemu", "commit_id": "5c53bb812152c3d7919cadfd47c210b181bf89ac", "target": 1, "func": "static void tcg_out_qemu_ld_slow_path(TCGContext *s, TCGLabelQemuLdst *l)\n\n{\n\n    TCGMemOp opc = l->opc;\n\n    TCGReg data_reg;\n\n    uint8_t **label_ptr = &l->label_ptr[0];\n\n\n\n    /* resolve label address */\n\n    *(uint32_t *)label_ptr[0] = (uint32_t)(s->code_ptr - label_ptr[0] - 4);\n\n    if (TARGET_LONG_BITS > TCG_TARGET_REG_BITS) {\n\n        *(uint32_t *)label_ptr[1] = (uint32_t)(s->code_ptr - label_ptr[1] - 4);\n\n    }\n\n\n\n    if (TCG_TARGET_REG_BITS == 32) {\n\n        int ofs = 0;\n\n\n\n        tcg_out_st(s, TCG_TYPE_PTR, TCG_AREG0, TCG_REG_ESP, ofs);\n\n        ofs += 4;\n\n\n\n        tcg_out_st(s, TCG_TYPE_I32, l->addrlo_reg, TCG_REG_ESP, ofs);\n\n        ofs += 4;\n\n\n\n        if (TARGET_LONG_BITS == 64) {\n\n            tcg_out_st(s, TCG_TYPE_I32, l->addrhi_reg, TCG_REG_ESP, ofs);\n\n            ofs += 4;\n\n        }\n\n\n\n        tcg_out_sti(s, TCG_TYPE_I32, TCG_REG_ESP, ofs, l->mem_index);\n\n        ofs += 4;\n\n\n\n        tcg_out_sti(s, TCG_TYPE_I32, TCG_REG_ESP, ofs, (uintptr_t)l->raddr);\n\n    } else {\n\n        tcg_out_mov(s, TCG_TYPE_PTR, tcg_target_call_iarg_regs[0], TCG_AREG0);\n\n        /* The second argument is already loaded with addrlo.  */\n\n        tcg_out_movi(s, TCG_TYPE_I32, tcg_target_call_iarg_regs[2],\n\n                     l->mem_index);\n\n        tcg_out_movi(s, TCG_TYPE_PTR, tcg_target_call_iarg_regs[3],\n\n                     (uintptr_t)l->raddr);\n\n    }\n\n\n\n    tcg_out_calli(s, (uintptr_t)qemu_ld_helpers[opc & ~MO_SIGN]);\n\n\n\n    data_reg = l->datalo_reg;\n\n    switch (opc & MO_SSIZE) {\n\n    case MO_SB:\n\n        tcg_out_ext8s(s, data_reg, TCG_REG_EAX, P_REXW);\n\n        break;\n\n    case MO_SW:\n\n        tcg_out_ext16s(s, data_reg, TCG_REG_EAX, P_REXW);\n\n        break;\n\n#if TCG_TARGET_REG_BITS == 64\n\n    case MO_SL:\n\n        tcg_out_ext32s(s, data_reg, TCG_REG_EAX);\n\n        break;\n\n#endif\n\n    case MO_UB:\n\n    case MO_UW:\n\n        /* Note that the helpers have zero-extended to tcg_target_long.  */\n\n    case MO_UL:\n\n        tcg_out_mov(s, TCG_TYPE_I32, data_reg, TCG_REG_EAX);\n\n        break;\n\n    case MO_Q:\n\n        if (TCG_TARGET_REG_BITS == 64) {\n\n            tcg_out_mov(s, TCG_TYPE_I64, data_reg, TCG_REG_RAX);\n\n        } else if (data_reg == TCG_REG_EDX) {\n\n            /* xchg %edx, %eax */\n\n            tcg_out_opc(s, OPC_XCHG_ax_r32 + TCG_REG_EDX, 0, 0, 0);\n\n            tcg_out_mov(s, TCG_TYPE_I32, l->datahi_reg, TCG_REG_EAX);\n\n        } else {\n\n            tcg_out_mov(s, TCG_TYPE_I32, data_reg, TCG_REG_EAX);\n\n            tcg_out_mov(s, TCG_TYPE_I32, l->datahi_reg, TCG_REG_EDX);\n\n        }\n\n        break;\n\n    default:\n\n        tcg_abort();\n\n    }\n\n\n\n    /* Jump to the code corresponding to next IR of qemu_st */\n\n    tcg_out_jmp(s, (uintptr_t)l->raddr);\n\n}\n", "idx": 26861}
{"project": "qemu", "commit_id": "978fae9f1ac47e22890a1bd9ebf5fa46fe8b6ef7", "target": 1, "func": "static long do_sigreturn_v1(CPUARMState *env)\n\n{\n\n        abi_ulong frame_addr;\n\n\tstruct sigframe_v1 *frame;\n\n\ttarget_sigset_t set;\n\n        sigset_t host_set;\n\n        int i;\n\n\n\n\t/*\n\n\t * Since we stacked the signal on a 64-bit boundary,\n\n\t * then 'sp' should be word aligned here.  If it's\n\n\t * not, then the user is trying to mess with us.\n\n\t */\n\n\tif (env->regs[13] & 7)\n\n\t\tgoto badframe;\n\n\n\n        frame_addr = env->regs[13];\n\n\tif (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))\n\n                goto badframe;\n\n\n\n\tif (__get_user(set.sig[0], &frame->sc.oldmask))\n\n            goto badframe;\n\n        for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n            if (__get_user(set.sig[i], &frame->extramask[i - 1]))\n\n                goto badframe;\n\n        }\n\n\n\n        target_to_host_sigset_internal(&host_set, &set);\n\n        sigprocmask(SIG_SETMASK, &host_set, NULL);\n\n\n\n\tif (restore_sigcontext(env, &frame->sc))\n\n\t\tgoto badframe;\n\n\n\n#if 0\n\n\t/* Send SIGTRAP if we're single-stepping */\n\n\tif (ptrace_cancel_bpt(current))\n\n\t\tsend_sig(SIGTRAP, current, 1);\n\n#endif\n\n\tunlock_user_struct(frame, frame_addr, 0);\n\n        return env->regs[0];\n\n\n\nbadframe:\n\n\tunlock_user_struct(frame, frame_addr, 0);\n\n        force_sig(TARGET_SIGSEGV /* , current */);\n\n\treturn 0;\n\n}\n", "idx": 26863}
{"project": "qemu", "commit_id": "a8fb542705ac7e0dcf00908bc47bf49cdd058abe", "target": 1, "func": "static void tcp_chr_connect(void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    TCPCharDriver *s = chr->opaque;\n\n    QIOChannelSocket *sioc = QIO_CHANNEL_SOCKET(s->ioc);\n\n\n\n    g_free(chr->filename);\n\n    chr->filename = sockaddr_to_str(&sioc->localAddr, sioc->localAddrLen,\n\n                                    &sioc->remoteAddr, sioc->remoteAddrLen,\n\n                                    s->is_listen, s->is_telnet);\n\n\n\n    s->connected = 1;\n\n    if (s->ioc) {\n\n        chr->fd_in_tag = io_add_watch_poll(s->ioc,\n\n                                           tcp_chr_read_poll,\n\n                                           tcp_chr_read, chr);\n\n    }\n\n    qemu_chr_be_generic_open(chr);\n\n}\n", "idx": 26864}
{"project": "qemu", "commit_id": "51127181cfac0315720e6ca502eb133a353f6b11", "target": 1, "func": "static void gen_muldiv (DisasContext *ctx, uint32_t opc,\n\n                        int rs, int rt)\n\n{\n\n    const char *opn = \"mul/div\";\n\n    TCGv t0, t1;\n\n    unsigned int acc;\n\n\n\n    switch (opc) {\n\n    case OPC_DIV:\n\n    case OPC_DIVU:\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_DDIV:\n\n    case OPC_DDIVU:\n\n#endif\n\n        t0 = tcg_temp_local_new();\n\n        t1 = tcg_temp_local_new();\n\n        break;\n\n    default:\n\n        t0 = tcg_temp_new();\n\n        t1 = tcg_temp_new();\n\n        break;\n\n    }\n\n\n\n    gen_load_gpr(t0, rs);\n\n    gen_load_gpr(t1, rt);\n\n    switch (opc) {\n\n    case OPC_DIV:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n\n\n            tcg_gen_ext32s_tl(t0, t0);\n\n            tcg_gen_ext32s_tl(t1, t1);\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, INT_MIN, l2);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1, l2);\n\n\n\n            tcg_gen_mov_tl(cpu_LO[0], t0);\n\n            tcg_gen_movi_tl(cpu_HI[0], 0);\n\n            tcg_gen_br(l1);\n\n            gen_set_label(l2);\n\n            tcg_gen_div_tl(cpu_LO[0], t0, t1);\n\n            tcg_gen_rem_tl(cpu_HI[0], t0, t1);\n\n            tcg_gen_ext32s_tl(cpu_LO[0], cpu_LO[0]);\n\n            tcg_gen_ext32s_tl(cpu_HI[0], cpu_HI[0]);\n\n            gen_set_label(l1);\n\n        }\n\n        opn = \"div\";\n\n        break;\n\n    case OPC_DIVU:\n\n        {\n\n            int l1 = gen_new_label();\n\n\n\n            tcg_gen_ext32u_tl(t0, t0);\n\n            tcg_gen_ext32u_tl(t1, t1);\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1);\n\n            tcg_gen_divu_tl(cpu_LO[0], t0, t1);\n\n            tcg_gen_remu_tl(cpu_HI[0], t0, t1);\n\n            tcg_gen_ext32s_tl(cpu_LO[0], cpu_LO[0]);\n\n            tcg_gen_ext32s_tl(cpu_HI[0], cpu_HI[0]);\n\n            gen_set_label(l1);\n\n        }\n\n        opn = \"divu\";\n\n        break;\n\n    case OPC_MULT:\n\n        {\n\n            TCGv_i64 t2 = tcg_temp_new_i64();\n\n            TCGv_i64 t3 = tcg_temp_new_i64();\n\n            acc = ((ctx->opcode) >> 11) & 0x03;\n\n            if (acc != 0) {\n\n                check_dsp(ctx);\n\n            }\n\n\n\n            tcg_gen_ext_tl_i64(t2, t0);\n\n            tcg_gen_ext_tl_i64(t3, t1);\n\n            tcg_gen_mul_i64(t2, t2, t3);\n\n            tcg_temp_free_i64(t3);\n\n            tcg_gen_trunc_i64_tl(t0, t2);\n\n            tcg_gen_shri_i64(t2, t2, 32);\n\n            tcg_gen_trunc_i64_tl(t1, t2);\n\n            tcg_temp_free_i64(t2);\n\n            tcg_gen_ext32s_tl(cpu_LO[acc], t0);\n\n            tcg_gen_ext32s_tl(cpu_HI[acc], t1);\n\n        }\n\n        opn = \"mult\";\n\n        break;\n\n    case OPC_MULTU:\n\n        {\n\n            TCGv_i64 t2 = tcg_temp_new_i64();\n\n            TCGv_i64 t3 = tcg_temp_new_i64();\n\n            acc = ((ctx->opcode) >> 11) & 0x03;\n\n            if (acc != 0) {\n\n                check_dsp(ctx);\n\n            }\n\n\n\n            tcg_gen_ext32u_tl(t0, t0);\n\n            tcg_gen_ext32u_tl(t1, t1);\n\n            tcg_gen_extu_tl_i64(t2, t0);\n\n            tcg_gen_extu_tl_i64(t3, t1);\n\n            tcg_gen_mul_i64(t2, t2, t3);\n\n            tcg_temp_free_i64(t3);\n\n            tcg_gen_trunc_i64_tl(t0, t2);\n\n            tcg_gen_shri_i64(t2, t2, 32);\n\n            tcg_gen_trunc_i64_tl(t1, t2);\n\n            tcg_temp_free_i64(t2);\n\n            tcg_gen_ext32s_tl(cpu_LO[acc], t0);\n\n            tcg_gen_ext32s_tl(cpu_HI[acc], t1);\n\n        }\n\n        opn = \"multu\";\n\n        break;\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_DDIV:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, -1LL << 63, l2);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2);\n\n            tcg_gen_mov_tl(cpu_LO[0], t0);\n\n            tcg_gen_movi_tl(cpu_HI[0], 0);\n\n            tcg_gen_br(l1);\n\n            gen_set_label(l2);\n\n            tcg_gen_div_i64(cpu_LO[0], t0, t1);\n\n            tcg_gen_rem_i64(cpu_HI[0], t0, t1);\n\n            gen_set_label(l1);\n\n        }\n\n        opn = \"ddiv\";\n\n        break;\n\n    case OPC_DDIVU:\n\n        {\n\n            int l1 = gen_new_label();\n\n\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1);\n\n            tcg_gen_divu_i64(cpu_LO[0], t0, t1);\n\n            tcg_gen_remu_i64(cpu_HI[0], t0, t1);\n\n            gen_set_label(l1);\n\n        }\n\n        opn = \"ddivu\";\n\n        break;\n\n    case OPC_DMULT:\n\n        gen_helper_dmult(cpu_env, t0, t1);\n\n        opn = \"dmult\";\n\n        break;\n\n    case OPC_DMULTU:\n\n        gen_helper_dmultu(cpu_env, t0, t1);\n\n        opn = \"dmultu\";\n\n        break;\n\n#endif\n\n    case OPC_MADD:\n\n        {\n\n            TCGv_i64 t2 = tcg_temp_new_i64();\n\n            TCGv_i64 t3 = tcg_temp_new_i64();\n\n            acc = ((ctx->opcode) >> 11) & 0x03;\n\n            if (acc != 0) {\n\n                check_dsp(ctx);\n\n            }\n\n\n\n            tcg_gen_ext_tl_i64(t2, t0);\n\n            tcg_gen_ext_tl_i64(t3, t1);\n\n            tcg_gen_mul_i64(t2, t2, t3);\n\n            tcg_gen_concat_tl_i64(t3, cpu_LO[acc], cpu_HI[acc]);\n\n            tcg_gen_add_i64(t2, t2, t3);\n\n            tcg_temp_free_i64(t3);\n\n            tcg_gen_trunc_i64_tl(t0, t2);\n\n            tcg_gen_shri_i64(t2, t2, 32);\n\n            tcg_gen_trunc_i64_tl(t1, t2);\n\n            tcg_temp_free_i64(t2);\n\n            tcg_gen_ext32s_tl(cpu_LO[acc], t0);\n\n            tcg_gen_ext32s_tl(cpu_HI[acc], t1);\n\n        }\n\n        opn = \"madd\";\n\n        break;\n\n    case OPC_MADDU:\n\n        {\n\n            TCGv_i64 t2 = tcg_temp_new_i64();\n\n            TCGv_i64 t3 = tcg_temp_new_i64();\n\n            acc = ((ctx->opcode) >> 11) & 0x03;\n\n            if (acc != 0) {\n\n                check_dsp(ctx);\n\n            }\n\n\n\n            tcg_gen_ext32u_tl(t0, t0);\n\n            tcg_gen_ext32u_tl(t1, t1);\n\n            tcg_gen_extu_tl_i64(t2, t0);\n\n            tcg_gen_extu_tl_i64(t3, t1);\n\n            tcg_gen_mul_i64(t2, t2, t3);\n\n            tcg_gen_concat_tl_i64(t3, cpu_LO[acc], cpu_HI[acc]);\n\n            tcg_gen_add_i64(t2, t2, t3);\n\n            tcg_temp_free_i64(t3);\n\n            tcg_gen_trunc_i64_tl(t0, t2);\n\n            tcg_gen_shri_i64(t2, t2, 32);\n\n            tcg_gen_trunc_i64_tl(t1, t2);\n\n            tcg_temp_free_i64(t2);\n\n            tcg_gen_ext32s_tl(cpu_LO[acc], t0);\n\n            tcg_gen_ext32s_tl(cpu_HI[acc], t1);\n\n        }\n\n        opn = \"maddu\";\n\n        break;\n\n    case OPC_MSUB:\n\n        {\n\n            TCGv_i64 t2 = tcg_temp_new_i64();\n\n            TCGv_i64 t3 = tcg_temp_new_i64();\n\n            acc = ((ctx->opcode) >> 11) & 0x03;\n\n            if (acc != 0) {\n\n                check_dsp(ctx);\n\n            }\n\n\n\n            tcg_gen_ext_tl_i64(t2, t0);\n\n            tcg_gen_ext_tl_i64(t3, t1);\n\n            tcg_gen_mul_i64(t2, t2, t3);\n\n            tcg_gen_concat_tl_i64(t3, cpu_LO[acc], cpu_HI[acc]);\n\n            tcg_gen_sub_i64(t2, t3, t2);\n\n            tcg_temp_free_i64(t3);\n\n            tcg_gen_trunc_i64_tl(t0, t2);\n\n            tcg_gen_shri_i64(t2, t2, 32);\n\n            tcg_gen_trunc_i64_tl(t1, t2);\n\n            tcg_temp_free_i64(t2);\n\n            tcg_gen_ext32s_tl(cpu_LO[acc], t0);\n\n            tcg_gen_ext32s_tl(cpu_HI[acc], t1);\n\n        }\n\n        opn = \"msub\";\n\n        break;\n\n    case OPC_MSUBU:\n\n        {\n\n            TCGv_i64 t2 = tcg_temp_new_i64();\n\n            TCGv_i64 t3 = tcg_temp_new_i64();\n\n            acc = ((ctx->opcode) >> 11) & 0x03;\n\n            if (acc != 0) {\n\n                check_dsp(ctx);\n\n            }\n\n\n\n            tcg_gen_ext32u_tl(t0, t0);\n\n            tcg_gen_ext32u_tl(t1, t1);\n\n            tcg_gen_extu_tl_i64(t2, t0);\n\n            tcg_gen_extu_tl_i64(t3, t1);\n\n            tcg_gen_mul_i64(t2, t2, t3);\n\n            tcg_gen_concat_tl_i64(t3, cpu_LO[acc], cpu_HI[acc]);\n\n            tcg_gen_sub_i64(t2, t3, t2);\n\n            tcg_temp_free_i64(t3);\n\n            tcg_gen_trunc_i64_tl(t0, t2);\n\n            tcg_gen_shri_i64(t2, t2, 32);\n\n            tcg_gen_trunc_i64_tl(t1, t2);\n\n            tcg_temp_free_i64(t2);\n\n            tcg_gen_ext32s_tl(cpu_LO[acc], t0);\n\n            tcg_gen_ext32s_tl(cpu_HI[acc], t1);\n\n        }\n\n        opn = \"msubu\";\n\n        break;\n\n    default:\n\n        MIPS_INVAL(opn);\n\n        generate_exception(ctx, EXCP_RI);\n\n        goto out;\n\n    }\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s %s %s\", opn, regnames[rs], regnames[rt]);\n\n out:\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n}\n", "idx": 26865}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static void usb_msd_copy_data(MSDState *s)\n\n{\n\n    uint32_t len;\n\n    len = s->usb_len;\n\n    if (len > s->scsi_len)\n\n        len = s->scsi_len;\n\n    if (s->mode == USB_MSDM_DATAIN) {\n\n        memcpy(s->usb_buf, s->scsi_buf, len);\n\n    } else {\n\n        memcpy(s->scsi_buf, s->usb_buf, len);\n\n    }\n\n    s->usb_len -= len;\n\n    s->scsi_len -= len;\n\n    s->usb_buf += len;\n\n    s->scsi_buf += len;\n\n    s->data_len -= len;\n\n    if (s->scsi_len == 0 || s->data_len == 0) {\n\n        if (s->mode == USB_MSDM_DATAIN) {\n\n            s->scsi_dev->info->read_data(s->scsi_dev, s->tag);\n\n        } else if (s->mode == USB_MSDM_DATAOUT) {\n\n            s->scsi_dev->info->write_data(s->scsi_dev, s->tag);\n\n        }\n\n    }\n\n}\n", "idx": 26866}
{"project": "qemu", "commit_id": "3f2ca480eb872b4946baf77f756236b637a5b15a", "target": 0, "func": "uint32_t kvmppc_get_dfp(void)\n\n{\n\n    return kvmppc_read_int_cpu_dt(\"ibm,dfp\");\n\n}\n", "idx": 26871}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static int send_full_color_rect(VncState *vs, int w, int h)\n\n{\n\n    int stream = 0;\n\n    size_t bytes;\n\n\n\n    vnc_write_u8(vs, stream << 4); /* no flushing, no filter */\n\n\n\n    if (vs->tight_pixel24) {\n\n        tight_pack24(vs, vs->tight.buffer, w * h, &vs->tight.offset);\n\n        bytes = 3;\n\n    } else {\n\n        bytes = vs->clientds.pf.bytes_per_pixel;\n\n    }\n\n\n\n    bytes = tight_compress_data(vs, stream, w * h * bytes,\n\n                                tight_conf[vs->tight_compression].raw_zlib_level,\n\n                                Z_DEFAULT_STRATEGY);\n\n\n\n    return (bytes >= 0);\n\n}\n", "idx": 26872}
{"project": "qemu", "commit_id": "977ec47de06bdcb24f01c93bc125b7c6c221a1c5", "target": 0, "func": "static void *thread_func(void *p)\n\n{\n\n    struct thread_info *info = p;\n\n\n\n    rcu_register_thread();\n\n\n\n    atomic_inc(&n_ready_threads);\n\n    while (!atomic_mb_read(&test_start)) {\n\n        cpu_relax();\n\n    }\n\n\n\n    rcu_read_lock();\n\n    while (!atomic_read(&test_stop)) {\n\n        info->r = xorshift64star(info->r);\n\n        info->func(info);\n\n    }\n\n    rcu_read_unlock();\n\n\n\n    rcu_unregister_thread();\n\n    return NULL;\n\n}\n", "idx": 26873}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_in_string(TestInputVisitorData *data,\n\n                                   const void *unused)\n\n{\n\n    char *res = NULL, *value = (char *) \"Q E M U\";\n\n    Visitor *v;\n\n\n\n    v = visitor_input_test_init(data, \"%s\", value);\n\n\n\n    visit_type_str(v, NULL, &res, &error_abort);\n\n    g_assert_cmpstr(res, ==, value);\n\n\n\n    g_free(res);\n\n}\n", "idx": 26874}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static inline void bt_hci_lmp_acl_data(struct bt_hci_s *hci, uint16_t handle,\n\n                const uint8_t *data, int start, int len)\n\n{\n\n    struct hci_acl_hdr *pkt = (void *) hci->acl_buf;\n\n\n\n    /* TODO: packet flags */\n\n    /* TODO: avoid memcpy'ing */\n\n\n\n    if (len + HCI_ACL_HDR_SIZE > sizeof(hci->acl_buf)) {\n\n        fprintf(stderr, \"%s: can't take ACL packets %i bytes long\\n\",\n\n                        __FUNCTION__, len);\n\n        return;\n\n    }\n\n    memcpy(hci->acl_buf + HCI_ACL_HDR_SIZE, data, len);\n\n\n\n    pkt->handle = cpu_to_le16(\n\n                    acl_handle_pack(handle, start ? ACL_START : ACL_CONT));\n\n    pkt->dlen = cpu_to_le16(len);\n\n    hci->info.acl_recv(hci->info.opaque,\n\n                    hci->acl_buf, len + HCI_ACL_HDR_SIZE);\n\n}\n", "idx": 26875}
{"project": "qemu", "commit_id": "28143b409f698210d85165ca518235ac7e7c5ac5", "target": 0, "func": "static int kvm_init(MachineState *ms)\n\n{\n\n    MachineClass *mc = MACHINE_GET_CLASS(ms);\n\n    static const char upgrade_note[] =\n\n        \"Please upgrade to at least kernel 2.6.29 or recent kvm-kmod\\n\"\n\n        \"(see http://sourceforge.net/projects/kvm).\\n\";\n\n    struct {\n\n        const char *name;\n\n        int num;\n\n    } num_cpus[] = {\n\n        { \"SMP\",          smp_cpus },\n\n        { \"hotpluggable\", max_cpus },\n\n        { NULL, }\n\n    }, *nc = num_cpus;\n\n    int soft_vcpus_limit, hard_vcpus_limit;\n\n    KVMState *s;\n\n    const KVMCapabilityInfo *missing_cap;\n\n    int ret;\n\n    int type = 0;\n\n    const char *kvm_type;\n\n\n\n    s = KVM_STATE(ms->accelerator);\n\n\n\n    /*\n\n     * On systems where the kernel can support different base page\n\n     * sizes, host page size may be different from TARGET_PAGE_SIZE,\n\n     * even with KVM.  TARGET_PAGE_SIZE is assumed to be the minimum\n\n     * page size for the system though.\n\n     */\n\n    assert(TARGET_PAGE_SIZE <= getpagesize());\n\n    page_size_init();\n\n\n\n    s->sigmask_len = 8;\n\n\n\n#ifdef KVM_CAP_SET_GUEST_DEBUG\n\n    QTAILQ_INIT(&s->kvm_sw_breakpoints);\n\n#endif\n\n    s->vmfd = -1;\n\n    s->fd = qemu_open(\"/dev/kvm\", O_RDWR);\n\n    if (s->fd == -1) {\n\n        fprintf(stderr, \"Could not access KVM kernel module: %m\\n\");\n\n        ret = -errno;\n\n        goto err;\n\n    }\n\n\n\n    ret = kvm_ioctl(s, KVM_GET_API_VERSION, 0);\n\n    if (ret < KVM_API_VERSION) {\n\n        if (ret >= 0) {\n\n            ret = -EINVAL;\n\n        }\n\n        fprintf(stderr, \"kvm version too old\\n\");\n\n        goto err;\n\n    }\n\n\n\n    if (ret > KVM_API_VERSION) {\n\n        ret = -EINVAL;\n\n        fprintf(stderr, \"kvm version not supported\\n\");\n\n        goto err;\n\n    }\n\n\n\n    s->nr_slots = kvm_check_extension(s, KVM_CAP_NR_MEMSLOTS);\n\n\n\n    /* If unspecified, use the default value */\n\n    if (!s->nr_slots) {\n\n        s->nr_slots = 32;\n\n    }\n\n\n\n    /* check the vcpu limits */\n\n    soft_vcpus_limit = kvm_recommended_vcpus(s);\n\n    hard_vcpus_limit = kvm_max_vcpus(s);\n\n\n\n    while (nc->name) {\n\n        if (nc->num > soft_vcpus_limit) {\n\n            fprintf(stderr,\n\n                    \"Warning: Number of %s cpus requested (%d) exceeds \"\n\n                    \"the recommended cpus supported by KVM (%d)\\n\",\n\n                    nc->name, nc->num, soft_vcpus_limit);\n\n\n\n            if (nc->num > hard_vcpus_limit) {\n\n                fprintf(stderr, \"Number of %s cpus requested (%d) exceeds \"\n\n                        \"the maximum cpus supported by KVM (%d)\\n\",\n\n                        nc->name, nc->num, hard_vcpus_limit);\n\n                exit(1);\n\n            }\n\n        }\n\n        nc++;\n\n    }\n\n\n\n    kvm_type = qemu_opt_get(qemu_get_machine_opts(), \"kvm-type\");\n\n    if (mc->kvm_type) {\n\n        type = mc->kvm_type(kvm_type);\n\n    } else if (kvm_type) {\n\n        ret = -EINVAL;\n\n        fprintf(stderr, \"Invalid argument kvm-type=%s\\n\", kvm_type);\n\n        goto err;\n\n    }\n\n\n\n    do {\n\n        ret = kvm_ioctl(s, KVM_CREATE_VM, type);\n\n    } while (ret == -EINTR);\n\n\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ioctl(KVM_CREATE_VM) failed: %d %s\\n\", -ret,\n\n                strerror(-ret));\n\n\n\n#ifdef TARGET_S390X\n\n        if (ret == -EINVAL) {\n\n            fprintf(stderr,\n\n                    \"Host kernel setup problem detected. Please verify:\\n\");\n\n            fprintf(stderr, \"- for kernels supporting the switch_amode or\"\n\n                    \" user_mode parameters, whether\\n\");\n\n            fprintf(stderr,\n\n                    \"  user space is running in primary address space\\n\");\n\n            fprintf(stderr,\n\n                    \"- for kernels supporting the vm.allocate_pgste sysctl, \"\n\n                    \"whether it is enabled\\n\");\n\n        }\n\n#endif\n\n        goto err;\n\n    }\n\n\n\n    s->vmfd = ret;\n\n    missing_cap = kvm_check_extension_list(s, kvm_required_capabilites);\n\n    if (!missing_cap) {\n\n        missing_cap =\n\n            kvm_check_extension_list(s, kvm_arch_required_capabilities);\n\n    }\n\n    if (missing_cap) {\n\n        ret = -EINVAL;\n\n        fprintf(stderr, \"kvm does not support %s\\n%s\",\n\n                missing_cap->name, upgrade_note);\n\n        goto err;\n\n    }\n\n\n\n    s->coalesced_mmio = kvm_check_extension(s, KVM_CAP_COALESCED_MMIO);\n\n\n\n    s->broken_set_mem_region = 1;\n\n    ret = kvm_check_extension(s, KVM_CAP_JOIN_MEMORY_REGIONS_WORKS);\n\n    if (ret > 0) {\n\n        s->broken_set_mem_region = 0;\n\n    }\n\n\n\n#ifdef KVM_CAP_VCPU_EVENTS\n\n    s->vcpu_events = kvm_check_extension(s, KVM_CAP_VCPU_EVENTS);\n\n#endif\n\n\n\n    s->robust_singlestep =\n\n        kvm_check_extension(s, KVM_CAP_X86_ROBUST_SINGLESTEP);\n\n\n\n#ifdef KVM_CAP_DEBUGREGS\n\n    s->debugregs = kvm_check_extension(s, KVM_CAP_DEBUGREGS);\n\n#endif\n\n\n\n#ifdef KVM_CAP_XSAVE\n\n    s->xsave = kvm_check_extension(s, KVM_CAP_XSAVE);\n\n#endif\n\n\n\n#ifdef KVM_CAP_XCRS\n\n    s->xcrs = kvm_check_extension(s, KVM_CAP_XCRS);\n\n#endif\n\n\n\n#ifdef KVM_CAP_PIT_STATE2\n\n    s->pit_state2 = kvm_check_extension(s, KVM_CAP_PIT_STATE2);\n\n#endif\n\n\n\n#ifdef KVM_CAP_IRQ_ROUTING\n\n    kvm_direct_msi_allowed = (kvm_check_extension(s, KVM_CAP_SIGNAL_MSI) > 0);\n\n#endif\n\n\n\n    s->intx_set_mask = kvm_check_extension(s, KVM_CAP_PCI_2_3);\n\n\n\n    s->irq_set_ioctl = KVM_IRQ_LINE;\n\n    if (kvm_check_extension(s, KVM_CAP_IRQ_INJECT_STATUS)) {\n\n        s->irq_set_ioctl = KVM_IRQ_LINE_STATUS;\n\n    }\n\n\n\n#ifdef KVM_CAP_READONLY_MEM\n\n    kvm_readonly_mem_allowed =\n\n        (kvm_check_extension(s, KVM_CAP_READONLY_MEM) > 0);\n\n#endif\n\n\n\n    kvm_eventfds_allowed =\n\n        (kvm_check_extension(s, KVM_CAP_IOEVENTFD) > 0);\n\n\n\n    kvm_irqfds_allowed =\n\n        (kvm_check_extension(s, KVM_CAP_IRQFD) > 0);\n\n\n\n    kvm_resamplefds_allowed =\n\n        (kvm_check_extension(s, KVM_CAP_IRQFD_RESAMPLE) > 0);\n\n\n\n    kvm_vm_attributes_allowed =\n\n        (kvm_check_extension(s, KVM_CAP_VM_ATTRIBUTES) > 0);\n\n\n\n    ret = kvm_arch_init(ms, s);\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    if (machine_kernel_irqchip_allowed(ms)) {\n\n        kvm_irqchip_create(ms, s);\n\n    }\n\n\n\n    kvm_state = s;\n\n\n\n    s->memory_listener.listener.eventfd_add = kvm_mem_ioeventfd_add;\n\n    s->memory_listener.listener.eventfd_del = kvm_mem_ioeventfd_del;\n\n    s->memory_listener.listener.coalesced_mmio_add = kvm_coalesce_mmio_region;\n\n    s->memory_listener.listener.coalesced_mmio_del = kvm_uncoalesce_mmio_region;\n\n\n\n    kvm_memory_listener_register(s, &s->memory_listener,\n\n                                 &address_space_memory, 0);\n\n    memory_listener_register(&kvm_io_listener,\n\n                             &address_space_io);\n\n\n\n    s->many_ioeventfds = kvm_check_many_ioeventfds();\n\n\n\n    cpu_interrupt_handler = kvm_handle_interrupt;\n\n\n\n    return 0;\n\n\n\nerr:\n\n    assert(ret < 0);\n\n    if (s->vmfd >= 0) {\n\n        close(s->vmfd);\n\n    }\n\n    if (s->fd != -1) {\n\n        close(s->fd);\n\n    }\n\n    g_free(s->memory_listener.slots);\n\n\n\n    return ret;\n\n}\n", "idx": 26876}
{"project": "qemu", "commit_id": "1b37b3442f78a77844fdaf7f53e5f04e4ce8f1d6", "target": 0, "func": "static void qemu_gluster_gconf_free(GlusterConf *gconf)\n\n{\n\n    g_free(gconf->server);\n\n    g_free(gconf->volname);\n\n    g_free(gconf->image);\n\n    g_free(gconf->transport);\n\n    g_free(gconf);\n\n}\n", "idx": 26877}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "void net_tx_pkt_init(struct NetTxPkt **pkt, uint32_t max_frags,\n\n    bool has_virt_hdr)\n\n{\n\n    struct NetTxPkt *p = g_malloc0(sizeof *p);\n\n\n\n    p->vec = g_malloc((sizeof *p->vec) *\n\n        (max_frags + NET_TX_PKT_PL_START_FRAG));\n\n\n\n    p->raw = g_malloc((sizeof *p->raw) * max_frags);\n\n\n\n    p->max_payload_frags = max_frags;\n\n    p->max_raw_frags = max_frags;\n\n    p->has_virt_hdr = has_virt_hdr;\n\n    p->vec[NET_TX_PKT_VHDR_FRAG].iov_base = &p->virt_hdr;\n\n    p->vec[NET_TX_PKT_VHDR_FRAG].iov_len =\n\n        p->has_virt_hdr ? sizeof p->virt_hdr : 0;\n\n    p->vec[NET_TX_PKT_L2HDR_FRAG].iov_base = &p->l2_hdr;\n\n    p->vec[NET_TX_PKT_L3HDR_FRAG].iov_base = NULL;\n\n    p->vec[NET_TX_PKT_L3HDR_FRAG].iov_len = 0;\n\n\n\n    *pkt = p;\n\n}\n", "idx": 26878}
{"project": "qemu", "commit_id": "d66b969b0d9c8eefdcbff4b48535b0fe1501d139", "target": 0, "func": "static void vtd_init(IntelIOMMUState *s)\n\n{\n\n    memset(s->csr, 0, DMAR_REG_SIZE);\n\n    memset(s->wmask, 0, DMAR_REG_SIZE);\n\n    memset(s->w1cmask, 0, DMAR_REG_SIZE);\n\n    memset(s->womask, 0, DMAR_REG_SIZE);\n\n\n\n    s->iommu_ops.translate = vtd_iommu_translate;\n\n    s->root = 0;\n\n    s->root_extended = false;\n\n    s->dmar_enabled = false;\n\n    s->iq_head = 0;\n\n    s->iq_tail = 0;\n\n    s->iq = 0;\n\n    s->iq_size = 0;\n\n    s->qi_enabled = false;\n\n    s->iq_last_desc_type = VTD_INV_DESC_NONE;\n\n    s->next_frcd_reg = 0;\n\n    s->cap = VTD_CAP_FRO | VTD_CAP_NFR | VTD_CAP_ND | VTD_CAP_MGAW |\n\n             VTD_CAP_SAGAW | VTD_CAP_MAMV | VTD_CAP_PSI;\n\n    s->ecap = VTD_ECAP_QI | VTD_ECAP_IRO;\n\n\n\n    vtd_reset_context_cache(s);\n\n    vtd_reset_iotlb(s);\n\n\n\n    /* Define registers with default values and bit semantics */\n\n    vtd_define_long(s, DMAR_VER_REG, 0x10UL, 0, 0);\n\n    vtd_define_quad(s, DMAR_CAP_REG, s->cap, 0, 0);\n\n    vtd_define_quad(s, DMAR_ECAP_REG, s->ecap, 0, 0);\n\n    vtd_define_long(s, DMAR_GCMD_REG, 0, 0xff800000UL, 0);\n\n    vtd_define_long_wo(s, DMAR_GCMD_REG, 0xff800000UL);\n\n    vtd_define_long(s, DMAR_GSTS_REG, 0, 0, 0);\n\n    vtd_define_quad(s, DMAR_RTADDR_REG, 0, 0xfffffffffffff000ULL, 0);\n\n    vtd_define_quad(s, DMAR_CCMD_REG, 0, 0xe0000003ffffffffULL, 0);\n\n    vtd_define_quad_wo(s, DMAR_CCMD_REG, 0x3ffff0000ULL);\n\n\n\n    /* Advanced Fault Logging not supported */\n\n    vtd_define_long(s, DMAR_FSTS_REG, 0, 0, 0x11UL);\n\n    vtd_define_long(s, DMAR_FECTL_REG, 0x80000000UL, 0x80000000UL, 0);\n\n    vtd_define_long(s, DMAR_FEDATA_REG, 0, 0x0000ffffUL, 0);\n\n    vtd_define_long(s, DMAR_FEADDR_REG, 0, 0xfffffffcUL, 0);\n\n\n\n    /* Treated as RsvdZ when EIM in ECAP_REG is not supported\n\n     * vtd_define_long(s, DMAR_FEUADDR_REG, 0, 0xffffffffUL, 0);\n\n     */\n\n    vtd_define_long(s, DMAR_FEUADDR_REG, 0, 0, 0);\n\n\n\n    /* Treated as RO for implementations that PLMR and PHMR fields reported\n\n     * as Clear in the CAP_REG.\n\n     * vtd_define_long(s, DMAR_PMEN_REG, 0, 0x80000000UL, 0);\n\n     */\n\n    vtd_define_long(s, DMAR_PMEN_REG, 0, 0, 0);\n\n\n\n    vtd_define_quad(s, DMAR_IQH_REG, 0, 0, 0);\n\n    vtd_define_quad(s, DMAR_IQT_REG, 0, 0x7fff0ULL, 0);\n\n    vtd_define_quad(s, DMAR_IQA_REG, 0, 0xfffffffffffff007ULL, 0);\n\n    vtd_define_long(s, DMAR_ICS_REG, 0, 0, 0x1UL);\n\n    vtd_define_long(s, DMAR_IECTL_REG, 0x80000000UL, 0x80000000UL, 0);\n\n    vtd_define_long(s, DMAR_IEDATA_REG, 0, 0xffffffffUL, 0);\n\n    vtd_define_long(s, DMAR_IEADDR_REG, 0, 0xfffffffcUL, 0);\n\n    /* Treadted as RsvdZ when EIM in ECAP_REG is not supported */\n\n    vtd_define_long(s, DMAR_IEUADDR_REG, 0, 0, 0);\n\n\n\n    /* IOTLB registers */\n\n    vtd_define_quad(s, DMAR_IOTLB_REG, 0, 0Xb003ffff00000000ULL, 0);\n\n    vtd_define_quad(s, DMAR_IVA_REG, 0, 0xfffffffffffff07fULL, 0);\n\n    vtd_define_quad_wo(s, DMAR_IVA_REG, 0xfffffffffffff07fULL);\n\n\n\n    /* Fault Recording Registers, 128-bit */\n\n    vtd_define_quad(s, DMAR_FRCD_REG_0_0, 0, 0, 0);\n\n    vtd_define_quad(s, DMAR_FRCD_REG_0_2, 0, 0, 0x8000000000000000ULL);\n\n}\n", "idx": 26879}
{"project": "qemu", "commit_id": "e70377dfa4bbc2e101066ca35675bed4129c5a8c", "target": 0, "func": "static S390PCIBusDevice *s390_pci_find_dev_by_uid(uint16_t uid)\n\n{\n\n    int i;\n\n    S390PCIBusDevice *pbdev;\n\n    S390pciState *s = s390_get_phb();\n\n\n\n    for (i = 0; i < PCI_SLOT_MAX; i++) {\n\n        pbdev = s->pbdev[i];\n\n        if (!pbdev) {\n\n            continue;\n\n        }\n\n\n\n        if (pbdev->uid == uid) {\n\n            return pbdev;\n\n        }\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 26881}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int usb_host_usbfs_type(USBHostDevice *s, USBPacket *p)\n\n{\n\n    static const int usbfs[] = {\n\n        [USB_ENDPOINT_XFER_CONTROL] = USBDEVFS_URB_TYPE_CONTROL,\n\n        [USB_ENDPOINT_XFER_ISOC]    = USBDEVFS_URB_TYPE_ISO,\n\n        [USB_ENDPOINT_XFER_BULK]    = USBDEVFS_URB_TYPE_BULK,\n\n        [USB_ENDPOINT_XFER_INT]     = USBDEVFS_URB_TYPE_INTERRUPT,\n\n    };\n\n    uint8_t type = usb_ep_get_type(&s->dev, p->pid, p->devep);\n\n    assert(type < ARRAY_SIZE(usbfs));\n\n    return usbfs[type];\n\n}\n", "idx": 26882}
{"project": "qemu", "commit_id": "3df9caf88f5c0859ae380101fea47609ba1dbfbd", "target": 0, "func": "static void scsi_cancel_io(SCSIRequest *req)\n\n{\n\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n\n\n    DPRINTF(\"Cancel tag=0x%x\\n\", req->tag);\n\n    if (r->req.aiocb) {\n\n        bdrv_aio_cancel(r->req.aiocb);\n\n\n\n        /* This reference was left in by scsi_*_data.  We take ownership of\n\n         * it the moment scsi_req_cancel is called, independent of whether\n\n         * bdrv_aio_cancel completes the request or not.  */\n\n        scsi_req_unref(&r->req);\n\n    }\n\n    r->req.aiocb = NULL;\n\n}\n", "idx": 26883}
{"project": "qemu", "commit_id": "0c402e5abb8c2755390eee864b43a98280fc2453", "target": 0, "func": "static int usb_host_scan_dev(void *opaque, USBScanFunc *func)\n\n{\n\n    FILE *f = NULL;\n\n    char line[1024];\n\n    char buf[1024];\n\n    int bus_num, addr, speed, device_count, class_id, product_id, vendor_id;\n\n    char product_name[512];\n\n    int ret = 0;\n\n\n\n    if (!usb_host_device_path) {\n\n        perror(\"husb: USB Host Device Path not set\");\n\n        goto the_end;\n\n    }\n\n    snprintf(line, sizeof(line), \"%s/devices\", usb_host_device_path);\n\n    f = fopen(line, \"r\");\n\n    if (!f) {\n\n        perror(\"husb: cannot open devices file\");\n\n        goto the_end;\n\n    }\n\n\n\n    device_count = 0;\n\n    bus_num = addr = class_id = product_id = vendor_id = 0;\n\n    speed = -1; /* Can't get the speed from /[proc|dev]/bus/usb/devices */\n\n    for(;;) {\n\n        if (fgets(line, sizeof(line), f) == NULL) {\n\n            break;\n\n        }\n\n        if (strlen(line) > 0) {\n\n            line[strlen(line) - 1] = '\\0';\n\n        }\n\n        if (line[0] == 'T' && line[1] == ':') {\n\n            if (device_count && (vendor_id || product_id)) {\n\n                /* New device.  Add the previously discovered device.  */\n\n                ret = func(opaque, bus_num, addr, 0, class_id, vendor_id,\n\n                           product_id, product_name, speed);\n\n                if (ret) {\n\n                    goto the_end;\n\n                }\n\n            }\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Bus=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            bus_num = atoi(buf);\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Dev#=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            addr = atoi(buf);\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Spd=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            if (!strcmp(buf, \"5000\")) {\n\n                speed = USB_SPEED_SUPER;\n\n            } else if (!strcmp(buf, \"480\")) {\n\n                speed = USB_SPEED_HIGH;\n\n            } else if (!strcmp(buf, \"1.5\")) {\n\n                speed = USB_SPEED_LOW;\n\n            } else {\n\n                speed = USB_SPEED_FULL;\n\n            }\n\n            product_name[0] = '\\0';\n\n            class_id = 0xff;\n\n            device_count++;\n\n            product_id = 0;\n\n            vendor_id = 0;\n\n        } else if (line[0] == 'P' && line[1] == ':') {\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Vendor=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            vendor_id = strtoul(buf, NULL, 16);\n\n            if (get_tag_value(buf, sizeof(buf), line, \"ProdID=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            product_id = strtoul(buf, NULL, 16);\n\n        } else if (line[0] == 'S' && line[1] == ':') {\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Product=\", \"\") < 0) {\n\n                goto fail;\n\n            }\n\n            pstrcpy(product_name, sizeof(product_name), buf);\n\n        } else if (line[0] == 'D' && line[1] == ':') {\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Cls=\", \" (\") < 0) {\n\n                goto fail;\n\n            }\n\n            class_id = strtoul(buf, NULL, 16);\n\n        }\n\n    fail: ;\n\n    }\n\n    if (device_count && (vendor_id || product_id)) {\n\n        /* Add the last device.  */\n\n        ret = func(opaque, bus_num, addr, 0, class_id, vendor_id,\n\n                   product_id, product_name, speed);\n\n    }\n\n the_end:\n\n    if (f) {\n\n        fclose(f);\n\n    }\n\n    return ret;\n\n}\n", "idx": 26884}
{"project": "qemu", "commit_id": "9d4c0f4f0a71e74fd7e04d73620268484d693adf", "target": 0, "func": "static uint32_t drc_unisolate_logical(sPAPRDRConnector *drc)\n\n{\n\n    /* cannot unisolate a non-existent resource, and, or resources\n\n     * which are in an 'UNUSABLE' allocation state. (PAPR 2.7,\n\n     * 13.5.3.5)\n\n     */\n\n    if (!drc->dev ||\n\n        drc->allocation_state == SPAPR_DR_ALLOCATION_STATE_UNUSABLE) {\n\n        return RTAS_OUT_NO_SUCH_INDICATOR;\n\n    }\n\n\n\n    drc->isolation_state = SPAPR_DR_ISOLATION_STATE_UNISOLATED;\n\n\n\n    return RTAS_OUT_SUCCESS;\n\n}\n", "idx": 26885}
{"project": "qemu", "commit_id": "03ae4133ab8675d4c67e6fdc8032de7c53a89514", "target": 0, "func": "static void ppc_cpu_class_init(ObjectClass *oc, void *data)\n\n{\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(oc);\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n    pcc->parent_realize = dc->realize;\n\n    pcc->pvr = CPU_POWERPC_DEFAULT_MASK;\n\n    pcc->pvr_mask = CPU_POWERPC_DEFAULT_MASK;\n\n    pcc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_always;\n\n    dc->realize = ppc_cpu_realizefn;\n\n    dc->unrealize = ppc_cpu_unrealizefn;\n\n\n\n    pcc->parent_reset = cc->reset;\n\n    cc->reset = ppc_cpu_reset;\n\n\n\n    cc->class_by_name = ppc_cpu_class_by_name;\n\n    cc->has_work = ppc_cpu_has_work;\n\n    cc->do_interrupt = ppc_cpu_do_interrupt;\n\n    cc->dump_state = ppc_cpu_dump_state;\n\n    cc->dump_statistics = ppc_cpu_dump_statistics;\n\n    cc->set_pc = ppc_cpu_set_pc;\n\n    cc->gdb_read_register = ppc_cpu_gdb_read_register;\n\n    cc->gdb_write_register = ppc_cpu_gdb_write_register;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = ppc_cpu_handle_mmu_fault;\n\n#else\n\n    cc->get_phys_page_debug = ppc_cpu_get_phys_page_debug;\n\n    cc->vmsd = &vmstate_ppc_cpu;\n\n#if defined(TARGET_PPC64)\n\n    cc->write_elf64_note = ppc64_cpu_write_elf64_note;\n\n    cc->write_elf64_qemunote = ppc64_cpu_write_elf64_qemunote;\n\n#endif\n\n#endif\n\n\n\n    cc->gdb_num_core_regs = 71;\n\n\n\n#ifdef USE_APPLE_GDB\n\n    cc->gdb_read_register = ppc_cpu_gdb_read_register_apple;\n\n    cc->gdb_write_register = ppc_cpu_gdb_write_register_apple;\n\n    cc->gdb_num_core_regs = 71 + 32;\n\n#endif\n\n\n\n#if defined(TARGET_PPC64)\n\n    cc->gdb_core_xml_file = \"power64-core.xml\";\n\n#else\n\n    cc->gdb_core_xml_file = \"power-core.xml\";\n\n#endif\n\n#ifndef CONFIG_USER_ONLY\n\n    cc->virtio_is_big_endian = ppc_cpu_is_big_endian;\n\n#endif\n\n\n\n    dc->fw_name = \"PowerPC,UNKNOWN\";\n\n}\n", "idx": 26886}
{"project": "qemu", "commit_id": "cef34eebf3d0f252a3b3e9a2a459b6c3ecc56f68", "target": 0, "func": "void do_blockdev_backup(const char *job_id, const char *device,\n\n                        const char *target, enum MirrorSyncMode sync,\n\n                         bool has_speed, int64_t speed,\n\n                         bool has_on_source_error,\n\n                         BlockdevOnError on_source_error,\n\n                         bool has_on_target_error,\n\n                         BlockdevOnError on_target_error,\n\n                         BlockJobTxn *txn, Error **errp)\n\n{\n\n    BlockBackend *blk;\n\n    BlockDriverState *bs;\n\n    BlockDriverState *target_bs;\n\n    Error *local_err = NULL;\n\n    AioContext *aio_context;\n\n\n\n    if (!has_speed) {\n\n        speed = 0;\n\n    }\n\n    if (!has_on_source_error) {\n\n        on_source_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n    if (!has_on_target_error) {\n\n        on_target_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n\n\n    blk = blk_by_name(device);\n\n    if (!blk) {\n\n        error_setg(errp, \"Device '%s' not found\", device);\n\n        return;\n\n    }\n\n\n\n    aio_context = blk_get_aio_context(blk);\n\n    aio_context_acquire(aio_context);\n\n\n\n    if (!blk_is_available(blk)) {\n\n        error_setg(errp, \"Device '%s' has no medium\", device);\n\n        goto out;\n\n    }\n\n    bs = blk_bs(blk);\n\n\n\n    target_bs = bdrv_lookup_bs(target, target, errp);\n\n    if (!target_bs) {\n\n        goto out;\n\n    }\n\n\n\n    if (bdrv_get_aio_context(target_bs) != aio_context) {\n\n        if (!bdrv_has_blk(target_bs)) {\n\n            /* The target BDS is not attached, we can safely move it to another\n\n             * AioContext. */\n\n            bdrv_set_aio_context(target_bs, aio_context);\n\n        } else {\n\n            error_setg(errp, \"Target is attached to a different thread from \"\n\n                             \"source.\");\n\n            goto out;\n\n        }\n\n    }\n\n    backup_start(job_id, bs, target_bs, speed, sync, NULL, on_source_error,\n\n                 on_target_error, block_job_cb, bs, txn, &local_err);\n\n    if (local_err != NULL) {\n\n        error_propagate(errp, local_err);\n\n    }\n\nout:\n\n    aio_context_release(aio_context);\n\n}\n", "idx": 26887}
{"project": "qemu", "commit_id": "8e8eb0a9035e5b6c6447c82138570e388282cfa2", "target": 0, "func": "BlockDeviceInfo *bdrv_block_device_info(BlockBackend *blk,\n\n                                        BlockDriverState *bs, Error **errp)\n\n{\n\n    ImageInfo **p_image_info;\n\n    BlockDriverState *bs0;\n\n    BlockDeviceInfo *info = g_malloc0(sizeof(*info));\n\n\n\n    info->file                   = g_strdup(bs->filename);\n\n    info->ro                     = bs->read_only;\n\n    info->drv                    = g_strdup(bs->drv->format_name);\n\n    info->encrypted              = bs->encrypted;\n\n    info->encryption_key_missing = false;\n\n\n\n    info->cache = g_new(BlockdevCacheInfo, 1);\n\n    *info->cache = (BlockdevCacheInfo) {\n\n        .writeback      = blk ? blk_enable_write_cache(blk) : true,\n\n        .direct         = !!(bs->open_flags & BDRV_O_NOCACHE),\n\n        .no_flush       = !!(bs->open_flags & BDRV_O_NO_FLUSH),\n\n    };\n\n\n\n    if (bs->node_name[0]) {\n\n        info->has_node_name = true;\n\n        info->node_name = g_strdup(bs->node_name);\n\n    }\n\n\n\n    if (bs->backing_file[0]) {\n\n        info->has_backing_file = true;\n\n        info->backing_file = g_strdup(bs->backing_file);\n\n    }\n\n\n\n    info->detect_zeroes = bs->detect_zeroes;\n\n\n\n    if (blk && blk_get_public(blk)->throttle_state) {\n\n        ThrottleConfig cfg;\n\n\n\n        throttle_group_get_config(blk, &cfg);\n\n\n\n        info->bps     = cfg.buckets[THROTTLE_BPS_TOTAL].avg;\n\n        info->bps_rd  = cfg.buckets[THROTTLE_BPS_READ].avg;\n\n        info->bps_wr  = cfg.buckets[THROTTLE_BPS_WRITE].avg;\n\n\n\n        info->iops    = cfg.buckets[THROTTLE_OPS_TOTAL].avg;\n\n        info->iops_rd = cfg.buckets[THROTTLE_OPS_READ].avg;\n\n        info->iops_wr = cfg.buckets[THROTTLE_OPS_WRITE].avg;\n\n\n\n        info->has_bps_max     = cfg.buckets[THROTTLE_BPS_TOTAL].max;\n\n        info->bps_max         = cfg.buckets[THROTTLE_BPS_TOTAL].max;\n\n        info->has_bps_rd_max  = cfg.buckets[THROTTLE_BPS_READ].max;\n\n        info->bps_rd_max      = cfg.buckets[THROTTLE_BPS_READ].max;\n\n        info->has_bps_wr_max  = cfg.buckets[THROTTLE_BPS_WRITE].max;\n\n        info->bps_wr_max      = cfg.buckets[THROTTLE_BPS_WRITE].max;\n\n\n\n        info->has_iops_max    = cfg.buckets[THROTTLE_OPS_TOTAL].max;\n\n        info->iops_max        = cfg.buckets[THROTTLE_OPS_TOTAL].max;\n\n        info->has_iops_rd_max = cfg.buckets[THROTTLE_OPS_READ].max;\n\n        info->iops_rd_max     = cfg.buckets[THROTTLE_OPS_READ].max;\n\n        info->has_iops_wr_max = cfg.buckets[THROTTLE_OPS_WRITE].max;\n\n        info->iops_wr_max     = cfg.buckets[THROTTLE_OPS_WRITE].max;\n\n\n\n        info->has_bps_max_length     = info->has_bps_max;\n\n        info->bps_max_length         =\n\n            cfg.buckets[THROTTLE_BPS_TOTAL].burst_length;\n\n        info->has_bps_rd_max_length  = info->has_bps_rd_max;\n\n        info->bps_rd_max_length      =\n\n            cfg.buckets[THROTTLE_BPS_READ].burst_length;\n\n        info->has_bps_wr_max_length  = info->has_bps_wr_max;\n\n        info->bps_wr_max_length      =\n\n            cfg.buckets[THROTTLE_BPS_WRITE].burst_length;\n\n\n\n        info->has_iops_max_length    = info->has_iops_max;\n\n        info->iops_max_length        =\n\n            cfg.buckets[THROTTLE_OPS_TOTAL].burst_length;\n\n        info->has_iops_rd_max_length = info->has_iops_rd_max;\n\n        info->iops_rd_max_length     =\n\n            cfg.buckets[THROTTLE_OPS_READ].burst_length;\n\n        info->has_iops_wr_max_length = info->has_iops_wr_max;\n\n        info->iops_wr_max_length     =\n\n            cfg.buckets[THROTTLE_OPS_WRITE].burst_length;\n\n\n\n        info->has_iops_size = cfg.op_size;\n\n        info->iops_size = cfg.op_size;\n\n\n\n        info->has_group = true;\n\n        info->group = g_strdup(throttle_group_get_name(blk));\n\n    }\n\n\n\n    info->write_threshold = bdrv_write_threshold_get(bs);\n\n\n\n    bs0 = bs;\n\n    p_image_info = &info->image;\n\n    info->backing_file_depth = 0;\n\n    while (1) {\n\n        Error *local_err = NULL;\n\n        bdrv_query_image_info(bs0, p_image_info, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            qapi_free_BlockDeviceInfo(info);\n\n            return NULL;\n\n        }\n\n\n\n        if (bs0->drv && bs0->backing) {\n\n            info->backing_file_depth++;\n\n            bs0 = bs0->backing->bs;\n\n            (*p_image_info)->has_backing_image = true;\n\n            p_image_info = &((*p_image_info)->backing_image);\n\n        } else {\n\n            break;\n\n        }\n\n\n\n        /* Skip automatically inserted nodes that the user isn't aware of for\n\n         * query-block (blk != NULL), but not for query-named-block-nodes */\n\n        while (blk && bs0 && bs0->drv && bs0->implicit) {\n\n            bs0 = backing_bs(bs0);\n\n        }\n\n    }\n\n\n\n    return info;\n\n}\n", "idx": 26888}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void qemu_clock_unregister_reset_notifier(QEMUClockType type,\n\n                                          Notifier *notifier)\n\n{\n\n    notifier_remove(notifier);\n\n}\n", "idx": 26889}
{"project": "qemu", "commit_id": "28c5af54c661e73e5596918fa67a22b5e87c2022", "target": 0, "func": "static void ppc_core99_init (int ram_size, int vga_ram_size,\n\n                             const char *boot_device, DisplayState *ds,\n\n                             const char **fd_filename, int snapshot,\n\n                             const char *kernel_filename,\n\n                             const char *kernel_cmdline,\n\n                             const char *initrd_filename,\n\n                             const char *cpu_model)\n\n{\n\n    CPUState *env = NULL, *envs[MAX_CPUS];\n\n    char buf[1024];\n\n    qemu_irq *pic, **openpic_irqs;\n\n    int unin_memory;\n\n    int linux_boot, i;\n\n    unsigned long bios_offset, vga_bios_offset;\n\n    uint32_t kernel_base, kernel_size, initrd_base, initrd_size;\n\n    PCIBus *pci_bus;\n\n    nvram_t nvram;\n\n#if 0\n\n    MacIONVRAMState *nvr;\n\n    int nvram_mem_index;\n\n#endif\n\n    m48t59_t *m48t59;\n\n    int vga_bios_size, bios_size;\n\n    qemu_irq *dummy_irq;\n\n    int pic_mem_index, dbdma_mem_index, cuda_mem_index;\n\n    int ide_mem_index[2];\n\n    int ppc_boot_device = boot_device[0];\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL)\n\n        cpu_model = \"default\";\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        /* Set time-base frequency to 100 Mhz */\n\n        cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);\n\n#if 0\n\n        env->osi_call = vga_osi_call;\n\n#endif\n\n        qemu_register_reset(&cpu_ppc_reset, env);\n\n        register_savevm(\"cpu\", 0, 3, cpu_save, cpu_load, env);\n\n        envs[i] = env;\n\n    }\n\n    if (env->nip < 0xFFF80000) {\n\n        /* Special test for PowerPC 601:\n\n         * the boot vector is at 0xFFF00100, then we need a 1MB BIOS.\n\n         * But the NVRAM is located at 0xFFF04000...\n\n         */\n\n        cpu_abort(env, \"Mac99 hardware can not handle 1 MB BIOS\\n\");\n\n    }\n\n\n\n    /* allocate RAM */\n\n    cpu_register_physical_memory(0, ram_size, IO_MEM_RAM);\n\n\n\n    /* allocate and load BIOS */\n\n    bios_offset = ram_size + vga_ram_size;\n\n    if (bios_name == NULL)\n\n        bios_name = BIOS_FILENAME;\n\n    snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, bios_name);\n\n    bios_size = load_image(buf, phys_ram_base + bios_offset);\n\n    if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n        cpu_abort(env, \"qemu: could not load PowerPC bios '%s'\\n\", buf);\n\n        exit(1);\n\n    }\n\n    bios_size = (bios_size + 0xfff) & ~0xfff;\n\n    if (bios_size > 0x00080000) {\n\n        /* As the NVRAM is located at 0xFFF04000, we cannot use 1 MB BIOSes */\n\n        cpu_abort(env, \"Mac99 hardware can not handle 1 MB BIOS\\n\");\n\n    }\n\n    cpu_register_physical_memory((uint32_t)(-bios_size),\n\n                                 bios_size, bios_offset | IO_MEM_ROM);\n\n\n\n    /* allocate and load VGA BIOS */\n\n    vga_bios_offset = bios_offset + bios_size;\n\n    snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, VGABIOS_FILENAME);\n\n    vga_bios_size = load_image(buf, phys_ram_base + vga_bios_offset + 8);\n\n    if (vga_bios_size < 0) {\n\n        /* if no bios is present, we can still work */\n\n        fprintf(stderr, \"qemu: warning: could not load VGA bios '%s'\\n\", buf);\n\n        vga_bios_size = 0;\n\n    } else {\n\n        /* set a specific header (XXX: find real Apple format for NDRV\n\n           drivers) */\n\n        phys_ram_base[vga_bios_offset] = 'N';\n\n        phys_ram_base[vga_bios_offset + 1] = 'D';\n\n        phys_ram_base[vga_bios_offset + 2] = 'R';\n\n        phys_ram_base[vga_bios_offset + 3] = 'V';\n\n        cpu_to_be32w((uint32_t *)(phys_ram_base + vga_bios_offset + 4),\n\n                     vga_bios_size);\n\n        vga_bios_size += 8;\n\n    }\n\n    vga_bios_size = (vga_bios_size + 0xfff) & ~0xfff;\n\n\n\n    if (linux_boot) {\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n        /* now we can load the kernel */\n\n        kernel_size = load_image(kernel_filename, phys_ram_base + kernel_base);\n\n        if (kernel_size < 0) {\n\n            cpu_abort(env, \"qemu: could not load kernel '%s'\\n\",\n\n                      kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image(initrd_filename,\n\n                                     phys_ram_base + initrd_base);\n\n            if (initrd_size < 0) {\n\n                cpu_abort(env, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                          initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n        ppc_boot_device = 'm';\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n    }\n\n\n\n    isa_mem_base = 0x80000000;\n\n\n\n    /* Register 8 MB of ISA IO space */\n\n    isa_mmio_init(0xf2000000, 0x00800000);\n\n\n\n    /* UniN init */\n\n    unin_memory = cpu_register_io_memory(0, unin_read, unin_write, NULL);\n\n    cpu_register_physical_memory(0xf8000000, 0x00001000, unin_memory);\n\n\n\n    openpic_irqs = qemu_mallocz(smp_cpus * sizeof(qemu_irq *));\n\n    openpic_irqs[0] =\n\n        qemu_mallocz(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB);\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        /* Mac99 IRQ connection between OpenPIC outputs pins\n\n         * and PowerPC input pins\n\n         */\n\n        switch (PPC_INPUT(env)) {\n\n        case PPC_FLAGS_INPUT_6xx:\n\n            openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB);\n\n            openpic_irqs[i][OPENPIC_OUTPUT_INT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_CINT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_MCK] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_MCP];\n\n            /* Not connected ? */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL;\n\n            /* Check this */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_RESET] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_HRESET];\n\n            break;\n\n#if defined(TARGET_PPC64)\n\n        case PPC_FLAGS_INPUT_970:\n\n            openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB);\n\n            openpic_irqs[i][OPENPIC_OUTPUT_INT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_CINT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_MCK] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_MCP];\n\n            /* Not connected ? */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL;\n\n            /* Check this */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_RESET] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_HRESET];\n\n            break;\n\n#endif /* defined(TARGET_PPC64) */\n\n        default:\n\n            cpu_abort(env, \"Bus model not supported on mac99 machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n    pic = openpic_init(NULL, &pic_mem_index, smp_cpus, openpic_irqs, NULL);\n\n    pci_bus = pci_pmac_init(pic);\n\n    /* init basic PC hardware */\n\n    pci_vga_init(pci_bus, ds, phys_ram_base + ram_size,\n\n                 ram_size, vga_ram_size,\n\n                 vga_bios_offset, vga_bios_size);\n\n    \n\n    /* XXX: suppress that */\n\n    dummy_irq = i8259_init(NULL);\n\n\n\n    /* XXX: use Mac Serial port */\n\n    serial_init(0x3f8, dummy_irq[4], serial_hds[0]);\n\n    for(i = 0; i < nb_nics; i++) {\n\n        if (!nd_table[i].model)\n\n            nd_table[i].model = \"ne2k_pci\";\n\n        pci_nic_init(pci_bus, &nd_table[i], -1);\n\n    }\n\n#if 1\n\n    ide_mem_index[0] = pmac_ide_init(&bs_table[0], pic[0x13]);\n\n    ide_mem_index[1] = pmac_ide_init(&bs_table[2], pic[0x14]);\n\n#else\n\n    pci_cmd646_ide_init(pci_bus, &bs_table[0], 0);\n\n#endif\n\n    /* cuda also initialize ADB */\n\n    cuda_init(&cuda_mem_index, pic[0x19]);\n\n    \n\n    adb_kbd_init(&adb_bus);\n\n    adb_mouse_init(&adb_bus);\n\n\n\n    dbdma_init(&dbdma_mem_index);\n\n\n\n    macio_init(pci_bus, 0x0022, 0, pic_mem_index, dbdma_mem_index,\n\n               cuda_mem_index, NULL, 2, ide_mem_index);\n\n\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, 3, -1);\n\n    }\n\n\n\n    if (graphic_depth != 15 && graphic_depth != 32 && graphic_depth != 8)\n\n        graphic_depth = 15;\n\n#if 0 /* XXX: this is ugly but needed for now, or OHW won't boot */\n\n    /* The NewWorld NVRAM is not located in the MacIO device */\n\n    nvr = macio_nvram_init(&nvram_mem_index, 0x2000);\n\n    pmac_format_nvram_partition(nvr, 0x2000);\n\n    macio_nvram_map(nvr, 0xFFF04000);\n\n    nvram.opaque = nvr;\n\n    nvram.read_fn = &macio_nvram_read;\n\n    nvram.write_fn = &macio_nvram_write;\n\n#else\n\n    m48t59 = m48t59_init(dummy_irq[8], 0xFFF04000, 0x0074, NVRAM_SIZE, 59);\n\n    nvram.opaque = m48t59;\n\n    nvram.read_fn = &m48t59_read;\n\n    nvram.write_fn = &m48t59_write;\n\n#endif\n\n    PPC_NVRAM_set_params(&nvram, NVRAM_SIZE, \"MAC99\", ram_size,\n\n                         ppc_boot_device, kernel_base, kernel_size,\n\n                         kernel_cmdline,\n\n                         initrd_base, initrd_size,\n\n                         /* XXX: need an option to load a NVRAM image */\n\n                         0,\n\n                         graphic_width, graphic_height, graphic_depth);\n\n    /* No PCI init: the BIOS will do it */\n\n\n\n    /* Special port to get debug messages from Open-Firmware */\n\n    register_ioport_write(0x0F00, 4, 1, &PPC_debug_write, NULL);\n\n }\n", "idx": 26890}
{"project": "qemu", "commit_id": "90618f4f4d1e7b5b9fe40834646adac1e21d1b07", "target": 0, "func": "POWERPC_FAMILY(POWER5P)(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);\n\n\n\n    dc->fw_name = \"PowerPC,POWER5\";\n\n    dc->desc = \"POWER5+\";\n\n    pcc->init_proc = init_proc_power5plus;\n\n    pcc->check_pow = check_pow_970FX;\n\n    pcc->insns_flags = PPC_INSNS_BASE | PPC_STRING | PPC_MFTB |\n\n                       PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES |\n\n                       PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |\n\n                       PPC_FLOAT_STFIWX |\n\n                       PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ |\n\n                       PPC_MEM_SYNC | PPC_MEM_EIEIO |\n\n                       PPC_MEM_TLBIE | PPC_MEM_TLBSYNC |\n\n                       PPC_64B |\n\n                       PPC_SEGMENT_64B | PPC_SLBI;\n\n    pcc->msr_mask = (1ull << MSR_SF) |\n\n                    (1ull << MSR_VR) |\n\n                    (1ull << MSR_POW) |\n\n                    (1ull << MSR_EE) |\n\n                    (1ull << MSR_PR) |\n\n                    (1ull << MSR_FP) |\n\n                    (1ull << MSR_ME) |\n\n                    (1ull << MSR_FE0) |\n\n                    (1ull << MSR_SE) |\n\n                    (1ull << MSR_DE) |\n\n                    (1ull << MSR_FE1) |\n\n                    (1ull << MSR_IR) |\n\n                    (1ull << MSR_DR) |\n\n                    (1ull << MSR_PMM) |\n\n                    (1ull << MSR_RI);\n\n    pcc->mmu_model = POWERPC_MMU_64B;\n\n#if defined(CONFIG_SOFTMMU)\n\n    pcc->handle_mmu_fault = ppc_hash64_handle_mmu_fault;\n\n#endif\n\n    pcc->excp_model = POWERPC_EXCP_970;\n\n    pcc->bus_model = PPC_FLAGS_INPUT_970;\n\n    pcc->bfd_mach = bfd_mach_ppc64;\n\n    pcc->flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE |\n\n                 POWERPC_FLAG_BE | POWERPC_FLAG_PMM |\n\n                 POWERPC_FLAG_BUS_CLK;\n\n    pcc->l1_dcache_size = 0x8000;\n\n    pcc->l1_icache_size = 0x10000;\n\n}\n", "idx": 26891}
{"project": "qemu", "commit_id": "42bb9c9178ae7ac4c439172b1ae99cc29188a5c6", "target": 0, "func": "static void xilinx_enet_init(Object *obj)\n\n{\n\n    XilinxAXIEnet *s = XILINX_AXI_ENET(obj);\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);\n\n    Error *errp = NULL;\n\n\n\n    object_property_add_link(obj, \"axistream-connected\", TYPE_STREAM_SLAVE,\n\n                             (Object **) &s->tx_dev, &errp);\n\n    assert_no_error(errp);\n\n\n\n    object_initialize(&s->rx_data_dev, TYPE_XILINX_AXI_ENET_DATA_STREAM);\n\n    object_property_add_child(OBJECT(s), \"axistream-connected-target\",\n\n                              (Object *)&s->rx_data_dev, &errp);\n\n    assert_no_error(errp);\n\n\n\n    sysbus_init_irq(sbd, &s->irq);\n\n\n\n    memory_region_init_io(&s->iomem, &enet_ops, s, \"enet\", 0x40000);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n\n}\n", "idx": 26892}
{"project": "qemu", "commit_id": "23326164ae6fe8d94b7eff123e03f97ca6978d33", "target": 0, "func": "bool address_space_rw(AddressSpace *as, hwaddr addr, uint8_t *buf,\n\n                      int len, bool is_write)\n\n{\n\n    hwaddr l;\n\n    uint8_t *ptr;\n\n    uint64_t val;\n\n    hwaddr addr1;\n\n    MemoryRegion *mr;\n\n    bool error = false;\n\n\n\n    while (len > 0) {\n\n        l = len;\n\n        mr = address_space_translate(as, addr, &addr1, &l, is_write);\n\n\n\n        if (is_write) {\n\n            if (!memory_access_is_direct(mr, is_write)) {\n\n                l = memory_access_size(mr, l, addr1);\n\n                /* XXX: could force current_cpu to NULL to avoid\n\n                   potential bugs */\n\n                if (l == 4) {\n\n                    /* 32 bit write access */\n\n                    val = ldl_p(buf);\n\n                    error |= io_mem_write(mr, addr1, val, 4);\n\n                } else if (l == 2) {\n\n                    /* 16 bit write access */\n\n                    val = lduw_p(buf);\n\n                    error |= io_mem_write(mr, addr1, val, 2);\n\n                } else {\n\n                    /* 8 bit write access */\n\n                    val = ldub_p(buf);\n\n                    error |= io_mem_write(mr, addr1, val, 1);\n\n                }\n\n            } else {\n\n                addr1 += memory_region_get_ram_addr(mr);\n\n                /* RAM case */\n\n                ptr = qemu_get_ram_ptr(addr1);\n\n                memcpy(ptr, buf, l);\n\n                invalidate_and_set_dirty(addr1, l);\n\n            }\n\n        } else {\n\n            if (!memory_access_is_direct(mr, is_write)) {\n\n                /* I/O case */\n\n                l = memory_access_size(mr, l, addr1);\n\n                if (l == 4) {\n\n                    /* 32 bit read access */\n\n                    error |= io_mem_read(mr, addr1, &val, 4);\n\n                    stl_p(buf, val);\n\n                } else if (l == 2) {\n\n                    /* 16 bit read access */\n\n                    error |= io_mem_read(mr, addr1, &val, 2);\n\n                    stw_p(buf, val);\n\n                } else {\n\n                    /* 8 bit read access */\n\n                    error |= io_mem_read(mr, addr1, &val, 1);\n\n                    stb_p(buf, val);\n\n                }\n\n            } else {\n\n                /* RAM case */\n\n                ptr = qemu_get_ram_ptr(mr->ram_addr + addr1);\n\n                memcpy(buf, ptr, l);\n\n            }\n\n        }\n\n        len -= l;\n\n        buf += l;\n\n        addr += l;\n\n    }\n\n\n\n    return error;\n\n}\n", "idx": 26893}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_addi_acr(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tDIS(fprintf (logfile, \"addi.%c $r%u, $r%u, $acr\\n\",\n\n\t\t  memsize_char(memsize_zz(dc)), dc->op2, dc->op1));\n\n\tcris_cc_mask(dc, 0);\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\ttcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));\n\n\ttcg_gen_add_tl(cpu_R[R_ACR], cpu_R[dc->op1], t0);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n", "idx": 26894}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_out_list_qapi_free(TestOutputVisitorData *data,\n\n                                            const void *unused)\n\n{\n\n    UserDefTwoList *p, *head = NULL;\n\n    const char string[] = \"foo bar\";\n\n    int i, max_count = 1024;\n\n\n\n    for (i = 0; i < max_count; i++) {\n\n        p = g_malloc0(sizeof(*p));\n\n        p->value = g_malloc0(sizeof(*p->value));\n\n\n\n        p->value->string0 = g_strdup(string);\n\n        p->value->dict1 = g_new0(UserDefTwoDict, 1);\n\n        p->value->dict1->string1 = g_strdup(string);\n\n        p->value->dict1->dict2 = g_new0(UserDefTwoDictDict, 1);\n\n        p->value->dict1->dict2->userdef = g_new0(UserDefOne, 1);\n\n        p->value->dict1->dict2->userdef->string = g_strdup(string);\n\n        p->value->dict1->dict2->userdef->integer = 42;\n\n        p->value->dict1->dict2->string = g_strdup(string);\n\n        p->value->dict1->has_dict3 = false;\n\n\n\n        p->next = head;\n\n        head = p;\n\n    }\n\n\n\n    qapi_free_UserDefTwoList(head);\n\n}\n", "idx": 26895}
{"project": "qemu", "commit_id": "31dce3ccca98bc9f9eb57f8b08b008edd07661ba", "target": 0, "func": "void bdrv_io_limits_enable(BlockDriverState *bs, const char *group)\n\n{\n\n    assert(!bs->throttle_state);\n\n    throttle_group_register_bs(bs, group);\n\n}\n", "idx": 26896}
{"project": "qemu", "commit_id": "d9911d14e01f5e97c6ac1fe681ef15334250d149", "target": 0, "func": "static bool select_accel_fn(const void *buf, size_t len)\n\n{\n\n    uintptr_t ibuf = (uintptr_t)buf;\n\n#ifdef CONFIG_AVX2_OPT\n\n    if (len % 128 == 0 && ibuf % 32 == 0 && (cpuid_cache & CACHE_AVX2)) {\n\n        return buffer_zero_avx2(buf, len);\n\n    }\n\n    if (len % 64 == 0 && ibuf % 16 == 0 && (cpuid_cache & CACHE_SSE4)) {\n\n        return buffer_zero_sse4(buf, len);\n\n    }\n\n#endif\n\n    if (len % 64 == 0 && ibuf % 16 == 0 && (cpuid_cache & CACHE_SSE2)) {\n\n        return buffer_zero_sse2(buf, len);\n\n    }\n\n    return buffer_zero_int(buf, len);\n\n}\n", "idx": 26897}
{"project": "qemu", "commit_id": "b172c56a6d849554f7e43adc95983a9d6c042689", "target": 0, "func": "static void cpu_ppc_set_tb_clk (void *opaque, uint32_t freq)\n\n{\n\n    CPUState *env = opaque;\n\n    ppc_tb_t *tb_env = env->tb_env;\n\n\n\n    tb_env->tb_freq = freq;\n\n    tb_env->decr_freq = freq;\n\n    /* There is a bug in Linux 2.4 kernels:\n\n     * if a decrementer exception is pending when it enables msr_ee at startup,\n\n     * it's not ready to handle it...\n\n     */\n\n    _cpu_ppc_store_decr(env, 0xFFFFFFFF, 0xFFFFFFFF, 0);\n\n#if defined(TARGET_PPC64H)\n\n    _cpu_ppc_store_hdecr(env, 0xFFFFFFFF, 0xFFFFFFFF, 0);\n\n    cpu_ppc_store_purr(env, 0x0000000000000000ULL);\n\n#endif /* defined(TARGET_PPC64H) */\n\n}\n", "idx": 26898}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void pci_apb_iowritel (void *opaque, target_phys_addr_t addr,\n\n                                uint32_t val)\n\n{\n\n    cpu_outl(addr & IOPORTS_MASK, bswap32(val));\n\n}\n", "idx": 26901}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "tight_detect_smooth_image24(VncState *vs, int w, int h)\n\n{\n\n    int off;\n\n    int x, y, d, dx;\n\n    uint c;\n\n    uint stats[256];\n\n    int pixels = 0;\n\n    int pix, left[3];\n\n    uint errors;\n\n    unsigned char *buf = vs->tight.buffer;\n\n\n\n    /*\n\n     * If client is big-endian, color samples begin from the second\n\n     * byte (offset 1) of a 32-bit pixel value.\n\n     */\n\n    off = !!(vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG);\n\n\n\n    memset(stats, 0, sizeof (stats));\n\n\n\n    for (y = 0, x = 0; y < h && x < w;) {\n\n        for (d = 0; d < h - y && d < w - x - VNC_TIGHT_DETECT_SUBROW_WIDTH;\n\n             d++) {\n\n            for (c = 0; c < 3; c++) {\n\n                left[c] = buf[((y+d)*w+x+d)*4+off+c] & 0xFF;\n\n            }\n\n            for (dx = 1; dx <= VNC_TIGHT_DETECT_SUBROW_WIDTH; dx++) {\n\n                for (c = 0; c < 3; c++) {\n\n                    pix = buf[((y+d)*w+x+d+dx)*4+off+c] & 0xFF;\n\n                    stats[abs(pix - left[c])]++;\n\n                    left[c] = pix;\n\n                }\n\n                pixels++;\n\n            }\n\n        }\n\n        if (w > h) {\n\n            x += h;\n\n            y = 0;\n\n        } else {\n\n            x = 0;\n\n            y += w;\n\n        }\n\n    }\n\n\n\n    /* 95% smooth or more ... */\n\n    if (stats[0] * 33 / pixels >= 95) {\n\n        return 0;\n\n    }\n\n\n\n    errors = 0;\n\n    for (c = 1; c < 8; c++) {\n\n        errors += stats[c] * (c * c);\n\n        if (stats[c] == 0 || stats[c] > stats[c-1] * 2) {\n\n            return 0;\n\n        }\n\n    }\n\n    for (; c < 256; c++) {\n\n        errors += stats[c] * (c * c);\n\n    }\n\n    errors /= (pixels * 3 - stats[0]);\n\n\n\n    return errors;\n\n}\n", "idx": 26902}
{"project": "qemu", "commit_id": "8d5c773e323b22402abdd0beef4c7d2fc91dd0eb", "target": 0, "func": "static void csselr_write(CPUARMState *env, const ARMCPRegInfo *ri,\n\n                         uint64_t value)\n\n{\n\n    env->cp15.c0_cssel = value & 0xf;\n\n}\n", "idx": 26903}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "qemu_deliver_packet(VLANClientState *sender, const uint8_t *buf, int size)\n\n{\n\n    VLANClientState *vc;\n\n\n\n    for (vc = sender->vlan->first_client; vc != NULL; vc = vc->next) {\n\n        if (vc != sender && !vc->link_down) {\n\n            vc->receive(vc->opaque, buf, size);\n\n        }\n\n    }\n\n}\n", "idx": 26904}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "bool net_tx_pkt_send(struct NetTxPkt *pkt, NetClientState *nc)\n\n{\n\n    assert(pkt);\n\n\n\n    if (!pkt->has_virt_hdr &&\n\n        pkt->virt_hdr.flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) {\n\n        net_tx_pkt_do_sw_csum(pkt);\n\n    }\n\n\n\n    /*\n\n     * Since underlying infrastructure does not support IP datagrams longer\n\n     * than 64K we should drop such packets and don't even try to send\n\n     */\n\n    if (VIRTIO_NET_HDR_GSO_NONE != pkt->virt_hdr.gso_type) {\n\n        if (pkt->payload_len >\n\n            ETH_MAX_IP_DGRAM_LEN -\n\n            pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len) {\n\n            return false;\n\n        }\n\n    }\n\n\n\n    if (pkt->has_virt_hdr ||\n\n        pkt->virt_hdr.gso_type == VIRTIO_NET_HDR_GSO_NONE) {\n\n        qemu_sendv_packet(nc, pkt->vec,\n\n            pkt->payload_frags + NET_TX_PKT_PL_START_FRAG);\n\n        return true;\n\n    }\n\n\n\n    return net_tx_pkt_do_sw_fragmentation(pkt, nc);\n\n}\n", "idx": 26905}
{"project": "qemu", "commit_id": "5c55ff99fa88158871d5b9f619c485deae5f3d5b", "target": 0, "func": "static int create_ppc_opcodes (CPUPPCState *env, const ppc_def_t *def)\n\n{\n\n    opcode_t *opc, *start, *end;\n\n\n\n    fill_new_table(env->opcodes, 0x40);\n\n    if (&opc_start < &opc_end) {\n\n        start = &opc_start;\n\n        end = &opc_end;\n\n    } else {\n\n        start = &opc_end;\n\n        end = &opc_start;\n\n    }\n\n    for (opc = start + 1; opc != end; opc++) {\n\n        if ((opc->handler.type & def->insns_flags) != 0) {\n\n            if (register_insn(env->opcodes, opc) < 0) {\n\n                printf(\"*** ERROR initializing PowerPC instruction \"\n\n                       \"0x%02x 0x%02x 0x%02x\\n\", opc->opc1, opc->opc2,\n\n                       opc->opc3);\n\n                return -1;\n\n            }\n\n        }\n\n    }\n\n    fix_opcode_tables(env->opcodes);\n\n    fflush(stdout);\n\n    fflush(stderr);\n\n\n\n    return 0;\n\n}\n", "idx": 26906}
{"project": "qemu", "commit_id": "ec5c3e487eb49100e6cb1b84e7f0bd022fbbf54b", "target": 0, "func": "static int mmu40x_get_physical_address (CPUState *env, mmu_ctx_t *ctx,\n\n                                 target_ulong address, int rw, int access_type)\n\n{\n\n    ppcemb_tlb_t *tlb;\n\n    target_phys_addr_t raddr;\n\n    int i, ret, zsel, zpr, pr;\n\n\n\n    ret = -1;\n\n    raddr = (target_phys_addr_t)-1ULL;\n\n    pr = msr_pr;\n\n    for (i = 0; i < env->nb_tlb; i++) {\n\n        tlb = &env->tlb[i].tlbe;\n\n        if (ppcemb_tlb_check(env, tlb, &raddr, address,\n\n                             env->spr[SPR_40x_PID], 0, i) < 0)\n\n            continue;\n\n        zsel = (tlb->attr >> 4) & 0xF;\n\n        zpr = (env->spr[SPR_40x_ZPR] >> (28 - (2 * zsel))) & 0x3;\n\n        LOG_SWTLB(\"%s: TLB %d zsel %d zpr %d rw %d attr %08x\\n\",\n\n                    __func__, i, zsel, zpr, rw, tlb->attr);\n\n        /* Check execute enable bit */\n\n        switch (zpr) {\n\n        case 0x2:\n\n            if (pr != 0)\n\n                goto check_perms;\n\n            /* No break here */\n\n        case 0x3:\n\n            /* All accesses granted */\n\n            ctx->prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n            ret = 0;\n\n            break;\n\n        case 0x0:\n\n            if (pr != 0) {\n\n                ctx->prot = 0;\n\n                ret = -2;\n\n                break;\n\n            }\n\n            /* No break here */\n\n        case 0x1:\n\n        check_perms:\n\n            /* Check from TLB entry */\n\n            /* XXX: there is a problem here or in the TLB fill code... */\n\n            ctx->prot = tlb->prot;\n\n            ctx->prot |= PAGE_EXEC;\n\n            ret = check_prot(ctx->prot, rw, access_type);\n\n            break;\n\n        }\n\n        if (ret >= 0) {\n\n            ctx->raddr = raddr;\n\n            LOG_SWTLB(\"%s: access granted \" TARGET_FMT_lx \" => \" TARGET_FMT_plx\n\n                      \" %d %d\\n\", __func__, address, ctx->raddr, ctx->prot,\n\n                      ret);\n\n            return 0;\n\n        }\n\n    }\n\n    LOG_SWTLB(\"%s: access refused \" TARGET_FMT_lx \" => \" TARGET_FMT_plx\n\n              \" %d %d\\n\", __func__, address, raddr, ctx->prot, ret);\n\n\n\n    return ret;\n\n}\n", "idx": 26907}
{"project": "qemu", "commit_id": "4fc9af53d88c0a2a810704a06cb39a7182982e4e", "target": 0, "func": "int bdrv_read(BlockDriverState *bs, int64_t sector_num,\n\n              uint8_t *buf, int nb_sectors)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n\n\n    if (sector_num == 0 && bs->boot_sector_enabled && nb_sectors > 0) {\n\n            memcpy(buf, bs->boot_sector_data, 512);\n\n        sector_num++;\n\n        nb_sectors--;\n\n        buf += 512;\n\n        if (nb_sectors == 0)\n\n            return 0;\n\n    }\n\n    if (drv->bdrv_pread) {\n\n        int ret, len;\n\n        len = nb_sectors * 512;\n\n        ret = drv->bdrv_pread(bs, sector_num * 512, buf, len);\n\n        if (ret < 0)\n\n            return ret;\n\n        else if (ret != len)\n\n            return -EINVAL;\n\n        else {\n\n\t    bs->rd_bytes += (unsigned) len;\n\n\t    bs->rd_ops ++;\n\n            return 0;\n\n\t}\n\n    } else {\n\n        return drv->bdrv_read(bs, sector_num, buf, nb_sectors);\n\n    }\n\n}\n", "idx": 26908}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "int socket_connect(SocketAddress *addr, Error **errp,\n\n                   NonBlockingConnectHandler *callback, void *opaque)\n\n{\n\n    int fd;\n\n\n\n    switch (addr->type) {\n\n    case SOCKET_ADDRESS_KIND_INET:\n\n        fd = inet_connect_saddr(addr->u.inet, errp, callback, opaque);\n\n        break;\n\n\n\n    case SOCKET_ADDRESS_KIND_UNIX:\n\n        fd = unix_connect_saddr(addr->u.q_unix, errp, callback, opaque);\n\n        break;\n\n\n\n    case SOCKET_ADDRESS_KIND_FD:\n\n        fd = monitor_get_fd(cur_mon, addr->u.fd->str, errp);\n\n        if (fd >= 0 && callback) {\n\n            qemu_set_nonblock(fd);\n\n            callback(fd, NULL, opaque);\n\n        }\n\n        break;\n\n\n\n    default:\n\n        abort();\n\n    }\n\n    return fd;\n\n}\n", "idx": 26909}
{"project": "qemu", "commit_id": "04097f7c5957273c578f72b9bd603ba6b1d69e33", "target": 1, "func": "static int vhost_client_sync_dirty_bitmap(CPUPhysMemoryClient *client,\n\n                                          target_phys_addr_t start_addr,\n\n                                          target_phys_addr_t end_addr)\n\n{\n\n    struct vhost_dev *dev = container_of(client, struct vhost_dev, client);\n\n    int i;\n\n    if (!dev->log_enabled || !dev->started) {\n\n        return 0;\n\n    }\n\n    for (i = 0; i < dev->mem->nregions; ++i) {\n\n        struct vhost_memory_region *reg = dev->mem->regions + i;\n\n        vhost_dev_sync_region(dev, start_addr, end_addr,\n\n                              reg->guest_phys_addr,\n\n                              range_get_last(reg->guest_phys_addr,\n\n                                             reg->memory_size));\n\n    }\n\n    for (i = 0; i < dev->nvqs; ++i) {\n\n        struct vhost_virtqueue *vq = dev->vqs + i;\n\n        vhost_dev_sync_region(dev, start_addr, end_addr, vq->used_phys,\n\n                              range_get_last(vq->used_phys, vq->used_size));\n\n    }\n\n    return 0;\n\n}\n", "idx": 26912}
{"project": "qemu", "commit_id": "ad2d30f79d3b0812f02c741be2189796b788d6d7", "target": 1, "func": "void scsi_req_free(SCSIRequest *req)\n\n{\n\n    scsi_req_dequeue(req);\n\n    qemu_free(req);\n\n}\n", "idx": 26914}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void qpci_memwrite(QPCIDevice *dev, void *data, const void *buf, size_t len)\n\n{\n\n    uintptr_t addr = (uintptr_t)data;\n\n\n\n    g_assert(addr >= QPCI_PIO_LIMIT);\n\n    dev->bus->memwrite(dev->bus, addr, buf, len);\n\n}\n", "idx": 26915}
{"project": "qemu", "commit_id": "1108b2f8a939fb5778d384149e2f1b99062a72da", "target": 1, "func": "e1000e_init_msi(E1000EState *s)\n\n{\n\n    int res;\n\n\n\n    res = msi_init(PCI_DEVICE(s),\n\n                   0xD0,   /* MSI capability offset              */\n\n                   1,      /* MAC MSI interrupts                 */\n\n                   true,   /* 64-bit message addresses supported */\n\n                   false); /* Per vector mask supported          */\n\n\n\n    if (res > 0) {\n\n        s->intr_state |= E1000E_USE_MSI;\n\n    } else {\n\n        trace_e1000e_msi_init_fail(res);\n\n    }\n\n}\n", "idx": 26916}
{"project": "qemu", "commit_id": "56439e9d55626b65ecb887f1ac3714652555312e", "target": 1, "func": "static coroutine_fn int qcow_co_readv(BlockDriverState *bs, int64_t sector_num,\n\n                         int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    int ret = 0, n;\n\n    uint64_t cluster_offset;\n\n    struct iovec hd_iov;\n\n    QEMUIOVector hd_qiov;\n\n    uint8_t *buf;\n\n    void *orig_buf;\n\n\n\n    if (qiov->niov > 1) {\n\n        buf = orig_buf = qemu_try_blockalign(bs, qiov->size);\n\n        if (buf == NULL) {\n\n            return -ENOMEM;\n\n        }\n\n    } else {\n\n        orig_buf = NULL;\n\n        buf = (uint8_t *)qiov->iov->iov_base;\n\n    }\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (nb_sectors != 0) {\n\n        /* prepare next request */\n\n        cluster_offset = get_cluster_offset(bs, sector_num << 9,\n\n                                                 0, 0, 0, 0);\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        n = s->cluster_sectors - index_in_cluster;\n\n        if (n > nb_sectors) {\n\n            n = nb_sectors;\n\n        }\n\n\n\n        if (!cluster_offset) {\n\n            if (bs->backing) {\n\n                /* read from the base image */\n\n                hd_iov.iov_base = (void *)buf;\n\n                hd_iov.iov_len = n * 512;\n\n                qemu_iovec_init_external(&hd_qiov, &hd_iov, 1);\n\n                qemu_co_mutex_unlock(&s->lock);\n\n                ret = bdrv_co_readv(bs->backing, sector_num, n, &hd_qiov);\n\n                qemu_co_mutex_lock(&s->lock);\n\n                if (ret < 0) {\n\n                    goto fail;\n\n                }\n\n            } else {\n\n                /* Note: in this case, no need to wait */\n\n                memset(buf, 0, 512 * n);\n\n            }\n\n        } else if (cluster_offset & QCOW_OFLAG_COMPRESSED) {\n\n            /* add AIO support for compressed blocks ? */\n\n            if (decompress_cluster(bs, cluster_offset) < 0) {\n\n                goto fail;\n\n            }\n\n            memcpy(buf,\n\n                   s->cluster_cache + index_in_cluster * 512, 512 * n);\n\n        } else {\n\n            if ((cluster_offset & 511) != 0) {\n\n                goto fail;\n\n            }\n\n            hd_iov.iov_base = (void *)buf;\n\n            hd_iov.iov_len = n * 512;\n\n            qemu_iovec_init_external(&hd_qiov, &hd_iov, 1);\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            ret = bdrv_co_readv(bs->file,\n\n                                (cluster_offset >> 9) + index_in_cluster,\n\n                                n, &hd_qiov);\n\n            qemu_co_mutex_lock(&s->lock);\n\n            if (ret < 0) {\n\n                break;\n\n            }\n\n            if (bs->encrypted) {\n\n                assert(s->crypto);\n\n                if (qcrypto_block_decrypt(s->crypto, sector_num, buf,\n\n                                          n * BDRV_SECTOR_SIZE, NULL) < 0) {\n\n                    goto fail;\n\n                }\n\n            }\n\n        }\n\n        ret = 0;\n\n\n\n        nb_sectors -= n;\n\n        sector_num += n;\n\n        buf += n * 512;\n\n    }\n\n\n\ndone:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    if (qiov->niov > 1) {\n\n        qemu_iovec_from_buf(qiov, 0, orig_buf, qiov->size);\n\n        qemu_vfree(orig_buf);\n\n    }\n\n\n\n    return ret;\n\n\n\nfail:\n\n    ret = -EIO;\n\n    goto done;\n\n}\n", "idx": 26918}
{"project": "qemu", "commit_id": "e0dadc1e9ef1f35208e5d2af9c7740c18a0b769f", "target": 1, "func": "static inline I2CBus *aux_bridge_get_i2c_bus(AUXTOI2CState *bridge)\n\n{\n\n    return bridge->i2c_bus;\n\n}\n", "idx": 26919}
{"project": "qemu", "commit_id": "33e66b86d89040f0a9e99aa53deb74ce8936a649", "target": 1, "func": "static int usb_host_auto_scan(void *opaque, int bus_num, int addr,\n\n                     int class_id, int vendor_id, int product_id,\n\n                     const char *product_name, int speed)\n\n{\n\n    struct USBAutoFilter *f;\n\n    struct USBDevice *dev;\n\n\n\n    /* Ignore hubs */\n\n    if (class_id == 9)\n\n        return 0;\n\n\n\n    for (f = usb_auto_filter; f; f = f->next) {\n\n\tif (f->bus_num >= 0 && f->bus_num != bus_num)\n\n            continue;\n\n\n\n\tif (f->addr >= 0 && f->addr != addr)\n\n            continue;\n\n\n\n\tif (f->vendor_id >= 0 && f->vendor_id != vendor_id)\n\n            continue;\n\n\n\n\tif (f->product_id >= 0 && f->product_id != product_id)\n\n            continue;\n\n\n\n        /* We got a match */\n\n\n\n        /* Allredy attached ? */\n\n        if (hostdev_find(bus_num, addr))\n\n            return 0;\n\n\n\n        dprintf(\"husb: auto open: bus_num %d addr %d\\n\", bus_num, addr);\n\n\n\n\tdev = usb_host_device_open_addr(bus_num, addr, product_name);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 26920}
{"project": "qemu", "commit_id": "6f2d8978728c48ca46f5c01835438508aace5c64", "target": 1, "func": "void do_POWER_divso (void)\n\n{\n\n    if (((int32_t)T0 == INT32_MIN && (int32_t)T1 == -1) || (int32_t)T1 == 0) {\n\n        T0 = (long)((-1) * (T0 >> 31));\n\n        env->spr[SPR_MQ] = 0;\n\n        xer_ov = 1;\n\n        xer_so = 1;\n\n    } else {\n\n        T0 = (int32_t)T0 / (int32_t)T1;\n\n        env->spr[SPR_MQ] = (int32_t)T0 % (int32_t)T1;\n\n        xer_ov = 0;\n\n    }\n\n}\n", "idx": 26924}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void add_migration_state_change_notifier(Notifier *notify)\n\n{\n\n    notifier_list_add(&migration_state_notifiers, notify);\n\n}\n", "idx": 26925}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void OPPROTO op_addco (void)\n\n{\n\n    do_addco();\n\n    RETURN();\n\n}\n", "idx": 26930}
{"project": "qemu", "commit_id": "e0e2d644096c79a71099b176d08f465f6803a8b1", "target": 1, "func": "static inline void vring_used_flags_set_bit(VirtQueue *vq, int mask)\n\n{\n\n    VRingMemoryRegionCaches *caches = atomic_rcu_read(&vq->vring.caches);\n\n    VirtIODevice *vdev = vq->vdev;\n\n    hwaddr pa = offsetof(VRingUsed, flags);\n\n    uint16_t flags = virtio_lduw_phys_cached(vq->vdev, &caches->used, pa);\n\n\n\n    virtio_stw_phys_cached(vdev, &caches->used, pa, flags | mask);\n\n    address_space_cache_invalidate(&caches->used, pa, sizeof(flags));\n\n}\n", "idx": 26931}
{"project": "qemu", "commit_id": "d832fb4d66ead62da4af7e44cce34cd939e865e1", "target": 1, "func": "static int iscsi_truncate(BlockDriverState *bs, int64_t offset)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    Error *local_err = NULL;\n\n\n\n    if (iscsilun->type != TYPE_DISK) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    iscsi_readcapacity_sync(iscsilun, &local_err);\n\n    if (local_err != NULL) {\n\n        error_free(local_err);\n\n        return -EIO;\n\n    }\n\n\n\n    if (offset > iscsi_getlength(bs)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (iscsilun->allocationmap != NULL) {\n\n        g_free(iscsilun->allocationmap);\n\n        iscsilun->allocationmap =\n\n            bitmap_new(DIV_ROUND_UP(bs->total_sectors,\n\n                                    iscsilun->cluster_sectors));\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 26932}
{"project": "qemu", "commit_id": "b7f43fe46029d8fd0594cd599fa2599dcce0f553", "target": 1, "func": "Object *object_dynamic_cast_assert(Object *obj, const char *typename)\n\n{\n\n    Object *inst;\n\n\n\n    inst = object_dynamic_cast(obj, typename);\n\n\n\n    if (!inst) {\n\n        fprintf(stderr, \"Object %p is not an instance of type %s\\n\",\n\n                obj, typename);\n\n        abort();\n\n    }\n\n\n\n    return inst;\n\n}\n", "idx": 26933}
{"project": "qemu", "commit_id": "6658ffb81ee56a510d7d77025872a508a9adce3a", "target": 1, "func": "static inline int gen_intermediate_code_internal(CPUState *env, \n\n                                                 TranslationBlock *tb, \n\n                                                 int search_pc)\n\n{\n\n    DisasContext dc1, *dc = &dc1;\n\n    uint16_t *gen_opc_end;\n\n    int j, lj;\n\n    target_ulong pc_start;\n\n    uint32_t next_page_start;\n\n    \n\n    /* generate intermediate code */\n\n    pc_start = tb->pc;\n\n       \n\n    dc->tb = tb;\n\n\n\n    gen_opc_ptr = gen_opc_buf;\n\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n    gen_opparam_ptr = gen_opparam_buf;\n\n\n\n    dc->is_jmp = DISAS_NEXT;\n\n    dc->pc = pc_start;\n\n    dc->singlestep_enabled = env->singlestep_enabled;\n\n    dc->condjmp = 0;\n\n    dc->thumb = env->thumb;\n\n\n#if !defined(CONFIG_USER_ONLY)\n\n    dc->user = (env->uncached_cpsr & 0x1f) == ARM_CPU_MODE_USR;\n\n#endif\n\n    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n\n    nb_gen_labels = 0;\n\n    lj = -1;\n\n    do {\n\n        if (env->nb_breakpoints > 0) {\n\n            for(j = 0; j < env->nb_breakpoints; j++) {\n\n                if (env->breakpoints[j] == dc->pc) {\n\n                    gen_op_movl_T0_im((long)dc->pc);\n\n                    gen_op_movl_reg_TN[0][15]();\n\n                    gen_op_debug();\n\n                    dc->is_jmp = DISAS_JUMP;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (search_pc) {\n\n            j = gen_opc_ptr - gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    gen_opc_instr_start[lj++] = 0;\n\n            }\n\n            gen_opc_pc[lj] = dc->pc;\n\n            gen_opc_instr_start[lj] = 1;\n\n        }\n\n\n\n        if (env->thumb)\n\n          disas_thumb_insn(dc);\n\n        else\n\n          disas_arm_insn(env, dc);\n\n\n\n        if (dc->condjmp && !dc->is_jmp) {\n\n            gen_set_label(dc->condlabel);\n\n            dc->condjmp = 0;\n\n        }\n\n        /* Terminate the TB on memory ops if watchpoints are present.  */\n\n        /* FIXME: This should be replacd by the deterministic execution\n\n         * IRQ raising bits.  */\n\n        if (dc->is_mem && env->nb_watchpoints)\n\n            break;\n\n\n\n        /* Translation stops when a conditional branch is enoutered.\n\n         * Otherwise the subsequent code could get translated several times.\n\n         * Also stop translation when a page boundary is reached.  This\n\n         * ensures prefech aborts occur at the right place.  */\n\n    } while (!dc->is_jmp && gen_opc_ptr < gen_opc_end &&\n\n             !env->singlestep_enabled &&\n\n             dc->pc < next_page_start);\n\n    /* At this stage dc->condjmp will only be set when the skipped\n\n     * instruction was a conditional branch, and the PC has already been\n\n     * written.  */\n\n    if (__builtin_expect(env->singlestep_enabled, 0)) {\n\n        /* Make sure the pc is updated, and raise a debug exception.  */\n\n        if (dc->condjmp) {\n\n            gen_op_debug();\n\n            gen_set_label(dc->condlabel);\n\n        }\n\n        if (dc->condjmp || !dc->is_jmp) {\n\n            gen_op_movl_T0_im((long)dc->pc);\n\n            gen_op_movl_reg_TN[0][15]();\n\n            dc->condjmp = 0;\n\n        }\n\n        gen_op_debug();\n\n    } else {\n\n        switch(dc->is_jmp) {\n\n        case DISAS_NEXT:\n\n            gen_goto_tb(dc, 1, dc->pc);\n\n            break;\n\n        default:\n\n        case DISAS_JUMP:\n\n        case DISAS_UPDATE:\n\n            /* indicate that the hash table must be used to find the next TB */\n\n            gen_op_movl_T0_0();\n\n            gen_op_exit_tb();\n\n            break;\n\n        case DISAS_TB_JUMP:\n\n            /* nothing more to generate */\n\n            break;\n\n        }\n\n        if (dc->condjmp) {\n\n            gen_set_label(dc->condlabel);\n\n            gen_goto_tb(dc, 1, dc->pc);\n\n            dc->condjmp = 0;\n\n        }\n\n    }\n\n    *gen_opc_ptr = INDEX_op_end;\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n        fprintf(logfile, \"----------------\\n\");\n\n        fprintf(logfile, \"IN: %s\\n\", lookup_symbol(pc_start));\n\n        target_disas(logfile, pc_start, dc->pc - pc_start, env->thumb);\n\n        fprintf(logfile, \"\\n\");\n\n        if (loglevel & (CPU_LOG_TB_OP)) {\n\n            fprintf(logfile, \"OP:\\n\");\n\n            dump_ops(gen_opc_buf, gen_opparam_buf);\n\n            fprintf(logfile, \"\\n\");\n\n        }\n\n    }\n\n#endif\n\n    if (search_pc) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n        tb->size = 0;\n\n    } else {\n\n        tb->size = dc->pc - pc_start;\n\n    }\n\n    return 0;\n\n}", "idx": 26934}
{"project": "qemu", "commit_id": "7b62a955047934bab158e84ecb63cb432c193ace", "target": 1, "func": "void ppc970_irq_init (CPUState *env)\n\n{\n\n    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env, 7);\n\n}\n", "idx": 26935}
{"project": "qemu", "commit_id": "ac531cb6e542b1e61d668604adf9dc5306a948c0", "target": 0, "func": "START_TEST(qdict_del_test)\n\n{\n\n    const char *key = \"key test\";\n\n\n\n    qdict_put(tests_dict, key, qstring_from_str(\"foo\"));\n\n    fail_unless(qdict_size(tests_dict) == 1);\n\n\n\n    qdict_del(tests_dict, key);\n\n\n\n    fail_unless(qdict_size(tests_dict) == 0);\n\n    fail_unless(qdict_haskey(tests_dict, key) == 0);\n\n}\n", "idx": 26937}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void spawn_thread(ThreadPool *pool)\n\n{\n\n    pool->cur_threads++;\n\n    pool->new_threads++;\n\n    /* If there are threads being created, they will spawn new workers, so\n\n     * we don't spend time creating many threads in a loop holding a mutex or\n\n     * starving the current vcpu.\n\n     *\n\n     * If there are no idle threads, ask the main thread to create one, so we\n\n     * inherit the correct affinity instead of the vcpu affinity.\n\n     */\n\n    if (!pool->pending_threads) {\n\n        qemu_bh_schedule(pool->new_thread_bh);\n\n    }\n\n}\n", "idx": 26938}
{"project": "qemu", "commit_id": "bf7aa45e7b378691ea0e8616a2aeae2aaabb7bc3", "target": 0, "func": "static void vnc_display_close(VncDisplay *vs)\n\n{\n\n    if (!vs)\n\n        return;\n\n    g_free(vs->display);\n\n    vs->display = NULL;\n\n    if (vs->lsock != -1) {\n\n        qemu_set_fd_handler2(vs->lsock, NULL, NULL, NULL, NULL);\n\n        close(vs->lsock);\n\n        vs->lsock = -1;\n\n    }\n\n#ifdef CONFIG_VNC_WS\n\n    g_free(vs->ws_display);\n\n    vs->ws_display = NULL;\n\n    if (vs->lwebsock != -1) {\n\n        qemu_set_fd_handler2(vs->lwebsock, NULL, NULL, NULL, NULL);\n\n        close(vs->lwebsock);\n\n        vs->lwebsock = -1;\n\n    }\n\n#endif /* CONFIG_VNC_WS */\n\n    vs->auth = VNC_AUTH_INVALID;\n\n#ifdef CONFIG_VNC_TLS\n\n    vs->subauth = VNC_AUTH_INVALID;\n\n    vs->tls.x509verify = 0;\n\n#endif\n\n}\n", "idx": 26939}
{"project": "qemu", "commit_id": "de13d2161473d02ae97ec0f8e4503147554892dd", "target": 0, "func": "void kvm_s390_crw_mchk(S390CPU *cpu)\n\n{\n\n    kvm_s390_interrupt_internal(cpu, KVM_S390_MCHK, 1 << 28,\n\n                                0x00400f1d40330000, 1);\n\n}\n", "idx": 26940}
{"project": "qemu", "commit_id": "1110bfe6f5600017258fa6578f9c17ec25b32277", "target": 0, "func": "static void do_interrupt_protected(CPUX86State *env, int intno, int is_int,\n\n                                   int error_code, unsigned int next_eip,\n\n                                   int is_hw)\n\n{\n\n    SegmentCache *dt;\n\n    target_ulong ptr, ssp;\n\n    int type, dpl, selector, ss_dpl, cpl;\n\n    int has_error_code, new_stack, shift;\n\n    uint32_t e1, e2, offset, ss = 0, esp, ss_e1 = 0, ss_e2 = 0;\n\n    uint32_t old_eip, sp_mask;\n\n    int vm86 = env->eflags & VM_MASK;\n\n\n\n    has_error_code = 0;\n\n    if (!is_int && !is_hw) {\n\n        has_error_code = exception_has_error_code(intno);\n\n    }\n\n    if (is_int) {\n\n        old_eip = next_eip;\n\n    } else {\n\n        old_eip = env->eip;\n\n    }\n\n\n\n    dt = &env->idt;\n\n    if (intno * 8 + 7 > dt->limit) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);\n\n    }\n\n    ptr = dt->base + intno * 8;\n\n    e1 = cpu_ldl_kernel(env, ptr);\n\n    e2 = cpu_ldl_kernel(env, ptr + 4);\n\n    /* check gate type */\n\n    type = (e2 >> DESC_TYPE_SHIFT) & 0x1f;\n\n    switch (type) {\n\n    case 5: /* task gate */\n\n        /* must do that check here to return the correct error code */\n\n        if (!(e2 & DESC_P_MASK)) {\n\n            raise_exception_err(env, EXCP0B_NOSEG, intno * 8 + 2);\n\n        }\n\n        switch_tss(env, intno * 8, e1, e2, SWITCH_TSS_CALL, old_eip);\n\n        if (has_error_code) {\n\n            int type;\n\n            uint32_t mask;\n\n\n\n            /* push the error code */\n\n            type = (env->tr.flags >> DESC_TYPE_SHIFT) & 0xf;\n\n            shift = type >> 3;\n\n            if (env->segs[R_SS].flags & DESC_B_MASK) {\n\n                mask = 0xffffffff;\n\n            } else {\n\n                mask = 0xffff;\n\n            }\n\n            esp = (env->regs[R_ESP] - (2 << shift)) & mask;\n\n            ssp = env->segs[R_SS].base + esp;\n\n            if (shift) {\n\n                cpu_stl_kernel(env, ssp, error_code);\n\n            } else {\n\n                cpu_stw_kernel(env, ssp, error_code);\n\n            }\n\n            SET_ESP(esp, mask);\n\n        }\n\n        return;\n\n    case 6: /* 286 interrupt gate */\n\n    case 7: /* 286 trap gate */\n\n    case 14: /* 386 interrupt gate */\n\n    case 15: /* 386 trap gate */\n\n        break;\n\n    default:\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);\n\n        break;\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    cpl = env->hflags & HF_CPL_MASK;\n\n    /* check privilege if software int */\n\n    if (is_int && dpl < cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);\n\n    }\n\n    /* check valid bit */\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, intno * 8 + 2);\n\n    }\n\n    selector = e1 >> 16;\n\n    offset = (e2 & 0xffff0000) | (e1 & 0x0000ffff);\n\n    if ((selector & 0xfffc) == 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, 0);\n\n    }\n\n    if (load_segment(env, &e1, &e2, selector) != 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    if (dpl > cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_C_MASK) && dpl < cpl) {\n\n        /* to inner privilege */\n\n        get_ss_esp_from_tss(env, &ss, &esp, dpl, 0);\n\n        if ((ss & 0xfffc) == 0) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if ((ss & 3) != dpl) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if (load_segment(env, &ss_e1, &ss_e2, ss) != 0) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        ss_dpl = (ss_e2 >> DESC_DPL_SHIFT) & 3;\n\n        if (ss_dpl != dpl) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if (!(ss_e2 & DESC_S_MASK) ||\n\n            (ss_e2 & DESC_CS_MASK) ||\n\n            !(ss_e2 & DESC_W_MASK)) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if (!(ss_e2 & DESC_P_MASK)) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        new_stack = 1;\n\n        sp_mask = get_sp_mask(ss_e2);\n\n        ssp = get_seg_base(ss_e1, ss_e2);\n\n    } else if ((e2 & DESC_C_MASK) || dpl == cpl) {\n\n        /* to same privilege */\n\n        if (vm86) {\n\n            raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        }\n\n        new_stack = 0;\n\n        sp_mask = get_sp_mask(env->segs[R_SS].flags);\n\n        ssp = env->segs[R_SS].base;\n\n        esp = env->regs[R_ESP];\n\n        dpl = cpl;\n\n    } else {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        new_stack = 0; /* avoid warning */\n\n        sp_mask = 0; /* avoid warning */\n\n        ssp = 0; /* avoid warning */\n\n        esp = 0; /* avoid warning */\n\n    }\n\n\n\n    shift = type >> 3;\n\n\n\n#if 0\n\n    /* XXX: check that enough room is available */\n\n    push_size = 6 + (new_stack << 2) + (has_error_code << 1);\n\n    if (vm86) {\n\n        push_size += 8;\n\n    }\n\n    push_size <<= shift;\n\n#endif\n\n    if (shift == 1) {\n\n        if (new_stack) {\n\n            if (vm86) {\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_GS].selector);\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_FS].selector);\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_DS].selector);\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_ES].selector);\n\n            }\n\n            PUSHL(ssp, esp, sp_mask, env->segs[R_SS].selector);\n\n            PUSHL(ssp, esp, sp_mask, env->regs[R_ESP]);\n\n        }\n\n        PUSHL(ssp, esp, sp_mask, cpu_compute_eflags(env));\n\n        PUSHL(ssp, esp, sp_mask, env->segs[R_CS].selector);\n\n        PUSHL(ssp, esp, sp_mask, old_eip);\n\n        if (has_error_code) {\n\n            PUSHL(ssp, esp, sp_mask, error_code);\n\n        }\n\n    } else {\n\n        if (new_stack) {\n\n            if (vm86) {\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_GS].selector);\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_FS].selector);\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_DS].selector);\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_ES].selector);\n\n            }\n\n            PUSHW(ssp, esp, sp_mask, env->segs[R_SS].selector);\n\n            PUSHW(ssp, esp, sp_mask, env->regs[R_ESP]);\n\n        }\n\n        PUSHW(ssp, esp, sp_mask, cpu_compute_eflags(env));\n\n        PUSHW(ssp, esp, sp_mask, env->segs[R_CS].selector);\n\n        PUSHW(ssp, esp, sp_mask, old_eip);\n\n        if (has_error_code) {\n\n            PUSHW(ssp, esp, sp_mask, error_code);\n\n        }\n\n    }\n\n\n\n    /* interrupt gate clear IF mask */\n\n    if ((type & 1) == 0) {\n\n        env->eflags &= ~IF_MASK;\n\n    }\n\n    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);\n\n\n\n    if (new_stack) {\n\n        if (vm86) {\n\n            cpu_x86_load_seg_cache(env, R_ES, 0, 0, 0, 0);\n\n            cpu_x86_load_seg_cache(env, R_DS, 0, 0, 0, 0);\n\n            cpu_x86_load_seg_cache(env, R_FS, 0, 0, 0, 0);\n\n            cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0, 0);\n\n        }\n\n        ss = (ss & ~3) | dpl;\n\n        cpu_x86_load_seg_cache(env, R_SS, ss,\n\n                               ssp, get_seg_limit(ss_e1, ss_e2), ss_e2);\n\n    }\n\n    SET_ESP(esp, sp_mask);\n\n\n\n    selector = (selector & ~3) | dpl;\n\n    cpu_x86_load_seg_cache(env, R_CS, selector,\n\n                   get_seg_base(e1, e2),\n\n                   get_seg_limit(e1, e2),\n\n                   e2);\n\n    env->eip = offset;\n\n}\n", "idx": 26941}
{"project": "qemu", "commit_id": "9e41bade85ef338afd983c109368d1bbbe931f80", "target": 0, "func": "static int pxa2xx_i2c_slave_init(I2CSlave *i2c)\n\n{\n\n    /* Nothing to do.  */\n\n    return 0;\n\n}\n", "idx": 26942}
{"project": "qemu", "commit_id": "5861a33898bbddfd1a80c2e202cb9352e3b1ba62", "target": 0, "func": "static void openpic_cpu_write_internal(void *opaque, hwaddr addr,\n\n                                       uint32_t val, int idx)\n\n{\n\n    openpic_t *opp = opaque;\n\n    IRQ_src_t *src;\n\n    IRQ_dst_t *dst;\n\n    int s_IRQ, n_IRQ;\n\n\n\n    DPRINTF(\"%s: cpu %d addr \" TARGET_FMT_plx \" <= %08x\\n\", __func__, idx,\n\n            addr, val);\n\n    if (addr & 0xF)\n\n        return;\n\n    dst = &opp->dst[idx];\n\n    addr &= 0xFF0;\n\n    switch (addr) {\n\n    case 0x40: /* IPIDR */\n\n    case 0x50:\n\n    case 0x60:\n\n    case 0x70:\n\n        idx = (addr - 0x40) >> 4;\n\n        /* we use IDE as mask which CPUs to deliver the IPI to still. */\n\n        write_IRQreg_ide(opp, opp->irq_ipi0 + idx,\n\n                         opp->src[opp->irq_ipi0 + idx].ide | val);\n\n        openpic_set_irq(opp, opp->irq_ipi0 + idx, 1);\n\n        openpic_set_irq(opp, opp->irq_ipi0 + idx, 0);\n\n        break;\n\n    case 0x80: /* PCTP */\n\n        dst->pctp = val & 0x0000000F;\n\n        break;\n\n    case 0x90: /* WHOAMI */\n\n        /* Read-only register */\n\n        break;\n\n    case 0xA0: /* PIAC */\n\n        /* Read-only register */\n\n        break;\n\n    case 0xB0: /* PEOI */\n\n        DPRINTF(\"PEOI\\n\");\n\n        s_IRQ = IRQ_get_next(opp, &dst->servicing);\n\n        IRQ_resetbit(&dst->servicing, s_IRQ);\n\n        dst->servicing.next = -1;\n\n        /* Set up next servicing IRQ */\n\n        s_IRQ = IRQ_get_next(opp, &dst->servicing);\n\n        /* Check queued interrupts. */\n\n        n_IRQ = IRQ_get_next(opp, &dst->raised);\n\n        src = &opp->src[n_IRQ];\n\n        if (n_IRQ != -1 &&\n\n            (s_IRQ == -1 ||\n\n             IPVP_PRIORITY(src->ipvp) > dst->servicing.priority)) {\n\n            DPRINTF(\"Raise OpenPIC INT output cpu %d irq %d\\n\",\n\n                    idx, n_IRQ);\n\n            opp->irq_raise(opp, idx, src);\n\n        }\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 26943}
{"project": "qemu", "commit_id": "64a31d5c3d73396a88563d7a504654edc85aa854", "target": 0, "func": "static inline int dmg_read_chunk(BDRVDMGState *s,int sector_num)\n\n{\n\n    if(!is_sector_in_chunk(s,s->current_chunk,sector_num)) {\n\n\tint ret;\n\n\tuint32_t chunk = search_chunk(s,sector_num);\n\n\n\n\tif(chunk>=s->n_chunks)\n\n\t    return -1;\n\n\n\n\ts->current_chunk = s->n_chunks;\n\n\tswitch(s->types[chunk]) {\n\n\tcase 0x80000005: { /* zlib compressed */\n\n\t    int i;\n\n\n\n\t    /* we need to buffer, because only the chunk as whole can be\n\n\t     * inflated. */\n\n\t    i=0;\n\n\t    do {\n\n\t\tret = pread(s->fd, s->compressed_chunk+i, s->lengths[chunk]-i,\n\n                            s->offsets[chunk] + i);\n\n\t\tif(ret<0 && errno==EINTR)\n\n\t\t    ret=0;\n\n\t\ti+=ret;\n\n\t    } while(ret>=0 && ret+i<s->lengths[chunk]);\n\n\n\n\t    if (ret != s->lengths[chunk])\n\n\t\treturn -1;\n\n\n\n\t    s->zstream.next_in = s->compressed_chunk;\n\n\t    s->zstream.avail_in = s->lengths[chunk];\n\n\t    s->zstream.next_out = s->uncompressed_chunk;\n\n\t    s->zstream.avail_out = 512*s->sectorcounts[chunk];\n\n\t    ret = inflateReset(&s->zstream);\n\n\t    if(ret != Z_OK)\n\n\t\treturn -1;\n\n\t    ret = inflate(&s->zstream, Z_FINISH);\n\n\t    if(ret != Z_STREAM_END || s->zstream.total_out != 512*s->sectorcounts[chunk])\n\n\t\treturn -1;\n\n\t    break; }\n\n\tcase 1: /* copy */\n\n\t    ret = pread(s->fd, s->uncompressed_chunk, s->lengths[chunk],\n\n                        s->offsets[chunk]);\n\n\t    if (ret != s->lengths[chunk])\n\n\t\treturn -1;\n\n\t    break;\n\n\tcase 2: /* zero */\n\n\t    memset(s->uncompressed_chunk, 0, 512*s->sectorcounts[chunk]);\n\n\t    break;\n\n\t}\n\n\ts->current_chunk = chunk;\n\n    }\n\n    return 0;\n\n}\n", "idx": 26944}
{"project": "qemu", "commit_id": "7e97cd88148876bad36ee7c66d526dcaed328d0d", "target": 0, "func": "static void kvm_start_vcpu(CPUState *env)\n\n{\n\n    env->thread = qemu_mallocz(sizeof(QemuThread));\n\n    env->halt_cond = qemu_mallocz(sizeof(QemuCond));\n\n    qemu_cond_init(env->halt_cond);\n\n    qemu_thread_create(env->thread, kvm_cpu_thread_fn, env);\n\n    while (env->created == 0)\n\n        qemu_cond_timedwait(&qemu_cpu_cond, &qemu_global_mutex, 100);\n\n}\n", "idx": 26945}
{"project": "qemu", "commit_id": "c18ad9a54b75495ce61e8b28d353f8eec51768fc", "target": 0, "func": "static hwaddr ppc_hash64_pteg_search(PowerPCCPU *cpu, hwaddr hash,\n\n                                     bool secondary, target_ulong ptem,\n\n                                     ppc_hash_pte64_t *pte)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    int i;\n\n    uint64_t token;\n\n    target_ulong pte0, pte1;\n\n    target_ulong pte_index;\n\n\n\n    pte_index = (hash & env->htab_mask) * HPTES_PER_GROUP;\n\n    token = ppc_hash64_start_access(cpu, pte_index);\n\n    if (!token) {\n\n        return -1;\n\n    }\n\n    for (i = 0; i < HPTES_PER_GROUP; i++) {\n\n        pte0 = ppc_hash64_load_hpte0(cpu, token, i);\n\n        pte1 = ppc_hash64_load_hpte1(cpu, token, i);\n\n\n\n        if ((pte0 & HPTE64_V_VALID)\n\n            && (secondary == !!(pte0 & HPTE64_V_SECONDARY))\n\n            && HPTE64_V_COMPARE(pte0, ptem)) {\n\n            pte->pte0 = pte0;\n\n            pte->pte1 = pte1;\n\n            ppc_hash64_stop_access(token);\n\n            return (pte_index + i) * HASH_PTE_SIZE_64;\n\n        }\n\n    }\n\n    ppc_hash64_stop_access(token);\n\n    /*\n\n     * We didn't find a valid entry.\n\n     */\n\n    return -1;\n\n}\n", "idx": 26946}
{"project": "qemu", "commit_id": "c021f8e65f5009a5ab5711d9d5326fcab553ef1c", "target": 0, "func": "static QObject *pci_get_dev_dict(PCIDevice *dev, PCIBus *bus, int bus_num)\n\n{\n\n    int class;\n\n    QObject *obj;\n\n\n\n    obj = qobject_from_jsonf(\"{ 'bus': %d, 'slot': %d, 'function': %d,\"                                       \"'class_info': %p, 'id': %p, 'regions': %p,\"\n\n                              \" 'qdev_id': %s }\",\n\n                              bus_num,\n\n                              PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn),\n\n                              pci_get_dev_class(dev), pci_get_dev_id(dev),\n\n                              pci_get_regions_list(dev),\n\n                              dev->qdev.id ? dev->qdev.id : \"\");\n\n\n\n    if (dev->config[PCI_INTERRUPT_PIN] != 0) {\n\n        QDict *qdict = qobject_to_qdict(obj);\n\n        qdict_put(qdict, \"irq\", qint_from_int(dev->config[PCI_INTERRUPT_LINE]));\n\n    }\n\n\n\n    class = pci_get_word(dev->config + PCI_CLASS_DEVICE);\n\n    if (class == 0x0604) {\n\n        QDict *qdict;\n\n        QObject *pci_bridge;\n\n\n\n        pci_bridge = qobject_from_jsonf(\"{ 'bus': \"\n\n        \"{ 'number': %d, 'secondary': %d, 'subordinate': %d }, \"\n\n        \"'io_range': { 'base': %\" PRId64 \", 'limit': %\" PRId64 \"}, \"\n\n        \"'memory_range': { 'base': %\" PRId64 \", 'limit': %\" PRId64 \"}, \"\n\n        \"'prefetchable_range': { 'base': %\" PRId64 \", 'limit': %\" PRId64 \"} }\",\n\n        dev->config[0x19], dev->config[PCI_SECONDARY_BUS],\n\n        dev->config[PCI_SUBORDINATE_BUS],\n\n        pci_bridge_get_base(dev, PCI_BASE_ADDRESS_SPACE_IO),\n\n        pci_bridge_get_limit(dev, PCI_BASE_ADDRESS_SPACE_IO),\n\n        pci_bridge_get_base(dev, PCI_BASE_ADDRESS_SPACE_MEMORY),\n\n        pci_bridge_get_limit(dev, PCI_BASE_ADDRESS_SPACE_MEMORY),\n\n        pci_bridge_get_base(dev, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                               PCI_BASE_ADDRESS_MEM_PREFETCH),\n\n        pci_bridge_get_limit(dev, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                PCI_BASE_ADDRESS_MEM_PREFETCH));\n\n\n\n        if (dev->config[0x19] != 0) {\n\n            qdict = qobject_to_qdict(pci_bridge);\n\n            qdict_put_obj(qdict, \"devices\",\n\n                          pci_get_devices_list(bus, dev->config[0x19]));\n\n        }\n\n\n\n        qdict = qobject_to_qdict(obj);\n\n        qdict_put_obj(qdict, \"pci_bridge\", pci_bridge);\n\n    }\n\n\n\n    return obj;\n\n}\n", "idx": 26948}
{"project": "qemu", "commit_id": "b8c18e4c901edae8cc14c07baa36f852be1f1ad0", "target": 0, "func": "static void vga_draw_graphic(VGAState *s, int full_update)\n\n{\n\n    int y1, y, update, page_min, page_max, linesize, y_start, double_scan, mask, depth;\n\n    int width, height, shift_control, line_offset, page0, page1, bwidth, bits;\n\n    int disp_width, multi_scan, multi_run;\n\n    uint8_t *d;\n\n    uint32_t v, addr1, addr;\n\n    vga_draw_line_func *vga_draw_line;\n\n\n\n    full_update |= update_basic_params(s);\n\n\n\n    if (!full_update)\n\n        vga_sync_dirty_bitmap(s);\n\n\n\n    s->get_resolution(s, &width, &height);\n\n    disp_width = width;\n\n\n\n    shift_control = (s->gr[0x05] >> 5) & 3;\n\n    double_scan = (s->cr[0x09] >> 7);\n\n    if (shift_control != 1) {\n\n        multi_scan = (((s->cr[0x09] & 0x1f) + 1) << double_scan) - 1;\n\n    } else {\n\n        /* in CGA modes, multi_scan is ignored */\n\n        /* XXX: is it correct ? */\n\n        multi_scan = double_scan;\n\n    }\n\n    multi_run = multi_scan;\n\n    if (shift_control != s->shift_control ||\n\n        double_scan != s->double_scan) {\n\n        full_update = 1;\n\n        s->shift_control = shift_control;\n\n        s->double_scan = double_scan;\n\n    }\n\n\n\n    depth = s->get_bpp(s);\n\n    if (s->line_offset != s->last_line_offset ||\n\n        disp_width != s->last_width ||\n\n        height != s->last_height ||\n\n        s->last_depth != depth) {\n\n#if defined(WORDS_BIGENDIAN) == defined(TARGET_WORDS_BIGENDIAN)\n\n        if (depth == 16 || depth == 32) {\n\n#else\n\n        if (depth == 32) {\n\n#endif\n\n            if (is_graphic_console()) {\n\n                qemu_free_displaysurface(s->ds);\n\n                s->ds->surface = qemu_create_displaysurface_from(disp_width, height, depth,\n\n                                                               s->line_offset,\n\n                                                               s->vram_ptr + (s->start_addr * 4));\n\n#if defined(WORDS_BIGENDIAN) != defined(TARGET_WORDS_BIGENDIAN)\n\n                s->ds->surface->pf = qemu_different_endianness_pixelformat(depth);\n\n#endif\n\n                dpy_resize(s->ds);\n\n            } else {\n\n                qemu_console_resize(s->ds, disp_width, height);\n\n            }\n\n        } else {\n\n            qemu_console_resize(s->ds, disp_width, height);\n\n        }\n\n        s->last_scr_width = disp_width;\n\n        s->last_scr_height = height;\n\n        s->last_width = disp_width;\n\n        s->last_height = height;\n\n        s->last_line_offset = s->line_offset;\n\n        s->last_depth = depth;\n\n        full_update = 1;\n\n    } else if (is_graphic_console() && is_buffer_shared(s->ds->surface) &&\n\n               (full_update || s->ds->surface->data != s->vram_ptr + (s->start_addr * 4))) {\n\n        s->ds->surface->data = s->vram_ptr + (s->start_addr * 4);\n\n        dpy_setdata(s->ds);\n\n    }\n\n\n\n    s->rgb_to_pixel =\n\n        rgb_to_pixel_dup_table[get_depth_index(s->ds)];\n\n\n\n    if (shift_control == 0) {\n\n        full_update |= update_palette16(s);\n\n        if (s->sr[0x01] & 8) {\n\n            v = VGA_DRAW_LINE4D2;\n\n            disp_width <<= 1;\n\n        } else {\n\n            v = VGA_DRAW_LINE4;\n\n        }\n\n        bits = 4;\n\n    } else if (shift_control == 1) {\n\n        full_update |= update_palette16(s);\n\n        if (s->sr[0x01] & 8) {\n\n            v = VGA_DRAW_LINE2D2;\n\n            disp_width <<= 1;\n\n        } else {\n\n            v = VGA_DRAW_LINE2;\n\n        }\n\n        bits = 4;\n\n    } else {\n\n        switch(s->get_bpp(s)) {\n\n        default:\n\n        case 0:\n\n            full_update |= update_palette256(s);\n\n            v = VGA_DRAW_LINE8D2;\n\n            bits = 4;\n\n            break;\n\n        case 8:\n\n            full_update |= update_palette256(s);\n\n            v = VGA_DRAW_LINE8;\n\n            bits = 8;\n\n            break;\n\n        case 15:\n\n            v = VGA_DRAW_LINE15;\n\n            bits = 16;\n\n            break;\n\n        case 16:\n\n            v = VGA_DRAW_LINE16;\n\n            bits = 16;\n\n            break;\n\n        case 24:\n\n            v = VGA_DRAW_LINE24;\n\n            bits = 24;\n\n            break;\n\n        case 32:\n\n            v = VGA_DRAW_LINE32;\n\n            bits = 32;\n\n            break;\n\n        }\n\n    }\n\n    vga_draw_line = vga_draw_line_table[v * NB_DEPTHS + get_depth_index(s->ds)];\n\n\n\n    if (!is_buffer_shared(s->ds->surface) && s->cursor_invalidate)\n\n        s->cursor_invalidate(s);\n\n\n\n    line_offset = s->line_offset;\n\n#if 0\n\n    printf(\"w=%d h=%d v=%d line_offset=%d cr[0x09]=0x%02x cr[0x17]=0x%02x linecmp=%d sr[0x01]=0x%02x\\n\",\n\n           width, height, v, line_offset, s->cr[9], s->cr[0x17], s->line_compare, s->sr[0x01]);\n\n#endif\n\n    addr1 = (s->start_addr * 4);\n\n    bwidth = (width * bits + 7) / 8;\n\n    y_start = -1;\n\n    page_min = 0x7fffffff;\n\n    page_max = -1;\n\n    d = ds_get_data(s->ds);\n\n    linesize = ds_get_linesize(s->ds);\n\n    y1 = 0;\n\n    for(y = 0; y < height; y++) {\n\n        addr = addr1;\n\n        if (!(s->cr[0x17] & 1)) {\n\n            int shift;\n\n            /* CGA compatibility handling */\n\n            shift = 14 + ((s->cr[0x17] >> 6) & 1);\n\n            addr = (addr & ~(1 << shift)) | ((y1 & 1) << shift);\n\n        }\n\n        if (!(s->cr[0x17] & 2)) {\n\n            addr = (addr & ~0x8000) | ((y1 & 2) << 14);\n\n        }\n\n        page0 = s->vram_offset + (addr & TARGET_PAGE_MASK);\n\n        page1 = s->vram_offset + ((addr + bwidth - 1) & TARGET_PAGE_MASK);\n\n        update = full_update |\n\n            cpu_physical_memory_get_dirty(page0, VGA_DIRTY_FLAG) |\n\n            cpu_physical_memory_get_dirty(page1, VGA_DIRTY_FLAG);\n\n        if ((page1 - page0) > TARGET_PAGE_SIZE) {\n\n            /* if wide line, can use another page */\n\n            update |= cpu_physical_memory_get_dirty(page0 + TARGET_PAGE_SIZE,\n\n                                                    VGA_DIRTY_FLAG);\n\n        }\n\n        /* explicit invalidation for the hardware cursor */\n\n        update |= (s->invalidated_y_table[y >> 5] >> (y & 0x1f)) & 1;\n\n        if (update) {\n\n            if (y_start < 0)\n\n                y_start = y;\n\n            if (page0 < page_min)\n\n                page_min = page0;\n\n            if (page1 > page_max)\n\n                page_max = page1;\n\n            if (!(is_buffer_shared(s->ds->surface))) {\n\n                vga_draw_line(s, d, s->vram_ptr + addr, width);\n\n                if (s->cursor_draw_line)\n\n                    s->cursor_draw_line(s, d, y);\n\n            }\n\n        } else {\n\n            if (y_start >= 0) {\n\n                /* flush to display */\n\n                dpy_update(s->ds, 0, y_start,\n\n                           disp_width, y - y_start);\n\n                y_start = -1;\n\n            }\n\n        }\n\n        if (!multi_run) {\n\n            mask = (s->cr[0x17] & 3) ^ 3;\n\n            if ((y1 & mask) == mask)\n\n                addr1 += line_offset;\n\n            y1++;\n\n            multi_run = multi_scan;\n\n        } else {\n\n            multi_run--;\n\n        }\n\n        /* line compare acts on the displayed lines */\n\n        if (y == s->line_compare)\n\n            addr1 = 0;\n\n        d += linesize;\n\n    }\n\n    if (y_start >= 0) {\n\n        /* flush to display */\n\n        dpy_update(s->ds, 0, y_start,\n\n                   disp_width, y - y_start);\n\n    }\n\n    /* reset modified pages */\n\n    if (page_max != -1) {\n\n        cpu_physical_memory_reset_dirty(page_min, page_max + TARGET_PAGE_SIZE,\n\n                                        VGA_DIRTY_FLAG);\n\n    }\n\n    memset(s->invalidated_y_table, 0, ((height + 31) >> 5) * 4);\n\n}\n", "idx": 26949}
{"project": "qemu", "commit_id": "aa15f497178a8a3d489bf410171c3b6dfa0d9f49", "target": 0, "func": "static void qtest_process_command(CharDriverState *chr, gchar **words)\n\n{\n\n    const gchar *command;\n\n\n\n    g_assert(words);\n\n\n\n    command = words[0];\n\n\n\n    if (qtest_log_fp) {\n\n        qemu_timeval tv;\n\n        int i;\n\n\n\n        qtest_get_time(&tv);\n\n        fprintf(qtest_log_fp, \"[R +\" FMT_timeval \"]\",\n\n                (long) tv.tv_sec, (long) tv.tv_usec);\n\n        for (i = 0; words[i]; i++) {\n\n            fprintf(qtest_log_fp, \" %s\", words[i]);\n\n        }\n\n        fprintf(qtest_log_fp, \"\\n\");\n\n    }\n\n\n\n    g_assert(command);\n\n    if (strcmp(words[0], \"irq_intercept_out\") == 0\n\n        || strcmp(words[0], \"irq_intercept_in\") == 0) {\n\n        DeviceState *dev;\n\n        NamedGPIOList *ngl;\n\n\n\n        g_assert(words[1]);\n\n        dev = DEVICE(object_resolve_path(words[1], NULL));\n\n        if (!dev) {\n\n            qtest_send_prefix(chr);\n\n            qtest_send(chr, \"FAIL Unknown device\\n\");\n\n\t    return;\n\n        }\n\n\n\n        if (irq_intercept_dev) {\n\n            qtest_send_prefix(chr);\n\n            if (irq_intercept_dev != dev) {\n\n                qtest_send(chr, \"FAIL IRQ intercept already enabled\\n\");\n\n            } else {\n\n                qtest_send(chr, \"OK\\n\");\n\n            }\n\n\t    return;\n\n        }\n\n\n\n        QLIST_FOREACH(ngl, &dev->gpios, node) {\n\n            /* We don't support intercept of named GPIOs yet */\n\n            if (ngl->name) {\n\n                continue;\n\n            }\n\n            if (words[0][14] == 'o') {\n\n                int i;\n\n                for (i = 0; i < ngl->num_out; ++i) {\n\n                    qemu_irq *disconnected = g_new0(qemu_irq, 1);\n\n                    qemu_irq icpt = qemu_allocate_irq(qtest_irq_handler,\n\n                                                      disconnected, i);\n\n\n\n                    *disconnected = qdev_intercept_gpio_out(dev, icpt,\n\n                                                            ngl->name, i);\n\n                }\n\n            } else {\n\n                qemu_irq_intercept_in(ngl->in, qtest_irq_handler,\n\n                                      ngl->num_in);\n\n            }\n\n        }\n\n        irq_intercept_dev = dev;\n\n        qtest_send_prefix(chr);\n\n        qtest_send(chr, \"OK\\n\");\n\n\n\n    } else if (strcmp(words[0], \"outb\") == 0 ||\n\n               strcmp(words[0], \"outw\") == 0 ||\n\n               strcmp(words[0], \"outl\") == 0) {\n\n        uint16_t addr;\n\n        uint32_t value;\n\n\n\n        g_assert(words[1] && words[2]);\n\n        addr = strtoul(words[1], NULL, 0);\n\n        value = strtoul(words[2], NULL, 0);\n\n\n\n        if (words[0][3] == 'b') {\n\n            cpu_outb(addr, value);\n\n        } else if (words[0][3] == 'w') {\n\n            cpu_outw(addr, value);\n\n        } else if (words[0][3] == 'l') {\n\n            cpu_outl(addr, value);\n\n        }\n\n        qtest_send_prefix(chr);\n\n        qtest_send(chr, \"OK\\n\");\n\n    } else if (strcmp(words[0], \"inb\") == 0 ||\n\n        strcmp(words[0], \"inw\") == 0 ||\n\n        strcmp(words[0], \"inl\") == 0) {\n\n        uint16_t addr;\n\n        uint32_t value = -1U;\n\n\n\n        g_assert(words[1]);\n\n        addr = strtoul(words[1], NULL, 0);\n\n\n\n        if (words[0][2] == 'b') {\n\n            value = cpu_inb(addr);\n\n        } else if (words[0][2] == 'w') {\n\n            value = cpu_inw(addr);\n\n        } else if (words[0][2] == 'l') {\n\n            value = cpu_inl(addr);\n\n        }\n\n        qtest_send_prefix(chr);\n\n        qtest_sendf(chr, \"OK 0x%04x\\n\", value);\n\n    } else if (strcmp(words[0], \"writeb\") == 0 ||\n\n               strcmp(words[0], \"writew\") == 0 ||\n\n               strcmp(words[0], \"writel\") == 0 ||\n\n               strcmp(words[0], \"writeq\") == 0) {\n\n        uint64_t addr;\n\n        uint64_t value;\n\n\n\n        g_assert(words[1] && words[2]);\n\n        addr = strtoull(words[1], NULL, 0);\n\n        value = strtoull(words[2], NULL, 0);\n\n\n\n        if (words[0][5] == 'b') {\n\n            uint8_t data = value;\n\n            cpu_physical_memory_write(addr, &data, 1);\n\n        } else if (words[0][5] == 'w') {\n\n            uint16_t data = value;\n\n            tswap16s(&data);\n\n            cpu_physical_memory_write(addr, &data, 2);\n\n        } else if (words[0][5] == 'l') {\n\n            uint32_t data = value;\n\n            tswap32s(&data);\n\n            cpu_physical_memory_write(addr, &data, 4);\n\n        } else if (words[0][5] == 'q') {\n\n            uint64_t data = value;\n\n            tswap64s(&data);\n\n            cpu_physical_memory_write(addr, &data, 8);\n\n        }\n\n        qtest_send_prefix(chr);\n\n        qtest_send(chr, \"OK\\n\");\n\n    } else if (strcmp(words[0], \"readb\") == 0 ||\n\n               strcmp(words[0], \"readw\") == 0 ||\n\n               strcmp(words[0], \"readl\") == 0 ||\n\n               strcmp(words[0], \"readq\") == 0) {\n\n        uint64_t addr;\n\n        uint64_t value = UINT64_C(-1);\n\n\n\n        g_assert(words[1]);\n\n        addr = strtoull(words[1], NULL, 0);\n\n\n\n        if (words[0][4] == 'b') {\n\n            uint8_t data;\n\n            cpu_physical_memory_read(addr, &data, 1);\n\n            value = data;\n\n        } else if (words[0][4] == 'w') {\n\n            uint16_t data;\n\n            cpu_physical_memory_read(addr, &data, 2);\n\n            value = tswap16(data);\n\n        } else if (words[0][4] == 'l') {\n\n            uint32_t data;\n\n            cpu_physical_memory_read(addr, &data, 4);\n\n            value = tswap32(data);\n\n        } else if (words[0][4] == 'q') {\n\n            cpu_physical_memory_read(addr, &value, 8);\n\n            tswap64s(&value);\n\n        }\n\n        qtest_send_prefix(chr);\n\n        qtest_sendf(chr, \"OK 0x%016\" PRIx64 \"\\n\", value);\n\n    } else if (strcmp(words[0], \"read\") == 0) {\n\n        uint64_t addr, len, i;\n\n        uint8_t *data;\n\n        char *enc;\n\n\n\n        g_assert(words[1] && words[2]);\n\n        addr = strtoull(words[1], NULL, 0);\n\n        len = strtoull(words[2], NULL, 0);\n\n\n\n        data = g_malloc(len);\n\n        cpu_physical_memory_read(addr, data, len);\n\n\n\n        enc = g_malloc(2 * len + 1);\n\n        for (i = 0; i < len; i++) {\n\n            sprintf(&enc[i * 2], \"%02x\", data[i]);\n\n        }\n\n\n\n        qtest_send_prefix(chr);\n\n        qtest_sendf(chr, \"OK 0x%s\\n\", enc);\n\n\n\n        g_free(data);\n\n        g_free(enc);\n\n    } else if (strcmp(words[0], \"b64read\") == 0) {\n\n        uint64_t addr, len;\n\n        uint8_t *data;\n\n        gchar *b64_data;\n\n\n\n        g_assert(words[1] && words[2]);\n\n        addr = strtoull(words[1], NULL, 0);\n\n        len = strtoull(words[2], NULL, 0);\n\n\n\n        data = g_malloc(len);\n\n        cpu_physical_memory_read(addr, data, len);\n\n        b64_data = g_base64_encode(data, len);\n\n        qtest_send_prefix(chr);\n\n        qtest_sendf(chr, \"OK %s\\n\", b64_data);\n\n\n\n        g_free(data);\n\n        g_free(b64_data);\n\n    } else if (strcmp(words[0], \"write\") == 0) {\n\n        uint64_t addr, len, i;\n\n        uint8_t *data;\n\n        size_t data_len;\n\n\n\n        g_assert(words[1] && words[2] && words[3]);\n\n        addr = strtoull(words[1], NULL, 0);\n\n        len = strtoull(words[2], NULL, 0);\n\n\n\n        data_len = strlen(words[3]);\n\n        if (data_len < 3) {\n\n            qtest_send(chr, \"ERR invalid argument size\\n\");\n\n            return;\n\n        }\n\n\n\n        data = g_malloc(len);\n\n        for (i = 0; i < len; i++) {\n\n            if ((i * 2 + 4) <= data_len) {\n\n                data[i] = hex2nib(words[3][i * 2 + 2]) << 4;\n\n                data[i] |= hex2nib(words[3][i * 2 + 3]);\n\n            } else {\n\n                data[i] = 0;\n\n            }\n\n        }\n\n        cpu_physical_memory_write(addr, data, len);\n\n        g_free(data);\n\n\n\n        qtest_send_prefix(chr);\n\n        qtest_send(chr, \"OK\\n\");\n\n    } else if (strcmp(words[0], \"memset\") == 0) {\n\n        uint64_t addr, len;\n\n        uint8_t *data;\n\n        uint8_t pattern;\n\n\n\n        g_assert(words[1] && words[2] && words[3]);\n\n        addr = strtoull(words[1], NULL, 0);\n\n        len = strtoull(words[2], NULL, 0);\n\n        pattern = strtoull(words[3], NULL, 0);\n\n\n\n        if (len) {\n\n            data = g_malloc(len);\n\n            memset(data, pattern, len);\n\n            cpu_physical_memory_write(addr, data, len);\n\n            g_free(data);\n\n        }\n\n\n\n        qtest_send_prefix(chr);\n\n        qtest_send(chr, \"OK\\n\");\n\n    }  else if (strcmp(words[0], \"b64write\") == 0) {\n\n        uint64_t addr, len;\n\n        uint8_t *data;\n\n        size_t data_len;\n\n        gsize out_len;\n\n\n\n        g_assert(words[1] && words[2] && words[3]);\n\n        addr = strtoull(words[1], NULL, 0);\n\n        len = strtoull(words[2], NULL, 0);\n\n\n\n        data_len = strlen(words[3]);\n\n        if (data_len < 3) {\n\n            qtest_send(chr, \"ERR invalid argument size\\n\");\n\n            return;\n\n        }\n\n\n\n        data = g_base64_decode_inplace(words[3], &out_len);\n\n        if (out_len != len) {\n\n            qtest_log_send(\"b64write: data length mismatch (told %\"PRIu64\", \"\n\n                           \"found %zu)\\n\",\n\n                           len, out_len);\n\n            out_len = MIN(out_len, len);\n\n        }\n\n\n\n        cpu_physical_memory_write(addr, data, out_len);\n\n\n\n        qtest_send_prefix(chr);\n\n        qtest_send(chr, \"OK\\n\");\n\n    } else if (qtest_enabled() && strcmp(words[0], \"clock_step\") == 0) {\n\n        int64_t ns;\n\n\n\n        if (words[1]) {\n\n            ns = strtoll(words[1], NULL, 0);\n\n        } else {\n\n            ns = qemu_clock_deadline_ns_all(QEMU_CLOCK_VIRTUAL);\n\n        }\n\n        qtest_clock_warp(qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + ns);\n\n        qtest_send_prefix(chr);\n\n        qtest_sendf(chr, \"OK %\"PRIi64\"\\n\",\n\n                    (int64_t)qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL));\n\n    } else if (qtest_enabled() && strcmp(words[0], \"clock_set\") == 0) {\n\n        int64_t ns;\n\n\n\n        g_assert(words[1]);\n\n        ns = strtoll(words[1], NULL, 0);\n\n        qtest_clock_warp(ns);\n\n        qtest_send_prefix(chr);\n\n        qtest_sendf(chr, \"OK %\"PRIi64\"\\n\",\n\n                    (int64_t)qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL));\n\n    } else {\n\n        qtest_send_prefix(chr);\n\n        qtest_sendf(chr, \"FAIL Unknown command '%s'\\n\", words[0]);\n\n    }\n\n}\n", "idx": 26950}
{"project": "qemu", "commit_id": "c18ad9a54b75495ce61e8b28d353f8eec51768fc", "target": 0, "func": "static RemoveResult remove_hpte(PowerPCCPU *cpu, target_ulong ptex,\n\n                                target_ulong avpn,\n\n                                target_ulong flags,\n\n                                target_ulong *vp, target_ulong *rp)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    uint64_t token;\n\n    target_ulong v, r;\n\n\n\n    if (!valid_pte_index(env, ptex)) {\n\n        return REMOVE_PARM;\n\n    }\n\n\n\n    token = ppc_hash64_start_access(cpu, ptex);\n\n    v = ppc_hash64_load_hpte0(cpu, token, 0);\n\n    r = ppc_hash64_load_hpte1(cpu, token, 0);\n\n    ppc_hash64_stop_access(token);\n\n\n\n    if ((v & HPTE64_V_VALID) == 0 ||\n\n        ((flags & H_AVPN) && (v & ~0x7fULL) != avpn) ||\n\n        ((flags & H_ANDCOND) && (v & avpn) != 0)) {\n\n        return REMOVE_NOT_FOUND;\n\n    }\n\n    *vp = v;\n\n    *rp = r;\n\n    ppc_hash64_store_hpte(cpu, ptex, HPTE64_V_HPTE_DIRTY, 0);\n\n    ppc_hash64_tlb_flush_hpte(cpu, ptex, v, r);\n\n    return REMOVE_SUCCESS;\n\n}\n", "idx": 26951}
{"project": "qemu", "commit_id": "2572b37a4751cc967582d7d04f21d9bf97187ae5", "target": 0, "func": "static void bdrv_aio_co_cancel_em(BlockDriverAIOCB *blockacb)\n\n{\n\n    BlockDriverAIOCBCoroutine *acb =\n\n        container_of(blockacb, BlockDriverAIOCBCoroutine, common);\n\n    bool done = false;\n\n\n\n    acb->done = &done;\n\n    while (!done) {\n\n        qemu_aio_wait();\n\n    }\n\n}\n", "idx": 26952}
{"project": "qemu", "commit_id": "1c46efaa0a175e468772405385ca26a1e35dd94c", "target": 0, "func": "static void qcow_aio_read_cb(void *opaque, int ret)\n\n{\n\n    QCowAIOCB *acb = opaque;\n\n    BlockDriverState *bs = acb->common.bs;\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster, n1;\n\n\n\n    acb->hd_aiocb = NULL;\n\n    if (ret < 0)\n\n        goto done;\n\n\n\n    /* post process the read buffer */\n\n    if (!acb->cluster_offset) {\n\n        /* nothing to do */\n\n    } else if (acb->cluster_offset & QCOW_OFLAG_COMPRESSED) {\n\n        /* nothing to do */\n\n    } else {\n\n        if (s->crypt_method) {\n\n            qcow2_encrypt_sectors(s, acb->sector_num, acb->buf, acb->buf,\n\n                            acb->cur_nr_sectors, 0,\n\n                            &s->aes_decrypt_key);\n\n        }\n\n    }\n\n\n\n    acb->remaining_sectors -= acb->cur_nr_sectors;\n\n    acb->sector_num += acb->cur_nr_sectors;\n\n    acb->buf += acb->cur_nr_sectors * 512;\n\n\n\n    if (acb->remaining_sectors == 0) {\n\n        /* request completed */\n\n        ret = 0;\n\n        goto done;\n\n    }\n\n\n\n    /* prepare next AIO request */\n\n    acb->cur_nr_sectors = acb->remaining_sectors;\n\n    acb->cluster_offset = qcow2_get_cluster_offset(bs, acb->sector_num << 9,\n\n                                                   &acb->cur_nr_sectors);\n\n    index_in_cluster = acb->sector_num & (s->cluster_sectors - 1);\n\n\n\n    if (!acb->cluster_offset) {\n\n        if (bs->backing_hd) {\n\n            /* read from the base image */\n\n            n1 = qcow2_backing_read1(bs->backing_hd, acb->sector_num,\n\n                               acb->buf, acb->cur_nr_sectors);\n\n            if (n1 > 0) {\n\n                acb->hd_iov.iov_base = (void *)acb->buf;\n\n                acb->hd_iov.iov_len = acb->cur_nr_sectors * 512;\n\n                qemu_iovec_init_external(&acb->hd_qiov, &acb->hd_iov, 1);\n\n                BLKDBG_EVENT(bs->file, BLKDBG_READ_BACKING_AIO);\n\n                acb->hd_aiocb = bdrv_aio_readv(bs->backing_hd, acb->sector_num,\n\n                                    &acb->hd_qiov, acb->cur_nr_sectors,\n\n\t\t\t\t    qcow_aio_read_cb, acb);\n\n                if (acb->hd_aiocb == NULL)\n\n                    goto done;\n\n            } else {\n\n                ret = qcow_schedule_bh(qcow_aio_read_bh, acb);\n\n                if (ret < 0)\n\n                    goto done;\n\n            }\n\n        } else {\n\n            /* Note: in this case, no need to wait */\n\n            memset(acb->buf, 0, 512 * acb->cur_nr_sectors);\n\n            ret = qcow_schedule_bh(qcow_aio_read_bh, acb);\n\n            if (ret < 0)\n\n                goto done;\n\n        }\n\n    } else if (acb->cluster_offset & QCOW_OFLAG_COMPRESSED) {\n\n        /* add AIO support for compressed blocks ? */\n\n        if (qcow2_decompress_cluster(bs, acb->cluster_offset) < 0)\n\n            goto done;\n\n        memcpy(acb->buf, s->cluster_cache + index_in_cluster * 512,\n\n               512 * acb->cur_nr_sectors);\n\n        ret = qcow_schedule_bh(qcow_aio_read_bh, acb);\n\n        if (ret < 0)\n\n            goto done;\n\n    } else {\n\n        if ((acb->cluster_offset & 511) != 0) {\n\n            ret = -EIO;\n\n            goto done;\n\n        }\n\n\n\n        acb->hd_iov.iov_base = (void *)acb->buf;\n\n        acb->hd_iov.iov_len = acb->cur_nr_sectors * 512;\n\n        qemu_iovec_init_external(&acb->hd_qiov, &acb->hd_iov, 1);\n\n        BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);\n\n        acb->hd_aiocb = bdrv_aio_readv(bs->file,\n\n                            (acb->cluster_offset >> 9) + index_in_cluster,\n\n                            &acb->hd_qiov, acb->cur_nr_sectors,\n\n                            qcow_aio_read_cb, acb);\n\n        if (acb->hd_aiocb == NULL) {\n\n            ret = -EIO;\n\n            goto done;\n\n        }\n\n    }\n\n\n\n    return;\n\ndone:\n\n    if (acb->qiov->niov > 1) {\n\n        qemu_iovec_from_buffer(acb->qiov, acb->orig_buf, acb->qiov->size);\n\n        qemu_vfree(acb->orig_buf);\n\n    }\n\n    acb->common.cb(acb->common.opaque, ret);\n\n    qemu_aio_release(acb);\n\n}\n", "idx": 26953}
{"project": "qemu", "commit_id": "69970fcef937bddd7f745efe39501c7716fdfe56", "target": 0, "func": "static uint64_t vfio_rtl8168_window_quirk_read(void *opaque,\n\n                                               hwaddr addr, unsigned size)\n\n{\n\n    VFIOQuirk *quirk = opaque;\n\n    VFIOPCIDevice *vdev = quirk->vdev;\n\n\n\n    switch (addr) {\n\n    case 4: /* address */\n\n        if (quirk->data.flags) {\n\n            trace_vfio_rtl8168_window_quirk_read_fake(\n\n                    memory_region_name(&quirk->mem),\n\n                    vdev->vbasedev.name);\n\n\n\n            return quirk->data.address_match ^ 0x10000000U;\n\n        }\n\n        break;\n\n    case 0: /* data */\n\n        if (quirk->data.flags) {\n\n            uint64_t val;\n\n\n\n            trace_vfio_rtl8168_window_quirk_read_table(\n\n                    memory_region_name(&quirk->mem),\n\n                    vdev->vbasedev.name);\n\n\n\n            if (!(vdev->pdev.cap_present & QEMU_PCI_CAP_MSIX)) {\n\n                return 0;\n\n            }\n\n\n\n            memory_region_dispatch_read(&vdev->pdev.msix_table_mmio,\n\n                                        (hwaddr)(quirk->data.address_match\n\n                                                 & 0xfff),\n\n                                        &val,\n\n                                        size,\n\n                                        MEMTXATTRS_UNSPECIFIED);\n\n            return val;\n\n        }\n\n    }\n\n\n\n    trace_vfio_rtl8168_window_quirk_read_direct(memory_region_name(&quirk->mem),\n\n                                                vdev->vbasedev.name);\n\n\n\n    return vfio_region_read(&vdev->bars[quirk->data.bar].region,\n\n                            addr + 0x70, size);\n\n}\n", "idx": 26954}
{"project": "qemu", "commit_id": "7059384c7e27d68c502d8636eb711873a9a6a597", "target": 0, "func": "static void init_event_facility(Object *obj)\n\n{\n\n    SCLPEventFacility *event_facility = EVENT_FACILITY(obj);\n\n    DeviceState *sdev = DEVICE(obj);\n\n\n\n    /* Spawn a new bus for SCLP events */\n\n    qbus_create_inplace(&event_facility->sbus, sizeof(event_facility->sbus),\n\n                        TYPE_SCLP_EVENTS_BUS, sdev, NULL);\n\n\n\n    object_initialize(&event_facility->quiesce_event, sizeof(SCLPEvent),\n\n                      TYPE_SCLP_QUIESCE);\n\n    qdev_set_parent_bus(DEVICE(&event_facility->quiesce_event),\n\n                        &event_facility->sbus.qbus);\n\n    object_initialize(&event_facility->cpu_hotplug_event, sizeof(SCLPEvent),\n\n                      TYPE_SCLP_CPU_HOTPLUG);\n\n    qdev_set_parent_bus(DEVICE(&event_facility->cpu_hotplug_event),\n\n                        &event_facility->sbus.qbus);\n\n    /* the facility will automatically realize the devices via the bus */\n\n}\n", "idx": 26955}
{"project": "qemu", "commit_id": "7f61f4690dd153be98900a2a508b88989e692753", "target": 0, "func": "pvscsi_dbg_dump_tx_rings_config(PVSCSICmdDescSetupRings *rc)\n\n{\n\n    int i;\n\n    trace_pvscsi_tx_rings_ppn(\"Rings State\", rc->ringsStatePPN);\n\n\n\n    trace_pvscsi_tx_rings_num_pages(\"Request Ring\", rc->reqRingNumPages);\n\n    for (i = 0; i < rc->reqRingNumPages; i++) {\n\n        trace_pvscsi_tx_rings_ppn(\"Request Ring\", rc->reqRingPPNs[i]);\n\n    }\n\n\n\n    trace_pvscsi_tx_rings_num_pages(\"Confirm Ring\", rc->cmpRingNumPages);\n\n    for (i = 0; i < rc->cmpRingNumPages; i++) {\n\n        trace_pvscsi_tx_rings_ppn(\"Confirm Ring\", rc->reqRingPPNs[i]);\n\n    }\n\n}\n", "idx": 26958}
{"project": "qemu", "commit_id": "7e01376daea75e888c370aab521a7d4aeaf2ffd1", "target": 0, "func": "void ioinst_handle_ssch(S390CPU *cpu, uint64_t reg1, uint32_t ipb)\n\n{\n\n    int cssid, ssid, schid, m;\n\n    SubchDev *sch;\n\n    ORB orig_orb, orb;\n\n    uint64_t addr;\n\n    int ret = -ENODEV;\n\n    int cc;\n\n    CPUS390XState *env = &cpu->env;\n\n    uint8_t ar;\n\n\n\n    addr = decode_basedisp_s(env, ipb, &ar);\n\n    if (addr & 3) {\n\n        program_interrupt(env, PGM_SPECIFICATION, 2);\n\n        return;\n\n    }\n\n    if (s390_cpu_virt_mem_read(cpu, addr, ar, &orig_orb, sizeof(orb))) {\n\n        return;\n\n    }\n\n    copy_orb_from_guest(&orb, &orig_orb);\n\n    if (ioinst_disassemble_sch_ident(reg1, &m, &cssid, &ssid, &schid) ||\n\n        !ioinst_orb_valid(&orb)) {\n\n        program_interrupt(env, PGM_OPERAND, 2);\n\n        return;\n\n    }\n\n    trace_ioinst_sch_id(\"ssch\", cssid, ssid, schid);\n\n    sch = css_find_subch(m, cssid, ssid, schid);\n\n    if (sch && css_subch_visible(sch)) {\n\n        ret = css_do_ssch(sch, &orb);\n\n    }\n\n    switch (ret) {\n\n    case -ENODEV:\n\n        cc = 3;\n\n        break;\n\n    case -EBUSY:\n\n        cc = 2;\n\n        break;\n\n    case -EFAULT:\n\n        /*\n\n         * TODO:\n\n         * I'm wondering whether there is something better\n\n         * to do for us here (like setting some device or\n\n         * subchannel status).\n\n         */\n\n        program_interrupt(env, PGM_ADDRESSING, 4);\n\n        return;\n\n    case 0:\n\n        cc = 0;\n\n        break;\n\n    default:\n\n        cc = 1;\n\n        break;\n\n    }\n\n    setcc(cpu, cc);\n\n}\n", "idx": 26959}
{"project": "qemu", "commit_id": "c650c008e326f3a1e84083bc269265456057a212", "target": 0, "func": "static void setup_frame(int sig, struct target_sigaction *ka,\n\n                        target_sigset_t *set, CPUPPCState *env)\n\n{\n\n    struct target_sigframe *frame;\n\n    struct target_sigcontext *sc;\n\n    target_ulong frame_addr, newsp;\n\n    int err = 0;\n\n    int signal;\n\n\n\n    frame_addr = get_sigframe(ka, env, sizeof(*frame));\n\n    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))\n\n        goto sigsegv;\n\n    sc = &frame->sctx;\n\n\n\n    signal = current_exec_domain_sig(sig);\n\n\n\n    __put_user(ka->_sa_handler, &sc->handler);\n\n    __put_user(set->sig[0], &sc->oldmask);\n\n#if defined(TARGET_PPC64)\n\n    __put_user(set->sig[0] >> 32, &sc->_unused[3]);\n\n#else\n\n    __put_user(set->sig[1], &sc->_unused[3]);\n\n#endif\n\n    __put_user(h2g(&frame->mctx), &sc->regs);\n\n    __put_user(sig, &sc->signal);\n\n\n\n    /* Save user regs.  */\n\n    err |= save_user_regs(env, &frame->mctx, TARGET_NR_sigreturn);\n\n\n\n    /* The kernel checks for the presence of a VDSO here.  We don't\n\n       emulate a vdso, so use a sigreturn system call.  */\n\n    env->lr = (target_ulong) h2g(frame->mctx.tramp);\n\n\n\n    /* Turn off all fp exceptions.  */\n\n    env->fpscr = 0;\n\n\n\n    /* Create a stack frame for the caller of the handler.  */\n\n    newsp = frame_addr - SIGNAL_FRAMESIZE;\n\n    err |= put_user(env->gpr[1], newsp, target_ulong);\n\n\n\n    if (err)\n\n        goto sigsegv;\n\n\n\n    /* Set up registers for signal handler.  */\n\n    env->gpr[1] = newsp;\n\n    env->gpr[3] = signal;\n\n    env->gpr[4] = frame_addr + offsetof(struct target_sigframe, sctx);\n\n    env->nip = (target_ulong) ka->_sa_handler;\n\n    /* Signal handlers are entered in big-endian mode.  */\n\n    env->msr &= ~MSR_LE;\n\n\n\n    unlock_user_struct(frame, frame_addr, 1);\n\n    return;\n\n\n\nsigsegv:\n\n    unlock_user_struct(frame, frame_addr, 1);\n\n    qemu_log(\"segfaulting from setup_frame\\n\");\n\n    force_sig(TARGET_SIGSEGV);\n\n}\n", "idx": 26961}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void aio_context_ref(AioContext *ctx)\n\n{\n\n    g_source_ref(&ctx->source);\n\n}\n", "idx": 26962}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t mv88w8618_audio_read(void *opaque, target_phys_addr_t offset,\n\n                                    unsigned size)\n\n{\n\n    mv88w8618_audio_state *s = opaque;\n\n\n\n    switch (offset) {\n\n    case MP_AUDIO_PLAYBACK_MODE:\n\n        return s->playback_mode;\n\n\n\n    case MP_AUDIO_CLOCK_DIV:\n\n        return s->clock_div;\n\n\n\n    case MP_AUDIO_IRQ_STATUS:\n\n        return s->status;\n\n\n\n    case MP_AUDIO_IRQ_ENABLE:\n\n        return s->irq_enable;\n\n\n\n    case MP_AUDIO_TX_STATUS:\n\n        return s->play_pos >> 2;\n\n\n\n    default:\n\n        return 0;\n\n    }\n\n}\n", "idx": 26963}
{"project": "qemu", "commit_id": "f8b6cc0070aab8b75bd082582c829be1353f395f", "target": 0, "func": "static void free_drive(DeviceState *dev, Property *prop)\n\n{\n\n    DriveInfo **ptr = qdev_get_prop_ptr(dev, prop);\n\n\n\n    if (*ptr) {\n\n        blockdev_auto_del((*ptr)->bdrv);\n\n    }\n\n}\n", "idx": 26964}
{"project": "qemu", "commit_id": "d8754f40acb2d30e4735cdcd21a16e7ac29264a3", "target": 0, "func": "opts_end_list(Visitor *v, Error **errp)\n\n{\n\n    OptsVisitor *ov = DO_UPCAST(OptsVisitor, visitor, v);\n\n\n\n    assert(ov->list_mode == LM_STARTED || ov->list_mode == LM_IN_PROGRESS);\n\n    ov->repeated_opts = NULL;\n\n    ov->list_mode = LM_NONE;\n\n}\n", "idx": 26965}
{"project": "qemu", "commit_id": "e48e84ea80cb2e7fe6e48196ce187cfba6e3eb2c", "target": 0, "func": "void scsi_device_purge_requests(SCSIDevice *sdev, SCSISense sense)\n\n{\n\n    SCSIRequest *req;\n\n\n\n    while (!QTAILQ_EMPTY(&sdev->requests)) {\n\n        req = QTAILQ_FIRST(&sdev->requests);\n\n        scsi_req_cancel(req);\n\n    }\n\n    sdev->unit_attention = sense;\n\n}\n", "idx": 26966}
{"project": "qemu", "commit_id": "dd673288a8ff73ad77fcc1c255486d2466a772e1", "target": 0, "func": "uint64_t cpu_get_apic_base(DeviceState *d)\n\n{\n\n    if (d) {\n\n        APICCommonState *s = APIC_COMMON(d);\n\n        trace_cpu_get_apic_base((uint64_t)s->apicbase);\n\n        return s->apicbase;\n\n    } else {\n\n        trace_cpu_get_apic_base(0);\n\n        return 0;\n\n    }\n\n}\n", "idx": 26967}
{"project": "qemu", "commit_id": "a91246c95f913dc6fd391eee32f6c9796de70183", "target": 0, "func": "static int ram_save_complete(QEMUFile *f, void *opaque)\n\n{\n\n    rcu_read_lock();\n\n\n\n    if (!migration_in_postcopy(migrate_get_current())) {\n\n        migration_bitmap_sync();\n\n    }\n\n\n\n    ram_control_before_iterate(f, RAM_CONTROL_FINISH);\n\n\n\n    /* try transferring iterative blocks of memory */\n\n\n\n    /* flush all remaining blocks regardless of rate limiting */\n\n    while (true) {\n\n        int pages;\n\n\n\n        pages = ram_find_and_save_block(f, true, &bytes_transferred);\n\n        /* no more blocks to sent */\n\n        if (pages == 0) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    flush_compressed_data(f);\n\n    ram_control_after_iterate(f, RAM_CONTROL_FINISH);\n\n\n\n    rcu_read_unlock();\n\n\n\n    qemu_put_be64(f, RAM_SAVE_FLAG_EOS);\n\n\n\n    return 0;\n\n}\n", "idx": 26968}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static CaptureVoiceOut *audio_pcm_capture_find_specific (\n\n    AudioState *s,\n\n    audsettings_t *as\n\n    )\n\n{\n\n    CaptureVoiceOut *cap;\n\n\n\n    for (cap = s->cap_head.lh_first; cap; cap = cap->entries.le_next) {\n\n        if (audio_pcm_info_eq (&cap->hw.info, as)) {\n\n            return cap;\n\n        }\n\n    }\n\n    return NULL;\n\n}\n", "idx": 26969}
{"project": "qemu", "commit_id": "5d7fd045cafeac1831c1999cb9e1251b7906c6b2", "target": 0, "func": "uint32_t HELPER(lpxbr)(CPUS390XState *env, uint32_t f1, uint32_t f2)\n\n{\n\n    CPU_QuadU v1;\n\n    CPU_QuadU v2;\n\n\n\n    v2.ll.upper = env->fregs[f2].ll;\n\n    v2.ll.lower = env->fregs[f2 + 2].ll;\n\n    v1.q = float128_abs(v2.q);\n\n    env->fregs[f1].ll = v1.ll.upper;\n\n    env->fregs[f1 + 2].ll = v1.ll.lower;\n\n    return set_cc_nz_f128(v1.q);\n\n}\n", "idx": 26970}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static int v9fs_synth_statfs(FsContext *s, V9fsPath *fs_path,\n\n                             struct statfs *stbuf)\n\n{\n\n    stbuf->f_type = 0xABCD;\n\n    stbuf->f_bsize = 512;\n\n    stbuf->f_blocks = 0;\n\n    stbuf->f_files = v9fs_synth_node_count;\n\n    stbuf->f_namelen = NAME_MAX;\n\n    return 0;\n\n}\n", "idx": 26972}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void m5206_mbar_writew(void *opaque, target_phys_addr_t offset,\n\n                              uint32_t value)\n\n{\n\n    m5206_mbar_state *s = (m5206_mbar_state *)opaque;\n\n    int width;\n\n    offset &= 0x3ff;\n\n    if (offset >= 0x200) {\n\n        hw_error(\"Bad MBAR write offset 0x%x\", (int)offset);\n\n    }\n\n    width = m5206_mbar_width[offset >> 2];\n\n    if (width > 2) {\n\n        uint32_t tmp;\n\n        tmp = m5206_mbar_readl(opaque, offset & ~3);\n\n        if (offset & 3) {\n\n            tmp = (tmp & 0xffff0000) | value;\n\n        } else {\n\n            tmp = (tmp & 0x0000ffff) | (value << 16);\n\n        }\n\n        m5206_mbar_writel(opaque, offset & ~3, tmp);\n\n        return;\n\n    } else if (width < 2) {\n\n        m5206_mbar_writeb(opaque, offset, value >> 8);\n\n        m5206_mbar_writeb(opaque, offset + 1, value & 0xff);\n\n        return;\n\n    }\n\n    m5206_mbar_write(s, offset, value, 2);\n\n}\n", "idx": 26973}
{"project": "qemu", "commit_id": "149f54b53b7666a3facd45e86eece60ce7d3b114", "target": 0, "func": "hwaddr memory_region_section_get_iotlb(CPUArchState *env,\n\n                                                   MemoryRegionSection *section,\n\n                                                   target_ulong vaddr,\n\n                                                   hwaddr paddr,\n\n                                                   int prot,\n\n                                                   target_ulong *address)\n\n{\n\n    hwaddr iotlb;\n\n    CPUWatchpoint *wp;\n\n\n\n    if (memory_region_is_ram(section->mr)) {\n\n        /* Normal RAM.  */\n\n        iotlb = (memory_region_get_ram_addr(section->mr) & TARGET_PAGE_MASK)\n\n            + memory_region_section_addr(section, paddr);\n\n        if (!section->readonly) {\n\n            iotlb |= phys_section_notdirty;\n\n        } else {\n\n            iotlb |= phys_section_rom;\n\n        }\n\n    } else {\n\n        iotlb = section - phys_sections;\n\n        iotlb += memory_region_section_addr(section, paddr);\n\n    }\n\n\n\n    /* Make accesses to pages with watchpoints go via the\n\n       watchpoint trap routines.  */\n\n    QTAILQ_FOREACH(wp, &env->watchpoints, entry) {\n\n        if (vaddr == (wp->vaddr & TARGET_PAGE_MASK)) {\n\n            /* Avoid trapping reads of pages with a write breakpoint. */\n\n            if ((prot & PAGE_WRITE) || (wp->flags & BP_MEM_READ)) {\n\n                iotlb = phys_section_watch + paddr;\n\n                *address |= TLB_MMIO;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    return iotlb;\n\n}\n", "idx": 26974}
{"project": "qemu", "commit_id": "d57e4e482e3997b1382625c84149ad0b69155fc0", "target": 0, "func": "static void term_init(void)\n\n{\n\n    struct termios tty;\n\n\n\n    tcgetattr (0, &tty);\n\n    oldtty = tty;\n\n\n\n    tty.c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP\n\n                          |INLCR|IGNCR|ICRNL|IXON);\n\n    tty.c_oflag |= OPOST;\n\n    tty.c_lflag &= ~(ECHO|ECHONL|ICANON|IEXTEN);\n\n    tty.c_cflag &= ~(CSIZE|PARENB);\n\n    tty.c_cflag |= CS8;\n\n    tty.c_cc[VMIN] = 1;\n\n    tty.c_cc[VTIME] = 0;\n\n\n\n    tcsetattr (0, TCSANOW, &tty);\n\n\n\n    atexit(term_exit);\n\n}\n", "idx": 26975}
{"project": "qemu", "commit_id": "f41389ae3c54bd5e2040e3f95a2872981c3ed965", "target": 0, "func": "static void xics_kvm_realize(DeviceState *dev, Error **errp)\n\n{\n\n    KVMXICSState *icpkvm = KVM_XICS(dev);\n\n    XICSState *icp = XICS_COMMON(dev);\n\n    int i, rc;\n\n    Error *error = NULL;\n\n    struct kvm_create_device xics_create_device = {\n\n        .type = KVM_DEV_TYPE_XICS,\n\n        .flags = 0,\n\n    };\n\n\n\n    if (!kvm_enabled() || !kvm_check_extension(kvm_state, KVM_CAP_IRQ_XICS)) {\n\n        error_setg(errp,\n\n                   \"KVM and IRQ_XICS capability must be present for in-kernel XICS\");\n\n        goto fail;\n\n    }\n\n\n\n    spapr_rtas_register(RTAS_IBM_SET_XIVE, \"ibm,set-xive\", rtas_dummy);\n\n    spapr_rtas_register(RTAS_IBM_GET_XIVE, \"ibm,get-xive\", rtas_dummy);\n\n    spapr_rtas_register(RTAS_IBM_INT_OFF, \"ibm,int-off\", rtas_dummy);\n\n    spapr_rtas_register(RTAS_IBM_INT_ON, \"ibm,int-on\", rtas_dummy);\n\n\n\n    rc = kvmppc_define_rtas_kernel_token(RTAS_IBM_SET_XIVE, \"ibm,set-xive\");\n\n    if (rc < 0) {\n\n        error_setg(errp, \"kvmppc_define_rtas_kernel_token: ibm,set-xive\");\n\n        goto fail;\n\n    }\n\n\n\n    rc = kvmppc_define_rtas_kernel_token(RTAS_IBM_GET_XIVE, \"ibm,get-xive\");\n\n    if (rc < 0) {\n\n        error_setg(errp, \"kvmppc_define_rtas_kernel_token: ibm,get-xive\");\n\n        goto fail;\n\n    }\n\n\n\n    rc = kvmppc_define_rtas_kernel_token(RTAS_IBM_INT_ON, \"ibm,int-on\");\n\n    if (rc < 0) {\n\n        error_setg(errp, \"kvmppc_define_rtas_kernel_token: ibm,int-on\");\n\n        goto fail;\n\n    }\n\n\n\n    rc = kvmppc_define_rtas_kernel_token(RTAS_IBM_INT_OFF, \"ibm,int-off\");\n\n    if (rc < 0) {\n\n        error_setg(errp, \"kvmppc_define_rtas_kernel_token: ibm,int-off\");\n\n        goto fail;\n\n    }\n\n\n\n    /* Create the kernel ICP */\n\n    rc = kvm_vm_ioctl(kvm_state, KVM_CREATE_DEVICE, &xics_create_device);\n\n    if (rc < 0) {\n\n        error_setg_errno(errp, -rc, \"Error on KVM_CREATE_DEVICE for XICS\");\n\n        goto fail;\n\n    }\n\n\n\n    icpkvm->kernel_xics_fd = xics_create_device.fd;\n\n\n\n    object_property_set_bool(OBJECT(icp->ics), true, \"realized\", &error);\n\n    if (error) {\n\n        error_propagate(errp, error);\n\n        goto fail;\n\n    }\n\n\n\n    assert(icp->nr_servers);\n\n    for (i = 0; i < icp->nr_servers; i++) {\n\n        object_property_set_bool(OBJECT(&icp->ss[i]), true, \"realized\", &error);\n\n        if (error) {\n\n            error_propagate(errp, error);\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    kvm_kernel_irqchip = true;\n\n    kvm_irqfds_allowed = true;\n\n    kvm_msi_via_irqfd_allowed = true;\n\n    kvm_gsi_direct_mapping = true;\n\n\n\n    return;\n\n\n\nfail:\n\n    kvmppc_define_rtas_kernel_token(0, \"ibm,set-xive\");\n\n    kvmppc_define_rtas_kernel_token(0, \"ibm,get-xive\");\n\n    kvmppc_define_rtas_kernel_token(0, \"ibm,int-on\");\n\n    kvmppc_define_rtas_kernel_token(0, \"ibm,int-off\");\n\n}\n", "idx": 26976}
{"project": "qemu", "commit_id": "df8bf7a7fe75eb5d5caffa55f5cd4292b757aea6", "target": 1, "func": "void net_rx_pkt_dump(struct NetRxPkt *pkt)\n\n{\n\n#ifdef NET_RX_PKT_DEBUG\n\n    assert(pkt);\n\n\n\n    printf(\"RX PKT: tot_len: %d, vlan_stripped: %d, vlan_tag: %d\\n\",\n\n              pkt->tot_len, pkt->vlan_stripped, pkt->tci);\n\n#endif\n\n}\n", "idx": 26978}
{"project": "qemu", "commit_id": "cab4888136a92250fdd401402622824994f7ce0b", "target": 1, "func": "static void gen_msa_elm_df(CPUMIPSState *env, DisasContext *ctx, uint32_t df,\n\n        uint32_t n)\n\n{\n\n#define MASK_MSA_ELM(op)    (MASK_MSA_MINOR(op) | (op & (0xf << 22)))\n\n    uint8_t ws = (ctx->opcode >> 11) & 0x1f;\n\n    uint8_t wd = (ctx->opcode >> 6) & 0x1f;\n\n\n\n    TCGv_i32 tws = tcg_const_i32(ws);\n\n    TCGv_i32 twd = tcg_const_i32(wd);\n\n    TCGv_i32 tn  = tcg_const_i32(n);\n\n    TCGv_i32 tdf = tcg_const_i32(df);\n\n\n\n    switch (MASK_MSA_ELM(ctx->opcode)) {\n\n    case OPC_SLDI_df:\n\n        gen_helper_msa_sldi_df(cpu_env, tdf, twd, tws, tn);\n\n        break;\n\n    case OPC_SPLATI_df:\n\n        gen_helper_msa_splati_df(cpu_env, tdf, twd, tws, tn);\n\n        break;\n\n    case OPC_INSVE_df:\n\n        gen_helper_msa_insve_df(cpu_env, tdf, twd, tws, tn);\n\n        break;\n\n    case OPC_COPY_S_df:\n\n    case OPC_COPY_U_df:\n\n    case OPC_INSERT_df:\n\n#if !defined(TARGET_MIPS64)\n\n        /* Double format valid only for MIPS64 */\n\n        if (df == DF_DOUBLE) {\n\n            generate_exception_end(ctx, EXCP_RI);\n\n            break;\n\n        }\n\n#endif\n\n        switch (MASK_MSA_ELM(ctx->opcode)) {\n\n        case OPC_COPY_S_df:\n\n            gen_helper_msa_copy_s_df(cpu_env, tdf, twd, tws, tn);\n\n            break;\n\n        case OPC_COPY_U_df:\n\n            gen_helper_msa_copy_u_df(cpu_env, tdf, twd, tws, tn);\n\n            break;\n\n        case OPC_INSERT_df:\n\n            gen_helper_msa_insert_df(cpu_env, tdf, twd, tws, tn);\n\n            break;\n\n        }\n\n        break;\n\n    default:\n\n        MIPS_INVAL(\"MSA instruction\");\n\n        generate_exception_end(ctx, EXCP_RI);\n\n    }\n\n    tcg_temp_free_i32(twd);\n\n    tcg_temp_free_i32(tws);\n\n    tcg_temp_free_i32(tn);\n\n    tcg_temp_free_i32(tdf);\n\n}\n", "idx": 26980}
{"project": "qemu", "commit_id": "5e52e5f903b2648c59030637e1610b32e965d615", "target": 1, "func": "static uint32_t get_features(VirtIODevice *vdev, uint32_t features)\n\n{\n\n    VirtIOSerial *vser;\n\n\n\n    vser = DO_UPCAST(VirtIOSerial, vdev, vdev);\n\n\n\n    if (vser->bus->max_nr_ports > 1) {\n\n        features |= (1 << VIRTIO_CONSOLE_F_MULTIPORT);\n\n    }\n\n    return features;\n\n}\n", "idx": 26982}
{"project": "qemu", "commit_id": "c599d4d6d6e9bfdb64e54c33a22cb26e3496b96d", "target": 1, "func": "static void QEMU_NORETURN force_sig(int target_sig)\n\n{\n\n    CPUState *cpu = thread_cpu;\n\n    CPUArchState *env = cpu->env_ptr;\n\n    TaskState *ts = (TaskState *)cpu->opaque;\n\n    int host_sig, core_dumped = 0;\n\n    struct sigaction act;\n\n\n\n    host_sig = target_to_host_signal(target_sig);\n\n    trace_user_force_sig(env, target_sig, host_sig);\n\n    gdb_signalled(env, target_sig);\n\n\n\n    /* dump core if supported by target binary format */\n\n    if (core_dump_signal(target_sig) && (ts->bprm->core_dump != NULL)) {\n\n        stop_all_tasks();\n\n        core_dumped =\n\n            ((*ts->bprm->core_dump)(target_sig, env) == 0);\n\n    }\n\n    if (core_dumped) {\n\n        /* we already dumped the core of target process, we don't want\n\n         * a coredump of qemu itself */\n\n        struct rlimit nodump;\n\n        getrlimit(RLIMIT_CORE, &nodump);\n\n        nodump.rlim_cur=0;\n\n        setrlimit(RLIMIT_CORE, &nodump);\n\n        (void) fprintf(stderr, \"qemu: uncaught target signal %d (%s) - %s\\n\",\n\n            target_sig, strsignal(host_sig), \"core dumped\" );\n\n    }\n\n\n\n    /* The proper exit code for dying from an uncaught signal is\n\n     * -<signal>.  The kernel doesn't allow exit() or _exit() to pass\n\n     * a negative value.  To get the proper exit code we need to\n\n     * actually die from an uncaught signal.  Here the default signal\n\n     * handler is installed, we send ourself a signal and we wait for\n\n     * it to arrive. */\n\n    sigfillset(&act.sa_mask);\n\n    act.sa_handler = SIG_DFL;\n\n    act.sa_flags = 0;\n\n    sigaction(host_sig, &act, NULL);\n\n\n\n    /* For some reason raise(host_sig) doesn't send the signal when\n\n     * statically linked on x86-64. */\n\n    kill(getpid(), host_sig);\n\n\n\n    /* Make sure the signal isn't masked (just reuse the mask inside\n\n    of act) */\n\n    sigdelset(&act.sa_mask, host_sig);\n\n    sigsuspend(&act.sa_mask);\n\n\n\n    /* unreachable */\n\n    abort();\n\n}\n", "idx": 26984}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)\n\n{\n\n    val = tswap64(val);\n\n    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));\n\n}\n", "idx": 26987}
{"project": "qemu", "commit_id": "21f88d021d0d2b4ecee8f6cd6ca63a943a3ce71d", "target": 1, "func": "test_opts_dict_unvisited(void)\n\n{\n\n    QemuOpts *opts;\n\n    Visitor *v;\n\n    UserDefOptions *userdef;\n\n\n\n    opts = qemu_opts_parse(qemu_find_opts(\"userdef\"), \"i64x=0,bogus=1\", false,\n\n                           &error_abort);\n\n\n\n    v = opts_visitor_new(opts);\n\n    /* BUG: bogus should be diagnosed */\n\n    visit_type_UserDefOptions(v, NULL, &userdef, &error_abort);\n\n    visit_free(v);\n\n    qemu_opts_del(opts);\n\n    qapi_free_UserDefOptions(userdef);\n\n}\n", "idx": 26993}
{"project": "qemu", "commit_id": "970311646a701eecb103eb28093e8924d2fa6861", "target": 1, "func": "void block_job_completed(BlockJob *job, int ret)\n\n{\n\n    BlockDriverState *bs = job->bs;\n\n\n\n    assert(bs->job == job);\n\n    job->cb(job->opaque, ret);\n\n    bs->job = NULL;\n\n    bdrv_op_unblock_all(bs, job->blocker);\n\n    error_free(job->blocker);\n\n    g_free(job);\n\n}\n", "idx": 26995}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void set_tco_timeout(const TestData *d, uint16_t ticks)\n\n{\n\n    qpci_io_writew(d->dev, d->tco_io_base + TCO_TMR, ticks);\n\n}\n", "idx": 26996}
{"project": "qemu", "commit_id": "21ef45d71221b4577330fe3aacfb06afad91ad46", "target": 1, "func": "int vnc_display_password(DisplayState *ds, const char *password)\n\n{\n\n    VncDisplay *vs = ds ? (VncDisplay *)ds->opaque : vnc_display;\n\n\n\n    if (!vs) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (!password) {\n\n        /* This is not the intention of this interface but err on the side\n\n           of being safe */\n\n        return vnc_display_disable_login(ds);\n\n    }\n\n\n\n    if (vs->password) {\n\n        g_free(vs->password);\n\n        vs->password = NULL;\n\n    }\n\n    vs->password = g_strdup(password);\n\n    if (vs->auth == VNC_AUTH_NONE) {\n\n        vs->auth = VNC_AUTH_VNC;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 26998}
{"project": "qemu", "commit_id": "348295838384941d1e5420d10e57366c4e303d45", "target": 0, "func": "static void data_plane_remove_op_blockers(VirtIOBlockDataPlane *s)\n\n{\n\n    if (s->blocker) {\n\n        blk_op_unblock_all(s->conf->conf.blk, s->blocker);\n\n        error_free(s->blocker);\n\n        s->blocker = NULL;\n\n    }\n\n}\n", "idx": 26999}
{"project": "qemu", "commit_id": "67a0fd2a9bca204d2b39f910a97c7137636a0715", "target": 0, "func": "static int64_t coroutine_fn parallels_co_get_block_status(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, int *pnum)\n\n{\n\n    BDRVParallelsState *s = bs->opaque;\n\n    int64_t offset;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    offset = block_status(s, sector_num, nb_sectors, pnum);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    if (offset < 0) {\n\n        return 0;\n\n    }\n\n\n\n    return (offset << BDRV_SECTOR_BITS) |\n\n        BDRV_BLOCK_DATA | BDRV_BLOCK_OFFSET_VALID;\n\n}\n", "idx": 27000}
{"project": "qemu", "commit_id": "74475455442398a64355428b37422d14ccc293cb", "target": 0, "func": "static int no_run_in (HWVoiceIn *hw)\n\n{\n\n    NoVoiceIn *no = (NoVoiceIn *) hw;\n\n    int live = audio_pcm_hw_get_live_in (hw);\n\n    int dead = hw->samples - live;\n\n    int samples = 0;\n\n\n\n    if (dead) {\n\n        int64_t now = qemu_get_clock (vm_clock);\n\n        int64_t ticks = now - no->old_ticks;\n\n        int64_t bytes =\n\n            muldiv64 (ticks, hw->info.bytes_per_second, get_ticks_per_sec ());\n\n\n\n        no->old_ticks = now;\n\n        bytes = audio_MIN (bytes, INT_MAX);\n\n        samples = bytes >> hw->info.shift;\n\n        samples = audio_MIN (samples, dead);\n\n    }\n\n    return samples;\n\n}\n", "idx": 27001}
{"project": "qemu", "commit_id": "95251725e335af2b885e2ab33dd29c86f8084663", "target": 0, "func": "int vfio_region_setup(Object *obj, VFIODevice *vbasedev, VFIORegion *region,\n\n                      int index, const char *name)\n\n{\n\n    struct vfio_region_info *info;\n\n    int ret;\n\n\n\n    ret = vfio_get_region_info(vbasedev, index, &info);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    region->vbasedev = vbasedev;\n\n    region->flags = info->flags;\n\n    region->size = info->size;\n\n    region->fd_offset = info->offset;\n\n    region->nr = index;\n\n\n\n    if (region->size) {\n\n        region->mem = g_new0(MemoryRegion, 1);\n\n        memory_region_init_io(region->mem, obj, &vfio_region_ops,\n\n                              region, name, region->size);\n\n\n\n        if (!vbasedev->no_mmap &&\n\n            region->flags & VFIO_REGION_INFO_FLAG_MMAP &&\n\n            !(region->size & ~qemu_real_host_page_mask)) {\n\n\n\n            ret = vfio_setup_region_sparse_mmaps(region, info);\n\n\n\n            if (ret) {\n\n                region->nr_mmaps = 1;\n\n                region->mmaps = g_new0(VFIOMmap, region->nr_mmaps);\n\n                region->mmaps[0].offset = 0;\n\n                region->mmaps[0].size = region->size;\n\n            }\n\n        }\n\n    }\n\n\n\n    g_free(info);\n\n\n\n    trace_vfio_region_setup(vbasedev->name, index, name,\n\n                            region->flags, region->fd_offset, region->size);\n\n    return 0;\n\n}\n", "idx": 27002}
{"project": "qemu", "commit_id": "d1fdf257d52822695f5ace6c586e059aa17d4b79", "target": 0, "func": "static ssize_t nbd_co_send_reply(NBDRequestData *req, NBDReply *reply,\n\n                                 int len)\n\n{\n\n    NBDClient *client = req->client;\n\n    ssize_t rc, ret;\n\n\n\n    g_assert(qemu_in_coroutine());\n\n    qemu_co_mutex_lock(&client->send_lock);\n\n    client->send_coroutine = qemu_coroutine_self();\n\n\n\n    if (!len) {\n\n        rc = nbd_send_reply(client->ioc, reply);\n\n    } else {\n\n        qio_channel_set_cork(client->ioc, true);\n\n        rc = nbd_send_reply(client->ioc, reply);\n\n        if (rc >= 0) {\n\n            ret = write_sync(client->ioc, req->data, len, NULL);\n\n            if (ret < 0) {\n\n                rc = -EIO;\n\n            }\n\n        }\n\n        qio_channel_set_cork(client->ioc, false);\n\n    }\n\n\n\n    client->send_coroutine = NULL;\n\n    qemu_co_mutex_unlock(&client->send_lock);\n\n    return rc;\n\n}\n", "idx": 27003}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "static void kzm_init(MachineState *machine)\n\n{\n\n    IMX31KZM *s = g_new0(IMX31KZM, 1);\n\n    unsigned int ram_size;\n\n    unsigned int alias_offset;\n\n    unsigned int i;\n\n\n\n    object_initialize(&s->soc, sizeof(s->soc), TYPE_FSL_IMX31);\n\n    object_property_add_child(OBJECT(machine), \"soc\", OBJECT(&s->soc),\n\n                              &error_abort);\n\n\n\n    object_property_set_bool(OBJECT(&s->soc), true, \"realized\", &error_fatal);\n\n\n\n    /* Check the amount of memory is compatible with the SOC */\n\n    if (machine->ram_size > (FSL_IMX31_SDRAM0_SIZE + FSL_IMX31_SDRAM1_SIZE)) {\n\n        error_report(\"WARNING: RAM size \" RAM_ADDR_FMT \" above max supported, \"\n\n                     \"reduced to %x\", machine->ram_size,\n\n                     FSL_IMX31_SDRAM0_SIZE + FSL_IMX31_SDRAM1_SIZE);\n\n        machine->ram_size = FSL_IMX31_SDRAM0_SIZE + FSL_IMX31_SDRAM1_SIZE;\n\n    }\n\n\n\n    memory_region_allocate_system_memory(&s->ram, NULL, \"kzm.ram\",\n\n                                         machine->ram_size);\n\n    memory_region_add_subregion(get_system_memory(), FSL_IMX31_SDRAM0_ADDR,\n\n                                &s->ram);\n\n\n\n    /* initialize the alias memory if any */\n\n    for (i = 0, ram_size = machine->ram_size, alias_offset = 0;\n\n         (i < 2) && ram_size; i++) {\n\n        unsigned int size;\n\n        static const struct {\n\n            hwaddr addr;\n\n            unsigned int size;\n\n        } ram[2] = {\n\n            { FSL_IMX31_SDRAM0_ADDR, FSL_IMX31_SDRAM0_SIZE },\n\n            { FSL_IMX31_SDRAM1_ADDR, FSL_IMX31_SDRAM1_SIZE },\n\n        };\n\n\n\n        size = MIN(ram_size, ram[i].size);\n\n\n\n        ram_size -= size;\n\n\n\n        if (size < ram[i].size) {\n\n            memory_region_init_alias(&s->ram_alias, NULL, \"ram.alias\",\n\n                                     &s->ram, alias_offset, ram[i].size - size);\n\n            memory_region_add_subregion(get_system_memory(),\n\n                                        ram[i].addr + size, &s->ram_alias);\n\n        }\n\n\n\n        alias_offset += ram[i].size;\n\n    }\n\n\n\n    if (nd_table[0].used) {\n\n        lan9118_init(&nd_table[0], KZM_LAN9118_ADDR,\n\n                     qdev_get_gpio_in(DEVICE(&s->soc.avic), 52));\n\n    }\n\n\n\n    if (serial_hds[2]) { /* touchscreen */\n\n        serial_mm_init(get_system_memory(), KZM_FPGA_ADDR+0x10, 0,\n\n                       qdev_get_gpio_in(DEVICE(&s->soc.avic), 52),\n\n                       14745600, serial_hds[2], DEVICE_NATIVE_ENDIAN);\n\n    }\n\n\n\n    kzm_binfo.ram_size = machine->ram_size;\n\n    kzm_binfo.kernel_filename = machine->kernel_filename;\n\n    kzm_binfo.kernel_cmdline = machine->kernel_cmdline;\n\n    kzm_binfo.initrd_filename = machine->initrd_filename;\n\n    kzm_binfo.nb_cpus = 1;\n\n\n\n    if (!qtest_enabled()) {\n\n        arm_load_kernel(&s->soc.cpu, &kzm_binfo);\n\n    }\n\n}\n", "idx": 27004}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "const char *bdrv_get_device_name(const BlockDriverState *bs)\n\n{\n\n    return bs->blk ? blk_name(bs->blk) : \"\";\n\n}\n", "idx": 27006}
{"project": "qemu", "commit_id": "c5b9729ae918b890905e00870ffc08c9b56e6d17", "target": 0, "func": "void helper_4xx_tlbwe_hi (target_ulong entry, target_ulong val)\n\n{\n\n    ppcemb_tlb_t *tlb;\n\n    target_ulong page, end;\n\n\n\n    LOG_SWTLB(\"%s entry %d val \" TARGET_FMT_lx \"\\n\", __func__, (int)entry,\n\n              val);\n\n    entry &= 0x3F;\n\n    tlb = &env->tlb[entry].tlbe;\n\n    /* Invalidate previous TLB (if it's valid) */\n\n    if (tlb->prot & PAGE_VALID) {\n\n        end = tlb->EPN + tlb->size;\n\n        LOG_SWTLB(\"%s: invalidate old TLB %d start \" TARGET_FMT_lx \" end \"\n\n                  TARGET_FMT_lx \"\\n\", __func__, (int)entry, tlb->EPN, end);\n\n        for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE)\n\n            tlb_flush_page(env, page);\n\n    }\n\n    tlb->size = booke_tlb_to_page_size((val >> 7) & 0x7);\n\n    /* We cannot handle TLB size < TARGET_PAGE_SIZE.\n\n     * If this ever occurs, one should use the ppcemb target instead\n\n     * of the ppc or ppc64 one\n\n     */\n\n    if ((val & 0x40) && tlb->size < TARGET_PAGE_SIZE) {\n\n        cpu_abort(env, \"TLB size \" TARGET_FMT_lu \" < %u \"\n\n                  \"are not supported (%d)\\n\",\n\n                  tlb->size, TARGET_PAGE_SIZE, (int)((val >> 7) & 0x7));\n\n    }\n\n    tlb->EPN = val & ~(tlb->size - 1);\n\n    if (val & 0x40)\n\n        tlb->prot |= PAGE_VALID;\n\n    else\n\n        tlb->prot &= ~PAGE_VALID;\n\n    if (val & 0x20) {\n\n        /* XXX: TO BE FIXED */\n\n        cpu_abort(env, \"Little-endian TLB entries are not supported by now\\n\");\n\n    }\n\n    tlb->PID = env->spr[SPR_40x_PID]; /* PID */\n\n    LOG_SWTLB(\"%s: set up TLB %d RPN \" TARGET_FMT_plx \" EPN \" TARGET_FMT_lx\n\n              \" size \" TARGET_FMT_lx \" prot %c%c%c%c PID %d\\n\", __func__,\n\n              (int)entry, tlb->RPN, tlb->EPN, tlb->size,\n\n              tlb->prot & PAGE_READ ? 'r' : '-',\n\n              tlb->prot & PAGE_WRITE ? 'w' : '-',\n\n              tlb->prot & PAGE_EXEC ? 'x' : '-',\n\n              tlb->prot & PAGE_VALID ? 'v' : '-', (int)tlb->PID);\n\n    /* Invalidate new TLB (if valid) */\n\n    if (tlb->prot & PAGE_VALID) {\n\n        end = tlb->EPN + tlb->size;\n\n        LOG_SWTLB(\"%s: invalidate TLB %d start \" TARGET_FMT_lx \" end \"\n\n                  TARGET_FMT_lx \"\\n\", __func__, (int)entry, tlb->EPN, end);\n\n        for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE)\n\n            tlb_flush_page(env, page);\n\n    }\n\n}\n", "idx": 27007}
{"project": "qemu", "commit_id": "8dfbaa6ac450c4ec2646b1ca08a4017052a90c1d", "target": 0, "func": "static int virtio_ccw_hcall_notify(const uint64_t *args)\n\n{\n\n    uint64_t subch_id = args[0];\n\n    uint64_t queue = args[1];\n\n    SubchDev *sch;\n\n    int cssid, ssid, schid, m;\n\n\n\n    if (ioinst_disassemble_sch_ident(subch_id, &m, &cssid, &ssid, &schid)) {\n\n        return -EINVAL;\n\n    }\n\n    sch = css_find_subch(m, cssid, ssid, schid);\n\n    if (!sch || !css_subch_visible(sch)) {\n\n        return -EINVAL;\n\n    }\n\n    if (queue >= VIRTIO_PCI_QUEUE_MAX) {\n\n        return -EINVAL;\n\n    }\n\n    virtio_queue_notify(virtio_ccw_get_vdev(sch), queue);\n\n    return 0;\n\n\n\n}\n", "idx": 27008}
{"project": "qemu", "commit_id": "36778660d7fd0748a6129916e47ecedd67bdb758", "target": 0, "func": "static void mmu6xx_dump_mmu(FILE *f, fprintf_function cpu_fprintf,\n\n                            CPUPPCState *env)\n\n{\n\n    ppc6xx_tlb_t *tlb;\n\n    target_ulong sr;\n\n    int type, way, entry, i;\n\n\n\n    cpu_fprintf(f, \"HTAB base = 0x%\"HWADDR_PRIx\"\\n\", env->htab_base);\n\n    cpu_fprintf(f, \"HTAB mask = 0x%\"HWADDR_PRIx\"\\n\", env->htab_mask);\n\n\n\n    cpu_fprintf(f, \"\\nSegment registers:\\n\");\n\n    for (i = 0; i < 32; i++) {\n\n        sr = env->sr[i];\n\n        if (sr & 0x80000000) {\n\n            cpu_fprintf(f, \"%02d T=%d Ks=%d Kp=%d BUID=0x%03x \"\n\n                        \"CNTLR_SPEC=0x%05x\\n\", i,\n\n                        sr & 0x80000000 ? 1 : 0, sr & 0x40000000 ? 1 : 0,\n\n                        sr & 0x20000000 ? 1 : 0, (uint32_t)((sr >> 20) & 0x1FF),\n\n                        (uint32_t)(sr & 0xFFFFF));\n\n        } else {\n\n            cpu_fprintf(f, \"%02d T=%d Ks=%d Kp=%d N=%d VSID=0x%06x\\n\", i,\n\n                        sr & 0x80000000 ? 1 : 0, sr & 0x40000000 ? 1 : 0,\n\n                        sr & 0x20000000 ? 1 : 0, sr & 0x10000000 ? 1 : 0,\n\n                        (uint32_t)(sr & 0x00FFFFFF));\n\n        }\n\n    }\n\n\n\n    cpu_fprintf(f, \"\\nBATs:\\n\");\n\n    mmu6xx_dump_BATs(f, cpu_fprintf, env, ACCESS_INT);\n\n    mmu6xx_dump_BATs(f, cpu_fprintf, env, ACCESS_CODE);\n\n\n\n    if (env->id_tlbs != 1) {\n\n        cpu_fprintf(f, \"ERROR: 6xx MMU should have separated TLB\"\n\n                    \" for code and data\\n\");\n\n    }\n\n\n\n    cpu_fprintf(f, \"\\nTLBs                       [EPN    EPN + SIZE]\\n\");\n\n\n\n    for (type = 0; type < 2; type++) {\n\n        for (way = 0; way < env->nb_ways; way++) {\n\n            for (entry = env->nb_tlb * type + env->tlb_per_way * way;\n\n                 entry < (env->nb_tlb * type + env->tlb_per_way * (way + 1));\n\n                 entry++) {\n\n\n\n                tlb = &env->tlb.tlb6[entry];\n\n                cpu_fprintf(f, \"%s TLB %02d/%02d way:%d %s [\"\n\n                            TARGET_FMT_lx \" \" TARGET_FMT_lx \"]\\n\",\n\n                            type ? \"code\" : \"data\", entry % env->nb_tlb,\n\n                            env->nb_tlb, way,\n\n                            pte_is_valid(tlb->pte0) ? \"valid\" : \"inval\",\n\n                            tlb->EPN, tlb->EPN + TARGET_PAGE_SIZE);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 27009}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static SocketAddress *nbd_build_socket_address(const char *sockpath,\n\n                                               const char *bindto,\n\n                                               const char *port)\n\n{\n\n    SocketAddress *saddr;\n\n\n\n    saddr = g_new0(SocketAddress, 1);\n\n    if (sockpath) {\n\n        saddr->type = SOCKET_ADDRESS_KIND_UNIX;\n\n        saddr->u.q_unix.data = g_new0(UnixSocketAddress, 1);\n\n        saddr->u.q_unix.data->path = g_strdup(sockpath);\n\n    } else {\n\n        InetSocketAddress *inet;\n\n        saddr->type = SOCKET_ADDRESS_KIND_INET;\n\n        inet = saddr->u.inet.data = g_new0(InetSocketAddress, 1);\n\n        inet->host = g_strdup(bindto);\n\n        if (port) {\n\n            inet->port = g_strdup(port);\n\n        } else  {\n\n            inet->port = g_strdup_printf(\"%d\", NBD_DEFAULT_PORT);\n\n        }\n\n    }\n\n\n\n    return saddr;\n\n}\n", "idx": 27010}
{"project": "qemu", "commit_id": "8c9a2b71de67742b40870da22abeccab57c81924", "target": 0, "func": "static void select_vgahw (const char *p)\n\n{\n\n    const char *opts;\n\n\n\n    assert(vga_interface_type == VGA_NONE);\n\n    if (strstart(p, \"std\", &opts)) {\n\n        if (vga_available()) {\n\n            vga_interface_type = VGA_STD;\n\n        } else {\n\n            error_report(\"standard VGA not available\");\n\n            exit(1);\n\n        }\n\n    } else if (strstart(p, \"cirrus\", &opts)) {\n\n        if (cirrus_vga_available()) {\n\n            vga_interface_type = VGA_CIRRUS;\n\n        } else {\n\n            error_report(\"Cirrus VGA not available\");\n\n            exit(1);\n\n        }\n\n    } else if (strstart(p, \"vmware\", &opts)) {\n\n        if (vmware_vga_available()) {\n\n            vga_interface_type = VGA_VMWARE;\n\n        } else {\n\n            error_report(\"VMWare SVGA not available\");\n\n            exit(1);\n\n        }\n\n    } else if (strstart(p, \"virtio\", &opts)) {\n\n        if (virtio_vga_available()) {\n\n            vga_interface_type = VGA_VIRTIO;\n\n        } else {\n\n            error_report(\"Virtio VGA not available\");\n\n            exit(1);\n\n        }\n\n    } else if (strstart(p, \"xenfb\", &opts)) {\n\n        vga_interface_type = VGA_XENFB;\n\n    } else if (strstart(p, \"qxl\", &opts)) {\n\n        if (qxl_vga_available()) {\n\n            vga_interface_type = VGA_QXL;\n\n        } else {\n\n            error_report(\"QXL VGA not available\");\n\n            exit(1);\n\n        }\n\n    } else if (strstart(p, \"tcx\", &opts)) {\n\n        if (tcx_vga_available()) {\n\n            vga_interface_type = VGA_TCX;\n\n        } else {\n\n            error_report(\"TCX framebuffer not available\");\n\n            exit(1);\n\n        }\n\n    } else if (strstart(p, \"cg3\", &opts)) {\n\n        if (cg3_vga_available()) {\n\n            vga_interface_type = VGA_CG3;\n\n        } else {\n\n            error_report(\"CG3 framebuffer not available\");\n\n            exit(1);\n\n        }\n\n    } else if (!strstart(p, \"none\", &opts)) {\n\n    invalid_vga:\n\n        error_report(\"unknown vga type: %s\", p);\n\n        exit(1);\n\n    }\n\n    while (*opts) {\n\n        const char *nextopt;\n\n\n\n        if (strstart(opts, \",retrace=\", &nextopt)) {\n\n            opts = nextopt;\n\n            if (strstart(opts, \"dumb\", &nextopt))\n\n                vga_retrace_method = VGA_RETRACE_DUMB;\n\n            else if (strstart(opts, \"precise\", &nextopt))\n\n                vga_retrace_method = VGA_RETRACE_PRECISE;\n\n            else goto invalid_vga;\n\n        } else goto invalid_vga;\n\n        opts = nextopt;\n\n    }\n\n}\n", "idx": 27011}
{"project": "qemu", "commit_id": "1ec26c757d5996468afcc0dced4fad04139574b3", "target": 0, "func": "static target_ulong h_resize_hpt_commit(PowerPCCPU *cpu,\n\n                                        sPAPRMachineState *spapr,\n\n                                        target_ulong opcode,\n\n                                        target_ulong *args)\n\n{\n\n    target_ulong flags = args[0];\n\n    target_ulong shift = args[1];\n\n    sPAPRPendingHPT *pending = spapr->pending_hpt;\n\n    int rc;\n\n    size_t newsize;\n\n\n\n    if (spapr->resize_hpt == SPAPR_RESIZE_HPT_DISABLED) {\n\n        return H_AUTHORITY;\n\n    }\n\n\n\n    trace_spapr_h_resize_hpt_commit(flags, shift);\n\n\n\n    rc = kvmppc_resize_hpt_commit(cpu, flags, shift);\n\n    if (rc != -ENOSYS) {\n\n        return resize_hpt_convert_rc(rc);\n\n    }\n\n\n\n    if (flags != 0) {\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    if (!pending || (pending->shift != shift)) {\n\n        /* no matching prepare */\n\n        return H_CLOSED;\n\n    }\n\n\n\n    if (!pending->complete) {\n\n        /* prepare has not completed */\n\n        return H_BUSY;\n\n    }\n\n\n\n    /* Shouldn't have got past PREPARE without an HPT */\n\n    g_assert(spapr->htab_shift);\n\n\n\n    newsize = 1ULL << pending->shift;\n\n    rc = rehash_hpt(cpu, spapr->htab, HTAB_SIZE(spapr),\n\n                    pending->hpt, newsize);\n\n    if (rc == H_SUCCESS) {\n\n        qemu_vfree(spapr->htab);\n\n        spapr->htab = pending->hpt;\n\n        spapr->htab_shift = pending->shift;\n\n\n\n        if (kvm_enabled()) {\n\n            /* For KVM PR, update the HPT pointer */\n\n            target_ulong sdr1 = (target_ulong)(uintptr_t)spapr->htab\n\n                | (spapr->htab_shift - 18);\n\n            kvmppc_update_sdr1(sdr1);\n\n        }\n\n\n\n        pending->hpt = NULL; /* so it's not free()d */\n\n    }\n\n\n\n    /* Clean up */\n\n    spapr->pending_hpt = NULL;\n\n    free_pending_hpt(pending);\n\n\n\n    return rc;\n\n}\n", "idx": 27012}
{"project": "qemu", "commit_id": "c6bf8e0e0cf04b40a8a22426e00ebbd727331d8b", "target": 0, "func": "static inline void migration_bitmap_set_dirty(MemoryRegion *mr, int length)\n\n{\n\n    ram_addr_t addr;\n\n\n\n    for (addr = 0; addr < length; addr += TARGET_PAGE_SIZE) {\n\n        if (!memory_region_get_dirty(mr, addr, TARGET_PAGE_SIZE,\n\n                                     DIRTY_MEMORY_MIGRATION)) {\n\n            memory_region_set_dirty(mr, addr, TARGET_PAGE_SIZE);\n\n        }\n\n    }\n\n}\n", "idx": 27013}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "static int piix3_pre_save(void *opaque)\n\n{\n\n    int i;\n\n    PIIX3State *piix3 = opaque;\n\n\n\n    for (i = 0; i < ARRAY_SIZE(piix3->pci_irq_levels_vmstate); i++) {\n\n        piix3->pci_irq_levels_vmstate[i] =\n\n            pci_bus_get_irq_level(piix3->dev.bus, i);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 27014}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static void send_qmp_error_event(BlockDriverState *bs,\n\n                                 BlockErrorAction action,\n\n                                 bool is_read, int error)\n\n{\n\n    IoOperationType optype;\n\n\n\n    optype = is_read ? IO_OPERATION_TYPE_READ : IO_OPERATION_TYPE_WRITE;\n\n    qapi_event_send_block_io_error(bdrv_get_device_name(bs), optype, action,\n\n                                   bdrv_iostatus_is_enabled(bs),\n\n                                   error == ENOSPC, strerror(error),\n\n                                   &error_abort);\n\n}\n", "idx": 27015}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static int vnc_display_get_address(const char *addrstr,\n\n                                   bool websocket,\n\n                                   bool reverse,\n\n                                   int displaynum,\n\n                                   int to,\n\n                                   bool has_ipv4,\n\n                                   bool has_ipv6,\n\n                                   bool ipv4,\n\n                                   bool ipv6,\n\n                                   SocketAddressLegacy **retaddr,\n\n                                   Error **errp)\n\n{\n\n    int ret = -1;\n\n    SocketAddressLegacy *addr = NULL;\n\n\n\n    addr = g_new0(SocketAddressLegacy, 1);\n\n\n\n    if (strncmp(addrstr, \"unix:\", 5) == 0) {\n\n        addr->type = SOCKET_ADDRESS_LEGACY_KIND_UNIX;\n\n        addr->u.q_unix.data = g_new0(UnixSocketAddress, 1);\n\n        addr->u.q_unix.data->path = g_strdup(addrstr + 5);\n\n\n\n        if (websocket) {\n\n            error_setg(errp, \"UNIX sockets not supported with websock\");\n\n            goto cleanup;\n\n        }\n\n\n\n        if (to) {\n\n            error_setg(errp, \"Port range not support with UNIX socket\");\n\n            goto cleanup;\n\n        }\n\n        ret = 0;\n\n    } else {\n\n        const char *port;\n\n        size_t hostlen;\n\n        unsigned long long baseport = 0;\n\n        InetSocketAddress *inet;\n\n\n\n        port = strrchr(addrstr, ':');\n\n        if (!port) {\n\n            if (websocket) {\n\n                hostlen = 0;\n\n                port = addrstr;\n\n            } else {\n\n                error_setg(errp, \"no vnc port specified\");\n\n                goto cleanup;\n\n            }\n\n        } else {\n\n            hostlen = port - addrstr;\n\n            port++;\n\n            if (*port == '\\0') {\n\n                error_setg(errp, \"vnc port cannot be empty\");\n\n                goto cleanup;\n\n            }\n\n        }\n\n\n\n        addr->type = SOCKET_ADDRESS_LEGACY_KIND_INET;\n\n        inet = addr->u.inet.data = g_new0(InetSocketAddress, 1);\n\n        if (addrstr[0] == '[' && addrstr[hostlen - 1] == ']') {\n\n            inet->host = g_strndup(addrstr + 1, hostlen - 2);\n\n        } else {\n\n            inet->host = g_strndup(addrstr, hostlen);\n\n        }\n\n        /* plain VNC port is just an offset, for websocket\n\n         * port is absolute */\n\n        if (websocket) {\n\n            if (g_str_equal(addrstr, \"\") ||\n\n                g_str_equal(addrstr, \"on\")) {\n\n                if (displaynum == -1) {\n\n                    error_setg(errp, \"explicit websocket port is required\");\n\n                    goto cleanup;\n\n                }\n\n                inet->port = g_strdup_printf(\n\n                    \"%d\", displaynum + 5700);\n\n                if (to) {\n\n                    inet->has_to = true;\n\n                    inet->to = to + 5700;\n\n                }\n\n            } else {\n\n                inet->port = g_strdup(port);\n\n            }\n\n        } else {\n\n            int offset = reverse ? 0 : 5900;\n\n            if (parse_uint_full(port, &baseport, 10) < 0) {\n\n                error_setg(errp, \"can't convert to a number: %s\", port);\n\n                goto cleanup;\n\n            }\n\n            if (baseport > 65535 ||\n\n                baseport + offset > 65535) {\n\n                error_setg(errp, \"port %s out of range\", port);\n\n                goto cleanup;\n\n            }\n\n            inet->port = g_strdup_printf(\n\n                \"%d\", (int)baseport + offset);\n\n\n\n            if (to) {\n\n                inet->has_to = true;\n\n                inet->to = to + offset;\n\n            }\n\n        }\n\n\n\n        inet->ipv4 = ipv4;\n\n        inet->has_ipv4 = has_ipv4;\n\n        inet->ipv6 = ipv6;\n\n        inet->has_ipv6 = has_ipv6;\n\n\n\n        ret = baseport;\n\n    }\n\n\n\n    *retaddr = addr;\n\n\n\n cleanup:\n\n    if (ret < 0) {\n\n        qapi_free_SocketAddressLegacy(addr);\n\n    }\n\n    return ret;\n\n}\n", "idx": 27017}
{"project": "qemu", "commit_id": "3494d650273e619606c6cb2c38aa9b8b7bed98e2", "target": 1, "func": "static size_t curl_size_cb(void *ptr, size_t size, size_t nmemb, void *opaque)\n\n{\n\n    CURLState *s = ((CURLState*)opaque);\n\n    size_t realsize = size * nmemb;\n\n    size_t fsize;\n\n\n\n    if(sscanf(ptr, \"Content-Length: %zd\", &fsize) == 1) {\n\n        s->s->len = fsize;\n\n    }\n\n\n\n    return realsize;\n\n}\n", "idx": 27020}
{"project": "qemu", "commit_id": "fd563564222f308e1d86847efdec8555fb472536", "target": 1, "func": "static void kvm_update_msi_routes_all(void *private, bool global,\n\n                                      uint32_t index, uint32_t mask)\n\n{\n\n    int cnt = 0;\n\n    MSIRouteEntry *entry;\n\n    MSIMessage msg;\n\n    /* TODO: explicit route update */\n\n    QLIST_FOREACH(entry, &msi_route_list, list) {\n\n        cnt++;\n\n        msg = pci_get_msi_message(entry->dev, entry->vector);\n\n        kvm_irqchip_update_msi_route(kvm_state, entry->virq,\n\n                                     msg, entry->dev);\n\n    }\n\n    kvm_irqchip_commit_routes(kvm_state);\n\n    trace_kvm_x86_update_msi_routes(cnt);\n\n}\n", "idx": 27021}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void fw_cfg_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = fw_cfg_realize;\n\n    dc->no_user = 1;\n\n    dc->reset = fw_cfg_reset;\n\n    dc->vmsd = &vmstate_fw_cfg;\n\n    dc->props = fw_cfg_properties;\n\n}\n", "idx": 27023}
{"project": "qemu", "commit_id": "f3c75d42adbba553eaf218a832d4fbea32c8f7b8", "target": 1, "func": "static target_ulong h_read(PowerPCCPU *cpu, sPAPREnvironment *spapr,\n\n                           target_ulong opcode, target_ulong *args)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    target_ulong flags = args[0];\n\n    target_ulong pte_index = args[1];\n\n    uint8_t *hpte;\n\n    int i, ridx, n_entries = 1;\n\n\n\n    if ((pte_index * HASH_PTE_SIZE_64) & ~env->htab_mask) {\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    if (flags & H_READ_4) {\n\n        /* Clear the two low order bits */\n\n        pte_index &= ~(3ULL);\n\n        n_entries = 4;\n\n    }\n\n\n\n    hpte = env->external_htab + (pte_index * HASH_PTE_SIZE_64);\n\n\n\n    for (i = 0, ridx = 0; i < n_entries; i++) {\n\n        args[ridx++] = ldq_p(hpte);\n\n        args[ridx++] = ldq_p(hpte + (HASH_PTE_SIZE_64/2));\n\n        hpte += HASH_PTE_SIZE_64;\n\n    }\n\n\n\n    return H_SUCCESS;\n\n}\n", "idx": 27024}
{"project": "qemu", "commit_id": "c8a9fd80719e63615dac12e3625223fb54aa8430", "target": 1, "func": "static int bdrv_co_do_ioctl(BlockDriverState *bs, int req, void *buf)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    BdrvTrackedRequest tracked_req;\n\n    CoroutineIOCompletion co = {\n\n        .coroutine = qemu_coroutine_self(),\n\n    };\n\n    BlockAIOCB *acb;\n\n\n\n    tracked_request_begin(&tracked_req, bs, 0, 0, BDRV_TRACKED_IOCTL);\n\n    if (!drv || !drv->bdrv_aio_ioctl) {\n\n        co.ret = -ENOTSUP;\n\n        goto out;\n\n    }\n\n\n\n    acb = drv->bdrv_aio_ioctl(bs, req, buf, bdrv_co_io_em_complete, &co);\n\n    if (!acb) {\n\n        BdrvIoctlCompletionData *data = g_new(BdrvIoctlCompletionData, 1);\n\n        data->bh = aio_bh_new(bdrv_get_aio_context(bs),\n\n                                bdrv_ioctl_bh_cb, data);\n\n        data->co = &co;\n\n        qemu_bh_schedule(data->bh);\n\n    }\n\n    qemu_coroutine_yield();\n\nout:\n\n    tracked_request_end(&tracked_req);\n\n    return co.ret;\n\n}\n", "idx": 27027}
{"project": "qemu", "commit_id": "0c9390d978cbf61e8f16c9f580fa96b305c43568", "target": 1, "func": "void nbd_client_new(NBDExport *exp,\n\n                    QIOChannelSocket *sioc,\n\n                    QCryptoTLSCreds *tlscreds,\n\n                    const char *tlsaclname,\n\n                    void (*close_fn)(NBDClient *))\n\n{\n\n    NBDClient *client;\n\n    NBDClientNewData *data = g_new(NBDClientNewData, 1);\n\n\n\n    client = g_malloc0(sizeof(NBDClient));\n\n    client->refcount = 1;\n\n    client->exp = exp;\n\n    client->tlscreds = tlscreds;\n\n    if (tlscreds) {\n\n        object_ref(OBJECT(client->tlscreds));\n\n    }\n\n    client->tlsaclname = g_strdup(tlsaclname);\n\n    client->sioc = sioc;\n\n    object_ref(OBJECT(client->sioc));\n\n    client->ioc = QIO_CHANNEL(sioc);\n\n    object_ref(OBJECT(client->ioc));\n\n    client->close = close_fn;\n\n\n\n    data->client = client;\n\n    data->co = qemu_coroutine_create(nbd_co_client_start, data);\n\n    qemu_coroutine_enter(data->co);\n\n}\n", "idx": 27030}
{"project": "qemu", "commit_id": "0e321191224c8cd137eef41da3257e096965c3d6", "target": 1, "func": "void hbitmap_set(HBitmap *hb, uint64_t start, uint64_t count)\n\n{\n\n    /* Compute range in the last layer.  */\n\n    uint64_t last = start + count - 1;\n\n\n\n    trace_hbitmap_set(hb, start, count,\n\n                      start >> hb->granularity, last >> hb->granularity);\n\n\n\n    start >>= hb->granularity;\n\n    last >>= hb->granularity;\n\n    count = last - start + 1;\n\n\n\n\n    hb->count += count - hb_count_between(hb, start, last);\n\n    hb_set_between(hb, HBITMAP_LEVELS - 1, start, last);\n\n}", "idx": 27031}
{"project": "qemu", "commit_id": "016d2e1dfa21b64a524d3629fdd317d4c25bc3b8", "target": 1, "func": "long do_sigreturn(CPUAlphaState *env)\n\n{\n\n    struct target_sigcontext *sc;\n\n    abi_ulong sc_addr = env->ir[IR_A0];\n\n    target_sigset_t target_set;\n\n    sigset_t set;\n\n\n\n    if (!lock_user_struct(VERIFY_READ, sc, sc_addr, 1)) {\n\n        goto badframe;\n\n    }\n\n\n\n    target_sigemptyset(&target_set);\n\n    if (__get_user(target_set.sig[0], &sc->sc_mask)) {\n\n        goto badframe;\n\n    }\n\n\n\n    target_to_host_sigset_internal(&set, &target_set);\n\n    do_sigprocmask(SIG_SETMASK, &set, NULL);\n\n\n\n    if (restore_sigcontext(env, sc)) {\n\n        goto badframe;\n\n    }\n\n    unlock_user_struct(sc, sc_addr, 0);\n\n    return env->ir[IR_V0];\n\n\n\n badframe:\n\n    unlock_user_struct(sc, sc_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n}\n", "idx": 27034}
{"project": "qemu", "commit_id": "6460440f34c709461b84375cfd8a86b27d433225", "target": 1, "func": "static void coroutine_fn wait_serialising_requests(BdrvTrackedRequest *self)\n\n{\n\n    BlockDriverState *bs = self->bs;\n\n    BdrvTrackedRequest *req;\n\n    bool retry;\n\n\n\n    if (!bs->serialising_in_flight) {\n\n        return;\n\n    }\n\n\n\n    do {\n\n        retry = false;\n\n        QLIST_FOREACH(req, &bs->tracked_requests, list) {\n\n            if (req == self || (!req->serialising && !self->serialising)) {\n\n                continue;\n\n            }\n\n            if (tracked_request_overlaps(req, self->overlap_offset,\n\n                                         self->overlap_bytes))\n\n            {\n\n                /* Hitting this means there was a reentrant request, for\n\n                 * example, a block driver issuing nested requests.  This must\n\n                 * never happen since it means deadlock.\n\n                 */\n\n                assert(qemu_coroutine_self() != req->co);\n\n\n\n                qemu_co_queue_wait(&req->wait_queue);\n\n                retry = true;\n\n                break;\n\n            }\n\n        }\n\n    } while (retry);\n\n}\n", "idx": 27035}
{"project": "qemu", "commit_id": "21ce148c7ec71ee32834061355a5ecfd1a11f90f", "target": 1, "func": "static inline void cris_fidx_i(unsigned int x)\n\n{\n\n\tregister unsigned int v asm(\"$r10\") = x;\n\n\tasm (\"fidxi\\t[%0]\\n\" : : \"r\" (v) );\n\n}\n", "idx": 27036}
{"project": "qemu", "commit_id": "48b3ed0a68b8c1b288b4e15743ea39b7b5b318c3", "target": 1, "func": "void qemu_spice_init(void)\n\n{\n\n    QemuOpts *opts = QTAILQ_FIRST(&qemu_spice_opts.head);\n\n    const char *password, *str, *x509_dir, *addr,\n\n        *x509_key_password = NULL,\n\n        *x509_dh_file = NULL,\n\n        *tls_ciphers = NULL;\n\n    char *x509_key_file = NULL,\n\n        *x509_cert_file = NULL,\n\n        *x509_cacert_file = NULL;\n\n    int port, tls_port, len, addr_flags;\n\n    spice_image_compression_t compression;\n\n    spice_wan_compression_t wan_compr;\n\n\n\n    if (!opts) {\n\n        return;\n\n\n    port = qemu_opt_get_number(opts, \"port\", 0);\n\n    tls_port = qemu_opt_get_number(opts, \"tls-port\", 0);\n\n    if (!port && !tls_port) {\n\n        return;\n\n\n    password = qemu_opt_get(opts, \"password\");\n\n\n\n    if (tls_port) {\n\n        x509_dir = qemu_opt_get(opts, \"x509-dir\");\n\n        if (NULL == x509_dir) {\n\n            x509_dir = \".\";\n\n\n        len = strlen(x509_dir) + 32;\n\n\n\n        str = qemu_opt_get(opts, \"x509-key-file\");\n\n        if (str) {\n\n            x509_key_file = qemu_strdup(str);\n\n        } else {\n\n            x509_key_file = qemu_malloc(len);\n\n            snprintf(x509_key_file, len, \"%s/%s\", x509_dir, X509_SERVER_KEY_FILE);\n\n\n\n\n        str = qemu_opt_get(opts, \"x509-cert-file\");\n\n        if (str) {\n\n            x509_cert_file = qemu_strdup(str);\n\n        } else {\n\n            x509_cert_file = qemu_malloc(len);\n\n            snprintf(x509_cert_file, len, \"%s/%s\", x509_dir, X509_SERVER_CERT_FILE);\n\n\n\n\n        str = qemu_opt_get(opts, \"x509-cacert-file\");\n\n        if (str) {\n\n            x509_cacert_file = qemu_strdup(str);\n\n        } else {\n\n            x509_cacert_file = qemu_malloc(len);\n\n            snprintf(x509_cacert_file, len, \"%s/%s\", x509_dir, X509_CA_CERT_FILE);\n\n\n\n\n        x509_key_password = qemu_opt_get(opts, \"x509-key-password\");\n\n        x509_dh_file = qemu_opt_get(opts, \"x509-dh-file\");\n\n        tls_ciphers = qemu_opt_get(opts, \"tls-ciphers\");\n\n\n\n\n    addr = qemu_opt_get(opts, \"addr\");\n\n    addr_flags = 0;\n\n    if (qemu_opt_get_bool(opts, \"ipv4\", 0)) {\n\n        addr_flags |= SPICE_ADDR_FLAG_IPV4_ONLY;\n\n    } else if (qemu_opt_get_bool(opts, \"ipv6\", 0)) {\n\n        addr_flags |= SPICE_ADDR_FLAG_IPV6_ONLY;\n\n\n\n\n    spice_server = spice_server_new();\n\n    spice_server_set_addr(spice_server, addr ? addr : \"\", addr_flags);\n\n    if (port) {\n\n        spice_server_set_port(spice_server, port);\n\n\n    if (tls_port) {\n\n        spice_server_set_tls(spice_server, tls_port,\n\n                             x509_cacert_file,\n\n                             x509_cert_file,\n\n                             x509_key_file,\n\n                             x509_key_password,\n\n                             x509_dh_file,\n\n                             tls_ciphers);\n\n\n    if (password) {\n\n        spice_server_set_ticket(spice_server, password, 0, 0, 0);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    if (qemu_opt_get_bool(opts, \"disable-ticketing\", 0)) {\n\n        auth = \"none\";\n\n        spice_server_set_noauth(spice_server);\n\n\n\n\n#if SPICE_SERVER_VERSION >= 0x000801\n\n    if (qemu_opt_get_bool(opts, \"disable-copy-paste\", 0)) {\n\n        spice_server_set_agent_copypaste(spice_server, false);\n\n\n\n\n\n    compression = SPICE_IMAGE_COMPRESS_AUTO_GLZ;\n\n    str = qemu_opt_get(opts, \"image-compression\");\n\n    if (str) {\n\n        compression = parse_compression(str);\n\n\n    spice_server_set_image_compression(spice_server, compression);\n\n\n\n    wan_compr = SPICE_WAN_COMPRESSION_AUTO;\n\n    str = qemu_opt_get(opts, \"jpeg-wan-compression\");\n\n    if (str) {\n\n        wan_compr = parse_wan_compression(str);\n\n\n    spice_server_set_jpeg_compression(spice_server, wan_compr);\n\n\n\n    wan_compr = SPICE_WAN_COMPRESSION_AUTO;\n\n    str = qemu_opt_get(opts, \"zlib-glz-wan-compression\");\n\n    if (str) {\n\n        wan_compr = parse_wan_compression(str);\n\n\n    spice_server_set_zlib_glz_compression(spice_server, wan_compr);\n\n\n\n#if SPICE_SERVER_VERSION >= 0x000600 /* 0.6.0 */\n\n\n\n    str = qemu_opt_get(opts, \"streaming-video\");\n\n    if (str) {\n\n        int streaming_video = parse_stream_video(str);\n\n        spice_server_set_streaming_video(spice_server, streaming_video);\n\n\n\n\n    spice_server_set_agent_mouse\n\n        (spice_server, qemu_opt_get_bool(opts, \"agent-mouse\", 1));\n\n    spice_server_set_playback_compression\n\n        (spice_server, qemu_opt_get_bool(opts, \"playback-compression\", 1));\n\n\n\n#endif /* >= 0.6.0 */\n\n\n\n    qemu_opt_foreach(opts, add_channel, NULL, 0);\n\n\n\n    spice_server_init(spice_server, &core_interface);\n\n    using_spice = 1;\n\n\n\n    migration_state.notify = migration_state_notifier;\n\n    add_migration_state_change_notifier(&migration_state);\n\n\n\n    qemu_spice_input_init();\n\n    qemu_spice_audio_init();\n\n\n\n    qemu_free(x509_key_file);\n\n    qemu_free(x509_cert_file);\n\n    qemu_free(x509_cacert_file);\n", "idx": 27037}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void do_store_601_batu (int nr)\n\n{\n\n    do_store_ibatu(env, nr, T0);\n\n    env->DBAT[0][nr] = env->IBAT[0][nr];\n\n    env->DBAT[1][nr] = env->IBAT[1][nr];\n\n}\n", "idx": 27038}
{"project": "qemu", "commit_id": "52579c681cb12bf64de793e85edc50d990f4d42f", "target": 1, "func": "static void dp8393x_realize(DeviceState *dev, Error **errp)\n\n{\n\n    dp8393xState *s = DP8393X(dev);\n\n    int i, checksum;\n\n    uint8_t *prom;\n\n\n\n    address_space_init(&s->as, s->dma_mr, \"dp8393x\");\n\n    memory_region_init_io(&s->mmio, OBJECT(dev), &dp8393x_ops, s,\n\n                          \"dp8393x-regs\", 0x40 << s->it_shift);\n\n\n\n    s->nic = qemu_new_nic(&net_dp83932_info, &s->conf,\n\n                          object_get_typename(OBJECT(dev)), dev->id, s);\n\n    qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);\n\n\n\n    s->watchdog = timer_new_ns(QEMU_CLOCK_VIRTUAL, dp8393x_watchdog, s);\n\n    s->regs[SONIC_SR] = 0x0004; /* only revision recognized by Linux */\n\n\n\n    memory_region_init_rom_device(&s->prom, OBJECT(dev), NULL, NULL,\n\n                                  \"dp8393x-prom\", SONIC_PROM_SIZE, NULL);\n\n    prom = memory_region_get_ram_ptr(&s->prom);\n\n    checksum = 0;\n\n    for (i = 0; i < 6; i++) {\n\n        prom[i] = s->conf.macaddr.a[i];\n\n        checksum += prom[i];\n\n        if (checksum > 0xff) {\n\n            checksum = (checksum + 1) & 0xff;\n\n        }\n\n    }\n\n    prom[7] = 0xff - checksum;\n\n}\n", "idx": 27039}
{"project": "qemu", "commit_id": "7cfd527525a7d6b1c904890a6b84c1227846415e", "target": 1, "func": "void bdrv_round_to_clusters(BlockDriverState *bs,\n\n                            int64_t offset, unsigned int bytes,\n\n                            int64_t *cluster_offset,\n\n                            unsigned int *cluster_bytes)\n\n{\n\n    BlockDriverInfo bdi;\n\n\n\n    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {\n\n        *cluster_offset = offset;\n\n        *cluster_bytes = bytes;\n\n    } else {\n\n        int64_t c = bdi.cluster_size;\n\n        *cluster_offset = QEMU_ALIGN_DOWN(offset, c);\n\n        *cluster_bytes = QEMU_ALIGN_UP(offset - *cluster_offset + bytes, c);\n\n    }\n\n}\n", "idx": 27040}
{"project": "qemu", "commit_id": "786a4ea82ec9c87e3a895cf41081029b285a5fe5", "target": 0, "func": "static uint32_t bonito_sbridge_pciaddr(void *opaque, hwaddr addr)\n\n{\n\n    PCIBonitoState *s = opaque;\n\n    PCIHostState *phb = PCI_HOST_BRIDGE(s->pcihost);\n\n    uint32_t cfgaddr;\n\n    uint32_t idsel;\n\n    uint32_t devno;\n\n    uint32_t funno;\n\n    uint32_t regno;\n\n    uint32_t pciaddr;\n\n\n\n    /* support type0 pci config */\n\n    if ((s->regs[BONITO_PCIMAP_CFG] & 0x10000) != 0x0) {\n\n        return 0xffffffff;\n\n    }\n\n\n\n    cfgaddr = addr & 0xffff;\n\n    cfgaddr |= (s->regs[BONITO_PCIMAP_CFG] & 0xffff) << 16;\n\n\n\n    idsel = (cfgaddr & BONITO_PCICONF_IDSEL_MASK) >> BONITO_PCICONF_IDSEL_OFFSET;\n\n    devno = ffs(idsel) - 1;\n\n    funno = (cfgaddr & BONITO_PCICONF_FUN_MASK) >> BONITO_PCICONF_FUN_OFFSET;\n\n    regno = (cfgaddr & BONITO_PCICONF_REG_MASK) >> BONITO_PCICONF_REG_OFFSET;\n\n\n\n    if (idsel == 0) {\n\n        fprintf(stderr, \"error in bonito pci config address \" TARGET_FMT_plx\n\n            \",pcimap_cfg=%x\\n\", addr, s->regs[BONITO_PCIMAP_CFG]);\n\n        exit(1);\n\n    }\n\n    pciaddr = PCI_ADDR(pci_bus_num(phb->bus), devno, funno, regno);\n\n    DPRINTF(\"cfgaddr %x pciaddr %x busno %x devno %d funno %d regno %d\\n\",\n\n        cfgaddr, pciaddr, pci_bus_num(phb->bus), devno, funno, regno);\n\n\n\n    return pciaddr;\n\n}\n", "idx": 27044}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "static void spr_write_601_ubatu (void *opaque, int sprn)\n\n{\n\n    DisasContext *ctx = opaque;\n\n\n\n    gen_op_store_601_batu((sprn - SPR_IBAT0U) / 2);\n\n    RET_STOP(ctx);\n\n}\n", "idx": 27045}
{"project": "qemu", "commit_id": "e774a278d82c9391c9fb6c9af42cd08bb9364b9f", "target": 0, "func": "static void ide_sector_write(IDEState *s)\n\n{\n\n    int64_t sector_num;\n\n    int ret, n, n1;\n\n\n\n    s->status = READY_STAT | SEEK_STAT;\n\n    sector_num = ide_get_sector(s);\n\n#if defined(DEBUG_IDE)\n\n    printf(\"write sector=%Ld\\n\", sector_num);\n\n#endif\n\n    n = s->nsector;\n\n    if (n > s->req_nb_sectors)\n\n        n = s->req_nb_sectors;\n\n    ret = bdrv_write(s->bs, sector_num, s->io_buffer, n);\n\n    s->nsector -= n;\n\n    if (s->nsector == 0) {\n\n        /* no more sector to write */\n\n        ide_transfer_stop(s);\n\n    } else {\n\n        n1 = s->nsector;\n\n        if (n1 > s->req_nb_sectors)\n\n            n1 = s->req_nb_sectors;\n\n        ide_transfer_start(s, s->io_buffer, 512 * n1, ide_sector_write);\n\n    }\n\n    ide_set_sector(s, sector_num + n);\n\n    \n\n#ifdef TARGET_I386\n\n    if (win2k_install_hack) {\n\n        /* It seems there is a bug in the Windows 2000 installer HDD\n\n           IDE driver which fills the disk with empty logs when the\n\n           IDE write IRQ comes too early. This hack tries to correct\n\n           that at the expense of slower write performances. Use this\n\n           option _only_ to install Windows 2000. You must disable it\n\n           for normal use. */\n\n        qemu_mod_timer(s->sector_write_timer, \n\n                       qemu_get_clock(vm_clock) + (ticks_per_sec / 1000));\n\n    } else \n\n#endif\n\n    {\n\n        ide_set_irq(s);\n\n    }\n\n}\n", "idx": 27046}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "const char *drive_get_serial(BlockDriverState *bdrv)\n\n{\n\n    DriveInfo *dinfo;\n\n\n\n    TAILQ_FOREACH(dinfo, &drives, next) {\n\n        if (dinfo->bdrv == bdrv)\n\n            return dinfo->serial;\n\n    }\n\n\n\n    return \"\\0\";\n\n}\n", "idx": 27047}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "AioContext *iohandler_get_aio_context(void)\n\n{\n\n    iohandler_init();\n\n    return iohandler_ctx;\n\n}\n", "idx": 27048}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static void vnc_read_when(VncState *vs, VncReadEvent *func, size_t expecting)\n\n{\n\n    vs->read_handler = func;\n\n    vs->read_handler_expect = expecting;\n\n}\n", "idx": 27049}
{"project": "qemu", "commit_id": "620e48f66350991918dd78e9a686a9b159fec111", "target": 0, "func": "static int decode_mips16_opc (CPUState *env, DisasContext *ctx,\n\n                              int *is_branch)\n\n{\n\n    int rx, ry;\n\n    int sa;\n\n    int op, cnvt_op, op1, offset;\n\n    int funct;\n\n    int n_bytes;\n\n\n\n    op = (ctx->opcode >> 11) & 0x1f;\n\n    sa = (ctx->opcode >> 2) & 0x7;\n\n    sa = sa == 0 ? 8 : sa;\n\n    rx = xlat((ctx->opcode >> 8) & 0x7);\n\n    cnvt_op = (ctx->opcode >> 5) & 0x7;\n\n    ry = xlat((ctx->opcode >> 5) & 0x7);\n\n    op1 = offset = ctx->opcode & 0x1f;\n\n\n\n    n_bytes = 2;\n\n\n\n    switch (op) {\n\n    case M16_OPC_ADDIUSP:\n\n        {\n\n            int16_t imm = ((uint8_t) ctx->opcode) << 2;\n\n\n\n            gen_arith_imm(env, ctx, OPC_ADDIU, rx, 29, imm);\n\n        }\n\n        break;\n\n    case M16_OPC_ADDIUPC:\n\n        gen_addiupc(ctx, rx, ((uint8_t) ctx->opcode) << 2, 0, 0);\n\n        break;\n\n    case M16_OPC_B:\n\n        offset = (ctx->opcode & 0x7ff) << 1;\n\n        offset = (int16_t)(offset << 4) >> 4;\n\n        gen_compute_branch(ctx, OPC_BEQ, 2, 0, 0, offset);\n\n        /* No delay slot, so just process as a normal instruction */\n\n        break;\n\n    case M16_OPC_JAL:\n\n        offset = lduw_code(ctx->pc + 2);\n\n        offset = (((ctx->opcode & 0x1f) << 21)\n\n                  | ((ctx->opcode >> 5) & 0x1f) << 16\n\n                  | offset) << 2;\n\n        op = ((ctx->opcode >> 10) & 0x1) ? OPC_JALX : OPC_JAL;\n\n        gen_compute_branch(ctx, op, 4, rx, ry, offset);\n\n        n_bytes = 4;\n\n        *is_branch = 1;\n\n        break;\n\n    case M16_OPC_BEQZ:\n\n        gen_compute_branch(ctx, OPC_BEQ, 2, rx, 0, ((int8_t)ctx->opcode) << 1);\n\n        /* No delay slot, so just process as a normal instruction */\n\n        break;\n\n    case M16_OPC_BNEQZ:\n\n        gen_compute_branch(ctx, OPC_BNE, 2, rx, 0, ((int8_t)ctx->opcode) << 1);\n\n        /* No delay slot, so just process as a normal instruction */\n\n        break;\n\n    case M16_OPC_SHIFT:\n\n        switch (ctx->opcode & 0x3) {\n\n        case 0x0:\n\n            gen_shift_imm(env, ctx, OPC_SLL, rx, ry, sa);\n\n            break;\n\n        case 0x1:\n\n#if defined(TARGET_MIPS64)\n\n            check_mips_64(ctx);\n\n            gen_shift_imm(env, ctx, OPC_DSLL, rx, ry, sa);\n\n#else\n\n            generate_exception(ctx, EXCP_RI);\n\n#endif\n\n            break;\n\n        case 0x2:\n\n            gen_shift_imm(env, ctx, OPC_SRL, rx, ry, sa);\n\n            break;\n\n        case 0x3:\n\n            gen_shift_imm(env, ctx, OPC_SRA, rx, ry, sa);\n\n            break;\n\n        }\n\n        break;\n\n#if defined(TARGET_MIPS64)\n\n    case M16_OPC_LD:\n\n        check_mips_64(ctx);\n\n        gen_ldst(ctx, OPC_LD, ry, rx, offset << 3);\n\n        break;\n\n#endif\n\n    case M16_OPC_RRIA:\n\n        {\n\n            int16_t imm = (int8_t)((ctx->opcode & 0xf) << 4) >> 4;\n\n\n\n            if ((ctx->opcode >> 4) & 1) {\n\n#if defined(TARGET_MIPS64)\n\n                check_mips_64(ctx);\n\n                gen_arith_imm(env, ctx, OPC_DADDIU, ry, rx, imm);\n\n#else\n\n                generate_exception(ctx, EXCP_RI);\n\n#endif\n\n            } else {\n\n                gen_arith_imm(env, ctx, OPC_ADDIU, ry, rx, imm);\n\n            }\n\n        }\n\n        break;\n\n    case M16_OPC_ADDIU8:\n\n        {\n\n            int16_t imm = (int8_t) ctx->opcode;\n\n\n\n            gen_arith_imm(env, ctx, OPC_ADDIU, rx, rx, imm);\n\n        }\n\n        break;\n\n    case M16_OPC_SLTI:\n\n        {\n\n            int16_t imm = (uint8_t) ctx->opcode;\n\n\n\n            gen_slt_imm(env, OPC_SLTI, 24, rx, imm);\n\n        }\n\n        break;\n\n    case M16_OPC_SLTIU:\n\n        {\n\n            int16_t imm = (uint8_t) ctx->opcode;\n\n\n\n            gen_slt_imm(env, OPC_SLTIU, 24, rx, imm);\n\n        }\n\n        break;\n\n    case M16_OPC_I8:\n\n        {\n\n            int reg32;\n\n\n\n            funct = (ctx->opcode >> 8) & 0x7;\n\n            switch (funct) {\n\n            case I8_BTEQZ:\n\n                gen_compute_branch(ctx, OPC_BEQ, 2, 24, 0,\n\n                                   ((int8_t)ctx->opcode) << 1);\n\n                break;\n\n            case I8_BTNEZ:\n\n                gen_compute_branch(ctx, OPC_BNE, 2, 24, 0,\n\n                                   ((int8_t)ctx->opcode) << 1);\n\n                break;\n\n            case I8_SWRASP:\n\n                gen_ldst(ctx, OPC_SW, 31, 29, (ctx->opcode & 0xff) << 2);\n\n                break;\n\n            case I8_ADJSP:\n\n                gen_arith_imm(env, ctx, OPC_ADDIU, 29, 29,\n\n                              ((int8_t)ctx->opcode) << 3);\n\n                break;\n\n            case I8_SVRS:\n\n                {\n\n                    int do_ra = ctx->opcode & (1 << 6);\n\n                    int do_s0 = ctx->opcode & (1 << 5);\n\n                    int do_s1 = ctx->opcode & (1 << 4);\n\n                    int framesize = ctx->opcode & 0xf;\n\n\n\n                    if (framesize == 0) {\n\n                        framesize = 128;\n\n                    } else {\n\n                        framesize = framesize << 3;\n\n                    }\n\n\n\n                    if (ctx->opcode & (1 << 7)) {\n\n                        gen_mips16_save(ctx, 0, 0,\n\n                                        do_ra, do_s0, do_s1, framesize);\n\n                    } else {\n\n                        gen_mips16_restore(ctx, 0, 0,\n\n                                           do_ra, do_s0, do_s1, framesize);\n\n                    }\n\n                }\n\n                break;\n\n            case I8_MOV32R:\n\n                {\n\n                    int rz = xlat(ctx->opcode & 0x7);\n\n\n\n                    reg32 = (((ctx->opcode >> 3) & 0x3) << 3) |\n\n                        ((ctx->opcode >> 5) & 0x7);\n\n                    gen_arith(env, ctx, OPC_ADDU, reg32, rz, 0);\n\n                }\n\n                break;\n\n            case I8_MOVR32:\n\n                reg32 = ctx->opcode & 0x1f;\n\n                gen_arith(env, ctx, OPC_ADDU, ry, reg32, 0);\n\n                break;\n\n            default:\n\n                generate_exception(ctx, EXCP_RI);\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n    case M16_OPC_LI:\n\n        {\n\n            int16_t imm = (uint8_t) ctx->opcode;\n\n\n\n            gen_arith_imm(env, ctx, OPC_ADDIU, rx, 0, imm);\n\n        }\n\n        break;\n\n    case M16_OPC_CMPI:\n\n        {\n\n            int16_t imm = (uint8_t) ctx->opcode;\n\n\n\n            gen_logic_imm(env, OPC_XORI, 24, rx, imm);\n\n        }\n\n        break;\n\n#if defined(TARGET_MIPS64)\n\n    case M16_OPC_SD:\n\n        check_mips_64(ctx);\n\n        gen_ldst(ctx, OPC_SD, ry, rx, offset << 3);\n\n        break;\n\n#endif\n\n    case M16_OPC_LB:\n\n        gen_ldst(ctx, OPC_LB, ry, rx, offset);\n\n        break;\n\n    case M16_OPC_LH:\n\n        gen_ldst(ctx, OPC_LH, ry, rx, offset << 1);\n\n        break;\n\n    case M16_OPC_LWSP:\n\n        gen_ldst(ctx, OPC_LW, rx, 29, ((uint8_t)ctx->opcode) << 2);\n\n        break;\n\n    case M16_OPC_LW:\n\n        gen_ldst(ctx, OPC_LW, ry, rx, offset << 2);\n\n        break;\n\n    case M16_OPC_LBU:\n\n        gen_ldst(ctx, OPC_LBU, ry, rx, offset);\n\n        break;\n\n    case M16_OPC_LHU:\n\n        gen_ldst(ctx, OPC_LHU, ry, rx, offset << 1);\n\n        break;\n\n    case M16_OPC_LWPC:\n\n        gen_ldst(ctx, OPC_LWPC, rx, 0, ((uint8_t)ctx->opcode) << 2);\n\n        break;\n\n#if defined (TARGET_MIPS64)\n\n    case M16_OPC_LWU:\n\n        check_mips_64(ctx);\n\n        gen_ldst(ctx, OPC_LWU, ry, rx, offset << 2);\n\n        break;\n\n#endif\n\n    case M16_OPC_SB:\n\n        gen_ldst(ctx, OPC_SB, ry, rx, offset);\n\n        break;\n\n    case M16_OPC_SH:\n\n        gen_ldst(ctx, OPC_SH, ry, rx, offset << 1);\n\n        break;\n\n    case M16_OPC_SWSP:\n\n        gen_ldst(ctx, OPC_SW, rx, 29, ((uint8_t)ctx->opcode) << 2);\n\n        break;\n\n    case M16_OPC_SW:\n\n        gen_ldst(ctx, OPC_SW, ry, rx, offset << 2);\n\n        break;\n\n    case M16_OPC_RRR:\n\n        {\n\n            int rz = xlat((ctx->opcode >> 2) & 0x7);\n\n            int mips32_op;\n\n\n\n            switch (ctx->opcode & 0x3) {\n\n            case RRR_ADDU:\n\n                mips32_op = OPC_ADDU;\n\n                break;\n\n            case RRR_SUBU:\n\n                mips32_op = OPC_SUBU;\n\n                break;\n\n#if defined(TARGET_MIPS64)\n\n            case RRR_DADDU:\n\n                mips32_op = OPC_DADDU;\n\n                check_mips_64(ctx);\n\n                break;\n\n            case RRR_DSUBU:\n\n                mips32_op = OPC_DSUBU;\n\n                check_mips_64(ctx);\n\n                break;\n\n#endif\n\n            default:\n\n                generate_exception(ctx, EXCP_RI);\n\n                goto done;\n\n            }\n\n\n\n            gen_arith(env, ctx, mips32_op, rz, rx, ry);\n\n        done:\n\n            ;\n\n        }\n\n        break;\n\n    case M16_OPC_RR:\n\n        switch (op1) {\n\n        case RR_JR:\n\n            {\n\n                int nd = (ctx->opcode >> 7) & 0x1;\n\n                int link = (ctx->opcode >> 6) & 0x1;\n\n                int ra = (ctx->opcode >> 5) & 0x1;\n\n\n\n                if (link) {\n\n                    op = nd ? OPC_JALRC : OPC_JALR;\n\n                } else {\n\n                    op = OPC_JR;\n\n                }\n\n\n\n                gen_compute_branch(ctx, op, 2, ra ? 31 : rx, 31, 0);\n\n                if (!nd) {\n\n                    *is_branch = 1;\n\n                }\n\n            }\n\n            break;\n\n        case RR_SDBBP:\n\n            /* XXX: not clear which exception should be raised\n\n             *      when in debug mode...\n\n             */\n\n            check_insn(env, ctx, ISA_MIPS32);\n\n            if (!(ctx->hflags & MIPS_HFLAG_DM)) {\n\n                generate_exception(ctx, EXCP_DBp);\n\n            } else {\n\n                generate_exception(ctx, EXCP_DBp);\n\n            }\n\n            break;\n\n        case RR_SLT:\n\n            gen_slt(env, OPC_SLT, 24, rx, ry);\n\n            break;\n\n        case RR_SLTU:\n\n            gen_slt(env, OPC_SLTU, 24, rx, ry);\n\n            break;\n\n        case RR_BREAK:\n\n            generate_exception(ctx, EXCP_BREAK);\n\n            break;\n\n        case RR_SLLV:\n\n            gen_shift(env, ctx, OPC_SLLV, ry, rx, ry);\n\n            break;\n\n        case RR_SRLV:\n\n            gen_shift(env, ctx, OPC_SRLV, ry, rx, ry);\n\n            break;\n\n        case RR_SRAV:\n\n            gen_shift(env, ctx, OPC_SRAV, ry, rx, ry);\n\n            break;\n\n#if defined (TARGET_MIPS64)\n\n        case RR_DSRL:\n\n            check_mips_64(ctx);\n\n            gen_shift_imm(env, ctx, OPC_DSRL, ry, ry, sa);\n\n            break;\n\n#endif\n\n        case RR_CMP:\n\n            gen_logic(env, OPC_XOR, 24, rx, ry);\n\n            break;\n\n        case RR_NEG:\n\n            gen_arith(env, ctx, OPC_SUBU, rx, 0, ry);\n\n            break;\n\n        case RR_AND:\n\n            gen_logic(env, OPC_AND, rx, rx, ry);\n\n            break;\n\n        case RR_OR:\n\n            gen_logic(env, OPC_OR, rx, rx, ry);\n\n            break;\n\n        case RR_XOR:\n\n            gen_logic(env, OPC_XOR, rx, rx, ry);\n\n            break;\n\n        case RR_NOT:\n\n            gen_logic(env, OPC_NOR, rx, ry, 0);\n\n            break;\n\n        case RR_MFHI:\n\n            gen_HILO(ctx, OPC_MFHI, rx);\n\n            break;\n\n        case RR_CNVT:\n\n            switch (cnvt_op) {\n\n            case RR_RY_CNVT_ZEB:\n\n                tcg_gen_ext8u_tl(cpu_gpr[rx], cpu_gpr[rx]);\n\n                break;\n\n            case RR_RY_CNVT_ZEH:\n\n                tcg_gen_ext16u_tl(cpu_gpr[rx], cpu_gpr[rx]);\n\n                break;\n\n            case RR_RY_CNVT_SEB:\n\n                tcg_gen_ext8s_tl(cpu_gpr[rx], cpu_gpr[rx]);\n\n                break;\n\n            case RR_RY_CNVT_SEH:\n\n                tcg_gen_ext16s_tl(cpu_gpr[rx], cpu_gpr[rx]);\n\n                break;\n\n#if defined (TARGET_MIPS64)\n\n            case RR_RY_CNVT_ZEW:\n\n                check_mips_64(ctx);\n\n                tcg_gen_ext32u_tl(cpu_gpr[rx], cpu_gpr[rx]);\n\n                break;\n\n            case RR_RY_CNVT_SEW:\n\n                check_mips_64(ctx);\n\n                tcg_gen_ext32s_tl(cpu_gpr[rx], cpu_gpr[rx]);\n\n                break;\n\n#endif\n\n            default:\n\n                generate_exception(ctx, EXCP_RI);\n\n                break;\n\n            }\n\n            break;\n\n        case RR_MFLO:\n\n            gen_HILO(ctx, OPC_MFLO, rx);\n\n            break;\n\n#if defined (TARGET_MIPS64)\n\n        case RR_DSRA:\n\n            check_mips_64(ctx);\n\n            gen_shift_imm(env, ctx, OPC_DSRA, ry, ry, sa);\n\n            break;\n\n        case RR_DSLLV:\n\n            check_mips_64(ctx);\n\n            gen_shift(env, ctx, OPC_DSLLV, ry, rx, ry);\n\n            break;\n\n        case RR_DSRLV:\n\n            check_mips_64(ctx);\n\n            gen_shift(env, ctx, OPC_DSRLV, ry, rx, ry);\n\n            break;\n\n        case RR_DSRAV:\n\n            check_mips_64(ctx);\n\n            gen_shift(env, ctx, OPC_DSRAV, ry, rx, ry);\n\n            break;\n\n#endif\n\n        case RR_MULT:\n\n            gen_muldiv(ctx, OPC_MULT, rx, ry);\n\n            break;\n\n        case RR_MULTU:\n\n            gen_muldiv(ctx, OPC_MULTU, rx, ry);\n\n            break;\n\n        case RR_DIV:\n\n            gen_muldiv(ctx, OPC_DIV, rx, ry);\n\n            break;\n\n        case RR_DIVU:\n\n            gen_muldiv(ctx, OPC_DIVU, rx, ry);\n\n            break;\n\n#if defined (TARGET_MIPS64)\n\n        case RR_DMULT:\n\n            check_mips_64(ctx);\n\n            gen_muldiv(ctx, OPC_DMULT, rx, ry);\n\n            break;\n\n        case RR_DMULTU:\n\n            check_mips_64(ctx);\n\n            gen_muldiv(ctx, OPC_DMULTU, rx, ry);\n\n            break;\n\n        case RR_DDIV:\n\n            check_mips_64(ctx);\n\n            gen_muldiv(ctx, OPC_DDIV, rx, ry);\n\n            break;\n\n        case RR_DDIVU:\n\n            check_mips_64(ctx);\n\n            gen_muldiv(ctx, OPC_DDIVU, rx, ry);\n\n            break;\n\n#endif\n\n        default:\n\n            generate_exception(ctx, EXCP_RI);\n\n            break;\n\n        }\n\n        break;\n\n    case M16_OPC_EXTEND:\n\n        decode_extended_mips16_opc(env, ctx, is_branch);\n\n        n_bytes = 4;\n\n        break;\n\n#if defined(TARGET_MIPS64)\n\n    case M16_OPC_I64:\n\n        funct = (ctx->opcode >> 8) & 0x7;\n\n        decode_i64_mips16(env, ctx, ry, funct, offset, 0);\n\n        break;\n\n#endif\n\n    default:\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    }\n\n\n\n    return n_bytes;\n\n}\n", "idx": 27050}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static void proxy_seekdir(FsContext *ctx, V9fsFidOpenState *fs, off_t off)\n\n{\n\n    seekdir(fs->dir, off);\n\n}\n", "idx": 27052}
{"project": "qemu", "commit_id": "97b83deb557679c909465456acaa723c2ba34948", "target": 0, "func": "void virtio_notify(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    /* Always notify when queue is empty */\n\n    if ((vq->inuse || vring_avail_idx(vq) != vq->last_avail_idx) &&\n\n        (vring_avail_flags(vq) & VRING_AVAIL_F_NO_INTERRUPT))\n\n        return;\n\n\n\n    vdev->isr |= 0x01;\n\n    virtio_update_irq(vdev);\n\n}\n", "idx": 27053}
{"project": "qemu", "commit_id": "369f7de9d57e4dd2f312255fc12271d5749c0a4e", "target": 0, "func": "static int64_t allocate_cluster(BlockDriverState *bs, int64_t sector_num)\n\n{\n\n    BDRVParallelsState *s = bs->opaque;\n\n    uint32_t idx, offset, tmp;\n\n    int64_t pos;\n\n    int ret;\n\n\n\n    idx = sector_num / s->tracks;\n\n    offset = sector_num % s->tracks;\n\n\n\n    if (idx >= s->catalog_size) {\n\n        return -EINVAL;\n\n    }\n\n    if (s->catalog_bitmap[idx] != 0) {\n\n        return (uint64_t)s->catalog_bitmap[idx] * s->off_multiplier + offset;\n\n    }\n\n\n\n    pos = bdrv_getlength(bs->file) >> BDRV_SECTOR_BITS;\n\n    if (s->has_truncate) {\n\n        ret = bdrv_truncate(bs->file, (pos + s->tracks) << BDRV_SECTOR_BITS);\n\n    } else {\n\n        ret = bdrv_write_zeroes(bs->file, pos, s->tracks, 0);\n\n    }\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    s->catalog_bitmap[idx] = pos / s->off_multiplier;\n\n\n\n    tmp = cpu_to_le32(s->catalog_bitmap[idx]);\n\n\n\n    ret = bdrv_pwrite(bs->file,\n\n            sizeof(ParallelsHeader) + idx * sizeof(tmp), &tmp, sizeof(tmp));\n\n    if (ret < 0) {\n\n        s->catalog_bitmap[idx] = 0;\n\n        return ret;\n\n    }\n\n    return (uint64_t)s->catalog_bitmap[idx] * s->off_multiplier + offset;\n\n}\n", "idx": 27054}
{"project": "qemu", "commit_id": "76abe4071d111a9ca6dcc9b9689a831c39ffa718", "target": 0, "func": "static int vdi_open(BlockDriverState *bs, QDict *options, int flags,\n\n                    Error **errp)\n\n{\n\n    BDRVVdiState *s = bs->opaque;\n\n    VdiHeader header;\n\n    size_t bmap_size;\n\n    int ret;\n\n\n\n    logout(\"\\n\");\n\n\n\n    ret = bdrv_read(bs->file, 0, (uint8_t *)&header, 1);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    vdi_header_to_cpu(&header);\n\n#if defined(CONFIG_VDI_DEBUG)\n\n    vdi_header_print(&header);\n\n#endif\n\n\n\n    if (header.disk_size % SECTOR_SIZE != 0) {\n\n        /* 'VBoxManage convertfromraw' can create images with odd disk sizes.\n\n           We accept them but round the disk size to the next multiple of\n\n           SECTOR_SIZE. */\n\n        logout(\"odd disk size %\" PRIu64 \" B, round up\\n\", header.disk_size);\n\n        header.disk_size += SECTOR_SIZE - 1;\n\n        header.disk_size &= ~(SECTOR_SIZE - 1);\n\n    }\n\n\n\n    if (header.signature != VDI_SIGNATURE) {\n\n        logout(\"bad vdi signature %08x\\n\", header.signature);\n\n        ret = -EMEDIUMTYPE;\n\n        goto fail;\n\n    } else if (header.version != VDI_VERSION_1_1) {\n\n        logout(\"unsupported version %u.%u\\n\",\n\n               header.version >> 16, header.version & 0xffff);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.offset_bmap % SECTOR_SIZE != 0) {\n\n        /* We only support block maps which start on a sector boundary. */\n\n        logout(\"unsupported block map offset 0x%x B\\n\", header.offset_bmap);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.offset_data % SECTOR_SIZE != 0) {\n\n        /* We only support data blocks which start on a sector boundary. */\n\n        logout(\"unsupported data offset 0x%x B\\n\", header.offset_data);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.sector_size != SECTOR_SIZE) {\n\n        logout(\"unsupported sector size %u B\\n\", header.sector_size);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.block_size != 1 * MiB) {\n\n        logout(\"unsupported block size %u B\\n\", header.block_size);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.disk_size >\n\n               (uint64_t)header.blocks_in_image * header.block_size) {\n\n        logout(\"unsupported disk size %\" PRIu64 \" B\\n\", header.disk_size);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (!uuid_is_null(header.uuid_link)) {\n\n        logout(\"link uuid != 0, unsupported\\n\");\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (!uuid_is_null(header.uuid_parent)) {\n\n        logout(\"parent uuid != 0, unsupported\\n\");\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    }\n\n\n\n    bs->total_sectors = header.disk_size / SECTOR_SIZE;\n\n\n\n    s->block_size = header.block_size;\n\n    s->block_sectors = header.block_size / SECTOR_SIZE;\n\n    s->bmap_sector = header.offset_bmap / SECTOR_SIZE;\n\n    s->header = header;\n\n\n\n    bmap_size = header.blocks_in_image * sizeof(uint32_t);\n\n    bmap_size = (bmap_size + SECTOR_SIZE - 1) / SECTOR_SIZE;\n\n    s->bmap = g_malloc(bmap_size * SECTOR_SIZE);\n\n    ret = bdrv_read(bs->file, s->bmap_sector, (uint8_t *)s->bmap, bmap_size);\n\n    if (ret < 0) {\n\n        goto fail_free_bmap;\n\n    }\n\n\n\n    /* Disable migration when vdi images are used */\n\n    error_set(&s->migration_blocker,\n\n              QERR_BLOCK_FORMAT_FEATURE_NOT_SUPPORTED,\n\n              \"vdi\", bs->device_name, \"live migration\");\n\n    migrate_add_blocker(s->migration_blocker);\n\n\n\n    return 0;\n\n\n\n fail_free_bmap:\n\n    g_free(s->bmap);\n\n\n\n fail:\n\n    return ret;\n\n}\n", "idx": 27055}
{"project": "qemu", "commit_id": "6049f4f831c6f409031dfa09282b38d0cbaecad8", "target": 0, "func": "abi_long do_syscall(void *cpu_env, int num, abi_long arg1,\n\n                    abi_long arg2, abi_long arg3, abi_long arg4,\n\n                    abi_long arg5, abi_long arg6)\n\n{\n\n    abi_long ret;\n\n    struct stat st;\n\n    struct statfs stfs;\n\n    void *p;\n\n\n\n#ifdef DEBUG\n\n    gemu_log(\"syscall %d\", num);\n\n#endif\n\n    if(do_strace)\n\n        print_syscall(num, arg1, arg2, arg3, arg4, arg5, arg6);\n\n\n\n    switch(num) {\n\n    case TARGET_NR_exit:\n\n#ifdef CONFIG_USE_NPTL\n\n      /* In old applications this may be used to implement _exit(2).\n\n         However in threaded applictions it is used for thread termination,\n\n         and _exit_group is used for application termination.\n\n         Do thread termination if we have more then one thread.  */\n\n      /* FIXME: This probably breaks if a signal arrives.  We should probably\n\n         be disabling signals.  */\n\n      if (first_cpu->next_cpu) {\n\n          TaskState *ts;\n\n          CPUState **lastp;\n\n          CPUState *p;\n\n\n\n          cpu_list_lock();\n\n          lastp = &first_cpu;\n\n          p = first_cpu;\n\n          while (p && p != (CPUState *)cpu_env) {\n\n              lastp = &p->next_cpu;\n\n              p = p->next_cpu;\n\n          }\n\n          /* If we didn't find the CPU for this thread then something is\n\n             horribly wrong.  */\n\n          if (!p)\n\n              abort();\n\n          /* Remove the CPU from the list.  */\n\n          *lastp = p->next_cpu;\n\n          cpu_list_unlock();\n\n          ts = ((CPUState *)cpu_env)->opaque;\n\n          if (ts->child_tidptr) {\n\n              put_user_u32(0, ts->child_tidptr);\n\n              sys_futex(g2h(ts->child_tidptr), FUTEX_WAKE, INT_MAX,\n\n                        NULL, NULL, 0);\n\n          }\n\n          /* TODO: Free CPU state.  */\n\n          pthread_exit(NULL);\n\n      }\n\n#endif\n\n#ifdef TARGET_GPROF\n\n        _mcleanup();\n\n#endif\n\n        gdb_exit(cpu_env, arg1);\n\n        _exit(arg1);\n\n        ret = 0; /* avoid warning */\n\n        break;\n\n    case TARGET_NR_read:\n\n        if (arg3 == 0)\n\n            ret = 0;\n\n        else {\n\n            if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))\n\n                goto efault;\n\n            ret = get_errno(read(arg1, p, arg3));\n\n            unlock_user(p, arg2, ret);\n\n        }\n\n        break;\n\n    case TARGET_NR_write:\n\n        if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))\n\n            goto efault;\n\n        ret = get_errno(write(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n    case TARGET_NR_open:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(open(path(p),\n\n                             target_to_host_bitmask(arg2, fcntl_flags_tbl),\n\n                             arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_openat) && defined(__NR_openat)\n\n    case TARGET_NR_openat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_openat(arg1,\n\n                                   path(p),\n\n                                   target_to_host_bitmask(arg3, fcntl_flags_tbl),\n\n                                   arg4));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_close:\n\n        ret = get_errno(close(arg1));\n\n        break;\n\n    case TARGET_NR_brk:\n\n        ret = do_brk(arg1);\n\n        break;\n\n    case TARGET_NR_fork:\n\n        ret = get_errno(do_fork(cpu_env, SIGCHLD, 0, 0, 0, 0));\n\n        break;\n\n#ifdef TARGET_NR_waitpid\n\n    case TARGET_NR_waitpid:\n\n        {\n\n            int status;\n\n            ret = get_errno(waitpid(arg1, &status, arg3));\n\n            if (!is_error(ret) && arg2\n\n                && put_user_s32(host_to_target_waitstatus(status), arg2))\n\n                goto efault;\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_waitid\n\n    case TARGET_NR_waitid:\n\n        {\n\n            siginfo_t info;\n\n            info.si_pid = 0;\n\n            ret = get_errno(waitid(arg1, arg2, &info, arg4));\n\n            if (!is_error(ret) && arg3 && info.si_pid != 0) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_siginfo_t), 0)))\n\n                    goto efault;\n\n                host_to_target_siginfo(p, &info);\n\n                unlock_user(p, arg3, sizeof(target_siginfo_t));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_creat /* not on alpha */\n\n    case TARGET_NR_creat:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(creat(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_link:\n\n        {\n\n            void * p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg2);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(link(p, p2));\n\n            unlock_user(p2, arg2, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_linkat) && defined(__NR_linkat)\n\n    case TARGET_NR_linkat:\n\n        {\n\n            void * p2 = NULL;\n\n            if (!arg2 || !arg4)\n\n                goto efault;\n\n            p  = lock_user_string(arg2);\n\n            p2 = lock_user_string(arg4);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_linkat(arg1, p, arg3, p2, arg5));\n\n            unlock_user(p, arg2, 0);\n\n            unlock_user(p2, arg4, 0);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_unlink:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(unlink(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_unlinkat) && defined(__NR_unlinkat)\n\n    case TARGET_NR_unlinkat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_unlinkat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_execve:\n\n        {\n\n            char **argp, **envp;\n\n            int argc, envc;\n\n            abi_ulong gp;\n\n            abi_ulong guest_argp;\n\n            abi_ulong guest_envp;\n\n            abi_ulong addr;\n\n            char **q;\n\n\n\n            argc = 0;\n\n            guest_argp = arg2;\n\n            for (gp = guest_argp; gp; gp += sizeof(abi_ulong)) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto efault;\n\n                if (!addr)\n\n                    break;\n\n                argc++;\n\n            }\n\n            envc = 0;\n\n            guest_envp = arg3;\n\n            for (gp = guest_envp; gp; gp += sizeof(abi_ulong)) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto efault;\n\n                if (!addr)\n\n                    break;\n\n                envc++;\n\n            }\n\n\n\n            argp = alloca((argc + 1) * sizeof(void *));\n\n            envp = alloca((envc + 1) * sizeof(void *));\n\n\n\n            for (gp = guest_argp, q = argp; gp;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto execve_efault;\n\n                if (!addr)\n\n                    break;\n\n                if (!(*q = lock_user_string(addr)))\n\n                    goto execve_efault;\n\n            }\n\n            *q = NULL;\n\n\n\n            for (gp = guest_envp, q = envp; gp;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto execve_efault;\n\n                if (!addr)\n\n                    break;\n\n                if (!(*q = lock_user_string(addr)))\n\n                    goto execve_efault;\n\n            }\n\n            *q = NULL;\n\n\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto execve_efault;\n\n            ret = get_errno(execve(p, argp, envp));\n\n            unlock_user(p, arg1, 0);\n\n\n\n            goto execve_end;\n\n\n\n        execve_efault:\n\n            ret = -TARGET_EFAULT;\n\n\n\n        execve_end:\n\n            for (gp = guest_argp, q = argp; *q;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp)\n\n                    || !addr)\n\n                    break;\n\n                unlock_user(*q, addr, 0);\n\n            }\n\n            for (gp = guest_envp, q = envp; *q;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp)\n\n                    || !addr)\n\n                    break;\n\n                unlock_user(*q, addr, 0);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_chdir:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chdir(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_time\n\n    case TARGET_NR_time:\n\n        {\n\n            time_t host_time;\n\n            ret = get_errno(time(&host_time));\n\n            if (!is_error(ret)\n\n                && arg1\n\n                && put_user_sal(host_time, arg1))\n\n                goto efault;\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_mknod:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(mknod(p, arg2, arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_mknodat) && defined(__NR_mknodat)\n\n    case TARGET_NR_mknodat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_mknodat(arg1, p, arg3, arg4));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_chmod:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chmod(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_break\n\n    case TARGET_NR_break:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_oldstat\n\n    case TARGET_NR_oldstat:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_lseek:\n\n        ret = get_errno(lseek(arg1, arg2, arg3));\n\n        break;\n\n#ifdef TARGET_NR_getxpid\n\n    case TARGET_NR_getxpid:\n\n#else\n\n    case TARGET_NR_getpid:\n\n#endif\n\n        ret = get_errno(getpid());\n\n        break;\n\n    case TARGET_NR_mount:\n\n\t\t{\n\n\t\t\t/* need to look at the data field */\n\n\t\t\tvoid *p2, *p3;\n\n\t\t\tp = lock_user_string(arg1);\n\n\t\t\tp2 = lock_user_string(arg2);\n\n\t\t\tp3 = lock_user_string(arg3);\n\n                        if (!p || !p2 || !p3)\n\n                            ret = -TARGET_EFAULT;\n\n                        else {\n\n                            /* FIXME - arg5 should be locked, but it isn't clear how to\n\n                             * do that since it's not guaranteed to be a NULL-terminated\n\n                             * string.\n\n                             */\n\n                            if ( ! arg5 )\n\n                                ret = get_errno(mount(p, p2, p3, (unsigned long)arg4, NULL));\n\n                            else\n\n                                ret = get_errno(mount(p, p2, p3, (unsigned long)arg4, g2h(arg5)));\n\n                        }\n\n                        unlock_user(p, arg1, 0);\n\n                        unlock_user(p2, arg2, 0);\n\n                        unlock_user(p3, arg3, 0);\n\n\t\t\tbreak;\n\n\t\t}\n\n#ifdef TARGET_NR_umount\n\n    case TARGET_NR_umount:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(umount(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_stime /* not on alpha */\n\n    case TARGET_NR_stime:\n\n        {\n\n            time_t host_time;\n\n            if (get_user_sal(host_time, arg1))\n\n                goto efault;\n\n            ret = get_errno(stime(&host_time));\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_ptrace:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_alarm /* not on alpha */\n\n    case TARGET_NR_alarm:\n\n        ret = alarm(arg1);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_oldfstat\n\n    case TARGET_NR_oldfstat:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_pause /* not on alpha */\n\n    case TARGET_NR_pause:\n\n        ret = get_errno(pause());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_utime\n\n    case TARGET_NR_utime:\n\n        {\n\n            struct utimbuf tbuf, *host_tbuf;\n\n            struct target_utimbuf *target_tbuf;\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, target_tbuf, arg2, 1))\n\n                    goto efault;\n\n                tbuf.actime = tswapl(target_tbuf->actime);\n\n                tbuf.modtime = tswapl(target_tbuf->modtime);\n\n                unlock_user_struct(target_tbuf, arg2, 0);\n\n                host_tbuf = &tbuf;\n\n            } else {\n\n                host_tbuf = NULL;\n\n            }\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto efault;\n\n            ret = get_errno(utime(p, host_tbuf));\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_utimes:\n\n        {\n\n            struct timeval *tvp, tv[2];\n\n            if (arg2) {\n\n                if (copy_from_user_timeval(&tv[0], arg2)\n\n                    || copy_from_user_timeval(&tv[1],\n\n                                              arg2 + sizeof(struct target_timeval)))\n\n                    goto efault;\n\n                tvp = tv;\n\n            } else {\n\n                tvp = NULL;\n\n            }\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto efault;\n\n            ret = get_errno(utimes(p, tvp));\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_futimesat) && defined(__NR_futimesat)\n\n    case TARGET_NR_futimesat:\n\n        {\n\n            struct timeval *tvp, tv[2];\n\n            if (arg3) {\n\n                if (copy_from_user_timeval(&tv[0], arg3)\n\n                    || copy_from_user_timeval(&tv[1],\n\n                                              arg3 + sizeof(struct target_timeval)))\n\n                    goto efault;\n\n                tvp = tv;\n\n            } else {\n\n                tvp = NULL;\n\n            }\n\n            if (!(p = lock_user_string(arg2)))\n\n                goto efault;\n\n            ret = get_errno(sys_futimesat(arg1, path(p), tvp));\n\n            unlock_user(p, arg2, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_stty\n\n    case TARGET_NR_stty:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_gtty\n\n    case TARGET_NR_gtty:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_access:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(access(path(p), arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_faccessat) && defined(__NR_faccessat)\n\n    case TARGET_NR_faccessat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_faccessat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_nice /* not on alpha */\n\n    case TARGET_NR_nice:\n\n        ret = get_errno(nice(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_ftime\n\n    case TARGET_NR_ftime:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_sync:\n\n        sync();\n\n        ret = 0;\n\n        break;\n\n    case TARGET_NR_kill:\n\n        ret = get_errno(kill(arg1, target_to_host_signal(arg2)));\n\n        break;\n\n    case TARGET_NR_rename:\n\n        {\n\n            void *p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg2);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(rename(p, p2));\n\n            unlock_user(p2, arg2, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_renameat) && defined(__NR_renameat)\n\n    case TARGET_NR_renameat:\n\n        {\n\n            void *p2;\n\n            p  = lock_user_string(arg2);\n\n            p2 = lock_user_string(arg4);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_renameat(arg1, p, arg3, p2));\n\n            unlock_user(p2, arg4, 0);\n\n            unlock_user(p, arg2, 0);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_mkdir:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(mkdir(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_mkdirat) && defined(__NR_mkdirat)\n\n    case TARGET_NR_mkdirat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_mkdirat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_rmdir:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(rmdir(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_dup:\n\n        ret = get_errno(dup(arg1));\n\n        break;\n\n    case TARGET_NR_pipe:\n\n        ret = do_pipe(cpu_env, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_pipe2\n\n    case TARGET_NR_pipe2:\n\n        ret = do_pipe(cpu_env, arg1, arg2);\n\n        break;\n\n#endif\n\n    case TARGET_NR_times:\n\n        {\n\n            struct target_tms *tmsp;\n\n            struct tms tms;\n\n            ret = get_errno(times(&tms));\n\n            if (arg1) {\n\n                tmsp = lock_user(VERIFY_WRITE, arg1, sizeof(struct target_tms), 0);\n\n                if (!tmsp)\n\n                    goto efault;\n\n                tmsp->tms_utime = tswapl(host_to_target_clock_t(tms.tms_utime));\n\n                tmsp->tms_stime = tswapl(host_to_target_clock_t(tms.tms_stime));\n\n                tmsp->tms_cutime = tswapl(host_to_target_clock_t(tms.tms_cutime));\n\n                tmsp->tms_cstime = tswapl(host_to_target_clock_t(tms.tms_cstime));\n\n            }\n\n            if (!is_error(ret))\n\n                ret = host_to_target_clock_t(ret);\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_prof\n\n    case TARGET_NR_prof:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_signal\n\n    case TARGET_NR_signal:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_acct:\n\n        if (arg1 == 0) {\n\n            ret = get_errno(acct(NULL));\n\n        } else {\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto efault;\n\n            ret = get_errno(acct(path(p)));\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_umount2 /* not on alpha */\n\n    case TARGET_NR_umount2:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(umount2(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_lock\n\n    case TARGET_NR_lock:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_ioctl:\n\n        ret = do_ioctl(arg1, arg2, arg3);\n\n        break;\n\n    case TARGET_NR_fcntl:\n\n        ret = do_fcntl(arg1, arg2, arg3);\n\n        break;\n\n#ifdef TARGET_NR_mpx\n\n    case TARGET_NR_mpx:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_setpgid:\n\n        ret = get_errno(setpgid(arg1, arg2));\n\n        break;\n\n#ifdef TARGET_NR_ulimit\n\n    case TARGET_NR_ulimit:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_oldolduname\n\n    case TARGET_NR_oldolduname:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_umask:\n\n        ret = get_errno(umask(arg1));\n\n        break;\n\n    case TARGET_NR_chroot:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chroot(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_ustat:\n\n        goto unimplemented;\n\n    case TARGET_NR_dup2:\n\n        ret = get_errno(dup2(arg1, arg2));\n\n        break;\n\n#if defined(CONFIG_DUP3) && defined(TARGET_NR_dup3)\n\n    case TARGET_NR_dup3:\n\n        ret = get_errno(dup3(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getppid /* not on alpha */\n\n    case TARGET_NR_getppid:\n\n        ret = get_errno(getppid());\n\n        break;\n\n#endif\n\n    case TARGET_NR_getpgrp:\n\n        ret = get_errno(getpgrp());\n\n        break;\n\n    case TARGET_NR_setsid:\n\n        ret = get_errno(setsid());\n\n        break;\n\n#ifdef TARGET_NR_sigaction\n\n    case TARGET_NR_sigaction:\n\n        {\n\n#if !defined(TARGET_MIPS)\n\n            struct target_old_sigaction *old_act;\n\n            struct target_sigaction act, oact, *pact;\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, old_act, arg2, 1))\n\n                    goto efault;\n\n                act._sa_handler = old_act->_sa_handler;\n\n                target_siginitset(&act.sa_mask, old_act->sa_mask);\n\n                act.sa_flags = old_act->sa_flags;\n\n                act.sa_restorer = old_act->sa_restorer;\n\n                unlock_user_struct(old_act, arg2, 0);\n\n                pact = &act;\n\n            } else {\n\n                pact = NULL;\n\n            }\n\n            ret = get_errno(do_sigaction(arg1, pact, &oact));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, old_act, arg3, 0))\n\n                    goto efault;\n\n                old_act->_sa_handler = oact._sa_handler;\n\n                old_act->sa_mask = oact.sa_mask.sig[0];\n\n                old_act->sa_flags = oact.sa_flags;\n\n                old_act->sa_restorer = oact.sa_restorer;\n\n                unlock_user_struct(old_act, arg3, 1);\n\n            }\n\n#else\n\n\t    struct target_sigaction act, oact, *pact, *old_act;\n\n\n\n\t    if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, old_act, arg2, 1))\n\n                    goto efault;\n\n\t\tact._sa_handler = old_act->_sa_handler;\n\n\t\ttarget_siginitset(&act.sa_mask, old_act->sa_mask.sig[0]);\n\n\t\tact.sa_flags = old_act->sa_flags;\n\n\t\tunlock_user_struct(old_act, arg2, 0);\n\n\t\tpact = &act;\n\n\t    } else {\n\n\t\tpact = NULL;\n\n\t    }\n\n\n\n\t    ret = get_errno(do_sigaction(arg1, pact, &oact));\n\n\n\n\t    if (!is_error(ret) && arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, old_act, arg3, 0))\n\n                    goto efault;\n\n\t\told_act->_sa_handler = oact._sa_handler;\n\n\t\told_act->sa_flags = oact.sa_flags;\n\n\t\told_act->sa_mask.sig[0] = oact.sa_mask.sig[0];\n\n\t\told_act->sa_mask.sig[1] = 0;\n\n\t\told_act->sa_mask.sig[2] = 0;\n\n\t\told_act->sa_mask.sig[3] = 0;\n\n\t\tunlock_user_struct(old_act, arg3, 1);\n\n\t    }\n\n#endif\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigaction:\n\n        {\n\n            struct target_sigaction *act;\n\n            struct target_sigaction *oact;\n\n\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, act, arg2, 1))\n\n                    goto efault;\n\n            } else\n\n                act = NULL;\n\n            if (arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, oact, arg3, 0)) {\n\n                    ret = -TARGET_EFAULT;\n\n                    goto rt_sigaction_fail;\n\n                }\n\n            } else\n\n                oact = NULL;\n\n            ret = get_errno(do_sigaction(arg1, act, oact));\n\n\trt_sigaction_fail:\n\n            if (act)\n\n                unlock_user_struct(act, arg2, 0);\n\n            if (oact)\n\n                unlock_user_struct(oact, arg3, 1);\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sgetmask /* not on alpha */\n\n    case TARGET_NR_sgetmask:\n\n        {\n\n            sigset_t cur_set;\n\n            abi_ulong target_set;\n\n            sigprocmask(0, NULL, &cur_set);\n\n            host_to_target_old_sigset(&target_set, &cur_set);\n\n            ret = target_set;\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_ssetmask /* not on alpha */\n\n    case TARGET_NR_ssetmask:\n\n        {\n\n            sigset_t set, oset, cur_set;\n\n            abi_ulong target_set = arg1;\n\n            sigprocmask(0, NULL, &cur_set);\n\n            target_to_host_old_sigset(&set, &target_set);\n\n            sigorset(&set, &set, &cur_set);\n\n            sigprocmask(SIG_SETMASK, &set, &oset);\n\n            host_to_target_old_sigset(&target_set, &oset);\n\n            ret = target_set;\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sigprocmask\n\n    case TARGET_NR_sigprocmask:\n\n        {\n\n            int how = arg1;\n\n            sigset_t set, oldset, *set_ptr;\n\n\n\n            if (arg2) {\n\n                switch(how) {\n\n                case TARGET_SIG_BLOCK:\n\n                    how = SIG_BLOCK;\n\n                    break;\n\n                case TARGET_SIG_UNBLOCK:\n\n                    how = SIG_UNBLOCK;\n\n                    break;\n\n                case TARGET_SIG_SETMASK:\n\n                    how = SIG_SETMASK;\n\n                    break;\n\n                default:\n\n                    ret = -TARGET_EINVAL;\n\n                    goto fail;\n\n                }\n\n                if (!(p = lock_user(VERIFY_READ, arg2, sizeof(target_sigset_t), 1)))\n\n                    goto efault;\n\n                target_to_host_old_sigset(&set, p);\n\n                unlock_user(p, arg2, 0);\n\n                set_ptr = &set;\n\n            } else {\n\n                how = 0;\n\n                set_ptr = NULL;\n\n            }\n\n            ret = get_errno(sigprocmask(arg1, set_ptr, &oldset));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_old_sigset(p, &oldset);\n\n                unlock_user(p, arg3, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigprocmask:\n\n        {\n\n            int how = arg1;\n\n            sigset_t set, oldset, *set_ptr;\n\n\n\n            if (arg2) {\n\n                switch(how) {\n\n                case TARGET_SIG_BLOCK:\n\n                    how = SIG_BLOCK;\n\n                    break;\n\n                case TARGET_SIG_UNBLOCK:\n\n                    how = SIG_UNBLOCK;\n\n                    break;\n\n                case TARGET_SIG_SETMASK:\n\n                    how = SIG_SETMASK;\n\n                    break;\n\n                default:\n\n                    ret = -TARGET_EINVAL;\n\n                    goto fail;\n\n                }\n\n                if (!(p = lock_user(VERIFY_READ, arg2, sizeof(target_sigset_t), 1)))\n\n                    goto efault;\n\n                target_to_host_sigset(&set, p);\n\n                unlock_user(p, arg2, 0);\n\n                set_ptr = &set;\n\n            } else {\n\n                how = 0;\n\n                set_ptr = NULL;\n\n            }\n\n            ret = get_errno(sigprocmask(how, set_ptr, &oldset));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_sigset(p, &oldset);\n\n                unlock_user(p, arg3, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sigpending\n\n    case TARGET_NR_sigpending:\n\n        {\n\n            sigset_t set;\n\n            ret = get_errno(sigpending(&set));\n\n            if (!is_error(ret)) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg1, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_old_sigset(p, &set);\n\n                unlock_user(p, arg1, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigpending:\n\n        {\n\n            sigset_t set;\n\n            ret = get_errno(sigpending(&set));\n\n            if (!is_error(ret)) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg1, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_sigset(p, &set);\n\n                unlock_user(p, arg1, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sigsuspend\n\n    case TARGET_NR_sigsuspend:\n\n        {\n\n            sigset_t set;\n\n            if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_old_sigset(&set, p);\n\n            unlock_user(p, arg1, 0);\n\n            ret = get_errno(sigsuspend(&set));\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigsuspend:\n\n        {\n\n            sigset_t set;\n\n            if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_sigset(&set, p);\n\n            unlock_user(p, arg1, 0);\n\n            ret = get_errno(sigsuspend(&set));\n\n        }\n\n        break;\n\n    case TARGET_NR_rt_sigtimedwait:\n\n        {\n\n            sigset_t set;\n\n            struct timespec uts, *puts;\n\n            siginfo_t uinfo;\n\n\n\n            if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_sigset(&set, p);\n\n            unlock_user(p, arg1, 0);\n\n            if (arg3) {\n\n                puts = &uts;\n\n                target_to_host_timespec(puts, arg3);\n\n            } else {\n\n                puts = NULL;\n\n            }\n\n            ret = get_errno(sigtimedwait(&set, &uinfo, puts));\n\n            if (!is_error(ret) && arg2) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg2, sizeof(target_siginfo_t), 0)))\n\n                    goto efault;\n\n                host_to_target_siginfo(p, &uinfo);\n\n                unlock_user(p, arg2, sizeof(target_siginfo_t));\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_rt_sigqueueinfo:\n\n        {\n\n            siginfo_t uinfo;\n\n            if (!(p = lock_user(VERIFY_READ, arg3, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_siginfo(&uinfo, p);\n\n            unlock_user(p, arg1, 0);\n\n            ret = get_errno(sys_rt_sigqueueinfo(arg1, arg2, &uinfo));\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sigreturn\n\n    case TARGET_NR_sigreturn:\n\n        /* NOTE: ret is eax, so not transcoding must be done */\n\n        ret = do_sigreturn(cpu_env);\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigreturn:\n\n        /* NOTE: ret is eax, so not transcoding must be done */\n\n        ret = do_rt_sigreturn(cpu_env);\n\n        break;\n\n    case TARGET_NR_sethostname:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(sethostname(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_setrlimit:\n\n        {\n\n            /* XXX: convert resource ? */\n\n            int resource = arg1;\n\n            struct target_rlimit *target_rlim;\n\n            struct rlimit rlim;\n\n            if (!lock_user_struct(VERIFY_READ, target_rlim, arg2, 1))\n\n                goto efault;\n\n            rlim.rlim_cur = tswapl(target_rlim->rlim_cur);\n\n            rlim.rlim_max = tswapl(target_rlim->rlim_max);\n\n            unlock_user_struct(target_rlim, arg2, 0);\n\n            ret = get_errno(setrlimit(resource, &rlim));\n\n        }\n\n        break;\n\n    case TARGET_NR_getrlimit:\n\n        {\n\n            /* XXX: convert resource ? */\n\n            int resource = arg1;\n\n            struct target_rlimit *target_rlim;\n\n            struct rlimit rlim;\n\n\n\n            ret = get_errno(getrlimit(resource, &rlim));\n\n            if (!is_error(ret)) {\n\n                if (!lock_user_struct(VERIFY_WRITE, target_rlim, arg2, 0))\n\n                    goto efault;\n\n                target_rlim->rlim_cur = tswapl(rlim.rlim_cur);\n\n                target_rlim->rlim_max = tswapl(rlim.rlim_max);\n\n                unlock_user_struct(target_rlim, arg2, 1);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_getrusage:\n\n        {\n\n            struct rusage rusage;\n\n            ret = get_errno(getrusage(arg1, &rusage));\n\n            if (!is_error(ret)) {\n\n                host_to_target_rusage(arg2, &rusage);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_gettimeofday:\n\n        {\n\n            struct timeval tv;\n\n            ret = get_errno(gettimeofday(&tv, NULL));\n\n            if (!is_error(ret)) {\n\n                if (copy_to_user_timeval(arg1, &tv))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_settimeofday:\n\n        {\n\n            struct timeval tv;\n\n            if (copy_from_user_timeval(&tv, arg1))\n\n                goto efault;\n\n            ret = get_errno(settimeofday(&tv, NULL));\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_select\n\n    case TARGET_NR_select:\n\n        {\n\n            struct target_sel_arg_struct *sel;\n\n            abi_ulong inp, outp, exp, tvp;\n\n            long nsel;\n\n\n\n            if (!lock_user_struct(VERIFY_READ, sel, arg1, 1))\n\n                goto efault;\n\n            nsel = tswapl(sel->n);\n\n            inp = tswapl(sel->inp);\n\n            outp = tswapl(sel->outp);\n\n            exp = tswapl(sel->exp);\n\n            tvp = tswapl(sel->tvp);\n\n            unlock_user_struct(sel, arg1, 0);\n\n            ret = do_select(nsel, inp, outp, exp, tvp);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_symlink:\n\n        {\n\n            void *p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg2);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(symlink(p, p2));\n\n            unlock_user(p2, arg2, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_symlinkat) && defined(__NR_symlinkat)\n\n    case TARGET_NR_symlinkat:\n\n        {\n\n            void *p2;\n\n            p  = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg3);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_symlinkat(p, arg2, p2));\n\n            unlock_user(p2, arg3, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_oldlstat\n\n    case TARGET_NR_oldlstat:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_readlink:\n\n        {\n\n            void *p2, *temp;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user(VERIFY_WRITE, arg2, arg3, 0);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else {\n\n                if (strncmp((const char *)p, \"/proc/self/exe\", 14) == 0) {\n\n                    char real[PATH_MAX];\n\n                    temp = realpath(exec_path,real);\n\n                    ret = (temp==NULL) ? get_errno(-1) : strlen(real) ;\n\n                    snprintf((char *)p2, arg3, \"%s\", real);\n\n                    }\n\n                else\n\n                    ret = get_errno(readlink(path(p), p2, arg3));\n\n            }\n\n            unlock_user(p2, arg2, ret);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_readlinkat) && defined(__NR_readlinkat)\n\n    case TARGET_NR_readlinkat:\n\n        {\n\n            void *p2;\n\n            p  = lock_user_string(arg2);\n\n            p2 = lock_user(VERIFY_WRITE, arg3, arg4, 0);\n\n            if (!p || !p2)\n\n        \tret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_readlinkat(arg1, path(p), p2, arg4));\n\n            unlock_user(p2, arg3, ret);\n\n            unlock_user(p, arg2, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_uselib\n\n    case TARGET_NR_uselib:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_swapon\n\n    case TARGET_NR_swapon:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(swapon(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_reboot:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_readdir\n\n    case TARGET_NR_readdir:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_mmap\n\n    case TARGET_NR_mmap:\n\n#if (defined(TARGET_I386) && defined(TARGET_ABI32)) || defined(TARGET_ARM) || defined(TARGET_M68K) || defined(TARGET_CRIS) || defined(TARGET_MICROBLAZE)\n\n        {\n\n            abi_ulong *v;\n\n            abi_ulong v1, v2, v3, v4, v5, v6;\n\n            if (!(v = lock_user(VERIFY_READ, arg1, 6 * sizeof(abi_ulong), 1)))\n\n                goto efault;\n\n            v1 = tswapl(v[0]);\n\n            v2 = tswapl(v[1]);\n\n            v3 = tswapl(v[2]);\n\n            v4 = tswapl(v[3]);\n\n            v5 = tswapl(v[4]);\n\n            v6 = tswapl(v[5]);\n\n            unlock_user(v, arg1, 0);\n\n            ret = get_errno(target_mmap(v1, v2, v3,\n\n                                        target_to_host_bitmask(v4, mmap_flags_tbl),\n\n                                        v5, v6));\n\n        }\n\n#else\n\n        ret = get_errno(target_mmap(arg1, arg2, arg3,\n\n                                    target_to_host_bitmask(arg4, mmap_flags_tbl),\n\n                                    arg5,\n\n                                    arg6));\n\n#endif\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_mmap2\n\n    case TARGET_NR_mmap2:\n\n#ifndef MMAP_SHIFT\n\n#define MMAP_SHIFT 12\n\n#endif\n\n        ret = get_errno(target_mmap(arg1, arg2, arg3,\n\n                                    target_to_host_bitmask(arg4, mmap_flags_tbl),\n\n                                    arg5,\n\n                                    arg6 << MMAP_SHIFT));\n\n        break;\n\n#endif\n\n    case TARGET_NR_munmap:\n\n        ret = get_errno(target_munmap(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_mprotect:\n\n        ret = get_errno(target_mprotect(arg1, arg2, arg3));\n\n        break;\n\n#ifdef TARGET_NR_mremap\n\n    case TARGET_NR_mremap:\n\n        ret = get_errno(target_mremap(arg1, arg2, arg3, arg4, arg5));\n\n        break;\n\n#endif\n\n        /* ??? msync/mlock/munlock are broken for softmmu.  */\n\n#ifdef TARGET_NR_msync\n\n    case TARGET_NR_msync:\n\n        ret = get_errno(msync(g2h(arg1), arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_mlock\n\n    case TARGET_NR_mlock:\n\n        ret = get_errno(mlock(g2h(arg1), arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_munlock\n\n    case TARGET_NR_munlock:\n\n        ret = get_errno(munlock(g2h(arg1), arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_mlockall\n\n    case TARGET_NR_mlockall:\n\n        ret = get_errno(mlockall(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_munlockall\n\n    case TARGET_NR_munlockall:\n\n        ret = get_errno(munlockall());\n\n        break;\n\n#endif\n\n    case TARGET_NR_truncate:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(truncate(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_ftruncate:\n\n        ret = get_errno(ftruncate(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_fchmod:\n\n        ret = get_errno(fchmod(arg1, arg2));\n\n        break;\n\n#if defined(TARGET_NR_fchmodat) && defined(__NR_fchmodat)\n\n    case TARGET_NR_fchmodat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_fchmodat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_getpriority:\n\n        /* libc does special remapping of the return value of\n\n         * sys_getpriority() so it's just easiest to call\n\n         * sys_getpriority() directly rather than through libc. */\n\n        ret = get_errno(sys_getpriority(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_setpriority:\n\n        ret = get_errno(setpriority(arg1, arg2, arg3));\n\n        break;\n\n#ifdef TARGET_NR_profil\n\n    case TARGET_NR_profil:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_statfs:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(statfs(path(p), &stfs));\n\n        unlock_user(p, arg1, 0);\n\n    convert_statfs:\n\n        if (!is_error(ret)) {\n\n            struct target_statfs *target_stfs;\n\n\n\n            if (!lock_user_struct(VERIFY_WRITE, target_stfs, arg2, 0))\n\n                goto efault;\n\n            __put_user(stfs.f_type, &target_stfs->f_type);\n\n            __put_user(stfs.f_bsize, &target_stfs->f_bsize);\n\n            __put_user(stfs.f_blocks, &target_stfs->f_blocks);\n\n            __put_user(stfs.f_bfree, &target_stfs->f_bfree);\n\n            __put_user(stfs.f_bavail, &target_stfs->f_bavail);\n\n            __put_user(stfs.f_files, &target_stfs->f_files);\n\n            __put_user(stfs.f_ffree, &target_stfs->f_ffree);\n\n            __put_user(stfs.f_fsid.__val[0], &target_stfs->f_fsid.val[0]);\n\n            __put_user(stfs.f_fsid.__val[1], &target_stfs->f_fsid.val[1]);\n\n            __put_user(stfs.f_namelen, &target_stfs->f_namelen);\n\n            unlock_user_struct(target_stfs, arg2, 1);\n\n        }\n\n        break;\n\n    case TARGET_NR_fstatfs:\n\n        ret = get_errno(fstatfs(arg1, &stfs));\n\n        goto convert_statfs;\n\n#ifdef TARGET_NR_statfs64\n\n    case TARGET_NR_statfs64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(statfs(path(p), &stfs));\n\n        unlock_user(p, arg1, 0);\n\n    convert_statfs64:\n\n        if (!is_error(ret)) {\n\n            struct target_statfs64 *target_stfs;\n\n\n\n            if (!lock_user_struct(VERIFY_WRITE, target_stfs, arg3, 0))\n\n                goto efault;\n\n            __put_user(stfs.f_type, &target_stfs->f_type);\n\n            __put_user(stfs.f_bsize, &target_stfs->f_bsize);\n\n            __put_user(stfs.f_blocks, &target_stfs->f_blocks);\n\n            __put_user(stfs.f_bfree, &target_stfs->f_bfree);\n\n            __put_user(stfs.f_bavail, &target_stfs->f_bavail);\n\n            __put_user(stfs.f_files, &target_stfs->f_files);\n\n            __put_user(stfs.f_ffree, &target_stfs->f_ffree);\n\n            __put_user(stfs.f_fsid.__val[0], &target_stfs->f_fsid.val[0]);\n\n            __put_user(stfs.f_fsid.__val[1], &target_stfs->f_fsid.val[1]);\n\n            __put_user(stfs.f_namelen, &target_stfs->f_namelen);\n\n            unlock_user_struct(target_stfs, arg3, 1);\n\n        }\n\n        break;\n\n    case TARGET_NR_fstatfs64:\n\n        ret = get_errno(fstatfs(arg1, &stfs));\n\n        goto convert_statfs64;\n\n#endif\n\n#ifdef TARGET_NR_ioperm\n\n    case TARGET_NR_ioperm:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_socketcall\n\n    case TARGET_NR_socketcall:\n\n        ret = do_socketcall(arg1, arg2);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_accept\n\n    case TARGET_NR_accept:\n\n        ret = do_accept(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_bind\n\n    case TARGET_NR_bind:\n\n        ret = do_bind(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_connect\n\n    case TARGET_NR_connect:\n\n        ret = do_connect(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getpeername\n\n    case TARGET_NR_getpeername:\n\n        ret = do_getpeername(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getsockname\n\n    case TARGET_NR_getsockname:\n\n        ret = do_getsockname(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getsockopt\n\n    case TARGET_NR_getsockopt:\n\n        ret = do_getsockopt(arg1, arg2, arg3, arg4, arg5);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_listen\n\n    case TARGET_NR_listen:\n\n        ret = get_errno(listen(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_recv\n\n    case TARGET_NR_recv:\n\n        ret = do_recvfrom(arg1, arg2, arg3, arg4, 0, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_recvfrom\n\n    case TARGET_NR_recvfrom:\n\n        ret = do_recvfrom(arg1, arg2, arg3, arg4, arg5, arg6);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_recvmsg\n\n    case TARGET_NR_recvmsg:\n\n        ret = do_sendrecvmsg(arg1, arg2, arg3, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_send\n\n    case TARGET_NR_send:\n\n        ret = do_sendto(arg1, arg2, arg3, arg4, 0, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sendmsg\n\n    case TARGET_NR_sendmsg:\n\n        ret = do_sendrecvmsg(arg1, arg2, arg3, 1);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sendto\n\n    case TARGET_NR_sendto:\n\n        ret = do_sendto(arg1, arg2, arg3, arg4, arg5, arg6);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shutdown\n\n    case TARGET_NR_shutdown:\n\n        ret = get_errno(shutdown(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_socket\n\n    case TARGET_NR_socket:\n\n        ret = do_socket(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_socketpair\n\n    case TARGET_NR_socketpair:\n\n        ret = do_socketpair(arg1, arg2, arg3, arg4);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setsockopt\n\n    case TARGET_NR_setsockopt:\n\n        ret = do_setsockopt(arg1, arg2, arg3, arg4, (socklen_t) arg5);\n\n        break;\n\n#endif\n\n\n\n    case TARGET_NR_syslog:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_syslog((int)arg1, p, (int)arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n\n\n    case TARGET_NR_setitimer:\n\n        {\n\n            struct itimerval value, ovalue, *pvalue;\n\n\n\n            if (arg2) {\n\n                pvalue = &value;\n\n                if (copy_from_user_timeval(&pvalue->it_interval, arg2)\n\n                    || copy_from_user_timeval(&pvalue->it_value,\n\n                                              arg2 + sizeof(struct target_timeval)))\n\n                    goto efault;\n\n            } else {\n\n                pvalue = NULL;\n\n            }\n\n            ret = get_errno(setitimer(arg1, pvalue, &ovalue));\n\n            if (!is_error(ret) && arg3) {\n\n                if (copy_to_user_timeval(arg3,\n\n                                         &ovalue.it_interval)\n\n                    || copy_to_user_timeval(arg3 + sizeof(struct target_timeval),\n\n                                            &ovalue.it_value))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_getitimer:\n\n        {\n\n            struct itimerval value;\n\n\n\n            ret = get_errno(getitimer(arg1, &value));\n\n            if (!is_error(ret) && arg2) {\n\n                if (copy_to_user_timeval(arg2,\n\n                                         &value.it_interval)\n\n                    || copy_to_user_timeval(arg2 + sizeof(struct target_timeval),\n\n                                            &value.it_value))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_stat:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(stat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        goto do_stat;\n\n    case TARGET_NR_lstat:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lstat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        goto do_stat;\n\n    case TARGET_NR_fstat:\n\n        {\n\n            ret = get_errno(fstat(arg1, &st));\n\n        do_stat:\n\n            if (!is_error(ret)) {\n\n                struct target_stat *target_st;\n\n\n\n                if (!lock_user_struct(VERIFY_WRITE, target_st, arg2, 0))\n\n                    goto efault;\n\n                memset(target_st, 0, sizeof(*target_st));\n\n                __put_user(st.st_dev, &target_st->st_dev);\n\n                __put_user(st.st_ino, &target_st->st_ino);\n\n                __put_user(st.st_mode, &target_st->st_mode);\n\n                __put_user(st.st_uid, &target_st->st_uid);\n\n                __put_user(st.st_gid, &target_st->st_gid);\n\n                __put_user(st.st_nlink, &target_st->st_nlink);\n\n                __put_user(st.st_rdev, &target_st->st_rdev);\n\n                __put_user(st.st_size, &target_st->st_size);\n\n                __put_user(st.st_blksize, &target_st->st_blksize);\n\n                __put_user(st.st_blocks, &target_st->st_blocks);\n\n                __put_user(st.st_atime, &target_st->target_st_atime);\n\n                __put_user(st.st_mtime, &target_st->target_st_mtime);\n\n                __put_user(st.st_ctime, &target_st->target_st_ctime);\n\n                unlock_user_struct(target_st, arg2, 1);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_olduname\n\n    case TARGET_NR_olduname:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_iopl\n\n    case TARGET_NR_iopl:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_vhangup:\n\n        ret = get_errno(vhangup());\n\n        break;\n\n#ifdef TARGET_NR_idle\n\n    case TARGET_NR_idle:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_syscall\n\n    case TARGET_NR_syscall:\n\n    \tret = do_syscall(cpu_env,arg1 & 0xffff,arg2,arg3,arg4,arg5,arg6,0);\n\n    \tbreak;\n\n#endif\n\n    case TARGET_NR_wait4:\n\n        {\n\n            int status;\n\n            abi_long status_ptr = arg2;\n\n            struct rusage rusage, *rusage_ptr;\n\n            abi_ulong target_rusage = arg4;\n\n            if (target_rusage)\n\n                rusage_ptr = &rusage;\n\n            else\n\n                rusage_ptr = NULL;\n\n            ret = get_errno(wait4(arg1, &status, arg3, rusage_ptr));\n\n            if (!is_error(ret)) {\n\n                if (status_ptr) {\n\n                    status = host_to_target_waitstatus(status);\n\n                    if (put_user_s32(status, status_ptr))\n\n                        goto efault;\n\n                }\n\n                if (target_rusage)\n\n                    host_to_target_rusage(target_rusage, &rusage);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_swapoff\n\n    case TARGET_NR_swapoff:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(swapoff(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_sysinfo:\n\n        {\n\n            struct target_sysinfo *target_value;\n\n            struct sysinfo value;\n\n            ret = get_errno(sysinfo(&value));\n\n            if (!is_error(ret) && arg1)\n\n            {\n\n                if (!lock_user_struct(VERIFY_WRITE, target_value, arg1, 0))\n\n                    goto efault;\n\n                __put_user(value.uptime, &target_value->uptime);\n\n                __put_user(value.loads[0], &target_value->loads[0]);\n\n                __put_user(value.loads[1], &target_value->loads[1]);\n\n                __put_user(value.loads[2], &target_value->loads[2]);\n\n                __put_user(value.totalram, &target_value->totalram);\n\n                __put_user(value.freeram, &target_value->freeram);\n\n                __put_user(value.sharedram, &target_value->sharedram);\n\n                __put_user(value.bufferram, &target_value->bufferram);\n\n                __put_user(value.totalswap, &target_value->totalswap);\n\n                __put_user(value.freeswap, &target_value->freeswap);\n\n                __put_user(value.procs, &target_value->procs);\n\n                __put_user(value.totalhigh, &target_value->totalhigh);\n\n                __put_user(value.freehigh, &target_value->freehigh);\n\n                __put_user(value.mem_unit, &target_value->mem_unit);\n\n                unlock_user_struct(target_value, arg1, 1);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_ipc\n\n    case TARGET_NR_ipc:\n\n\tret = do_ipc(arg1, arg2, arg3, arg4, arg5, arg6);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_semget\n\n    case TARGET_NR_semget:\n\n        ret = get_errno(semget(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_semop\n\n    case TARGET_NR_semop:\n\n        ret = get_errno(do_semop(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_semctl\n\n    case TARGET_NR_semctl:\n\n        ret = do_semctl(arg1, arg2, arg3, (union target_semun)(abi_ulong)arg4);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgctl\n\n    case TARGET_NR_msgctl:\n\n        ret = do_msgctl(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgget\n\n    case TARGET_NR_msgget:\n\n        ret = get_errno(msgget(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgrcv\n\n    case TARGET_NR_msgrcv:\n\n        ret = do_msgrcv(arg1, arg2, arg3, arg4, arg5);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgsnd\n\n    case TARGET_NR_msgsnd:\n\n        ret = do_msgsnd(arg1, arg2, arg3, arg4);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmget\n\n    case TARGET_NR_shmget:\n\n        ret = get_errno(shmget(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmctl\n\n    case TARGET_NR_shmctl:\n\n        ret = do_shmctl(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmat\n\n    case TARGET_NR_shmat:\n\n        ret = do_shmat(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmdt\n\n    case TARGET_NR_shmdt:\n\n        ret = do_shmdt(arg1);\n\n        break;\n\n#endif\n\n    case TARGET_NR_fsync:\n\n        ret = get_errno(fsync(arg1));\n\n        break;\n\n    case TARGET_NR_clone:\n\n#if defined(TARGET_SH4)\n\n        ret = get_errno(do_fork(cpu_env, arg1, arg2, arg3, arg5, arg4));\n\n#elif defined(TARGET_CRIS)\n\n        ret = get_errno(do_fork(cpu_env, arg2, arg1, arg3, arg4, arg5));\n\n#else\n\n        ret = get_errno(do_fork(cpu_env, arg1, arg2, arg3, arg4, arg5));\n\n#endif\n\n        break;\n\n#ifdef __NR_exit_group\n\n        /* new thread calls */\n\n    case TARGET_NR_exit_group:\n\n#ifdef TARGET_GPROF\n\n        _mcleanup();\n\n#endif\n\n        gdb_exit(cpu_env, arg1);\n\n        ret = get_errno(exit_group(arg1));\n\n        break;\n\n#endif\n\n    case TARGET_NR_setdomainname:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(setdomainname(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_uname:\n\n        /* no need to transcode because we use the linux syscall */\n\n        {\n\n            struct new_utsname * buf;\n\n\n\n            if (!lock_user_struct(VERIFY_WRITE, buf, arg1, 0))\n\n                goto efault;\n\n            ret = get_errno(sys_uname(buf));\n\n            if (!is_error(ret)) {\n\n                /* Overrite the native machine name with whatever is being\n\n                   emulated. */\n\n                strcpy (buf->machine, cpu_to_uname_machine(cpu_env));\n\n                /* Allow the user to override the reported release.  */\n\n                if (qemu_uname_release && *qemu_uname_release)\n\n                  strcpy (buf->release, qemu_uname_release);\n\n            }\n\n            unlock_user_struct(buf, arg1, 1);\n\n        }\n\n        break;\n\n#ifdef TARGET_I386\n\n    case TARGET_NR_modify_ldt:\n\n        ret = do_modify_ldt(cpu_env, arg1, arg2, arg3);\n\n        break;\n\n#if !defined(TARGET_X86_64)\n\n    case TARGET_NR_vm86old:\n\n        goto unimplemented;\n\n    case TARGET_NR_vm86:\n\n        ret = do_vm86(cpu_env, arg1, arg2);\n\n        break;\n\n#endif\n\n#endif\n\n    case TARGET_NR_adjtimex:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_create_module\n\n    case TARGET_NR_create_module:\n\n#endif\n\n    case TARGET_NR_init_module:\n\n    case TARGET_NR_delete_module:\n\n#ifdef TARGET_NR_get_kernel_syms\n\n    case TARGET_NR_get_kernel_syms:\n\n#endif\n\n        goto unimplemented;\n\n    case TARGET_NR_quotactl:\n\n        goto unimplemented;\n\n    case TARGET_NR_getpgid:\n\n        ret = get_errno(getpgid(arg1));\n\n        break;\n\n    case TARGET_NR_fchdir:\n\n        ret = get_errno(fchdir(arg1));\n\n        break;\n\n#ifdef TARGET_NR_bdflush /* not on x86_64 */\n\n    case TARGET_NR_bdflush:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_sysfs\n\n    case TARGET_NR_sysfs:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_personality:\n\n        ret = get_errno(personality(arg1));\n\n        break;\n\n#ifdef TARGET_NR_afs_syscall\n\n    case TARGET_NR_afs_syscall:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR__llseek /* Not on alpha */\n\n    case TARGET_NR__llseek:\n\n        {\n\n#if defined (__x86_64__)\n\n            ret = get_errno(lseek(arg1, ((uint64_t )arg2 << 32) | arg3, arg5));\n\n            if (put_user_s64(ret, arg4))\n\n                goto efault;\n\n#else\n\n            int64_t res;\n\n            ret = get_errno(_llseek(arg1, arg2, arg3, &res, arg5));\n\n            if (put_user_s64(res, arg4))\n\n                goto efault;\n\n#endif\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_getdents:\n\n#if TARGET_ABI_BITS == 32 && HOST_LONG_BITS == 64\n\n        {\n\n            struct target_dirent *target_dirp;\n\n            struct linux_dirent *dirp;\n\n            abi_long count = arg3;\n\n\n\n\t    dirp = malloc(count);\n\n\t    if (!dirp) {\n\n                ret = -TARGET_ENOMEM;\n\n                goto fail;\n\n            }\n\n\n\n            ret = get_errno(sys_getdents(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct linux_dirent *de;\n\n\t\tstruct target_dirent *tde;\n\n                int len = ret;\n\n                int reclen, treclen;\n\n\t\tint count1, tnamelen;\n\n\n\n\t\tcount1 = 0;\n\n                de = dirp;\n\n                if (!(target_dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))\n\n                    goto efault;\n\n\t\ttde = target_dirp;\n\n                while (len > 0) {\n\n                    reclen = de->d_reclen;\n\n\t\t    treclen = reclen - (2 * (sizeof(long) - sizeof(abi_long)));\n\n                    tde->d_reclen = tswap16(treclen);\n\n                    tde->d_ino = tswapl(de->d_ino);\n\n                    tde->d_off = tswapl(de->d_off);\n\n\t\t    tnamelen = treclen - (2 * sizeof(abi_long) + 2);\n\n\t\t    if (tnamelen > 256)\n\n                        tnamelen = 256;\n\n                    /* XXX: may not be correct */\n\n                    pstrcpy(tde->d_name, tnamelen, de->d_name);\n\n                    de = (struct linux_dirent *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                    tde = (struct target_dirent *)((char *)tde + treclen);\n\n\t\t    count1 += treclen;\n\n                }\n\n\t\tret = count1;\n\n                unlock_user(target_dirp, arg2, ret);\n\n            }\n\n\t    free(dirp);\n\n        }\n\n#else\n\n        {\n\n            struct linux_dirent *dirp;\n\n            abi_long count = arg3;\n\n\n\n            if (!(dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))\n\n                goto efault;\n\n            ret = get_errno(sys_getdents(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct linux_dirent *de;\n\n                int len = ret;\n\n                int reclen;\n\n                de = dirp;\n\n                while (len > 0) {\n\n                    reclen = de->d_reclen;\n\n                    if (reclen > len)\n\n                        break;\n\n                    de->d_reclen = tswap16(reclen);\n\n                    tswapls(&de->d_ino);\n\n                    tswapls(&de->d_off);\n\n                    de = (struct linux_dirent *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                }\n\n            }\n\n            unlock_user(dirp, arg2, ret);\n\n        }\n\n#endif\n\n        break;\n\n#if defined(TARGET_NR_getdents64) && defined(__NR_getdents64)\n\n    case TARGET_NR_getdents64:\n\n        {\n\n            struct linux_dirent64 *dirp;\n\n            abi_long count = arg3;\n\n            if (!(dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))\n\n                goto efault;\n\n            ret = get_errno(sys_getdents64(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct linux_dirent64 *de;\n\n                int len = ret;\n\n                int reclen;\n\n                de = dirp;\n\n                while (len > 0) {\n\n                    reclen = de->d_reclen;\n\n                    if (reclen > len)\n\n                        break;\n\n                    de->d_reclen = tswap16(reclen);\n\n                    tswap64s((uint64_t *)&de->d_ino);\n\n                    tswap64s((uint64_t *)&de->d_off);\n\n                    de = (struct linux_dirent64 *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                }\n\n            }\n\n            unlock_user(dirp, arg2, ret);\n\n        }\n\n        break;\n\n#endif /* TARGET_NR_getdents64 */\n\n#ifdef TARGET_NR__newselect\n\n    case TARGET_NR__newselect:\n\n        ret = do_select(arg1, arg2, arg3, arg4, arg5);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_poll\n\n    case TARGET_NR_poll:\n\n        {\n\n            struct target_pollfd *target_pfd;\n\n            unsigned int nfds = arg2;\n\n            int timeout = arg3;\n\n            struct pollfd *pfd;\n\n            unsigned int i;\n\n\n\n            target_pfd = lock_user(VERIFY_WRITE, arg1, sizeof(struct target_pollfd) * nfds, 1);\n\n            if (!target_pfd)\n\n                goto efault;\n\n            pfd = alloca(sizeof(struct pollfd) * nfds);\n\n            for(i = 0; i < nfds; i++) {\n\n                pfd[i].fd = tswap32(target_pfd[i].fd);\n\n                pfd[i].events = tswap16(target_pfd[i].events);\n\n            }\n\n            ret = get_errno(poll(pfd, nfds, timeout));\n\n            if (!is_error(ret)) {\n\n                for(i = 0; i < nfds; i++) {\n\n                    target_pfd[i].revents = tswap16(pfd[i].revents);\n\n                }\n\n                ret += nfds * (sizeof(struct target_pollfd)\n\n                               - sizeof(struct pollfd));\n\n            }\n\n            unlock_user(target_pfd, arg1, ret);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_flock:\n\n        /* NOTE: the flock constant seems to be the same for every\n\n           Linux platform */\n\n        ret = get_errno(flock(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_readv:\n\n        {\n\n            int count = arg3;\n\n            struct iovec *vec;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            if (lock_iovec(VERIFY_WRITE, vec, arg2, count, 0) < 0)\n\n                goto efault;\n\n            ret = get_errno(readv(arg1, vec, count));\n\n            unlock_iovec(vec, arg2, count, 1);\n\n        }\n\n        break;\n\n    case TARGET_NR_writev:\n\n        {\n\n            int count = arg3;\n\n            struct iovec *vec;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            if (lock_iovec(VERIFY_READ, vec, arg2, count, 1) < 0)\n\n                goto efault;\n\n            ret = get_errno(writev(arg1, vec, count));\n\n            unlock_iovec(vec, arg2, count, 0);\n\n        }\n\n        break;\n\n    case TARGET_NR_getsid:\n\n        ret = get_errno(getsid(arg1));\n\n        break;\n\n#if defined(TARGET_NR_fdatasync) /* Not on alpha (osf_datasync ?) */\n\n    case TARGET_NR_fdatasync:\n\n        ret = get_errno(fdatasync(arg1));\n\n        break;\n\n#endif\n\n    case TARGET_NR__sysctl:\n\n        /* We don't implement this, but ENOTDIR is always a safe\n\n           return value. */\n\n        ret = -TARGET_ENOTDIR;\n\n        break;\n\n    case TARGET_NR_sched_setparam:\n\n        {\n\n            struct sched_param *target_schp;\n\n            struct sched_param schp;\n\n\n\n            if (!lock_user_struct(VERIFY_READ, target_schp, arg2, 1))\n\n                goto efault;\n\n            schp.sched_priority = tswap32(target_schp->sched_priority);\n\n            unlock_user_struct(target_schp, arg2, 0);\n\n            ret = get_errno(sched_setparam(arg1, &schp));\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_getparam:\n\n        {\n\n            struct sched_param *target_schp;\n\n            struct sched_param schp;\n\n            ret = get_errno(sched_getparam(arg1, &schp));\n\n            if (!is_error(ret)) {\n\n                if (!lock_user_struct(VERIFY_WRITE, target_schp, arg2, 0))\n\n                    goto efault;\n\n                target_schp->sched_priority = tswap32(schp.sched_priority);\n\n                unlock_user_struct(target_schp, arg2, 1);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_setscheduler:\n\n        {\n\n            struct sched_param *target_schp;\n\n            struct sched_param schp;\n\n            if (!lock_user_struct(VERIFY_READ, target_schp, arg3, 1))\n\n                goto efault;\n\n            schp.sched_priority = tswap32(target_schp->sched_priority);\n\n            unlock_user_struct(target_schp, arg3, 0);\n\n            ret = get_errno(sched_setscheduler(arg1, arg2, &schp));\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_getscheduler:\n\n        ret = get_errno(sched_getscheduler(arg1));\n\n        break;\n\n    case TARGET_NR_sched_yield:\n\n        ret = get_errno(sched_yield());\n\n        break;\n\n    case TARGET_NR_sched_get_priority_max:\n\n        ret = get_errno(sched_get_priority_max(arg1));\n\n        break;\n\n    case TARGET_NR_sched_get_priority_min:\n\n        ret = get_errno(sched_get_priority_min(arg1));\n\n        break;\n\n    case TARGET_NR_sched_rr_get_interval:\n\n        {\n\n            struct timespec ts;\n\n            ret = get_errno(sched_rr_get_interval(arg1, &ts));\n\n            if (!is_error(ret)) {\n\n                host_to_target_timespec(arg2, &ts);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_nanosleep:\n\n        {\n\n            struct timespec req, rem;\n\n            target_to_host_timespec(&req, arg1);\n\n            ret = get_errno(nanosleep(&req, &rem));\n\n            if (is_error(ret) && arg2) {\n\n                host_to_target_timespec(arg2, &rem);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_query_module\n\n    case TARGET_NR_query_module:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_nfsservctl\n\n    case TARGET_NR_nfsservctl:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_prctl:\n\n        switch (arg1)\n\n            {\n\n            case PR_GET_PDEATHSIG:\n\n                {\n\n                    int deathsig;\n\n                    ret = get_errno(prctl(arg1, &deathsig, arg3, arg4, arg5));\n\n                    if (!is_error(ret) && arg2\n\n                        && put_user_ual(deathsig, arg2))\n\n                        goto efault;\n\n                }\n\n                break;\n\n            default:\n\n                ret = get_errno(prctl(arg1, arg2, arg3, arg4, arg5));\n\n                break;\n\n            }\n\n        break;\n\n#ifdef TARGET_NR_arch_prctl\n\n    case TARGET_NR_arch_prctl:\n\n#if defined(TARGET_I386) && !defined(TARGET_ABI32)\n\n        ret = do_arch_prctl(cpu_env, arg1, arg2);\n\n        break;\n\n#else\n\n        goto unimplemented;\n\n#endif\n\n#endif\n\n#ifdef TARGET_NR_pread\n\n    case TARGET_NR_pread:\n\n#ifdef TARGET_ARM\n\n        if (((CPUARMState *)cpu_env)->eabi)\n\n            arg4 = arg5;\n\n#endif\n\n        if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))\n\n            goto efault;\n\n        ret = get_errno(pread(arg1, p, arg3, arg4));\n\n        unlock_user(p, arg2, ret);\n\n        break;\n\n    case TARGET_NR_pwrite:\n\n#ifdef TARGET_ARM\n\n        if (((CPUARMState *)cpu_env)->eabi)\n\n            arg4 = arg5;\n\n#endif\n\n        if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))\n\n            goto efault;\n\n        ret = get_errno(pwrite(arg1, p, arg3, arg4));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_pread64\n\n    case TARGET_NR_pread64:\n\n        if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))\n\n            goto efault;\n\n        ret = get_errno(pread64(arg1, p, arg3, target_offset64(arg4, arg5)));\n\n        unlock_user(p, arg2, ret);\n\n        break;\n\n    case TARGET_NR_pwrite64:\n\n        if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))\n\n            goto efault;\n\n        ret = get_errno(pwrite64(arg1, p, arg3, target_offset64(arg4, arg5)));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_getcwd:\n\n        if (!(p = lock_user(VERIFY_WRITE, arg1, arg2, 0)))\n\n            goto efault;\n\n        ret = get_errno(sys_getcwd1(p, arg2));\n\n        unlock_user(p, arg1, ret);\n\n        break;\n\n    case TARGET_NR_capget:\n\n        goto unimplemented;\n\n    case TARGET_NR_capset:\n\n        goto unimplemented;\n\n    case TARGET_NR_sigaltstack:\n\n#if defined(TARGET_I386) || defined(TARGET_ARM) || defined(TARGET_MIPS) || \\\n\n    defined(TARGET_SPARC) || defined(TARGET_PPC) || defined(TARGET_ALPHA) || \\\n\n    defined(TARGET_M68K)\n\n        ret = do_sigaltstack(arg1, arg2, get_sp_from_cpustate((CPUState *)cpu_env));\n\n        break;\n\n#else\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_sendfile:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_getpmsg\n\n    case TARGET_NR_getpmsg:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_putpmsg\n\n    case TARGET_NR_putpmsg:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_vfork\n\n    case TARGET_NR_vfork:\n\n        ret = get_errno(do_fork(cpu_env, CLONE_VFORK | CLONE_VM | SIGCHLD,\n\n                        0, 0, 0, 0));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_ugetrlimit\n\n    case TARGET_NR_ugetrlimit:\n\n    {\n\n\tstruct rlimit rlim;\n\n\tret = get_errno(getrlimit(arg1, &rlim));\n\n\tif (!is_error(ret)) {\n\n\t    struct target_rlimit *target_rlim;\n\n            if (!lock_user_struct(VERIFY_WRITE, target_rlim, arg2, 0))\n\n                goto efault;\n\n\t    target_rlim->rlim_cur = tswapl(rlim.rlim_cur);\n\n\t    target_rlim->rlim_max = tswapl(rlim.rlim_max);\n\n            unlock_user_struct(target_rlim, arg2, 1);\n\n\t}\n\n\tbreak;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_truncate64\n\n    case TARGET_NR_truncate64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n\tret = target_truncate64(cpu_env, p, arg2, arg3, arg4);\n\n        unlock_user(p, arg1, 0);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_ftruncate64\n\n    case TARGET_NR_ftruncate64:\n\n\tret = target_ftruncate64(cpu_env, arg1, arg2, arg3, arg4);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_stat64\n\n    case TARGET_NR_stat64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(stat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg2, &st);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_lstat64\n\n    case TARGET_NR_lstat64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lstat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg2, &st);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_fstat64\n\n    case TARGET_NR_fstat64:\n\n        ret = get_errno(fstat(arg1, &st));\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg2, &st);\n\n        break;\n\n#endif\n\n#if (defined(TARGET_NR_fstatat64) || defined(TARGET_NR_newfstatat)) && \\\n\n        (defined(__NR_fstatat64) || defined(__NR_newfstatat))\n\n#ifdef TARGET_NR_fstatat64\n\n    case TARGET_NR_fstatat64:\n\n#endif\n\n#ifdef TARGET_NR_newfstatat\n\n    case TARGET_NR_newfstatat:\n\n#endif\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n#ifdef __NR_fstatat64\n\n        ret = get_errno(sys_fstatat64(arg1, path(p), &st, arg4));\n\n#else\n\n        ret = get_errno(sys_newfstatat(arg1, path(p), &st, arg4));\n\n#endif\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg3, &st);\n\n        break;\n\n#endif\n\n#ifdef USE_UID16\n\n    case TARGET_NR_lchown:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lchown(p, low2highuid(arg2), low2highgid(arg3)));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_getuid:\n\n        ret = get_errno(high2lowuid(getuid()));\n\n        break;\n\n    case TARGET_NR_getgid:\n\n        ret = get_errno(high2lowgid(getgid()));\n\n        break;\n\n    case TARGET_NR_geteuid:\n\n        ret = get_errno(high2lowuid(geteuid()));\n\n        break;\n\n    case TARGET_NR_getegid:\n\n        ret = get_errno(high2lowgid(getegid()));\n\n        break;\n\n    case TARGET_NR_setreuid:\n\n        ret = get_errno(setreuid(low2highuid(arg1), low2highuid(arg2)));\n\n        break;\n\n    case TARGET_NR_setregid:\n\n        ret = get_errno(setregid(low2highgid(arg1), low2highgid(arg2)));\n\n        break;\n\n    case TARGET_NR_getgroups:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint16_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            ret = get_errno(getgroups(gidsetsize, grouplist));\n\n            if (gidsetsize == 0)\n\n                break;\n\n            if (!is_error(ret)) {\n\n                target_grouplist = lock_user(VERIFY_WRITE, arg2, gidsetsize * 2, 0);\n\n                if (!target_grouplist)\n\n                    goto efault;\n\n                for(i = 0;i < ret; i++)\n\n                    target_grouplist[i] = tswap16(grouplist[i]);\n\n                unlock_user(target_grouplist, arg2, gidsetsize * 2);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_setgroups:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint16_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            target_grouplist = lock_user(VERIFY_READ, arg2, gidsetsize * 2, 1);\n\n            if (!target_grouplist) {\n\n                ret = -TARGET_EFAULT;\n\n                goto fail;\n\n            }\n\n            for(i = 0;i < gidsetsize; i++)\n\n                grouplist[i] = tswap16(target_grouplist[i]);\n\n            unlock_user(target_grouplist, arg2, 0);\n\n            ret = get_errno(setgroups(gidsetsize, grouplist));\n\n        }\n\n        break;\n\n    case TARGET_NR_fchown:\n\n        ret = get_errno(fchown(arg1, low2highuid(arg2), low2highgid(arg3)));\n\n        break;\n\n#if defined(TARGET_NR_fchownat) && defined(__NR_fchownat)\n\n    case TARGET_NR_fchownat:\n\n        if (!(p = lock_user_string(arg2))) \n\n            goto efault;\n\n        ret = get_errno(sys_fchownat(arg1, p, low2highuid(arg3), low2highgid(arg4), arg5));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setresuid\n\n    case TARGET_NR_setresuid:\n\n        ret = get_errno(setresuid(low2highuid(arg1),\n\n                                  low2highuid(arg2),\n\n                                  low2highuid(arg3)));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresuid\n\n    case TARGET_NR_getresuid:\n\n        {\n\n            uid_t ruid, euid, suid;\n\n            ret = get_errno(getresuid(&ruid, &euid, &suid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u16(high2lowuid(ruid), arg1)\n\n                    || put_user_u16(high2lowuid(euid), arg2)\n\n                    || put_user_u16(high2lowuid(suid), arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresgid\n\n    case TARGET_NR_setresgid:\n\n        ret = get_errno(setresgid(low2highgid(arg1),\n\n                                  low2highgid(arg2),\n\n                                  low2highgid(arg3)));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresgid\n\n    case TARGET_NR_getresgid:\n\n        {\n\n            gid_t rgid, egid, sgid;\n\n            ret = get_errno(getresgid(&rgid, &egid, &sgid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u16(high2lowgid(rgid), arg1)\n\n                    || put_user_u16(high2lowgid(egid), arg2)\n\n                    || put_user_u16(high2lowgid(sgid), arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_chown:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chown(p, low2highuid(arg2), low2highgid(arg3)));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_setuid:\n\n        ret = get_errno(setuid(low2highuid(arg1)));\n\n        break;\n\n    case TARGET_NR_setgid:\n\n        ret = get_errno(setgid(low2highgid(arg1)));\n\n        break;\n\n    case TARGET_NR_setfsuid:\n\n        ret = get_errno(setfsuid(arg1));\n\n        break;\n\n    case TARGET_NR_setfsgid:\n\n        ret = get_errno(setfsgid(arg1));\n\n        break;\n\n#endif /* USE_UID16 */\n\n\n\n#ifdef TARGET_NR_lchown32\n\n    case TARGET_NR_lchown32:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lchown(p, arg2, arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getuid32\n\n    case TARGET_NR_getuid32:\n\n        ret = get_errno(getuid());\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_getxuid) && defined(TARGET_ALPHA)\n\n   /* Alpha specific */\n\n    case TARGET_NR_getxuid:\n\n         {\n\n            uid_t euid;\n\n            euid=geteuid();\n\n            ((CPUAlphaState *)cpu_env)->ir[IR_A4]=euid;\n\n         }\n\n        ret = get_errno(getuid());\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_getxgid) && defined(TARGET_ALPHA)\n\n   /* Alpha specific */\n\n    case TARGET_NR_getxgid:\n\n         {\n\n            uid_t egid;\n\n            egid=getegid();\n\n            ((CPUAlphaState *)cpu_env)->ir[IR_A4]=egid;\n\n         }\n\n        ret = get_errno(getgid());\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_osf_getsysinfo) && defined(TARGET_ALPHA)\n\n    /* Alpha specific */\n\n    case TARGET_NR_osf_getsysinfo:\n\n        ret = -TARGET_EOPNOTSUPP;\n\n        switch (arg1) {\n\n          case TARGET_GSI_IEEE_FP_CONTROL:\n\n            {\n\n                uint64_t swcr, fpcr = cpu_alpha_load_fpcr (cpu_env);\n\n\n\n                /* Copied from linux ieee_fpcr_to_swcr.  */\n\n                swcr = (fpcr >> 35) & SWCR_STATUS_MASK;\n\n                swcr |= (fpcr >> 36) & SWCR_MAP_DMZ;\n\n                swcr |= (~fpcr >> 48) & (SWCR_TRAP_ENABLE_INV\n\n                                        | SWCR_TRAP_ENABLE_DZE\n\n                                        | SWCR_TRAP_ENABLE_OVF);\n\n                swcr |= (~fpcr >> 57) & (SWCR_TRAP_ENABLE_UNF\n\n                                        | SWCR_TRAP_ENABLE_INE);\n\n                swcr |= (fpcr >> 47) & SWCR_MAP_UMZ;\n\n                swcr |= (~fpcr >> 41) & SWCR_TRAP_ENABLE_DNO;\n\n\n\n                if (put_user_u64 (swcr, arg2))\n\n                        goto efault;\n\n                ret = 0;\n\n            }\n\n            break;\n\n\n\n          /* case GSI_IEEE_STATE_AT_SIGNAL:\n\n             -- Not implemented in linux kernel.\n\n             case GSI_UACPROC:\n\n             -- Retrieves current unaligned access state; not much used.\n\n             case GSI_PROC_TYPE:\n\n             -- Retrieves implver information; surely not used.\n\n             case GSI_GET_HWRPB:\n\n             -- Grabs a copy of the HWRPB; surely not used.\n\n          */\n\n        }\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_osf_setsysinfo) && defined(TARGET_ALPHA)\n\n    /* Alpha specific */\n\n    case TARGET_NR_osf_setsysinfo:\n\n        ret = -TARGET_EOPNOTSUPP;\n\n        switch (arg1) {\n\n          case TARGET_SSI_IEEE_FP_CONTROL:\n\n          case TARGET_SSI_IEEE_RAISE_EXCEPTION:\n\n            {\n\n                uint64_t swcr, fpcr, orig_fpcr;\n\n\n\n                if (get_user_u64 (swcr, arg2))\n\n                    goto efault;\n\n                orig_fpcr = cpu_alpha_load_fpcr (cpu_env);\n\n                fpcr = orig_fpcr & FPCR_DYN_MASK;\n\n\n\n                /* Copied from linux ieee_swcr_to_fpcr.  */\n\n                fpcr |= (swcr & SWCR_STATUS_MASK) << 35;\n\n                fpcr |= (swcr & SWCR_MAP_DMZ) << 36;\n\n                fpcr |= (~swcr & (SWCR_TRAP_ENABLE_INV\n\n                                  | SWCR_TRAP_ENABLE_DZE\n\n                                  | SWCR_TRAP_ENABLE_OVF)) << 48;\n\n                fpcr |= (~swcr & (SWCR_TRAP_ENABLE_UNF\n\n                                  | SWCR_TRAP_ENABLE_INE)) << 57;\n\n                fpcr |= (swcr & SWCR_MAP_UMZ ? FPCR_UNDZ | FPCR_UNFD : 0);\n\n                fpcr |= (~swcr & SWCR_TRAP_ENABLE_DNO) << 41;\n\n\n\n                cpu_alpha_store_fpcr (cpu_env, fpcr);\n\n                ret = 0;\n\n\n\n                if (arg1 == TARGET_SSI_IEEE_RAISE_EXCEPTION) {\n\n                    /* Old exceptions are not signaled.  */\n\n                    fpcr &= ~(orig_fpcr & FPCR_STATUS_MASK);\n\n\n\n                    /* If any exceptions set by this call, and are unmasked,\n\n                       send a signal.  */\n\n                    /* ??? FIXME */\n\n                }\n\n            }\n\n            break;\n\n\n\n          /* case SSI_NVPAIRS:\n\n             -- Used with SSIN_UACPROC to enable unaligned accesses.\n\n             case SSI_IEEE_STATE_AT_SIGNAL:\n\n             case SSI_IEEE_IGNORE_STATE_AT_SIGNAL:\n\n             -- Not implemented in linux kernel\n\n          */\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_osf_sigprocmask\n\n    /* Alpha specific.  */\n\n    case TARGET_NR_osf_sigprocmask:\n\n        {\n\n            abi_ulong mask;\n\n            int how = arg1;\n\n            sigset_t set, oldset;\n\n\n\n            switch(arg1) {\n\n            case TARGET_SIG_BLOCK:\n\n                how = SIG_BLOCK;\n\n                break;\n\n            case TARGET_SIG_UNBLOCK:\n\n                how = SIG_UNBLOCK;\n\n                break;\n\n            case TARGET_SIG_SETMASK:\n\n                how = SIG_SETMASK;\n\n                break;\n\n            default:\n\n                ret = -TARGET_EINVAL;\n\n                goto fail;\n\n            }\n\n            mask = arg2;\n\n            target_to_host_old_sigset(&set, &mask);\n\n            sigprocmask(arg1, &set, &oldset);\n\n            host_to_target_old_sigset(&mask, &oldset);\n\n            ret = mask;\n\n        }\n\n        break;\n\n#endif\n\n\n\n#ifdef TARGET_NR_getgid32\n\n    case TARGET_NR_getgid32:\n\n        ret = get_errno(getgid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_geteuid32\n\n    case TARGET_NR_geteuid32:\n\n        ret = get_errno(geteuid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getegid32\n\n    case TARGET_NR_getegid32:\n\n        ret = get_errno(getegid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setreuid32\n\n    case TARGET_NR_setreuid32:\n\n        ret = get_errno(setreuid(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setregid32\n\n    case TARGET_NR_setregid32:\n\n        ret = get_errno(setregid(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getgroups32\n\n    case TARGET_NR_getgroups32:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint32_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            ret = get_errno(getgroups(gidsetsize, grouplist));\n\n            if (gidsetsize == 0)\n\n                break;\n\n            if (!is_error(ret)) {\n\n                target_grouplist = lock_user(VERIFY_WRITE, arg2, gidsetsize * 4, 0);\n\n                if (!target_grouplist) {\n\n                    ret = -TARGET_EFAULT;\n\n                    goto fail;\n\n                }\n\n                for(i = 0;i < ret; i++)\n\n                    target_grouplist[i] = tswap32(grouplist[i]);\n\n                unlock_user(target_grouplist, arg2, gidsetsize * 4);\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setgroups32\n\n    case TARGET_NR_setgroups32:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint32_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            target_grouplist = lock_user(VERIFY_READ, arg2, gidsetsize * 4, 1);\n\n            if (!target_grouplist) {\n\n                ret = -TARGET_EFAULT;\n\n                goto fail;\n\n            }\n\n            for(i = 0;i < gidsetsize; i++)\n\n                grouplist[i] = tswap32(target_grouplist[i]);\n\n            unlock_user(target_grouplist, arg2, 0);\n\n            ret = get_errno(setgroups(gidsetsize, grouplist));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_fchown32\n\n    case TARGET_NR_fchown32:\n\n        ret = get_errno(fchown(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setresuid32\n\n    case TARGET_NR_setresuid32:\n\n        ret = get_errno(setresuid(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresuid32\n\n    case TARGET_NR_getresuid32:\n\n        {\n\n            uid_t ruid, euid, suid;\n\n            ret = get_errno(getresuid(&ruid, &euid, &suid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u32(ruid, arg1)\n\n                    || put_user_u32(euid, arg2)\n\n                    || put_user_u32(suid, arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setresgid32\n\n    case TARGET_NR_setresgid32:\n\n        ret = get_errno(setresgid(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresgid32\n\n    case TARGET_NR_getresgid32:\n\n        {\n\n            gid_t rgid, egid, sgid;\n\n            ret = get_errno(getresgid(&rgid, &egid, &sgid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u32(rgid, arg1)\n\n                    || put_user_u32(egid, arg2)\n\n                    || put_user_u32(sgid, arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_chown32\n\n    case TARGET_NR_chown32:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chown(p, arg2, arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setuid32\n\n    case TARGET_NR_setuid32:\n\n        ret = get_errno(setuid(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setgid32\n\n    case TARGET_NR_setgid32:\n\n        ret = get_errno(setgid(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setfsuid32\n\n    case TARGET_NR_setfsuid32:\n\n        ret = get_errno(setfsuid(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setfsgid32\n\n    case TARGET_NR_setfsgid32:\n\n        ret = get_errno(setfsgid(arg1));\n\n        break;\n\n#endif\n\n\n\n    case TARGET_NR_pivot_root:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_mincore\n\n    case TARGET_NR_mincore:\n\n        {\n\n            void *a;\n\n            ret = -TARGET_EFAULT;\n\n            if (!(a = lock_user(VERIFY_READ, arg1,arg2, 0)))\n\n                goto efault;\n\n            if (!(p = lock_user_string(arg3)))\n\n                goto mincore_fail;\n\n            ret = get_errno(mincore(a, arg2, p));\n\n            unlock_user(p, arg3, ret);\n\n            mincore_fail:\n\n            unlock_user(a, arg1, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_arm_fadvise64_64\n\n    case TARGET_NR_arm_fadvise64_64:\n\n\t{\n\n\t\t/*\n\n\t\t * arm_fadvise64_64 looks like fadvise64_64 but\n\n\t\t * with different argument order\n\n\t\t */\n\n\t\tabi_long temp;\n\n\t\ttemp = arg3;\n\n\t\targ3 = arg4;\n\n\t\targ4 = temp;\n\n\t}\n\n#endif\n\n#if defined(TARGET_NR_fadvise64_64) || defined(TARGET_NR_arm_fadvise64_64) || defined(TARGET_NR_fadvise64)\n\n#ifdef TARGET_NR_fadvise64_64\n\n    case TARGET_NR_fadvise64_64:\n\n#endif\n\n#ifdef TARGET_NR_fadvise64\n\n    case TARGET_NR_fadvise64:\n\n#endif\n\n#ifdef TARGET_S390X\n\n        switch (arg4) {\n\n        case 4: arg4 = POSIX_FADV_NOREUSE + 1; break; /* make sure it's an invalid value */\n\n        case 5: arg4 = POSIX_FADV_NOREUSE + 2; break; /* ditto */\n\n        case 6: arg4 = POSIX_FADV_DONTNEED; break;\n\n        case 7: arg4 = POSIX_FADV_NOREUSE; break;\n\n        default: break;\n\n        }\n\n#endif\n\n        ret = -posix_fadvise(arg1, arg2, arg3, arg4);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_madvise\n\n    case TARGET_NR_madvise:\n\n        /* A straight passthrough may not be safe because qemu sometimes\n\n           turns private flie-backed mappings into anonymous mappings.\n\n           This will break MADV_DONTNEED.\n\n           This is a hint, so ignoring and returning success is ok.  */\n\n        ret = get_errno(0);\n\n        break;\n\n#endif\n\n#if TARGET_ABI_BITS == 32\n\n    case TARGET_NR_fcntl64:\n\n    {\n\n\tint cmd;\n\n\tstruct flock64 fl;\n\n\tstruct target_flock64 *target_fl;\n\n#ifdef TARGET_ARM\n\n\tstruct target_eabi_flock64 *target_efl;\n\n#endif\n\n\n\n\tcmd = target_to_host_fcntl_cmd(arg2);\n\n\tif (cmd == -TARGET_EINVAL)\n\n\t\treturn cmd;\n\n\n\n        switch(arg2) {\n\n        case TARGET_F_GETLK64:\n\n#ifdef TARGET_ARM\n\n            if (((CPUARMState *)cpu_env)->eabi) {\n\n                if (!lock_user_struct(VERIFY_READ, target_efl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_efl->l_type);\n\n                fl.l_whence = tswap16(target_efl->l_whence);\n\n                fl.l_start = tswap64(target_efl->l_start);\n\n                fl.l_len = tswap64(target_efl->l_len);\n\n                fl.l_pid = tswap32(target_efl->l_pid);\n\n                unlock_user_struct(target_efl, arg3, 0);\n\n            } else\n\n#endif\n\n            {\n\n                if (!lock_user_struct(VERIFY_READ, target_fl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_fl->l_type);\n\n                fl.l_whence = tswap16(target_fl->l_whence);\n\n                fl.l_start = tswap64(target_fl->l_start);\n\n                fl.l_len = tswap64(target_fl->l_len);\n\n                fl.l_pid = tswap32(target_fl->l_pid);\n\n                unlock_user_struct(target_fl, arg3, 0);\n\n            }\n\n            ret = get_errno(fcntl(arg1, cmd, &fl));\n\n\t    if (ret == 0) {\n\n#ifdef TARGET_ARM\n\n                if (((CPUARMState *)cpu_env)->eabi) {\n\n                    if (!lock_user_struct(VERIFY_WRITE, target_efl, arg3, 0)) \n\n                        goto efault;\n\n                    target_efl->l_type = tswap16(fl.l_type);\n\n                    target_efl->l_whence = tswap16(fl.l_whence);\n\n                    target_efl->l_start = tswap64(fl.l_start);\n\n                    target_efl->l_len = tswap64(fl.l_len);\n\n                    target_efl->l_pid = tswap32(fl.l_pid);\n\n                    unlock_user_struct(target_efl, arg3, 1);\n\n                } else\n\n#endif\n\n                {\n\n                    if (!lock_user_struct(VERIFY_WRITE, target_fl, arg3, 0)) \n\n                        goto efault;\n\n                    target_fl->l_type = tswap16(fl.l_type);\n\n                    target_fl->l_whence = tswap16(fl.l_whence);\n\n                    target_fl->l_start = tswap64(fl.l_start);\n\n                    target_fl->l_len = tswap64(fl.l_len);\n\n                    target_fl->l_pid = tswap32(fl.l_pid);\n\n                    unlock_user_struct(target_fl, arg3, 1);\n\n                }\n\n\t    }\n\n\t    break;\n\n\n\n        case TARGET_F_SETLK64:\n\n        case TARGET_F_SETLKW64:\n\n#ifdef TARGET_ARM\n\n            if (((CPUARMState *)cpu_env)->eabi) {\n\n                if (!lock_user_struct(VERIFY_READ, target_efl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_efl->l_type);\n\n                fl.l_whence = tswap16(target_efl->l_whence);\n\n                fl.l_start = tswap64(target_efl->l_start);\n\n                fl.l_len = tswap64(target_efl->l_len);\n\n                fl.l_pid = tswap32(target_efl->l_pid);\n\n                unlock_user_struct(target_efl, arg3, 0);\n\n            } else\n\n#endif\n\n            {\n\n                if (!lock_user_struct(VERIFY_READ, target_fl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_fl->l_type);\n\n                fl.l_whence = tswap16(target_fl->l_whence);\n\n                fl.l_start = tswap64(target_fl->l_start);\n\n                fl.l_len = tswap64(target_fl->l_len);\n\n                fl.l_pid = tswap32(target_fl->l_pid);\n\n                unlock_user_struct(target_fl, arg3, 0);\n\n            }\n\n            ret = get_errno(fcntl(arg1, cmd, &fl));\n\n\t    break;\n\n        default:\n\n            ret = do_fcntl(arg1, arg2, arg3);\n\n            break;\n\n        }\n\n\tbreak;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_cacheflush\n\n    case TARGET_NR_cacheflush:\n\n        /* self-modifying code is handled automatically, so nothing needed */\n\n        ret = 0;\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_security\n\n    case TARGET_NR_security:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_getpagesize\n\n    case TARGET_NR_getpagesize:\n\n        ret = TARGET_PAGE_SIZE;\n\n        break;\n\n#endif\n\n    case TARGET_NR_gettid:\n\n        ret = get_errno(gettid());\n\n        break;\n\n#ifdef TARGET_NR_readahead\n\n    case TARGET_NR_readahead:\n\n#if TARGET_ABI_BITS == 32\n\n#ifdef TARGET_ARM\n\n        if (((CPUARMState *)cpu_env)->eabi)\n\n        {\n\n            arg2 = arg3;\n\n            arg3 = arg4;\n\n            arg4 = arg5;\n\n        }\n\n#endif\n\n        ret = get_errno(readahead(arg1, ((off64_t)arg3 << 32) | arg2, arg4));\n\n#else\n\n        ret = get_errno(readahead(arg1, arg2, arg3));\n\n#endif\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setxattr\n\n    case TARGET_NR_setxattr:\n\n    case TARGET_NR_lsetxattr:\n\n    case TARGET_NR_fsetxattr:\n\n    case TARGET_NR_getxattr:\n\n    case TARGET_NR_lgetxattr:\n\n    case TARGET_NR_fgetxattr:\n\n    case TARGET_NR_listxattr:\n\n    case TARGET_NR_llistxattr:\n\n    case TARGET_NR_flistxattr:\n\n    case TARGET_NR_removexattr:\n\n    case TARGET_NR_lremovexattr:\n\n    case TARGET_NR_fremovexattr:\n\n        ret = -TARGET_EOPNOTSUPP;\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_set_thread_area\n\n    case TARGET_NR_set_thread_area:\n\n#if defined(TARGET_MIPS)\n\n      ((CPUMIPSState *) cpu_env)->tls_value = arg1;\n\n      ret = 0;\n\n      break;\n\n#elif defined(TARGET_CRIS)\n\n      if (arg1 & 0xff)\n\n          ret = -TARGET_EINVAL;\n\n      else {\n\n          ((CPUCRISState *) cpu_env)->pregs[PR_PID] = arg1;\n\n          ret = 0;\n\n      }\n\n      break;\n\n#elif defined(TARGET_I386) && defined(TARGET_ABI32)\n\n      ret = do_set_thread_area(cpu_env, arg1);\n\n      break;\n\n#else\n\n      goto unimplemented_nowarn;\n\n#endif\n\n#endif\n\n#ifdef TARGET_NR_get_thread_area\n\n    case TARGET_NR_get_thread_area:\n\n#if defined(TARGET_I386) && defined(TARGET_ABI32)\n\n        ret = do_get_thread_area(cpu_env, arg1);\n\n#else\n\n        goto unimplemented_nowarn;\n\n#endif\n\n#endif\n\n#ifdef TARGET_NR_getdomainname\n\n    case TARGET_NR_getdomainname:\n\n        goto unimplemented_nowarn;\n\n#endif\n\n\n\n#ifdef TARGET_NR_clock_gettime\n\n    case TARGET_NR_clock_gettime:\n\n    {\n\n        struct timespec ts;\n\n        ret = get_errno(clock_gettime(arg1, &ts));\n\n        if (!is_error(ret)) {\n\n            host_to_target_timespec(arg2, &ts);\n\n        }\n\n        break;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_clock_getres\n\n    case TARGET_NR_clock_getres:\n\n    {\n\n        struct timespec ts;\n\n        ret = get_errno(clock_getres(arg1, &ts));\n\n        if (!is_error(ret)) {\n\n            host_to_target_timespec(arg2, &ts);\n\n        }\n\n        break;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_clock_nanosleep\n\n    case TARGET_NR_clock_nanosleep:\n\n    {\n\n        struct timespec ts;\n\n        target_to_host_timespec(&ts, arg3);\n\n        ret = get_errno(clock_nanosleep(arg1, arg2, &ts, arg4 ? &ts : NULL));\n\n        if (arg4)\n\n            host_to_target_timespec(arg4, &ts);\n\n        break;\n\n    }\n\n#endif\n\n\n\n#if defined(TARGET_NR_set_tid_address) && defined(__NR_set_tid_address)\n\n    case TARGET_NR_set_tid_address:\n\n        ret = get_errno(set_tid_address((int *)g2h(arg1)));\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_tkill) && defined(__NR_tkill)\n\n    case TARGET_NR_tkill:\n\n        ret = get_errno(sys_tkill((int)arg1, target_to_host_signal(arg2)));\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_tgkill) && defined(__NR_tgkill)\n\n    case TARGET_NR_tgkill:\n\n\tret = get_errno(sys_tgkill((int)arg1, (int)arg2,\n\n                        target_to_host_signal(arg3)));\n\n\tbreak;\n\n#endif\n\n\n\n#ifdef TARGET_NR_set_robust_list\n\n    case TARGET_NR_set_robust_list:\n\n\tgoto unimplemented_nowarn;\n\n#endif\n\n\n\n#if defined(TARGET_NR_utimensat) && defined(__NR_utimensat)\n\n    case TARGET_NR_utimensat:\n\n        {\n\n            struct timespec *tsp, ts[2];\n\n            if (!arg3) {\n\n                tsp = NULL;\n\n            } else {\n\n                target_to_host_timespec(ts, arg3);\n\n                target_to_host_timespec(ts+1, arg3+sizeof(struct target_timespec));\n\n                tsp = ts;\n\n            }\n\n            if (!arg2)\n\n                ret = get_errno(sys_utimensat(arg1, NULL, tsp, arg4));\n\n            else {\n\n                if (!(p = lock_user_string(arg2))) {\n\n                    ret = -TARGET_EFAULT;\n\n                    goto fail;\n\n                }\n\n                ret = get_errno(sys_utimensat(arg1, path(p), tsp, arg4));\n\n                unlock_user(p, arg2, 0);\n\n            }\n\n        }\n\n\tbreak;\n\n#endif\n\n#if defined(CONFIG_USE_NPTL)\n\n    case TARGET_NR_futex:\n\n        ret = do_futex(arg1, arg2, arg3, arg4, arg5, arg6);\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)\n\n    case TARGET_NR_inotify_init:\n\n        ret = get_errno(sys_inotify_init());\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_inotify_add_watch) && defined(__NR_inotify_add_watch)\n\n    case TARGET_NR_inotify_add_watch:\n\n        p = lock_user_string(arg2);\n\n        ret = get_errno(sys_inotify_add_watch(arg1, path(p), arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_inotify_rm_watch) && defined(__NR_inotify_rm_watch)\n\n    case TARGET_NR_inotify_rm_watch:\n\n        ret = get_errno(sys_inotify_rm_watch(arg1, arg2));\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_mq_open) && defined(__NR_mq_open)\n\n    case TARGET_NR_mq_open:\n\n        {\n\n            struct mq_attr posix_mq_attr;\n\n\n\n            p = lock_user_string(arg1 - 1);\n\n            if (arg4 != 0)\n\n                copy_from_user_mq_attr (&posix_mq_attr, arg4);\n\n            ret = get_errno(mq_open(p, arg2, arg3, &posix_mq_attr));\n\n            unlock_user (p, arg1, 0);\n\n        }\n\n        break;\n\n\n\n    case TARGET_NR_mq_unlink:\n\n        p = lock_user_string(arg1 - 1);\n\n        ret = get_errno(mq_unlink(p));\n\n        unlock_user (p, arg1, 0);\n\n        break;\n\n\n\n    case TARGET_NR_mq_timedsend:\n\n        {\n\n            struct timespec ts;\n\n\n\n            p = lock_user (VERIFY_READ, arg2, arg3, 1);\n\n            if (arg5 != 0) {\n\n                target_to_host_timespec(&ts, arg5);\n\n                ret = get_errno(mq_timedsend(arg1, p, arg3, arg4, &ts));\n\n                host_to_target_timespec(arg5, &ts);\n\n            }\n\n            else\n\n                ret = get_errno(mq_send(arg1, p, arg3, arg4));\n\n            unlock_user (p, arg2, arg3);\n\n        }\n\n        break;\n\n\n\n    case TARGET_NR_mq_timedreceive:\n\n        {\n\n            struct timespec ts;\n\n            unsigned int prio;\n\n\n\n            p = lock_user (VERIFY_READ, arg2, arg3, 1);\n\n            if (arg5 != 0) {\n\n                target_to_host_timespec(&ts, arg5);\n\n                ret = get_errno(mq_timedreceive(arg1, p, arg3, &prio, &ts));\n\n                host_to_target_timespec(arg5, &ts);\n\n            }\n\n            else\n\n                ret = get_errno(mq_receive(arg1, p, arg3, &prio));\n\n            unlock_user (p, arg2, arg3);\n\n            if (arg4 != 0)\n\n                put_user_u32(prio, arg4);\n\n        }\n\n        break;\n\n\n\n    /* Not implemented for now... */\n\n/*     case TARGET_NR_mq_notify: */\n\n/*         break; */\n\n\n\n    case TARGET_NR_mq_getsetattr:\n\n        {\n\n            struct mq_attr posix_mq_attr_in, posix_mq_attr_out;\n\n            ret = 0;\n\n            if (arg3 != 0) {\n\n                ret = mq_getattr(arg1, &posix_mq_attr_out);\n\n                copy_to_user_mq_attr(arg3, &posix_mq_attr_out);\n\n            }\n\n            if (arg2 != 0) {\n\n                copy_from_user_mq_attr(&posix_mq_attr_in, arg2);\n\n                ret |= mq_setattr(arg1, &posix_mq_attr_in, &posix_mq_attr_out);\n\n            }\n\n\n\n        }\n\n        break;\n\n#endif\n\n\n\n#ifdef CONFIG_SPLICE\n\n#ifdef TARGET_NR_tee\n\n    case TARGET_NR_tee:\n\n        {\n\n            ret = get_errno(tee(arg1,arg2,arg3,arg4));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_splice\n\n    case TARGET_NR_splice:\n\n        {\n\n            loff_t loff_in, loff_out;\n\n            loff_t *ploff_in = NULL, *ploff_out = NULL;\n\n            if(arg2) {\n\n                get_user_u64(loff_in, arg2);\n\n                ploff_in = &loff_in;\n\n            }\n\n            if(arg4) {\n\n                get_user_u64(loff_out, arg2);\n\n                ploff_out = &loff_out;\n\n            }\n\n            ret = get_errno(splice(arg1, ploff_in, arg3, ploff_out, arg5, arg6));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_vmsplice\n\n\tcase TARGET_NR_vmsplice:\n\n        {\n\n            int count = arg3;\n\n            struct iovec *vec;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            if (lock_iovec(VERIFY_READ, vec, arg2, count, 1) < 0)\n\n                goto efault;\n\n            ret = get_errno(vmsplice(arg1, vec, count, arg4));\n\n            unlock_iovec(vec, arg2, count, 0);\n\n        }\n\n        break;\n\n#endif\n\n#endif /* CONFIG_SPLICE */\n\n#ifdef CONFIG_EVENTFD\n\n#if defined(TARGET_NR_eventfd)\n\n    case TARGET_NR_eventfd:\n\n        ret = get_errno(eventfd(arg1, 0));\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_eventfd2)\n\n    case TARGET_NR_eventfd2:\n\n        ret = get_errno(eventfd(arg1, arg2));\n\n        break;\n\n#endif\n\n#endif /* CONFIG_EVENTFD  */\n\n#if defined(CONFIG_FALLOCATE) && defined(TARGET_NR_fallocate)\n\n    case TARGET_NR_fallocate:\n\n        ret = get_errno(fallocate(arg1, arg2, arg3, arg4));\n\n        break;\n\n#endif\n\n    default:\n\n    unimplemented:\n\n        gemu_log(\"qemu: Unsupported syscall: %d\\n\", num);\n\n#if defined(TARGET_NR_setxattr) || defined(TARGET_NR_get_thread_area) || defined(TARGET_NR_getdomainname) || defined(TARGET_NR_set_robust_list)\n\n    unimplemented_nowarn:\n\n#endif\n\n        ret = -TARGET_ENOSYS;\n\n        break;\n\n    }\n\nfail:\n\n#ifdef DEBUG\n\n    gemu_log(\" = \" TARGET_ABI_FMT_ld \"\\n\", ret);\n\n#endif\n\n    if(do_strace)\n\n        print_syscall_ret(num, ret);\n\n    return ret;\n\nefault:\n\n    ret = -TARGET_EFAULT;\n\n    goto fail;\n\n}\n", "idx": 27056}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "ThreadPool *aio_get_thread_pool(AioContext *ctx)\n\n{\n\n    if (!ctx->thread_pool) {\n\n        ctx->thread_pool = thread_pool_new(ctx);\n\n    }\n\n    return ctx->thread_pool;\n\n}\n", "idx": 27057}
{"project": "qemu", "commit_id": "4058fd98fd7e9c476774717adbd49698dd273166", "target": 0, "func": "cpu_x86_dump_seg_cache(CPUState *env, FILE *f, fprintf_function cpu_fprintf,\n\n                       const char *name, struct SegmentCache *sc)\n\n{\n\n#ifdef TARGET_X86_64\n\n    if (env->hflags & HF_CS64_MASK) {\n\n        cpu_fprintf(f, \"%-3s=%04x %016\" PRIx64 \" %08x %08x\", name,\n\n                    sc->selector, sc->base, sc->limit, sc->flags);\n\n    } else\n\n#endif\n\n    {\n\n        cpu_fprintf(f, \"%-3s=%04x %08x %08x %08x\", name, sc->selector,\n\n                    (uint32_t)sc->base, sc->limit, sc->flags);\n\n    }\n\n\n\n    if (!(env->hflags & HF_PE_MASK) || !(sc->flags & DESC_P_MASK))\n\n        goto done;\n\n\n\n    cpu_fprintf(f, \" DPL=%d \", (sc->flags & DESC_DPL_MASK) >> DESC_DPL_SHIFT);\n\n    if (sc->flags & DESC_S_MASK) {\n\n        if (sc->flags & DESC_CS_MASK) {\n\n            cpu_fprintf(f, (sc->flags & DESC_L_MASK) ? \"CS64\" :\n\n                           ((sc->flags & DESC_B_MASK) ? \"CS32\" : \"CS16\"));\n\n            cpu_fprintf(f, \" [%c%c\", (sc->flags & DESC_C_MASK) ? 'C' : '-',\n\n                        (sc->flags & DESC_R_MASK) ? 'R' : '-');\n\n        } else {\n\n            cpu_fprintf(f, (sc->flags & DESC_B_MASK) ? \"DS  \" : \"DS16\");\n\n            cpu_fprintf(f, \" [%c%c\", (sc->flags & DESC_E_MASK) ? 'E' : '-',\n\n                        (sc->flags & DESC_W_MASK) ? 'W' : '-');\n\n        }\n\n        cpu_fprintf(f, \"%c]\", (sc->flags & DESC_A_MASK) ? 'A' : '-');\n\n    } else {\n\n        static const char *sys_type_name[2][16] = {\n\n            { /* 32 bit mode */\n\n                \"Reserved\", \"TSS16-avl\", \"LDT\", \"TSS16-busy\",\n\n                \"CallGate16\", \"TaskGate\", \"IntGate16\", \"TrapGate16\",\n\n                \"Reserved\", \"TSS32-avl\", \"Reserved\", \"TSS32-busy\",\n\n                \"CallGate32\", \"Reserved\", \"IntGate32\", \"TrapGate32\"\n\n            },\n\n            { /* 64 bit mode */\n\n                \"<hiword>\", \"Reserved\", \"LDT\", \"Reserved\", \"Reserved\",\n\n                \"Reserved\", \"Reserved\", \"Reserved\", \"Reserved\",\n\n                \"TSS64-avl\", \"Reserved\", \"TSS64-busy\", \"CallGate64\",\n\n                \"Reserved\", \"IntGate64\", \"TrapGate64\"\n\n            }\n\n        };\n\n        cpu_fprintf(f, \"%s\",\n\n                    sys_type_name[(env->hflags & HF_LMA_MASK) ? 1 : 0]\n\n                                 [(sc->flags & DESC_TYPE_MASK)\n\n                                  >> DESC_TYPE_SHIFT]);\n\n    }\n\ndone:\n\n    cpu_fprintf(f, \"\\n\");\n\n}\n", "idx": 27058}
{"project": "qemu", "commit_id": "3b098d56979d2f7fd707c5be85555d114353a28d", "target": 0, "func": "static void string_serialize(void *native_in, void **datap,\n\n                             VisitorFunc visit, Error **errp)\n\n{\n\n    StringSerializeData *d = g_malloc0(sizeof(*d));\n\n\n\n    d->sov = string_output_visitor_new(false);\n\n    visit(string_output_get_visitor(d->sov), &native_in, errp);\n\n    *datap = d;\n\n}\n", "idx": 27059}
{"project": "qemu", "commit_id": "b6fcf32d9b851a83dedcb609091236b97cc4a985", "target": 0, "func": "static void test_nested_struct_list(gconstpointer opaque)\n\n{\n\n    TestArgs *args = (TestArgs *) opaque;\n\n    const SerializeOps *ops = args->ops;\n\n    UserDefNestedList *listp = NULL, *tmp, *tmp_copy, *listp_copy = NULL;\n\n    Error *err = NULL;\n\n    void *serialize_data;\n\n    int i = 0;\n\n\n\n    for (i = 0; i < 8; i++) {\n\n        tmp = g_malloc0(sizeof(UserDefNestedList));\n\n        tmp->value = nested_struct_create();\n\n        tmp->next = listp;\n\n        listp = tmp;\n\n    }\n\n    \n\n    ops->serialize(listp, &serialize_data, visit_nested_struct_list, &err);\n\n    ops->deserialize((void **)&listp_copy, serialize_data,\n\n                     visit_nested_struct_list, &err); \n\n\n\n    g_assert(err == NULL);\n\n\n\n    tmp = listp;\n\n    tmp_copy = listp_copy;\n\n    while (listp_copy) {\n\n        g_assert(listp);\n\n        nested_struct_compare(listp->value, listp_copy->value);\n\n        listp = listp->next;\n\n        listp_copy = listp_copy->next;\n\n    }\n\n\n\n    qapi_free_UserDefNestedList(tmp);\n\n    qapi_free_UserDefNestedList(tmp_copy);\n\n\n\n    ops->cleanup(serialize_data);\n\n    g_free(args);\n\n}\n", "idx": 27060}
{"project": "qemu", "commit_id": "1ac157da77c863b62b1d2f467626a440d57cf17d", "target": 0, "func": "void cpu_x86_update_cr3(CPUX86State *env)\n\n{\n\n    if (env->cr[0] & CR0_PG_MASK) {\n\n#if defined(DEBUG_MMU)\n\n        printf(\"CR3 update: CR3=%08x\\n\", env->cr[3]);\n\n#endif\n\n        tlb_flush(env);\n\n    }\n\n}\n", "idx": 27061}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "int qemu_cpu_is_self(void *env)\n\n{\n\n    return 1;\n\n}\n", "idx": 27069}
{"project": "qemu", "commit_id": "ef4cbe14342c1f63b3c754e306218f004f4e26c4", "target": 1, "func": "int kvm_arch_init_vcpu(CPUState *cs)\n\n{\n\n    struct {\n\n        struct kvm_cpuid2 cpuid;\n\n        struct kvm_cpuid_entry2 entries[KVM_MAX_CPUID_ENTRIES];\n\n    } QEMU_PACKED cpuid_data;\n\n    X86CPU *cpu = X86_CPU(cs);\n\n    CPUX86State *env = &cpu->env;\n\n    uint32_t limit, i, j, cpuid_i;\n\n    uint32_t unused;\n\n    struct kvm_cpuid_entry2 *c;\n\n    uint32_t signature[3];\n\n    int r;\n\n\n\n    cpuid_i = 0;\n\n\n\n    /* Paravirtualization CPUIDs */\n\n    c = &cpuid_data.entries[cpuid_i++];\n\n    memset(c, 0, sizeof(*c));\n\n    c->function = KVM_CPUID_SIGNATURE;\n\n    if (!hyperv_enabled(cpu)) {\n\n        memcpy(signature, \"KVMKVMKVM\\0\\0\\0\", 12);\n\n        c->eax = 0;\n\n    } else {\n\n        memcpy(signature, \"Microsoft Hv\", 12);\n\n        c->eax = HYPERV_CPUID_MIN;\n\n    }\n\n    c->ebx = signature[0];\n\n    c->ecx = signature[1];\n\n    c->edx = signature[2];\n\n\n\n    c = &cpuid_data.entries[cpuid_i++];\n\n    memset(c, 0, sizeof(*c));\n\n    c->function = KVM_CPUID_FEATURES;\n\n    c->eax = env->features[FEAT_KVM];\n\n\n\n    if (hyperv_enabled(cpu)) {\n\n        memcpy(signature, \"Hv#1\\0\\0\\0\\0\\0\\0\\0\\0\", 12);\n\n        c->eax = signature[0];\n\n\n\n        c = &cpuid_data.entries[cpuid_i++];\n\n        memset(c, 0, sizeof(*c));\n\n        c->function = HYPERV_CPUID_VERSION;\n\n        c->eax = 0x00001bbc;\n\n        c->ebx = 0x00060001;\n\n\n\n        c = &cpuid_data.entries[cpuid_i++];\n\n        memset(c, 0, sizeof(*c));\n\n        c->function = HYPERV_CPUID_FEATURES;\n\n        if (cpu->hyperv_relaxed_timing) {\n\n            c->eax |= HV_X64_MSR_HYPERCALL_AVAILABLE;\n\n        }\n\n        if (cpu->hyperv_vapic) {\n\n            c->eax |= HV_X64_MSR_HYPERCALL_AVAILABLE;\n\n            c->eax |= HV_X64_MSR_APIC_ACCESS_AVAILABLE;\n\n        }\n\n\n\n        c = &cpuid_data.entries[cpuid_i++];\n\n        memset(c, 0, sizeof(*c));\n\n        c->function = HYPERV_CPUID_ENLIGHTMENT_INFO;\n\n        if (cpu->hyperv_relaxed_timing) {\n\n            c->eax |= HV_X64_RELAXED_TIMING_RECOMMENDED;\n\n        }\n\n        if (cpu->hyperv_vapic) {\n\n            c->eax |= HV_X64_APIC_ACCESS_RECOMMENDED;\n\n        }\n\n        c->ebx = cpu->hyperv_spinlock_attempts;\n\n\n\n        c = &cpuid_data.entries[cpuid_i++];\n\n        memset(c, 0, sizeof(*c));\n\n        c->function = HYPERV_CPUID_IMPLEMENT_LIMITS;\n\n        c->eax = 0x40;\n\n        c->ebx = 0x40;\n\n\n\n        c = &cpuid_data.entries[cpuid_i++];\n\n        memset(c, 0, sizeof(*c));\n\n        c->function = KVM_CPUID_SIGNATURE_NEXT;\n\n        memcpy(signature, \"KVMKVMKVM\\0\\0\\0\", 12);\n\n        c->eax = 0;\n\n        c->ebx = signature[0];\n\n        c->ecx = signature[1];\n\n        c->edx = signature[2];\n\n    }\n\n\n\n    has_msr_async_pf_en = c->eax & (1 << KVM_FEATURE_ASYNC_PF);\n\n\n\n    has_msr_pv_eoi_en = c->eax & (1 << KVM_FEATURE_PV_EOI);\n\n\n\n    has_msr_kvm_steal_time = c->eax & (1 << KVM_FEATURE_STEAL_TIME);\n\n\n\n    cpu_x86_cpuid(env, 0, 0, &limit, &unused, &unused, &unused);\n\n\n\n    for (i = 0; i <= limit; i++) {\n\n        if (cpuid_i == KVM_MAX_CPUID_ENTRIES) {\n\n            fprintf(stderr, \"unsupported level value: 0x%x\\n\", limit);\n\n            abort();\n\n        }\n\n        c = &cpuid_data.entries[cpuid_i++];\n\n\n\n        switch (i) {\n\n        case 2: {\n\n            /* Keep reading function 2 till all the input is received */\n\n            int times;\n\n\n\n            c->function = i;\n\n            c->flags = KVM_CPUID_FLAG_STATEFUL_FUNC |\n\n                       KVM_CPUID_FLAG_STATE_READ_NEXT;\n\n            cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);\n\n            times = c->eax & 0xff;\n\n\n\n            for (j = 1; j < times; ++j) {\n\n                if (cpuid_i == KVM_MAX_CPUID_ENTRIES) {\n\n                    fprintf(stderr, \"cpuid_data is full, no space for \"\n\n                            \"cpuid(eax:2):eax & 0xf = 0x%x\\n\", times);\n\n                    abort();\n\n                }\n\n                c = &cpuid_data.entries[cpuid_i++];\n\n                c->function = i;\n\n                c->flags = KVM_CPUID_FLAG_STATEFUL_FUNC;\n\n                cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);\n\n            }\n\n            break;\n\n        }\n\n        case 4:\n\n        case 0xb:\n\n        case 0xd:\n\n            for (j = 0; ; j++) {\n\n                if (i == 0xd && j == 64) {\n\n                    break;\n\n                }\n\n                c->function = i;\n\n                c->flags = KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\n                c->index = j;\n\n                cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);\n\n\n\n                if (i == 4 && c->eax == 0) {\n\n                    break;\n\n                }\n\n                if (i == 0xb && !(c->ecx & 0xff00)) {\n\n                    break;\n\n                }\n\n                if (i == 0xd && c->eax == 0) {\n\n                    continue;\n\n                }\n\n                if (cpuid_i == KVM_MAX_CPUID_ENTRIES) {\n\n                    fprintf(stderr, \"cpuid_data is full, no space for \"\n\n                            \"cpuid(eax:0x%x,ecx:0x%x)\\n\", i, j);\n\n                    abort();\n\n                }\n\n                c = &cpuid_data.entries[cpuid_i++];\n\n            }\n\n            break;\n\n        default:\n\n            c->function = i;\n\n            c->flags = 0;\n\n            cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (limit >= 0x0a) {\n\n        uint32_t ver;\n\n\n\n        cpu_x86_cpuid(env, 0x0a, 0, &ver, &unused, &unused, &unused);\n\n        if ((ver & 0xff) > 0) {\n\n            has_msr_architectural_pmu = true;\n\n            num_architectural_pmu_counters = (ver & 0xff00) >> 8;\n\n\n\n            /* Shouldn't be more than 32, since that's the number of bits\n\n             * available in EBX to tell us _which_ counters are available.\n\n             * Play it safe.\n\n             */\n\n            if (num_architectural_pmu_counters > MAX_GP_COUNTERS) {\n\n                num_architectural_pmu_counters = MAX_GP_COUNTERS;\n\n            }\n\n        }\n\n    }\n\n\n\n    cpu_x86_cpuid(env, 0x80000000, 0, &limit, &unused, &unused, &unused);\n\n\n\n    for (i = 0x80000000; i <= limit; i++) {\n\n        if (cpuid_i == KVM_MAX_CPUID_ENTRIES) {\n\n            fprintf(stderr, \"unsupported xlevel value: 0x%x\\n\", limit);\n\n            abort();\n\n        }\n\n        c = &cpuid_data.entries[cpuid_i++];\n\n\n\n        c->function = i;\n\n        c->flags = 0;\n\n        cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);\n\n    }\n\n\n\n    /* Call Centaur's CPUID instructions they are supported. */\n\n    if (env->cpuid_xlevel2 > 0) {\n\n        cpu_x86_cpuid(env, 0xC0000000, 0, &limit, &unused, &unused, &unused);\n\n\n\n        for (i = 0xC0000000; i <= limit; i++) {\n\n            if (cpuid_i == KVM_MAX_CPUID_ENTRIES) {\n\n                fprintf(stderr, \"unsupported xlevel2 value: 0x%x\\n\", limit);\n\n                abort();\n\n            }\n\n            c = &cpuid_data.entries[cpuid_i++];\n\n\n\n            c->function = i;\n\n            c->flags = 0;\n\n            cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);\n\n        }\n\n    }\n\n\n\n    cpuid_data.cpuid.nent = cpuid_i;\n\n\n\n    if (((env->cpuid_version >> 8)&0xF) >= 6\n\n        && (env->features[FEAT_1_EDX] & (CPUID_MCE | CPUID_MCA)) ==\n\n           (CPUID_MCE | CPUID_MCA)\n\n        && kvm_check_extension(cs->kvm_state, KVM_CAP_MCE) > 0) {\n\n        uint64_t mcg_cap;\n\n        int banks;\n\n        int ret;\n\n\n\n        ret = kvm_get_mce_cap_supported(cs->kvm_state, &mcg_cap, &banks);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"kvm_get_mce_cap_supported: %s\", strerror(-ret));\n\n            return ret;\n\n        }\n\n\n\n        if (banks > MCE_BANKS_DEF) {\n\n            banks = MCE_BANKS_DEF;\n\n        }\n\n        mcg_cap &= MCE_CAP_DEF;\n\n        mcg_cap |= banks;\n\n        ret = kvm_vcpu_ioctl(cs, KVM_X86_SETUP_MCE, &mcg_cap);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"KVM_X86_SETUP_MCE: %s\", strerror(-ret));\n\n            return ret;\n\n        }\n\n\n\n        env->mcg_cap = mcg_cap;\n\n    }\n\n\n\n    qemu_add_vm_change_state_handler(cpu_update_state, env);\n\n\n\n    c = cpuid_find_entry(&cpuid_data.cpuid, 1, 0);\n\n    if (c) {\n\n        has_msr_feature_control = !!(c->ecx & CPUID_EXT_VMX) ||\n\n                                  !!(c->ecx & CPUID_EXT_SMX);\n\n    }\n\n\n\n    cpuid_data.cpuid.padding = 0;\n\n    r = kvm_vcpu_ioctl(cs, KVM_SET_CPUID2, &cpuid_data);\n\n    if (r) {\n\n        return r;\n\n    }\n\n\n\n    r = kvm_check_extension(cs->kvm_state, KVM_CAP_TSC_CONTROL);\n\n    if (r && env->tsc_khz) {\n\n        r = kvm_vcpu_ioctl(cs, KVM_SET_TSC_KHZ, env->tsc_khz);\n\n        if (r < 0) {\n\n            fprintf(stderr, \"KVM_SET_TSC_KHZ failed\\n\");\n\n            return r;\n\n        }\n\n    }\n\n\n\n    if (kvm_has_xsave()) {\n\n        env->kvm_xsave_buf = qemu_memalign(4096, sizeof(struct kvm_xsave));\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 27071}
{"project": "qemu", "commit_id": "71d0770c4cec9f1dc04f4dadcbf7fd6c335030a9", "target": 1, "func": "BlockDriverAIOCB *bdrv_aio_writev(BlockDriverState *bs, int64_t sector_num,\n                                  QEMUIOVector *iov, int nb_sectors,\n                                  BlockDriverCompletionFunc *cb, void *opaque)\n{\n    return bdrv_aio_rw_vector(bs, sector_num, iov, nb_sectors,\n                              cb, opaque, 1);\n}", "idx": 27072}
{"project": "qemu", "commit_id": "b5937f297819bec5bf704dda1df9807fc7f0a766", "target": 1, "func": "static QObject *pci_get_dev_dict(PCIDevice *dev, PCIBus *bus, int bus_num)\n\n{\n\n    int class;\n\n    QObject *obj;\n\n\n\n    obj = qobject_from_jsonf(\"{ 'bus': %d, 'slot': %d, 'function': %d,\"                                       \"'class_info': %p, 'id': %p, 'regions': %p,\"\n\n                              \" 'qdev_id': %s }\",\n\n                              bus_num,\n\n                              PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn),\n\n                              pci_get_dev_class(dev), pci_get_dev_id(dev),\n\n                              pci_get_regions_list(dev),\n\n                              dev->qdev.id ? dev->qdev.id : \"\");\n\n\n\n    if (dev->config[PCI_INTERRUPT_PIN] != 0) {\n\n        QDict *qdict = qobject_to_qdict(obj);\n\n        qdict_put(qdict, \"irq\", qint_from_int(dev->config[PCI_INTERRUPT_LINE]));\n\n    }\n\n\n\n    class = pci_get_word(dev->config + PCI_CLASS_DEVICE);\n\n    if (class == PCI_CLASS_BRIDGE_HOST || class == PCI_CLASS_BRIDGE_PCI) {\n\n        QDict *qdict;\n\n        QObject *pci_bridge;\n\n\n\n        pci_bridge = qobject_from_jsonf(\"{ 'bus': \"\n\n        \"{ 'number': %d, 'secondary': %d, 'subordinate': %d }, \"\n\n        \"'io_range': { 'base': %\" PRId64 \", 'limit': %\" PRId64 \"}, \"\n\n        \"'memory_range': { 'base': %\" PRId64 \", 'limit': %\" PRId64 \"}, \"\n\n        \"'prefetchable_range': { 'base': %\" PRId64 \", 'limit': %\" PRId64 \"} }\",\n\n        dev->config[PCI_PRIMARY_BUS], dev->config[PCI_SECONDARY_BUS],\n\n        dev->config[PCI_SUBORDINATE_BUS],\n\n        pci_bridge_get_base(dev, PCI_BASE_ADDRESS_SPACE_IO),\n\n        pci_bridge_get_limit(dev, PCI_BASE_ADDRESS_SPACE_IO),\n\n        pci_bridge_get_base(dev, PCI_BASE_ADDRESS_SPACE_MEMORY),\n\n        pci_bridge_get_limit(dev, PCI_BASE_ADDRESS_SPACE_MEMORY),\n\n        pci_bridge_get_base(dev, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                               PCI_BASE_ADDRESS_MEM_PREFETCH),\n\n        pci_bridge_get_limit(dev, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                PCI_BASE_ADDRESS_MEM_PREFETCH));\n\n\n\n        if (dev->config[PCI_SECONDARY_BUS] != 0) {\n\n            PCIBus *child_bus = pci_find_bus(bus, dev->config[PCI_SECONDARY_BUS]);\n\n\n\n            if (child_bus) {\n\n                qdict = qobject_to_qdict(pci_bridge);\n\n                qdict_put_obj(qdict, \"devices\",\n\n                              pci_get_devices_list(child_bus,\n\n                                                   dev->config[PCI_SECONDARY_BUS]));\n\n            }\n\n        }\n\n        qdict = qobject_to_qdict(obj);\n\n        qdict_put_obj(qdict, \"pci_bridge\", pci_bridge);\n\n    }\n\n\n\n    return obj;\n\n}\n", "idx": 27073}
{"project": "qemu", "commit_id": "b7b5233ad7fdd9985bb6d05b7919f3a20723ff2c", "target": 1, "func": "static void *bsd_vmalloc(size_t size)\n\n{\n\n    void *p;\n\n    mmap_lock();\n\n    /* Use map and mark the pages as used.  */\n\n    p = mmap(NULL, size, PROT_READ | PROT_WRITE,\n\n             MAP_PRIVATE | MAP_ANON, -1, 0);\n\n\n\n    if (h2g_valid(p)) {\n\n        /* Allocated region overlaps guest address space.\n\n           This may recurse.  */\n\n        abi_ulong addr = h2g(p);\n\n        page_set_flags(addr & TARGET_PAGE_MASK, TARGET_PAGE_ALIGN(addr + size),\n\n                       PAGE_RESERVED);\n\n    }\n\n\n\n    mmap_unlock();\n\n    return p;\n\n}\n", "idx": 27075}
{"project": "qemu", "commit_id": "e7852674d5013bffd0bb8e822a7521f76677a60b", "target": 1, "func": "static ssize_t usbnet_receive(VLANClientState *nc, const uint8_t *buf, size_t size)\n\n{\n\n    USBNetState *s = DO_UPCAST(NICState, nc, nc)->opaque;\n\n    struct rndis_packet_msg_type *msg;\n\n\n\n    if (is_rndis(s)) {\n\n        msg = (struct rndis_packet_msg_type *) s->in_buf;\n\n        if (!s->rndis_state == RNDIS_DATA_INITIALIZED)\n\n            return -1;\n\n        if (size + sizeof(struct rndis_packet_msg_type) > sizeof(s->in_buf))\n\n            return -1;\n\n\n\n        memset(msg, 0, sizeof(struct rndis_packet_msg_type));\n\n        msg->MessageType = cpu_to_le32(RNDIS_PACKET_MSG);\n\n        msg->MessageLength = cpu_to_le32(size + sizeof(struct rndis_packet_msg_type));\n\n        msg->DataOffset = cpu_to_le32(sizeof(struct rndis_packet_msg_type) - 8);\n\n        msg->DataLength = cpu_to_le32(size);\n\n        /* msg->OOBDataOffset;\n\n         * msg->OOBDataLength;\n\n         * msg->NumOOBDataElements;\n\n         * msg->PerPacketInfoOffset;\n\n         * msg->PerPacketInfoLength;\n\n         * msg->VcHandle;\n\n         * msg->Reserved;\n\n         */\n\n        memcpy(msg + 1, buf, size);\n\n        s->in_len = size + sizeof(struct rndis_packet_msg_type);\n\n    } else {\n\n        if (size > sizeof(s->in_buf))\n\n            return -1;\n\n        memcpy(s->in_buf, buf, size);\n\n        s->in_len = size;\n\n    }\n\n    s->in_ptr = 0;\n\n    return size;\n\n}\n", "idx": 27078}
{"project": "qemu", "commit_id": "8be7e7e4c72c048b90e3482557954a24bba43ba7", "target": 1, "func": "int unix_connect(const char *path)\n\n{\n\n    QemuOpts *opts;\n\n    int sock;\n\n\n\n    opts = qemu_opts_create(&dummy_opts, NULL, 0);\n\n    qemu_opt_set(opts, \"path\", path);\n\n    sock = unix_connect_opts(opts);\n\n    qemu_opts_del(opts);\n\n    return sock;\n\n}\n", "idx": 27079}
{"project": "qemu", "commit_id": "62593718d77c06ad2b5e942727cead40775d2395", "target": 1, "func": "static inline bool regime_translation_disabled(CPUARMState *env,\n\n                                               ARMMMUIdx mmu_idx)\n\n{\n\n    if (arm_feature(env, ARM_FEATURE_M)) {\n\n        switch (env->v7m.mpu_ctrl[regime_is_secure(env, mmu_idx)] &\n\n                (R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK)) {\n\n        case R_V7M_MPU_CTRL_ENABLE_MASK:\n\n            /* Enabled, but not for HardFault and NMI */\n\n            return mmu_idx == ARMMMUIdx_MNegPri ||\n\n                mmu_idx == ARMMMUIdx_MSNegPri;\n\n        case R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK:\n\n            /* Enabled for all cases */\n\n            return false;\n\n        case 0:\n\n        default:\n\n            /* HFNMIENA set and ENABLE clear is UNPREDICTABLE, but\n\n             * we warned about that in armv7m_nvic.c when the guest set it.\n\n             */\n\n            return true;\n\n        }\n\n    }\n\n\n\n    if (mmu_idx == ARMMMUIdx_S2NS) {\n\n        return (env->cp15.hcr_el2 & HCR_VM) == 0;\n\n    }\n\n    return (regime_sctlr(env, mmu_idx) & SCTLR_M) == 0;\n\n}\n", "idx": 27080}
{"project": "qemu", "commit_id": "8b0b29dcec59730e6b21b253a6b43271cb3d831b", "target": 0, "func": "static void migration_instance_init(Object *obj)\n\n{\n\n    MigrationState *ms = MIGRATION_OBJ(obj);\n\n\n\n    ms->state = MIGRATION_STATUS_NONE;\n\n    ms->xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE;\n\n    ms->mbps = -1;\n\n    ms->parameters.tls_creds = g_strdup(\"\");\n\n    ms->parameters.tls_hostname = g_strdup(\"\");\n\n}\n", "idx": 27082}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void disas_fp_ccomp(DisasContext *s, uint32_t insn)\n\n{\n\n    unsigned int mos, type, rm, cond, rn, op, nzcv;\n\n    TCGv_i64 tcg_flags;\n\n    int label_continue = -1;\n\n\n\n    mos = extract32(insn, 29, 3);\n\n    type = extract32(insn, 22, 2); /* 0 = single, 1 = double */\n\n    rm = extract32(insn, 16, 5);\n\n    cond = extract32(insn, 12, 4);\n\n    rn = extract32(insn, 5, 5);\n\n    op = extract32(insn, 4, 1);\n\n    nzcv = extract32(insn, 0, 4);\n\n\n\n    if (mos || type > 1) {\n\n        unallocated_encoding(s);\n\n        return;\n\n    }\n\n\n\n    if (!fp_access_check(s)) {\n\n        return;\n\n    }\n\n\n\n    if (cond < 0x0e) { /* not always */\n\n        int label_match = gen_new_label();\n\n        label_continue = gen_new_label();\n\n        arm_gen_test_cc(cond, label_match);\n\n        /* nomatch: */\n\n        tcg_flags = tcg_const_i64(nzcv << 28);\n\n        gen_set_nzcv(tcg_flags);\n\n        tcg_temp_free_i64(tcg_flags);\n\n        tcg_gen_br(label_continue);\n\n        gen_set_label(label_match);\n\n    }\n\n\n\n    handle_fp_compare(s, type, rn, rm, false, op);\n\n\n\n    if (cond < 0x0e) {\n\n        gen_set_label(label_continue);\n\n    }\n\n}\n", "idx": 27083}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void do_stop_capture(Monitor *mon, const QDict *qdict)\n\n{\n\n    int i;\n\n    int n = qdict_get_int(qdict, \"n\");\n\n    CaptureState *s;\n\n\n\n    for (s = capture_head.lh_first, i = 0; s; s = s->entries.le_next, ++i) {\n\n        if (i == n) {\n\n            s->ops.destroy (s->opaque);\n\n            LIST_REMOVE (s, entries);\n\n            qemu_free (s);\n\n            return;\n\n        }\n\n    }\n\n}\n", "idx": 27084}
{"project": "qemu", "commit_id": "4cdd01d32ee6fe04f8d909bfd3708be6864873a2", "target": 0, "func": "static void nbd_refresh_filename(BlockDriverState *bs)\n\n{\n\n    QDict *opts = qdict_new();\n\n    const char *path   = qdict_get_try_str(bs->options, \"path\");\n\n    const char *host   = qdict_get_try_str(bs->options, \"host\");\n\n    const char *port   = qdict_get_try_str(bs->options, \"port\");\n\n    const char *export = qdict_get_try_str(bs->options, \"export\");\n\n\n\n    qdict_put_obj(opts, \"driver\", QOBJECT(qstring_from_str(\"nbd\")));\n\n\n\n    if (path && export) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nbd+unix:///%s?socket=%s\", export, path);\n\n    } else if (path && !export) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nbd+unix://?socket=%s\", path);\n\n    } else if (!path && export && port) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nbd://%s:%s/%s\", host, port, export);\n\n    } else if (!path && export && !port) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nbd://%s/%s\", host, export);\n\n    } else if (!path && !export && port) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nbd://%s:%s\", host, port);\n\n    } else if (!path && !export && !port) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nbd://%s\", host);\n\n    }\n\n\n\n    if (path) {\n\n        qdict_put_obj(opts, \"path\", QOBJECT(qstring_from_str(path)));\n\n    } else if (port) {\n\n        qdict_put_obj(opts, \"host\", QOBJECT(qstring_from_str(host)));\n\n        qdict_put_obj(opts, \"port\", QOBJECT(qstring_from_str(port)));\n\n    } else {\n\n        qdict_put_obj(opts, \"host\", QOBJECT(qstring_from_str(host)));\n\n    }\n\n    if (export) {\n\n        qdict_put_obj(opts, \"export\", QOBJECT(qstring_from_str(export)));\n\n    }\n\n\n\n    bs->full_open_options = opts;\n\n}\n", "idx": 27085}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static inline void iwmmxt_store_reg(TCGv var, int reg)\n\n{\n\n    tcg_gen_st_i64(var, cpu_env, offsetof(CPUState, iwmmxt.regs[reg]));\n\n}\n", "idx": 27087}
{"project": "qemu", "commit_id": "ea6c5f8ffe6de12e04e63acbb9937683b30216e2", "target": 0, "func": "static inline int test_bit(unsigned int bit, const unsigned long *map)\n\n{\n\n    return !!((map)[(bit) / BITS_PER_LONG] & (1UL << ((bit) % BITS_PER_LONG)));\n\n}\n", "idx": 27088}
{"project": "qemu", "commit_id": "5b5cb08683b6715a2aca5314168e68ff0665912b", "target": 0, "func": "static int msix_is_masked(PCIDevice *dev, int vector)\n\n{\n\n    unsigned offset = vector * MSIX_ENTRY_SIZE + MSIX_VECTOR_CTRL;\n\n    return dev->msix_table_page[offset] & MSIX_VECTOR_MASK;\n\n}\n", "idx": 27089}
{"project": "qemu", "commit_id": "018598747c775394471ce4a341a1ce225a1738dc", "target": 0, "func": "static void qed_aio_next_io(QEDAIOCB *acb)\n\n{\n\n    BDRVQEDState *s = acb_to_s(acb);\n\n    uint64_t offset;\n\n    size_t len;\n\n    int ret;\n\n\n\n    trace_qed_aio_next_io(s, acb, 0, acb->cur_pos + acb->cur_qiov.size);\n\n\n\n    if (acb->backing_qiov) {\n\n        qemu_iovec_destroy(acb->backing_qiov);\n\n        g_free(acb->backing_qiov);\n\n        acb->backing_qiov = NULL;\n\n    }\n\n\n\n    acb->qiov_offset += acb->cur_qiov.size;\n\n    acb->cur_pos += acb->cur_qiov.size;\n\n    qemu_iovec_reset(&acb->cur_qiov);\n\n\n\n    /* Complete request */\n\n    if (acb->cur_pos >= acb->end_pos) {\n\n        qed_aio_complete(acb, 0);\n\n        return;\n\n    }\n\n\n\n    /* Find next cluster and start I/O */\n\n    len = acb->end_pos - acb->cur_pos;\n\n    ret = qed_find_cluster(s, &acb->request, acb->cur_pos, &len, &offset);\n\n    if (ret < 0) {\n\n        qed_aio_complete(acb, ret);\n\n        return;\n\n    }\n\n\n\n    if (acb->flags & QED_AIOCB_WRITE) {\n\n        ret = qed_aio_write_data(acb, ret, offset, len);\n\n    } else {\n\n        ret = qed_aio_read_data(acb, ret, offset, len);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        if (ret != -EINPROGRESS) {\n\n            qed_aio_complete(acb, ret);\n\n        }\n\n        return;\n\n    }\n\n    qed_aio_next_io(acb);\n\n}\n", "idx": 27090}
{"project": "qemu", "commit_id": "cf070d7ec0b8fb21faa9a630ed5cc66f90844a08", "target": 0, "func": "writev_f(int argc, char **argv)\n\n{\n\n\tstruct timeval t1, t2;\n\n\tint Cflag = 0, qflag = 0;\n\n\tint c, cnt;\n\n\tchar *buf;\n\n\tint64_t offset;\n\n\tint total;\n\n\tint nr_iov;\n\n\tint pattern = 0xcd;\n\n\tQEMUIOVector qiov;\n\n\n\n\twhile ((c = getopt(argc, argv, \"CqP:\")) != EOF) {\n\n\t\tswitch (c) {\n\n\t\tcase 'C':\n\n\t\t\tCflag = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'q':\n\n\t\t\tqflag = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'P':\n\n\t\t\tpattern = atoi(optarg);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\treturn command_usage(&writev_cmd);\n\n\t\t}\n\n\t}\n\n\n\n\tif (optind > argc - 2)\n\n\t\treturn command_usage(&writev_cmd);\n\n\n\n\toffset = cvtnum(argv[optind]);\n\n\tif (offset < 0) {\n\n\t\tprintf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n\t\treturn 0;\n\n\t}\n\n\toptind++;\n\n\n\n\tif (offset & 0x1ff) {\n\n\t\tprintf(\"offset %lld is not sector aligned\\n\",\n\n\t\t\t(long long)offset);\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tnr_iov = argc - optind;\n\n\tbuf = create_iovec(&qiov, &argv[optind], nr_iov, pattern);\n\n\n\n\tgettimeofday(&t1, NULL);\n\n\tcnt = do_aio_writev(&qiov, offset, &total);\n\n\tgettimeofday(&t2, NULL);\n\n\n\n\tif (cnt < 0) {\n\n\t\tprintf(\"writev failed: %s\\n\", strerror(-cnt));\n\n\t\tgoto out;\n\n\t}\n\n\n\n\tif (qflag)\n\n\t\tgoto out;\n\n\n\n\t/* Finally, report back -- -C gives a parsable format */\n\n\tt2 = tsub(t2, t1);\n\n\tprint_report(\"wrote\", &t2, offset, qiov.size, total, cnt, Cflag);\n\nout:\n\n\tqemu_io_free(buf);\n\n\treturn 0;\n\n}\n", "idx": 27091}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoull_decimal(void)\n\n{\n\n    const char *str = \"0123\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    uint64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoull(str, &endptr, 10, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 123);\n\n    g_assert(endptr == str + strlen(str));\n\n\n\n    str = \"123\";\n\n    endptr = &f;\n\n    res = 999;\n\n    err = qemu_strtoull(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 123);\n\n    g_assert(endptr == str + strlen(str));\n\n}\n", "idx": 27092}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t imx_timerp_read(void *opaque, target_phys_addr_t offset,\n\n                                unsigned size)\n\n{\n\n    IMXTimerPState *s = (IMXTimerPState *)opaque;\n\n\n\n    DPRINTF(\"p-read(offset=%x)\", offset >> 2);\n\n    switch (offset >> 2) {\n\n    case 0: /* Control Register */\n\n        DPRINTF(\"cr %x\\n\", s->cr);\n\n        return s->cr;\n\n\n\n    case 1: /* Status Register */\n\n        DPRINTF(\"int_level %x\\n\", s->int_level);\n\n        return s->int_level;\n\n\n\n    case 2: /* LR - ticks*/\n\n        DPRINTF(\"lr %x\\n\", s->lr);\n\n        return s->lr;\n\n\n\n    case 3: /* CMP */\n\n        DPRINTF(\"cmp %x\\n\", s->cmp);\n\n        return s->cmp;\n\n\n\n    case 4: /* CNT */\n\n        return ptimer_get_count(s->timer);\n\n    }\n\n    IPRINTF(\"imx_timerp_read: Bad offset %x\\n\",\n\n            (int)offset >> 2);\n\n    return 0;\n\n}\n", "idx": 27093}
{"project": "qemu", "commit_id": "bec1631100323fac0900aea71043d5c4e22fc2fa", "target": 0, "func": "static void tcg_out_brcond2(TCGContext *s, TCGCond cond, TCGReg al, TCGReg ah,\n\n                            TCGReg bl, TCGReg bh, int label_index)\n\n{\n\n    TCGCond b_cond = TCG_COND_NE;\n\n    TCGReg tmp = TCG_TMP1;\n\n\n\n    /* With branches, we emit between 4 and 9 insns with 2 or 3 branches.\n\n       With setcond, we emit between 3 and 10 insns and only 1 branch,\n\n       which ought to get better branch prediction.  */\n\n     switch (cond) {\n\n     case TCG_COND_EQ:\n\n     case TCG_COND_NE:\n\n        b_cond = cond;\n\n        tmp = tcg_out_reduce_eq2(s, TCG_TMP0, TCG_TMP1, al, ah, bl, bh);\n\n        break;\n\n\n\n    default:\n\n        /* Minimize code size by preferring a compare not requiring INV.  */\n\n        if (mips_cmp_map[cond] & MIPS_CMP_INV) {\n\n            cond = tcg_invert_cond(cond);\n\n            b_cond = TCG_COND_EQ;\n\n        }\n\n        tcg_out_setcond2(s, cond, tmp, al, ah, bl, bh);\n\n        break;\n\n    }\n\n\n\n    tcg_out_brcond(s, b_cond, tmp, TCG_REG_ZERO, label_index);\n\n}\n", "idx": 27094}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_mcbsp_writeh(void *opaque, target_phys_addr_t addr,\n\n                uint32_t value)\n\n{\n\n    struct omap_mcbsp_s *s = (struct omap_mcbsp_s *) opaque;\n\n    int offset = addr & OMAP_MPUI_REG_MASK;\n\n\n\n    switch (offset) {\n\n    case 0x00:\t/* DRR2 */\n\n    case 0x02:\t/* DRR1 */\n\n        OMAP_RO_REG(addr);\n\n        return;\n\n\n\n    case 0x04:\t/* DXR2 */\n\n        if (((s->xcr[0] >> 5) & 7) < 3)\t\t\t/* XWDLEN1 */\n\n            return;\n\n        /* Fall through.  */\n\n    case 0x06:\t/* DXR1 */\n\n        if (s->tx_req > 1) {\n\n            s->tx_req -= 2;\n\n            if (s->codec && s->codec->cts) {\n\n                s->codec->out.fifo[s->codec->out.len ++] = (value >> 8) & 0xff;\n\n                s->codec->out.fifo[s->codec->out.len ++] = (value >> 0) & 0xff;\n\n            }\n\n            if (s->tx_req < 2)\n\n                omap_mcbsp_tx_done(s);\n\n        } else\n\n            printf(\"%s: Tx FIFO overrun\\n\", __FUNCTION__);\n\n        return;\n\n\n\n    case 0x08:\t/* SPCR2 */\n\n        s->spcr[1] &= 0x0002;\n\n        s->spcr[1] |= 0x03f9 & value;\n\n        s->spcr[1] |= 0x0004 & (value << 2);\t\t/* XEMPTY := XRST */\n\n        if (~value & 1)\t\t\t\t\t/* XRST */\n\n            s->spcr[1] &= ~6;\n\n        omap_mcbsp_req_update(s);\n\n        return;\n\n    case 0x0a:\t/* SPCR1 */\n\n        s->spcr[0] &= 0x0006;\n\n        s->spcr[0] |= 0xf8f9 & value;\n\n        if (value & (1 << 15))\t\t\t\t/* DLB */\n\n            printf(\"%s: Digital Loopback mode enable attempt\\n\", __FUNCTION__);\n\n        if (~value & 1) {\t\t\t\t/* RRST */\n\n            s->spcr[0] &= ~6;\n\n            s->rx_req = 0;\n\n            omap_mcbsp_rx_done(s);\n\n        }\n\n        omap_mcbsp_req_update(s);\n\n        return;\n\n\n\n    case 0x0c:\t/* RCR2 */\n\n        s->rcr[1] = value & 0xffff;\n\n        return;\n\n    case 0x0e:\t/* RCR1 */\n\n        s->rcr[0] = value & 0x7fe0;\n\n        return;\n\n    case 0x10:\t/* XCR2 */\n\n        s->xcr[1] = value & 0xffff;\n\n        return;\n\n    case 0x12:\t/* XCR1 */\n\n        s->xcr[0] = value & 0x7fe0;\n\n        return;\n\n    case 0x14:\t/* SRGR2 */\n\n        s->srgr[1] = value & 0xffff;\n\n        omap_mcbsp_req_update(s);\n\n        return;\n\n    case 0x16:\t/* SRGR1 */\n\n        s->srgr[0] = value & 0xffff;\n\n        omap_mcbsp_req_update(s);\n\n        return;\n\n    case 0x18:\t/* MCR2 */\n\n        s->mcr[1] = value & 0x03e3;\n\n        if (value & 3)\t\t\t\t\t/* XMCM */\n\n            printf(\"%s: Tx channel selection mode enable attempt\\n\",\n\n                            __FUNCTION__);\n\n        return;\n\n    case 0x1a:\t/* MCR1 */\n\n        s->mcr[0] = value & 0x03e1;\n\n        if (value & 1)\t\t\t\t\t/* RMCM */\n\n            printf(\"%s: Rx channel selection mode enable attempt\\n\",\n\n                            __FUNCTION__);\n\n        return;\n\n    case 0x1c:\t/* RCERA */\n\n        s->rcer[0] = value & 0xffff;\n\n        return;\n\n    case 0x1e:\t/* RCERB */\n\n        s->rcer[1] = value & 0xffff;\n\n        return;\n\n    case 0x20:\t/* XCERA */\n\n        s->xcer[0] = value & 0xffff;\n\n        return;\n\n    case 0x22:\t/* XCERB */\n\n        s->xcer[1] = value & 0xffff;\n\n        return;\n\n    case 0x24:\t/* PCR0 */\n\n        s->pcr = value & 0x7faf;\n\n        return;\n\n    case 0x26:\t/* RCERC */\n\n        s->rcer[2] = value & 0xffff;\n\n        return;\n\n    case 0x28:\t/* RCERD */\n\n        s->rcer[3] = value & 0xffff;\n\n        return;\n\n    case 0x2a:\t/* XCERC */\n\n        s->xcer[2] = value & 0xffff;\n\n        return;\n\n    case 0x2c:\t/* XCERD */\n\n        s->xcer[3] = value & 0xffff;\n\n        return;\n\n    case 0x2e:\t/* RCERE */\n\n        s->rcer[4] = value & 0xffff;\n\n        return;\n\n    case 0x30:\t/* RCERF */\n\n        s->rcer[5] = value & 0xffff;\n\n        return;\n\n    case 0x32:\t/* XCERE */\n\n        s->xcer[4] = value & 0xffff;\n\n        return;\n\n    case 0x34:\t/* XCERF */\n\n        s->xcer[5] = value & 0xffff;\n\n        return;\n\n    case 0x36:\t/* RCERG */\n\n        s->rcer[6] = value & 0xffff;\n\n        return;\n\n    case 0x38:\t/* RCERH */\n\n        s->rcer[7] = value & 0xffff;\n\n        return;\n\n    case 0x3a:\t/* XCERG */\n\n        s->xcer[6] = value & 0xffff;\n\n        return;\n\n    case 0x3c:\t/* XCERH */\n\n        s->xcer[7] = value & 0xffff;\n\n        return;\n\n    }\n\n\n\n    OMAP_BAD_REG(addr);\n\n}\n", "idx": 27095}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static void legacy_mouse_event(DeviceState *dev, QemuConsole *src,\n\n                               InputEvent *evt)\n\n{\n\n    static const int bmap[INPUT_BUTTON__MAX] = {\n\n        [INPUT_BUTTON_LEFT]   = MOUSE_EVENT_LBUTTON,\n\n        [INPUT_BUTTON_MIDDLE] = MOUSE_EVENT_MBUTTON,\n\n        [INPUT_BUTTON_RIGHT]  = MOUSE_EVENT_RBUTTON,\n\n    };\n\n    QEMUPutMouseEntry *s = (QEMUPutMouseEntry *)dev;\n\n    InputBtnEvent *btn;\n\n    InputMoveEvent *move;\n\n\n\n    switch (evt->type) {\n\n    case INPUT_EVENT_KIND_BTN:\n\n        btn = evt->u.btn;\n\n        if (btn->down) {\n\n            s->buttons |= bmap[btn->button];\n\n        } else {\n\n            s->buttons &= ~bmap[btn->button];\n\n        }\n\n        if (btn->down && btn->button == INPUT_BUTTON_WHEEL_UP) {\n\n            s->qemu_put_mouse_event(s->qemu_put_mouse_event_opaque,\n\n                                    s->axis[INPUT_AXIS_X],\n\n                                    s->axis[INPUT_AXIS_Y],\n\n                                    -1,\n\n                                    s->buttons);\n\n        }\n\n        if (btn->down && btn->button == INPUT_BUTTON_WHEEL_DOWN) {\n\n            s->qemu_put_mouse_event(s->qemu_put_mouse_event_opaque,\n\n                                    s->axis[INPUT_AXIS_X],\n\n                                    s->axis[INPUT_AXIS_Y],\n\n                                    1,\n\n                                    s->buttons);\n\n        }\n\n        break;\n\n    case INPUT_EVENT_KIND_ABS:\n\n        move = evt->u.abs;\n\n        s->axis[move->axis] = move->value;\n\n        break;\n\n    case INPUT_EVENT_KIND_REL:\n\n        move = evt->u.rel;\n\n        s->axis[move->axis] += move->value;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 27096}
{"project": "qemu", "commit_id": "1e885b25275fb6763eb947b1e53b2d6911b967a8", "target": 0, "func": "static guint io_add_watch_poll(GIOChannel *channel,\n\n                               IOCanReadHandler *fd_can_read,\n\n                               GIOFunc fd_read,\n\n                               gpointer user_data)\n\n{\n\n    IOWatchPoll *iwp;\n\n\n\n    iwp = (IOWatchPoll *) g_source_new(&io_watch_poll_funcs, sizeof(IOWatchPoll));\n\n    iwp->fd_can_read = fd_can_read;\n\n    iwp->opaque = user_data;\n\n    iwp->src = g_io_create_watch(channel, G_IO_IN | G_IO_ERR | G_IO_HUP);\n\n    g_source_set_callback(iwp->src, (GSourceFunc)fd_read, user_data, NULL);\n\n\n\n    return g_source_attach(&iwp->parent, NULL);\n\n}\n", "idx": 27099}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static bool try_poll_mode(AioContext *ctx, bool blocking)\n\n{\n\n    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {\n\n        /* See qemu_soonest_timeout() uint64_t hack */\n\n        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),\n\n                             (uint64_t)ctx->poll_ns);\n\n\n\n        if (max_ns) {\n\n            poll_set_started(ctx, true);\n\n\n\n            if (run_poll_handlers(ctx, max_ns)) {\n\n                return true;\n\n            }\n\n        }\n\n    }\n\n\n\n    poll_set_started(ctx, false);\n\n\n\n    /* Even if we don't run busy polling, try polling once in case it can make\n\n     * progress and the caller will be able to avoid ppoll(2)/epoll_wait(2).\n\n     */\n\n    return run_poll_handlers_once(ctx);\n\n}\n", "idx": 27100}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,\n\n                                  SocketAddress *localAddr,\n\n                                  SocketAddress *remoteAddr,\n\n                                  Error **errp)\n\n{\n\n    int fd;\n\n\n\n    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);\n\n    fd = socket_dgram(remoteAddr, localAddr, errp);\n\n    if (fd < 0) {\n\n        trace_qio_channel_socket_dgram_fail(ioc);\n\n        return -1;\n\n    }\n\n\n\n    trace_qio_channel_socket_dgram_complete(ioc, fd);\n\n    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {\n\n        close(fd);\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 27101}
{"project": "qemu", "commit_id": "326b9e98a391d542cc33c4c91782ff4ba51edfc5", "target": 1, "func": "float32 float32_scalbn( float32 a, int n STATUS_PARAM )\n\n{\n\n    flag aSign;\n\n    int16 aExp;\n\n    uint32_t aSig;\n\n\n\n    a = float32_squash_input_denormal(a STATUS_VAR);\n\n    aSig = extractFloat32Frac( a );\n\n    aExp = extractFloat32Exp( a );\n\n    aSign = extractFloat32Sign( a );\n\n\n\n    if ( aExp == 0xFF ) {\n\n        return a;\n\n    }\n\n    if ( aExp != 0 )\n\n        aSig |= 0x00800000;\n\n    else if ( aSig == 0 )\n\n        return a;\n\n\n\n    aExp += n - 1;\n\n    aSig <<= 7;\n\n    return normalizeRoundAndPackFloat32( aSign, aExp, aSig STATUS_VAR );\n\n}\n", "idx": 27105}
{"project": "qemu", "commit_id": "64e69d50a394a48de7607f178d53c192443f9066", "target": 1, "func": "void net_check_clients(void)\n\n{\n\n    VLANState *vlan;\n\n    VLANClientState *vc;\n\n    int has_nic, has_host_dev;\n\n\n\n    QTAILQ_FOREACH(vlan, &vlans, next) {\n\n        QTAILQ_FOREACH(vc, &vlan->clients, next) {\n\n            switch (vc->info->type) {\n\n            case NET_CLIENT_TYPE_NIC:\n\n                has_nic = 1;\n\n                break;\n\n            case NET_CLIENT_TYPE_SLIRP:\n\n            case NET_CLIENT_TYPE_TAP:\n\n            case NET_CLIENT_TYPE_SOCKET:\n\n            case NET_CLIENT_TYPE_VDE:\n\n                has_host_dev = 1;\n\n                break;\n\n            default: ;\n\n            }\n\n        }\n\n        if (has_host_dev && !has_nic)\n\n            fprintf(stderr, \"Warning: vlan %d with no nics\\n\", vlan->id);\n\n        if (has_nic && !has_host_dev)\n\n            fprintf(stderr,\n\n                    \"Warning: vlan %d is not connected to host network\\n\",\n\n                    vlan->id);\n\n    }\n\n    QTAILQ_FOREACH(vc, &non_vlan_clients, next) {\n\n        if (!vc->peer) {\n\n            fprintf(stderr, \"Warning: %s %s has no peer\\n\",\n\n                    vc->info->type == NET_CLIENT_TYPE_NIC ? \"nic\" : \"netdev\",\n\n                    vc->name);\n\n        }\n\n    }\n\n}\n", "idx": 27106}
{"project": "qemu", "commit_id": "563890c7c7e977842e2a35afe7a24d06d2103242", "target": 1, "func": "static int qmp_tmp105_get_temperature(const char *id)\n\n{\n\n    QDict *response;\n\n    int ret;\n\n\n\n    response = qmp(\"{ 'execute': 'qom-get', 'arguments': { 'path': '%s', \"\n\n                   \"'property': 'temperature' } }\", id);\n\n    g_assert(qdict_haskey(response, \"return\"));\n\n    ret = qdict_get_int(response, \"return\");\n\n    QDECREF(response);\n\n    return ret;\n\n}\n", "idx": 27107}
{"project": "qemu", "commit_id": "d17008bc2914d62fd0af6a8f313604ae9f9a102c", "target": 1, "func": "static uint32_t hpet_time_after64(uint64_t a, uint64_t b)\n\n{\n\n    return ((int64_t)(b) - (int64_t)(a) < 0);\n\n}\n", "idx": 27108}
{"project": "qemu", "commit_id": "d19a4d4ef448e736d341df47bd1adc78c8e40814", "target": 1, "func": "static void kvm_arm_gicv3_realize(DeviceState *dev, Error **errp)\n\n{\n\n    GICv3State *s = KVM_ARM_GICV3(dev);\n\n    KVMARMGICv3Class *kgc = KVM_ARM_GICV3_GET_CLASS(s);\n\n    Error *local_err = NULL;\n\n\n\n\n    DPRINTF(\"kvm_arm_gicv3_realize\\n\");\n\n\n\n    kgc->parent_realize(dev, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    if (s->security_extn) {\n\n        error_setg(errp, \"the in-kernel VGICv3 does not implement the \"\n\n                   \"security extensions\");\n\n        return;\n\n    }\n\n\n\n    gicv3_init_irqs_and_mmio(s, kvm_arm_gicv3_set_irq, NULL);\n\n\n\n    /* Try to create the device via the device control API */\n\n    s->dev_fd = kvm_create_device(kvm_state, KVM_DEV_TYPE_ARM_VGIC_V3, false);\n\n    if (s->dev_fd < 0) {\n\n        error_setg_errno(errp, -s->dev_fd, \"error creating in-kernel VGIC\");\n\n        return;\n\n    }\n\n\n\n    kvm_device_access(s->dev_fd, KVM_DEV_ARM_VGIC_GRP_NR_IRQS,\n\n                      0, &s->num_irq, true);\n\n\n\n    /* Tell the kernel to complete VGIC initialization now */\n\n    kvm_device_access(s->dev_fd, KVM_DEV_ARM_VGIC_GRP_CTRL,\n\n                      KVM_DEV_ARM_VGIC_CTRL_INIT, NULL, true);\n\n\n\n    kvm_arm_register_device(&s->iomem_dist, -1, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\n                            KVM_VGIC_V3_ADDR_TYPE_DIST, s->dev_fd);\n\n    kvm_arm_register_device(&s->iomem_redist, -1, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\n                            KVM_VGIC_V3_ADDR_TYPE_REDIST, s->dev_fd);\n\n\n\n    /* Block migration of a KVM GICv3 device: the API for saving and restoring\n\n     * the state in the kernel is not yet finalised in the kernel or\n\n     * implemented in QEMU.\n\n     */\n\n    error_setg(&s->migration_blocker, \"vGICv3 migration is not implemented\");\n\n    migrate_add_blocker(s->migration_blocker);\n\n\n\n    if (kvm_has_gsi_routing()) {\n\n        /* set up irq routing */\n\n        kvm_init_irq_routing(kvm_state);\n\n        for (i = 0; i < s->num_irq - GIC_INTERNAL; ++i) {\n\n            kvm_irqchip_add_irq_route(kvm_state, i, 0, i);\n\n        }\n\n\n\n        kvm_gsi_routing_allowed = true;\n\n\n\n        kvm_irqchip_commit_routes(kvm_state);\n\n    }\n\n}", "idx": 27109}
{"project": "qemu", "commit_id": "b061dc41f62048acd4a34c6570c0ea396cd9d0b4", "target": 1, "func": "static TypeImpl *type_register_internal(const TypeInfo *info)\n\n{\n\n    TypeImpl *ti = g_malloc0(sizeof(*ti));\n\n    int i;\n\n\n\n    g_assert(info->name != NULL);\n\n\n\n    if (type_table_lookup(info->name) != NULL) {\n\n        fprintf(stderr, \"Registering `%s' which already exists\\n\", info->name);\n\n        abort();\n\n    }\n\n\n\n    ti->name = g_strdup(info->name);\n\n    ti->parent = g_strdup(info->parent);\n\n\n\n    ti->class_size = info->class_size;\n\n    ti->instance_size = info->instance_size;\n\n\n\n    ti->class_init = info->class_init;\n\n    ti->class_base_init = info->class_base_init;\n\n    ti->class_finalize = info->class_finalize;\n\n    ti->class_data = info->class_data;\n\n\n\n    ti->instance_init = info->instance_init;\n\n    ti->instance_post_init = info->instance_post_init;\n\n    ti->instance_finalize = info->instance_finalize;\n\n\n\n    ti->abstract = info->abstract;\n\n\n\n    for (i = 0; info->interfaces && info->interfaces[i].type; i++) {\n\n        ti->interfaces[i].typename = g_strdup(info->interfaces[i].type);\n\n    }\n\n    ti->num_interfaces = i;\n\n\n\n    type_table_add(ti);\n\n\n\n    return ti;\n\n}\n", "idx": 27110}
{"project": "qemu", "commit_id": "71b3c3dea21a310c5df7406cdc1cffc64cf14c18", "target": 1, "func": "static int disas_vfp_insn(CPUState * env, DisasContext *s, uint32_t insn)\n\n{\n\n    uint32_t rd, rn, rm, op, i, n, offset, delta_d, delta_m, bank_mask;\n\n    int dp, veclen;\n\n    TCGv addr;\n\n    TCGv tmp;\n\n    TCGv tmp2;\n\n\n\n    if (!arm_feature(env, ARM_FEATURE_VFP))\n\n        return 1;\n\n\n\n    if (!vfp_enabled(env)) {\n\n        /* VFP disabled.  Only allow fmxr/fmrx to/from some control regs.  */\n\n        if ((insn & 0x0fe00fff) != 0x0ee00a10)\n\n            return 1;\n\n        rn = (insn >> 16) & 0xf;\n\n        if (rn != ARM_VFP_FPSID && rn != ARM_VFP_FPEXC\n\n            && rn != ARM_VFP_MVFR1 && rn != ARM_VFP_MVFR0)\n\n            return 1;\n\n    }\n\n    dp = ((insn & 0xf00) == 0xb00);\n\n    switch ((insn >> 24) & 0xf) {\n\n    case 0xe:\n\n        if (insn & (1 << 4)) {\n\n            /* single register transfer */\n\n            rd = (insn >> 12) & 0xf;\n\n            if (dp) {\n\n                int size;\n\n                int pass;\n\n\n\n                VFP_DREG_N(rn, insn);\n\n                if (insn & 0xf)\n\n                    return 1;\n\n                if (insn & 0x00c00060\n\n                    && !arm_feature(env, ARM_FEATURE_NEON))\n\n                    return 1;\n\n\n\n                pass = (insn >> 21) & 1;\n\n                if (insn & (1 << 22)) {\n\n                    size = 0;\n\n                    offset = ((insn >> 5) & 3) * 8;\n\n                } else if (insn & (1 << 5)) {\n\n                    size = 1;\n\n                    offset = (insn & (1 << 6)) ? 16 : 0;\n\n                } else {\n\n                    size = 2;\n\n                    offset = 0;\n\n                }\n\n                if (insn & ARM_CP_RW_BIT) {\n\n                    /* vfp->arm */\n\n                    tmp = neon_load_reg(rn, pass);\n\n                    switch (size) {\n\n                    case 0:\n\n                        if (offset)\n\n                            tcg_gen_shri_i32(tmp, tmp, offset);\n\n                        if (insn & (1 << 23))\n\n                            gen_uxtb(tmp);\n\n                        else\n\n                            gen_sxtb(tmp);\n\n                        break;\n\n                    case 1:\n\n                        if (insn & (1 << 23)) {\n\n                            if (offset) {\n\n                                tcg_gen_shri_i32(tmp, tmp, 16);\n\n                            } else {\n\n                                gen_uxth(tmp);\n\n                            }\n\n                        } else {\n\n                            if (offset) {\n\n                                tcg_gen_sari_i32(tmp, tmp, 16);\n\n                            } else {\n\n                                gen_sxth(tmp);\n\n                            }\n\n                        }\n\n                        break;\n\n                    case 2:\n\n                        break;\n\n                    }\n\n                    store_reg(s, rd, tmp);\n\n                } else {\n\n                    /* arm->vfp */\n\n                    tmp = load_reg(s, rd);\n\n                    if (insn & (1 << 23)) {\n\n                        /* VDUP */\n\n                        if (size == 0) {\n\n                            gen_neon_dup_u8(tmp, 0);\n\n                        } else if (size == 1) {\n\n                            gen_neon_dup_low16(tmp);\n\n                        }\n\n                        for (n = 0; n <= pass * 2; n++) {\n\n                            tmp2 = new_tmp();\n\n                            tcg_gen_mov_i32(tmp2, tmp);\n\n                            neon_store_reg(rn, n, tmp2);\n\n                        }\n\n                        neon_store_reg(rn, n, tmp);\n\n                    } else {\n\n                        /* VMOV */\n\n                        switch (size) {\n\n                        case 0:\n\n                            tmp2 = neon_load_reg(rn, pass);\n\n                            gen_bfi(tmp, tmp2, tmp, offset, 0xff);\n\n                            dead_tmp(tmp2);\n\n                            break;\n\n                        case 1:\n\n                            tmp2 = neon_load_reg(rn, pass);\n\n                            gen_bfi(tmp, tmp2, tmp, offset, 0xffff);\n\n                            dead_tmp(tmp2);\n\n                            break;\n\n                        case 2:\n\n                            break;\n\n                        }\n\n                        neon_store_reg(rn, pass, tmp);\n\n                    }\n\n                }\n\n            } else { /* !dp */\n\n                if ((insn & 0x6f) != 0x00)\n\n                    return 1;\n\n                rn = VFP_SREG_N(insn);\n\n                if (insn & ARM_CP_RW_BIT) {\n\n                    /* vfp->arm */\n\n                    if (insn & (1 << 21)) {\n\n                        /* system register */\n\n                        rn >>= 1;\n\n\n\n                        switch (rn) {\n\n                        case ARM_VFP_FPSID:\n\n                            /* VFP2 allows access to FSID from userspace.\n\n                               VFP3 restricts all id registers to privileged\n\n                               accesses.  */\n\n                            if (IS_USER(s)\n\n                                && arm_feature(env, ARM_FEATURE_VFP3))\n\n                                return 1;\n\n                            tmp = load_cpu_field(vfp.xregs[rn]);\n\n                            break;\n\n                        case ARM_VFP_FPEXC:\n\n                            if (IS_USER(s))\n\n                                return 1;\n\n                            tmp = load_cpu_field(vfp.xregs[rn]);\n\n                            break;\n\n                        case ARM_VFP_FPINST:\n\n                        case ARM_VFP_FPINST2:\n\n                            /* Not present in VFP3.  */\n\n                            if (IS_USER(s)\n\n                                || arm_feature(env, ARM_FEATURE_VFP3))\n\n                                return 1;\n\n                            tmp = load_cpu_field(vfp.xregs[rn]);\n\n                            break;\n\n                        case ARM_VFP_FPSCR:\n\n                            if (rd == 15) {\n\n                                tmp = load_cpu_field(vfp.xregs[ARM_VFP_FPSCR]);\n\n                                tcg_gen_andi_i32(tmp, tmp, 0xf0000000);\n\n                            } else {\n\n                                tmp = new_tmp();\n\n                                gen_helper_vfp_get_fpscr(tmp, cpu_env);\n\n                            }\n\n                            break;\n\n                        case ARM_VFP_MVFR0:\n\n                        case ARM_VFP_MVFR1:\n\n                            if (IS_USER(s)\n\n                                || !arm_feature(env, ARM_FEATURE_VFP3))\n\n                                return 1;\n\n                            tmp = load_cpu_field(vfp.xregs[rn]);\n\n                            break;\n\n                        default:\n\n                            return 1;\n\n                        }\n\n                    } else {\n\n                        gen_mov_F0_vreg(0, rn);\n\n                        tmp = gen_vfp_mrs();\n\n                    }\n\n                    if (rd == 15) {\n\n                        /* Set the 4 flag bits in the CPSR.  */\n\n                        gen_set_nzcv(tmp);\n\n                        dead_tmp(tmp);\n\n                    } else {\n\n                        store_reg(s, rd, tmp);\n\n                    }\n\n                } else {\n\n                    /* arm->vfp */\n\n                    tmp = load_reg(s, rd);\n\n                    if (insn & (1 << 21)) {\n\n                        rn >>= 1;\n\n                        /* system register */\n\n                        switch (rn) {\n\n                        case ARM_VFP_FPSID:\n\n                        case ARM_VFP_MVFR0:\n\n                        case ARM_VFP_MVFR1:\n\n                            /* Writes are ignored.  */\n\n                            break;\n\n                        case ARM_VFP_FPSCR:\n\n                            gen_helper_vfp_set_fpscr(cpu_env, tmp);\n\n                            dead_tmp(tmp);\n\n                            gen_lookup_tb(s);\n\n                            break;\n\n                        case ARM_VFP_FPEXC:\n\n                            if (IS_USER(s))\n\n                                return 1;\n\n\n\n\n                            store_cpu_field(tmp, vfp.xregs[rn]);\n\n                            gen_lookup_tb(s);\n\n                            break;\n\n                        case ARM_VFP_FPINST:\n\n                        case ARM_VFP_FPINST2:\n\n                            store_cpu_field(tmp, vfp.xregs[rn]);\n\n                            break;\n\n                        default:\n\n                            return 1;\n\n                        }\n\n                    } else {\n\n                        gen_vfp_msr(tmp);\n\n                        gen_mov_vreg_F0(0, rn);\n\n                    }\n\n                }\n\n            }\n\n        } else {\n\n            /* data processing */\n\n            /* The opcode is in bits 23, 21, 20 and 6.  */\n\n            op = ((insn >> 20) & 8) | ((insn >> 19) & 6) | ((insn >> 6) & 1);\n\n            if (dp) {\n\n                if (op == 15) {\n\n                    /* rn is opcode */\n\n                    rn = ((insn >> 15) & 0x1e) | ((insn >> 7) & 1);\n\n                } else {\n\n                    /* rn is register number */\n\n                    VFP_DREG_N(rn, insn);\n\n                }\n\n\n\n                if (op == 15 && (rn == 15 || rn > 17)) {\n\n                    /* Integer or single precision destination.  */\n\n                    rd = VFP_SREG_D(insn);\n\n                } else {\n\n                    VFP_DREG_D(rd, insn);\n\n                }\n\n\n\n                if (op == 15 && (rn == 16 || rn == 17)) {\n\n                    /* Integer source.  */\n\n                    rm = ((insn << 1) & 0x1e) | ((insn >> 5) & 1);\n\n                } else {\n\n                    VFP_DREG_M(rm, insn);\n\n                }\n\n            } else {\n\n                rn = VFP_SREG_N(insn);\n\n                if (op == 15 && rn == 15) {\n\n                    /* Double precision destination.  */\n\n                    VFP_DREG_D(rd, insn);\n\n                } else {\n\n                    rd = VFP_SREG_D(insn);\n\n                }\n\n                rm = VFP_SREG_M(insn);\n\n            }\n\n\n\n            veclen = env->vfp.vec_len;\n\n            if (op == 15 && rn > 3)\n\n                veclen = 0;\n\n\n\n            /* Shut up compiler warnings.  */\n\n            delta_m = 0;\n\n            delta_d = 0;\n\n            bank_mask = 0;\n\n\n\n            if (veclen > 0) {\n\n                if (dp)\n\n                    bank_mask = 0xc;\n\n                else\n\n                    bank_mask = 0x18;\n\n\n\n                /* Figure out what type of vector operation this is.  */\n\n                if ((rd & bank_mask) == 0) {\n\n                    /* scalar */\n\n                    veclen = 0;\n\n                } else {\n\n                    if (dp)\n\n                        delta_d = (env->vfp.vec_stride >> 1) + 1;\n\n                    else\n\n                        delta_d = env->vfp.vec_stride + 1;\n\n\n\n                    if ((rm & bank_mask) == 0) {\n\n                        /* mixed scalar/vector */\n\n                        delta_m = 0;\n\n                    } else {\n\n                        /* vector */\n\n                        delta_m = delta_d;\n\n                    }\n\n                }\n\n            }\n\n\n\n            /* Load the initial operands.  */\n\n            if (op == 15) {\n\n                switch (rn) {\n\n                case 16:\n\n                case 17:\n\n                    /* Integer source */\n\n                    gen_mov_F0_vreg(0, rm);\n\n                    break;\n\n                case 8:\n\n                case 9:\n\n                    /* Compare */\n\n                    gen_mov_F0_vreg(dp, rd);\n\n                    gen_mov_F1_vreg(dp, rm);\n\n                    break;\n\n                case 10:\n\n                case 11:\n\n                    /* Compare with zero */\n\n                    gen_mov_F0_vreg(dp, rd);\n\n                    gen_vfp_F1_ld0(dp);\n\n                    break;\n\n                case 20:\n\n                case 21:\n\n                case 22:\n\n                case 23:\n\n                case 28:\n\n                case 29:\n\n                case 30:\n\n                case 31:\n\n                    /* Source and destination the same.  */\n\n                    gen_mov_F0_vreg(dp, rd);\n\n                    break;\n\n                default:\n\n                    /* One source operand.  */\n\n                    gen_mov_F0_vreg(dp, rm);\n\n                    break;\n\n                }\n\n            } else {\n\n                /* Two source operands.  */\n\n                gen_mov_F0_vreg(dp, rn);\n\n                gen_mov_F1_vreg(dp, rm);\n\n            }\n\n\n\n            for (;;) {\n\n                /* Perform the calculation.  */\n\n                switch (op) {\n\n                case 0: /* mac: fd + (fn * fm) */\n\n                    gen_vfp_mul(dp);\n\n                    gen_mov_F1_vreg(dp, rd);\n\n                    gen_vfp_add(dp);\n\n                    break;\n\n                case 1: /* nmac: fd - (fn * fm) */\n\n                    gen_vfp_mul(dp);\n\n                    gen_vfp_neg(dp);\n\n                    gen_mov_F1_vreg(dp, rd);\n\n                    gen_vfp_add(dp);\n\n                    break;\n\n                case 2: /* msc: -fd + (fn * fm) */\n\n                    gen_vfp_mul(dp);\n\n                    gen_mov_F1_vreg(dp, rd);\n\n                    gen_vfp_sub(dp);\n\n                    break;\n\n                case 3: /* nmsc: -fd - (fn * fm)  */\n\n                    gen_vfp_mul(dp);\n\n                    gen_vfp_neg(dp);\n\n                    gen_mov_F1_vreg(dp, rd);\n\n                    gen_vfp_sub(dp);\n\n                    break;\n\n                case 4: /* mul: fn * fm */\n\n                    gen_vfp_mul(dp);\n\n                    break;\n\n                case 5: /* nmul: -(fn * fm) */\n\n                    gen_vfp_mul(dp);\n\n                    gen_vfp_neg(dp);\n\n                    break;\n\n                case 6: /* add: fn + fm */\n\n                    gen_vfp_add(dp);\n\n                    break;\n\n                case 7: /* sub: fn - fm */\n\n                    gen_vfp_sub(dp);\n\n                    break;\n\n                case 8: /* div: fn / fm */\n\n                    gen_vfp_div(dp);\n\n                    break;\n\n                case 14: /* fconst */\n\n                    if (!arm_feature(env, ARM_FEATURE_VFP3))\n\n                      return 1;\n\n\n\n                    n = (insn << 12) & 0x80000000;\n\n                    i = ((insn >> 12) & 0x70) | (insn & 0xf);\n\n                    if (dp) {\n\n                        if (i & 0x40)\n\n                            i |= 0x3f80;\n\n                        else\n\n                            i |= 0x4000;\n\n                        n |= i << 16;\n\n                        tcg_gen_movi_i64(cpu_F0d, ((uint64_t)n) << 32);\n\n                    } else {\n\n                        if (i & 0x40)\n\n                            i |= 0x780;\n\n                        else\n\n                            i |= 0x800;\n\n                        n |= i << 19;\n\n                        tcg_gen_movi_i32(cpu_F0s, n);\n\n                    }\n\n                    break;\n\n                case 15: /* extension space */\n\n                    switch (rn) {\n\n                    case 0: /* cpy */\n\n                        /* no-op */\n\n                        break;\n\n                    case 1: /* abs */\n\n                        gen_vfp_abs(dp);\n\n                        break;\n\n                    case 2: /* neg */\n\n                        gen_vfp_neg(dp);\n\n                        break;\n\n                    case 3: /* sqrt */\n\n                        gen_vfp_sqrt(dp);\n\n                        break;\n\n                    case 8: /* cmp */\n\n                        gen_vfp_cmp(dp);\n\n                        break;\n\n                    case 9: /* cmpe */\n\n                        gen_vfp_cmpe(dp);\n\n                        break;\n\n                    case 10: /* cmpz */\n\n                        gen_vfp_cmp(dp);\n\n                        break;\n\n                    case 11: /* cmpez */\n\n                        gen_vfp_F1_ld0(dp);\n\n                        gen_vfp_cmpe(dp);\n\n                        break;\n\n                    case 15: /* single<->double conversion */\n\n                        if (dp)\n\n                            gen_helper_vfp_fcvtsd(cpu_F0s, cpu_F0d, cpu_env);\n\n                        else\n\n                            gen_helper_vfp_fcvtds(cpu_F0d, cpu_F0s, cpu_env);\n\n                        break;\n\n                    case 16: /* fuito */\n\n                        gen_vfp_uito(dp);\n\n                        break;\n\n                    case 17: /* fsito */\n\n                        gen_vfp_sito(dp);\n\n                        break;\n\n                    case 20: /* fshto */\n\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n\n                          return 1;\n\n                        gen_vfp_shto(dp, 16 - rm);\n\n                        break;\n\n                    case 21: /* fslto */\n\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n\n                          return 1;\n\n                        gen_vfp_slto(dp, 32 - rm);\n\n                        break;\n\n                    case 22: /* fuhto */\n\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n\n                          return 1;\n\n                        gen_vfp_uhto(dp, 16 - rm);\n\n                        break;\n\n                    case 23: /* fulto */\n\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n\n                          return 1;\n\n                        gen_vfp_ulto(dp, 32 - rm);\n\n                        break;\n\n                    case 24: /* ftoui */\n\n                        gen_vfp_toui(dp);\n\n                        break;\n\n                    case 25: /* ftouiz */\n\n                        gen_vfp_touiz(dp);\n\n                        break;\n\n                    case 26: /* ftosi */\n\n                        gen_vfp_tosi(dp);\n\n                        break;\n\n                    case 27: /* ftosiz */\n\n                        gen_vfp_tosiz(dp);\n\n                        break;\n\n                    case 28: /* ftosh */\n\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n\n                          return 1;\n\n                        gen_vfp_tosh(dp, 16 - rm);\n\n                        break;\n\n                    case 29: /* ftosl */\n\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n\n                          return 1;\n\n                        gen_vfp_tosl(dp, 32 - rm);\n\n                        break;\n\n                    case 30: /* ftouh */\n\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n\n                          return 1;\n\n                        gen_vfp_touh(dp, 16 - rm);\n\n                        break;\n\n                    case 31: /* ftoul */\n\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n\n                          return 1;\n\n                        gen_vfp_toul(dp, 32 - rm);\n\n                        break;\n\n                    default: /* undefined */\n\n                        printf (\"rn:%d\\n\", rn);\n\n                        return 1;\n\n                    }\n\n                    break;\n\n                default: /* undefined */\n\n                    printf (\"op:%d\\n\", op);\n\n                    return 1;\n\n                }\n\n\n\n                /* Write back the result.  */\n\n                if (op == 15 && (rn >= 8 && rn <= 11))\n\n                    ; /* Comparison, do nothing.  */\n\n                else if (op == 15 && rn > 17)\n\n                    /* Integer result.  */\n\n                    gen_mov_vreg_F0(0, rd);\n\n                else if (op == 15 && rn == 15)\n\n                    /* conversion */\n\n                    gen_mov_vreg_F0(!dp, rd);\n\n                else\n\n                    gen_mov_vreg_F0(dp, rd);\n\n\n\n                /* break out of the loop if we have finished  */\n\n                if (veclen == 0)\n\n                    break;\n\n\n\n                if (op == 15 && delta_m == 0) {\n\n                    /* single source one-many */\n\n                    while (veclen--) {\n\n                        rd = ((rd + delta_d) & (bank_mask - 1))\n\n                             | (rd & bank_mask);\n\n                        gen_mov_vreg_F0(dp, rd);\n\n                    }\n\n                    break;\n\n                }\n\n                /* Setup the next operands.  */\n\n                veclen--;\n\n                rd = ((rd + delta_d) & (bank_mask - 1))\n\n                     | (rd & bank_mask);\n\n\n\n                if (op == 15) {\n\n                    /* One source operand.  */\n\n                    rm = ((rm + delta_m) & (bank_mask - 1))\n\n                         | (rm & bank_mask);\n\n                    gen_mov_F0_vreg(dp, rm);\n\n                } else {\n\n                    /* Two source operands.  */\n\n                    rn = ((rn + delta_d) & (bank_mask - 1))\n\n                         | (rn & bank_mask);\n\n                    gen_mov_F0_vreg(dp, rn);\n\n                    if (delta_m) {\n\n                        rm = ((rm + delta_m) & (bank_mask - 1))\n\n                             | (rm & bank_mask);\n\n                        gen_mov_F1_vreg(dp, rm);\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    case 0xc:\n\n    case 0xd:\n\n        if (dp && (insn & 0x03e00000) == 0x00400000) {\n\n            /* two-register transfer */\n\n            rn = (insn >> 16) & 0xf;\n\n            rd = (insn >> 12) & 0xf;\n\n            if (dp) {\n\n                VFP_DREG_M(rm, insn);\n\n            } else {\n\n                rm = VFP_SREG_M(insn);\n\n            }\n\n\n\n            if (insn & ARM_CP_RW_BIT) {\n\n                /* vfp->arm */\n\n                if (dp) {\n\n                    gen_mov_F0_vreg(0, rm * 2);\n\n                    tmp = gen_vfp_mrs();\n\n                    store_reg(s, rd, tmp);\n\n                    gen_mov_F0_vreg(0, rm * 2 + 1);\n\n                    tmp = gen_vfp_mrs();\n\n                    store_reg(s, rn, tmp);\n\n                } else {\n\n                    gen_mov_F0_vreg(0, rm);\n\n                    tmp = gen_vfp_mrs();\n\n                    store_reg(s, rn, tmp);\n\n                    gen_mov_F0_vreg(0, rm + 1);\n\n                    tmp = gen_vfp_mrs();\n\n                    store_reg(s, rd, tmp);\n\n                }\n\n            } else {\n\n                /* arm->vfp */\n\n                if (dp) {\n\n                    tmp = load_reg(s, rd);\n\n                    gen_vfp_msr(tmp);\n\n                    gen_mov_vreg_F0(0, rm * 2);\n\n                    tmp = load_reg(s, rn);\n\n                    gen_vfp_msr(tmp);\n\n                    gen_mov_vreg_F0(0, rm * 2 + 1);\n\n                } else {\n\n                    tmp = load_reg(s, rn);\n\n                    gen_vfp_msr(tmp);\n\n                    gen_mov_vreg_F0(0, rm);\n\n                    tmp = load_reg(s, rd);\n\n                    gen_vfp_msr(tmp);\n\n                    gen_mov_vreg_F0(0, rm + 1);\n\n                }\n\n            }\n\n        } else {\n\n            /* Load/store */\n\n            rn = (insn >> 16) & 0xf;\n\n            if (dp)\n\n                VFP_DREG_D(rd, insn);\n\n            else\n\n                rd = VFP_SREG_D(insn);\n\n            if (s->thumb && rn == 15) {\n\n                addr = new_tmp();\n\n                tcg_gen_movi_i32(addr, s->pc & ~2);\n\n            } else {\n\n                addr = load_reg(s, rn);\n\n            }\n\n            if ((insn & 0x01200000) == 0x01000000) {\n\n                /* Single load/store */\n\n                offset = (insn & 0xff) << 2;\n\n                if ((insn & (1 << 23)) == 0)\n\n                    offset = -offset;\n\n                tcg_gen_addi_i32(addr, addr, offset);\n\n                if (insn & (1 << 20)) {\n\n                    gen_vfp_ld(s, dp, addr);\n\n                    gen_mov_vreg_F0(dp, rd);\n\n                } else {\n\n                    gen_mov_F0_vreg(dp, rd);\n\n                    gen_vfp_st(s, dp, addr);\n\n                }\n\n                dead_tmp(addr);\n\n            } else {\n\n                /* load/store multiple */\n\n                if (dp)\n\n                    n = (insn >> 1) & 0x7f;\n\n                else\n\n                    n = insn & 0xff;\n\n\n\n                if (insn & (1 << 24)) /* pre-decrement */\n\n                    tcg_gen_addi_i32(addr, addr, -((insn & 0xff) << 2));\n\n\n\n                if (dp)\n\n                    offset = 8;\n\n                else\n\n                    offset = 4;\n\n                for (i = 0; i < n; i++) {\n\n                    if (insn & ARM_CP_RW_BIT) {\n\n                        /* load */\n\n                        gen_vfp_ld(s, dp, addr);\n\n                        gen_mov_vreg_F0(dp, rd + i);\n\n                    } else {\n\n                        /* store */\n\n                        gen_mov_F0_vreg(dp, rd + i);\n\n                        gen_vfp_st(s, dp, addr);\n\n                    }\n\n                    tcg_gen_addi_i32(addr, addr, offset);\n\n                }\n\n                if (insn & (1 << 21)) {\n\n                    /* writeback */\n\n                    if (insn & (1 << 24))\n\n                        offset = -offset * n;\n\n                    else if (dp && (insn & 1))\n\n                        offset = 4;\n\n                    else\n\n                        offset = 0;\n\n\n\n                    if (offset != 0)\n\n                        tcg_gen_addi_i32(addr, addr, offset);\n\n                    store_reg(s, rn, addr);\n\n                } else {\n\n                    dead_tmp(addr);\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    default:\n\n        /* Should never happen.  */\n\n        return 1;\n\n    }\n\n    return 0;\n\n}", "idx": 27111}
{"project": "qemu", "commit_id": "30d335d68d93705eb346387c03bb6aca0f52454a", "target": 1, "func": "void drive_hot_add(Monitor *mon, const QDict *qdict)\n\n{\n\n    int dom, pci_bus;\n\n    unsigned slot;\n\n    int type, bus;\n\n    PCIDevice *dev;\n\n    DriveInfo *dinfo = NULL;\n\n    const char *pci_addr = qdict_get_str(qdict, \"pci_addr\");\n\n    const char *opts = qdict_get_str(qdict, \"opts\");\n\n    BusState *scsibus;\n\n\n\n    dinfo = add_init_drive(opts);\n\n    if (!dinfo)\n\n        goto err;\n\n    if (dinfo->devaddr) {\n\n        monitor_printf(mon, \"Parameter addr not supported\\n\");\n\n        goto err;\n\n    }\n\n    type = dinfo->type;\n\n    bus = drive_get_max_bus (type);\n\n\n\n    switch (type) {\n\n    case IF_SCSI:\n\n        if (pci_read_devaddr(mon, pci_addr, &dom, &pci_bus, &slot)) {\n\n            goto err;\n\n        }\n\n        dev = pci_find_device(pci_bus, slot, 0);\n\n        if (!dev) {\n\n            monitor_printf(mon, \"no pci device with address %s\\n\", pci_addr);\n\n            goto err;\n\n        }\n\n        scsibus = QLIST_FIRST(&dev->qdev.child_bus);\n\n        scsi_bus_legacy_add_drive(DO_UPCAST(SCSIBus, qbus, scsibus),\n\n                                  dinfo, dinfo->unit);\n\n        monitor_printf(mon, \"OK bus %d, unit %d\\n\",\n\n                       dinfo->bus,\n\n                       dinfo->unit);\n\n        break;\n\n    case IF_NONE:\n\n        monitor_printf(mon, \"OK\\n\");\n\n        break;\n\n    default:\n\n        monitor_printf(mon, \"Can't hot-add drive to type %d\\n\", type);\n\n        goto err;\n\n    }\n\n    return;\n\n\n\nerr:\n\n    if (dinfo)\n\n        drive_uninit(dinfo);\n\n    return;\n\n}\n", "idx": 27112}
{"project": "qemu", "commit_id": "c60174e847082ab9f70720f86509a3353f816fad", "target": 1, "func": "static int usb_device_post_load(void *opaque, int version_id)\n\n{\n\n    USBDevice *dev = opaque;\n\n\n\n    if (dev->state == USB_STATE_NOTATTACHED) {\n\n        dev->attached = 0;\n\n    } else {\n\n        dev->attached = 1;\n\n\n\n\n\n\n    return 0;\n", "idx": 27114}
{"project": "qemu", "commit_id": "ec9c10d29c6bb5613a680af62f5825d3bb2d31d4", "target": 1, "func": "static DriveInfo *blockdev_init(QDict *bs_opts,\n\n                                BlockInterfaceType type,\n\n                                Error **errp)\n\n{\n\n    const char *buf;\n\n    const char *file = NULL;\n\n    const char *serial;\n\n    int ro = 0;\n\n    int bdrv_flags = 0;\n\n    int on_read_error, on_write_error;\n\n    DriveInfo *dinfo;\n\n    ThrottleConfig cfg;\n\n    int snapshot = 0;\n\n    bool copy_on_read;\n\n    int ret;\n\n    Error *error = NULL;\n\n    QemuOpts *opts;\n\n    const char *id;\n\n    bool has_driver_specific_opts;\n\n    BlockDriver *drv = NULL;\n\n\n\n    /* Check common options by copying from bs_opts to opts, all other options\n\n     * stay in bs_opts for processing by bdrv_open(). */\n\n    id = qdict_get_try_str(bs_opts, \"id\");\n\n    opts = qemu_opts_create(&qemu_common_drive_opts, id, 1, &error);\n\n    if (error_is_set(&error)) {\n\n        error_propagate(errp, error);\n\n        return NULL;\n\n    }\n\n\n\n    qemu_opts_absorb_qdict(opts, bs_opts, &error);\n\n    if (error_is_set(&error)) {\n\n        error_propagate(errp, error);\n\n        return NULL;\n\n    }\n\n\n\n    if (id) {\n\n        qdict_del(bs_opts, \"id\");\n\n    }\n\n\n\n    has_driver_specific_opts = !!qdict_size(bs_opts);\n\n\n\n    /* extract parameters */\n\n    snapshot = qemu_opt_get_bool(opts, \"snapshot\", 0);\n\n    ro = qemu_opt_get_bool(opts, \"read-only\", 0);\n\n    copy_on_read = qemu_opt_get_bool(opts, \"copy-on-read\", false);\n\n\n\n    file = qemu_opt_get(opts, \"file\");\n\n    serial = qemu_opt_get(opts, \"serial\");\n\n\n\n    if ((buf = qemu_opt_get(opts, \"discard\")) != NULL) {\n\n        if (bdrv_parse_discard_flags(buf, &bdrv_flags) != 0) {\n\n            error_setg(errp, \"invalid discard option\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if (qemu_opt_get_bool(opts, \"cache.writeback\", true)) {\n\n        bdrv_flags |= BDRV_O_CACHE_WB;\n\n    }\n\n    if (qemu_opt_get_bool(opts, \"cache.direct\", false)) {\n\n        bdrv_flags |= BDRV_O_NOCACHE;\n\n    }\n\n    if (qemu_opt_get_bool(opts, \"cache.no-flush\", false)) {\n\n        bdrv_flags |= BDRV_O_NO_FLUSH;\n\n    }\n\n\n\n#ifdef CONFIG_LINUX_AIO\n\n    if ((buf = qemu_opt_get(opts, \"aio\")) != NULL) {\n\n        if (!strcmp(buf, \"native\")) {\n\n            bdrv_flags |= BDRV_O_NATIVE_AIO;\n\n        } else if (!strcmp(buf, \"threads\")) {\n\n            /* this is the default */\n\n        } else {\n\n           error_setg(errp, \"invalid aio option\");\n\n           return NULL;\n\n        }\n\n    }\n\n#endif\n\n\n\n    if ((buf = qemu_opt_get(opts, \"format\")) != NULL) {\n\n        if (is_help_option(buf)) {\n\n            error_printf(\"Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            error_printf(\"\\n\");\n\n            return NULL;\n\n        }\n\n\n\n        drv = bdrv_find_format(buf);\n\n        if (!drv) {\n\n            error_setg(errp, \"'%s' invalid format\", buf);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* disk I/O throttling */\n\n    memset(&cfg, 0, sizeof(cfg));\n\n    cfg.buckets[THROTTLE_BPS_TOTAL].avg =\n\n        qemu_opt_get_number(opts, \"throttling.bps-total\", 0);\n\n    cfg.buckets[THROTTLE_BPS_READ].avg  =\n\n        qemu_opt_get_number(opts, \"throttling.bps-read\", 0);\n\n    cfg.buckets[THROTTLE_BPS_WRITE].avg =\n\n        qemu_opt_get_number(opts, \"throttling.bps-write\", 0);\n\n    cfg.buckets[THROTTLE_OPS_TOTAL].avg =\n\n        qemu_opt_get_number(opts, \"throttling.iops-total\", 0);\n\n    cfg.buckets[THROTTLE_OPS_READ].avg =\n\n        qemu_opt_get_number(opts, \"throttling.iops-read\", 0);\n\n    cfg.buckets[THROTTLE_OPS_WRITE].avg =\n\n        qemu_opt_get_number(opts, \"throttling.iops-write\", 0);\n\n\n\n    cfg.buckets[THROTTLE_BPS_TOTAL].max =\n\n        qemu_opt_get_number(opts, \"throttling.bps-total-max\", 0);\n\n    cfg.buckets[THROTTLE_BPS_READ].max  =\n\n        qemu_opt_get_number(opts, \"throttling.bps-read-max\", 0);\n\n    cfg.buckets[THROTTLE_BPS_WRITE].max =\n\n        qemu_opt_get_number(opts, \"throttling.bps-write-max\", 0);\n\n    cfg.buckets[THROTTLE_OPS_TOTAL].max =\n\n        qemu_opt_get_number(opts, \"throttling.iops-total-max\", 0);\n\n    cfg.buckets[THROTTLE_OPS_READ].max =\n\n        qemu_opt_get_number(opts, \"throttling.iops-read-max\", 0);\n\n    cfg.buckets[THROTTLE_OPS_WRITE].max =\n\n        qemu_opt_get_number(opts, \"throttling.iops-write-max\", 0);\n\n\n\n    cfg.op_size = qemu_opt_get_number(opts, \"throttling.iops-size\", 0);\n\n\n\n    if (!check_throttle_config(&cfg, &error)) {\n\n        error_propagate(errp, error);\n\n        return NULL;\n\n    }\n\n\n\n    on_write_error = BLOCKDEV_ON_ERROR_ENOSPC;\n\n    if ((buf = qemu_opt_get(opts, \"werror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO && type != IF_NONE) {\n\n            error_setg(errp, \"werror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_write_error = parse_block_error_action(buf, 0, &error);\n\n        if (error_is_set(&error)) {\n\n            error_propagate(errp, error);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    on_read_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    if ((buf = qemu_opt_get(opts, \"rerror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_VIRTIO && type != IF_SCSI && type != IF_NONE) {\n\n            error_report(\"rerror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_read_error = parse_block_error_action(buf, 1, &error);\n\n        if (error_is_set(&error)) {\n\n            error_propagate(errp, error);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* init */\n\n    dinfo = g_malloc0(sizeof(*dinfo));\n\n    dinfo->id = g_strdup(qemu_opts_id(opts));\n\n    dinfo->bdrv = bdrv_new(dinfo->id);\n\n    dinfo->bdrv->open_flags = snapshot ? BDRV_O_SNAPSHOT : 0;\n\n    dinfo->bdrv->read_only = ro;\n\n    dinfo->type = type;\n\n    dinfo->refcount = 1;\n\n    if (serial != NULL) {\n\n        dinfo->serial = g_strdup(serial);\n\n    }\n\n    QTAILQ_INSERT_TAIL(&drives, dinfo, next);\n\n\n\n    bdrv_set_on_error(dinfo->bdrv, on_read_error, on_write_error);\n\n\n\n    /* disk I/O throttling */\n\n    if (throttle_enabled(&cfg)) {\n\n        bdrv_io_limits_enable(dinfo->bdrv);\n\n        bdrv_set_io_limits(dinfo->bdrv, &cfg);\n\n    }\n\n\n\n    if (!file || !*file) {\n\n        if (has_driver_specific_opts) {\n\n            file = NULL;\n\n        } else {\n\n            return dinfo;\n\n        }\n\n    }\n\n    if (snapshot) {\n\n        /* always use cache=unsafe with snapshot */\n\n        bdrv_flags &= ~BDRV_O_CACHE_MASK;\n\n        bdrv_flags |= (BDRV_O_SNAPSHOT|BDRV_O_CACHE_WB|BDRV_O_NO_FLUSH);\n\n    }\n\n\n\n    if (copy_on_read) {\n\n        bdrv_flags |= BDRV_O_COPY_ON_READ;\n\n    }\n\n\n\n    if (runstate_check(RUN_STATE_INMIGRATE)) {\n\n        bdrv_flags |= BDRV_O_INCOMING;\n\n    }\n\n\n\n    bdrv_flags |= ro ? 0 : BDRV_O_RDWR;\n\n\n\n    QINCREF(bs_opts);\n\n    ret = bdrv_open(dinfo->bdrv, file, bs_opts, bdrv_flags, drv, &error);\n\n\n\n    if (ret < 0) {\n\n        error_setg(errp, \"could not open disk image %s: %s\",\n\n                   file ?: dinfo->id, error_get_pretty(error));\n\n        error_free(error);\n\n        goto err;\n\n    }\n\n\n\n    if (bdrv_key_required(dinfo->bdrv))\n\n        autostart = 0;\n\n\n\n    QDECREF(bs_opts);\n\n    qemu_opts_del(opts);\n\n\n\n    return dinfo;\n\n\n\nerr:\n\n    qemu_opts_del(opts);\n\n    QDECREF(bs_opts);\n\n    bdrv_unref(dinfo->bdrv);\n\n    g_free(dinfo->id);\n\n    QTAILQ_REMOVE(&drives, dinfo, next);\n\n    g_free(dinfo);\n\n    return NULL;\n\n}\n", "idx": 27115}
{"project": "qemu", "commit_id": "3de3d698d942d1116152417f882c897b26b44e41", "target": 1, "func": "int inet_listen_opts(QemuOpts *opts, int port_offset, Error **errp)\n\n{\n\n    struct addrinfo ai,*res,*e;\n\n    const char *addr;\n\n    char port[33];\n\n    char uaddr[INET6_ADDRSTRLEN+1];\n\n    char uport[33];\n\n    int slisten, rc, to, port_min, port_max, p;\n\n\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;\n\n    ai.ai_family = PF_UNSPEC;\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    if ((qemu_opt_get(opts, \"host\") == NULL) ||\n\n        (qemu_opt_get(opts, \"port\") == NULL)) {\n\n        error_setg(errp, \"host and/or port not specified\");\n\n        return -1;\n\n    }\n\n    pstrcpy(port, sizeof(port), qemu_opt_get(opts, \"port\"));\n\n    addr = qemu_opt_get(opts, \"host\");\n\n\n\n    to = qemu_opt_get_number(opts, \"to\", 0);\n\n    if (qemu_opt_get_bool(opts, \"ipv4\", 0))\n\n        ai.ai_family = PF_INET;\n\n    if (qemu_opt_get_bool(opts, \"ipv6\", 0))\n\n        ai.ai_family = PF_INET6;\n\n\n\n    /* lookup */\n\n    if (port_offset) {\n\n        unsigned long long baseport;\n\n        if (parse_uint_full(port, &baseport, 10) < 0) {\n\n            error_setg(errp, \"can't convert to a number: %s\", port);\n\n            return -1;\n\n        }\n\n        if (baseport > 65535 ||\n\n            baseport + port_offset > 65535) {\n\n            error_setg(errp, \"port %s out of range\", port);\n\n            return -1;\n\n        }\n\n        snprintf(port, sizeof(port), \"%d\", (int)baseport + port_offset);\n\n    }\n\n    rc = getaddrinfo(strlen(addr) ? addr : NULL, port, &ai, &res);\n\n    if (rc != 0) {\n\n        error_setg(errp, \"address resolution failed for %s:%s: %s\", addr, port,\n\n                   gai_strerror(rc));\n\n        return -1;\n\n    }\n\n\n\n    /* create socket + bind */\n\n    for (e = res; e != NULL; e = e->ai_next) {\n\n        getnameinfo((struct sockaddr*)e->ai_addr,e->ai_addrlen,\n\n\t\t        uaddr,INET6_ADDRSTRLEN,uport,32,\n\n\t\t        NI_NUMERICHOST | NI_NUMERICSERV);\n\n        slisten = qemu_socket(e->ai_family, e->ai_socktype, e->ai_protocol);\n\n        if (slisten < 0) {\n\n            if (!e->ai_next) {\n\n                error_setg_errno(errp, errno, \"Failed to create socket\");\n\n            }\n\n            continue;\n\n        }\n\n\n\n        socket_set_fast_reuse(slisten);\n\n#ifdef IPV6_V6ONLY\n\n        if (e->ai_family == PF_INET6) {\n\n            /* listen on both ipv4 and ipv6 */\n\n            const int off = 0;\n\n            qemu_setsockopt(slisten, IPPROTO_IPV6, IPV6_V6ONLY, &off,\n\n                            sizeof(off));\n\n        }\n\n#endif\n\n\n\n        port_min = inet_getport(e);\n\n        port_max = to ? to + port_offset : port_min;\n\n        for (p = port_min; p <= port_max; p++) {\n\n            inet_setport(e, p);\n\n            if (bind(slisten, e->ai_addr, e->ai_addrlen) == 0) {\n\n                goto listen;\n\n            }\n\n            if (p == port_max) {\n\n                if (!e->ai_next) {\n\n                    error_setg_errno(errp, errno, \"Failed to bind socket\");\n\n                }\n\n            }\n\n        }\n\n        closesocket(slisten);\n\n    }\n\n    freeaddrinfo(res);\n\n    return -1;\n\n\n\nlisten:\n\n    if (listen(slisten,1) != 0) {\n\n        error_setg_errno(errp, errno, \"Failed to listen on socket\");\n\n        closesocket(slisten);\n\n        freeaddrinfo(res);\n\n        return -1;\n\n    }\n\n    qemu_opt_set(opts, \"host\", uaddr, &error_abort);\n\n    qemu_opt_set_number(opts, \"port\", inet_getport(e) - port_offset,\n\n                        &error_abort);\n\n    qemu_opt_set_bool(opts, \"ipv6\", e->ai_family == PF_INET6,\n\n                      &error_abort);\n\n    qemu_opt_set_bool(opts, \"ipv4\", e->ai_family != PF_INET6,\n\n                      &error_abort);\n\n    freeaddrinfo(res);\n\n    return slisten;\n\n}\n", "idx": 27116}
{"project": "qemu", "commit_id": "88be7b4be4aa17c88247e162bdd7577ea79db94f", "target": 1, "func": "BdrvNextIterator *bdrv_next(BdrvNextIterator *it, BlockDriverState **bs)\n\n{\n\n    if (!it) {\n\n        it = g_new(BdrvNextIterator, 1);\n\n        *it = (BdrvNextIterator) {\n\n            .phase = BDRV_NEXT_BACKEND_ROOTS,\n\n        };\n\n    }\n\n\n\n    /* First, return all root nodes of BlockBackends. In order to avoid\n\n     * returning a BDS twice when multiple BBs refer to it, we only return it\n\n     * if the BB is the first one in the parent list of the BDS. */\n\n    if (it->phase == BDRV_NEXT_BACKEND_ROOTS) {\n\n        do {\n\n            it->blk = blk_all_next(it->blk);\n\n            *bs = it->blk ? blk_bs(it->blk) : NULL;\n\n        } while (it->blk && (*bs == NULL || bdrv_first_blk(*bs) != it->blk));\n\n\n\n        if (*bs) {\n\n            return it;\n\n        }\n\n        it->phase = BDRV_NEXT_MONITOR_OWNED;\n\n    }\n\n\n\n    /* Then return the monitor-owned BDSes without a BB attached. Ignore all\n\n     * BDSes that are attached to a BlockBackend here; they have been handled\n\n     * by the above block already */\n\n    do {\n\n        it->bs = bdrv_next_monitor_owned(it->bs);\n\n        *bs = it->bs;\n\n    } while (*bs && bdrv_has_blk(*bs));\n\n\n\n    return *bs ? it : NULL;\n\n}\n", "idx": 27120}
{"project": "qemu", "commit_id": "8fd2a2f1a9048b9e37a898c2a5e9ef59d0c1a095", "target": 1, "func": "static int virtio_net_handle_mac(VirtIONet *n, uint8_t cmd,\n\n                                 VirtQueueElement *elem)\n\n{\n\n    struct virtio_net_ctrl_mac mac_data;\n\n\n\n    if (cmd != VIRTIO_NET_CTRL_MAC_TABLE_SET || elem->out_num != 3 ||\n\n        elem->out_sg[1].iov_len < sizeof(mac_data) ||\n\n        elem->out_sg[2].iov_len < sizeof(mac_data))\n\n        return VIRTIO_NET_ERR;\n\n\n\n    n->mac_table.in_use = 0;\n\n    memset(n->mac_table.macs, 0, MAC_TABLE_ENTRIES * ETH_ALEN);\n\n\n\n    mac_data.entries = ldl_le_p(elem->out_sg[1].iov_base);\n\n\n\n    if (sizeof(mac_data.entries) +\n\n        (mac_data.entries * ETH_ALEN) > elem->out_sg[1].iov_len)\n\n        return VIRTIO_NET_ERR;\n\n\n\n    if (mac_data.entries <= MAC_TABLE_ENTRIES) {\n\n        memcpy(n->mac_table.macs, elem->out_sg[1].iov_base + sizeof(mac_data),\n\n               mac_data.entries * ETH_ALEN);\n\n        n->mac_table.in_use += mac_data.entries;\n\n    } else {\n\n        n->promisc = 1;\n\n        return VIRTIO_NET_OK;\n\n    }\n\n\n\n    mac_data.entries = ldl_le_p(elem->out_sg[2].iov_base);\n\n\n\n    if (sizeof(mac_data.entries) +\n\n        (mac_data.entries * ETH_ALEN) > elem->out_sg[2].iov_len)\n\n        return VIRTIO_NET_ERR;\n\n\n\n    if (mac_data.entries) {\n\n        if (n->mac_table.in_use + mac_data.entries <= MAC_TABLE_ENTRIES) {\n\n            memcpy(n->mac_table.macs + (n->mac_table.in_use * ETH_ALEN),\n\n                   elem->out_sg[2].iov_base + sizeof(mac_data),\n\n                   mac_data.entries * ETH_ALEN);\n\n            n->mac_table.in_use += mac_data.entries;\n\n        } else\n\n            n->allmulti = 1;\n\n    }\n\n\n\n    return VIRTIO_NET_OK;\n\n}\n", "idx": 27124}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "static ssize_t vnc_tls_pull(gnutls_transport_ptr_t transport,\n\n                            void *data,\n\n                            size_t len) {\n\n    VncState *vs = (VncState *)transport;\n\n    int ret;\n\n\n\n retry:\n\n    ret = qemu_recv(vs->csock, data, len, 0);\n\n    if (ret < 0) {\n\n        if (errno == EINTR)\n\n            goto retry;\n\n        return -1;\n\n    }\n\n    return ret;\n\n}\n", "idx": 27125}
{"project": "qemu", "commit_id": "696b55017d90b3237ca9d656aa4904d6b5c46c7a", "target": 1, "func": "file_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)\n\n{\n\n    HostMemoryBackendFile *fb = MEMORY_BACKEND_FILE(backend);\n\n\n\n    if (!backend->size) {\n\n        error_setg(errp, \"can't create backend with size 0\");\n\n        return;\n\n    }\n\n    if (!fb->mem_path) {\n\n        error_setg(errp, \"mem-path property not set\");\n\n        return;\n\n    }\n\n#ifndef CONFIG_LINUX\n\n    error_setg(errp, \"-mem-path not supported on this host\");\n\n#else\n\n    if (!memory_region_size(&backend->mr)) {\n\n        backend->force_prealloc = mem_prealloc;\n\n        memory_region_init_ram_from_file(&backend->mr, OBJECT(backend),\n\n                                 object_get_canonical_path(OBJECT(backend)),\n\n                                 backend->size, fb->share,\n\n                                 fb->mem_path, errp);\n\n    }\n\n#endif\n\n}\n", "idx": 27126}
{"project": "qemu", "commit_id": "bfb1ac14029ee72b19296109fba880c0551755d5", "target": 1, "func": "sorecvoob(struct socket *so)\n\n{\n\n\tstruct tcpcb *tp = sototcpcb(so);\n\n\n\n\tDEBUG_CALL(\"sorecvoob\");\n\n\tDEBUG_ARG(\"so = %p\", so);\n\n\n\n\t/*\n\n\t * We take a guess at how much urgent data has arrived.\n\n\t * In most situations, when urgent data arrives, the next\n\n\t * read() should get all the urgent data.  This guess will\n\n\t * be wrong however if more data arrives just after the\n\n\t * urgent data, or the read() doesn't return all the\n\n\t * urgent data.\n\n\t */\n\n\tsoread(so);\n\n\ttp->snd_up = tp->snd_una + so->so_snd.sb_cc;\n\n\ttp->t_force = 1;\n\n\ttcp_output(tp);\n\n\ttp->t_force = 0;\n\n}\n", "idx": 27127}
{"project": "qemu", "commit_id": "93b665693dd4afd32c89b0d5ee2b407b26a7a3bc", "target": 1, "func": "static uint32_t cmos_ioport_read(void *opaque, uint32_t addr)\n\n{\n\n    RTCState *s = opaque;\n\n    int ret;\n\n    if ((addr & 1) == 0) {\n\n        return 0xff;\n\n    } else {\n\n        switch(s->cmos_index) {\n\n        case RTC_SECONDS:\n\n        case RTC_MINUTES:\n\n        case RTC_HOURS:\n\n        case RTC_DAY_OF_WEEK:\n\n        case RTC_DAY_OF_MONTH:\n\n        case RTC_MONTH:\n\n        case RTC_YEAR:\n\n            ret = s->cmos_data[s->cmos_index];\n\n            break;\n\n        case RTC_REG_A:\n\n            ret = s->cmos_data[s->cmos_index];\n\n            break;\n\n        case RTC_REG_C:\n\n            ret = s->cmos_data[s->cmos_index];\n\n            qemu_irq_lower(s->irq);\n\n#ifdef TARGET_I386\n\n            if(s->irq_coalesced) {\n\n                apic_reset_irq_delivered();\n\n                qemu_irq_raise(s->irq);\n\n                if (apic_get_irq_delivered())\n\n                    s->irq_coalesced--;\n\n                break;\n\n            }\n\n#endif\n\n            s->cmos_data[RTC_REG_C] = 0x00;\n\n            break;\n\n        default:\n\n            ret = s->cmos_data[s->cmos_index];\n\n            break;\n\n        }\n\n#ifdef DEBUG_CMOS\n\n        printf(\"cmos: read index=0x%02x val=0x%02x\\n\",\n\n               s->cmos_index, ret);\n\n#endif\n\n        return ret;\n\n    }\n\n}\n", "idx": 27128}
{"project": "qemu", "commit_id": "f678f671ba654d4610f0e43d175c8c1b2fad10df", "target": 1, "func": "static void decode_sys_interrupts(CPUTriCoreState *env, DisasContext *ctx)\n\n{\n\n    uint32_t op2;\n\n    uint32_t r1;\n\n    TCGLabel *l1;\n\n    TCGv tmp;\n\n\n\n    op2 = MASK_OP_SYS_OP2(ctx->opcode);\n\n    r1  = MASK_OP_SYS_S1D(ctx->opcode);\n\n\n\n    switch (op2) {\n\n    case OPC2_32_SYS_DEBUG:\n\n        /* raise EXCP_DEBUG */\n\n        break;\n\n    case OPC2_32_SYS_DISABLE:\n\n        tcg_gen_andi_tl(cpu_ICR, cpu_ICR, ~MASK_ICR_IE);\n\n        break;\n\n    case OPC2_32_SYS_DSYNC:\n\n        break;\n\n    case OPC2_32_SYS_ENABLE:\n\n        tcg_gen_ori_tl(cpu_ICR, cpu_ICR, MASK_ICR_IE);\n\n        break;\n\n    case OPC2_32_SYS_ISYNC:\n\n        break;\n\n    case OPC2_32_SYS_NOP:\n\n        break;\n\n    case OPC2_32_SYS_RET:\n\n        gen_compute_branch(ctx, op2, 0, 0, 0, 0);\n\n        break;\n\n    case OPC2_32_SYS_FRET:\n\n        gen_fret(ctx);\n\n        break;\n\n    case OPC2_32_SYS_RFE:\n\n        gen_helper_rfe(cpu_env);\n\n        tcg_gen_exit_tb(0);\n\n        ctx->bstate = BS_BRANCH;\n\n        break;\n\n    case OPC2_32_SYS_RFM:\n\n        if ((ctx->hflags & TRICORE_HFLAG_KUU) == TRICORE_HFLAG_SM) {\n\n            tmp = tcg_temp_new();\n\n            l1 = gen_new_label();\n\n\n\n            tcg_gen_ld32u_tl(tmp, cpu_env, offsetof(CPUTriCoreState, DBGSR));\n\n            tcg_gen_andi_tl(tmp, tmp, MASK_DBGSR_DE);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, tmp, 1, l1);\n\n            gen_helper_rfm(cpu_env);\n\n            gen_set_label(l1);\n\n            tcg_gen_exit_tb(0);\n\n            ctx->bstate = BS_BRANCH;\n\n            tcg_temp_free(tmp);\n\n        } else {\n\n            /* generate privilege trap */\n\n        }\n\n        break;\n\n    case OPC2_32_SYS_RSLCX:\n\n        gen_helper_rslcx(cpu_env);\n\n        break;\n\n    case OPC2_32_SYS_SVLCX:\n\n        gen_helper_svlcx(cpu_env);\n\n        break;\n\n    case OPC2_32_SYS_RESTORE:\n\n        if (tricore_feature(env, TRICORE_FEATURE_16)) {\n\n            if ((ctx->hflags & TRICORE_HFLAG_KUU) == TRICORE_HFLAG_SM ||\n\n                (ctx->hflags & TRICORE_HFLAG_KUU) == TRICORE_HFLAG_UM1) {\n\n                tcg_gen_deposit_tl(cpu_ICR, cpu_ICR, cpu_gpr_d[r1], 8, 1);\n\n            } /* else raise privilege trap */\n\n        } /* else raise illegal opcode trap */\n\n        break;\n\n    case OPC2_32_SYS_TRAPSV:\n\n        l1 = gen_new_label();\n\n        tcg_gen_brcondi_tl(TCG_COND_GE, cpu_PSW_SV, 0, l1);\n\n        generate_trap(ctx, TRAPC_ASSERT, TIN5_SOVF);\n\n        gen_set_label(l1);\n\n        break;\n\n    case OPC2_32_SYS_TRAPV:\n\n        l1 = gen_new_label();\n\n        tcg_gen_brcondi_tl(TCG_COND_GE, cpu_PSW_V, 0, l1);\n\n        generate_trap(ctx, TRAPC_ASSERT, TIN5_OVF);\n\n        gen_set_label(l1);\n\n        break;\n\n    }\n\n}\n", "idx": 27129}
{"project": "qemu", "commit_id": "5dd7a535b71a0f2f8e7af75c5d694174359ce323", "target": 1, "func": "iscsi_co_generic_cb(struct iscsi_context *iscsi, int status,\n\n                        void *command_data, void *opaque)\n\n{\n\n    struct IscsiTask *iTask = opaque;\n\n    struct scsi_task *task = command_data;\n\n\n\n    iTask->status = status;\n\n    iTask->do_retry = 0;\n\n    iTask->task = task;\n\n\n\n    if (status != SCSI_STATUS_GOOD) {\n\n        if (iTask->retries++ < ISCSI_CMD_RETRIES) {\n\n            if (status == SCSI_STATUS_CHECK_CONDITION\n\n                && task->sense.key == SCSI_SENSE_UNIT_ATTENTION) {\n\n                error_report(\"iSCSI CheckCondition: %s\",\n\n                             iscsi_get_error(iscsi));\n\n                iTask->do_retry = 1;\n\n                goto out;\n\n            }\n\n            /* status 0x28 is SCSI_TASK_SET_FULL. It was first introduced\n\n             * in libiscsi 1.10.0. Hardcode this value here to avoid\n\n             * the need to bump the libiscsi requirement to 1.10.0 */\n\n            if (status == SCSI_STATUS_BUSY || status == 0x28) {\n\n                unsigned retry_time =\n\n                    exp_random(iscsi_retry_times[iTask->retries - 1]);\n\n                error_report(\"iSCSI Busy/TaskSetFull (retry #%u in %u ms): %s\",\n\n                             iTask->retries, retry_time,\n\n                             iscsi_get_error(iscsi));\n\n                aio_timer_init(iTask->iscsilun->aio_context,\n\n                               &iTask->retry_timer, QEMU_CLOCK_REALTIME,\n\n                               SCALE_MS, iscsi_retry_timer_expired, iTask);\n\n                timer_mod(&iTask->retry_timer,\n\n                          qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + retry_time);\n\n                iTask->do_retry = 1;\n\n                return;\n\n            }\n\n        }\n\n        error_report(\"iSCSI Failure: %s\", iscsi_get_error(iscsi));\n\n    } else {\n\n        iTask->iscsilun->force_next_flush |= iTask->force_next_flush;\n\n    }\n\n\n\nout:\n\n    if (iTask->co) {\n\n        iTask->bh = aio_bh_new(iTask->iscsilun->aio_context,\n\n                               iscsi_co_generic_bh_cb, iTask);\n\n        qemu_bh_schedule(iTask->bh);\n\n    } else {\n\n        iTask->complete = 1;\n\n    }\n\n}\n", "idx": 27130}
{"project": "qemu", "commit_id": "33e66b86d89040f0a9e99aa53deb74ce8936a649", "target": 1, "func": "SCSIDevice *scsi_bus_legacy_add_drive(SCSIBus *bus, DriveInfo *dinfo, int unit)\n\n{\n\n    const char *driver;\n\n    DeviceState *dev;\n\n\n\n    driver = bdrv_is_sg(dinfo->bdrv) ? \"scsi-generic\" : \"scsi-disk\";\n\n    dev = qdev_create(&bus->qbus, driver);\n\n    qdev_prop_set_uint32(dev, \"scsi-id\", unit);\n\n    qdev_prop_set_drive(dev, \"drive\", dinfo);\n\n    qdev_init(dev);\n\n    return DO_UPCAST(SCSIDevice, qdev, dev);\n\n}\n", "idx": 27140}
{"project": "qemu", "commit_id": "36bcac16fdd6ecb75314db06171f54dcd400ab8c", "target": 1, "func": "static int sd_open(BlockDriverState *bs, QDict *options, int flags,\n\n                   Error **errp)\n\n{\n\n    int ret, fd;\n\n    uint32_t vid = 0;\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    char vdi[SD_MAX_VDI_LEN], tag[SD_MAX_VDI_TAG_LEN];\n\n    uint32_t snapid;\n\n    char *buf = NULL;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n    const char *filename;\n\n\n\n    s->bs = bs;\n\n    s->aio_context = bdrv_get_aio_context(bs);\n\n\n\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto err_no_fd;\n\n    }\n\n\n\n    filename = qemu_opt_get(opts, \"filename\");\n\n\n\n    QLIST_INIT(&s->inflight_aio_head);\n\n    QLIST_INIT(&s->failed_aio_head);\n\n    QLIST_INIT(&s->inflight_aiocb_head);\n\n    s->fd = -1;\n\n\n\n    memset(vdi, 0, sizeof(vdi));\n\n    memset(tag, 0, sizeof(tag));\n\n\n\n    if (strstr(filename, \"://\")) {\n\n        ret = sd_parse_uri(s, filename, vdi, &snapid, tag);\n\n    } else {\n\n        ret = parse_vdiname(s, filename, vdi, &snapid, tag);\n\n    }\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Can't parse filename\");\n\n        goto err_no_fd;\n\n    }\n\n    s->fd = get_sheep_fd(s, errp);\n\n    if (s->fd < 0) {\n\n        ret = s->fd;\n\n        goto err_no_fd;\n\n    }\n\n\n\n    ret = find_vdi_name(s, vdi, snapid, tag, &vid, true, errp);\n\n    if (ret) {\n\n        goto err;\n\n    }\n\n\n\n    /*\n\n     * QEMU block layer emulates writethrough cache as 'writeback + flush', so\n\n     * we always set SD_FLAG_CMD_CACHE (writeback cache) as default.\n\n     */\n\n    s->cache_flags = SD_FLAG_CMD_CACHE;\n\n    if (flags & BDRV_O_NOCACHE) {\n\n        s->cache_flags = SD_FLAG_CMD_DIRECT;\n\n    }\n\n    s->discard_supported = true;\n\n\n\n    if (snapid || tag[0] != '\\0') {\n\n        DPRINTF(\"%\" PRIx32 \" snapshot inode was open.\\n\", vid);\n\n        s->is_snapshot = true;\n\n    }\n\n\n\n    fd = connect_to_sdog(s, errp);\n\n    if (fd < 0) {\n\n        ret = fd;\n\n        goto err;\n\n    }\n\n\n\n    buf = g_malloc(SD_INODE_SIZE);\n\n    ret = read_object(fd, s->bs, buf, vid_to_vdi_oid(vid),\n\n                      0, SD_INODE_SIZE, 0, s->cache_flags);\n\n\n\n    closesocket(fd);\n\n\n\n    if (ret) {\n\n        error_setg(errp, \"Can't read snapshot inode\");\n\n        goto err;\n\n    }\n\n\n\n    memcpy(&s->inode, buf, sizeof(s->inode));\n\n\n\n    bs->total_sectors = s->inode.vdi_size / BDRV_SECTOR_SIZE;\n\n    pstrcpy(s->name, sizeof(s->name), vdi);\n\n    qemu_co_mutex_init(&s->lock);\n\n    qemu_co_queue_init(&s->overlapping_queue);\n\n    qemu_opts_del(opts);\n\n    g_free(buf);\n\n    return 0;\n\n\n\nerr:\n\n    aio_set_fd_handler(bdrv_get_aio_context(bs), s->fd,\n\n                       false, NULL, NULL, NULL, NULL);\n\n    closesocket(s->fd);\n\nerr_no_fd:\n\n    qemu_opts_del(opts);\n\n    g_free(buf);\n\n    return ret;\n\n}\n", "idx": 27145}
{"project": "qemu", "commit_id": "6cec5487990bf3f1f22b3fcb871978255e92ae0d", "target": 1, "func": "static void pixel_format_message (VncState *vs) {\n\n    char pad[3] = { 0, 0, 0 };\n\n\n\n    vnc_write_u8(vs, vs->depth * 8); /* bits-per-pixel */\n\n    if (vs->depth == 4) vnc_write_u8(vs, 24); /* depth */\n\n    else vnc_write_u8(vs, vs->depth * 8); /* depth */\n\n\n\n#ifdef WORDS_BIGENDIAN\n\n    vnc_write_u8(vs, 1);             /* big-endian-flag */\n\n#else\n\n    vnc_write_u8(vs, 0);             /* big-endian-flag */\n\n#endif\n\n    vnc_write_u8(vs, 1);             /* true-color-flag */\n\n    if (vs->depth == 4) {\n\n        vnc_write_u16(vs, 0xFF);     /* red-max */\n\n        vnc_write_u16(vs, 0xFF);     /* green-max */\n\n        vnc_write_u16(vs, 0xFF);     /* blue-max */\n\n        vnc_write_u8(vs, 16);        /* red-shift */\n\n        vnc_write_u8(vs, 8);         /* green-shift */\n\n        vnc_write_u8(vs, 0);         /* blue-shift */\n\n        vs->send_hextile_tile = send_hextile_tile_32;\n\n    } else if (vs->depth == 2) {\n\n        vnc_write_u16(vs, 31);       /* red-max */\n\n        vnc_write_u16(vs, 63);       /* green-max */\n\n        vnc_write_u16(vs, 31);       /* blue-max */\n\n        vnc_write_u8(vs, 11);        /* red-shift */\n\n        vnc_write_u8(vs, 5);         /* green-shift */\n\n        vnc_write_u8(vs, 0);         /* blue-shift */\n\n        vs->send_hextile_tile = send_hextile_tile_16;\n\n    } else if (vs->depth == 1) {\n\n        /* XXX: change QEMU pixel 8 bit pixel format to match the VNC one ? */\n\n        vnc_write_u16(vs, 7);        /* red-max */\n\n        vnc_write_u16(vs, 7);        /* green-max */\n\n        vnc_write_u16(vs, 3);        /* blue-max */\n\n        vnc_write_u8(vs, 5);         /* red-shift */\n\n        vnc_write_u8(vs, 2);         /* green-shift */\n\n        vnc_write_u8(vs, 0);         /* blue-shift */\n\n        vs->send_hextile_tile = send_hextile_tile_8;\n\n    }\n\n    vs->client_red_max = vs->server_red_max;\n\n    vs->client_green_max = vs->server_green_max;\n\n    vs->client_blue_max = vs->server_blue_max;\n\n    vs->client_red_shift = vs->server_red_shift;\n\n    vs->client_green_shift = vs->server_green_shift;\n\n    vs->client_blue_shift = vs->server_blue_shift;\n\n    vs->pix_bpp = vs->depth * 8;\n\n    vs->write_pixels = vnc_write_pixels_copy;\n\n\n\n    vnc_write(vs, pad, 3);           /* padding */\n\n}\n", "idx": 27146}
{"project": "qemu", "commit_id": "80e1eea37a25a7696137e680285e36d0bfdc9f34", "target": 1, "func": "static void pci_hotplug(void)\n\n{\n\n    QVirtioPCIDevice *dev;\n\n    QOSState *qs;\n\n    const char *arch = qtest_get_arch();\n\n\n\n    qs = pci_test_start();\n\n\n\n    /* plug secondary disk */\n\n    qpci_plug_device_test(\"virtio-blk-pci\", \"drv1\", PCI_SLOT_HP,\n\n                          \"'drive': 'drive1'\");\n\n\n\n    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);\n\n    g_assert(dev);\n\n    qvirtio_pci_device_disable(dev);\n\n    g_free(dev);\n\n\n\n    /* unplug secondary disk */\n\n    if (strcmp(arch, \"i386\") == 0 || strcmp(arch, \"x86_64\") == 0) {\n\n        qpci_unplug_acpi_device_test(\"drv1\", PCI_SLOT_HP);\n\n    }\n\n    qtest_shutdown(qs);\n\n}\n", "idx": 27148}
{"project": "qemu", "commit_id": "1c02e2a17104fe7fc11893125864dc0daf1e6d5b", "target": 1, "func": "static int load_refcount_block(BlockDriverState *bs,\n\n                               int64_t refcount_block_offset)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int ret;\n\n\n\n    if (cache_refcount_updates) {\n\n        ret = write_refcount_block(bs);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_LOAD);\n\n    ret = bdrv_pread(bs->file, refcount_block_offset, s->refcount_block_cache,\n\n                     s->cluster_size);\n\n    if (ret < 0) {\n\n\n        return ret;\n\n    }\n\n\n\n    s->refcount_block_cache_offset = refcount_block_offset;\n\n    return 0;\n\n}", "idx": 27149}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "void qemu_coroutine_enter(Coroutine *co, void *opaque)\n\n{\n\n    Coroutine *self = qemu_coroutine_self();\n\n    CoroutineAction ret;\n\n\n\n    trace_qemu_coroutine_enter(self, co, opaque);\n\n\n\n    if (co->caller) {\n\n        fprintf(stderr, \"Co-routine re-entered recursively\\n\");\n\n        abort();\n\n    }\n\n\n\n    co->caller = self;\n\n    co->entry_arg = opaque;\n\n    ret = qemu_coroutine_switch(self, co, COROUTINE_ENTER);\n\n\n\n    qemu_co_queue_run_restart(co);\n\n\n\n    switch (ret) {\n\n    case COROUTINE_YIELD:\n\n        return;\n\n    case COROUTINE_TERMINATE:\n\n        trace_qemu_coroutine_terminate(co);\n\n        coroutine_delete(co);\n\n        return;\n\n    default:\n\n        abort();\n\n    }\n\n}\n", "idx": 27150}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "static void div64(uint64_t *plow, uint64_t *phigh, uint64_t b)\n\n{\n\n    uint64_t q, r, a1, a0;\n\n    int i, qb;\n\n\n\n    a0 = *plow;\n\n    a1 = *phigh;\n\n    if (a1 == 0) {\n\n        q = a0 / b;\n\n        r = a0 % b;\n\n        *plow = q;\n\n        *phigh = r;\n\n    } else {\n\n        /* XXX: use a better algorithm */\n\n        for(i = 0; i < 64; i++) {\n\n            a1 = (a1 << 1) | (a0 >> 63);\n\n            if (a1 >= b) {\n\n                a1 -= b;\n\n                qb = 1;\n\n            } else {\n\n                qb = 0;\n\n            }\n\n            a0 = (a0 << 1) | qb;\n\n        }\n\n#if defined(DEBUG_MULDIV)\n\n        printf(\"div: 0x%016llx%016llx / 0x%016llx: q=0x%016llx r=0x%016llx\\n\",\n\n               *phigh, *plow, b, a0, a1);\n\n#endif\n\n        *plow = a0;\n\n        *phigh = a1;\n\n    }\n\n}\n", "idx": 27155}
{"project": "qemu", "commit_id": "ea375f9ab8c76686dca0af8cb4f87a4eb569cad3", "target": 1, "func": "static void cpu_pre_save(void *opaque)\n\n{\n\n    CPUState *env = opaque;\n\n    int i;\n\n\n\n    cpu_synchronize_state(env);\n\n\n\n    /* FPU */\n\n    env->fpus_vmstate = (env->fpus & ~0x3800) | (env->fpstt & 0x7) << 11;\n\n    env->fptag_vmstate = 0;\n\n    for(i = 0; i < 8; i++) {\n\n        env->fptag_vmstate |= ((!env->fptags[i]) << i);\n\n    }\n\n\n\n#ifdef USE_X86LDOUBLE\n\n    env->fpregs_format_vmstate = 0;\n\n#else\n\n    env->fpregs_format_vmstate = 1;\n\n#endif\n\n}\n", "idx": 27160}
{"project": "qemu", "commit_id": "d87576e38df760ef1cb635197d51f207e2a8eda9", "target": 1, "func": "static uint64_t ich_elrsr_read(CPUARMState *env, const ARMCPRegInfo *ri)\n\n{\n\n    GICv3CPUState *cs = icc_cs_from_env(env);\n\n    uint64_t value = 0;\n\n    int i;\n\n\n\n    for (i = 0; i < cs->num_list_regs; i++) {\n\n        uint64_t lr = cs->ich_lr_el2[i];\n\n\n\n        if ((lr & ICH_LR_EL2_STATE_MASK) == 0 &&\n\n            ((lr & ICH_LR_EL2_HW) == 1 || (lr & ICH_LR_EL2_EOI) == 0)) {\n\n            value |= (1 << i);\n\n        }\n\n    }\n\n\n\n    trace_gicv3_ich_elrsr_read(gicv3_redist_affid(cs), value);\n\n    return value;\n\n}\n", "idx": 27161}
{"project": "qemu", "commit_id": "72f0d0bf51362011c4d841a89fb8f5cfb16e0bf3", "target": 1, "func": "static int mp_user_removexattr(FsContext *ctx,\n\n                               const char *path, const char *name)\n\n{\n\n    char *buffer;\n\n    int ret;\n\n\n\n    if (strncmp(name, \"user.virtfs.\", 12) == 0) {\n\n        /*\n\n         * Don't allow fetch of user.virtfs namesapce\n\n         * in case of mapped security\n\n         */\n\n        errno = EACCES;\n\n        return -1;\n\n    }\n\n    buffer = rpath(ctx, path);\n\n    ret = lremovexattr(buffer, name);\n\n    g_free(buffer);\n\n    return ret;\n\n}\n", "idx": 27162}
{"project": "qemu", "commit_id": "5f5a1318653c08e435cfa52f60b6a712815b659d", "target": 1, "func": "void virtio_config_writel(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n\n{\n\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n\n    uint32_t val = data;\n\n\n\n    if (addr > (vdev->config_len - sizeof(val)))\n\n        return;\n\n\n\n    stl_p(vdev->config + addr, val);\n\n\n\n    if (k->set_config) {\n\n        k->set_config(vdev, vdev->config);\n\n    }\n\n}\n", "idx": 27166}
{"project": "qemu", "commit_id": "b20e61e0d52eef57cf5db55087b16e0b5207e730", "target": 1, "func": "int bdrv_open_image(BlockDriverState **pbs, const char *filename,\n\n                    QDict *options, const char *bdref_key, int flags,\n\n                    bool allow_none, Error **errp)\n\n{\n\n    QDict *image_options;\n\n    int ret;\n\n    char *bdref_key_dot;\n\n    const char *reference;\n\n\n\n    assert(pbs);\n\n    assert(*pbs == NULL);\n\n\n\n    bdref_key_dot = g_strdup_printf(\"%s.\", bdref_key);\n\n    qdict_extract_subqdict(options, &image_options, bdref_key_dot);\n\n    g_free(bdref_key_dot);\n\n\n\n    reference = qdict_get_try_str(options, bdref_key);\n\n    if (!filename && !reference && !qdict_size(image_options)) {\n\n        if (allow_none) {\n\n            ret = 0;\n\n        } else {\n\n            error_setg(errp, \"A block device must be specified for \\\"%s\\\"\",\n\n                       bdref_key);\n\n            ret = -EINVAL;\n\n        }\n\n\n        goto done;\n\n    }\n\n\n\n    ret = bdrv_open(pbs, filename, reference, image_options, flags, NULL, errp);\n\n\n\ndone:\n\n    qdict_del(options, bdref_key);\n\n    return ret;\n\n}", "idx": 27167}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void musb_packet(MUSBState *s, MUSBEndPoint *ep,\n\n                int epnum, int pid, int len, USBCallback cb, int dir)\n\n{\n\n    int ret;\n\n    int idx = epnum && dir;\n\n    int ttype;\n\n\n\n    /* ep->type[0,1] contains:\n\n     * in bits 7:6 the speed (0 - invalid, 1 - high, 2 - full, 3 - slow)\n\n     * in bits 5:4 the transfer type (BULK / INT)\n\n     * in bits 3:0 the EP num\n\n     */\n\n    ttype = epnum ? (ep->type[idx] >> 4) & 3 : 0;\n\n\n\n    ep->timeout[dir] = musb_timeout(ttype,\n\n                    ep->type[idx] >> 6, ep->interval[idx]);\n\n    ep->interrupt[dir] = ttype == USB_ENDPOINT_XFER_INT;\n\n    ep->delayed_cb[dir] = cb;\n\n\n\n    ep->packey[dir].p.pid = pid;\n\n    /* A wild guess on the FADDR semantics... */\n\n    ep->packey[dir].p.devaddr = ep->faddr[idx];\n\n    ep->packey[dir].p.devep = ep->type[idx] & 0xf;\n\n    ep->packey[dir].p.data = (void *) ep->buf[idx];\n\n    ep->packey[dir].p.len = len;\n\n    ep->packey[dir].ep = ep;\n\n    ep->packey[dir].dir = dir;\n\n\n\n    if (s->port.dev)\n\n        ret = usb_handle_packet(s->port.dev, &ep->packey[dir].p);\n\n    else\n\n        ret = USB_RET_NODEV;\n\n\n\n    if (ret == USB_RET_ASYNC) {\n\n        ep->status[dir] = len;\n\n        return;\n\n    }\n\n\n\n    ep->status[dir] = ret;\n\n    musb_schedule_cb(&s->port, &ep->packey[dir].p);\n\n}\n", "idx": 27168}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "int gen_intermediate_code_internal (CPUState *env, TranslationBlock *tb,\n\n                                    int search_pc)\n\n{\n\n    DisasContext ctx, *ctxp = &ctx;\n\n    opc_handler_t **table, *handler;\n\n    target_ulong pc_start;\n\n    uint16_t *gen_opc_end;\n\n    int j, lj = -1;\n\n\n\n    pc_start = tb->pc;\n\n    gen_opc_ptr = gen_opc_buf;\n\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n    gen_opparam_ptr = gen_opparam_buf;\n\n    nb_gen_labels = 0;\n\n    ctx.nip = pc_start;\n\n    ctx.tb = tb;\n\n    ctx.exception = EXCP_NONE;\n\n    ctx.spr_cb = env->spr_cb;\n\n#if defined(CONFIG_USER_ONLY)\n\n    ctx.mem_idx = msr_le;\n\n#else\n\n    ctx.supervisor = 1 - msr_pr;\n\n    ctx.mem_idx = ((1 - msr_pr) << 1) | msr_le;\n\n#endif\n\n    ctx.fpu_enabled = msr_fp;\n\n    ctx.singlestep_enabled = env->singlestep_enabled;\n\n#if defined (DO_SINGLE_STEP) && 0\n\n    /* Single step trace mode */\n\n    msr_se = 1;\n\n#endif\n\n    /* Set env in case of segfault during code fetch */\n\n    while (ctx.exception == EXCP_NONE && gen_opc_ptr < gen_opc_end) {\n\n        if (unlikely(env->nb_breakpoints > 0)) {\n\n            for (j = 0; j < env->nb_breakpoints; j++) {\n\n                if (env->breakpoints[j] == ctx.nip) {\n\n                    gen_op_update_nip(ctx.nip); \n\n                    gen_op_debug();\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (unlikely(search_pc)) {\n\n            j = gen_opc_ptr - gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    gen_opc_instr_start[lj++] = 0;\n\n                gen_opc_pc[lj] = ctx.nip;\n\n                gen_opc_instr_start[lj] = 1;\n\n            }\n\n        }\n\n#if defined PPC_DEBUG_DISAS\n\n        if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n            fprintf(logfile, \"----------------\\n\");\n\n            fprintf(logfile, \"nip=%08x super=%d ir=%d\\n\",\n\n                    ctx.nip, 1 - msr_pr, msr_ir);\n\n        }\n\n#endif\n\n        ctx.opcode = ldl_code(ctx.nip);\n\n        if (msr_le) {\n\n            ctx.opcode = ((ctx.opcode & 0xFF000000) >> 24) |\n\n                ((ctx.opcode & 0x00FF0000) >> 8) |\n\n                ((ctx.opcode & 0x0000FF00) << 8) |\n\n                ((ctx.opcode & 0x000000FF) << 24);\n\n        }\n\n#if defined PPC_DEBUG_DISAS\n\n        if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n            fprintf(logfile, \"translate opcode %08x (%02x %02x %02x) (%s)\\n\",\n\n                    ctx.opcode, opc1(ctx.opcode), opc2(ctx.opcode),\n\n                    opc3(ctx.opcode), msr_le ? \"little\" : \"big\");\n\n        }\n\n#endif\n\n        ctx.nip += 4;\n\n        table = env->opcodes;\n\n        handler = table[opc1(ctx.opcode)];\n\n        if (is_indirect_opcode(handler)) {\n\n            table = ind_table(handler);\n\n            handler = table[opc2(ctx.opcode)];\n\n            if (is_indirect_opcode(handler)) {\n\n                table = ind_table(handler);\n\n                handler = table[opc3(ctx.opcode)];\n\n            }\n\n        }\n\n        /* Is opcode *REALLY* valid ? */\n\n        if (unlikely(handler->handler == &gen_invalid)) {\n\n            if (loglevel > 0) {\n\n                fprintf(logfile, \"invalid/unsupported opcode: \"\n\n                        \"%02x - %02x - %02x (%08x) 0x%08x %d\\n\",\n\n                        opc1(ctx.opcode), opc2(ctx.opcode),\n\n                        opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, msr_ir);\n\n            } else {\n\n                printf(\"invalid/unsupported opcode: \"\n\n                       \"%02x - %02x - %02x (%08x) 0x%08x %d\\n\",\n\n                       opc1(ctx.opcode), opc2(ctx.opcode),\n\n                       opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, msr_ir);\n\n            }\n\n        } else {\n\n            if (unlikely((ctx.opcode & handler->inval) != 0)) {\n\n                if (loglevel > 0) {\n\n                    fprintf(logfile, \"invalid bits: %08x for opcode: \"\n\n                            \"%02x -%02x - %02x (0x%08x) (0x%08x)\\n\",\n\n                            ctx.opcode & handler->inval, opc1(ctx.opcode),\n\n                            opc2(ctx.opcode), opc3(ctx.opcode),\n\n                            ctx.opcode, ctx.nip - 4);\n\n                } else {\n\n                    printf(\"invalid bits: %08x for opcode: \"\n\n                           \"%02x -%02x - %02x (0x%08x) (0x%08x)\\n\",\n\n                           ctx.opcode & handler->inval, opc1(ctx.opcode),\n\n                           opc2(ctx.opcode), opc3(ctx.opcode),\n\n                           ctx.opcode, ctx.nip - 4);\n\n                }\n\n                RET_INVAL(ctxp);\n\n                break;\n\n            }\n\n        }\n\n        (*(handler->handler))(&ctx);\n\n#if defined(DO_PPC_STATISTICS)\n\n        handler->count++;\n\n#endif\n\n        /* Check trace mode exceptions */\n\n        if (unlikely((msr_be && ctx.exception == EXCP_BRANCH) ||\n\n                     /* Check in single step trace mode\n\n                      * we need to stop except if:\n\n                      * - rfi, trap or syscall\n\n                      * - first instruction of an exception handler\n\n                      */\n\n                     (msr_se && (ctx.nip < 0x100 ||\n\n                                 ctx.nip > 0xF00 ||\n\n                                 (ctx.nip & 0xFC) != 0x04) &&\n\n                      ctx.exception != EXCP_SYSCALL &&\n\n                      ctx.exception != EXCP_SYSCALL_USER &&\n\n                      ctx.exception != EXCP_TRAP))) {\n\n            RET_EXCP(ctxp, EXCP_TRACE, 0);\n\n        }\n\n        /* if we reach a page boundary or are single stepping, stop\n\n         * generation\n\n         */\n\n        if (unlikely(((ctx.nip & (TARGET_PAGE_SIZE - 1)) == 0) ||\n\n                     (env->singlestep_enabled))) {\n\n            break;\n\n        }\n\n#if defined (DO_SINGLE_STEP)\n\n        break;\n\n#endif\n\n    }\n\n    if (ctx.exception == EXCP_NONE) {\n\n        gen_goto_tb(&ctx, 0, ctx.nip);\n\n    } else if (ctx.exception != EXCP_BRANCH) {\n\n        gen_op_reset_T0();\n\n        /* Generate the return instruction */\n\n        gen_op_exit_tb();\n\n    }\n\n    *gen_opc_ptr = INDEX_op_end;\n\n    if (unlikely(search_pc)) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n        tb->size = 0;\n\n    } else {\n\n        tb->size = ctx.nip - pc_start;\n\n    }\n\n#ifdef DEBUG_DISAS\n\n    if (loglevel & CPU_LOG_TB_CPU) {\n\n        fprintf(logfile, \"---------------- excp: %04x\\n\", ctx.exception);\n\n        cpu_dump_state(env, logfile, fprintf, 0);\n\n    }\n\n    if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n        int flags;\n\n        flags = msr_le;\n\n        fprintf(logfile, \"IN: %s\\n\", lookup_symbol(pc_start));\n\n        target_disas(logfile, pc_start, ctx.nip - pc_start, flags);\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n    if (loglevel & CPU_LOG_TB_OP) {\n\n        fprintf(logfile, \"OP:\\n\");\n\n        dump_ops(gen_opc_buf, gen_opparam_buf);\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 27169}
{"project": "qemu", "commit_id": "0b5538c300a56c3cfb33022840fe0b4968147e7a", "target": 1, "func": "bool st_set_trace_file(const char *file)\n\n{\n\n    st_set_trace_file_enabled(false);\n\n\n\n    free(trace_file_name);\n\n\n\n    if (!file) {\n\n        if (asprintf(&trace_file_name, CONFIG_TRACE_FILE, getpid()) < 0) {\n\n            trace_file_name = NULL;\n\n            return false;\n\n        }\n\n    } else {\n\n        if (asprintf(&trace_file_name, \"%s\", file) < 0) {\n\n            trace_file_name = NULL;\n\n            return false;\n\n        }\n\n    }\n\n\n\n    st_set_trace_file_enabled(true);\n\n    return true;\n\n}\n", "idx": 27170}
{"project": "qemu", "commit_id": "2c8f86961b6eaac705be21bc98299f5517eb0b6b", "target": 1, "func": "static void test_ide_drive_cd_0(void)\n\n{\n\n    char *argv[256];\n\n    int argc, ide_idx;\n\n    Backend i;\n\n\n\n    argc = setup_common(argv, ARRAY_SIZE(argv));\n\n    for (i = 0; i <= backend_empty; i++) {\n\n        ide_idx = backend_empty - i;\n\n        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];\n\n        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),\n\n                         ide_idx, NULL, i, mbr_blank, \"\");\n\n    }\n\n    qtest_start(g_strjoinv(\" \", argv));\n\n    test_cmos();\n\n    qtest_end();\n\n}\n", "idx": 27171}
{"project": "qemu", "commit_id": "a01672d3968cf91208666d371784110bfde9d4f8", "target": 1, "func": "static int kvm_client_migration_log(struct CPUPhysMemoryClient *client,\n\n                                    int enable)\n\n{\n\n    return kvm_set_migration_log(enable);\n\n}\n", "idx": 27172}
{"project": "qemu", "commit_id": "0ec7b534821c8b287317f97cd98ee3f908bd3839", "target": 0, "func": "static int poll_rest(gboolean poll_msgs, HANDLE *handles, gint nhandles,\n\n                     GPollFD *fds, guint nfds, gint timeout)\n\n{\n\n    DWORD ready;\n\n    GPollFD *f;\n\n    int recursed_result;\n\n\n\n    if (poll_msgs) {\n\n        /* Wait for either messages or handles\n\n         * -> Use MsgWaitForMultipleObjectsEx\n\n         */\n\n        ready = MsgWaitForMultipleObjectsEx(nhandles, handles, timeout,\n\n                                            QS_ALLINPUT, MWMO_ALERTABLE);\n\n\n\n        if (ready == WAIT_FAILED) {\n\n            gchar *emsg = g_win32_error_message(GetLastError());\n\n            g_warning(\"MsgWaitForMultipleObjectsEx failed: %s\", emsg);\n\n            g_free(emsg);\n\n        }\n\n    } else if (nhandles == 0) {\n\n        /* No handles to wait for, just the timeout */\n\n        if (timeout == INFINITE) {\n\n            ready = WAIT_FAILED;\n\n        } else {\n\n            SleepEx(timeout, TRUE);\n\n            ready = WAIT_TIMEOUT;\n\n        }\n\n    } else {\n\n        /* Wait for just handles\n\n         * -> Use WaitForMultipleObjectsEx\n\n         */\n\n        ready =\n\n            WaitForMultipleObjectsEx(nhandles, handles, FALSE, timeout, TRUE);\n\n        if (ready == WAIT_FAILED) {\n\n            gchar *emsg = g_win32_error_message(GetLastError());\n\n            g_warning(\"WaitForMultipleObjectsEx failed: %s\", emsg);\n\n            g_free(emsg);\n\n        }\n\n    }\n\n\n\n    if (ready == WAIT_FAILED) {\n\n        return -1;\n\n    } else if (ready == WAIT_TIMEOUT || ready == WAIT_IO_COMPLETION) {\n\n        return 0;\n\n    } else if (poll_msgs && ready == WAIT_OBJECT_0 + nhandles) {\n\n        for (f = fds; f < &fds[nfds]; ++f) {\n\n            if (f->fd == G_WIN32_MSG_HANDLE && f->events & G_IO_IN) {\n\n                f->revents |= G_IO_IN;\n\n            }\n\n        }\n\n\n\n        /* If we have a timeout, or no handles to poll, be satisfied\n\n         * with just noticing we have messages waiting.\n\n         */\n\n        if (timeout != 0 || nhandles == 0) {\n\n            return 1;\n\n        }\n\n\n\n        /* If no timeout and handles to poll, recurse to poll them,\n\n         * too.\n\n         */\n\n        recursed_result = poll_rest(FALSE, handles, nhandles, fds, nfds, 0);\n\n        return (recursed_result == -1) ? -1 : 1 + recursed_result;\n\n    } else if (/* QEMU: removed the following unneeded statement which causes\n\n                * a compiler warning: ready >= WAIT_OBJECT_0 && */\n\n               ready < WAIT_OBJECT_0 + nhandles) {\n\n        for (f = fds; f < &fds[nfds]; ++f) {\n\n            if ((HANDLE) f->fd == handles[ready - WAIT_OBJECT_0]) {\n\n                f->revents = f->events;\n\n            }\n\n        }\n\n\n\n        /* If no timeout and polling several handles, recurse to poll\n\n         * the rest of them.\n\n         */\n\n        if (timeout == 0 && nhandles > 1) {\n\n            /* Remove the handle that fired */\n\n            int i;\n\n            if (ready < nhandles - 1) {\n\n                for (i = ready - WAIT_OBJECT_0 + 1; i < nhandles; i++) {\n\n                    handles[i-1] = handles[i];\n\n                }\n\n            }\n\n            nhandles--;\n\n            recursed_result = poll_rest(FALSE, handles, nhandles, fds, nfds, 0);\n\n            return (recursed_result == -1) ? -1 : 1 + recursed_result;\n\n        }\n\n        return 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 27175}
{"project": "qemu", "commit_id": "7a39fe588251ba042c91bf23d53b0ba820bf964c", "target": 0, "func": "int kvm_arch_pre_run(CPUState *env, struct kvm_run *run)\n\n{\n\n    /* Inject NMI */\n\n    if (env->interrupt_request & CPU_INTERRUPT_NMI) {\n\n        env->interrupt_request &= ~CPU_INTERRUPT_NMI;\n\n        DPRINTF(\"injected NMI\\n\");\n\n        kvm_vcpu_ioctl(env, KVM_NMI);\n\n    }\n\n\n\n    if (!kvm_irqchip_in_kernel()) {\n\n        /* Force the VCPU out of its inner loop to process the INIT request */\n\n        if (env->interrupt_request & CPU_INTERRUPT_INIT) {\n\n            env->exit_request = 1;\n\n        }\n\n\n\n        /* Try to inject an interrupt if the guest can accept it */\n\n        if (run->ready_for_interrupt_injection &&\n\n            (env->interrupt_request & CPU_INTERRUPT_HARD) &&\n\n            (env->eflags & IF_MASK)) {\n\n            int irq;\n\n\n\n            env->interrupt_request &= ~CPU_INTERRUPT_HARD;\n\n            irq = cpu_get_pic_interrupt(env);\n\n            if (irq >= 0) {\n\n                struct kvm_interrupt intr;\n\n\n\n                intr.irq = irq;\n\n                /* FIXME: errors */\n\n                DPRINTF(\"injected interrupt %d\\n\", irq);\n\n                kvm_vcpu_ioctl(env, KVM_INTERRUPT, &intr);\n\n            }\n\n        }\n\n\n\n        /* If we have an interrupt but the guest is not ready to receive an\n\n         * interrupt, request an interrupt window exit.  This will\n\n         * cause a return to userspace as soon as the guest is ready to\n\n         * receive interrupts. */\n\n        if ((env->interrupt_request & CPU_INTERRUPT_HARD)) {\n\n            run->request_interrupt_window = 1;\n\n        } else {\n\n            run->request_interrupt_window = 0;\n\n        }\n\n\n\n        DPRINTF(\"setting tpr\\n\");\n\n        run->cr8 = cpu_get_apic_tpr(env->apic_state);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 27176}
{"project": "qemu", "commit_id": "dcb2b9e1003a9179650b44c747faa4e5767ce92b", "target": 0, "func": "static void gen_msync(DisasContext *ctx)\n\n{\n\n    /* interpreted as no-op */\n\n}\n", "idx": 27177}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void nvram_writeb (void *opaque, target_phys_addr_t addr, uint32_t value)\n\n{\n\n    M48t59State *NVRAM = opaque;\n\n\n\n    m48t59_write(NVRAM, addr, value & 0xff);\n\n}\n", "idx": 27178}
{"project": "qemu", "commit_id": "b011f61931f0113b29b7cd7e921dd022e0b04834", "target": 0, "func": "static int json_lexer_feed_char(JSONLexer *lexer, char ch, bool flush)\n\n{\n\n    int char_consumed, new_state;\n\n\n\n    lexer->x++;\n\n    if (ch == '\\n') {\n\n        lexer->x = 0;\n\n        lexer->y++;\n\n    }\n\n\n\n    do {\n\n        new_state = json_lexer[lexer->state][(uint8_t)ch];\n\n        char_consumed = !TERMINAL_NEEDED_LOOKAHEAD(lexer->state, new_state);\n\n        if (char_consumed) {\n\n            qstring_append_chr(lexer->token, ch);\n\n        }\n\n\n\n        switch (new_state) {\n\n        case JSON_OPERATOR:\n\n        case JSON_ESCAPE:\n\n        case JSON_INTEGER:\n\n        case JSON_FLOAT:\n\n        case JSON_KEYWORD:\n\n        case JSON_STRING:\n\n            lexer->emit(lexer, lexer->token, new_state, lexer->x, lexer->y);\n\n        case JSON_SKIP:\n\n            QDECREF(lexer->token);\n\n            lexer->token = qstring_new();\n\n            new_state = IN_START;\n\n            break;\n\n        case IN_ERROR:\n\n            QDECREF(lexer->token);\n\n            lexer->token = qstring_new();\n\n            new_state = IN_START;\n\n            return -EINVAL;\n\n        default:\n\n            break;\n\n        }\n\n        lexer->state = new_state;\n\n    } while (!char_consumed && !flush);\n\n\n\n    /* Do not let a single token grow to an arbitrarily large size,\n\n     * this is a security consideration.\n\n     */\n\n    if (lexer->token->length > MAX_TOKEN_SIZE) {\n\n        lexer->emit(lexer, lexer->token, lexer->state, lexer->x, lexer->y);\n\n        QDECREF(lexer->token);\n\n        lexer->token = qstring_new();\n\n        lexer->state = IN_START;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 27179}
{"project": "qemu", "commit_id": "1f01e50b8330c24714ddca5841fdbb703076b121", "target": 0, "func": "static int coroutine_fn qed_aio_write_alloc(QEDAIOCB *acb, size_t len)\n\n{\n\n    BDRVQEDState *s = acb_to_s(acb);\n\n    int ret;\n\n\n\n    /* Cancel timer when the first allocating request comes in */\n\n    if (s->allocating_acb == NULL) {\n\n        qed_cancel_need_check_timer(s);\n\n    }\n\n\n\n    /* Freeze this request if another allocating write is in progress */\n\n    if (s->allocating_acb != acb || s->allocating_write_reqs_plugged) {\n\n        if (s->allocating_acb != NULL) {\n\n            qemu_co_queue_wait(&s->allocating_write_reqs, NULL);\n\n            assert(s->allocating_acb == NULL);\n\n        }\n\n        s->allocating_acb = acb;\n\n        return -EAGAIN; /* start over with looking up table entries */\n\n    }\n\n\n\n    acb->cur_nclusters = qed_bytes_to_clusters(s,\n\n            qed_offset_into_cluster(s, acb->cur_pos) + len);\n\n    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);\n\n\n\n    if (acb->flags & QED_AIOCB_ZERO) {\n\n        /* Skip ahead if the clusters are already zero */\n\n        if (acb->find_cluster_ret == QED_CLUSTER_ZERO) {\n\n            return 0;\n\n        }\n\n        acb->cur_cluster = 1;\n\n    } else {\n\n        acb->cur_cluster = qed_alloc_clusters(s, acb->cur_nclusters);\n\n    }\n\n\n\n    if (qed_should_set_need_check(s)) {\n\n        s->header.features |= QED_F_NEED_CHECK;\n\n        ret = qed_write_header(s);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    if (!(acb->flags & QED_AIOCB_ZERO)) {\n\n        ret = qed_aio_write_cow(acb);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    return qed_aio_write_l2_update(acb, acb->cur_cluster);\n\n}\n", "idx": 27180}
{"project": "qemu", "commit_id": "d2cb36af2b0040d421b347e6e4e803e07220f78d", "target": 0, "func": "int qcow2_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    QCowSnapshot *new_snapshot_list = NULL;\n\n    QCowSnapshot *old_snapshot_list = NULL;\n\n    QCowSnapshot sn1, *sn = &sn1;\n\n    int i, ret;\n\n    uint64_t *l1_table = NULL;\n\n    int64_t l1_table_offset;\n\n\n\n    if (s->nb_snapshots >= QCOW_MAX_SNAPSHOTS) {\n\n        return -EFBIG;\n\n    }\n\n\n\n    memset(sn, 0, sizeof(*sn));\n\n\n\n    /* Generate an ID */\n\n    find_new_snapshot_id(bs, sn_info->id_str, sizeof(sn_info->id_str));\n\n\n\n    /* Check that the ID is unique */\n\n    if (find_snapshot_by_id_and_name(bs, sn_info->id_str, NULL) >= 0) {\n\n        return -EEXIST;\n\n    }\n\n\n\n    /* Populate sn with passed data */\n\n    sn->id_str = g_strdup(sn_info->id_str);\n\n    sn->name = g_strdup(sn_info->name);\n\n\n\n    sn->disk_size = bs->total_sectors * BDRV_SECTOR_SIZE;\n\n    sn->vm_state_size = sn_info->vm_state_size;\n\n    sn->date_sec = sn_info->date_sec;\n\n    sn->date_nsec = sn_info->date_nsec;\n\n    sn->vm_clock_nsec = sn_info->vm_clock_nsec;\n\n\n\n    /* Allocate the L1 table of the snapshot and copy the current one there. */\n\n    l1_table_offset = qcow2_alloc_clusters(bs, s->l1_size * sizeof(uint64_t));\n\n    if (l1_table_offset < 0) {\n\n        ret = l1_table_offset;\n\n        goto fail;\n\n    }\n\n\n\n    sn->l1_table_offset = l1_table_offset;\n\n    sn->l1_size = s->l1_size;\n\n\n\n    l1_table = g_try_new(uint64_t, s->l1_size);\n\n    if (s->l1_size && l1_table == NULL) {\n\n        ret = -ENOMEM;\n\n        goto fail;\n\n    }\n\n\n\n    for(i = 0; i < s->l1_size; i++) {\n\n        l1_table[i] = cpu_to_be64(s->l1_table[i]);\n\n    }\n\n\n\n    ret = qcow2_pre_write_overlap_check(bs, 0, sn->l1_table_offset,\n\n                                        s->l1_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    ret = bdrv_pwrite(bs->file, sn->l1_table_offset, l1_table,\n\n                      s->l1_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    g_free(l1_table);\n\n    l1_table = NULL;\n\n\n\n    /*\n\n     * Increase the refcounts of all clusters and make sure everything is\n\n     * stable on disk before updating the snapshot table to contain a pointer\n\n     * to the new L1 table.\n\n     */\n\n    ret = qcow2_update_snapshot_refcount(bs, s->l1_table_offset, s->l1_size, 1);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Append the new snapshot to the snapshot list */\n\n    new_snapshot_list = g_new(QCowSnapshot, s->nb_snapshots + 1);\n\n    if (s->snapshots) {\n\n        memcpy(new_snapshot_list, s->snapshots,\n\n               s->nb_snapshots * sizeof(QCowSnapshot));\n\n        old_snapshot_list = s->snapshots;\n\n    }\n\n    s->snapshots = new_snapshot_list;\n\n    s->snapshots[s->nb_snapshots++] = *sn;\n\n\n\n    ret = qcow2_write_snapshots(bs);\n\n    if (ret < 0) {\n\n        g_free(s->snapshots);\n\n        s->snapshots = old_snapshot_list;\n\n        s->nb_snapshots--;\n\n        goto fail;\n\n    }\n\n\n\n    g_free(old_snapshot_list);\n\n\n\n    /* The VM state isn't needed any more in the active L1 table; in fact, it\n\n     * hurts by causing expensive COW for the next snapshot. */\n\n    qcow2_discard_clusters(bs, qcow2_vm_state_offset(s),\n\n                           align_offset(sn->vm_state_size, s->cluster_size)\n\n                                >> BDRV_SECTOR_BITS,\n\n                           QCOW2_DISCARD_NEVER, false);\n\n\n\n#ifdef DEBUG_ALLOC\n\n    {\n\n      BdrvCheckResult result = {0};\n\n      qcow2_check_refcounts(bs, &result, 0);\n\n    }\n\n#endif\n\n    return 0;\n\n\n\nfail:\n\n    g_free(sn->id_str);\n\n    g_free(sn->name);\n\n    g_free(l1_table);\n\n\n\n    return ret;\n\n}\n", "idx": 27181}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "static void superio_ioport_writeb(void *opaque, uint32_t addr, uint32_t data)\n\n{\n\n    int can_write;\n\n    SuperIOConfig *superio_conf = opaque;\n\n\n\n    DPRINTF(\"superio_ioport_writeb  address 0x%x  val 0x%x  \\n\", addr, data);\n\n    if (addr == 0x3f0) {\n\n        superio_conf->index = data & 0xff;\n\n    } else {\n\n        /* 0x3f1 */\n\n        switch (superio_conf->index) {\n\n        case 0x00 ... 0xdf:\n\n        case 0xe4:\n\n        case 0xe5:\n\n        case 0xe9 ... 0xed:\n\n        case 0xf3:\n\n        case 0xf5:\n\n        case 0xf7:\n\n        case 0xf9 ... 0xfb:\n\n        case 0xfd ... 0xff:\n\n            can_write = 0;\n\n            break;\n\n        default:\n\n            can_write = 1;\n\n\n\n            if (can_write) {\n\n                switch (superio_conf->index) {\n\n                case 0xe7:\n\n                    if ((data & 0xff) != 0xfe) {\n\n                        DPRINTF(\"chage uart 1 base. unsupported yet \\n\");\n\n                    }\n\n                    break;\n\n                case 0xe8:\n\n                    if ((data & 0xff) != 0xbe) {\n\n                        DPRINTF(\"chage uart 2 base. unsupported yet \\n\");\n\n                    }\n\n                    break;\n\n\n\n                default:\n\n                    superio_conf->config[superio_conf->index] = data & 0xff;\n\n                }\n\n            }\n\n        }\n\n        superio_conf->config[superio_conf->index] = data & 0xff;\n\n    }\n\n}\n", "idx": 27182}
{"project": "qemu", "commit_id": "bb5fc20f7c1c65e95030da3629dd0d7a0cce38cd", "target": 0, "func": "static void monitor_handle_command1(void *opaque, const char *cmdline)\n\n{\n\n    monitor_handle_command(cmdline);\n\n    if (!monitor_suspended)\n\n        monitor_start_input();\n\n    else\n\n        monitor_suspended = 2;\n\n}\n", "idx": 27184}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "static void do_pci_unregister_device(PCIDevice *pci_dev)\n\n{\n\n    pci_dev->bus->devices[pci_dev->devfn] = NULL;\n\n    pci_config_free(pci_dev);\n\n\n\n    if (memory_region_is_mapped(&pci_dev->bus_master_enable_region)) {\n\n        memory_region_del_subregion(&pci_dev->bus_master_container_region,\n\n                                    &pci_dev->bus_master_enable_region);\n\n    }\n\n    address_space_destroy(&pci_dev->bus_master_as);\n\n}\n", "idx": 27185}
{"project": "qemu", "commit_id": "b6dcbe086c77ec683f5ff0b693593cda1d61f3a1", "target": 0, "func": "CPUState *ppc405cr_init (target_phys_addr_t ram_bases[4],\n\n                         target_phys_addr_t ram_sizes[4],\n\n                         uint32_t sysclk, qemu_irq **picp,\n\n                         int do_init)\n\n{\n\n    clk_setup_t clk_setup[PPC405CR_CLK_NB];\n\n    qemu_irq dma_irqs[4];\n\n    CPUState *env;\n\n    qemu_irq *pic, *irqs;\n\n\n\n    memset(clk_setup, 0, sizeof(clk_setup));\n\n    env = ppc4xx_init(\"405cr\", &clk_setup[PPC405CR_CPU_CLK],\n\n                      &clk_setup[PPC405CR_TMR_CLK], sysclk);\n\n    /* Memory mapped devices registers */\n\n    /* PLB arbitrer */\n\n    ppc4xx_plb_init(env);\n\n    /* PLB to OPB bridge */\n\n    ppc4xx_pob_init(env);\n\n    /* OBP arbitrer */\n\n    ppc4xx_opba_init(0xef600600);\n\n    /* Universal interrupt controller */\n\n    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);\n\n    irqs[PPCUIC_OUTPUT_INT] =\n\n        ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];\n\n    irqs[PPCUIC_OUTPUT_CINT] =\n\n        ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];\n\n    pic = ppcuic_init(env, irqs, 0x0C0, 0, 1);\n\n    *picp = pic;\n\n    /* SDRAM controller */\n\n    ppc4xx_sdram_init(env, pic[14], 1, ram_bases, ram_sizes, do_init);\n\n    /* External bus controller */\n\n    ppc405_ebc_init(env);\n\n    /* DMA controller */\n\n    dma_irqs[0] = pic[26];\n\n    dma_irqs[1] = pic[25];\n\n    dma_irqs[2] = pic[24];\n\n    dma_irqs[3] = pic[23];\n\n    ppc405_dma_init(env, dma_irqs);\n\n    /* Serial ports */\n\n    if (serial_hds[0] != NULL) {\n\n        serial_mm_init(0xef600300, 0, pic[0], PPC_SERIAL_MM_BAUDBASE,\n\n                       serial_hds[0], 1, 1);\n\n    }\n\n    if (serial_hds[1] != NULL) {\n\n        serial_mm_init(0xef600400, 0, pic[1], PPC_SERIAL_MM_BAUDBASE,\n\n                       serial_hds[1], 1, 1);\n\n    }\n\n    /* IIC controller */\n\n    ppc405_i2c_init(0xef600500, pic[2]);\n\n    /* GPIO */\n\n    ppc405_gpio_init(0xef600700);\n\n    /* CPU control */\n\n    ppc405cr_cpc_init(env, clk_setup, sysclk);\n\n\n\n    return env;\n\n}\n", "idx": 27186}
{"project": "qemu", "commit_id": "7e84c2498f0ff3999937d18d1e9abaa030400000", "target": 0, "func": "static inline int load_segment(uint32_t *e1_ptr, uint32_t *e2_ptr,\n\n                               int selector)\n\n{\n\n    SegmentCache *dt;\n\n    int index;\n\n    uint8_t *ptr;\n\n\n\n    if (selector & 0x4)\n\n        dt = &env->ldt;\n\n    else\n\n        dt = &env->gdt;\n\n    index = selector & ~7;\n\n    if ((index + 7) > dt->limit)\n\n        return -1;\n\n    ptr = dt->base + index;\n\n    *e1_ptr = ldl_kernel(ptr);\n\n    *e2_ptr = ldl_kernel(ptr + 4);\n\n    return 0;\n\n}\n", "idx": 27187}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "int nbd_client_session_co_discard(NbdClientSession *client, int64_t sector_num,\n\n    int nb_sectors)\n\n{\n\n    struct nbd_request request = { .type = NBD_CMD_TRIM };\n\n    struct nbd_reply reply;\n\n    ssize_t ret;\n\n\n\n    if (!(client->nbdflags & NBD_FLAG_SEND_TRIM)) {\n\n        return 0;\n\n    }\n\n    request.from = sector_num * 512;\n\n    request.len = nb_sectors * 512;\n\n\n\n    nbd_coroutine_start(client, &request);\n\n    ret = nbd_co_send_request(client, &request, NULL, 0);\n\n    if (ret < 0) {\n\n        reply.error = -ret;\n\n    } else {\n\n        nbd_co_receive_reply(client, &request, &reply, NULL, 0);\n\n    }\n\n    nbd_coroutine_end(client, &request);\n\n    return -reply.error;\n\n\n\n}\n", "idx": 27188}
{"project": "qemu", "commit_id": "d368ba4376b2c1c24175c74b3733b8fe64dbe8a6", "target": 0, "func": "static void sdhci_do_adma(SDHCIState *s)\n\n{\n\n    unsigned int n, begin, length;\n\n    const uint16_t block_size = s->blksize & 0x0fff;\n\n    ADMADescr dscr;\n\n    int i;\n\n\n\n    for (i = 0; i < SDHC_ADMA_DESCS_PER_DELAY; ++i) {\n\n        s->admaerr &= ~SDHC_ADMAERR_LENGTH_MISMATCH;\n\n\n\n        get_adma_description(s, &dscr);\n\n        DPRINT_L2(\"ADMA loop: addr=\" TARGET_FMT_plx \", len=%d, attr=%x\\n\",\n\n                dscr.addr, dscr.length, dscr.attr);\n\n\n\n        if ((dscr.attr & SDHC_ADMA_ATTR_VALID) == 0) {\n\n            /* Indicate that error occurred in ST_FDS state */\n\n            s->admaerr &= ~SDHC_ADMAERR_STATE_MASK;\n\n            s->admaerr |= SDHC_ADMAERR_STATE_ST_FDS;\n\n\n\n            /* Generate ADMA error interrupt */\n\n            if (s->errintstsen & SDHC_EISEN_ADMAERR) {\n\n                s->errintsts |= SDHC_EIS_ADMAERR;\n\n                s->norintsts |= SDHC_NIS_ERR;\n\n            }\n\n\n\n            sdhci_update_irq(s);\n\n            return;\n\n        }\n\n\n\n        length = dscr.length ? dscr.length : 65536;\n\n\n\n        switch (dscr.attr & SDHC_ADMA_ATTR_ACT_MASK) {\n\n        case SDHC_ADMA_ATTR_ACT_TRAN:  /* data transfer */\n\n\n\n            if (s->trnmod & SDHC_TRNS_READ) {\n\n                while (length) {\n\n                    if (s->data_count == 0) {\n\n                        for (n = 0; n < block_size; n++) {\n\n                            s->fifo_buffer[n] = sd_read_data(s->card);\n\n                        }\n\n                    }\n\n                    begin = s->data_count;\n\n                    if ((length + begin) < block_size) {\n\n                        s->data_count = length + begin;\n\n                        length = 0;\n\n                     } else {\n\n                        s->data_count = block_size;\n\n                        length -= block_size - begin;\n\n                    }\n\n                    dma_memory_write(&address_space_memory, dscr.addr,\n\n                                     &s->fifo_buffer[begin],\n\n                                     s->data_count - begin);\n\n                    dscr.addr += s->data_count - begin;\n\n                    if (s->data_count == block_size) {\n\n                        s->data_count = 0;\n\n                        if (s->trnmod & SDHC_TRNS_BLK_CNT_EN) {\n\n                            s->blkcnt--;\n\n                            if (s->blkcnt == 0) {\n\n                                break;\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            } else {\n\n                while (length) {\n\n                    begin = s->data_count;\n\n                    if ((length + begin) < block_size) {\n\n                        s->data_count = length + begin;\n\n                        length = 0;\n\n                     } else {\n\n                        s->data_count = block_size;\n\n                        length -= block_size - begin;\n\n                    }\n\n                    dma_memory_read(&address_space_memory, dscr.addr,\n\n                                    &s->fifo_buffer[begin],\n\n                                    s->data_count - begin);\n\n                    dscr.addr += s->data_count - begin;\n\n                    if (s->data_count == block_size) {\n\n                        for (n = 0; n < block_size; n++) {\n\n                            sd_write_data(s->card, s->fifo_buffer[n]);\n\n                        }\n\n                        s->data_count = 0;\n\n                        if (s->trnmod & SDHC_TRNS_BLK_CNT_EN) {\n\n                            s->blkcnt--;\n\n                            if (s->blkcnt == 0) {\n\n                                break;\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            s->admasysaddr += dscr.incr;\n\n            break;\n\n        case SDHC_ADMA_ATTR_ACT_LINK:   /* link to next descriptor table */\n\n            s->admasysaddr = dscr.addr;\n\n            DPRINT_L1(\"ADMA link: admasysaddr=0x%lx\\n\", s->admasysaddr);\n\n            break;\n\n        default:\n\n            s->admasysaddr += dscr.incr;\n\n            break;\n\n        }\n\n\n\n        if (dscr.attr & SDHC_ADMA_ATTR_INT) {\n\n            DPRINT_L1(\"ADMA interrupt: admasysaddr=0x%lx\\n\", s->admasysaddr);\n\n            if (s->norintstsen & SDHC_NISEN_DMA) {\n\n                s->norintsts |= SDHC_NIS_DMA;\n\n            }\n\n\n\n            sdhci_update_irq(s);\n\n        }\n\n\n\n        /* ADMA transfer terminates if blkcnt == 0 or by END attribute */\n\n        if (((s->trnmod & SDHC_TRNS_BLK_CNT_EN) &&\n\n                    (s->blkcnt == 0)) || (dscr.attr & SDHC_ADMA_ATTR_END)) {\n\n            DPRINT_L2(\"ADMA transfer completed\\n\");\n\n            if (length || ((dscr.attr & SDHC_ADMA_ATTR_END) &&\n\n                (s->trnmod & SDHC_TRNS_BLK_CNT_EN) &&\n\n                s->blkcnt != 0)) {\n\n                ERRPRINT(\"SD/MMC host ADMA length mismatch\\n\");\n\n                s->admaerr |= SDHC_ADMAERR_LENGTH_MISMATCH |\n\n                        SDHC_ADMAERR_STATE_ST_TFR;\n\n                if (s->errintstsen & SDHC_EISEN_ADMAERR) {\n\n                    ERRPRINT(\"Set ADMA error flag\\n\");\n\n                    s->errintsts |= SDHC_EIS_ADMAERR;\n\n                    s->norintsts |= SDHC_NIS_ERR;\n\n                }\n\n\n\n                sdhci_update_irq(s);\n\n            }\n\n            SDHCI_GET_CLASS(s)->end_data_transfer(s);\n\n            return;\n\n        }\n\n\n\n    }\n\n\n\n    /* we have unfinished business - reschedule to continue ADMA */\n\n    timer_mod(s->transfer_timer,\n\n                   qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + SDHC_TRANSFER_DELAY);\n\n}\n", "idx": 27189}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t omap_sysctl_read8(void *opaque, target_phys_addr_t addr)\n\n{\n\n\n\n    struct omap_sysctl_s *s = (struct omap_sysctl_s *) opaque;\n\n    int pad_offset, byte_offset;\n\n    int value;\n\n\n\n    switch (addr) {\n\n    case 0x030 ... 0x140:\t/* CONTROL_PADCONF - only used in the POP */\n\n        pad_offset = (addr - 0x30) >> 2;\n\n        byte_offset = (addr - 0x30) & (4 - 1);\n\n\n\n        value = s->padconf[pad_offset];\n\n        value = (value >> (byte_offset * 8)) & 0xff;\n\n\n\n        return value;\n\n\n\n    default:\n\n        break;\n\n    }\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 27190}
{"project": "qemu", "commit_id": "d0b3e4f5f4a29d48250887e5c0b3c65bc4dc6d13", "target": 0, "func": "abi_ulong mmap_find_vma(abi_ulong start, abi_ulong size)\n\n{\n\n    void *ptr, *prev;\n\n    abi_ulong addr;\n\n    int wrapped, repeat;\n\n\n\n    /* If 'start' == 0, then a default start address is used. */\n\n    if (start == 0) {\n\n        start = mmap_next_start;\n\n    } else {\n\n        start &= qemu_host_page_mask;\n\n    }\n\n\n\n    size = HOST_PAGE_ALIGN(size);\n\n\n\n    if (RESERVED_VA) {\n\n        return mmap_find_vma_reserved(start, size);\n\n    }\n\n\n\n    addr = start;\n\n    wrapped = repeat = 0;\n\n    prev = 0;\n\n\n\n    for (;; prev = ptr) {\n\n        /*\n\n         * Reserve needed memory area to avoid a race.\n\n         * It should be discarded using:\n\n         *  - mmap() with MAP_FIXED flag\n\n         *  - mremap() with MREMAP_FIXED flag\n\n         *  - shmat() with SHM_REMAP flag\n\n         */\n\n        ptr = mmap(g2h(addr), size, PROT_NONE,\n\n                   MAP_ANONYMOUS|MAP_PRIVATE|MAP_NORESERVE, -1, 0);\n\n\n\n        /* ENOMEM, if host address space has no memory */\n\n        if (ptr == MAP_FAILED) {\n\n            return (abi_ulong)-1;\n\n        }\n\n\n\n        /* Count the number of sequential returns of the same address.\n\n           This is used to modify the search algorithm below.  */\n\n        repeat = (ptr == prev ? repeat + 1 : 0);\n\n\n\n        if (h2g_valid(ptr + size - 1)) {\n\n            addr = h2g(ptr);\n\n\n\n            if ((addr & ~TARGET_PAGE_MASK) == 0) {\n\n                /* Success.  */\n\n                if (start == mmap_next_start && addr >= TASK_UNMAPPED_BASE) {\n\n                    mmap_next_start = addr + size;\n\n                }\n\n                return addr;\n\n            }\n\n\n\n            /* The address is not properly aligned for the target.  */\n\n            switch (repeat) {\n\n            case 0:\n\n                /* Assume the result that the kernel gave us is the\n\n                   first with enough free space, so start again at the\n\n                   next higher target page.  */\n\n                addr = TARGET_PAGE_ALIGN(addr);\n\n                break;\n\n            case 1:\n\n                /* Sometimes the kernel decides to perform the allocation\n\n                   at the top end of memory instead.  */\n\n                addr &= TARGET_PAGE_MASK;\n\n                break;\n\n            case 2:\n\n                /* Start over at low memory.  */\n\n                addr = 0;\n\n                break;\n\n            default:\n\n                /* Fail.  This unaligned block must the last.  */\n\n                addr = -1;\n\n                break;\n\n            }\n\n        } else {\n\n            /* Since the result the kernel gave didn't fit, start\n\n               again at low memory.  If any repetition, fail.  */\n\n            addr = (repeat ? -1 : 0);\n\n        }\n\n\n\n        /* Unmap and try again.  */\n\n        munmap(ptr, size);\n\n\n\n        /* ENOMEM if we checked the whole of the target address space.  */\n\n        if (addr == -1ul) {\n\n            return (abi_ulong)-1;\n\n        } else if (addr == 0) {\n\n            if (wrapped) {\n\n                return (abi_ulong)-1;\n\n            }\n\n            wrapped = 1;\n\n            /* Don't actually use 0 when wrapping, instead indicate\n\n               that we'd truely like an allocation in low memory.  */\n\n            addr = (mmap_min_addr > TARGET_PAGE_SIZE\n\n                     ? TARGET_PAGE_ALIGN(mmap_min_addr)\n\n                     : TARGET_PAGE_SIZE);\n\n        } else if (wrapped && addr >= start) {\n\n            return (abi_ulong)-1;\n\n        }\n\n    }\n\n}\n", "idx": 27191}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int do_token_out(USBDevice *s, USBPacket *p)\n\n{\n\n    assert(p->devep == 0);\n\n\n\n    switch(s->setup_state) {\n\n    case SETUP_STATE_ACK:\n\n        if (s->setup_buf[0] & USB_DIR_IN) {\n\n            s->setup_state = SETUP_STATE_IDLE;\n\n            /* transfer OK */\n\n        } else {\n\n            /* ignore additional output */\n\n        }\n\n        return 0;\n\n\n\n    case SETUP_STATE_DATA:\n\n        if (!(s->setup_buf[0] & USB_DIR_IN)) {\n\n            int len = s->setup_len - s->setup_index;\n\n            if (len > p->iov.size) {\n\n                len = p->iov.size;\n\n            }\n\n            usb_packet_copy(p, s->data_buf + s->setup_index, len);\n\n            s->setup_index += len;\n\n            if (s->setup_index >= s->setup_len)\n\n                s->setup_state = SETUP_STATE_ACK;\n\n            return len;\n\n        }\n\n\n\n        s->setup_state = SETUP_STATE_IDLE;\n\n        return USB_RET_STALL;\n\n\n\n    default:\n\n        return USB_RET_STALL;\n\n    }\n\n}\n", "idx": 27192}
{"project": "qemu", "commit_id": "7399a337e4126f7c8c8af3336726f001378c4798", "target": 0, "func": "int page_unprotect(target_ulong address, uintptr_t pc)\n\n{\n\n    unsigned int prot;\n\n    PageDesc *p;\n\n    target_ulong host_start, host_end, addr;\n\n\n\n    /* Technically this isn't safe inside a signal handler.  However we\n\n       know this only ever happens in a synchronous SEGV handler, so in\n\n       practice it seems to be ok.  */\n\n    mmap_lock();\n\n\n\n    p = page_find(address >> TARGET_PAGE_BITS);\n\n    if (!p) {\n\n        mmap_unlock();\n\n        return 0;\n\n    }\n\n\n\n    /* if the page was really writable, then we change its\n\n       protection back to writable */\n\n    if ((p->flags & PAGE_WRITE_ORG) && !(p->flags & PAGE_WRITE)) {\n\n        host_start = address & qemu_host_page_mask;\n\n        host_end = host_start + qemu_host_page_size;\n\n\n\n        prot = 0;\n\n        for (addr = host_start ; addr < host_end ; addr += TARGET_PAGE_SIZE) {\n\n            p = page_find(addr >> TARGET_PAGE_BITS);\n\n            p->flags |= PAGE_WRITE;\n\n            prot |= p->flags;\n\n\n\n            /* and since the content will be modified, we must invalidate\n\n               the corresponding translated code. */\n\n            if (tb_invalidate_phys_page(addr, pc)) {\n\n                mmap_unlock();\n\n                return 2;\n\n            }\n\n#ifdef DEBUG_TB_CHECK\n\n            tb_invalidate_check(addr);\n\n#endif\n\n        }\n\n        mprotect((void *)g2h(host_start), qemu_host_page_size,\n\n                 prot & PAGE_BITS);\n\n\n\n        mmap_unlock();\n\n        return 1;\n\n    }\n\n    mmap_unlock();\n\n    return 0;\n\n}\n", "idx": 27193}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "uint64_t blk_mig_bytes_remaining(void)\n\n{\n\n    return blk_mig_bytes_total() - blk_mig_bytes_transferred();\n\n}\n", "idx": 27196}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void OPPROTO op_srli_T1 (void)\n\n{\n\n    T1 = T1 >> PARAM1;\n\n    RETURN();\n\n}\n", "idx": 27206}
{"project": "qemu", "commit_id": "5923f85fb82df7c8c60a89458a5ae856045e5ab1", "target": 1, "func": "static void qobject_output_type_uint64(Visitor *v, const char *name,\n\n                                       uint64_t *obj, Error **errp)\n\n{\n\n    /* FIXME values larger than INT64_MAX become negative */\n\n    QObjectOutputVisitor *qov = to_qov(v);\n\n    qobject_output_add(qov, name, qnum_from_int(*obj));\n\n}\n", "idx": 27209}
{"project": "qemu", "commit_id": "e3d142d073d02f0a3a4aad79eb838c15b6f99c01", "target": 1, "func": "float64 float64_muladd(float64 a, float64 b, float64 c, int flags STATUS_PARAM)\n\n{\n\n    flag aSign, bSign, cSign, zSign;\n\n    int_fast16_t aExp, bExp, cExp, pExp, zExp, expDiff;\n\n    uint64_t aSig, bSig, cSig;\n\n    flag pInf, pZero, pSign;\n\n    uint64_t pSig0, pSig1, cSig0, cSig1, zSig0, zSig1;\n\n    int shiftcount;\n\n    flag signflip, infzero;\n\n\n\n    a = float64_squash_input_denormal(a STATUS_VAR);\n\n    b = float64_squash_input_denormal(b STATUS_VAR);\n\n    c = float64_squash_input_denormal(c STATUS_VAR);\n\n    aSig = extractFloat64Frac(a);\n\n    aExp = extractFloat64Exp(a);\n\n    aSign = extractFloat64Sign(a);\n\n    bSig = extractFloat64Frac(b);\n\n    bExp = extractFloat64Exp(b);\n\n    bSign = extractFloat64Sign(b);\n\n    cSig = extractFloat64Frac(c);\n\n    cExp = extractFloat64Exp(c);\n\n    cSign = extractFloat64Sign(c);\n\n\n\n    infzero = ((aExp == 0 && aSig == 0 && bExp == 0x7ff && bSig == 0) ||\n\n               (aExp == 0x7ff && aSig == 0 && bExp == 0 && bSig == 0));\n\n\n\n    /* It is implementation-defined whether the cases of (0,inf,qnan)\n\n     * and (inf,0,qnan) raise InvalidOperation or not (and what QNaN\n\n     * they return if they do), so we have to hand this information\n\n     * off to the target-specific pick-a-NaN routine.\n\n     */\n\n    if (((aExp == 0x7ff) && aSig) ||\n\n        ((bExp == 0x7ff) && bSig) ||\n\n        ((cExp == 0x7ff) && cSig)) {\n\n        return propagateFloat64MulAddNaN(a, b, c, infzero STATUS_VAR);\n\n    }\n\n\n\n    if (infzero) {\n\n        float_raise(float_flag_invalid STATUS_VAR);\n\n        return float64_default_nan;\n\n    }\n\n\n\n    if (flags & float_muladd_negate_c) {\n\n        cSign ^= 1;\n\n    }\n\n\n\n    signflip = (flags & float_muladd_negate_result) ? 1 : 0;\n\n\n\n    /* Work out the sign and type of the product */\n\n    pSign = aSign ^ bSign;\n\n    if (flags & float_muladd_negate_product) {\n\n        pSign ^= 1;\n\n    }\n\n    pInf = (aExp == 0x7ff) || (bExp == 0x7ff);\n\n    pZero = ((aExp | aSig) == 0) || ((bExp | bSig) == 0);\n\n\n\n    if (cExp == 0x7ff) {\n\n        if (pInf && (pSign ^ cSign)) {\n\n            /* addition of opposite-signed infinities => InvalidOperation */\n\n            float_raise(float_flag_invalid STATUS_VAR);\n\n            return float64_default_nan;\n\n        }\n\n        /* Otherwise generate an infinity of the same sign */\n\n        return packFloat64(cSign ^ signflip, 0x7ff, 0);\n\n    }\n\n\n\n    if (pInf) {\n\n        return packFloat64(pSign ^ signflip, 0x7ff, 0);\n\n    }\n\n\n\n    if (pZero) {\n\n        if (cExp == 0) {\n\n            if (cSig == 0) {\n\n                /* Adding two exact zeroes */\n\n                if (pSign == cSign) {\n\n                    zSign = pSign;\n\n                } else if (STATUS(float_rounding_mode) == float_round_down) {\n\n                    zSign = 1;\n\n                } else {\n\n                    zSign = 0;\n\n                }\n\n                return packFloat64(zSign ^ signflip, 0, 0);\n\n            }\n\n            /* Exact zero plus a denorm */\n\n            if (STATUS(flush_to_zero)) {\n\n                float_raise(float_flag_output_denormal STATUS_VAR);\n\n                return packFloat64(cSign ^ signflip, 0, 0);\n\n            }\n\n        }\n\n        /* Zero plus something non-zero : just return the something */\n\n        return packFloat64(cSign ^ signflip, cExp, cSig);\n\n    }\n\n\n\n    if (aExp == 0) {\n\n        normalizeFloat64Subnormal(aSig, &aExp, &aSig);\n\n    }\n\n    if (bExp == 0) {\n\n        normalizeFloat64Subnormal(bSig, &bExp, &bSig);\n\n    }\n\n\n\n    /* Calculate the actual result a * b + c */\n\n\n\n    /* Multiply first; this is easy. */\n\n    /* NB: we subtract 0x3fe where float64_mul() subtracts 0x3ff\n\n     * because we want the true exponent, not the \"one-less-than\"\n\n     * flavour that roundAndPackFloat64() takes.\n\n     */\n\n    pExp = aExp + bExp - 0x3fe;\n\n    aSig = (aSig | LIT64(0x0010000000000000))<<10;\n\n    bSig = (bSig | LIT64(0x0010000000000000))<<11;\n\n    mul64To128(aSig, bSig, &pSig0, &pSig1);\n\n    if ((int64_t)(pSig0 << 1) >= 0) {\n\n        shortShift128Left(pSig0, pSig1, 1, &pSig0, &pSig1);\n\n        pExp--;\n\n    }\n\n\n\n    zSign = pSign ^ signflip;\n\n\n\n    /* Now [pSig0:pSig1] is the significand of the multiply, with the explicit\n\n     * bit in position 126.\n\n     */\n\n    if (cExp == 0) {\n\n        if (!cSig) {\n\n            /* Throw out the special case of c being an exact zero now */\n\n            shift128RightJamming(pSig0, pSig1, 64, &pSig0, &pSig1);\n\n            return roundAndPackFloat64(zSign, pExp - 1,\n\n                                       pSig1 STATUS_VAR);\n\n        }\n\n        normalizeFloat64Subnormal(cSig, &cExp, &cSig);\n\n    }\n\n\n\n    /* Shift cSig and add the explicit bit so [cSig0:cSig1] is the\n\n     * significand of the addend, with the explicit bit in position 126.\n\n     */\n\n    cSig0 = cSig << (126 - 64 - 52);\n\n    cSig1 = 0;\n\n    cSig0 |= LIT64(0x4000000000000000);\n\n    expDiff = pExp - cExp;\n\n\n\n    if (pSign == cSign) {\n\n        /* Addition */\n\n        if (expDiff > 0) {\n\n            /* scale c to match p */\n\n            shift128RightJamming(cSig0, cSig1, expDiff, &cSig0, &cSig1);\n\n            zExp = pExp;\n\n        } else if (expDiff < 0) {\n\n            /* scale p to match c */\n\n            shift128RightJamming(pSig0, pSig1, -expDiff, &pSig0, &pSig1);\n\n            zExp = cExp;\n\n        } else {\n\n            /* no scaling needed */\n\n            zExp = cExp;\n\n        }\n\n        /* Add significands and make sure explicit bit ends up in posn 126 */\n\n        add128(pSig0, pSig1, cSig0, cSig1, &zSig0, &zSig1);\n\n        if ((int64_t)zSig0 < 0) {\n\n            shift128RightJamming(zSig0, zSig1, 1, &zSig0, &zSig1);\n\n        } else {\n\n            zExp--;\n\n        }\n\n        shift128RightJamming(zSig0, zSig1, 64, &zSig0, &zSig1);\n\n        return roundAndPackFloat64(zSign, zExp, zSig1 STATUS_VAR);\n\n    } else {\n\n        /* Subtraction */\n\n        if (expDiff > 0) {\n\n            shift128RightJamming(cSig0, cSig1, expDiff, &cSig0, &cSig1);\n\n            sub128(pSig0, pSig1, cSig0, cSig1, &zSig0, &zSig1);\n\n            zExp = pExp;\n\n        } else if (expDiff < 0) {\n\n            shift128RightJamming(pSig0, pSig1, -expDiff, &pSig0, &pSig1);\n\n            sub128(cSig0, cSig1, pSig0, pSig1, &zSig0, &zSig1);\n\n            zExp = cExp;\n\n            zSign ^= 1;\n\n        } else {\n\n            zExp = pExp;\n\n            if (lt128(cSig0, cSig1, pSig0, pSig1)) {\n\n                sub128(pSig0, pSig1, cSig0, cSig1, &zSig0, &zSig1);\n\n            } else if (lt128(pSig0, pSig1, cSig0, cSig1)) {\n\n                sub128(cSig0, cSig1, pSig0, pSig1, &zSig0, &zSig1);\n\n                zSign ^= 1;\n\n            } else {\n\n                /* Exact zero */\n\n                zSign = signflip;\n\n                if (STATUS(float_rounding_mode) == float_round_down) {\n\n                    zSign ^= 1;\n\n                }\n\n                return packFloat64(zSign, 0, 0);\n\n            }\n\n        }\n\n        --zExp;\n\n        /* Do the equivalent of normalizeRoundAndPackFloat64() but\n\n         * starting with the significand in a pair of uint64_t.\n\n         */\n\n        if (zSig0) {\n\n            shiftcount = countLeadingZeros64(zSig0) - 1;\n\n            shortShift128Left(zSig0, zSig1, shiftcount, &zSig0, &zSig1);\n\n            if (zSig1) {\n\n                zSig0 |= 1;\n\n            }\n\n            zExp -= shiftcount;\n\n        } else {\n\n            shiftcount = countLeadingZeros64(zSig1) - 1;\n\n            zSig0 = zSig1 << shiftcount;\n\n            zExp -= (shiftcount + 64);\n\n        }\n\n        return roundAndPackFloat64(zSign, zExp, zSig0 STATUS_VAR);\n\n    }\n\n}\n", "idx": 27211}
{"project": "qemu", "commit_id": "94ef4f337fb614f18b765a8e0e878a4c23cdedcd", "target": 1, "func": "static void vga_precise_update_retrace_info(VGACommonState *s)\n\n{\n\n    int htotal_chars;\n\n    int hretr_start_char;\n\n    int hretr_skew_chars;\n\n    int hretr_end_char;\n\n\n\n    int vtotal_lines;\n\n    int vretr_start_line;\n\n    int vretr_end_line;\n\n\n\n    int dots;\n\n#if 0\n\n    int div2, sldiv2;\n\n#endif\n\n    int clocking_mode;\n\n    int clock_sel;\n\n    const int clk_hz[] = {25175000, 28322000, 25175000, 25175000};\n\n    int64_t chars_per_sec;\n\n    struct vga_precise_retrace *r = &s->retrace_info.precise;\n\n\n\n    htotal_chars = s->cr[VGA_CRTC_H_TOTAL] + 5;\n\n    hretr_start_char = s->cr[VGA_CRTC_H_SYNC_START];\n\n    hretr_skew_chars = (s->cr[VGA_CRTC_H_SYNC_END] >> 5) & 3;\n\n    hretr_end_char = s->cr[VGA_CRTC_H_SYNC_END] & 0x1f;\n\n\n\n    vtotal_lines = (s->cr[VGA_CRTC_V_TOTAL] |\n\n                    (((s->cr[VGA_CRTC_OVERFLOW] & 1) |\n\n                      ((s->cr[VGA_CRTC_OVERFLOW] >> 4) & 2)) << 8)) + 2;\n\n    vretr_start_line = s->cr[VGA_CRTC_V_SYNC_START] |\n\n        ((((s->cr[VGA_CRTC_OVERFLOW] >> 2) & 1) |\n\n          ((s->cr[VGA_CRTC_OVERFLOW] >> 6) & 2)) << 8);\n\n    vretr_end_line = s->cr[VGA_CRTC_V_SYNC_END] & 0xf;\n\n\n\n    clocking_mode = (s->sr[VGA_SEQ_CLOCK_MODE] >> 3) & 1;\n\n    clock_sel = (s->msr >> 2) & 3;\n\n    dots = (s->msr & 1) ? 8 : 9;\n\n\n\n    chars_per_sec = clk_hz[clock_sel] / dots;\n\n\n\n    htotal_chars <<= clocking_mode;\n\n\n\n    r->total_chars = vtotal_lines * htotal_chars;\n\n    if (r->freq) {\n\n        r->ticks_per_char = NANOSECONDS_PER_SECOND / (r->total_chars * r->freq);\n\n    } else {\n\n        r->ticks_per_char = NANOSECONDS_PER_SECOND / chars_per_sec;\n\n    }\n\n\n\n    r->vstart = vretr_start_line;\n\n    r->vend = r->vstart + vretr_end_line + 1;\n\n\n\n    r->hstart = hretr_start_char + hretr_skew_chars;\n\n    r->hend = r->hstart + hretr_end_char + 1;\n\n    r->htotal = htotal_chars;\n\n\n\n#if 0\n\n    div2 = (s->cr[VGA_CRTC_MODE] >> 2) & 1;\n\n    sldiv2 = (s->cr[VGA_CRTC_MODE] >> 3) & 1;\n\n    printf (\n\n        \"hz=%f\\n\"\n\n        \"htotal = %d\\n\"\n\n        \"hretr_start = %d\\n\"\n\n        \"hretr_skew = %d\\n\"\n\n        \"hretr_end = %d\\n\"\n\n        \"vtotal = %d\\n\"\n\n        \"vretr_start = %d\\n\"\n\n        \"vretr_end = %d\\n\"\n\n        \"div2 = %d sldiv2 = %d\\n\"\n\n        \"clocking_mode = %d\\n\"\n\n        \"clock_sel = %d %d\\n\"\n\n        \"dots = %d\\n\"\n\n        \"ticks/char = %\" PRId64 \"\\n\"\n\n        \"\\n\",\n\n        (double) NANOSECONDS_PER_SECOND / (r->ticks_per_char * r->total_chars),\n\n        htotal_chars,\n\n        hretr_start_char,\n\n        hretr_skew_chars,\n\n        hretr_end_char,\n\n        vtotal_lines,\n\n        vretr_start_line,\n\n        vretr_end_line,\n\n        div2, sldiv2,\n\n        clocking_mode,\n\n        clock_sel,\n\n        clk_hz[clock_sel],\n\n        dots,\n\n        r->ticks_per_char\n\n        );\n\n#endif\n\n}\n", "idx": 27212}
{"project": "qemu", "commit_id": "fe345a3d5d7ed4bc2965c65542832b1fa785ae9d", "target": 1, "func": "static void diag288_timer_expired(void *dev)\n\n{\n\n    qemu_log_mask(CPU_LOG_RESET, \"Watchdog timer expired.\\n\");\n\n    watchdog_perform_action();\n\n    /* Reset the watchdog only if the guest was notified about expiry. */\n\n    switch (get_watchdog_action()) {\n\n    case WDT_DEBUG:\n\n    case WDT_NONE:\n\n    case WDT_PAUSE:\n\n         return;\n\n    }\n\n    wdt_diag288_reset(dev);\n\n}\n", "idx": 27213}
{"project": "qemu", "commit_id": "04e00c92ef75629a241ebc50537f75de0867928d", "target": 1, "func": "void pcie_aer_inject_error_print(Monitor *mon, const QObject *data)\n\n{\n\n    QDict *qdict;\n\n    int devfn;\n\n    assert(qobject_type(data) == QTYPE_QDICT);\n\n    qdict = qobject_to_qdict(data);\n\n\n\n    devfn = (int)qdict_get_int(qdict, \"devfn\");\n\n    monitor_printf(mon, \"OK id: %s root bus: %s, bus: %x devfn: %x.%x\\n\",\n\n                   qdict_get_str(qdict, \"id\"),\n\n                   qdict_get_str(qdict, \"root_bus\"),\n\n                   (int) qdict_get_int(qdict, \"bus\"),\n\n                   PCI_SLOT(devfn), PCI_FUNC(devfn));\n\n}\n", "idx": 27214}
{"project": "qemu", "commit_id": "a5f533909e746ca6e534b232fb42c9c6fd81b468", "target": 1, "func": "static void gen_branch(DisasContext *ctx, int insn_bytes)\n\n{\n\n    if (ctx->hflags & MIPS_HFLAG_BMASK) {\n\n        int proc_hflags = ctx->hflags & MIPS_HFLAG_BMASK;\n\n        /* Branches completion */\n\n        ctx->hflags &= ~MIPS_HFLAG_BMASK;\n\n        ctx->bstate = BS_BRANCH;\n\n        save_cpu_state(ctx, 0);\n\n        /* FIXME: Need to clear can_do_io.  */\n\n        switch (proc_hflags & MIPS_HFLAG_BMASK_BASE) {\n\n        case MIPS_HFLAG_FBNSLOT:\n\n            MIPS_DEBUG(\"forbidden slot\");\n\n            gen_goto_tb(ctx, 0, ctx->pc + insn_bytes);\n\n            break;\n\n        case MIPS_HFLAG_B:\n\n            /* unconditional branch */\n\n            MIPS_DEBUG(\"unconditional branch\");\n\n            if (proc_hflags & MIPS_HFLAG_BX) {\n\n                tcg_gen_xori_i32(hflags, hflags, MIPS_HFLAG_M16);\n\n            }\n\n            gen_goto_tb(ctx, 0, ctx->btarget);\n\n            break;\n\n        case MIPS_HFLAG_BL:\n\n            /* blikely taken case */\n\n            MIPS_DEBUG(\"blikely branch taken\");\n\n            gen_goto_tb(ctx, 0, ctx->btarget);\n\n            break;\n\n        case MIPS_HFLAG_BC:\n\n            /* Conditional branch */\n\n            MIPS_DEBUG(\"conditional branch\");\n\n            {\n\n                TCGLabel *l1 = gen_new_label();\n\n\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, bcond, 0, l1);\n\n                gen_goto_tb(ctx, 1, ctx->pc + insn_bytes);\n\n                gen_set_label(l1);\n\n                gen_goto_tb(ctx, 0, ctx->btarget);\n\n            }\n\n            break;\n\n        case MIPS_HFLAG_BR:\n\n            /* unconditional branch to register */\n\n            MIPS_DEBUG(\"branch to register\");\n\n            if (ctx->insn_flags & (ASE_MIPS16 | ASE_MICROMIPS)) {\n\n                TCGv t0 = tcg_temp_new();\n\n                TCGv_i32 t1 = tcg_temp_new_i32();\n\n\n\n                tcg_gen_andi_tl(t0, btarget, 0x1);\n\n                tcg_gen_trunc_tl_i32(t1, t0);\n\n                tcg_temp_free(t0);\n\n                tcg_gen_andi_i32(hflags, hflags, ~(uint32_t)MIPS_HFLAG_M16);\n\n                tcg_gen_shli_i32(t1, t1, MIPS_HFLAG_M16_SHIFT);\n\n                tcg_gen_or_i32(hflags, hflags, t1);\n\n                tcg_temp_free_i32(t1);\n\n\n\n                tcg_gen_andi_tl(cpu_PC, btarget, ~(target_ulong)0x1);\n\n            } else {\n\n                tcg_gen_mov_tl(cpu_PC, btarget);\n\n            }\n\n            if (ctx->singlestep_enabled) {\n\n                save_cpu_state(ctx, 0);\n\n                gen_helper_0e0i(raise_exception, EXCP_DEBUG);\n\n            }\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        default:\n\n            MIPS_DEBUG(\"unknown branch\");\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 27215}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "qemu_irq qemu_irq_invert(qemu_irq irq)\n\n{\n\n    /* The default state for IRQs is low, so raise the output now.  */\n\n    qemu_irq_raise(irq);\n\n    return qemu_allocate_irqs(qemu_notirq, irq, 1)[0];\n\n}\n", "idx": 27220}
{"project": "qemu", "commit_id": "84cab1e2f5be3ea6eaa65c9fc0422fb992946ce0", "target": 1, "func": "static void gen_std(DisasContext *ctx)\n\n{\n\n    int rs;\n\n    TCGv EA;\n\n\n\n    rs = rS(ctx->opcode);\n\n    if ((ctx->opcode & 0x3) == 0x2) {\n\n#if defined(CONFIG_USER_ONLY)\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n        /* stq */\n\n        if (unlikely(ctx->mem_idx == 0)) {\n\n            gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n            return;\n\n        }\n\n        if (unlikely(rs & 1)) {\n\n            gen_inval_exception(ctx, POWERPC_EXCP_INVAL_INVAL);\n\n            return;\n\n        }\n\n        if (unlikely(ctx->le_mode)) {\n\n            /* Little-endian mode is not handled */\n\n            gen_exception_err(ctx, POWERPC_EXCP_ALIGN, POWERPC_EXCP_ALIGN_LE);\n\n            return;\n\n        }\n\n        gen_set_access_type(ctx, ACCESS_INT);\n\n        EA = tcg_temp_new();\n\n        gen_addr_imm_index(ctx, EA, 0x03);\n\n        gen_qemu_st64(ctx, cpu_gpr[rs], EA);\n\n        gen_addr_add(ctx, EA, EA, 8);\n\n        gen_qemu_st64(ctx, cpu_gpr[rs+1], EA);\n\n        tcg_temp_free(EA);\n\n#endif\n\n    } else {\n\n        /* std / stdu */\n\n        if (Rc(ctx->opcode)) {\n\n            if (unlikely(rA(ctx->opcode) == 0)) {\n\n                gen_inval_exception(ctx, POWERPC_EXCP_INVAL_INVAL);\n\n                return;\n\n            }\n\n        }\n\n        gen_set_access_type(ctx, ACCESS_INT);\n\n        EA = tcg_temp_new();\n\n        gen_addr_imm_index(ctx, EA, 0x03);\n\n        gen_qemu_st64(ctx, cpu_gpr[rs], EA);\n\n        if (Rc(ctx->opcode))\n\n            tcg_gen_mov_tl(cpu_gpr[rA(ctx->opcode)], EA);\n\n        tcg_temp_free(EA);\n\n    }\n\n}\n", "idx": 27223}
{"project": "qemu", "commit_id": "f11dc27bcc031b9dc90ffd82c503b55f83c246ca", "target": 1, "func": "static void free_test_data(test_data *data)\n\n{\n\n    AcpiSdtTable *temp;\n\n    int i;\n\n\n\n    g_free(data->rsdt_tables_addr);\n\n\n\n    for (i = 0; i < data->tables->len; ++i) {\n\n        temp = &g_array_index(data->tables, AcpiSdtTable, i);\n\n        g_free(temp->aml);\n\n        if (temp->aml_file &&\n\n            !temp->tmp_files_retain &&\n\n            g_strstr_len(temp->aml_file, -1, \"aml-\")) {\n\n            unlink(temp->aml_file);\n\n        }\n\n        g_free(temp->aml_file);\n\n        g_free(temp->asl);\n\n        if (temp->asl_file &&\n\n            !temp->tmp_files_retain) {\n\n            unlink(temp->asl_file);\n\n        }\n\n        g_free(temp->asl_file);\n\n    }\n\n\n\n    g_array_free(data->tables, false);\n\n}\n", "idx": 27225}
{"project": "qemu", "commit_id": "21ce148c7ec71ee32834061355a5ecfd1a11f90f", "target": 1, "func": "static inline int cris_bound_w(int v, int b)\n\n{\n\n\tint r = v;\n\n\tasm (\"bound.w\\t%1, %0\\n\" : \"+r\" (r) : \"ri\" (b));\n\n\treturn r;\n\n}\n", "idx": 27233}
{"project": "qemu", "commit_id": "c5633d998a27502ad8cc10c2d46f91b02555ae7a", "target": 1, "func": "static int xen_remove_from_physmap(XenIOState *state,\n\n                                   hwaddr start_addr,\n\n                                   ram_addr_t size)\n\n{\n\n    unsigned long i = 0;\n\n    int rc = 0;\n\n    XenPhysmap *physmap = NULL;\n\n    hwaddr phys_offset = 0;\n\n\n\n    physmap = get_physmapping(state, start_addr, size);\n\n    if (physmap == NULL) {\n\n        return -1;\n\n    }\n\n\n\n    phys_offset = physmap->phys_offset;\n\n    size = physmap->size;\n\n\n\n    DPRINTF(\"unmapping vram to %\"HWADDR_PRIx\" - %\"HWADDR_PRIx\", from \",\n\n            \"%\"HWADDR_PRIx\"\\n\", phys_offset, phys_offset + size, start_addr);\n\n\n\n    size >>= TARGET_PAGE_BITS;\n\n    start_addr >>= TARGET_PAGE_BITS;\n\n    phys_offset >>= TARGET_PAGE_BITS;\n\n    for (i = 0; i < size; i++) {\n\n        unsigned long idx = start_addr + i;\n\n        xen_pfn_t gpfn = phys_offset + i;\n\n\n\n        rc = xc_domain_add_to_physmap(xen_xc, xen_domid, XENMAPSPACE_gmfn, idx, gpfn);\n\n        if (rc) {\n\n            fprintf(stderr, \"add_to_physmap MFN %\"PRI_xen_pfn\" to PFN %\"\n\n                    PRI_xen_pfn\" failed: %d\\n\", idx, gpfn, rc);\n\n            return -rc;\n\n        }\n\n    }\n\n\n\n    QLIST_REMOVE(physmap, list);\n\n    if (state->log_for_dirtybit == physmap) {\n\n        state->log_for_dirtybit = NULL;\n\n    }\n\n    free(physmap);\n\n\n\n    return 0;\n\n}\n", "idx": 27235}
{"project": "qemu", "commit_id": "d400fc018b326104d26d730e5cc8c36c1f662c34", "target": 1, "func": "static void usb_ohci_init(OHCIState *ohci, DeviceState *dev,\n                          int num_ports, dma_addr_t localmem_base,\n                          char *masterbus, uint32_t firstport,\n                          AddressSpace *as, Error **errp)\n{\n    Error *err = NULL;\n    int i;\n    ohci->as = as;\n    if (usb_frame_time == 0) {\n#ifdef OHCI_TIME_WARP\n        usb_frame_time = NANOSECONDS_PER_SECOND;\n        usb_bit_time = NANOSECONDS_PER_SECOND / (USB_HZ / 1000);\n#else\n        usb_frame_time = NANOSECONDS_PER_SECOND / 1000;\n        if (NANOSECONDS_PER_SECOND >= USB_HZ) {\n            usb_bit_time = NANOSECONDS_PER_SECOND / USB_HZ;\n        } else {\n            usb_bit_time = 1;\n#endif\n        trace_usb_ohci_init_time(usb_frame_time, usb_bit_time);\n    ohci->num_ports = num_ports;\n    if (masterbus) {\n        USBPort *ports[OHCI_MAX_PORTS];\n        for(i = 0; i < num_ports; i++) {\n            ports[i] = &ohci->rhport[i].port;\n        usb_register_companion(masterbus, ports, num_ports,\n                               firstport, ohci, &ohci_port_ops,\n                               USB_SPEED_MASK_LOW | USB_SPEED_MASK_FULL,\n                               &err);\n        if (err) {\n            error_propagate(errp, err);\n    } else {\n        usb_bus_new(&ohci->bus, sizeof(ohci->bus), &ohci_bus_ops, dev);\n        for (i = 0; i < num_ports; i++) {\n            usb_register_port(&ohci->bus, &ohci->rhport[i].port,\n                              ohci, i, &ohci_port_ops,\n                              USB_SPEED_MASK_LOW | USB_SPEED_MASK_FULL);\n    memory_region_init_io(&ohci->mem, OBJECT(dev), &ohci_mem_ops,\n                          ohci, \"ohci\", 256);\n    ohci->localmem_base = localmem_base;\n    ohci->name = object_get_typename(OBJECT(dev));\n    usb_packet_init(&ohci->usb_packet);\n    ohci->async_td = 0;\n    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n                                   ohci_frame_boundary, ohci);", "idx": 27238}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void isabus_fdc_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = isabus_fdc_realize;\n\n    dc->fw_name = \"fdc\";\n\n    dc->no_user = 1;\n\n    dc->reset = fdctrl_external_reset_isa;\n\n    dc->vmsd = &vmstate_isa_fdc;\n\n    dc->props = isa_fdc_properties;\n\n    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);\n\n}\n", "idx": 27239}
{"project": "qemu", "commit_id": "277acfe8b38de35be8cb6e274678b5a7919c2d44", "target": 0, "func": "static int64_t expr_unary(Monitor *mon)\n\n{\n\n    int64_t n;\n\n    char *p;\n\n    int ret;\n\n\n\n    switch(*pch) {\n\n    case '+':\n\n        next();\n\n        n = expr_unary(mon);\n\n        break;\n\n    case '-':\n\n        next();\n\n        n = -expr_unary(mon);\n\n        break;\n\n    case '~':\n\n        next();\n\n        n = ~expr_unary(mon);\n\n        break;\n\n    case '(':\n\n        next();\n\n        n = expr_sum(mon);\n\n        if (*pch != ')') {\n\n            expr_error(mon, \"')' expected\");\n\n        }\n\n        next();\n\n        break;\n\n    case '\\'':\n\n        pch++;\n\n        if (*pch == '\\0')\n\n            expr_error(mon, \"character constant expected\");\n\n        n = *pch;\n\n        pch++;\n\n        if (*pch != '\\'')\n\n            expr_error(mon, \"missing terminating \\' character\");\n\n        next();\n\n        break;\n\n    case '$':\n\n        {\n\n            char buf[128], *q;\n\n            target_long reg=0;\n\n\n\n            pch++;\n\n            q = buf;\n\n            while ((*pch >= 'a' && *pch <= 'z') ||\n\n                   (*pch >= 'A' && *pch <= 'Z') ||\n\n                   (*pch >= '0' && *pch <= '9') ||\n\n                   *pch == '_' || *pch == '.') {\n\n                if ((q - buf) < sizeof(buf) - 1)\n\n                    *q++ = *pch;\n\n                pch++;\n\n            }\n\n            while (qemu_isspace(*pch))\n\n                pch++;\n\n            *q = 0;\n\n            ret = get_monitor_def(&reg, buf);\n\n            if (ret < 0)\n\n                expr_error(mon, \"unknown register\");\n\n            n = reg;\n\n        }\n\n        break;\n\n    case '\\0':\n\n        expr_error(mon, \"unexpected end of expression\");\n\n        n = 0;\n\n        break;\n\n    default:\n\n        errno = 0;\n\n        n = strtoull(pch, &p, 0);\n\n        if (errno == ERANGE) {\n\n            expr_error(mon, \"number too large\");\n\n        }\n\n        if (pch == p) {\n\n            expr_error(mon, \"invalid char in expression\");\n\n        }\n\n        pch = p;\n\n        while (qemu_isspace(*pch))\n\n            pch++;\n\n        break;\n\n    }\n\n    return n;\n\n}\n", "idx": 27240}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "mst_fpga_writeb(void *opaque, target_phys_addr_t addr, uint32_t value)\n\n{\n\n\tmst_irq_state *s = (mst_irq_state *) opaque;\n\n\tvalue &= 0xffffffff;\n\n\n\n\tswitch (addr) {\n\n\tcase MST_LEDDAT1:\n\n\t\ts->leddat1 = value;\n\n\t\tbreak;\n\n\tcase MST_LEDDAT2:\n\n\t\ts->leddat2 = value;\n\n\t\tbreak;\n\n\tcase MST_LEDCTRL:\n\n\t\ts->ledctrl = value;\n\n\t\tbreak;\n\n\tcase MST_GPSWR:\n\n\t\ts->gpswr = value;\n\n\t\tbreak;\n\n\tcase MST_MSCWR1:\n\n\t\ts->mscwr1 = value;\n\n\t\tbreak;\n\n\tcase MST_MSCWR2:\n\n\t\ts->mscwr2 = value;\n\n\t\tbreak;\n\n\tcase MST_MSCWR3:\n\n\t\ts->mscwr3 = value;\n\n\t\tbreak;\n\n\tcase MST_MSCRD:\n\n\t\ts->mscrd =  value;\n\n\t\tbreak;\n\n\tcase MST_INTMSKENA:\t/* Mask interrupt */\n\n\t\ts->intmskena = (value & 0xFEEFF);\n\n\t\tqemu_set_irq(s->parent, s->intsetclr & s->intmskena);\n\n\t\tbreak;\n\n\tcase MST_INTSETCLR:\t/* clear or set interrupt */\n\n\t\ts->intsetclr = (value & 0xFEEFF);\n\n\t\tqemu_set_irq(s->parent, s->intsetclr & s->intmskena);\n\n\t\tbreak;\n\n\t\t/* For PCMCIAx allow the to change only power and reset */\n\n\tcase MST_PCMCIA0:\n\n\t\ts->pcmcia0 = (value & 0x1f) | (s->pcmcia0 & ~0x1f);\n\n\t\tbreak;\n\n\tcase MST_PCMCIA1:\n\n\t\ts->pcmcia1 = (value & 0x1f) | (s->pcmcia1 & ~0x1f);\n\n\t\tbreak;\n\n\tdefault:\n\n\t\tprintf(\"Mainstone - mst_fpga_writeb: Bad register offset \"\n\n\t\t\t\"0x\" TARGET_FMT_plx \" \\n\", addr);\n\n\t}\n\n}\n", "idx": 27241}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void aio_bh_schedule_oneshot(AioContext *ctx, QEMUBHFunc *cb, void *opaque)\n\n{\n\n    QEMUBH *bh;\n\n    bh = g_new(QEMUBH, 1);\n\n    *bh = (QEMUBH){\n\n        .ctx = ctx,\n\n        .cb = cb,\n\n        .opaque = opaque,\n\n    };\n\n    qemu_lockcnt_lock(&ctx->list_lock);\n\n    bh->next = ctx->first_bh;\n\n    bh->scheduled = 1;\n\n    bh->deleted = 1;\n\n    /* Make sure that the members are ready before putting bh into list */\n\n    smp_wmb();\n\n    ctx->first_bh = bh;\n\n    qemu_lockcnt_unlock(&ctx->list_lock);\n\n    aio_notify(ctx);\n\n}\n", "idx": 27242}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void do_cont(int argc, const char **argv)\n\n{\n\n    vm_start();\n\n}\n", "idx": 27245}
{"project": "qemu", "commit_id": "37654d9e6af84003982f8b9a5d59a4aef28e0a79", "target": 0, "func": "static inline void _t_gen_mov_TN_env(TCGv tn, int offset)\n\n{\n\n    if (offset > sizeof(CPUCRISState)) {\n\n        fprintf(stderr, \"wrong load from env from off=%d\\n\", offset);\n\n    }\n\n    tcg_gen_ld_tl(tn, cpu_env, offset);\n\n}\n", "idx": 27246}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static int32_t virtio_net_flush_tx(VirtIONetQueue *q)\n\n{\n\n    VirtIONet *n = q->n;\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n\n    VirtQueueElement elem;\n\n    int32_t num_packets = 0;\n\n    int queue_index = vq2q(virtio_get_queue_index(q->tx_vq));\n\n    if (!(vdev->status & VIRTIO_CONFIG_S_DRIVER_OK)) {\n\n        return num_packets;\n\n    }\n\n\n\n    if (q->async_tx.elem.out_num) {\n\n        virtio_queue_set_notification(q->tx_vq, 0);\n\n        return num_packets;\n\n    }\n\n\n\n    while (virtqueue_pop(q->tx_vq, &elem)) {\n\n        ssize_t ret;\n\n        unsigned int out_num = elem.out_num;\n\n        struct iovec *out_sg = &elem.out_sg[0];\n\n        struct iovec sg[VIRTQUEUE_MAX_SIZE], sg2[VIRTQUEUE_MAX_SIZE + 1];\n\n        struct virtio_net_hdr_mrg_rxbuf mhdr;\n\n\n\n        if (out_num < 1) {\n\n            error_report(\"virtio-net header not in first element\");\n\n            exit(1);\n\n        }\n\n\n\n        if (n->has_vnet_hdr) {\n\n            if (iov_to_buf(out_sg, out_num, 0, &mhdr, n->guest_hdr_len) <\n\n                n->guest_hdr_len) {\n\n                error_report(\"virtio-net header incorrect\");\n\n                exit(1);\n\n            }\n\n            if (virtio_needs_swap(vdev)) {\n\n                virtio_net_hdr_swap(vdev, (void *) &mhdr);\n\n                sg2[0].iov_base = &mhdr;\n\n                sg2[0].iov_len = n->guest_hdr_len;\n\n                out_num = iov_copy(&sg2[1], ARRAY_SIZE(sg2) - 1,\n\n                                   out_sg, out_num,\n\n                                   n->guest_hdr_len, -1);\n\n                if (out_num == VIRTQUEUE_MAX_SIZE) {\n\n                    goto drop;\n\n\t\t}\n\n                out_num += 1;\n\n                out_sg = sg2;\n\n\t    }\n\n        }\n\n        /*\n\n         * If host wants to see the guest header as is, we can\n\n         * pass it on unchanged. Otherwise, copy just the parts\n\n         * that host is interested in.\n\n         */\n\n        assert(n->host_hdr_len <= n->guest_hdr_len);\n\n        if (n->host_hdr_len != n->guest_hdr_len) {\n\n            unsigned sg_num = iov_copy(sg, ARRAY_SIZE(sg),\n\n                                       out_sg, out_num,\n\n                                       0, n->host_hdr_len);\n\n            sg_num += iov_copy(sg + sg_num, ARRAY_SIZE(sg) - sg_num,\n\n                             out_sg, out_num,\n\n                             n->guest_hdr_len, -1);\n\n            out_num = sg_num;\n\n            out_sg = sg;\n\n        }\n\n\n\n        ret = qemu_sendv_packet_async(qemu_get_subqueue(n->nic, queue_index),\n\n                                      out_sg, out_num, virtio_net_tx_complete);\n\n        if (ret == 0) {\n\n            virtio_queue_set_notification(q->tx_vq, 0);\n\n            q->async_tx.elem = elem;\n\n            return -EBUSY;\n\n        }\n\n\n\ndrop:\n\n        virtqueue_push(q->tx_vq, &elem, 0);\n\n        virtio_notify(vdev, q->tx_vq);\n\n\n\n        if (++num_packets >= n->tx_burst) {\n\n            break;\n\n        }\n\n    }\n\n    return num_packets;\n\n}\n", "idx": 27247}
{"project": "qemu", "commit_id": "1f0c461b82d5ec2664ca0cfc9548f80da87a8f8a", "target": 0, "func": "static const char *bdrv_get_parent_name(const BlockDriverState *bs)\n\n{\n\n    BdrvChild *c;\n\n    const char *name;\n\n\n\n    /* If multiple parents have a name, just pick the first one. */\n\n    QLIST_FOREACH(c, &bs->parents, next_parent) {\n\n        if (c->role->get_name) {\n\n            name = c->role->get_name(c);\n\n            if (name && *name) {\n\n                return name;\n\n            }\n\n        }\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 27248}
{"project": "qemu", "commit_id": "9bc3a3a216e2689bfcdd36c3e079333bbdbf3ba0", "target": 0, "func": "static int ehci_state_waitlisthead(EHCIState *ehci,  int async)\n\n{\n\n    EHCIqh qh;\n\n    int i = 0;\n\n    int again = 0;\n\n    uint32_t entry = ehci->asynclistaddr;\n\n\n\n    /* set reclamation flag at start event (4.8.6) */\n\n    if (async) {\n\n        ehci_set_usbsts(ehci, USBSTS_REC);\n\n    }\n\n\n\n    ehci_queues_rip_unused(ehci, async, 0);\n\n\n\n    /*  Find the head of the list (4.9.1.1) */\n\n    for(i = 0; i < MAX_QH; i++) {\n\n        get_dwords(ehci, NLPTR_GET(entry), (uint32_t *) &qh,\n\n                   sizeof(EHCIqh) >> 2);\n\n        ehci_trace_qh(NULL, NLPTR_GET(entry), &qh);\n\n\n\n        if (qh.epchar & QH_EPCHAR_H) {\n\n            if (async) {\n\n                entry |= (NLPTR_TYPE_QH << 1);\n\n            }\n\n\n\n            ehci_set_fetch_addr(ehci, async, entry);\n\n            ehci_set_state(ehci, async, EST_FETCHENTRY);\n\n            again = 1;\n\n            goto out;\n\n        }\n\n\n\n        entry = qh.next;\n\n        if (entry == ehci->asynclistaddr) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* no head found for list. */\n\n\n\n    ehci_set_state(ehci, async, EST_ACTIVE);\n\n\n\nout:\n\n    return again;\n\n}\n", "idx": 27249}
{"project": "qemu", "commit_id": "b00c72180c36510bf9b124e190bd520e3b7e1358", "target": 0, "func": "static void gen_rdhwr(DisasContext *ctx, int rt, int rd)\n\n{\n\n    TCGv t0;\n\n\n\n#if !defined(CONFIG_USER_ONLY)\n\n    /* The Linux kernel will emulate rdhwr if it's not supported natively.\n\n       Therefore only check the ISA in system mode.  */\n\n    check_insn(ctx, ISA_MIPS32R2);\n\n#endif\n\n    t0 = tcg_temp_new();\n\n\n\n    switch (rd) {\n\n    case 0:\n\n        gen_helper_rdhwr_cpunum(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 1:\n\n        gen_helper_rdhwr_synci_step(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 2:\n\n        gen_helper_rdhwr_cc(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 3:\n\n        gen_helper_rdhwr_ccres(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 29:\n\n#if defined(CONFIG_USER_ONLY)\n\n        tcg_gen_ld_tl(t0, cpu_env,\n\n                      offsetof(CPUMIPSState, active_tc.CP0_UserLocal));\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n#else\n\n        if ((ctx->hflags & MIPS_HFLAG_CP0) ||\n\n            (ctx->hflags & MIPS_HFLAG_HWRENA_ULR)) {\n\n            tcg_gen_ld_tl(t0, cpu_env,\n\n                          offsetof(CPUMIPSState, active_tc.CP0_UserLocal));\n\n            gen_store_gpr(t0, rt);\n\n        } else {\n\n            generate_exception_end(ctx, EXCP_RI);\n\n        }\n\n        break;\n\n#endif\n\n    default:            /* Invalid */\n\n        MIPS_INVAL(\"rdhwr\");\n\n        generate_exception_end(ctx, EXCP_RI);\n\n        break;\n\n    }\n\n    tcg_temp_free(t0);\n\n}\n", "idx": 27250}
{"project": "qemu", "commit_id": "439e2a6e10ed7f5da819bf7dcaa54b8cfdbeab0d", "target": 0, "func": "Aml *aml_shiftright(Aml *arg1, Aml *count)\n\n{\n\n    Aml *var = aml_opcode(0x7A /* ShiftRightOp */);\n\n    aml_append(var, arg1);\n\n    aml_append(var, count);\n\n    build_append_byte(var->buf, 0x00); /* NullNameOp */\n\n    return var;\n\n}\n", "idx": 27251}
{"project": "qemu", "commit_id": "37cc9f7f684ed035da63274daca1594c7ee16213", "target": 0, "func": "static ssize_t handle_aiocb_write_zeroes(RawPosixAIOData *aiocb)\n\n{\n\n    int ret = -EOPNOTSUPP;\n\n    BDRVRawState *s = aiocb->bs->opaque;\n\n\n\n    if (s->has_write_zeroes == 0) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    if (aiocb->aio_type & QEMU_AIO_BLKDEV) {\n\n#ifdef BLKZEROOUT\n\n        do {\n\n            uint64_t range[2] = { aiocb->aio_offset, aiocb->aio_nbytes };\n\n            if (ioctl(aiocb->aio_fildes, BLKZEROOUT, range) == 0) {\n\n                return 0;\n\n            }\n\n        } while (errno == EINTR);\n\n\n\n        ret = -errno;\n\n#endif\n\n    } else {\n\n#ifdef CONFIG_XFS\n\n        if (s->is_xfs) {\n\n            return xfs_write_zeroes(s, aiocb->aio_offset, aiocb->aio_nbytes);\n\n        }\n\n#endif\n\n    }\n\n\n\n    ret = translate_err(ret);\n\n    if (ret == -ENOTSUP) {\n\n        s->has_write_zeroes = false;\n\n    }\n\n    return ret;\n\n}\n", "idx": 27252}
{"project": "qemu", "commit_id": "9fd3171af9d7de2777bf38ce79c2fe3dd6f9a49e", "target": 0, "func": "int bdrv_open(BlockDriverState *bs, const char *filename, QDict *options,\n\n              int flags, BlockDriver *drv, Error **errp)\n\n{\n\n    int ret;\n\n    /* TODO: extra byte is a hack to ensure MAX_PATH space on Windows. */\n\n    char tmp_filename[PATH_MAX + 1];\n\n    BlockDriverState *file = NULL;\n\n    QDict *file_options = NULL;\n\n    const char *drvname;\n\n    Error *local_err = NULL;\n\n\n\n    /* NULL means an empty set of options */\n\n    if (options == NULL) {\n\n        options = qdict_new();\n\n    }\n\n\n\n    bs->options = options;\n\n    options = qdict_clone_shallow(options);\n\n\n\n    /* For snapshot=on, create a temporary qcow2 overlay */\n\n    if (flags & BDRV_O_SNAPSHOT) {\n\n        BlockDriverState *bs1;\n\n        int64_t total_size;\n\n        BlockDriver *bdrv_qcow2;\n\n        QEMUOptionParameter *create_options;\n\n        char backing_filename[PATH_MAX];\n\n\n\n        if (qdict_size(options) != 0) {\n\n            error_setg(errp, \"Can't use snapshot=on with driver-specific options\");\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n        assert(filename != NULL);\n\n\n\n        /* if snapshot, we create a temporary backing file and open it\n\n           instead of opening 'filename' directly */\n\n\n\n        /* if there is a backing file, use it */\n\n        bs1 = bdrv_new(\"\");\n\n        ret = bdrv_open(bs1, filename, NULL, 0, drv, &local_err);\n\n        if (ret < 0) {\n\n            bdrv_unref(bs1);\n\n            goto fail;\n\n        }\n\n        total_size = bdrv_getlength(bs1) & BDRV_SECTOR_MASK;\n\n\n\n        bdrv_unref(bs1);\n\n\n\n        ret = get_tmp_filename(tmp_filename, sizeof(tmp_filename));\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret, \"Could not get temporary filename\");\n\n            goto fail;\n\n        }\n\n\n\n        /* Real path is meaningless for protocols */\n\n        if (path_has_protocol(filename)) {\n\n            snprintf(backing_filename, sizeof(backing_filename),\n\n                     \"%s\", filename);\n\n        } else if (!realpath(filename, backing_filename)) {\n\n            ret = -errno;\n\n            error_setg_errno(errp, errno, \"Could not resolve path '%s'\", filename);\n\n            goto fail;\n\n        }\n\n\n\n        bdrv_qcow2 = bdrv_find_format(\"qcow2\");\n\n        create_options = parse_option_parameters(\"\", bdrv_qcow2->create_options,\n\n                                                 NULL);\n\n\n\n        set_option_parameter_int(create_options, BLOCK_OPT_SIZE, total_size);\n\n        set_option_parameter(create_options, BLOCK_OPT_BACKING_FILE,\n\n                             backing_filename);\n\n        if (drv) {\n\n            set_option_parameter(create_options, BLOCK_OPT_BACKING_FMT,\n\n                drv->format_name);\n\n        }\n\n\n\n        ret = bdrv_create(bdrv_qcow2, tmp_filename, create_options, &local_err);\n\n        free_option_parameters(create_options);\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret, \"Could not create temporary overlay \"\n\n                             \"'%s': %s\", tmp_filename,\n\n                             error_get_pretty(local_err));\n\n            error_free(local_err);\n\n            local_err = NULL;\n\n            goto fail;\n\n        }\n\n\n\n        filename = tmp_filename;\n\n        drv = bdrv_qcow2;\n\n        bs->is_temporary = 1;\n\n    }\n\n\n\n    /* Open image file without format layer */\n\n    if (flags & BDRV_O_RDWR) {\n\n        flags |= BDRV_O_ALLOW_RDWR;\n\n    }\n\n\n\n    qdict_extract_subqdict(options, &file_options, \"file.\");\n\n\n\n    ret = bdrv_file_open(&file, filename, file_options,\n\n                         bdrv_open_flags(bs, flags | BDRV_O_UNMAP), &local_err);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Find the right image format driver */\n\n    drvname = qdict_get_try_str(options, \"driver\");\n\n    if (drvname) {\n\n        drv = bdrv_find_format(drvname);\n\n        qdict_del(options, \"driver\");\n\n        if (!drv) {\n\n            error_setg(errp, \"Invalid driver: '%s'\", drvname);\n\n            ret = -EINVAL;\n\n            goto unlink_and_fail;\n\n        }\n\n    }\n\n\n\n    if (!drv) {\n\n        ret = find_image_format(file, filename, &drv, &local_err);\n\n    }\n\n\n\n    if (!drv) {\n\n        goto unlink_and_fail;\n\n    }\n\n\n\n    /* Open the image */\n\n    ret = bdrv_open_common(bs, file, options, flags, drv, &local_err);\n\n    if (ret < 0) {\n\n        goto unlink_and_fail;\n\n    }\n\n\n\n    if (bs->file != file) {\n\n        bdrv_unref(file);\n\n        file = NULL;\n\n    }\n\n\n\n    /* If there is a backing file, use it */\n\n    if ((flags & BDRV_O_NO_BACKING) == 0) {\n\n        QDict *backing_options;\n\n\n\n        qdict_extract_subqdict(options, &backing_options, \"backing.\");\n\n        ret = bdrv_open_backing_file(bs, backing_options, &local_err);\n\n        if (ret < 0) {\n\n            goto close_and_fail;\n\n        }\n\n    }\n\n\n\n    /* Check if any unknown options were used */\n\n    if (qdict_size(options) != 0) {\n\n        const QDictEntry *entry = qdict_first(options);\n\n        error_setg(errp, \"Block format '%s' used by device '%s' doesn't \"\n\n                   \"support the option '%s'\", drv->format_name, bs->device_name,\n\n                   entry->key);\n\n\n\n        ret = -EINVAL;\n\n        goto close_and_fail;\n\n    }\n\n    QDECREF(options);\n\n\n\n    if (!bdrv_key_required(bs)) {\n\n        bdrv_dev_change_media_cb(bs, true);\n\n    }\n\n\n\n    return 0;\n\n\n\nunlink_and_fail:\n\n    if (file != NULL) {\n\n        bdrv_unref(file);\n\n    }\n\n    if (bs->is_temporary) {\n\n        unlink(filename);\n\n    }\n\nfail:\n\n    QDECREF(bs->options);\n\n    QDECREF(options);\n\n    bs->options = NULL;\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(errp, local_err);\n\n    }\n\n    return ret;\n\n\n\nclose_and_fail:\n\n    bdrv_close(bs);\n\n    QDECREF(options);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(errp, local_err);\n\n    }\n\n    return ret;\n\n}\n", "idx": 27253}
{"project": "qemu", "commit_id": "e91e972ccfbaeba1d1416202ad1b667810a33e1f", "target": 0, "func": "int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    int ret = 0;\n\n\n\n    switch (run->exit_reason) {\n\n        case KVM_EXIT_S390_SIEIC:\n\n            ret = handle_intercept(cpu);\n\n            break;\n\n        case KVM_EXIT_S390_RESET:\n\n            qemu_system_reset_request();\n\n            break;\n\n        case KVM_EXIT_S390_TSCH:\n\n            ret = handle_tsch(cpu);\n\n            break;\n\n        case KVM_EXIT_DEBUG:\n\n            ret = kvm_arch_handle_debug_exit(cpu);\n\n            break;\n\n        default:\n\n            fprintf(stderr, \"Unknown KVM exit: %d\\n\", run->exit_reason);\n\n            break;\n\n    }\n\n\n\n    if (ret == 0) {\n\n        ret = EXCP_INTERRUPT;\n\n    }\n\n    return ret;\n\n}\n", "idx": 27254}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)\n\n{\n\n    PCIBus *bus = PCI_BUS(dev->bus);\n\n    PCIBus *iommu_bus = bus;\n\n\n\n    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {\n\n        iommu_bus = PCI_BUS(iommu_bus->parent_dev->bus);\n\n    }\n\n    if (iommu_bus && iommu_bus->iommu_fn) {\n\n        return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, dev->devfn);\n\n    }\n\n    return &address_space_memory;\n\n}\n", "idx": 27256}
{"project": "qemu", "commit_id": "de9e9d9f17a36ff76c1a02a5348835e5e0a081b0", "target": 0, "func": "static inline void gen_op_eval_fbo(TCGv dst, TCGv src,\n\n                                    unsigned int fcc_offset)\n\n{\n\n    gen_mov_reg_FCC0(dst, src, fcc_offset);\n\n    gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);\n\n    tcg_gen_and_tl(dst, dst, cpu_tmp0);\n\n    tcg_gen_xori_tl(dst, dst, 0x1);\n\n}\n", "idx": 27257}
{"project": "qemu", "commit_id": "1e2713384c58037ad44f716c31c08daca18862c5", "target": 1, "func": "static void test_qga_config(gconstpointer data)\n\n{\n\n    GError *error = NULL;\n\n    char *cwd, *cmd, *out, *err, *str, **strv, **argv = NULL;\n\n    char *env[2];\n\n    int status;\n\n    gsize n;\n\n    GKeyFile *kf;\n\n\n\n    cwd = g_get_current_dir();\n\n    cmd = g_strdup_printf(\"%s%cqemu-ga -D\",\n\n                          cwd, G_DIR_SEPARATOR);\n\n\n    g_shell_parse_argv(cmd, NULL, &argv, &error);\n\n\n    g_assert_no_error(error);\n\n\n\n    env[0] = g_strdup_printf(\"QGA_CONF=tests%cdata%ctest-qga-config\",\n\n                             G_DIR_SEPARATOR, G_DIR_SEPARATOR);\n\n    env[1] = NULL;\n\n    g_spawn_sync(NULL, argv, env, 0,\n\n                 NULL, NULL, &out, &err, &status, &error);\n\n    g_strfreev(argv);\n\n\n\n    g_assert_no_error(error);\n\n    g_assert_cmpstr(err, ==, \"\");\n\n    g_assert_cmpint(status, ==, 0);\n\n\n\n    kf = g_key_file_new();\n\n    g_key_file_load_from_data(kf, out, -1, G_KEY_FILE_NONE, &error);\n\n    g_assert_no_error(error);\n\n\n\n    str = g_key_file_get_start_group(kf);\n\n    g_assert_cmpstr(str, ==, \"general\");\n\n    g_free(str);\n\n\n\n    g_assert_false(g_key_file_get_boolean(kf, \"general\", \"daemon\", &error));\n\n    g_assert_no_error(error);\n\n\n\n    str = g_key_file_get_string(kf, \"general\", \"method\", &error);\n\n    g_assert_no_error(error);\n\n    g_assert_cmpstr(str, ==, \"virtio-serial\");\n\n    g_free(str);\n\n\n\n    str = g_key_file_get_string(kf, \"general\", \"path\", &error);\n\n    g_assert_no_error(error);\n\n    g_assert_cmpstr(str, ==, \"/path/to/org.qemu.guest_agent.0\");\n\n    g_free(str);\n\n\n\n    str = g_key_file_get_string(kf, \"general\", \"pidfile\", &error);\n\n    g_assert_no_error(error);\n\n    g_assert_cmpstr(str, ==, \"/var/foo/qemu-ga.pid\");\n\n    g_free(str);\n\n\n\n    str = g_key_file_get_string(kf, \"general\", \"statedir\", &error);\n\n    g_assert_no_error(error);\n\n    g_assert_cmpstr(str, ==, \"/var/state\");\n\n    g_free(str);\n\n\n\n    g_assert_true(g_key_file_get_boolean(kf, \"general\", \"verbose\", &error));\n\n    g_assert_no_error(error);\n\n\n\n    strv = g_key_file_get_string_list(kf, \"general\", \"blacklist\", &n, &error);\n\n    g_assert_cmpint(n, ==, 2);\n\n#if GLIB_CHECK_VERSION(2, 44, 0)\n\n    g_assert_true(g_strv_contains((const char * const *)strv,\n\n                                  \"guest-ping\"));\n\n    g_assert_true(g_strv_contains((const char * const *)strv,\n\n                                  \"guest-get-time\"));\n\n#endif\n\n    g_assert_no_error(error);\n\n    g_strfreev(strv);\n\n\n\n    g_free(out);\n\n    g_free(err);\n\n    g_free(env[0]);\n\n    g_key_file_free(kf);\n\n}", "idx": 27258}
{"project": "qemu", "commit_id": "8be487d8f184f2f721cabeac559fb7a6cba18c95", "target": 1, "func": "static void sdhci_data_transfer(void *opaque)\n\n{\n\n    SDHCIState *s = (SDHCIState *)opaque;\n\n\n\n    if (s->trnmod & SDHC_TRNS_DMA) {\n\n        switch (SDHC_DMA_TYPE(s->hostctl)) {\n\n        case SDHC_CTRL_SDMA:\n\n            if ((s->blkcnt == 1) || !(s->trnmod & SDHC_TRNS_MULTI)) {\n\n                sdhci_sdma_transfer_single_block(s);\n\n            } else {\n\n                sdhci_sdma_transfer_multi_blocks(s);\n\n            }\n\n\n\n            break;\n\n        case SDHC_CTRL_ADMA1_32:\n\n            if (!(s->capareg & SDHC_CAN_DO_ADMA1)) {\n\n                ERRPRINT(\"ADMA1 not supported\\n\");\n\n                break;\n\n            }\n\n\n\n            sdhci_do_adma(s);\n\n            break;\n\n        case SDHC_CTRL_ADMA2_32:\n\n            if (!(s->capareg & SDHC_CAN_DO_ADMA2)) {\n\n                ERRPRINT(\"ADMA2 not supported\\n\");\n\n                break;\n\n            }\n\n\n\n            sdhci_do_adma(s);\n\n            break;\n\n        case SDHC_CTRL_ADMA2_64:\n\n            if (!(s->capareg & SDHC_CAN_DO_ADMA2) ||\n\n                    !(s->capareg & SDHC_64_BIT_BUS_SUPPORT)) {\n\n                ERRPRINT(\"64 bit ADMA not supported\\n\");\n\n                break;\n\n            }\n\n\n\n            sdhci_do_adma(s);\n\n            break;\n\n        default:\n\n            ERRPRINT(\"Unsupported DMA type\\n\");\n\n            break;\n\n        }\n\n    } else {\n\n        if ((s->trnmod & SDHC_TRNS_READ) && sdbus_data_ready(&s->sdbus)) {\n\n            s->prnsts |= SDHC_DOING_READ | SDHC_DATA_INHIBIT |\n\n                    SDHC_DAT_LINE_ACTIVE;\n\n            sdhci_read_block_from_card(s);\n\n        } else {\n\n            s->prnsts |= SDHC_DOING_WRITE | SDHC_DAT_LINE_ACTIVE |\n\n                    SDHC_SPACE_AVAILABLE | SDHC_DATA_INHIBIT;\n\n            sdhci_write_block_to_card(s);\n\n        }\n\n    }\n\n}\n", "idx": 27259}
{"project": "qemu", "commit_id": "7385aed20db5d83979f683b9d0048674411e963c", "target": 0, "func": "void helper_fitoq(CPUSPARCState *env, int32_t src)\n\n{\n\n    /* No possible exceptions converting int to long double.  */\n\n    QT0 = int32_to_float128(src, &env->fp_status);\n\n}\n", "idx": 27262}
{"project": "qemu", "commit_id": "d0d7708ba29cbcc343364a46bff981e0ff88366f", "target": 0, "func": "int gdbserver_start(const char *device)\n\n{\n\n    GDBState *s;\n\n    char gdbstub_device_name[128];\n\n    CharDriverState *chr = NULL;\n\n    CharDriverState *mon_chr;\n\n\n\n    if (!device)\n\n        return -1;\n\n    if (strcmp(device, \"none\") != 0) {\n\n        if (strstart(device, \"tcp:\", NULL)) {\n\n            /* enforce required TCP attributes */\n\n            snprintf(gdbstub_device_name, sizeof(gdbstub_device_name),\n\n                     \"%s,nowait,nodelay,server\", device);\n\n            device = gdbstub_device_name;\n\n        }\n\n#ifndef _WIN32\n\n        else if (strcmp(device, \"stdio\") == 0) {\n\n            struct sigaction act;\n\n\n\n            memset(&act, 0, sizeof(act));\n\n            act.sa_handler = gdb_sigterm_handler;\n\n            sigaction(SIGINT, &act, NULL);\n\n        }\n\n#endif\n\n        chr = qemu_chr_new(\"gdb\", device, NULL);\n\n        if (!chr)\n\n            return -1;\n\n\n\n        qemu_chr_fe_claim_no_fail(chr);\n\n        qemu_chr_add_handlers(chr, gdb_chr_can_receive, gdb_chr_receive,\n\n                              gdb_chr_event, NULL);\n\n    }\n\n\n\n    s = gdbserver_state;\n\n    if (!s) {\n\n        s = g_malloc0(sizeof(GDBState));\n\n        gdbserver_state = s;\n\n\n\n        qemu_add_vm_change_state_handler(gdb_vm_state_change, NULL);\n\n\n\n        /* Initialize a monitor terminal for gdb */\n\n        mon_chr = qemu_chr_alloc();\n\n        mon_chr->chr_write = gdb_monitor_write;\n\n        monitor_init(mon_chr, 0);\n\n    } else {\n\n        if (s->chr)\n\n            qemu_chr_delete(s->chr);\n\n        mon_chr = s->mon_chr;\n\n        memset(s, 0, sizeof(GDBState));\n\n    }\n\n    s->c_cpu = first_cpu;\n\n    s->g_cpu = first_cpu;\n\n    s->chr = chr;\n\n    s->state = chr ? RS_IDLE : RS_INACTIVE;\n\n    s->mon_chr = mon_chr;\n\n    s->current_syscall_cb = NULL;\n\n\n\n    return 0;\n\n}\n", "idx": 27263}
{"project": "qemu", "commit_id": "2637c754ccdb286890ed2a8d0d1da775dbd062af", "target": 0, "func": "void cpu_dump_state(CPUState *env, FILE *f,\n\n                    int (*cpu_fprintf)(FILE *f, const char *fmt, ...),\n\n                    int flags)\n\n{\n\n    int eflags, i, nb;\n\n    char cc_op_name[32];\n\n    static const char *seg_name[6] = { \"ES\", \"CS\", \"SS\", \"DS\", \"FS\", \"GS\" };\n\n\n\n    if (kvm_enabled())\n\n        kvm_arch_get_registers(env);\n\n\n\n    eflags = env->eflags;\n\n#ifdef TARGET_X86_64\n\n    if (env->hflags & HF_CS64_MASK) {\n\n        cpu_fprintf(f,\n\n                    \"RAX=%016\" PRIx64 \" RBX=%016\" PRIx64 \" RCX=%016\" PRIx64 \" RDX=%016\" PRIx64 \"\\n\"\n\n                    \"RSI=%016\" PRIx64 \" RDI=%016\" PRIx64 \" RBP=%016\" PRIx64 \" RSP=%016\" PRIx64 \"\\n\"\n\n                    \"R8 =%016\" PRIx64 \" R9 =%016\" PRIx64 \" R10=%016\" PRIx64 \" R11=%016\" PRIx64 \"\\n\"\n\n                    \"R12=%016\" PRIx64 \" R13=%016\" PRIx64 \" R14=%016\" PRIx64 \" R15=%016\" PRIx64 \"\\n\"\n\n                    \"RIP=%016\" PRIx64 \" RFL=%08x [%c%c%c%c%c%c%c] CPL=%d II=%d A20=%d SMM=%d HLT=%d\\n\",\n\n                    env->regs[R_EAX],\n\n                    env->regs[R_EBX],\n\n                    env->regs[R_ECX],\n\n                    env->regs[R_EDX],\n\n                    env->regs[R_ESI],\n\n                    env->regs[R_EDI],\n\n                    env->regs[R_EBP],\n\n                    env->regs[R_ESP],\n\n                    env->regs[8],\n\n                    env->regs[9],\n\n                    env->regs[10],\n\n                    env->regs[11],\n\n                    env->regs[12],\n\n                    env->regs[13],\n\n                    env->regs[14],\n\n                    env->regs[15],\n\n                    env->eip, eflags,\n\n                    eflags & DF_MASK ? 'D' : '-',\n\n                    eflags & CC_O ? 'O' : '-',\n\n                    eflags & CC_S ? 'S' : '-',\n\n                    eflags & CC_Z ? 'Z' : '-',\n\n                    eflags & CC_A ? 'A' : '-',\n\n                    eflags & CC_P ? 'P' : '-',\n\n                    eflags & CC_C ? 'C' : '-',\n\n                    env->hflags & HF_CPL_MASK,\n\n                    (env->hflags >> HF_INHIBIT_IRQ_SHIFT) & 1,\n\n                    (int)(env->a20_mask >> 20) & 1,\n\n                    (env->hflags >> HF_SMM_SHIFT) & 1,\n\n                    env->halted);\n\n    } else\n\n#endif\n\n    {\n\n        cpu_fprintf(f, \"EAX=%08x EBX=%08x ECX=%08x EDX=%08x\\n\"\n\n                    \"ESI=%08x EDI=%08x EBP=%08x ESP=%08x\\n\"\n\n                    \"EIP=%08x EFL=%08x [%c%c%c%c%c%c%c] CPL=%d II=%d A20=%d SMM=%d HLT=%d\\n\",\n\n                    (uint32_t)env->regs[R_EAX],\n\n                    (uint32_t)env->regs[R_EBX],\n\n                    (uint32_t)env->regs[R_ECX],\n\n                    (uint32_t)env->regs[R_EDX],\n\n                    (uint32_t)env->regs[R_ESI],\n\n                    (uint32_t)env->regs[R_EDI],\n\n                    (uint32_t)env->regs[R_EBP],\n\n                    (uint32_t)env->regs[R_ESP],\n\n                    (uint32_t)env->eip, eflags,\n\n                    eflags & DF_MASK ? 'D' : '-',\n\n                    eflags & CC_O ? 'O' : '-',\n\n                    eflags & CC_S ? 'S' : '-',\n\n                    eflags & CC_Z ? 'Z' : '-',\n\n                    eflags & CC_A ? 'A' : '-',\n\n                    eflags & CC_P ? 'P' : '-',\n\n                    eflags & CC_C ? 'C' : '-',\n\n                    env->hflags & HF_CPL_MASK,\n\n                    (env->hflags >> HF_INHIBIT_IRQ_SHIFT) & 1,\n\n                    (int)(env->a20_mask >> 20) & 1,\n\n                    (env->hflags >> HF_SMM_SHIFT) & 1,\n\n                    env->halted);\n\n    }\n\n\n\n    for(i = 0; i < 6; i++) {\n\n        cpu_x86_dump_seg_cache(env, f, cpu_fprintf, seg_name[i],\n\n                               &env->segs[i]);\n\n    }\n\n    cpu_x86_dump_seg_cache(env, f, cpu_fprintf, \"LDT\", &env->ldt);\n\n    cpu_x86_dump_seg_cache(env, f, cpu_fprintf, \"TR\", &env->tr);\n\n\n\n#ifdef TARGET_X86_64\n\n    if (env->hflags & HF_LMA_MASK) {\n\n        cpu_fprintf(f, \"GDT=     %016\" PRIx64 \" %08x\\n\",\n\n                    env->gdt.base, env->gdt.limit);\n\n        cpu_fprintf(f, \"IDT=     %016\" PRIx64 \" %08x\\n\",\n\n                    env->idt.base, env->idt.limit);\n\n        cpu_fprintf(f, \"CR0=%08x CR2=%016\" PRIx64 \" CR3=%016\" PRIx64 \" CR4=%08x\\n\",\n\n                    (uint32_t)env->cr[0],\n\n                    env->cr[2],\n\n                    env->cr[3],\n\n                    (uint32_t)env->cr[4]);\n\n        for(i = 0; i < 4; i++)\n\n            cpu_fprintf(f, \"DR%d=%016\" PRIx64 \" \", i, env->dr[i]);\n\n        cpu_fprintf(f, \"\\nDR6=%016\" PRIx64 \" DR7=%016\" PRIx64 \"\\n\",\n\n                    env->dr[6], env->dr[7]);\n\n    } else\n\n#endif\n\n    {\n\n        cpu_fprintf(f, \"GDT=     %08x %08x\\n\",\n\n                    (uint32_t)env->gdt.base, env->gdt.limit);\n\n        cpu_fprintf(f, \"IDT=     %08x %08x\\n\",\n\n                    (uint32_t)env->idt.base, env->idt.limit);\n\n        cpu_fprintf(f, \"CR0=%08x CR2=%08x CR3=%08x CR4=%08x\\n\",\n\n                    (uint32_t)env->cr[0],\n\n                    (uint32_t)env->cr[2],\n\n                    (uint32_t)env->cr[3],\n\n                    (uint32_t)env->cr[4]);\n\n        for(i = 0; i < 4; i++)\n\n            cpu_fprintf(f, \"DR%d=%08x \", i, env->dr[i]);\n\n        cpu_fprintf(f, \"\\nDR6=%08x DR7=%08x\\n\", env->dr[6], env->dr[7]);\n\n    }\n\n    if (flags & X86_DUMP_CCOP) {\n\n        if ((unsigned)env->cc_op < CC_OP_NB)\n\n            snprintf(cc_op_name, sizeof(cc_op_name), \"%s\", cc_op_str[env->cc_op]);\n\n        else\n\n            snprintf(cc_op_name, sizeof(cc_op_name), \"[%d]\", env->cc_op);\n\n#ifdef TARGET_X86_64\n\n        if (env->hflags & HF_CS64_MASK) {\n\n            cpu_fprintf(f, \"CCS=%016\" PRIx64 \" CCD=%016\" PRIx64 \" CCO=%-8s\\n\",\n\n                        env->cc_src, env->cc_dst,\n\n                        cc_op_name);\n\n        } else\n\n#endif\n\n        {\n\n            cpu_fprintf(f, \"CCS=%08x CCD=%08x CCO=%-8s\\n\",\n\n                        (uint32_t)env->cc_src, (uint32_t)env->cc_dst,\n\n                        cc_op_name);\n\n        }\n\n    }\n\n    if (flags & X86_DUMP_FPU) {\n\n        int fptag;\n\n        fptag = 0;\n\n        for(i = 0; i < 8; i++) {\n\n            fptag |= ((!env->fptags[i]) << i);\n\n        }\n\n        cpu_fprintf(f, \"FCW=%04x FSW=%04x [ST=%d] FTW=%02x MXCSR=%08x\\n\",\n\n                    env->fpuc,\n\n                    (env->fpus & ~0x3800) | (env->fpstt & 0x7) << 11,\n\n                    env->fpstt,\n\n                    fptag,\n\n                    env->mxcsr);\n\n        for(i=0;i<8;i++) {\n\n#if defined(USE_X86LDOUBLE)\n\n            union {\n\n                long double d;\n\n                struct {\n\n                    uint64_t lower;\n\n                    uint16_t upper;\n\n                } l;\n\n            } tmp;\n\n            tmp.d = env->fpregs[i].d;\n\n            cpu_fprintf(f, \"FPR%d=%016\" PRIx64 \" %04x\",\n\n                        i, tmp.l.lower, tmp.l.upper);\n\n#else\n\n            cpu_fprintf(f, \"FPR%d=%016\" PRIx64,\n\n                        i, env->fpregs[i].mmx.q);\n\n#endif\n\n            if ((i & 1) == 1)\n\n                cpu_fprintf(f, \"\\n\");\n\n            else\n\n                cpu_fprintf(f, \" \");\n\n        }\n\n        if (env->hflags & HF_CS64_MASK)\n\n            nb = 16;\n\n        else\n\n            nb = 8;\n\n        for(i=0;i<nb;i++) {\n\n            cpu_fprintf(f, \"XMM%02d=%08x%08x%08x%08x\",\n\n                        i,\n\n                        env->xmm_regs[i].XMM_L(3),\n\n                        env->xmm_regs[i].XMM_L(2),\n\n                        env->xmm_regs[i].XMM_L(1),\n\n                        env->xmm_regs[i].XMM_L(0));\n\n            if ((i & 1) == 1)\n\n                cpu_fprintf(f, \"\\n\");\n\n            else\n\n                cpu_fprintf(f, \" \");\n\n        }\n\n    }\n\n}\n", "idx": 27264}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "net_checksum_add_iov(const struct iovec *iov, const unsigned int iov_cnt,\n\n                     uint32_t iov_off, uint32_t size)\n\n{\n\n    size_t iovec_off, buf_off;\n\n    unsigned int i;\n\n    uint32_t res = 0;\n\n    uint32_t seq = 0;\n\n\n\n    iovec_off = 0;\n\n    buf_off = 0;\n\n    for (i = 0; i < iov_cnt && size; i++) {\n\n        if (iov_off < (iovec_off + iov[i].iov_len)) {\n\n            size_t len = MIN((iovec_off + iov[i].iov_len) - iov_off , size);\n\n            void *chunk_buf = iov[i].iov_base + (iov_off - iovec_off);\n\n\n\n            res += net_checksum_add_cont(len, chunk_buf, seq);\n\n            seq += len;\n\n\n\n            buf_off += len;\n\n            iov_off += len;\n\n            size -= len;\n\n        }\n\n        iovec_off += iov[i].iov_len;\n\n    }\n\n    return res;\n\n}\n", "idx": 27265}
{"project": "qemu", "commit_id": "04088adbe0c5adca66adb6022723362ad90ed0fc", "target": 0, "func": "static void *mpc8544_load_device_tree(target_phys_addr_t addr,\n\n                                     uint32_t ramsize,\n\n                                     target_phys_addr_t initrd_base,\n\n                                     target_phys_addr_t initrd_size,\n\n                                     const char *kernel_cmdline)\n\n{\n\n    void *fdt = NULL;\n\n#ifdef CONFIG_FDT\n\n    uint32_t mem_reg_property[] = {0, ramsize};\n\n    char *filename;\n\n    int fdt_size;\n\n    int ret;\n\n\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, BINARY_DEVICE_TREE_FILE);\n\n    if (!filename) {\n\n        goto out;\n\n    }\n\n    fdt = load_device_tree(filename, &fdt_size);\n\n    qemu_free(filename);\n\n    if (fdt == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    /* Manipulate device tree in memory. */\n\n    ret = qemu_devtree_setprop(fdt, \"/memory\", \"reg\", mem_reg_property,\n\n                               sizeof(mem_reg_property));\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /memory/reg\\n\");\n\n\n\n    ret = qemu_devtree_setprop_cell(fdt, \"/chosen\", \"linux,initrd-start\",\n\n                                    initrd_base);\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /chosen/linux,initrd-start\\n\");\n\n\n\n    ret = qemu_devtree_setprop_cell(fdt, \"/chosen\", \"linux,initrd-end\",\n\n                                    (initrd_base + initrd_size));\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /chosen/linux,initrd-end\\n\");\n\n\n\n    ret = qemu_devtree_setprop_string(fdt, \"/chosen\", \"bootargs\",\n\n                                      kernel_cmdline);\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /chosen/bootargs\\n\");\n\n\n\n    if (kvm_enabled()) {\n\n        struct dirent *dirp;\n\n        DIR *dp;\n\n        char buf[128];\n\n\n\n        if ((dp = opendir(\"/proc/device-tree/cpus/\")) == NULL) {\n\n            printf(\"Can't open directory /proc/device-tree/cpus/\\n\");\n\n            goto out;\n\n        }\n\n\n\n        buf[0] = '\\0';\n\n        while ((dirp = readdir(dp)) != NULL) {\n\n            if (strncmp(dirp->d_name, \"PowerPC\", 7) == 0) {\n\n                snprintf(buf, 128, \"/cpus/%s\", dirp->d_name);\n\n                break;\n\n            }\n\n        }\n\n        closedir(dp);\n\n        if (buf[0] == '\\0') {\n\n            printf(\"Unknow host!\\n\");\n\n            goto out;\n\n        }\n\n\n\n        mpc8544_copy_soc_cell(fdt, buf, \"clock-frequency\");\n\n        mpc8544_copy_soc_cell(fdt, buf, \"timebase-frequency\");\n\n    }\n\n\n\n    cpu_physical_memory_write (addr, (void *)fdt, fdt_size);\n\n\n\nout:\n\n#endif\n\n\n\n    return fdt;\n\n}\n", "idx": 27266}
{"project": "qemu", "commit_id": "54bf36ed351c526cde0c853079f9ff1ab7e2ff89", "target": 0, "func": "static inline int get_phys_addr(CPUARMState *env, target_ulong address,\n\n                                int access_type, int is_user,\n\n                                hwaddr *phys_ptr, int *prot,\n\n                                target_ulong *page_size)\n\n{\n\n    /* This is not entirely correct as get_phys_addr() can also be called\n\n     * from ats_write() for an address translation of a specific regime.\n\n     */\n\n    uint32_t sctlr = A32_BANKED_CURRENT_REG_GET(env, sctlr);\n\n\n\n    /* Fast Context Switch Extension.  */\n\n    if (address < 0x02000000)\n\n        address += env->cp15.c13_fcse;\n\n\n\n    if ((sctlr & SCTLR_M) == 0) {\n\n        /* MMU/MPU disabled.  */\n\n        *phys_ptr = address;\n\n        *prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n        *page_size = TARGET_PAGE_SIZE;\n\n        return 0;\n\n    } else if (arm_feature(env, ARM_FEATURE_MPU)) {\n\n        *page_size = TARGET_PAGE_SIZE;\n\n\treturn get_phys_addr_mpu(env, address, access_type, is_user, phys_ptr,\n\n\t\t\t\t prot);\n\n    } else if (extended_addresses_enabled(env)) {\n\n        return get_phys_addr_lpae(env, address, access_type, is_user, phys_ptr,\n\n                                  prot, page_size);\n\n    } else if (sctlr & SCTLR_XP) {\n\n        return get_phys_addr_v6(env, address, access_type, is_user, phys_ptr,\n\n                                prot, page_size);\n\n    } else {\n\n        return get_phys_addr_v5(env, address, access_type, is_user, phys_ptr,\n\n                                prot, page_size);\n\n    }\n\n}\n", "idx": 27267}
{"project": "qemu", "commit_id": "1960966d1b57628f730b66fe33cd2005846092e0", "target": 0, "func": "DriveInfo *drive_init(QemuOpts *opts, int default_to_scsi, int *fatal_error)\n\n{\n\n    const char *buf;\n\n    const char *file = NULL;\n\n    char devname[128];\n\n    const char *serial;\n\n    const char *mediastr = \"\";\n\n    BlockInterfaceType type;\n\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n\n    int bus_id, unit_id;\n\n    int cyls, heads, secs, translation;\n\n    BlockDriver *drv = NULL;\n\n    int max_devs;\n\n    int index;\n\n    int ro = 0;\n\n    int bdrv_flags = 0;\n\n    int on_read_error, on_write_error;\n\n    const char *devaddr;\n\n    DriveInfo *dinfo;\n\n    int snapshot = 0;\n\n    int ret;\n\n\n\n    *fatal_error = 1;\n\n\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\n\n    if (default_to_scsi) {\n\n        type = IF_SCSI;\n\n        max_devs = MAX_SCSI_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"scsi\");\n\n    } else {\n\n        type = IF_IDE;\n\n        max_devs = MAX_IDE_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"ide\");\n\n    }\n\n    media = MEDIA_DISK;\n\n\n\n    /* extract parameters */\n\n    bus_id  = qemu_opt_get_number(opts, \"bus\", 0);\n\n    unit_id = qemu_opt_get_number(opts, \"unit\", -1);\n\n    index   = qemu_opt_get_number(opts, \"index\", -1);\n\n\n\n    cyls  = qemu_opt_get_number(opts, \"cyls\", 0);\n\n    heads = qemu_opt_get_number(opts, \"heads\", 0);\n\n    secs  = qemu_opt_get_number(opts, \"secs\", 0);\n\n\n\n    snapshot = qemu_opt_get_bool(opts, \"snapshot\", 0);\n\n    ro = qemu_opt_get_bool(opts, \"readonly\", 0);\n\n\n\n    file = qemu_opt_get(opts, \"file\");\n\n    serial = qemu_opt_get(opts, \"serial\");\n\n\n\n    if ((buf = qemu_opt_get(opts, \"if\")) != NULL) {\n\n        pstrcpy(devname, sizeof(devname), buf);\n\n        if (!strcmp(buf, \"ide\")) {\n\n\t    type = IF_IDE;\n\n            max_devs = MAX_IDE_DEVS;\n\n        } else if (!strcmp(buf, \"scsi\")) {\n\n\t    type = IF_SCSI;\n\n            max_devs = MAX_SCSI_DEVS;\n\n        } else if (!strcmp(buf, \"floppy\")) {\n\n\t    type = IF_FLOPPY;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"pflash\")) {\n\n\t    type = IF_PFLASH;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"mtd\")) {\n\n\t    type = IF_MTD;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"sd\")) {\n\n\t    type = IF_SD;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"virtio\")) {\n\n            type = IF_VIRTIO;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"xen\")) {\n\n\t    type = IF_XEN;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"none\")) {\n\n\t    type = IF_NONE;\n\n            max_devs = 0;\n\n\t} else {\n\n            error_report(\"unsupported bus type '%s'\", buf);\n\n            return NULL;\n\n\t}\n\n    }\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1 || (type == IF_IDE && cyls > 16383)) {\n\n            error_report(\"invalid physical cyls number\");\n\n\t    return NULL;\n\n\t}\n\n        if (heads < 1 || (type == IF_IDE && heads > 16)) {\n\n            error_report(\"invalid physical heads number\");\n\n\t    return NULL;\n\n\t}\n\n        if (secs < 1 || (type == IF_IDE && secs > 63)) {\n\n            error_report(\"invalid physical secs number\");\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"trans\")) != NULL) {\n\n        if (!cyls) {\n\n            error_report(\"'%s' trans must be used with cyls,heads and secs\",\n\n                         buf);\n\n            return NULL;\n\n        }\n\n        if (!strcmp(buf, \"none\"))\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        else if (!strcmp(buf, \"lba\"))\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        else if (!strcmp(buf, \"auto\"))\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\telse {\n\n            error_report(\"'%s' invalid translation type\", buf);\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"media\")) != NULL) {\n\n        if (!strcmp(buf, \"disk\")) {\n\n\t    media = MEDIA_DISK;\n\n\t} else if (!strcmp(buf, \"cdrom\")) {\n\n            if (cyls || secs || heads) {\n\n                error_report(\"'%s' invalid physical CHS format\", buf);\n\n\t        return NULL;\n\n            }\n\n\t    media = MEDIA_CDROM;\n\n\t} else {\n\n\t    error_report(\"'%s' invalid media\", buf);\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"cache\")) != NULL) {\n\n        if (!strcmp(buf, \"off\") || !strcmp(buf, \"none\")) {\n\n            bdrv_flags |= BDRV_O_NOCACHE;\n\n        } else if (!strcmp(buf, \"writeback\")) {\n\n            bdrv_flags |= BDRV_O_CACHE_WB;\n\n        } else if (!strcmp(buf, \"unsafe\")) {\n\n            bdrv_flags |= BDRV_O_CACHE_WB;\n\n            bdrv_flags |= BDRV_O_NO_FLUSH;\n\n        } else if (!strcmp(buf, \"writethrough\")) {\n\n            /* this is the default */\n\n        } else {\n\n           error_report(\"invalid cache option\");\n\n           return NULL;\n\n        }\n\n    }\n\n\n\n#ifdef CONFIG_LINUX_AIO\n\n    if ((buf = qemu_opt_get(opts, \"aio\")) != NULL) {\n\n        if (!strcmp(buf, \"native\")) {\n\n            bdrv_flags |= BDRV_O_NATIVE_AIO;\n\n        } else if (!strcmp(buf, \"threads\")) {\n\n            /* this is the default */\n\n        } else {\n\n           error_report(\"invalid aio option\");\n\n           return NULL;\n\n        }\n\n    }\n\n#endif\n\n\n\n    if ((buf = qemu_opt_get(opts, \"format\")) != NULL) {\n\n       if (strcmp(buf, \"?\") == 0) {\n\n           error_printf(\"Supported formats:\");\n\n           bdrv_iterate_format(bdrv_format_print, NULL);\n\n           error_printf(\"\\n\");\n\n           return NULL;\n\n        }\n\n        drv = bdrv_find_whitelisted_format(buf);\n\n        if (!drv) {\n\n            error_report(\"'%s' invalid format\", buf);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    on_write_error = BLOCK_ERR_STOP_ENOSPC;\n\n    if ((buf = qemu_opt_get(opts, \"werror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO && type != IF_NONE) {\n\n            error_report(\"werror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_write_error = parse_block_error_action(buf, 0);\n\n        if (on_write_error < 0) {\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    on_read_error = BLOCK_ERR_REPORT;\n\n    if ((buf = qemu_opt_get(opts, \"rerror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_VIRTIO && type != IF_SCSI && type != IF_NONE) {\n\n            error_report(\"rerror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_read_error = parse_block_error_action(buf, 1);\n\n        if (on_read_error < 0) {\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if ((devaddr = qemu_opt_get(opts, \"addr\")) != NULL) {\n\n        if (type != IF_VIRTIO) {\n\n            error_report(\"addr is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* compute bus and unit according index */\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            error_report(\"index cannot be used with bus and unit\");\n\n            return NULL;\n\n        }\n\n        if (max_devs == 0)\n\n        {\n\n            unit_id = index;\n\n            bus_id = 0;\n\n        } else {\n\n            unit_id = index % max_devs;\n\n            bus_id = index / max_devs;\n\n        }\n\n    }\n\n\n\n    /* if user doesn't specify a unit_id,\n\n     * try to find the first free\n\n     */\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get(type, bus_id, unit_id) != NULL) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    /* check unit id */\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        error_report(\"unit %d too big (max is %d)\",\n\n                     unit_id, max_devs - 1);\n\n        return NULL;\n\n    }\n\n\n\n    /*\n\n     * ignore multiple definitions\n\n     */\n\n\n\n    if (drive_get(type, bus_id, unit_id) != NULL) {\n\n        *fatal_error = 0;\n\n        return NULL;\n\n    }\n\n\n\n    /* init */\n\n\n\n    dinfo = qemu_mallocz(sizeof(*dinfo));\n\n    if ((buf = qemu_opts_id(opts)) != NULL) {\n\n        dinfo->id = qemu_strdup(buf);\n\n    } else {\n\n        /* no id supplied -> create one */\n\n        dinfo->id = qemu_mallocz(32);\n\n        if (type == IF_IDE || type == IF_SCSI)\n\n            mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n        if (max_devs)\n\n            snprintf(dinfo->id, 32, \"%s%i%s%i\",\n\n                     devname, bus_id, mediastr, unit_id);\n\n        else\n\n            snprintf(dinfo->id, 32, \"%s%s%i\",\n\n                     devname, mediastr, unit_id);\n\n    }\n\n    dinfo->bdrv = bdrv_new(dinfo->id);\n\n    dinfo->devaddr = devaddr;\n\n    dinfo->type = type;\n\n    dinfo->bus = bus_id;\n\n    dinfo->unit = unit_id;\n\n    dinfo->opts = opts;\n\n    if (serial)\n\n        strncpy(dinfo->serial, serial, sizeof(dinfo->serial) - 1);\n\n    QTAILQ_INSERT_TAIL(&drives, dinfo, next);\n\n\n\n    bdrv_set_on_error(dinfo->bdrv, on_read_error, on_write_error);\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n    case IF_NONE:\n\n        switch(media) {\n\n\tcase MEDIA_DISK:\n\n            if (cyls != 0) {\n\n                bdrv_set_geometry_hint(dinfo->bdrv, cyls, heads, secs);\n\n                bdrv_set_translation_hint(dinfo->bdrv, translation);\n\n            }\n\n\t    break;\n\n\tcase MEDIA_CDROM:\n\n            bdrv_set_type_hint(dinfo->bdrv, BDRV_TYPE_CDROM);\n\n\t    break;\n\n\t}\n\n        break;\n\n    case IF_SD:\n\n        /* FIXME: This isn't really a floppy, but it's a reasonable\n\n           approximation.  */\n\n    case IF_FLOPPY:\n\n        bdrv_set_type_hint(dinfo->bdrv, BDRV_TYPE_FLOPPY);\n\n        break;\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n        break;\n\n    case IF_VIRTIO:\n\n        /* add virtio block device */\n\n        opts = qemu_opts_create(qemu_find_opts(\"device\"), NULL, 0);\n\n        qemu_opt_set(opts, \"driver\", \"virtio-blk-pci\");\n\n        qemu_opt_set(opts, \"drive\", dinfo->id);\n\n        if (devaddr)\n\n            qemu_opt_set(opts, \"addr\", devaddr);\n\n        break;\n\n    case IF_COUNT:\n\n        abort();\n\n    }\n\n    if (!file || !*file) {\n\n        *fatal_error = 0;\n\n        return NULL;\n\n    }\n\n    if (snapshot) {\n\n        /* always use cache=unsafe with snapshot */\n\n        bdrv_flags &= ~BDRV_O_CACHE_MASK;\n\n        bdrv_flags |= (BDRV_O_SNAPSHOT|BDRV_O_CACHE_WB|BDRV_O_NO_FLUSH);\n\n    }\n\n\n\n    if (media == MEDIA_CDROM) {\n\n        /* CDROM is fine for any interface, don't check.  */\n\n        ro = 1;\n\n    } else if (ro == 1) {\n\n        if (type != IF_SCSI && type != IF_VIRTIO && type != IF_FLOPPY && type != IF_NONE) {\n\n            error_report(\"readonly not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    bdrv_flags |= ro ? 0 : BDRV_O_RDWR;\n\n\n\n    ret = bdrv_open(dinfo->bdrv, file, bdrv_flags, drv);\n\n    if (ret < 0) {\n\n        error_report(\"could not open disk image %s: %s\",\n\n                     file, strerror(-ret));\n\n        return NULL;\n\n    }\n\n\n\n    if (bdrv_key_required(dinfo->bdrv))\n\n        autostart = 0;\n\n    *fatal_error = 0;\n\n    return dinfo;\n\n}\n", "idx": 27268}
{"project": "qemu", "commit_id": "9012a53f067a78022947e18050b145c34a3dc599", "target": 0, "func": "static void rtas_start_cpu(PowerPCCPU *cpu_, sPAPRMachineState *spapr,\n\n                           uint32_t token, uint32_t nargs,\n\n                           target_ulong args,\n\n                           uint32_t nret, target_ulong rets)\n\n{\n\n    target_ulong id, start, r3;\n\n    PowerPCCPU *cpu;\n\n\n\n    if (nargs != 3 || nret != 1) {\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    id = rtas_ld(args, 0);\n\n    start = rtas_ld(args, 1);\n\n    r3 = rtas_ld(args, 2);\n\n\n\n    cpu = spapr_find_cpu(id);\n\n    if (cpu != NULL) {\n\n        CPUState *cs = CPU(cpu);\n\n        CPUPPCState *env = &cpu->env;\n\n        PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);\n\n        Error *local_err = NULL;\n\n\n\n        if (!cs->halted) {\n\n            rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n\n            return;\n\n        }\n\n\n\n        /* This will make sure qemu state is up to date with kvm, and\n\n         * mark it dirty so our changes get flushed back before the\n\n         * new cpu enters */\n\n        kvm_cpu_synchronize_state(cs);\n\n\n\n        /* Set compatibility mode to match existing cpus */\n\n        ppc_set_compat(cpu, POWERPC_CPU(first_cpu)->compat_pvr, &local_err);\n\n        if (local_err) {\n\n            error_report_err(local_err);\n\n            rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n\n            return;\n\n        }\n\n\n\n        env->msr = (1ULL << MSR_SF) | (1ULL << MSR_ME);\n\n\n\n        /* Enable Power-saving mode Exit Cause exceptions for the new CPU */\n\n        env->spr[SPR_LPCR] |= pcc->lpcr_pm;\n\n\n\n        env->nip = start;\n\n        env->gpr[3] = r3;\n\n        cs->halted = 0;\n\n        spapr_cpu_set_endianness(cpu);\n\n        spapr_cpu_update_tb_offset(cpu);\n\n\n\n        qemu_cpu_kick(cs);\n\n\n\n        rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n        return;\n\n    }\n\n\n\n    /* Didn't find a matching cpu */\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n", "idx": 27269}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_in_struct(TestInputVisitorData *data,\n\n                                   const void *unused)\n\n{\n\n    TestStruct *p = NULL;\n\n    Visitor *v;\n\n\n\n    v = visitor_input_test_init(data, \"{ 'integer': -42, 'boolean': true, 'string': 'foo' }\");\n\n\n\n    visit_type_TestStruct(v, NULL, &p, &error_abort);\n\n    g_assert_cmpint(p->integer, ==, -42);\n\n    g_assert(p->boolean == true);\n\n    g_assert_cmpstr(p->string, ==, \"foo\");\n\n\n\n    g_free(p->string);\n\n    g_free(p);\n\n}\n", "idx": 27270}
{"project": "qemu", "commit_id": "393a98924eb00df76231384b86652e1d5f964d67", "target": 0, "func": "static int msix_add_config(struct PCIDevice *pdev, unsigned short nentries,\n\n                           unsigned bar_nr, unsigned bar_size)\n\n{\n\n    int config_offset;\n\n    uint8_t *config;\n\n    uint32_t new_size;\n\n\n\n    if (nentries < 1 || nentries > PCI_MSIX_FLAGS_QSIZE + 1)\n\n        return -EINVAL;\n\n    if (bar_size > 0x80000000)\n\n        return -ENOSPC;\n\n\n\n    /* Add space for MSI-X structures */\n\n    if (!bar_size) {\n\n        new_size = MSIX_PAGE_SIZE;\n\n    } else if (bar_size < MSIX_PAGE_SIZE) {\n\n        bar_size = MSIX_PAGE_SIZE;\n\n        new_size = MSIX_PAGE_SIZE * 2;\n\n    } else {\n\n        new_size = bar_size * 2;\n\n    }\n\n\n\n    pdev->msix_bar_size = new_size;\n\n    config_offset = pci_add_capability(pdev, PCI_CAP_ID_MSIX,\n\n                                       0, MSIX_CAP_LENGTH);\n\n    if (config_offset < 0)\n\n        return config_offset;\n\n    config = pdev->config + config_offset;\n\n\n\n    pci_set_word(config + PCI_MSIX_FLAGS, nentries - 1);\n\n    /* Table on top of BAR */\n\n    pci_set_long(config + PCI_MSIX_TABLE, bar_size | bar_nr);\n\n    /* Pending bits on top of that */\n\n    pci_set_long(config + PCI_MSIX_PBA, (bar_size + MSIX_PAGE_PENDING) |\n\n                 bar_nr);\n\n    pdev->msix_cap = config_offset;\n\n    /* Make flags bit writable. */\n\n    pdev->wmask[config_offset + MSIX_CONTROL_OFFSET] |= MSIX_ENABLE_MASK |\n\n\t    MSIX_MASKALL_MASK;\n\n    pdev->msix_function_masked = true;\n\n    return 0;\n\n}\n", "idx": 27271}
{"project": "qemu", "commit_id": "2f4d0f5990ede025720e41fa473029e9ca85e8b8", "target": 0, "func": "void qmp_memsave(int64_t addr, int64_t size, const char *filename,\n\n                 bool has_cpu, int64_t cpu_index, Error **errp)\n\n{\n\n    FILE *f;\n\n    uint32_t l;\n\n    CPUState *cpu;\n\n    uint8_t buf[1024];\n\n\n\n    if (!has_cpu) {\n\n        cpu_index = 0;\n\n    }\n\n\n\n    cpu = qemu_get_cpu(cpu_index);\n\n    if (cpu == NULL) {\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE, \"cpu-index\",\n\n                  \"a CPU number\");\n\n        return;\n\n    }\n\n\n\n    f = fopen(filename, \"wb\");\n\n    if (!f) {\n\n        error_setg_file_open(errp, errno, filename);\n\n        return;\n\n    }\n\n\n\n    while (size != 0) {\n\n        l = sizeof(buf);\n\n        if (l > size)\n\n            l = size;\n\n        cpu_memory_rw_debug(cpu, addr, buf, l, 0);\n\n        if (fwrite(buf, 1, l, f) != l) {\n\n            error_set(errp, QERR_IO_ERROR);\n\n            goto exit;\n\n        }\n\n        addr += l;\n\n        size -= l;\n\n    }\n\n\n\nexit:\n\n    fclose(f);\n\n}\n", "idx": 27273}
{"project": "qemu", "commit_id": "4098d49db549e20a2d87ca3cced28ace6e5864bf", "target": 0, "func": "static void xen_platform_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->init = xen_platform_initfn;\n\n    k->vendor_id = PCI_VENDOR_ID_XEN;\n\n    k->device_id = PCI_DEVICE_ID_XEN_PLATFORM;\n\n    k->class_id = PCI_CLASS_OTHERS << 8 | 0x80;\n\n    k->subsystem_vendor_id = PCI_VENDOR_ID_XEN;\n\n    k->subsystem_id = PCI_DEVICE_ID_XEN_PLATFORM;\n\n    k->revision = 1;\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    dc->desc = \"XEN platform pci device\";\n\n    dc->reset = platform_reset;\n\n    dc->vmsd = &vmstate_xen_platform;\n\n}\n", "idx": 27274}
{"project": "qemu", "commit_id": "ad196a9d0c14f681f010bb4b979030ec125ba976", "target": 0, "func": "void net_slirp_redir(Monitor *mon, const char *redir_str, const char *redir_opt2)\n\n{\n\n    struct slirp_config_str *config;\n\n\n\n    if (!slirp_inited) {\n\n        if (mon) {\n\n            monitor_printf(mon, \"user mode network stack not in use\\n\");\n\n        } else {\n\n            config = qemu_malloc(sizeof(*config));\n\n            config->str = redir_str;\n\n            config->next = slirp_redirs;\n\n            slirp_redirs = config;\n\n        }\n\n        return;\n\n    }\n\n\n\n    if (!strcmp(redir_str, \"remove\")) {\n\n        net_slirp_redir_rm(mon, redir_opt2);\n\n        return;\n\n    }\n\n\n\n    slirp_redirection(mon, redir_str);\n\n}\n", "idx": 27275}
{"project": "qemu", "commit_id": "a6152b52bc50c5cf1cd118a74b483dd3f0748ebd", "target": 0, "func": "int ppc_hash64_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr,\n\n                                int rwx, int mmu_idx)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUPPCState *env = &cpu->env;\n\n    ppc_slb_t *slb;\n\n    unsigned apshift;\n\n    hwaddr ptex;\n\n    ppc_hash_pte64_t pte;\n\n    int pp_prot, amr_prot, prot;\n\n    uint64_t new_pte1, dsisr;\n\n    const int need_prot[] = {PAGE_READ, PAGE_WRITE, PAGE_EXEC};\n\n    hwaddr raddr;\n\n\n\n    assert((rwx == 0) || (rwx == 1) || (rwx == 2));\n\n\n\n    /* Note on LPCR usage: 970 uses HID4, but our special variant\n\n     * of store_spr copies relevant fields into env->spr[SPR_LPCR].\n\n     * Similarily we filter unimplemented bits when storing into\n\n     * LPCR depending on the MMU version. This code can thus just\n\n     * use the LPCR \"as-is\".\n\n     */\n\n\n\n    /* 1. Handle real mode accesses */\n\n    if (((rwx == 2) && (msr_ir == 0)) || ((rwx != 2) && (msr_dr == 0))) {\n\n        /* Translation is supposedly \"off\"  */\n\n        /* In real mode the top 4 effective address bits are (mostly) ignored */\n\n        raddr = eaddr & 0x0FFFFFFFFFFFFFFFULL;\n\n\n\n        /* In HV mode, add HRMOR if top EA bit is clear */\n\n        if (msr_hv || !env->has_hv_mode) {\n\n            if (!(eaddr >> 63)) {\n\n                raddr |= env->spr[SPR_HRMOR];\n\n            }\n\n        } else {\n\n            /* Otherwise, check VPM for RMA vs VRMA */\n\n            if (env->spr[SPR_LPCR] & LPCR_VPM0) {\n\n                slb = &env->vrma_slb;\n\n                if (slb->sps) {\n\n                    goto skip_slb_search;\n\n                }\n\n                /* Not much else to do here */\n\n                cs->exception_index = POWERPC_EXCP_MCHECK;\n\n                env->error_code = 0;\n\n                return 1;\n\n            } else if (raddr < env->rmls) {\n\n                /* RMA. Check bounds in RMLS */\n\n                raddr |= env->spr[SPR_RMOR];\n\n            } else {\n\n                /* The access failed, generate the approriate interrupt */\n\n                if (rwx == 2) {\n\n                    ppc_hash64_set_isi(cs, env, 0x08000000);\n\n                } else {\n\n                    dsisr = 0x08000000;\n\n                    if (rwx == 1) {\n\n                        dsisr |= 0x02000000;\n\n                    }\n\n                    ppc_hash64_set_dsi(cs, env, eaddr, dsisr);\n\n                }\n\n                return 1;\n\n            }\n\n        }\n\n        tlb_set_page(cs, eaddr & TARGET_PAGE_MASK, raddr & TARGET_PAGE_MASK,\n\n                     PAGE_READ | PAGE_WRITE | PAGE_EXEC, mmu_idx,\n\n                     TARGET_PAGE_SIZE);\n\n        return 0;\n\n    }\n\n\n\n    /* 2. Translation is on, so look up the SLB */\n\n    slb = slb_lookup(cpu, eaddr);\n\n    if (!slb) {\n\n        /* No entry found, check if in-memory segment tables are in use */\n\n        if ((env->mmu_model & POWERPC_MMU_V3) && ppc64_use_proc_tbl(cpu)) {\n\n            /* TODO - Unsupported */\n\n            error_report(\"Segment Table Support Unimplemented\");\n\n            exit(1);\n\n        }\n\n        /* Segment still not found, generate the appropriate interrupt */\n\n        if (rwx == 2) {\n\n            cs->exception_index = POWERPC_EXCP_ISEG;\n\n            env->error_code = 0;\n\n        } else {\n\n            cs->exception_index = POWERPC_EXCP_DSEG;\n\n            env->error_code = 0;\n\n            env->spr[SPR_DAR] = eaddr;\n\n        }\n\n        return 1;\n\n    }\n\n\n\nskip_slb_search:\n\n\n\n    /* 3. Check for segment level no-execute violation */\n\n    if ((rwx == 2) && (slb->vsid & SLB_VSID_N)) {\n\n        ppc_hash64_set_isi(cs, env, 0x10000000);\n\n        return 1;\n\n    }\n\n\n\n    /* 4. Locate the PTE in the hash table */\n\n    ptex = ppc_hash64_htab_lookup(cpu, slb, eaddr, &pte, &apshift);\n\n    if (ptex == -1) {\n\n        dsisr = 0x40000000;\n\n        if (rwx == 2) {\n\n            ppc_hash64_set_isi(cs, env, dsisr);\n\n        } else {\n\n            if (rwx == 1) {\n\n                dsisr |= 0x02000000;\n\n            }\n\n            ppc_hash64_set_dsi(cs, env, eaddr, dsisr);\n\n        }\n\n        return 1;\n\n    }\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n                  \"found PTE at index %08\" HWADDR_PRIx \"\\n\", ptex);\n\n\n\n    /* 5. Check access permissions */\n\n\n\n    pp_prot = ppc_hash64_pte_prot(cpu, slb, pte);\n\n    amr_prot = ppc_hash64_amr_prot(cpu, pte);\n\n    prot = pp_prot & amr_prot;\n\n\n\n    if ((need_prot[rwx] & ~prot) != 0) {\n\n        /* Access right violation */\n\n        qemu_log_mask(CPU_LOG_MMU, \"PTE access rejected\\n\");\n\n        if (rwx == 2) {\n\n            ppc_hash64_set_isi(cs, env, 0x08000000);\n\n        } else {\n\n            dsisr = 0;\n\n            if (need_prot[rwx] & ~pp_prot) {\n\n                dsisr |= 0x08000000;\n\n            }\n\n            if (rwx == 1) {\n\n                dsisr |= 0x02000000;\n\n            }\n\n            if (need_prot[rwx] & ~amr_prot) {\n\n                dsisr |= 0x00200000;\n\n            }\n\n            ppc_hash64_set_dsi(cs, env, eaddr, dsisr);\n\n        }\n\n        return 1;\n\n    }\n\n\n\n    qemu_log_mask(CPU_LOG_MMU, \"PTE access granted !\\n\");\n\n\n\n    /* 6. Update PTE referenced and changed bits if necessary */\n\n\n\n    new_pte1 = pte.pte1 | HPTE64_R_R; /* set referenced bit */\n\n    if (rwx == 1) {\n\n        new_pte1 |= HPTE64_R_C; /* set changed (dirty) bit */\n\n    } else {\n\n        /* Treat the page as read-only for now, so that a later write\n\n         * will pass through this function again to set the C bit */\n\n        prot &= ~PAGE_WRITE;\n\n    }\n\n\n\n    if (new_pte1 != pte.pte1) {\n\n        ppc_hash64_store_hpte(cpu, ptex, pte.pte0, new_pte1);\n\n    }\n\n\n\n    /* 7. Determine the real address from the PTE */\n\n\n\n    raddr = deposit64(pte.pte1 & HPTE64_R_RPN, 0, apshift, eaddr);\n\n\n\n    tlb_set_page(cs, eaddr & TARGET_PAGE_MASK, raddr & TARGET_PAGE_MASK,\n\n                 prot, mmu_idx, 1ULL << apshift);\n\n\n\n    return 0;\n\n}\n", "idx": 27276}
{"project": "qemu", "commit_id": "62112d181ca33fea976100c4335dfc3e2f727e6c", "target": 0, "func": "int net_init_slirp(QemuOpts *opts,\n\n                   Monitor *mon,\n\n                   const char *name,\n\n                   VLANState *vlan)\n\n{\n\n    struct slirp_config_str *config;\n\n    const char *vhost;\n\n    const char *vhostname;\n\n    const char *vdhcp_start;\n\n    const char *vnamesrv;\n\n    const char *tftp_export;\n\n    const char *bootfile;\n\n    const char *smb_export;\n\n    const char *vsmbsrv;\n\n    char *vnet = NULL;\n\n    int restricted = 0;\n\n    int ret;\n\n\n\n    vhost       = qemu_opt_get(opts, \"host\");\n\n    vhostname   = qemu_opt_get(opts, \"hostname\");\n\n    vdhcp_start = qemu_opt_get(opts, \"dhcpstart\");\n\n    vnamesrv    = qemu_opt_get(opts, \"dns\");\n\n    tftp_export = qemu_opt_get(opts, \"tftp\");\n\n    bootfile    = qemu_opt_get(opts, \"bootfile\");\n\n    smb_export  = qemu_opt_get(opts, \"smb\");\n\n    vsmbsrv     = qemu_opt_get(opts, \"smbserver\");\n\n\n\n    if (qemu_opt_get(opts, \"ip\")) {\n\n        const char *ip = qemu_opt_get(opts, \"ip\");\n\n        int l = strlen(ip) + strlen(\"/24\") + 1;\n\n\n\n        vnet = qemu_malloc(l);\n\n\n\n        /* emulate legacy ip= parameter */\n\n        pstrcpy(vnet, l, ip);\n\n        pstrcat(vnet, l, \"/24\");\n\n    }\n\n\n\n    if (qemu_opt_get(opts, \"net\")) {\n\n        if (vnet) {\n\n            qemu_free(vnet);\n\n        }\n\n        vnet = qemu_strdup(qemu_opt_get(opts, \"net\"));\n\n    }\n\n\n\n    if (qemu_opt_get(opts, \"restrict\") &&\n\n        qemu_opt_get(opts, \"restrict\")[0] == 'y') {\n\n        restricted = 1;\n\n    }\n\n\n\n    qemu_opt_foreach(opts, net_init_slirp_configs, NULL, 0);\n\n\n\n    ret = net_slirp_init(vlan, \"user\", name, restricted, vnet, vhost,\n\n                         vhostname, tftp_export, bootfile, vdhcp_start,\n\n                         vnamesrv, smb_export, vsmbsrv);\n\n\n\n    while (slirp_configs) {\n\n        config = slirp_configs;\n\n        slirp_configs = config->next;\n\n        qemu_free(config);\n\n    }\n\n\n\n    if (ret != -1 && vlan) {\n\n        vlan->nb_host_devs++;\n\n    }\n\n\n\n    qemu_free(vnet);\n\n\n\n    return ret;\n\n}\n", "idx": 27277}
{"project": "qemu", "commit_id": "30ca440eec9fe1d7eec5a48addac656438778278", "target": 0, "func": "static QOSState *qvirtio_9p_start(void)\n\n{\n\n    const char *cmd = \"-fsdev local,id=fsdev0,security_model=none,path=%s \"\n\n                      \"-device virtio-9p-pci,fsdev=fsdev0,mount_tag=%s\";\n\n\n\n    test_share = g_strdup(\"/tmp/qtest.XXXXXX\");\n\n    g_assert_nonnull(mkdtemp(test_share));\n\n\n\n    return qtest_pc_boot(cmd, test_share, mount_tag);\n\n}\n", "idx": 27278}
{"project": "qemu", "commit_id": "6f442fe83821a06c5408056c7879e83a74f2ff32", "target": 1, "func": "static void test_read_without_media(void)\n\n{\n\n    uint8_t ret;\n\n\n\n    ret = send_read_command();\n\n    g_assert(ret == 0);\n\n}\n", "idx": 27279}
{"project": "qemu", "commit_id": "4f298a4b2957b7833bc607c951ca27c458d98d88", "target": 1, "func": "static void set_acpi_power_state(IPMIBmcSim *ibs,\n\n                          uint8_t *cmd, unsigned int cmd_len,\n\n                          uint8_t *rsp, unsigned int *rsp_len,\n\n                          unsigned int max_rsp_len)\n\n{\n\n    IPMI_CHECK_CMD_LEN(4);\n\n    ibs->acpi_power_state[0] = cmd[2];\n\n    ibs->acpi_power_state[1] = cmd[3];\n\n}\n", "idx": 27280}
{"project": "qemu", "commit_id": "cd7bc87868d534f95e928cad98e2a52df7695771", "target": 1, "func": "static void usb_uas_unrealize(USBDevice *dev, Error **errp)\n{\n    UASDevice *uas = USB_UAS(dev);\n    qemu_bh_delete(uas->status_bh);\n}", "idx": 27281}
{"project": "qemu", "commit_id": "3a661f1eabf7e8db66e28489884d9b54aacb94ea", "target": 1, "func": "int qcrypto_cipher_decrypt(QCryptoCipher *cipher,\n\n                           const void *in,\n\n                           void *out,\n\n                           size_t len,\n\n                           Error **errp)\n\n{\n\n    QCryptoCipherNettle *ctx = cipher->opaque;\n\n\n\n    switch (cipher->mode) {\n\n    case QCRYPTO_CIPHER_MODE_ECB:\n\n        ctx->alg_decrypt(ctx->ctx_decrypt ? ctx->ctx_decrypt : ctx->ctx_encrypt,\n\n                         len, out, in);\n\n        break;\n\n\n\n    case QCRYPTO_CIPHER_MODE_CBC:\n\n        cbc_decrypt(ctx->ctx_decrypt ? ctx->ctx_decrypt : ctx->ctx_encrypt,\n\n                    ctx->alg_decrypt, ctx->niv, ctx->iv,\n\n                    len, out, in);\n\n        break;\n\n    default:\n\n        error_setg(errp, \"Unsupported cipher algorithm %d\",\n\n                   cipher->alg);\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 27284}
{"project": "qemu", "commit_id": "e7c8526b2a1482a9b14319fda9f8ad4bfda5b958", "target": 1, "func": "static void ahci_migrate(AHCIQState *from, AHCIQState *to, const char *uri)\n\n{\n\n    QOSState *tmp = to->parent;\n\n    QPCIDevice *dev = to->dev;\n\n    char *uri_local = NULL;\n\n\n\n    if (uri == NULL) {\n\n        uri_local = g_strdup_printf(\"%s%s\", \"unix:\", mig_socket);\n\n        uri = uri_local;\n\n    }\n\n\n\n    /* context will be 'to' after completion. */\n\n    migrate(from->parent, to->parent, uri);\n\n\n\n    /* We'd like for the AHCIState objects to still point\n\n     * to information specific to its specific parent\n\n     * instance, but otherwise just inherit the new data. */\n\n    memcpy(to, from, sizeof(AHCIQState));\n\n    to->parent = tmp;\n\n    to->dev = dev;\n\n\n\n    tmp = from->parent;\n\n    dev = from->dev;\n\n    memset(from, 0x00, sizeof(AHCIQState));\n\n    from->parent = tmp;\n\n    from->dev = dev;\n\n\n\n    verify_state(to);\n\n    g_free(uri_local);\n\n}\n", "idx": 27285}
{"project": "qemu", "commit_id": "53510bfc1256711365cd2a841649f3ad5a79790f", "target": 1, "func": "static int kvm_virtio_pci_vq_vector_unmask(VirtIOPCIProxy *proxy,\n\n                                        unsigned int queue_no,\n\n                                        unsigned int vector,\n\n                                        MSIMessage msg)\n\n{\n\n    VirtQueue *vq = virtio_get_queue(proxy->vdev, queue_no);\n\n    EventNotifier *n = virtio_queue_get_guest_notifier(vq);\n\n    VirtIOIRQFD *irqfd = &proxy->vector_irqfd[vector];\n\n    int ret;\n\n\n\n    if (irqfd->msg.data != msg.data || irqfd->msg.address != msg.address) {\n\n        ret = kvm_irqchip_update_msi_route(kvm_state, irqfd->virq, msg);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* If guest supports masking, irqfd is already setup, unmask it.\n\n     * Otherwise, set it up now.\n\n     */\n\n    if (proxy->vdev->guest_notifier_mask) {\n\n        proxy->vdev->guest_notifier_mask(proxy->vdev, queue_no, false);\n\n        /* Test after unmasking to avoid losing events. */\n\n        if (proxy->vdev->guest_notifier_pending &&\n\n            proxy->vdev->guest_notifier_pending(proxy->vdev, queue_no)) {\n\n            event_notifier_set(n);\n\n        }\n\n    } else {\n\n        ret = kvm_virtio_pci_irqfd_use(proxy, queue_no, vector);\n\n    }\n\n    return ret;\n\n}\n", "idx": 27286}
{"project": "qemu", "commit_id": "273e4e03b3413fd489601cd9d8ba407ccb3b4130", "target": 1, "func": "static int vvfat_open(BlockDriverState *bs, const char* dirname, int flags)\n\n{\n\n    BDRVVVFATState *s = bs->opaque;\n\n    int floppy = 0;\n\n    int i;\n\n\n\n#ifdef DEBUG\n\n    vvv = s;\n\n#endif\n\n\n\nDLOG(if (stderr == NULL) {\n\n    stderr = fopen(\"vvfat.log\", \"a\");\n\n    setbuf(stderr, NULL);\n\n})\n\n\n\n    s->bs = bs;\n\n\n\n    s->fat_type=16;\n\n    /* LATER TODO: if FAT32, adjust */\n\n    s->sectors_per_cluster=0x10;\n\n    /* 504MB disk*/\n\n    bs->cyls=1024; bs->heads=16; bs->secs=63;\n\n\n\n    s->current_cluster=0xffffffff;\n\n\n\n    s->first_sectors_number=0x40;\n\n    /* read only is the default for safety */\n\n    bs->read_only = 1;\n\n    s->qcow = s->write_target = NULL;\n\n    s->qcow_filename = NULL;\n\n    s->fat2 = NULL;\n\n    s->downcase_short_names = 1;\n\n\n\n    if (!strstart(dirname, \"fat:\", NULL))\n\n\treturn -1;\n\n\n\n    if (strstr(dirname, \":floppy:\")) {\n\n\tfloppy = 1;\n\n\ts->fat_type = 12;\n\n\ts->first_sectors_number = 1;\n\n\ts->sectors_per_cluster=2;\n\n\tbs->cyls = 80; bs->heads = 2; bs->secs = 36;\n\n    }\n\n\n\n    if (strstr(dirname, \":32:\")) {\n\n\tfprintf(stderr, \"Big fat greek warning: FAT32 has not been tested. You are welcome to do so!\\n\");\n\n\ts->fat_type = 32;\n\n    } else if (strstr(dirname, \":16:\")) {\n\n\ts->fat_type = 16;\n\n    } else if (strstr(dirname, \":12:\")) {\n\n\ts->fat_type = 12;\n\n\tbs->secs = 18;\n\n    }\n\n\n\n    s->sector_count=bs->cyls*bs->heads*bs->secs-(s->first_sectors_number-1);\n\n\n\n    if (strstr(dirname, \":rw:\")) {\n\n\tif (enable_write_target(s))\n\n\t    return -1;\n\n\tbs->read_only = 0;\n\n    }\n\n\n\n    i = strrchr(dirname, ':') - dirname;\n\n    assert(i >= 3);\n\n    if (dirname[i-2] == ':' && qemu_isalpha(dirname[i-1]))\n\n\t/* workaround for DOS drive names */\n\n\tdirname += i-1;\n\n    else\n\n\tdirname += i+1;\n\n\n\n    bs->total_sectors=bs->cyls*bs->heads*bs->secs;\n\n\n\n    if(init_directories(s, dirname))\n\n\treturn -1;\n\n\n\n    s->sector_count = s->faked_sectors + s->sectors_per_cluster*s->cluster_count;\n\n\n\n    if(s->first_sectors_number==0x40)\n\n\tinit_mbr(s);\n\n\n\n    /* for some reason or other, MS-DOS does not like to know about CHS... */\n\n    if (floppy)\n\n\tbs->heads = bs->cyls = bs->secs = 0;\n\n\n\n    //    assert(is_consistent(s));\n\n    qemu_co_mutex_init(&s->lock);\n\n    return 0;\n\n}\n", "idx": 27287}
{"project": "qemu", "commit_id": "619d7ae952bb61ec27ec21fe4a383a8d4dd4cd70", "target": 1, "func": "VirtIODevice *virtio_scsi_init(DeviceState *dev, VirtIOSCSIConf *proxyconf)\n\n{\n\n    VirtIOSCSI *s;\n\n    static int virtio_scsi_id;\n\n    size_t sz;\n\n    int i;\n\n\n\n    sz = sizeof(VirtIOSCSI) + proxyconf->num_queues * sizeof(VirtQueue *);\n\n    s = (VirtIOSCSI *)virtio_common_init(\"virtio-scsi\", VIRTIO_ID_SCSI,\n\n                                         sizeof(VirtIOSCSIConfig), sz);\n\n\n\n    s->qdev = dev;\n\n    s->conf = proxyconf;\n\n\n\n    /* TODO set up vdev function pointers */\n\n    s->vdev.get_config = virtio_scsi_get_config;\n\n    s->vdev.set_config = virtio_scsi_set_config;\n\n    s->vdev.get_features = virtio_scsi_get_features;\n\n    s->vdev.reset = virtio_scsi_reset;\n\n\n\n    s->ctrl_vq = virtio_add_queue(&s->vdev, VIRTIO_SCSI_VQ_SIZE,\n\n                                   virtio_scsi_handle_ctrl);\n\n    s->event_vq = virtio_add_queue(&s->vdev, VIRTIO_SCSI_VQ_SIZE,\n\n                                   NULL);\n\n    for (i = 0; i < s->conf->num_queues; i++) {\n\n        s->cmd_vqs[i] = virtio_add_queue(&s->vdev, VIRTIO_SCSI_VQ_SIZE,\n\n                                         virtio_scsi_handle_cmd);\n\n    }\n\n\n\n    scsi_bus_new(&s->bus, dev, &virtio_scsi_scsi_info);\n\n    if (!dev->hotplugged) {\n\n        scsi_bus_legacy_handle_cmdline(&s->bus);\n\n    }\n\n\n\n    register_savevm(dev, \"virtio-scsi\", virtio_scsi_id++, 1,\n\n                    virtio_scsi_save, virtio_scsi_load, s);\n\n\n\n    return &s->vdev;\n\n}\n", "idx": 27288}
{"project": "qemu", "commit_id": "196a778428989217b82de042725dc8eb29c8f8d8", "target": 1, "func": "static void qxl_reset_surfaces(PCIQXLDevice *d)\n\n{\n\n    dprint(d, 1, \"%s:\\n\", __FUNCTION__);\n\n    d->mode = QXL_MODE_UNDEFINED;\n\n    qemu_mutex_unlock_iothread();\n\n    d->ssd.worker->destroy_surfaces(d->ssd.worker);\n\n    qemu_mutex_lock_iothread();\n\n    memset(&d->guest_surfaces.cmds, 0, sizeof(d->guest_surfaces.cmds));\n\n}\n", "idx": 27290}
{"project": "qemu", "commit_id": "0380aef323154205a7d838fb9953423621290d41", "target": 1, "func": "static void test_properties(const char *path)\n\n{\n\n    char *child_path;\n\n    QDict *response, *tuple;\n\n    QList *list;\n\n    QListEntry *entry;\n\n\n\n    g_test_message(\"Obtaining properties of %s\", path);\n\n    response = qmp(\"{ 'execute': 'qom-list',\"\n\n                   \"  'arguments': { 'path': '%s' } }\", path);\n\n    g_assert(response);\n\n\n\n    g_assert(qdict_haskey(response, \"return\"));\n\n    list = qobject_to_qlist(qdict_get(response, \"return\"));\n\n    QLIST_FOREACH_ENTRY(list, entry) {\n\n        tuple = qobject_to_qdict(qlist_entry_obj(entry));\n\n        if (strstart(qdict_get_str(tuple, \"type\"), \"child<\", NULL)) {\n\n            child_path = g_strdup_printf(\"%s/%s\",\n\n                                         path, qdict_get_str(tuple, \"name\"));\n\n            test_properties(child_path);\n\n            g_free(child_path);\n\n        } else {\n\n            const char *prop = qdict_get_str(tuple, \"name\");\n\n            g_test_message(\"Testing property %s.%s\", path, prop);\n\n            response = qmp(\"{ 'execute': 'qom-get',\"\n\n                           \"  'arguments': { 'path': '%s',\"\n\n                           \"                 'property': '%s' } }\",\n\n                           path, prop);\n\n            /* qom-get may fail but should not, e.g., segfault. */\n\n            g_assert(response);\n\n        }\n\n    }\n\n}\n", "idx": 27291}
{"project": "qemu", "commit_id": "a03ef88f77af045a2eb9629b5ce774a3fb973c5e", "target": 0, "func": "int coroutine_fn blk_co_pwritev(BlockBackend *blk, int64_t offset,\n\n                                unsigned int bytes, QEMUIOVector *qiov,\n\n                                BdrvRequestFlags flags)\n\n{\n\n    int ret;\n\n\n\n    trace_blk_co_pwritev(blk, blk_bs(blk), offset, bytes, flags);\n\n\n\n    ret = blk_check_byte_request(blk, offset, bytes);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* throttling disk I/O */\n\n    if (blk->public.throttle_state) {\n\n        throttle_group_co_io_limits_intercept(blk, bytes, true);\n\n    }\n\n\n\n    if (!blk->enable_write_cache) {\n\n        flags |= BDRV_REQ_FUA;\n\n    }\n\n\n\n    return bdrv_co_pwritev(blk_bs(blk), offset, bytes, qiov, flags);\n\n}\n", "idx": 27300}
{"project": "qemu", "commit_id": "23fabed13645fdf66473e458f318baa63be56b22", "target": 0, "func": "void monitor_protocol_event(MonitorEvent event, QObject *data)\n\n{\n\n    QDict *qmp;\n\n    const char *event_name;\n\n    Monitor *mon;\n\n\n\n    assert(event < QEVENT_MAX);\n\n\n\n    switch (event) {\n\n        case QEVENT_DEBUG:\n\n            event_name = \"DEBUG\";\n\n            break;\n\n        case QEVENT_SHUTDOWN:\n\n            event_name = \"SHUTDOWN\";\n\n            break;\n\n        case QEVENT_RESET:\n\n            event_name = \"RESET\";\n\n            break;\n\n        case QEVENT_POWERDOWN:\n\n            event_name = \"POWERDOWN\";\n\n            break;\n\n        case QEVENT_STOP:\n\n            event_name = \"STOP\";\n\n            break;\n\n        case QEVENT_VNC_CONNECTED:\n\n            event_name = \"VNC_CONNECTED\";\n\n            break;\n\n        case QEVENT_VNC_INITIALIZED:\n\n            event_name = \"VNC_INITIALIZED\";\n\n            break;\n\n        case QEVENT_VNC_DISCONNECTED:\n\n            event_name = \"VNC_DISCONNECTED\";\n\n            break;\n\n        default:\n\n            abort();\n\n            break;\n\n    }\n\n\n\n    qmp = qdict_new();\n\n    timestamp_put(qmp);\n\n    qdict_put(qmp, \"event\", qstring_from_str(event_name));\n\n    if (data) {\n\n        qobject_incref(data);\n\n        qdict_put_obj(qmp, \"data\", data);\n\n    }\n\n\n\n    QLIST_FOREACH(mon, &mon_list, entry) {\n\n        if (!monitor_ctrl_mode(mon))\n\n            return;\n\n\n\n        monitor_json_emitter(mon, QOBJECT(qmp));\n\n    }\n\n    QDECREF(qmp);\n\n}\n", "idx": 27301}
{"project": "qemu", "commit_id": "903585dec63ee83bd8149006e31f92ea789b38e3", "target": 0, "func": "static int ppce500_prep_device_tree(MachineState *machine,\n\n                                    PPCE500Params *params,\n\n                                    hwaddr addr,\n\n                                    hwaddr initrd_base,\n\n                                    hwaddr initrd_size)\n\n{\n\n    DeviceTreeParams *p = g_new(DeviceTreeParams, 1);\n\n    p->machine = machine;\n\n    p->params = *params;\n\n    p->addr = addr;\n\n    p->initrd_base = initrd_base;\n\n    p->initrd_size = initrd_size;\n\n\n\n    qemu_register_reset(ppce500_reset_device_tree, p);\n\n\n\n    /* Issue the device tree loader once, so that we get the size of the blob */\n\n    return ppce500_load_device_tree(machine, params, addr, initrd_base,\n\n                                    initrd_size, true);\n\n}\n", "idx": 27302}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_ioctl(BlockDriverState *bs, unsigned long int req, void *buf)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    if (drv && drv->bdrv_ioctl)\n\n        return drv->bdrv_ioctl(bs, req, buf);\n\n    return -ENOTSUP;\n\n}\n", "idx": 27303}
{"project": "qemu", "commit_id": "ac1970fbe8ad5a70174f462109ac0f6c7bf1bc43", "target": 0, "func": "void tb_invalidate_phys_addr(target_phys_addr_t addr)\n\n{\n\n    ram_addr_t ram_addr;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(addr >> TARGET_PAGE_BITS);\n\n    if (!(memory_region_is_ram(section->mr)\n\n          || (section->mr->rom_device && section->mr->readable))) {\n\n        return;\n\n    }\n\n    ram_addr = (memory_region_get_ram_addr(section->mr) & TARGET_PAGE_MASK)\n\n        + memory_region_section_addr(section, addr);\n\n    tb_invalidate_phys_page_range(ram_addr, ram_addr + 1, 0);\n\n}\n", "idx": 27304}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void scsi_generic_realize(SCSIDevice *s, Error **errp)\n\n{\n\n    int rc;\n\n    int sg_version;\n\n    struct sg_scsi_id scsiid;\n\n\n\n    if (!s->conf.bs) {\n\n        error_setg(errp, \"drive property not set\");\n\n        return;\n\n    }\n\n\n\n    if (bdrv_get_on_error(s->conf.bs, 0) != BLOCKDEV_ON_ERROR_ENOSPC) {\n\n        error_setg(errp, \"Device doesn't support drive option werror\");\n\n        return;\n\n    }\n\n    if (bdrv_get_on_error(s->conf.bs, 1) != BLOCKDEV_ON_ERROR_REPORT) {\n\n        error_setg(errp, \"Device doesn't support drive option rerror\");\n\n        return;\n\n    }\n\n\n\n    /* check we are using a driver managing SG_IO (version 3 and after */\n\n    rc = bdrv_ioctl(s->conf.bs, SG_GET_VERSION_NUM, &sg_version);\n\n    if (rc < 0) {\n\n        error_setg(errp, \"cannot get SG_IO version number: %s.  \"\n\n                         \"Is this a SCSI device?\",\n\n                         strerror(-rc));\n\n        return;\n\n    }\n\n    if (sg_version < 30000) {\n\n        error_setg(errp, \"scsi generic interface too old\");\n\n        return;\n\n    }\n\n\n\n    /* get LUN of the /dev/sg? */\n\n    if (bdrv_ioctl(s->conf.bs, SG_GET_SCSI_ID, &scsiid)) {\n\n        error_setg(errp, \"SG_GET_SCSI_ID ioctl failed\");\n\n        return;\n\n    }\n\n\n\n    /* define device state */\n\n    s->type = scsiid.scsi_type;\n\n    DPRINTF(\"device type %d\\n\", s->type);\n\n\n\n    switch (s->type) {\n\n    case TYPE_TAPE:\n\n        s->blocksize = get_stream_blocksize(s->conf.bs);\n\n        if (s->blocksize == -1) {\n\n            s->blocksize = 0;\n\n        }\n\n        break;\n\n\n\n        /* Make a guess for block devices, we'll fix it when the guest sends.\n\n         * READ CAPACITY.  If they don't, they likely would assume these sizes\n\n         * anyway. (TODO: they could also send MODE SENSE).\n\n         */\n\n    case TYPE_ROM:\n\n    case TYPE_WORM:\n\n        s->blocksize = 2048;\n\n        break;\n\n    default:\n\n        s->blocksize = 512;\n\n        break;\n\n    }\n\n\n\n    DPRINTF(\"block size %d\\n\", s->blocksize);\n\n}\n", "idx": 27305}
{"project": "qemu", "commit_id": "3aa80988430f41847e1b78d165440ac03503b6d0", "target": 0, "func": "static void dec_load(DisasContext *dc)\n\n{\n\n    TCGv t, *addr;\n\n    unsigned int size;\n\n\n\n    size = 1 << (dc->opcode & 3);\n\n\n\n    LOG_DIS(\"l %x %d\\n\", dc->opcode, size);\n\n    t_sync_flags(dc);\n\n    addr = compute_ldst_addr(dc, &t);\n\n\n\n    /* If we get a fault on a dslot, the jmpstate better be in sync.  */\n\n    sync_jmpstate(dc);\n\n\n\n    /* Verify alignment if needed.  */\n\n    if ((dc->env->pvr.regs[2] & PVR2_UNALIGNED_EXC_MASK) && size > 1) {\n\n        gen_helper_memalign(*addr, tcg_const_tl(dc->rd),\n\n                            tcg_const_tl(0), tcg_const_tl(size));\n\n    }\n\n\n\n    if (dc->rd) {\n\n        gen_load(dc, cpu_R[dc->rd], *addr, size);\n\n    } else {\n\n        gen_load(dc, env_imm, *addr, size);\n\n    }\n\n\n\n    if (addr == &t)\n\n        tcg_temp_free(t);\n\n}\n", "idx": 27307}
{"project": "qemu", "commit_id": "920557971b60e53c2f3f22e5d6c620ab1ed411fd", "target": 0, "func": "void ich9_lpc_pm_init(PCIDevice *lpc_pci, bool smm_enabled)\n\n{\n\n    ICH9LPCState *lpc = ICH9_LPC_DEVICE(lpc_pci);\n\n    qemu_irq sci_irq;\n\n\n\n    sci_irq = qemu_allocate_irq(ich9_set_sci, lpc, 0);\n\n    ich9_pm_init(lpc_pci, &lpc->pm, smm_enabled, sci_irq);\n\n    ich9_lpc_reset(&lpc->d.qdev);\n\n}\n", "idx": 27308}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint64_t helper_fctiw (uint64_t arg)\n\n{\n\n    CPU_DoubleU farg;\n\n    farg.ll = arg;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg.d))) {\n\n        /* sNaN conversion */\n\n        farg.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN | POWERPC_EXCP_FP_VXCVI);\n\n    } else if (unlikely(float64_is_nan(farg.d) || float64_is_infinity(farg.d))) {\n\n        /* qNan / infinity conversion */\n\n        farg.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXCVI);\n\n    } else {\n\n        farg.ll = float64_to_int32(farg.d, &env->fp_status);\n\n#if USE_PRECISE_EMULATION\n\n        /* XXX: higher bits are not supposed to be significant.\n\n         *     to make tests easier, return the same as a real PowerPC 750\n\n         */\n\n        farg.ll |= 0xFFF80000ULL << 32;\n\n#endif\n\n    }\n\n    return farg.ll;\n\n}\n", "idx": 27309}
{"project": "qemu", "commit_id": "347a5c73bafd1b5872c9d3192a4d08f8aa1d5f5a", "target": 0, "func": "static int ppc_hash64_pte_prot(PowerPCCPU *cpu,\n\n                               ppc_slb_t *slb, ppc_hash_pte64_t pte)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    unsigned pp, key;\n\n    /* Some pp bit combinations have undefined behaviour, so default\n\n     * to no access in those cases */\n\n    int prot = 0;\n\n\n\n    key = !!(msr_pr ? (slb->vsid & SLB_VSID_KP)\n\n             : (slb->vsid & SLB_VSID_KS));\n\n    pp = (pte.pte1 & HPTE64_R_PP) | ((pte.pte1 & HPTE64_R_PP0) >> 61);\n\n\n\n    if (key == 0) {\n\n        switch (pp) {\n\n        case 0x0:\n\n        case 0x1:\n\n        case 0x2:\n\n            prot = PAGE_READ | PAGE_WRITE;\n\n            break;\n\n\n\n        case 0x3:\n\n        case 0x6:\n\n            prot = PAGE_READ;\n\n            break;\n\n        }\n\n    } else {\n\n        switch (pp) {\n\n        case 0x0:\n\n        case 0x6:\n\n            prot = 0;\n\n            break;\n\n\n\n        case 0x1:\n\n        case 0x3:\n\n            prot = PAGE_READ;\n\n            break;\n\n\n\n        case 0x2:\n\n            prot = PAGE_READ | PAGE_WRITE;\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* No execute if either noexec or guarded bits set */\n\n    if (!(pte.pte1 & HPTE64_R_N) || (pte.pte1 & HPTE64_R_G)\n\n        || (slb->vsid & SLB_VSID_N)) {\n\n        prot |= PAGE_EXEC;\n\n    }\n\n\n\n    return prot;\n\n}\n", "idx": 27310}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static struct omap_mcbsp_s *omap_mcbsp_init(MemoryRegion *system_memory,\n\n                                            target_phys_addr_t base,\n\n                                            qemu_irq txirq, qemu_irq rxirq,\n\n                                            qemu_irq *dma, omap_clk clk)\n\n{\n\n    struct omap_mcbsp_s *s = (struct omap_mcbsp_s *)\n\n            g_malloc0(sizeof(struct omap_mcbsp_s));\n\n\n\n    s->txirq = txirq;\n\n    s->rxirq = rxirq;\n\n    s->txdrq = dma[0];\n\n    s->rxdrq = dma[1];\n\n    s->sink_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_sink_tick, s);\n\n    s->source_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_source_tick, s);\n\n    omap_mcbsp_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_mcbsp_ops, s, \"omap-mcbsp\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 27311}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void exynos4210_mct_write(void *opaque, target_phys_addr_t offset,\n\n        uint64_t value, unsigned size)\n\n{\n\n    Exynos4210MCTState *s = (Exynos4210MCTState *)opaque;\n\n    int index;  /* index in buffer which represents register set */\n\n    int shift;\n\n    int lt_i;\n\n    uint64_t new_frc;\n\n    uint32_t i;\n\n    uint32_t old_val;\n\n#ifdef DEBUG_MCT\n\n    static uint32_t icntb_max[2] = {0};\n\n    static uint32_t icntb_min[2] = {UINT32_MAX, UINT32_MAX};\n\n    static uint32_t tcntb_max[2] = {0};\n\n    static uint32_t tcntb_min[2] = {UINT32_MAX, UINT32_MAX};\n\n#endif\n\n\n\n    new_frc = s->g_timer.reg.cnt;\n\n\n\n    switch (offset) {\n\n\n\n    case MCT_CFG:\n\n        s->reg_mct_cfg = value;\n\n        exynos4210_mct_update_freq(s);\n\n        break;\n\n\n\n    case G_CNT_L:\n\n    case G_CNT_U:\n\n        if (offset == G_CNT_L) {\n\n\n\n            DPRINTF(\"global timer write to reg.cntl %llx\\n\", value);\n\n\n\n            new_frc = (s->g_timer.reg.cnt & (uint64_t)UINT32_MAX << 32) + value;\n\n            s->g_timer.reg.cnt_wstat |= G_CNT_WSTAT_L;\n\n        }\n\n        if (offset == G_CNT_U) {\n\n\n\n            DPRINTF(\"global timer write to reg.cntu %llx\\n\", value);\n\n\n\n            new_frc = (s->g_timer.reg.cnt & UINT32_MAX) +\n\n                    ((uint64_t)value << 32);\n\n            s->g_timer.reg.cnt_wstat |= G_CNT_WSTAT_U;\n\n        }\n\n\n\n        s->g_timer.reg.cnt = new_frc;\n\n        exynos4210_gfrc_restart(s);\n\n        break;\n\n\n\n    case G_CNT_WSTAT:\n\n        s->g_timer.reg.cnt_wstat &= ~(value);\n\n        break;\n\n\n\n    case G_COMP_L(0): case G_COMP_L(1): case G_COMP_L(2): case G_COMP_L(3):\n\n    case G_COMP_U(0): case G_COMP_U(1): case G_COMP_U(2): case G_COMP_U(3):\n\n    index = GET_G_COMP_IDX(offset);\n\n    shift = 8 * (offset & 0x4);\n\n    s->g_timer.reg.comp[index] =\n\n            (s->g_timer.reg.comp[index] &\n\n            (((uint64_t)UINT32_MAX << 32) >> shift)) +\n\n            (value << shift);\n\n\n\n    DPRINTF(\"comparator %d write 0x%llx val << %d\\n\", index, value, shift);\n\n\n\n    if (offset&0x4) {\n\n        s->g_timer.reg.wstat |= G_WSTAT_COMP_U(index);\n\n    } else {\n\n        s->g_timer.reg.wstat |= G_WSTAT_COMP_L(index);\n\n    }\n\n\n\n    exynos4210_gfrc_restart(s);\n\n    break;\n\n\n\n    case G_TCON:\n\n        old_val = s->g_timer.reg.tcon;\n\n        s->g_timer.reg.tcon = value;\n\n        s->g_timer.reg.wstat |= G_WSTAT_TCON_WRITE;\n\n\n\n        DPRINTF(\"global timer write to reg.g_tcon %llx\\n\", value);\n\n\n\n        /* Start FRC if transition from disabled to enabled */\n\n        if ((value & G_TCON_TIMER_ENABLE) > (old_val &\n\n                G_TCON_TIMER_ENABLE)) {\n\n            exynos4210_gfrc_start(&s->g_timer);\n\n        }\n\n        if ((value & G_TCON_TIMER_ENABLE) < (old_val &\n\n                G_TCON_TIMER_ENABLE)) {\n\n            exynos4210_gfrc_stop(&s->g_timer);\n\n        }\n\n\n\n        /* Start CMP if transition from disabled to enabled */\n\n        for (i = 0; i < MCT_GT_CMP_NUM; i++) {\n\n            if ((value & G_TCON_COMP_ENABLE(i)) != (old_val &\n\n                    G_TCON_COMP_ENABLE(i))) {\n\n                exynos4210_gfrc_restart(s);\n\n            }\n\n        }\n\n        break;\n\n\n\n    case G_INT_CSTAT:\n\n        s->g_timer.reg.int_cstat &= ~(value);\n\n        for (i = 0; i < MCT_GT_CMP_NUM; i++) {\n\n            if (value & G_INT_CSTAT_COMP(i)) {\n\n                exynos4210_gcomp_lower_irq(&s->g_timer, i);\n\n            }\n\n        }\n\n        break;\n\n\n\n    case G_INT_ENB:\n\n\n\n        /* Raise IRQ if transition from disabled to enabled and CSTAT pending */\n\n        for (i = 0; i < MCT_GT_CMP_NUM; i++) {\n\n            if ((value & G_INT_ENABLE(i)) > (s->g_timer.reg.tcon &\n\n                    G_INT_ENABLE(i))) {\n\n                if (s->g_timer.reg.int_cstat & G_INT_CSTAT_COMP(i)) {\n\n                    exynos4210_gcomp_raise_irq(&s->g_timer, i);\n\n                }\n\n            }\n\n\n\n            if ((value & G_INT_ENABLE(i)) < (s->g_timer.reg.tcon &\n\n                    G_INT_ENABLE(i))) {\n\n                exynos4210_gcomp_lower_irq(&s->g_timer, i);\n\n            }\n\n        }\n\n\n\n        DPRINTF(\"global timer INT enable %llx\\n\", value);\n\n        s->g_timer.reg.int_enb = value;\n\n        break;\n\n\n\n    case G_WSTAT:\n\n        s->g_timer.reg.wstat &= ~(value);\n\n        break;\n\n\n\n    case G_COMP0_ADD_INCR: case G_COMP1_ADD_INCR:\n\n    case G_COMP2_ADD_INCR: case G_COMP3_ADD_INCR:\n\n        index = GET_G_COMP_ADD_INCR_IDX(offset);\n\n        s->g_timer.reg.comp_add_incr[index] = value;\n\n        s->g_timer.reg.wstat |= G_WSTAT_COMP_ADDINCR(index);\n\n        break;\n\n\n\n        /* Local timers */\n\n    case L0_TCON: case L1_TCON:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n        old_val = s->l_timer[lt_i].reg.tcon;\n\n\n\n        s->l_timer[lt_i].reg.wstat |= L_WSTAT_TCON_WRITE;\n\n        s->l_timer[lt_i].reg.tcon = value;\n\n\n\n        /* Stop local CNT */\n\n        if ((value & L_TCON_TICK_START) <\n\n                (old_val & L_TCON_TICK_START)) {\n\n            DPRINTF(\"local timer[%d] stop cnt\\n\", lt_i);\n\n            exynos4210_ltick_cnt_stop(&s->l_timer[lt_i].tick_timer);\n\n        }\n\n\n\n        /* Stop local INT */\n\n        if ((value & L_TCON_INT_START) <\n\n                (old_val & L_TCON_INT_START)) {\n\n            DPRINTF(\"local timer[%d] stop int\\n\", lt_i);\n\n            exynos4210_ltick_int_stop(&s->l_timer[lt_i].tick_timer);\n\n        }\n\n\n\n        /* Start local CNT */\n\n        if ((value & L_TCON_TICK_START) >\n\n        (old_val & L_TCON_TICK_START)) {\n\n            DPRINTF(\"local timer[%d] start cnt\\n\", lt_i);\n\n            exynos4210_ltick_cnt_start(&s->l_timer[lt_i].tick_timer);\n\n        }\n\n\n\n        /* Start local INT */\n\n        if ((value & L_TCON_INT_START) >\n\n        (old_val & L_TCON_INT_START)) {\n\n            DPRINTF(\"local timer[%d] start int\\n\", lt_i);\n\n            exynos4210_ltick_int_start(&s->l_timer[lt_i].tick_timer);\n\n        }\n\n\n\n        /* Start or Stop local FRC if TCON changed */\n\n        if ((value & L_TCON_FRC_START) >\n\n        (s->l_timer[lt_i].reg.tcon & L_TCON_FRC_START)) {\n\n            DPRINTF(\"local timer[%d] start frc\\n\", lt_i);\n\n            exynos4210_lfrc_start(&s->l_timer[lt_i]);\n\n        }\n\n        if ((value & L_TCON_FRC_START) <\n\n                (s->l_timer[lt_i].reg.tcon & L_TCON_FRC_START)) {\n\n            DPRINTF(\"local timer[%d] stop frc\\n\", lt_i);\n\n            exynos4210_lfrc_stop(&s->l_timer[lt_i]);\n\n        }\n\n        break;\n\n\n\n    case L0_TCNTB: case L1_TCNTB:\n\n\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n        index = GET_L_TIMER_CNT_REG_IDX(offset, lt_i);\n\n\n\n        /*\n\n         * TCNTB is updated to internal register only after CNT expired.\n\n         * Due to this we should reload timer to nearest moment when CNT is\n\n         * expired and then in event handler update tcntb to new TCNTB value.\n\n         */\n\n        exynos4210_ltick_set_cntb(&s->l_timer[lt_i].tick_timer, value,\n\n                s->l_timer[lt_i].tick_timer.icntb);\n\n\n\n        s->l_timer[lt_i].reg.wstat |= L_WSTAT_TCNTB_WRITE;\n\n        s->l_timer[lt_i].reg.cnt[L_REG_CNT_TCNTB] = value;\n\n\n\n#ifdef DEBUG_MCT\n\n        if (tcntb_min[lt_i] > value) {\n\n            tcntb_min[lt_i] = value;\n\n        }\n\n        if (tcntb_max[lt_i] < value) {\n\n            tcntb_max[lt_i] = value;\n\n        }\n\n        DPRINTF(\"local timer[%d] TCNTB write %llx; max=%x, min=%x\\n\",\n\n                lt_i, value, tcntb_max[lt_i], tcntb_min[lt_i]);\n\n#endif\n\n        break;\n\n\n\n    case L0_ICNTB: case L1_ICNTB:\n\n\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n        index = GET_L_TIMER_CNT_REG_IDX(offset, lt_i);\n\n\n\n        s->l_timer[lt_i].reg.wstat |= L_WSTAT_ICNTB_WRITE;\n\n        s->l_timer[lt_i].reg.cnt[L_REG_CNT_ICNTB] = value &\n\n                ~L_ICNTB_MANUAL_UPDATE;\n\n\n\n        /*\n\n         * We need to avoid too small values for TCNTB*ICNTB. If not, IRQ event\n\n         * could raise too fast disallowing QEMU to execute target code.\n\n         */\n\n        if (s->l_timer[lt_i].reg.cnt[L_REG_CNT_ICNTB] *\n\n            s->l_timer[lt_i].reg.cnt[L_REG_CNT_TCNTB] < MCT_LT_CNT_LOW_LIMIT) {\n\n            if (!s->l_timer[lt_i].reg.cnt[L_REG_CNT_TCNTB]) {\n\n                s->l_timer[lt_i].reg.cnt[L_REG_CNT_ICNTB] =\n\n                        MCT_LT_CNT_LOW_LIMIT;\n\n            } else {\n\n                s->l_timer[lt_i].reg.cnt[L_REG_CNT_ICNTB] =\n\n                        MCT_LT_CNT_LOW_LIMIT /\n\n                        s->l_timer[lt_i].reg.cnt[L_REG_CNT_TCNTB];\n\n            }\n\n        }\n\n\n\n        if (value & L_ICNTB_MANUAL_UPDATE) {\n\n            exynos4210_ltick_set_cntb(&s->l_timer[lt_i].tick_timer,\n\n                    s->l_timer[lt_i].tick_timer.tcntb,\n\n                    s->l_timer[lt_i].reg.cnt[L_REG_CNT_ICNTB]);\n\n        }\n\n\n\n#ifdef DEBUG_MCT\n\n        if (icntb_min[lt_i] > value) {\n\n            icntb_min[lt_i] = value;\n\n        }\n\n        if (icntb_max[lt_i] < value) {\n\n            icntb_max[lt_i] = value;\n\n        }\n\nDPRINTF(\"local timer[%d] ICNTB write %llx; max=%x, min=%x\\n\\n\",\n\n        lt_i, value, icntb_max[lt_i], icntb_min[lt_i]);\n\n#endif\n\nbreak;\n\n\n\n    case L0_FRCNTB: case L1_FRCNTB:\n\n\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n        index = GET_L_TIMER_CNT_REG_IDX(offset, lt_i);\n\n\n\n        DPRINTF(\"local timer[%d] FRCNTB write %llx\\n\", lt_i, value);\n\n\n\n        s->l_timer[lt_i].reg.wstat |= L_WSTAT_FRCCNTB_WRITE;\n\n        s->l_timer[lt_i].reg.cnt[L_REG_CNT_FRCCNTB] = value;\n\n\n\n        break;\n\n\n\n    case L0_TCNTO: case L1_TCNTO:\n\n    case L0_ICNTO: case L1_ICNTO:\n\n    case L0_FRCNTO: case L1_FRCNTO:\n\n        fprintf(stderr, \"\\n[exynos4210.mct: write to RO register \"\n\n                TARGET_FMT_plx \"]\\n\\n\", offset);\n\n        break;\n\n\n\n    case L0_INT_CSTAT: case L1_INT_CSTAT:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n\n\n        DPRINTF(\"local timer[%d] CSTAT write %llx\\n\", lt_i, value);\n\n\n\n        s->l_timer[lt_i].reg.int_cstat &= ~value;\n\n        if (!s->l_timer[lt_i].reg.int_cstat) {\n\n            qemu_irq_lower(s->l_timer[lt_i].irq);\n\n        }\n\n        break;\n\n\n\n    case L0_INT_ENB: case L1_INT_ENB:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n        old_val = s->l_timer[lt_i].reg.int_enb;\n\n\n\n        /* Raise Local timer IRQ if cstat is pending */\n\n        if ((value & L_INT_INTENB_ICNTEIE) > (old_val & L_INT_INTENB_ICNTEIE)) {\n\n            if (s->l_timer[lt_i].reg.int_cstat & L_INT_CSTAT_INTCNT) {\n\n                qemu_irq_raise(s->l_timer[lt_i].irq);\n\n            }\n\n        }\n\n\n\n        s->l_timer[lt_i].reg.int_enb = value;\n\n\n\n        break;\n\n\n\n    case L0_WSTAT: case L1_WSTAT:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n\n\n        s->l_timer[lt_i].reg.wstat &= ~value;\n\n        break;\n\n\n\n    default:\n\n        hw_error(\"exynos4210.mct: bad write offset \"\n\n                TARGET_FMT_plx \"\\n\", offset);\n\n        break;\n\n    }\n\n}\n", "idx": 27312}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static int no_init_in (HWVoiceIn *hw, audsettings_t *as)\n\n{\n\n    audio_pcm_init_info (&hw->info, as);\n\n    hw->samples = 1024;\n\n    return 0;\n\n}\n", "idx": 27313}
{"project": "qemu", "commit_id": "f74990a5d019751c545e9800a3376b6336e77d38", "target": 0, "func": "uint32_t HELPER(stfle)(CPUS390XState *env, uint64_t addr)\n\n{\n\n    uint64_t words[MAX_STFL_WORDS];\n\n    unsigned count_m1 = env->regs[0] & 0xff;\n\n    unsigned max_m1 = do_stfle(env, words);\n\n    unsigned i;\n\n\n\n    for (i = 0; i <= count_m1; ++i) {\n\n        cpu_stq_data(env, addr + 8 * i, words[i]);\n\n    }\n\n\n\n    env->regs[0] = deposit64(env->regs[0], 0, 8, max_m1);\n\n    return (count_m1 >= max_m1 ? 0 : 3);\n\n}\n", "idx": 27314}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static void pxa2xx_fir_write(void *opaque, hwaddr addr,\n\n                             uint64_t value64, unsigned size)\n\n{\n\n    PXA2xxFIrState *s = (PXA2xxFIrState *) opaque;\n\n    uint32_t value = value64;\n\n    uint8_t ch;\n\n\n\n    switch (addr) {\n\n    case ICCR0:\n\n        s->control[0] = value;\n\n        if (!(value & (1 << 4)))\t\t\t/* RXE */\n\n            s->rx_len = s->rx_start = 0;\n\n        if (!(value & (1 << 3))) {                      /* TXE */\n\n            /* Nop */\n\n        }\n\n        s->enable = value & 1;\t\t\t\t/* ITR */\n\n        if (!s->enable)\n\n            s->status[0] = 0;\n\n        pxa2xx_fir_update(s);\n\n        break;\n\n    case ICCR1:\n\n        s->control[1] = value;\n\n        break;\n\n    case ICCR2:\n\n        s->control[2] = value & 0x3f;\n\n        pxa2xx_fir_update(s);\n\n        break;\n\n    case ICDR:\n\n        if (s->control[2] & (1 << 2)) { /* TXP */\n\n            ch = value;\n\n        } else {\n\n            ch = ~value;\n\n        }\n\n        if (s->enable && (s->control[0] & (1 << 3))) { /* TXE */\n\n            /* XXX this blocks entire thread. Rewrite to use\n\n             * qemu_chr_fe_write and background I/O callbacks */\n\n            qemu_chr_fe_write_all(&s->chr, &ch, 1);\n\n        }\n\n        break;\n\n    case ICSR0:\n\n        s->status[0] &= ~(value & 0x66);\n\n        pxa2xx_fir_update(s);\n\n        break;\n\n    case ICFOR:\n\n        break;\n\n    default:\n\n        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);\n\n    }\n\n}\n", "idx": 27315}
{"project": "qemu", "commit_id": "39fb730aed8c5f7b0058845cb9feac0d4b177985", "target": 0, "func": "static void disas_thumb_insn(CPUARMState *env, DisasContext *s)\n\n{\n\n    uint32_t val, insn, op, rm, rn, rd, shift, cond;\n\n    int32_t offset;\n\n    int i;\n\n    TCGv_i32 tmp;\n\n    TCGv_i32 tmp2;\n\n    TCGv_i32 addr;\n\n\n\n    if (s->condexec_mask) {\n\n        cond = s->condexec_cond;\n\n        if (cond != 0x0e) {     /* Skip conditional when condition is AL. */\n\n          s->condlabel = gen_new_label();\n\n          gen_test_cc(cond ^ 1, s->condlabel);\n\n          s->condjmp = 1;\n\n        }\n\n    }\n\n\n\n    insn = arm_lduw_code(env, s->pc, s->bswap_code);\n\n    s->pc += 2;\n\n\n\n    switch (insn >> 12) {\n\n    case 0: case 1:\n\n\n\n        rd = insn & 7;\n\n        op = (insn >> 11) & 3;\n\n        if (op == 3) {\n\n            /* add/subtract */\n\n            rn = (insn >> 3) & 7;\n\n            tmp = load_reg(s, rn);\n\n            if (insn & (1 << 10)) {\n\n                /* immediate */\n\n                tmp2 = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(tmp2, (insn >> 6) & 7);\n\n            } else {\n\n                /* reg */\n\n                rm = (insn >> 6) & 7;\n\n                tmp2 = load_reg(s, rm);\n\n            }\n\n            if (insn & (1 << 9)) {\n\n                if (s->condexec_mask)\n\n                    tcg_gen_sub_i32(tmp, tmp, tmp2);\n\n                else\n\n                    gen_sub_CC(tmp, tmp, tmp2);\n\n            } else {\n\n                if (s->condexec_mask)\n\n                    tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                else\n\n                    gen_add_CC(tmp, tmp, tmp2);\n\n            }\n\n            tcg_temp_free_i32(tmp2);\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            /* shift immediate */\n\n            rm = (insn >> 3) & 7;\n\n            shift = (insn >> 6) & 0x1f;\n\n            tmp = load_reg(s, rm);\n\n            gen_arm_shift_im(tmp, op, shift, s->condexec_mask == 0);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            store_reg(s, rd, tmp);\n\n        }\n\n        break;\n\n    case 2: case 3:\n\n        /* arithmetic large immediate */\n\n        op = (insn >> 11) & 3;\n\n        rd = (insn >> 8) & 0x7;\n\n        if (op == 0) { /* mov */\n\n            tmp = tcg_temp_new_i32();\n\n            tcg_gen_movi_i32(tmp, insn & 0xff);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            tmp = load_reg(s, rd);\n\n            tmp2 = tcg_temp_new_i32();\n\n            tcg_gen_movi_i32(tmp2, insn & 0xff);\n\n            switch (op) {\n\n            case 1: /* cmp */\n\n                gen_sub_CC(tmp, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp);\n\n                tcg_temp_free_i32(tmp2);\n\n                break;\n\n            case 2: /* add */\n\n                if (s->condexec_mask)\n\n                    tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                else\n\n                    gen_add_CC(tmp, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp2);\n\n                store_reg(s, rd, tmp);\n\n                break;\n\n            case 3: /* sub */\n\n                if (s->condexec_mask)\n\n                    tcg_gen_sub_i32(tmp, tmp, tmp2);\n\n                else\n\n                    gen_sub_CC(tmp, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp2);\n\n                store_reg(s, rd, tmp);\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n    case 4:\n\n        if (insn & (1 << 11)) {\n\n            rd = (insn >> 8) & 7;\n\n            /* load pc-relative.  Bit 1 of PC is ignored.  */\n\n            val = s->pc + 2 + ((insn & 0xff) * 4);\n\n            val &= ~(uint32_t)2;\n\n            addr = tcg_temp_new_i32();\n\n            tcg_gen_movi_i32(addr, val);\n\n            tmp = tcg_temp_new_i32();\n\n            gen_aa32_ld32u(tmp, addr, IS_USER(s));\n\n            tcg_temp_free_i32(addr);\n\n            store_reg(s, rd, tmp);\n\n            break;\n\n        }\n\n        if (insn & (1 << 10)) {\n\n            /* data processing extended or blx */\n\n            rd = (insn & 7) | ((insn >> 4) & 8);\n\n            rm = (insn >> 3) & 0xf;\n\n            op = (insn >> 8) & 3;\n\n            switch (op) {\n\n            case 0: /* add */\n\n                tmp = load_reg(s, rd);\n\n                tmp2 = load_reg(s, rm);\n\n                tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp2);\n\n                store_reg(s, rd, tmp);\n\n                break;\n\n            case 1: /* cmp */\n\n                tmp = load_reg(s, rd);\n\n                tmp2 = load_reg(s, rm);\n\n                gen_sub_CC(tmp, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp2);\n\n                tcg_temp_free_i32(tmp);\n\n                break;\n\n            case 2: /* mov/cpy */\n\n                tmp = load_reg(s, rm);\n\n                store_reg(s, rd, tmp);\n\n                break;\n\n            case 3:/* branch [and link] exchange thumb register */\n\n                tmp = load_reg(s, rm);\n\n                if (insn & (1 << 7)) {\n\n                    ARCH(5);\n\n                    val = (uint32_t)s->pc | 1;\n\n                    tmp2 = tcg_temp_new_i32();\n\n                    tcg_gen_movi_i32(tmp2, val);\n\n                    store_reg(s, 14, tmp2);\n\n                }\n\n                /* already thumb, no need to check */\n\n                gen_bx(s, tmp);\n\n                break;\n\n            }\n\n            break;\n\n        }\n\n\n\n        /* data processing register */\n\n        rd = insn & 7;\n\n        rm = (insn >> 3) & 7;\n\n        op = (insn >> 6) & 0xf;\n\n        if (op == 2 || op == 3 || op == 4 || op == 7) {\n\n            /* the shift/rotate ops want the operands backwards */\n\n            val = rm;\n\n            rm = rd;\n\n            rd = val;\n\n            val = 1;\n\n        } else {\n\n            val = 0;\n\n        }\n\n\n\n        if (op == 9) { /* neg */\n\n            tmp = tcg_temp_new_i32();\n\n            tcg_gen_movi_i32(tmp, 0);\n\n        } else if (op != 0xf) { /* mvn doesn't read its first operand */\n\n            tmp = load_reg(s, rd);\n\n        } else {\n\n            TCGV_UNUSED_I32(tmp);\n\n        }\n\n\n\n        tmp2 = load_reg(s, rm);\n\n        switch (op) {\n\n        case 0x0: /* and */\n\n            tcg_gen_and_i32(tmp, tmp, tmp2);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            break;\n\n        case 0x1: /* eor */\n\n            tcg_gen_xor_i32(tmp, tmp, tmp2);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            break;\n\n        case 0x2: /* lsl */\n\n            if (s->condexec_mask) {\n\n                gen_shl(tmp2, tmp2, tmp);\n\n            } else {\n\n                gen_helper_shl_cc(tmp2, cpu_env, tmp2, tmp);\n\n                gen_logic_CC(tmp2);\n\n            }\n\n            break;\n\n        case 0x3: /* lsr */\n\n            if (s->condexec_mask) {\n\n                gen_shr(tmp2, tmp2, tmp);\n\n            } else {\n\n                gen_helper_shr_cc(tmp2, cpu_env, tmp2, tmp);\n\n                gen_logic_CC(tmp2);\n\n            }\n\n            break;\n\n        case 0x4: /* asr */\n\n            if (s->condexec_mask) {\n\n                gen_sar(tmp2, tmp2, tmp);\n\n            } else {\n\n                gen_helper_sar_cc(tmp2, cpu_env, tmp2, tmp);\n\n                gen_logic_CC(tmp2);\n\n            }\n\n            break;\n\n        case 0x5: /* adc */\n\n            if (s->condexec_mask) {\n\n                gen_adc(tmp, tmp2);\n\n            } else {\n\n                gen_adc_CC(tmp, tmp, tmp2);\n\n            }\n\n            break;\n\n        case 0x6: /* sbc */\n\n            if (s->condexec_mask) {\n\n                gen_sub_carry(tmp, tmp, tmp2);\n\n            } else {\n\n                gen_sbc_CC(tmp, tmp, tmp2);\n\n            }\n\n            break;\n\n        case 0x7: /* ror */\n\n            if (s->condexec_mask) {\n\n                tcg_gen_andi_i32(tmp, tmp, 0x1f);\n\n                tcg_gen_rotr_i32(tmp2, tmp2, tmp);\n\n            } else {\n\n                gen_helper_ror_cc(tmp2, cpu_env, tmp2, tmp);\n\n                gen_logic_CC(tmp2);\n\n            }\n\n            break;\n\n        case 0x8: /* tst */\n\n            tcg_gen_and_i32(tmp, tmp, tmp2);\n\n            gen_logic_CC(tmp);\n\n            rd = 16;\n\n            break;\n\n        case 0x9: /* neg */\n\n            if (s->condexec_mask)\n\n                tcg_gen_neg_i32(tmp, tmp2);\n\n            else\n\n                gen_sub_CC(tmp, tmp, tmp2);\n\n            break;\n\n        case 0xa: /* cmp */\n\n            gen_sub_CC(tmp, tmp, tmp2);\n\n            rd = 16;\n\n            break;\n\n        case 0xb: /* cmn */\n\n            gen_add_CC(tmp, tmp, tmp2);\n\n            rd = 16;\n\n            break;\n\n        case 0xc: /* orr */\n\n            tcg_gen_or_i32(tmp, tmp, tmp2);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            break;\n\n        case 0xd: /* mul */\n\n            tcg_gen_mul_i32(tmp, tmp, tmp2);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            break;\n\n        case 0xe: /* bic */\n\n            tcg_gen_andc_i32(tmp, tmp, tmp2);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            break;\n\n        case 0xf: /* mvn */\n\n            tcg_gen_not_i32(tmp2, tmp2);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp2);\n\n            val = 1;\n\n            rm = rd;\n\n            break;\n\n        }\n\n        if (rd != 16) {\n\n            if (val) {\n\n                store_reg(s, rm, tmp2);\n\n                if (op != 0xf)\n\n                    tcg_temp_free_i32(tmp);\n\n            } else {\n\n                store_reg(s, rd, tmp);\n\n                tcg_temp_free_i32(tmp2);\n\n            }\n\n        } else {\n\n            tcg_temp_free_i32(tmp);\n\n            tcg_temp_free_i32(tmp2);\n\n        }\n\n        break;\n\n\n\n    case 5:\n\n        /* load/store register offset.  */\n\n        rd = insn & 7;\n\n        rn = (insn >> 3) & 7;\n\n        rm = (insn >> 6) & 7;\n\n        op = (insn >> 9) & 7;\n\n        addr = load_reg(s, rn);\n\n        tmp = load_reg(s, rm);\n\n        tcg_gen_add_i32(addr, addr, tmp);\n\n        tcg_temp_free_i32(tmp);\n\n\n\n        if (op < 3) { /* store */\n\n            tmp = load_reg(s, rd);\n\n        } else {\n\n            tmp = tcg_temp_new_i32();\n\n        }\n\n\n\n        switch (op) {\n\n        case 0: /* str */\n\n            gen_aa32_st32(tmp, addr, IS_USER(s));\n\n            break;\n\n        case 1: /* strh */\n\n            gen_aa32_st16(tmp, addr, IS_USER(s));\n\n            break;\n\n        case 2: /* strb */\n\n            gen_aa32_st8(tmp, addr, IS_USER(s));\n\n            break;\n\n        case 3: /* ldrsb */\n\n            gen_aa32_ld8s(tmp, addr, IS_USER(s));\n\n            break;\n\n        case 4: /* ldr */\n\n            gen_aa32_ld32u(tmp, addr, IS_USER(s));\n\n            break;\n\n        case 5: /* ldrh */\n\n            gen_aa32_ld16u(tmp, addr, IS_USER(s));\n\n            break;\n\n        case 6: /* ldrb */\n\n            gen_aa32_ld8u(tmp, addr, IS_USER(s));\n\n            break;\n\n        case 7: /* ldrsh */\n\n            gen_aa32_ld16s(tmp, addr, IS_USER(s));\n\n            break;\n\n        }\n\n        if (op >= 3) { /* load */\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            tcg_temp_free_i32(tmp);\n\n        }\n\n        tcg_temp_free_i32(addr);\n\n        break;\n\n\n\n    case 6:\n\n        /* load/store word immediate offset */\n\n        rd = insn & 7;\n\n        rn = (insn >> 3) & 7;\n\n        addr = load_reg(s, rn);\n\n        val = (insn >> 4) & 0x7c;\n\n        tcg_gen_addi_i32(addr, addr, val);\n\n\n\n        if (insn & (1 << 11)) {\n\n            /* load */\n\n            tmp = tcg_temp_new_i32();\n\n            gen_aa32_ld32u(tmp, addr, IS_USER(s));\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            /* store */\n\n            tmp = load_reg(s, rd);\n\n            gen_aa32_st32(tmp, addr, IS_USER(s));\n\n            tcg_temp_free_i32(tmp);\n\n        }\n\n        tcg_temp_free_i32(addr);\n\n        break;\n\n\n\n    case 7:\n\n        /* load/store byte immediate offset */\n\n        rd = insn & 7;\n\n        rn = (insn >> 3) & 7;\n\n        addr = load_reg(s, rn);\n\n        val = (insn >> 6) & 0x1f;\n\n        tcg_gen_addi_i32(addr, addr, val);\n\n\n\n        if (insn & (1 << 11)) {\n\n            /* load */\n\n            tmp = tcg_temp_new_i32();\n\n            gen_aa32_ld8u(tmp, addr, IS_USER(s));\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            /* store */\n\n            tmp = load_reg(s, rd);\n\n            gen_aa32_st8(tmp, addr, IS_USER(s));\n\n            tcg_temp_free_i32(tmp);\n\n        }\n\n        tcg_temp_free_i32(addr);\n\n        break;\n\n\n\n    case 8:\n\n        /* load/store halfword immediate offset */\n\n        rd = insn & 7;\n\n        rn = (insn >> 3) & 7;\n\n        addr = load_reg(s, rn);\n\n        val = (insn >> 5) & 0x3e;\n\n        tcg_gen_addi_i32(addr, addr, val);\n\n\n\n        if (insn & (1 << 11)) {\n\n            /* load */\n\n            tmp = tcg_temp_new_i32();\n\n            gen_aa32_ld16u(tmp, addr, IS_USER(s));\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            /* store */\n\n            tmp = load_reg(s, rd);\n\n            gen_aa32_st16(tmp, addr, IS_USER(s));\n\n            tcg_temp_free_i32(tmp);\n\n        }\n\n        tcg_temp_free_i32(addr);\n\n        break;\n\n\n\n    case 9:\n\n        /* load/store from stack */\n\n        rd = (insn >> 8) & 7;\n\n        addr = load_reg(s, 13);\n\n        val = (insn & 0xff) * 4;\n\n        tcg_gen_addi_i32(addr, addr, val);\n\n\n\n        if (insn & (1 << 11)) {\n\n            /* load */\n\n            tmp = tcg_temp_new_i32();\n\n            gen_aa32_ld32u(tmp, addr, IS_USER(s));\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            /* store */\n\n            tmp = load_reg(s, rd);\n\n            gen_aa32_st32(tmp, addr, IS_USER(s));\n\n            tcg_temp_free_i32(tmp);\n\n        }\n\n        tcg_temp_free_i32(addr);\n\n        break;\n\n\n\n    case 10:\n\n        /* add to high reg */\n\n        rd = (insn >> 8) & 7;\n\n        if (insn & (1 << 11)) {\n\n            /* SP */\n\n            tmp = load_reg(s, 13);\n\n        } else {\n\n            /* PC. bit 1 is ignored.  */\n\n            tmp = tcg_temp_new_i32();\n\n            tcg_gen_movi_i32(tmp, (s->pc + 2) & ~(uint32_t)2);\n\n        }\n\n        val = (insn & 0xff) * 4;\n\n        tcg_gen_addi_i32(tmp, tmp, val);\n\n        store_reg(s, rd, tmp);\n\n        break;\n\n\n\n    case 11:\n\n        /* misc */\n\n        op = (insn >> 8) & 0xf;\n\n        switch (op) {\n\n        case 0:\n\n            /* adjust stack pointer */\n\n            tmp = load_reg(s, 13);\n\n            val = (insn & 0x7f) * 4;\n\n            if (insn & (1 << 7))\n\n                val = -(int32_t)val;\n\n            tcg_gen_addi_i32(tmp, tmp, val);\n\n            store_reg(s, 13, tmp);\n\n            break;\n\n\n\n        case 2: /* sign/zero extend.  */\n\n            ARCH(6);\n\n            rd = insn & 7;\n\n            rm = (insn >> 3) & 7;\n\n            tmp = load_reg(s, rm);\n\n            switch ((insn >> 6) & 3) {\n\n            case 0: gen_sxth(tmp); break;\n\n            case 1: gen_sxtb(tmp); break;\n\n            case 2: gen_uxth(tmp); break;\n\n            case 3: gen_uxtb(tmp); break;\n\n            }\n\n            store_reg(s, rd, tmp);\n\n            break;\n\n        case 4: case 5: case 0xc: case 0xd:\n\n            /* push/pop */\n\n            addr = load_reg(s, 13);\n\n            if (insn & (1 << 8))\n\n                offset = 4;\n\n            else\n\n                offset = 0;\n\n            for (i = 0; i < 8; i++) {\n\n                if (insn & (1 << i))\n\n                    offset += 4;\n\n            }\n\n            if ((insn & (1 << 11)) == 0) {\n\n                tcg_gen_addi_i32(addr, addr, -offset);\n\n            }\n\n            for (i = 0; i < 8; i++) {\n\n                if (insn & (1 << i)) {\n\n                    if (insn & (1 << 11)) {\n\n                        /* pop */\n\n                        tmp = tcg_temp_new_i32();\n\n                        gen_aa32_ld32u(tmp, addr, IS_USER(s));\n\n                        store_reg(s, i, tmp);\n\n                    } else {\n\n                        /* push */\n\n                        tmp = load_reg(s, i);\n\n                        gen_aa32_st32(tmp, addr, IS_USER(s));\n\n                        tcg_temp_free_i32(tmp);\n\n                    }\n\n                    /* advance to the next address.  */\n\n                    tcg_gen_addi_i32(addr, addr, 4);\n\n                }\n\n            }\n\n            TCGV_UNUSED_I32(tmp);\n\n            if (insn & (1 << 8)) {\n\n                if (insn & (1 << 11)) {\n\n                    /* pop pc */\n\n                    tmp = tcg_temp_new_i32();\n\n                    gen_aa32_ld32u(tmp, addr, IS_USER(s));\n\n                    /* don't set the pc until the rest of the instruction\n\n                       has completed */\n\n                } else {\n\n                    /* push lr */\n\n                    tmp = load_reg(s, 14);\n\n                    gen_aa32_st32(tmp, addr, IS_USER(s));\n\n                    tcg_temp_free_i32(tmp);\n\n                }\n\n                tcg_gen_addi_i32(addr, addr, 4);\n\n            }\n\n            if ((insn & (1 << 11)) == 0) {\n\n                tcg_gen_addi_i32(addr, addr, -offset);\n\n            }\n\n            /* write back the new stack pointer */\n\n            store_reg(s, 13, addr);\n\n            /* set the new PC value */\n\n            if ((insn & 0x0900) == 0x0900) {\n\n                store_reg_from_load(env, s, 15, tmp);\n\n            }\n\n            break;\n\n\n\n        case 1: case 3: case 9: case 11: /* czb */\n\n            rm = insn & 7;\n\n            tmp = load_reg(s, rm);\n\n            s->condlabel = gen_new_label();\n\n            s->condjmp = 1;\n\n            if (insn & (1 << 11))\n\n                tcg_gen_brcondi_i32(TCG_COND_EQ, tmp, 0, s->condlabel);\n\n            else\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, tmp, 0, s->condlabel);\n\n            tcg_temp_free_i32(tmp);\n\n            offset = ((insn & 0xf8) >> 2) | (insn & 0x200) >> 3;\n\n            val = (uint32_t)s->pc + 2;\n\n            val += offset;\n\n            gen_jmp(s, val);\n\n            break;\n\n\n\n        case 15: /* IT, nop-hint.  */\n\n            if ((insn & 0xf) == 0) {\n\n                gen_nop_hint(s, (insn >> 4) & 0xf);\n\n                break;\n\n            }\n\n            /* If Then.  */\n\n            s->condexec_cond = (insn >> 4) & 0xe;\n\n            s->condexec_mask = insn & 0x1f;\n\n            /* No actual code generated for this insn, just setup state.  */\n\n            break;\n\n\n\n        case 0xe: /* bkpt */\n\n            ARCH(5);\n\n            gen_exception_insn(s, 2, EXCP_BKPT);\n\n            break;\n\n\n\n        case 0xa: /* rev */\n\n            ARCH(6);\n\n            rn = (insn >> 3) & 0x7;\n\n            rd = insn & 0x7;\n\n            tmp = load_reg(s, rn);\n\n            switch ((insn >> 6) & 3) {\n\n            case 0: tcg_gen_bswap32_i32(tmp, tmp); break;\n\n            case 1: gen_rev16(tmp); break;\n\n            case 3: gen_revsh(tmp); break;\n\n            default: goto illegal_op;\n\n            }\n\n            store_reg(s, rd, tmp);\n\n            break;\n\n\n\n        case 6:\n\n            switch ((insn >> 5) & 7) {\n\n            case 2:\n\n                /* setend */\n\n                ARCH(6);\n\n                if (((insn >> 3) & 1) != s->bswap_code) {\n\n                    /* Dynamic endianness switching not implemented. */\n\n                    qemu_log_mask(LOG_UNIMP, \"arm: unimplemented setend\\n\");\n\n                    goto illegal_op;\n\n                }\n\n                break;\n\n            case 3:\n\n                /* cps */\n\n                ARCH(6);\n\n                if (IS_USER(s)) {\n\n                    break;\n\n                }\n\n                if (IS_M(env)) {\n\n                    tmp = tcg_const_i32((insn & (1 << 4)) != 0);\n\n                    /* FAULTMASK */\n\n                    if (insn & 1) {\n\n                        addr = tcg_const_i32(19);\n\n                        gen_helper_v7m_msr(cpu_env, addr, tmp);\n\n                        tcg_temp_free_i32(addr);\n\n                    }\n\n                    /* PRIMASK */\n\n                    if (insn & 2) {\n\n                        addr = tcg_const_i32(16);\n\n                        gen_helper_v7m_msr(cpu_env, addr, tmp);\n\n                        tcg_temp_free_i32(addr);\n\n                    }\n\n                    tcg_temp_free_i32(tmp);\n\n                    gen_lookup_tb(s);\n\n                } else {\n\n                    if (insn & (1 << 4)) {\n\n                        shift = CPSR_A | CPSR_I | CPSR_F;\n\n                    } else {\n\n                        shift = 0;\n\n                    }\n\n                    gen_set_psr_im(s, ((insn & 7) << 6), 0, shift);\n\n                }\n\n                break;\n\n            default:\n\n                goto undef;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            goto undef;\n\n        }\n\n        break;\n\n\n\n    case 12:\n\n    {\n\n        /* load/store multiple */\n\n        TCGv_i32 loaded_var;\n\n        TCGV_UNUSED_I32(loaded_var);\n\n        rn = (insn >> 8) & 0x7;\n\n        addr = load_reg(s, rn);\n\n        for (i = 0; i < 8; i++) {\n\n            if (insn & (1 << i)) {\n\n                if (insn & (1 << 11)) {\n\n                    /* load */\n\n                    tmp = tcg_temp_new_i32();\n\n                    gen_aa32_ld32u(tmp, addr, IS_USER(s));\n\n                    if (i == rn) {\n\n                        loaded_var = tmp;\n\n                    } else {\n\n                        store_reg(s, i, tmp);\n\n                    }\n\n                } else {\n\n                    /* store */\n\n                    tmp = load_reg(s, i);\n\n                    gen_aa32_st32(tmp, addr, IS_USER(s));\n\n                    tcg_temp_free_i32(tmp);\n\n                }\n\n                /* advance to the next address */\n\n                tcg_gen_addi_i32(addr, addr, 4);\n\n            }\n\n        }\n\n        if ((insn & (1 << rn)) == 0) {\n\n            /* base reg not in list: base register writeback */\n\n            store_reg(s, rn, addr);\n\n        } else {\n\n            /* base reg in list: if load, complete it now */\n\n            if (insn & (1 << 11)) {\n\n                store_reg(s, rn, loaded_var);\n\n            }\n\n            tcg_temp_free_i32(addr);\n\n        }\n\n        break;\n\n    }\n\n    case 13:\n\n        /* conditional branch or swi */\n\n        cond = (insn >> 8) & 0xf;\n\n        if (cond == 0xe)\n\n            goto undef;\n\n\n\n        if (cond == 0xf) {\n\n            /* swi */\n\n            gen_set_pc_im(s, s->pc);\n\n            s->is_jmp = DISAS_SWI;\n\n            break;\n\n        }\n\n        /* generate a conditional jump to next instruction */\n\n        s->condlabel = gen_new_label();\n\n        gen_test_cc(cond ^ 1, s->condlabel);\n\n        s->condjmp = 1;\n\n\n\n        /* jump to the offset */\n\n        val = (uint32_t)s->pc + 2;\n\n        offset = ((int32_t)insn << 24) >> 24;\n\n        val += offset << 1;\n\n        gen_jmp(s, val);\n\n        break;\n\n\n\n    case 14:\n\n        if (insn & (1 << 11)) {\n\n            if (disas_thumb2_insn(env, s, insn))\n\n              goto undef32;\n\n            break;\n\n        }\n\n        /* unconditional branch */\n\n        val = (uint32_t)s->pc;\n\n        offset = ((int32_t)insn << 21) >> 21;\n\n        val += (offset << 1) + 2;\n\n        gen_jmp(s, val);\n\n        break;\n\n\n\n    case 15:\n\n        if (disas_thumb2_insn(env, s, insn))\n\n            goto undef32;\n\n        break;\n\n    }\n\n    return;\n\nundef32:\n\n    gen_exception_insn(s, 4, EXCP_UDEF);\n\n    return;\n\nillegal_op:\n\nundef:\n\n    gen_exception_insn(s, 2, EXCP_UDEF);\n\n}\n", "idx": 27316}
